HRESULT InvokeSetProperty( IDispatch* disp, DISPID id, VARIANT& val );
HRESULT InvokeGetProperty( IDispatch* disp, DISPID id, VARIANT& val );
HRESULT InvokeSetProperty( IDispatch* disp, LPCWSTR nm, VARIANT& val );
HRESULT InvokeGetProperty( IDispatch* disp, LPCWSTR nm, VARIANT& val );
HRESULT InvokeMethod0( IDispatch* disp, DISPID id, VARIANT& ret );
HRESULT InvokeMethod1( IDispatch* disp, DISPID id, VARIANT& ret, VARIANT& pm1 );
HRESULT InvokeMethod2( IDispatch* disp, DISPID id, VARIANT& ret, VARIANT& pm1,VARIANT& pm2 );
HRESULT InvokeMethod3( IDispatch* disp, DISPID id, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3 );
HRESULT InvokeMethod4( IDispatch* disp, DISPID id, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3,VARIANT& pm4 );
HRESULT InvokeGetDISPID( IDispatch* disp, LPCWSTR nm, DISPID& id );
HRESULT InvokeMethod0( IDispatch* disp, LPCWSTR nm, VARIANT& ret );
HRESULT InvokeMethod1( IDispatch* disp, LPCWSTR nm, VARIANT& ret, VARIANT& pm1 );
HRESULT InvokeMethod2( IDis

HRESULT InvokeMethod3( IDispatch* disp, LPCWSTR nm, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3 );
HRESULT InvokeMethod4( IDispatch* disp, LPCWSTR nm, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3,VARIANT& pm4 );
class CDispatchHelper
	public :
		CDispatchHelper( IDispatch* p ):p_(p){}
		CDispatchHelper( VARIANT& v )
		{
			_ASSERT( v.vt == VT_DISPATCH );
			p_ = v.pdispVal;
		}
		
		HRESULT Method0( DISPID id, VARIANT& ret ){ return InvokeMethod0( p_, id, ret ); }
		HRESULT Method1( DISPID id, VARIANT& ret, VARIANT& pm1 ){ return InvokeMethod1( p_, id, ret,pm1); }
		HRESULT Method2( DISPID id, VARIANT& ret, VARIANT& pm1,VARIANT& pm2 ){ return InvokeMethod2( p_, id, ret,pm1,pm2 ); }
		HRESULT Method3( DISPID id, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3 ){ return InvokeMethod3( p_, id, ret,pm1,pm2,pm3 ); }
		HRESULT Method4( DISPID id, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3,VARIANT& pm4 ){ return InvokeMethod4( p_, id, ret,pm1,pm2,pm3,pm4 ); }


		HRESULT Method1( LPCWSTR nm, VARIANT& ret, VARIANT& pm1 ){ return InvokeMethod1( p_, nm, ret,pm1 ); }
		HRESULT Method2( LPCWSTR nm, VARIANT& ret, VARIANT& pm1,VARIANT& pm2 ){ return InvokeMethod2( p_, nm, ret,pm1,pm2 ); }
		HRESULT Method3( LPCWSTR nm, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3 ){ return InvokeMethod3( p_, nm, ret,pm1,pm2,pm3 ); }
		HRESULT Method4( LPCWSTR nm, VARIANT& ret, VARIANT& pm1,VARIANT& pm2,VARIANT& pm3,VARIANT& pm4 ){ return InvokeMethod4( p_, nm, ret,pm1,pm2,pm3,pm4 ); }
		HRESULT SetProperty( DISPID id, VARIANT& val ){ return InvokeSetProperty( p_, id,val ); }
		HRESULT GetProperty( DISPID id, VARIANT& val ){ return InvokeGetProperty( p_, id,val ); }
		HRESULT SetProperty( LPCWSTR nm, VARIANT& val ){ return InvokeSetProperty( p_, nm,val ); }
		HRESULT GetProperty( LPCWSTR nm, VARIANT& val ){ return InvokeGetProperty( p_, nm,val ); }
		HRESULT GetDISPID( LPCWSTR nm, DISPID& id ){ return InvokeGetDISPID( p_, nm, id ); }
	private :
		IDispatch* 
void testMRepository(){
	MemRepository repo;
	string errors="";
	Expense e(1, 21, 92, "clothing");
	repo.add(e);
	assert(repo.size()==1);
	Expense e1(2, 23, 440, "telephone");
	repo.add(e1);
	assert(repo.size()==2);
	Expense e2(1, 2, 9, "pizza");
	try{
		repo.add(e2);
	}
	catch(RepositoryException& s)
	{
		errors+=s.getMsg();
	}
	assert(repo.size()==2);
	assert(errors!="");
	repo.update(1,e2);
	vector<Expense*> all=repo.getAll();
	assert(all.at(0)->getDay()==2);
	assert(repo.size()==2);
	Expense e3(3, 44, 29, "others");
	errors="";
	try{
		repo.update(7,e3);
	}
	catch (RepositoryException& s1)
	{
		errors+=s1.getMsg();
	}
	assert(errors!="");
	repo.remove(1);
	assert (repo.size()==1);
	errors="";
	try{
		repo.remove(7);
	}
	catch (RepositoryException& s1)
	{
		errors+=s1.getMsg();
	}
	assert(errors!="");
	assert (repo.size()==1);
	repo.add(e);
	all=repo.filterByDay(23);
	assert(all.size()==1);
	all=repo.filterByAmount(440);
	assert(all.size()==1);
	all=repo.sortByAmountA();
	assert(all
namespace content {
WebMemoryDumpProviderAdapter::WebMemoryDumpProviderAdapter(
    blink::WebMemoryDumpProvider* wmdp)
    : web_memory_dump_provider_(wmdp), is_registered_(false) {
WebMemoryDumpProviderAdapter::~WebMemoryDumpProviderAdapter() {
  DCHECK(!is_registered_);
bool WebMemoryDumpProviderAdapter::OnMemoryDump(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* pmd) {
  blink::WebMemoryDumpLevelOfDetail level;
  switch (args.level_of_detail) {
    case base::trace_event::MemoryDumpLevelOfDetail::LIGHT:
      level = blink::WebMemoryDumpLevelOfDetail::Light;
      break;
    case base::trace_event::MemoryDumpLevelOfDetail::DETAILED:
      level = blink::WebMemoryDumpLevelOfDetail::Detailed;
      break;
    default:
      NOTREACHED();
      return false;
  }
  WebProcessMemoryDumpImpl web_pmd_impl(args.level_of_detail, pmd);
  return web_memory_dump_provider_->onMemoryDump(level, &web_pmd_impl);
void WebMemoryDumpProviderAdapter::OnHe
using namespace domain;
QDataStream& SnsPacket::operator >>(QDataStream& stream) const
    stream << status;
    if (!status) return stream;
    stream << fix;
    if (fix > 1)
    {
        stream << fix2d.latitude;
        stream << fix2d.longitude;
        stream << fix2d.groundSpeed;
        stream << fix2d.yaw;
        if (fix > 2)
        {
            stream << fix3d.altitude;
            stream << fix3d.climb;
        }
    }
    return stream;
QDataStream& SnsPacket::operator <<(QDataStream& stream)
    stream >> status;
    if (!status) return stream;
    stream >> fix;
    if (fix > 1)
    {
        stream >> fix2d.latitude;
        stream >> fix2d.longitude;
        stream >> fix2d.groundSpeed;
        stream >> fix2d.yaw;
        if (fix > 2)
        {
            stream >> fix3d.altitude;
            stream >> fix3d.climb;
        }
    }
    return stream;
SnsPacket SnsPacket::fromByteArray(const QByteArray& data)
    QDataStream stream(data);
    SnsPacket packet;
    s
/**
 *  @file LB_CPU_Load_Average_Monitor.h
 *
 *  $Id$
 *
 *  @author Ossama Othman <ossama@uci.edu>
 */
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
/**
 * @class TAO_LB_CPU_Load_Average_Monitor
 *
 * @brief LoadMonitor implementation that monitors the overall CPU
 *        load on a given host.
 *
 * Loads returned from this load monitor are the average number of
 * processes in the "run" queue over a ***FIXME*** seconds averaged
 * over the number of processors.  For example, a load of 2 on a dual
 * CPU host is returned as an average load of 1 by this CPU load
 * monitor, a load of 5 on a quad CPU host will be reported as a load
 * of 1.25 (i.e. 5/4), and so on and so forth.
 */
class TAO_LoadBalancing_Export TAO_LB_CPU_Load_Average_Monitor
  : public virtual POA_CosLoadBalancing::LoadMonitor
public:
  /**
   * If no location is supplied the hostname or IP address is used by
   * default.
   */
  TAO_LB_CPU_Load_Average_Monitor (const ACE_TCHAR * location_id = 0,
                           
class Fragment_Type_Data_Chunk : public Chunk
public :
	Fragment_Type_Data_Chunk(Chunk_With_Children* parent,const char* name);
	Fragment_Type_Data_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
	~Fragment_Type_Data_Chunk();
	size_t size_chunk ();
	void fill_data_block (char * data_start);
	char* frag_type_name;
	int pad1,pad2,pad3;
};
class Fragment_Type_Shape_Chunk : public Chunk
public:	
	Fragment_Type_Shape_Chunk(Chunk_With_Children* parent,const char* _name,int number,ChunkVectorInt _location);
	Fragment_Type_Shape_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
	~Fragment_Type_Shape_Chunk();
	size_t size_chunk ();
	void fill_data_block (char * data_start);
	int num_fragments;
	ChunkVectorInt location;
	char* name;
	int pad1,pad2,pad3;	
};
class Fragment_Type_Sound_Chunk : public Chunk
public:	
	Fragment_Type_Sound_Chunk(Chunk_With_Children* parent);
	Fragment_Type_Sound_Chunk (Chunk_With_Children * const parent,const char *, size_t c
/*  Starshatter OpenSource Distribution
    Copyright (c) 1997-2004, Destroyer Studios LLC.
    All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name "Destroyer Studios" nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WA

    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
    SUBSYSTEM:    Stars
    FILE:         LoadScreen.cpp
    AUTHOR:       John DiCamillo
*/
LoadScreen::LoadScreen()
: screen(0), load_dlg(0), cmp_load_dlg(0), isShown(false)
{ }
LoadScreen::~LoadScreen()
    TearDown();
void
LoadScreen::Setup(Screen* s)
    if (!s)
    return;
    screen        = s;
    DataLoader* loader = DataLoader::GetLoader();
    loader->UseFileSystem(true);
    FormDef load_def("LoadDlg", 0);
    load_def.L

    load_dlg = new(__FILE__,__LINE__) LoadDlg(screen, load_def);
    FormDef cmp_load_def("CmpLoadDlg", 0);
    cmp_load_def.Load("CmpLoadDlg");
    cmp_load_dlg = new(__FILE__,__LINE__) CmpLoadDlg(screen, cmp_load_def);
    loader->UseFileSystem(Starshatter::UseFileSystem());
    ShowLoadDlg();
void
LoadScreen::TearDown()
    if (screen) {
        if (load_dlg)     screen->DelWindow(load_dlg);
        if (cmp_load_dlg) screen->DelWindow(cmp_load_dlg);
    }
    delete load_dlg;
    delete cmp_load_dlg;
    load_dlg       = 0;
    cmp_load_dlg   = 0;
    screen         = 0;
void
LoadScreen::ExecFrame()
    Game::SetScreenColor(Color::Black);
    if (load_dlg && load_dlg->IsShown())
    load_dlg->ExecFrame();
    if (cmp_load_dlg && cmp_load_dlg->IsShown())
    cmp_load_dlg->ExecFrame();
bool
LoadScreen::CloseTopmost()
    return false;
void
LoadScreen::Show()
    if (!isShown) {
        ShowLoadDlg();
        isShown = true;
    }
void
LoadScreen::Hide()
    if (isShown) {
        Hid
int samplesAdded = 0;
int patchSamplesAdded = 0;
static unsigned short g_PatchIterationKey = 0;
bool SampleData_CompareFunc( SampleData_t const &src1, SampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int SampleData_KeyFunc( SampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<SampleData_t> g_SampleHashTable( SAMPLEHASH_NUM_BUCKETS, 
										  SAMPLEHASH_GROW_SIZE, 
										  SAMPLEHASH_INIT_SIZE, 
										  SampleData_CompareFunc, SampleData_KeyFunc );
UtlHashHandle_t SampleData_Find( sample_t *pSample )
	SampleData_t sampleData;	
	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	return g_SampleHashTable.Find( sampleData );
UtlHashHandle_t SampleData_InsertIntoHashTable( sample_t *pSample, SampleHandle_t sampleHandle )
	Samp

	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	UtlHashHandle_t handle = g_SampleHashTable.AllocEntryFromKey( sampleData );
	SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
	pSampleData->x = sampleData.x;
	pSampleData->y = sampleData.y;
	pSampleData->z = sampleData.z;
	pSampleData->m_Samples.AddToTail( sampleHandle );
	samplesAdded++;
	return handle;
UtlHashHandle_t SampleData_AddSample( sample_t *pSample, SampleHandle_t sampleHandle )
	UtlHashHandle_t handle = SampleData_Find( pSample );
	if( handle == g_SampleHashTable.InvalidHandle() )
	{
		handle = SampleData_InsertIntoHashTable( pSample, sampleHandle );
	}
	else
	{
		SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
		pSampleData->m_Samples.AddToTail( sampleHandle );
		samplesAdded++;
	}
	return handle;
void SampleData_Log( void )
	if

	{
		g_SampleHashTable.Log( "samplehash.txt" );
	}
bool PatchSampleData_CompareFunc( PatchSampleData_t const &src1, PatchSampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int PatchSampleData_KeyFunc( PatchSampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<PatchSampleData_t>	g_PatchSampleHashTable( SAMPLEHASH_NUM_BUCKETS,
												    SAMPLEHASH_GROW_SIZE,
													SAMPLEHASH_INIT_SIZE,
													PatchSampleData_CompareFunc, PatchSampleData_KeyFunc );
void GetPatchSampleHashXYZ( const Vector &vOrigin, int &x, int &y, int &z )
	x = ( int )( vOrigin.x / SAMPLEHASH_VOXEL_SIZE );
	y = ( int )( vOrigin.y / SAMPLEHASH_VOXEL_SIZE );
	z = ( int )( vOrigin.z / SAMPLEHASH_VOXEL_SIZE );
unsigned short IncrementPatchIterationKey()
	if ( g_PatchIterationKey == 0xFFFF )
	{
		g_PatchIterationKey = 1;
		for ( int i=0; i < g_Patches.Count(); i++ )
			g_Patches[i].m_IterationKey = 0;
	}
	else
	{
	

	}
	return g_PatchIterationKey;
void PatchSampleData_AddSample( CPatch *pPatch, int ndxPatch )
	int patchSampleMins[3], patchSampleMaxs[3];
	GetPatchSampleHashXYZ( pPatch->mins, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	GetPatchSampleHashXYZ( pPatch->maxs, patchSampleMaxs[0], patchSampleMaxs[1], patchSampleMaxs[2] );
	GetPatchSampleHashXYZ( pPatch->origin, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	memcpy( patchSampleMaxs, patchSampleMins, sizeof( patchSampleMaxs ) );
	Assert( patchSampleMins[0] <= patchSampleMaxs[0] && patchSampleMins[1] <= patchSampleMaxs[1] && patchSampleMins[2] <= patchSampleMaxs[2] );
	patchSampleMins[0] = min( patchSampleMins[0], patchSampleMaxs[0] );
	patchSampleMins[1] = min( patchSampleMins[1], patchSampleMaxs[1] );
	patchSampleMins[2] = min( patchSampleMins[2], patchSampleMaxs[2] );
	int iterateCoords[3];
	for ( iterateCoords[0]=patchSampleMins[0]; iterateCoords[0] <= patchSampleMaxs[0]; iterateCoords[0]++ )
	{
		for 
Loader::Loader()
    int posX = 0;
    int posY = 0;
    int increment = 20;
    sf::Image spritesheet;
    sf::Texture loadTexture;
    spritesheet.loadFromFile("res/sprite/spritesheet.png");
    sf::SoundBuffer loadSound;
    for (int i = 0; i < spritesheet.getSize().y / 20; i++)
    {
        for (int k = 0; k < 10; k++)
        {
            loadTexture.loadFromImage(spritesheet, sf::IntRect(posX, posY, 20, 20));
            texVec.push_back(loadTexture);
            posX += increment;
        }
        posX = 0;
        posY += increment;
    }
    loadSound.loadFromFile("res/sound/hit.wav");
    sndVec.push_back(loadSound);
    loadSound.loadFromFile("res/sound/hit2.wav");
    sndVec.push_back(loadSound);
    loadSound.loadFromFile("res/sound/hit3.wav");
    sndVec.push_back(loadSound);
    loadSound.loadFromFile("res/sound/pHit.wav");
    sndVec.push_back(loadSound);
    loadSound.loadFromFile("res/sound/pHit2.wav");
    sndVec.push_back(loadSound);
    loadSound.loadFromFile("r
namespace blink {
WebMemoryDumpProviderAdapter::WebMemoryDumpProviderAdapter(
    blink::WebMemoryDumpProvider* wmdp)
    : web_memory_dump_provider_(wmdp), is_registered_(false) {
WebMemoryDumpProviderAdapter::~WebMemoryDumpProviderAdapter() {
  DCHECK(!is_registered_);
bool WebMemoryDumpProviderAdapter::OnMemoryDump(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* pmd) {
  blink::WebMemoryDumpLevelOfDetail level;
  switch (args.level_of_detail) {
    case base::trace_event::MemoryDumpLevelOfDetail::LIGHT:
      level = blink::WebMemoryDumpLevelOfDetail::Light;
      break;
    case base::trace_event::MemoryDumpLevelOfDetail::DETAILED:
      level = blink::WebMemoryDumpLevelOfDetail::Detailed;
      break;
    default:
      NOTREACHED();
      return false;
  }
  WebProcessMemoryDumpImpl web_pmd_impl(args.level_of_detail, pmd);
  return web_memory_dump_provider_->onMemoryDump(level, &web_pmd_impl);
void WebMemoryDumpProviderAdapter::OnHeap
namespace Medit
namespace MeditBase
namespace DI
ServiceLocator::ServiceLocator()
    parent = 0x0;
ServiceLocator::~ServiceLocator()
    Allocator<AbstractServiceContainer> alloc;
    for (ServiceMap::value_type item : services)
    {
        alloc.destroyAndDeallocate(item.second);
    }
bool ServiceLocator::isServiceRegistered(size_t id) const
    return services.find(id) != services.end();
ServiceLocatorAware *ServiceLocator::get(size_t id)
    if (!isServiceRegistered(id))
    {
        if (!parent)
        {
            MEDIT_THROW(ServiceLocatorException, "Service was not found",
                        ServiceLocatorException::SERVICE_NOT_FOUND);
        }
        return parent->get(id);
    }
    return services[id]->getInstance();
AbstractServiceContainer *ServiceLocator::getServiceContainer(size_t id)
    if (!isServiceRegistered(id))
    {
        if (parent)
        {
            return parent->getServiceContainer(id);
        }
        return 0x0;
    }
    return service

const AbstractServiceContainer *ServiceLocator::getServiceContainer(size_t id) const
    if (!isServiceRegistered(id))
    {
        if (parent)
        {
            return parent->getServiceContainer(id);
        }
        return 0x0;
    }
    return services.find(id)->second;
bool ServiceLocator::hasService(size_t id) const
    return isServiceRegistered(id) || (parent != 0x0 && parent->hasService(id));
void ServiceLocator::registerService(size_t id, AbstractServiceContainer *container)
    unregisterService(id);
    services[id] = container;
void ServiceLocator::unregisterService(size_t id)
    ServiceMap::iterator pos = services.find(id);
    if (pos != services.end())
    {
        services.erase(pos);
    }
ServiceLocator::ServiceMap ServiceLocator::getRegisteredServices() const
    return services;
ServiceLocator *ServiceLocator::getParent() const
    return parent;
void ServiceLocator::setParent(ServiceLocator *value)
    parent = value;
ServiceLocator::ServiceLocator(Servic
LocalFileSystem local("local");
int main(void) {
  /*
  FILE* fp;
  const char* fname = "/local/iris.csv";
  char s[100];
  int ret;
  float f1, f2, f3, f4;
  set_new_handler(no_memory);
  float* sample = new float[150 * 4];
  int* sample_label = new int[150];
  fp = fopen( fname, "r" );
  if( fp == NULL ){
    fprintf( stderr, "[%s] File cannot opne \r \n", fname );
    return 1;
  }
  int cnt = 0;
  while( ( ret = fscanf( fp, "%f,%f,%f,%f,%s", &f1, &f2, &f3, &f4, s) ) != EOF ){
    sample[cnt * 4]     = f1;
    sample[cnt * 4 + 1] = f2;
    sample[cnt * 4 + 2] = f3;
    sample[cnt * 4 + 3] = f4;
    
    if ( !strcmp(s,"Iris-setosa") ) {
      sample_label[cnt] = 0;
    } else if ( !strcmp(s,"Iris-versicolor")) {
      sample_label[cnt] = 1;
    } else if ( !strcmp(s,"Iris-virginica")) {
      sample_label[cnt] = 2;
    }
    cnt++;
  }
  MCSVM mcsvm(3, 4, 150, sample, sample_label);
  mcsvm.learning();
  float *test = new float[4];
  for (int i = 0; i < 150; i++ ) {
    test[0] = sa

    test[1] = sample[i * 4 + 1];
    test[2] = sample[i * 4 + 2];
    test[3] = sample[i * 4 + 3];
    printf("<TEST No:%d> label : %d, answer : %d \r\n", i, mcsvm.predict_label(test), sample_label[i]);
  }
  fclose( fp );
  */
  /* 簡単な例 : 2次元空間の象限 */
  float* easy_sample = new float[2 * 12];
  int* easy_sample_label = new int[12];
  easy_sample[2] = 0.5;   easy_sample[3] = 1;     easy_sample_label[1] = 0;
  easy_sample[4] = 1;     easy_sample[5] = 0.5;   easy_sample_label[2] = 0;
  easy_sample[8] = -0.5;  easy_sample[9] = 1;     easy_sample_label[4] = 1;
  easy_sample[10] = -1;   easy_sample[11] = 0.5;  easy_sample_label[5] = 1;
  easy_sample[14] = 0.5;  easy_sample[15] = -1;   easy_sample_label[7] = 2;
  easy_sample[16] = 1;    easy_sample[17] = -0.5; easy_sample_label[8] = 2;
  easy_sample[20] = -1;   easy_sample[21] = -0.5; easy_sample_label[10] = 3;
  easy_sample[22] = -1;   easy_sample[23] = -1;   easy_sample_label[11] = 3;
  MCSVM mcsvm(4, 2, 12, easy_sample, easy_sample_label)
using namespace std;
SampleCollector::SampleCollector(DatasetId datasetId, double trainingFraction) {
	for (size_t i = 0; i < SAMPLES.size(); ++i) {
		const Sample& sample = SAMPLES[i];
		if (datasetId == TRAINING) {
			if (sample.getRandomNumber() < trainingFraction) {
				dataset.push_back(&sample);
			}
		} else {
			if (sample.getRandomNumber() > trainingFraction) {
				dataset.push_back(&sample);
			}
		}
	}
SampleList SampleCollector::collectSamples(const CloudTest& cloudTest) const {
	SampleList samples;
	for (size_t i = 0; i < dataset.size(); ++i) {
		const Sample* sample = dataset[i];
		if (cloudTest.accept(*sample) && cloudTest.select(*sample)) {
			samples.push_back(sample);
		}
	}
	return samples;
static const string getenv(const string& name, const string& defaultValue) {
	const char* value = getenv(name.c_str());
	if (value == 0) {
		return defaultValue;
	}
	return string(value);
const vector<Sample>
		SampleCollector::SAMPLES =
				SampleRecordReader().AbstractDataReader
namespace Antumbra
	WorldRenderer::WorldRenderer(World &world) : m_world(world), m_shader("shaders/chunk.vert", "shaders/chunk.frag")
	{
		m_renderers.set_empty_key(nullptr);
		m_world.SetOnChunkLoaded([&](Chunk *c){ OnChunkLoaded(c); });
		m_world.SetOnChunkChanged([&](Chunk *c){ OnChunkChanged(c); });
		m_world.SetOnChunkUnloaded([&](Chunk *c){ OnChunkUnloaded(c); });
		BlockRegistry &blockReg = m_world.GetBlockRegistry();
		for(auto it = blockReg.begin(); it != blockReg.end(); ++it)
		{
			it->second->RegisterTextures(m_textureReg);
		}
		m_textureReg.BuildTexture();
	}
	void WorldRenderer::Render(const Camera &camera)
	{
		auto vp = camera.GetProjMatrix() * camera.GetViewMatrix();
		m_shader.Bind();
		m_textureReg.Bind(0);
		for(auto it = m_renderers.begin(); it != m_renderers.end(); ++it)
		{
			int chunkX, chunkZ;
			it->first->GetLocation(chunkX, chunkZ);
			m_shader.SetUniform("uniTex", 0);
			m_shader.SetUniform("uniMvp", vp * glm::translate(glm::mat4(), glm::vec3(chunkX * Chu
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla browser.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications, Inc.
 * Portions created by the Initial Developer are Copyright (C) 1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Travis Bogard <travis@netscape.com>
 *
 * Alternatively, the contents of this file may

 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Load flag for error pages. This should be bigger than all flags on
 * nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should not
 * be passed to MAKE_LO

 */
                          LOAD_FLAGS_FIRST_LOAD | \
                          LOAD_FLAGS_BYPASS_CLASSIFIER)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOA

    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOA

    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline PRBool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    case LOAD_HIST
typedef struct _stream_t stream_t;
typedef struct  
	uint32 (__fastcall *readData)(void *object, void *buffer, uint32 len);
	uint32 (__fastcall *writeData)(void *object, void *buffer, uint32 len);
	uint32 (__fastcall *getSize)(void *object);
	void (__fastcall *setSize)(void *object, uint32 size);
	uint32 (__fastcall *getSeek)(void *object);
	void (__fastcall *setSeek)(void *object, sint32 seek, bool relative);
	void (__fastcall *initStream)(void *object, stream_t *stream);
	void (__fastcall *destroyStream)(void *object, stream_t *stream);
	bool allowCaching;
}streamSettings_t;
typedef struct _stream_t
	void *object;
	streamSettings_t *settings;
	uint8 bitBuffer[8];
	uint8 bitIndex;
	uint8 bitReadBuffer[8];
	uint8 bitReadBufferState;
	uint8 bitReadIndex;
}stream_t;
stream_t*	stream_create	(streamSettings_t *settings, void *object);
void		stream_destroy	(stream_t *stream);
char stream_readS8(stream_t *stream);
short stream_readS16(stream_t *stream);
int stream_readS32(stream_t *stream);


uint16 stream_readU16(stream_t *stream);
uint32 stream_readU32(stream_t *stream);
unsigned long long stream_readU64(stream_t *stream);
float stream_readFloat(stream_t *stream);
uint32 stream_readData(stream_t *stream, void *data, int len);
void stream_writeS8(stream_t *stream, char value);
void stream_writeS16(stream_t *stream, short value);
void stream_writeS32(stream_t *stream, int value);
void stream_writeU8(stream_t *stream, uint8 value);
void stream_writeU16(stream_t *stream, uint16 value);
void stream_writeU32(stream_t *stream, uint32 value);
void stream_writeFloat(stream_t *stream, float value);
uint32 stream_writeData(stream_t *stream, void *data, int len);
void stream_setSeek(stream_t *stream, uint32 seek);
uint32 stream_getSeek(stream_t *stream);
uint32 stream_getSize(stream_t *stream);
void stream_setSize(stream_t *stream, uint32 size);
void stream_skipData(stream_t *stream, int len);
uint32 stream_copy(stream_t* dest, stream_t* source, uint32 length);
void stream_writeBits
/*================================================================================
  code generated by: java2cpp
  class: org.xml.sax.Locator
================================================================================*/
namespace j2cpp { namespace java { namespace lang { class String; } } }
namespace j2cpp { namespace java { namespace lang { class Object; } } }
namespace j2cpp {
namespace org { namespace xml { namespace sax {
	class Locator;
	class Locator
		: public object<Locator>
	{
	public:
		J2CPP_DECLARE_CLASS
		J2CPP_DECLARE_METHOD(0)
		J2CPP_DECLARE_METHOD(1)
		J2CPP_DECLARE_METHOD(2)
		J2CPP_DECLARE_METHOD(3)
		explicit Locator(jobject jobj)
		: object<Locator>(jobj)
		{
		}
		operator local_ref<java::lang::Object>() const;
		local_ref< java::lang::String > getPublicId();
		local_ref< java::lang::String > getSystemId();
		jint getLineNumber();
		jint getColumnNumber();
namespace j2cpp {
org::xml::sax::Locator::operator local_ref<java::lang::Object>() const
	return local_r

local_ref< java::lang::String > org::xml::sax::Locator::getPublicId()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(0),
		org::xml::sax::Locator::J2CPP_METHOD_SIGNATURE(0), 
		local_ref< java::lang::String >
	>(get_jobject());
local_ref< java::lang::String > org::xml::sax::Locator::getSystemId()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(1),
		org::xml::sax::Locator::J2CPP_METHOD_SIGNATURE(1), 
		local_ref< java::lang::String >
	>(get_jobject());
jint org::xml::sax::Locator::getLineNumber()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(2),
		org::xml::sax::Locator::J2CPP_METHOD_SIGNATURE(2), 
		jint
	>(get_jobject());
jint org::xml::sax::Locator::getColumnNumber()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(3),
		org::xml::sax::Loca
namespace Aiko {
  /* EventHanderList */
  void EventHandlerList::add(EventHandler* handler) {
    if (firstHandler_)
      last()->next_ = handler;
    else
      firstHandler_ = handler;
    if (!nextHandler_) nextHandler_ = handler;
    handler->next_ = 0;
  }
  void EventHandlerList::flush() {
    firstHandler_ = 0;
    nextHandler_  = 0;
  }
  EventHandler* EventHandlerList::handlerBefore(EventHandler* handler) {
    EventHandler* previousHandler = firstHandler_;
    while (previousHandler && previousHandler->next_ != handler) previousHandler = previousHandler->next_;
    return previousHandler;
  }
  EventHandler* EventHandlerList::last() {
    EventHandler* lastHandler = firstHandler_;
    while (lastHandler->next_) lastHandler = lastHandler->next_;
    return lastHandler;
  }
  
  EventHandler* EventHandlerList::next() {
    EventHandler* handler = nextHandler_;
    if (handler) nextHandler_ = handler->next_;
    return handler;
  }
  void EventHandlerList::remove(EventHandler*

    if (handler == firstHandler_)
      firstHandler_ = handler->next_;
    else
      handlerBefore(handler)->next_ = handler->next_;
    if (handler == nextHandler_) nextHandler_ = handler->next_;
    handler->next_ = 0;
  }
  void EventHandlerList::resetIterator() {
    nextHandler_ = firstHandler_;
  }
  /* EventManager */
  EventManager Events;
  void EventManager::addHandler(EventHandler* handler) {
    handlerList_.add(handler);
  }
  void EventManager::addHandler(void (*handlerFunction)(), unsigned int period, unsigned int delay) {
    EventHandler* handler = static_cast<EventHandler*>(malloc(sizeof(EventHandler)));
    handler->callback_  = functionCallback(handlerFunction);
    handler->period_    = period;
    handler->countdown_ = delay;
    addHandler(handler);
  }
  void EventManager::addOneShotHandler(void (*handlerFunction)(), unsigned int delay) {
    addHandler(handlerFunction, 0, delay);
  }
  void EventManager::loop(unsigned long time) {
    if (!isRunning_) start(
CNUBRelay::CNUBRelay(void):CStdElement()
   ID_OBJECT = ID_NUBRELAY;
   A = 1.0;
   B = 1.0;
   dX = 0.0;
   dY = 0.0;
   ElName = "Íåîäíîçíà÷íîå ðåëå";
   FNUBRelayProp = NULL;
void __fastcall CNUBRelay::SetData(void)
	FNUBRelayProp = new TFNUBRelayProp(Application);
   FNUBRelayProp->EA->Text = FloatToStr(A);
   FNUBRelayProp->EB->Text = FloatToStr(B);
   FNUBRelayProp->EdX->Text = FloatToStr(dX);
   FNUBRelayProp->EdY->Text = FloatToStr(dY);
   FNUBRelayProp->ShowModal();
   if(FNUBRelayProp->ResultOk)
   {
   	A = FNUBRelayProp->A;
   	B = FNUBRelayProp->B;
   	dX = FNUBRelayProp->dX;
   	dY = FNUBRelayProp->dY;
   }
   FNUBRelayProp->Free();
void CNUBRelay::FUNKCIJA(int index, int end, long double DT)
   long double a = fabs(A/2.0);
   long double X = real(In[index]) - dX;
   if(X > a) Out[index] = B/2.0;
   if(fabs(X) <= a)
   {
      long double OldX;
      if(index == 0) OldX = X; else OldX = real(In[index - 1]);
      if(OldX <= X) Out[index] = -B/2.0; else Out[index] = B/2.0;
int count = 0;
void f_void_1(int i)
    count += i;
struct A_void_1
    void operator()(int i)
    {
        count += i;
    }
    void mem1() {++count;}
    void mem2() const {count += 2;}
};
void
test_void_1()
    int save_count = count;
    {
    int i = 2;
    boost::detail::invoke(f_void_1, i);
    BOOST_TEST(count == save_count + 2);
    save_count = count;
    }
    {
    int i = 2;
    boost::detail::invoke<void>(f_void_1, i);
    BOOST_TEST(count == save_count + 2);
    save_count = count;
    }
    {
    void (*fp)(int) = f_void_1;
    int i = 3;
    boost::detail::invoke(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    void (*fp)(int) = f_void_1;
    int i = 3;
    boost::detail::invoke<void>(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    void (*fp)(int) = f_void_1;
    int i = 3;
    boost::detail::invoke(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    void (

    int i = 3;
    boost::detail::invoke<void>(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    A_void_1 a0;
    int i = 4;
    boost::detail::invoke(a0, i);
    BOOST_TEST(count == save_count+4);
    save_count = count;
    }
    {
    A_void_1 a0;
    int i = 4;
    boost::detail::invoke<void>(a0, i);
    BOOST_TEST(count == save_count+4);
    save_count = count;
    }
    {
    void (A_void_1::*fp)() = &A_void_1::mem1;
    A_void_1 a;
    boost::detail::invoke(fp, a);
    BOOST_TEST(count == save_count+1);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke(fp, ap);
    BOOST_TEST(count == save_count+1);
    save_count = count;
    }
    {
    void (A_void_1::*fp)() = &A_void_1::mem1;
    A_void_1 a;
    boost::detail::invoke<void>(fp, a);
    BOOST_TEST(count == save_count+1);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke<void>(fp, ap);
    BOOST_TEST(count == save_count+1);
    save_count = coun

    }
    {
    void (A_void_1::*fp)() const = &A_void_1::mem2;
    A_void_1 a;
    boost::detail::invoke(fp, a);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke(fp, ap);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    }
    {
    void (A_void_1::*fp)() const = &A_void_1::mem2;
    A_void_1 a;
    boost::detail::invoke<void>(fp, a);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke<void>(fp, ap);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    }
int f_int_1(int i)
    return i + 1;
struct A_int_1
    A_int_1() : data_(5) {}
    int operator()(int i)
    {
        return i - 1;
    }
    int mem1() {return 3;}
    int mem2() const {return 4;}
    int data_;
};
void
test_int_1()
    {
    int i = 2;
    BOOST_TEST(boost::detail::invoke(f_int_1, i) == 3);
    BOOST_TEST(boost::detail::invoke<int>(f_int_1, i) == 3);
    }
    {

    int (*fp)(int) = f_int_1;
    int i = 3;
    BOOST_TEST(boost::detail::invoke(fp, i) == 4);
    BOOST_TEST(boost::detail::invoke<int>(fp, i) == 4);
    }
    {
    int i = 4;
    BOOST_TEST(boost::detail::invoke(A_int_1(), i) == 3);
    const A_int_1 ca;
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke<int>(a, i) == 3);
    BOOST_TEST(boost::detail::invoke<int>(A_int_1(), i) == 3);
    }
    {
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem1, a) == 3);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::mem1, a) == 3);
    A_int_1* ap = &a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem1, ap) == 3);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::mem1, ap) == 3);
    }
    {
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem2, A_int_1()) == 4);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::mem2, A_int_1()) == 4);
    A_int_1* ap = &a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem2, ap) == 4);
    BOOST_TEST(boost::detail::invo

    }
    {
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, a) == 5);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, a) == 5);
    A_int_1* ap = &a;
    boost::detail::invoke(&A_int_1::data_, a) = 6;
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, a) == 6);
    boost::detail::invoke<int>(&A_int_1::data_, a) = 6;
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, a) == 6);
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, ap) == 6);
    boost::detail::invoke(&A_int_1::data_, ap) = 7;
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, ap) == 7);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, ap) == 7);
    boost::detail::invoke<int>(&A_int_1::data_, ap) = 8;
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, ap) == 8);
    }
void f_void_2(int i, int j)
    count += i+j;
struct A_void_2
    void operator()(int i, int j)
    {
        count += i+j;
    }
    void mem1(int i) {count += i;}
    void mem2(int i) const 
IMPLEMENT_DYNAMIC(CDlgFruRepoSettingPm, CDlgFruRepoSetting)
CDlgFruRepoSettingPm::CDlgFruRepoSettingPm(CWnd* pParent /*=NULL*/)
	: CDlgFruRepoSetting(CDlgFruRepoSettingPm::IDD, pParent)
	for(int i = IDC_CHECK1; i <= MAX_CHECK_ID; i++)
	{
		m_isCheckedArray.Add(0);
	}
CDlgFruRepoSettingPm::~CDlgFruRepoSettingPm()
void CDlgFruRepoSettingPm::DoDataExchange(CDataExchange* pDX)
	CDlgFruRepoSetting::DoDataExchange(pDX);
BEGIN_MESSAGE_MAP(CDlgFruRepoSettingPm, CDlgFruRepoSetting)
	ON_COMMAND_RANGE(IDC_CHECK1, MAX_CHECK_ID, OnCheckBox)
END_MESSAGE_MAP()
BOOL CDlgFruRepoSettingPm::OnInitDialog()
	CDlgFruRepoSetting::OnInitDialog();
	for(DWORD i = IDC_CHECK3; i <= MAX_CHECK_ID - 1; i++)
	{
		((CButton*)GetDlgItem(i))->SetCheck(TRUE);
		 m_isCheckedArray[i - IDC_CHECK1] = TRUE;
	}
	((CButton*)GetDlgItem(MAX_CHECK_ID))->SetCheck(FALSE);
	return TRUE;
void CDlgFruRepoSettingPm::OnCheckBox(UINT id)
	BOOL isCheck = ((CButton*)GetDlgItem(id))->GetCheck();
	m_isCheckedArray[id-IDC_CHECK1] = ((CButton*)
using namespace std;
RepoControl::RepoControl(const string &path)
    : path(path), uuid(""), udsClient(0), udsRepo(0), localRepo(0)
RepoControl::~RepoControl()
void RepoControl::open()
    try {
        udsClient = new UDSClient(path);
        udsClient->connect();
        udsRepo = new UDSRepo(udsClient);
    } catch (SystemException e) {
        if (udsRepo)
            delete udsRepo;
        udsRepo = NULL;
    }
    localRepo = new LocalRepo();
    localRepo->open(path);
    if (udsRepo)
        uuid = udsRepo->getUUID();
    else
        uuid = localRepo->getUUID();
void RepoControl::close()
    if (udsClient) {
        delete udsRepo;
        delete udsClient;
    }
    if (localRepo) {
        localRepo->close();
        delete localRepo;
    }
    udsClient = NULL;
    udsRepo = NULL;
    localRepo = NULL;
string RepoControl::getPath()
    return path;
string RepoControl::getUUID()
    ASSERT(uuid != "");
    return uuid;
string RepoControl::getHead()
    if (udsRepo)
       

    return localRepo->getHead().hex();
bool RepoControl::hasCommit(const string &objId)
    ObjectHash hash = ObjectHash::fromHex(objId);
    if (udsRepo)
        return udsRepo->hasObject(hash);
    return localRepo->hasObject(hash);
string RepoControl::pull(const string &host, const string &path)
    if (udsRepo) {
        strwstream pullReq;
        ObjectHash newHead;
        pullReq.writePStr("pull");
        pullReq.writePStr(host + ":" + path);
        strstream pullResp = udsRepo->callExt("FUSE", pullReq.str());
        if (pullResp.ended()) {
            WARNING("Unknown failure trying to pull from %s:%s",
                    host.c_str(), path.c_str());
            return "";
        }
        if (pullResp.readUInt8() == 1) {
            string error;
            pullResp.readPStr(error);
            WARNING("Failed to pull from %s:%s: %s",
                    host.c_str(), path.c_str(), error.c_str());
            return "";
        }
        pullResp.readHash(newHead);
   

        checkoutReq.writePStr("checkout");
        checkoutReq.writeHash(newHead);
        checkoutReq.writeUInt8(/* force */0);
        strstream checkoutResp = udsRepo->callExt("FUSE", checkoutReq.str());
        if (checkoutResp.ended()) {
            WARNING("Unknown failure trying to checkout %s",
                    newHead.hex().c_str());
            return "";
        }
        if (checkoutResp.readUInt8() == 0) {
            string error;
            checkoutResp.readPStr(error);
            WARNING("Failed to checkout %s", error.c_str());
            return "";
        }
        LOG("RepoControl::pull: Update from %s:%s suceeded",
            host.c_str(), path.c_str());
        return "";
    }
    RemoteRepo::sp srcRepo(new RemoteRepo());
    if (!srcRepo->connect(host + ":" + path)) {
        LOG("RepoControl::pull: Failed to connect to source %s", host.c_str());
        return  "";
    }
    ObjectHash newHead = srcRepo->get()->getHead();
    localRepo->pull(srcRepo->get
Buffer::Chunk::Chunk() : start(0), end(0) { mlock(this, sizeof(*this)); }
Buffer::Buffer() : _size(0) { mlock(this, sizeof(*this)); }
void Buffer::resize_smaller(size_t newSize) {
	assert(newSize <= _size);
	_size = newSize;
	for(auto chunkPtr = chunks.back(); chunkPtr && chunkPtr->isData() && newSize > 0; ) {
		Chunk& chunk = chunkPtr->value;
		
		if(newSize >= chunk.size()) {
			newSize -= chunk.size();
			auto prevChunkPtr = chunkPtr->getPrev();
			chunkPtr->popOut();
			chunkPtr = prevChunkPtr;
			continue;
		}
		
		chunk.end -= newSize;
		assert(chunk.start <= chunk.end);
		newSize = 0;
		break;
	}
	assert(newSize == 0);
size_t Buffer::pop(uint8_t* target, size_t target_size, bool doCleanup) {
	size_t c = 0;
	for(Chunk& chunk : chunks) {
		Chunk::Idx chunkEnd = chunk.end;
		if(chunk.start == 0 && chunkEnd == 0) {
			break;
		}
		int s = chunkEnd - chunk.start;
		if(s == 0) continue;
		if((size_t)s > target_size) s = (int)target_size;
		memcpy(target, chunk.data + chunk.start, s);


		_size -= s;
		target += s;
		target_size -= s;
		c += s;
		if(chunk.start < chunkEnd) {
			assert(target_size == 0);
			break;
		}
		if(chunkEnd < Chunk::BufferSize()) {
			break;
		}
		assert(chunk.start == chunkEnd);
		assert(chunkEnd == Chunk::BufferSize());
		if(doCleanup)
			chunks.pop_front();
	}
	return c;
void Buffer::push(const uint8_t* data, size_t size) {
	while(size > 0) {
		auto chunkBackPtr = chunks.back();
			chunks.push_back();
		else if(!chunkBackPtr->value.freeDataAvailable())
			chunks.push_back();
		auto chunkPtr = chunks.back();
		assert(chunkPtr && chunkPtr->isData(false));
		Chunk& chunk = chunkPtr->value;
		size_t s = std::min(size, (size_t)chunk.freeDataAvailable());
		assert(s > 0);
		memcpy(chunk.data + chunk.end, data, s);
		data += s;
		size -= s;
		chunk.end += s;
		_size += s;
	}
void Buffer::cleanup() {
	while(!chunks.empty()) {
		auto chunkPtr = chunks.front();
		Chunk& chunk = chunkPtr->value;
		if(chunk.end < Chunk::BufferSize()) break;
		if(chunk.
namespace rubinius {
  CodeManager::Chunk::Chunk(int size)
    : next(0)
  {
    resources = new CodeResource*[size];
    memset(resources, 0, sizeof(CodeResource*) * size);
  }
  CodeManager::Chunk::~Chunk() {
    delete[] resources;
  }
  CodeManager::CodeManager(SharedState* shared, int chunk_size)
    : shared_(shared)
    , chunk_size_(chunk_size)
    , first_chunk_(0)
    , last_chunk_(0)
    , current_chunk_(0)
    , current_index_(0)
    , freed_resources_(0)
    , total_allocated_(0)
    , total_freed_(0)
    , bytes_used_(0)
  {
    first_chunk_ = new Chunk(chunk_size_);
    last_chunk_ = first_chunk_;
    current_chunk_ = first_chunk_;
  }
  CodeManager::~CodeManager() {
    Chunk* chunk = first_chunk_;
    while(chunk) {
      for(int i = 0; i < chunk_size_; i++) {
        if(CodeResource* cr = chunk->resources[i]) {
          delete cr;
          chunk->resources[i] = 0;
        }
      }
      Chunk* next = chunk->next;
      delete chunk;
      chunk = next;
    }
  }
  

    Chunk* c = new Chunk(chunk_size_);
    last_chunk_->next = c;
    last_chunk_ = c;
    current_chunk_ = c;
  }
  void CodeManager::add_resource(CodeResource* cr) {
    utilities::thread::Mutex::LockGuard guard(mutex_);
    total_allocated_ += cr->size();
    bytes_used_ += cr->size();
    for(;;) {
      while(current_index_ < chunk_size_) {
        if(current_chunk_->resources[current_index_] == 0) {
          current_chunk_->resources[current_index_] = cr;
          return;
        }
        current_index_++;
      }
      current_index_ = 0;
      current_chunk_ = current_chunk_->next;
      if(!current_chunk_) add_chunk();
    }
  }
  void CodeManager::sweep() {
    Chunk* chunk = first_chunk_;
    freed_resources_ = 0;
    State state(shared_->root_vm());
    while(chunk) {
      for(int i = 0; i < chunk_size_; i++) {
        if(CodeResource* cr = chunk->resources[i]) {
          if(!cr->marked()) {
            total_freed_ += cr->size();
            bytes_used_ -= cr->size()
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
	namespace worker {
		/*!
		* Worker class to that fetches individual databases from given Mongo client.
		*/
		class DatabaseWorker : public RepoAbstractWorker {
			Q_OBJECT
		public:
			DatabaseWorker(repo::RepoController *controller, repo::RepoController::RepoToken *token);
			~DatabaseWorker();
		signals:
			void hostFetched(QString host);
			void 
namespace TAO
  namespace DCPS
  {
    ACE_INLINE
    DataSampleListElement::DataSampleListElement (
      PublicationId           publication_id,
      TransportSendListener*  send_listner,
      PublicationInstance*    handle,
      TransportSendElementAllocator* allocator)
      : sample_ (0),
        publication_id_ (publication_id), 
        num_subs_ (0),
        group_id_ (0),
        previous_sample_ (0),
        next_sample_ (0),
        next_instance_sample_ (0),
        next_send_sample_ (0),
        previous_send_sample_ (0),
        send_listener_ (send_listner),
        space_available_ (false),
        handle_(handle),
        transport_send_element_allocator_(allocator)
    {
    }
    ACE_INLINE
    DataSampleListElement::DataSampleListElement (const DataSampleListElement& elem)
    {
      sample_ = elem.sample_->duplicate ();
      publication_id_ = elem.publication_id_;
      num_subs_ = elem.publication_id_; 
      for (CORBA::ULong i = 0; i < num_subs_; ++i)
     

      group_id_ = elem.group_id_;
      previous_sample_ = elem.previous_sample_;
      next_sample_ = elem.next_sample_;
      next_instance_sample_ = elem.next_instance_sample_;
      next_send_sample_ = elem.next_send_sample_;
      previous_send_sample_ = elem.previous_send_sample_;
      send_listener_ = elem.send_listener_;
      space_available_ = elem.space_available_;
      handle_ = elem.handle_;
      transport_send_element_allocator_ = elem.transport_send_element_allocator_;
    }
    ACE_INLINE
    DataSampleListElement::~DataSampleListElement ()
    {
      if (sample_)
        {
          sample_->release ();
        }
    }
    ACE_INLINE
    DataSampleList::DataSampleList() 
      : head_( 0), 
        tail_( 0), 
        size_( 0) 
    { 
    }
    ACE_INLINE
    void DataSampleList::reset ()
    {
      head_ = tail_ = 0;
      size_ = 0;
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_sample (DataSampleListElement* sample)
    {
      
      ++s

      if( head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          tail_->next_sample_ = sample ;
          sample->previous_sample_ = tail_;
          tail_ = sample;
        }    
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_sample_;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else 
            {
              head_->previous_sample_ = 0;
            }
          stale->next_sample_ = 0;
          stale->previous_sample_ = 0;
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_send_sample (DataSampleListElement* sample)
    {
      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      e

        {
          sample->previous_send_sample_ = tail_;
          tail_->next_send_sample_ = sample ;
          tail_ = sample ;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_send_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_send_sample_ ;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else
            {
              head_->previous_send_sample_ = 0;
            }
          
          stale->next_send_sample_ = 0 ;
          stale->previous_send_sample_ = 0 ;
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_instance_sample (DataSampleListElement* sample)
    {
      sample->next_instance_sample_ = 0;
      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      el
namespace glm
	namespace virtrev_glmext
	{
		namespace xstream
		{
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec2<T> const & vec)
			{
				stream << "<glm_vec2 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec3<T> const & vec)
			{
				stream << "<glm_vec3 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec4<T> const & vec)
			{
				stream << "<glm_vec4 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "w=\"" << vec.w << "\" ";
				stream << "/>";
				return stream;
			}
			

			std::ostream & operator << (std::ostream & stream, glm::detail::tmat2x2<T> const & mat)
			{
				stream << "<glm_mat2>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat2>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat3x3<T> const & mat)
			{
				stream << "<glm_mat3>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << g

				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 2)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 2)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 2)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat3>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat4x4<T> const & mat)
			{
				stream << "<glm_mat4>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "w=\"" << glm::row(mat, 0)[3] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "w=\"" <<
using std::map;
namespace base {
typedef HistogramBase::Count Count;
typedef HistogramBase::Sample Sample;
SampleMap::SampleMap() {}
SampleMap::~SampleMap() {}
void SampleMap::Accumulate(Sample value, Count count) {
  sample_counts_[value] += count;
  IncreaseSum(count * value);
  IncreaseRedundantCount(count);
Count SampleMap::GetCount(Sample value) const {
  map<Sample, Count>::const_iterator it = sample_counts_.find(value);
  if (it == sample_counts_.end())
    return 0;
  return it->second;
Count SampleMap::TotalCount() const {
  Count count = 0;
  for (map<Sample, Count>::const_iterator it = sample_counts_.begin();
       it != sample_counts_.end();
       ++it) {
    count += it->second;
  }
  return count;
scoped_ptr<SampleCountIterator> SampleMap::Iterator() const {
  return scoped_ptr<SampleCountIterator>(new SampleMapIterator(sample_counts_));
void SampleMap::ResetRedundantCount(Count count) {
  IncreaseRedundantCount(-redundant_count());
  IncreaseRedundantCount(count);
bool
/*=========================================================================
  Program:   Insight Segmentation & Registration Toolkit
  Module:    itkFEMLoadImplementationsRegister.cxx
  Language:  C++
  Date:      $Date$
  Version:   $Revision$
  Copyright (c) Insight Software Consortium. All rights reserved.
     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
=========================================================================*/
namespace itk {
namespace fem {
/* This macro makes registering Load implementations easier. */
  { ElementClass::LoadImplementationFunctionPointer fp=&FunctionName; \
    /* NOTE: Borland compiler (bcc 5.5.1) crashes if the pointer to templated function is not stored in a variable, before it is used in a function call below. */ \
    VisitorDispatcher<ElementClass, ElementClass::LoadType, Element

    ::RegisterVisitor((LoadClass*)0, fp); }
/* Use this macro to also automatically declare load implementation function. */
  extern void FunctionName(ElementClass::ConstPointer, ElementClass::LoadPointer, ElementClass::VectorType& ); \
  REGISTER_LOAD_EX(ElementClass,LoadClass,FunctionName)
/**
 * Registers all Load classes in the FEM library with VisitorDispatcher.
 * This function must be called before the FEM library is functional!.
 */
void LoadImplementationsRegister(void)
  REGISTER_LOAD_EX(Element2DC0LinearLineStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC1Beam,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStress,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStrain,LoadGravConst

  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStress,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStrain,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularMembra
namespace cucumber {
namespace internal {
StepInfo::StepInfo(const std::string &stepMatcher, const std::string source) :
    regex(stepMatcher),
    source(source) {
    static step_id_type currentId = 0;
    id = ++currentId;
SingleStepMatch StepInfo::matches(const std::string &stepDescription) {
    SingleStepMatch stepMatch;
    shared_ptr<RegexMatch> regexMatch(regex.find(stepDescription));
    if (regexMatch->matches()) {
        stepMatch.stepInfo = this;
        stepMatch.submatches = regexMatch->getSubmatches();
    }
    return stepMatch;
SingleStepMatch::SingleStepMatch() :
    stepInfo(0) {
SingleStepMatch::SingleStepMatch(const SingleStepMatch &match) :
    stepInfo(match.stepInfo),
    submatches(match.submatches) {
SingleStepMatch & SingleStepMatch::operator =(const SingleStepMatch &match) {
    stepInfo = match.stepInfo;
    submatches = match.submatches;
    return *this;
SingleStepMatch::operator void *() {
    return (void *) stepInfo;
MatchResult::operator void *() {

    return (void *) resultSet.size();
MatchResult::operator bool() {
    return !resultSet.empty();
const MatchResult::match_results_type& MatchResult::getResultSet() {
    return resultSet;
void MatchResult::addMatch(SingleStepMatch match) {
    resultSet.push_back(match);
void InvokeArgs::addArg(const std::string arg) {
    args.push_back(arg);
const Table & InvokeArgs::getTableArg() const {
    return tableArg;
Table & InvokeArgs::getVariableTableArg() {
    return tableArg;
InvokeResult::InvokeResult(const InvokeResultType type, const char *description) :
    type(type) {
    if (description) { this->description = description; };
InvokeResult::InvokeResult() :
    type(FAILURE) {
InvokeResult::InvokeResult(const InvokeResult &ir) :
    type(ir.type),
    description(ir.description) {
InvokeResult& InvokeResult::operator= (const InvokeResult &rhs) {
    this->type = rhs.type;
    this->description = rhs.description;
    return *this;
InvokeResult InvokeResult::success() {
    retur

InvokeResult InvokeResult::failure(const char *description) {
    return InvokeResult(FAILURE, description);
InvokeResult InvokeResult::failure(const std::string &description) {
    return InvokeResult(FAILURE, description.c_str());
InvokeResult InvokeResult::pending(const char *description) {
    return InvokeResult(PENDING, description);
bool InvokeResult::isSuccess() const {
    return (type == SUCCESS);
bool InvokeResult::isPending() const {
    return (type == PENDING);
const InvokeResultType InvokeResult::getType() const {
    return type;
const std::string &InvokeResult::getDescription() const {
    return description;
StepManager::~StepManager() {
void StepManager::addStep(StepInfo *stepInfo) {
    steps().insert(std::make_pair(stepInfo->id, stepInfo));
MatchResult StepManager::stepMatches(const std::string &stepDescription) const {
    MatchResult matchResult;
    for (steps_type::iterator iter = steps().begin(); iter != steps().end(); ++iter) {
        StepInfo *stepInfo = i

        SingleStepMatch currentMatch = stepInfo->matches(stepDescription);
        if (currentMatch) {
            matchResult.addMatch(currentMatch);
        }
    }
    return matchResult;
StepInfo *StepManager::getStep(step_id_type id) {
    return steps()[id];
/**
 * Needed to fix the "static initialization order fiasco"
 */
StepManager::steps_type& StepManager::steps() const {
    static steps_type *steps = new steps_type();
    return *steps;
InvokeResult BasicStep::invoke(const InvokeArgs *pArgs) {
    this->pArgs = pArgs;
    currentArgIndex = 0;
    currentResult = InvokeResult::success();
    try {
        InvokeResult returnedResult = invokeStepBody();
        if (currentResult.isPending()) {
            return currentResult;
        } else {
            return returnedResult;
        }
    } catch (const std::exception& ex) {
        return InvokeResult::failure(ex.what());
    } catch (const std::string& ex) {
        return InvokeResult::failure(ex);
    } catch (const c
PEGASUS_USING_PEGASUS;
PEGASUS_USING_STD;
void testHostLocator()
    HostLocator locator("1.222.33.44:1234");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("1.222.33.44"));
    PEGASUS_TEST_ASSERT(locator.getPort() == 1234);
    PEGASUS_TEST_ASSERT(locator.getPortString() == String("1234"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV4);
    locator.setHostLocator("1.2.3.4");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("1.2.3.4"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV4);
    locator.setHostLocator("[fe00:ef::1]:1234");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("fe00:ef::1"));
    PEGASUS_TEST_ASSERT(locator.getAddres

    locator.setHostLocator("[fe00:1::]");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("fe00:1::"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV6);
    locator.setHostLocator("[fe00:1231:23fe:3456:acde:ebcd:12fe:ecd4]");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() ==
        String("fe00:1231:23fe:3456:acde:ebcd:12fe:ecd4"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV6);
    locator.setHostLocator("[fe00:1231:23fe:3456::ebcd:12fe:ecd4]:2345");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getPort() == 2345);
    PEGASUS_TEST_ASSERT(locator.getHost() ==
        String("fe00:1231:23fe:3456::ebcd:12fe:ecd4"));
    PEGASUS_TEST_ASSERT(locator.getAddressType

    locator.setHostLocator("123.34.abcd.xyz.com:65535");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("123.34.abcd.xyz.com"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_HOSTNAME);
    locator.setHostLocator("[1.2.3.4]:");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    locator.setHostLocator("[1.2.3.4]:1234");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[1.2.3.4]");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[ffff1:2:3:4]");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[123]:123345");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[]");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[1::24]:");
    PEGASUS_TEST_ASSERT(locato
class Dummy_Object_Data_Chunk;
class Dummy_Object_Chunk : public Chunk_With_Children
public:
	Dummy_Object_Chunk(Chunk_With_Children* parent,const char* _name ,ChunkVectorInt& _location,ChunkVectorInt& min ,ChunkVectorInt& max ,ChunkQuat& orient);
	Dummy_Object_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
};
class  Dummy_Object_Data_Chunk : public Chunk
public :
	Dummy_Object_Data_Chunk(Dummy_Object_Chunk* parent,const char* _name ,ChunkVectorInt& _location,ChunkVectorInt& min ,ChunkVectorInt& max ,ChunkQuat& orient);
	Dummy_Object_Data_Chunk (Chunk_With_Children * parent, const char * data, size_t );
	~Dummy_Object_Data_Chunk();
/*------------------------**
** Main dummy object data **
**------------------------*/
	char* name;
	ChunkVectorInt location;
	ChunkQuat orientation;
	ChunkVectorInt min_extents;
	ChunkVectorInt max_extents;
/*------------------------**
** Main dummy object data **
**------------------------*/
	size_t size_chunk();
	void fill_data_blo
/*!
 * Copyright (C) 2014 Nomovok Ltd. All rights reserved.
 * Contact: info@nomovok.com
 *
 * This file may be used under the terms of the GNU Lesser
 * General Public License version 2.1 as published by the Free Software
 * packaging of this file.  Please review the following information to
 * ensure the GNU Lesser General Public License version 2.1 requirements
 *
 * In addition, as a special exception, copyright holders
 * give you certain additional rights.  These rights are described in
 * LGPL_EXCEPTION.txt in this package.
 */
class TestSimpleQmlLoad: public QObject
    Q_OBJECT
private slots:
    void compileAndLoadBinding1();
    void loadBinding1();
    void loadItem();
    void compileAndLoadItem();
    void loadScript1();
    void compileAndLoadScript1();
    void loadSubItem2();
    void compileAndLoadSubItem2();
    void loadSubItem1();
    void compileAndLoadSubItem1();
    void loadSignal3();
    void compileAndLoadSignal3();
    void loadListView1();
    void compileA

    void loadSignal2();
    void compileAndLoadSignal2();
    void loadSignal1();
    void compileAndLoadSignal1();
    void loadComponent1();
    void compileAndLoadComponent1();
    void loadAlias1();
    void compileAndLoadAlias1();
    void loadAlias2();
    void compileAndLoadAlias2();
    void loadAlias3();
    void compileAndLoadAlias3();
    void loadAlias4();
    void compileAndLoadAlias4();
    void loadFunction1();
    void compileAndLoadFunction1();
    void compileModule1();
    void compileModule2();
    void loadCppSubItem();
    void compileAndLoadCppSubItem();
    void loadKeys();
    void compileAndLoadKeys();
    void loadProperty1();
    void compileAndLoadProperty1();
    void loadExceptions();
    void compileAndLoadExceptions();
    void loadScriptRef();
    void compileAndLoadScriptRef();
    void loadDefaultPropertyAlias();
    void compileAndLoadDefaultPropertyAlias();
    void initTestCase();
    void cleanupTestCase();
private:
    QQmlComponent *compileAnd
enum Process { WW, WZ, ZZ, Wjets, DYee, DYmm, DYtt, DY, Wgamma, Zgamma, ttbar, tW, 
			   LM1, LM2, LM3, LM4, LM5, LM6, LM7, LM8, LM9, LM10, LM11,
	       InclusiveMu5Pt50, InclusiveMuPt15, 
	       QCDBCtoEPt20to30, QCDBCtoEPt30to80, QCDBCtoEPt80to170, 
	       QCDEMenrichedPt20to30, QCDEMenrichedPt30to80, QCDEMenrichedPt80to170, QCDpt30,
	       QCDpt30to80,QCDpt80to170,QCDpt170to300,QCDpt300to470,QCDpt470to800,QCDpt800toInf};
class TChain;
class Sample {
public:
     TChain 		*chain;
     enum Process 	process;
     int		histo_color;
     double		kFactor;
     std::string	name;
     bool               sm;
     double             upper_pthat;
};
Sample fWW	();
Sample fWW_excl	();
Sample fWZ	();
Sample fZZ	();
Sample fWjets	();
Sample fWc	();
Sample fDYee 	();
Sample fDYmm 	();
Sample fDYtt 	();
Sample fVlqq	();
Sample fVlqq	();
Sample fAstar	();
Sample fDY20tt	();
Sample fDY20mm	();
Sample fDY20ee  ();
Sample fWgamma	();
Sample fZgamma	();
Sample fttbar	();
Sample fttbar_taula	();
Sa

Sample fSingleTop_tChannel	();
Sample fSingleTop_sChannel	();
Sample fLM1     ();
Sample fLM2     ();
Sample fLM3     ();
Sample fLM4     ();
Sample fLM5     ();
Sample fLM6     ();
Sample fLM7     ();
Sample fLM8     ();
Sample fLM9     ();
Sample fLM10    ();
Sample fLM11    ();
  
Sample fDYee_nofilter    ();
Sample fDYmm_nofilter    ();
Sample fDYtt_nofilter    ();
Sample fZeeJet80to120_nofilter();
Sample fZeeJet120to170_nofilter();
Sample fZeeJet170to230_nofilter();
Sample fZeeJet230to300_nofilter();
Sample fZeeJet300toInf_nofilter();
Sample fZeeJet300toInf_nofilter_sngl();
Sample fZeeJetALL80toInf_nofilter();
Sample fZmmJet80to120_nofilter();
Sample fZmmJet120to170_nofilter();
Sample fZmmJet170to230_nofilter();
Sample fZmmJet230to300_nofilter();
Sample fZmmJet300toInf_nofilter();
Sample fZmmJetALL80toInf_nofilter();
Sample fInclusiveMu5Pt50	();
Sample fInclusiveMuPt15	        ();
Sample fQCDBCtoEPt20to30	();
Sample fQCDBCtoEPt30to80	();
Sample fQCDBCtoEPt80to170	();
Sample fQCDE
static void free2(void *p){free(p);}
class Allocator{
  struct Chunk
  {
    struct Chunk *prev;
  };
  void *stack;
  Chunk *nextChunk;
  int stackSize;
  bool stackMode;
 public:
 Allocator():
  stack(0),
    stackSize(0),
    stackMode(false),
    nextChunk(0)
      {
      }
  void init(int stackSize_)
  {
    assert(stack==0);
    stackSize=stackSize_;
    stack=malloc(stackSize_);
    ((Chunk*)stack)->isAllocatedInStack=false;
    ((Chunk*)stack)->prev=0;
    nextChunk=(Chunk*)stack;
  }
  void deinit()
  {
    assert(((void*)nextChunk)==stack);
    if(stack)free2(stack);
    stack=0;
  }
  void setStackMode(bool mode){stackMode=mode;}
  MY_INLINE void *alloc(int s)
  {
    if(stackMode && (((char*)nextChunk-(char*)stack)+s+2*sizeof(Chunk)<=stackSize))
      {
	nextChunk->isAllocatedInStack=true;
	Chunk *ret=(Chunk*)(((char*)nextChunk)+sizeof(Chunk)+s);
	ret->prev=nextChunk;
	nextChunk=ret;
	return (void*)(ret->prev+1);
      }
    else
      {
	void *ret=malloc(s+sizeof(Chunk));
/*----------- defined in video/fromanc2.c -----------*/
VIDEO_UPDATE( fromanc2 );
VIDEO_START( fromanc2 );
VIDEO_START( fromancr );
VIDEO_START( fromanc4 );
READ16_HANDLER( fromanc2_paletteram_0_r );
READ16_HANDLER( fromanc2_paletteram_1_r );
WRITE16_HANDLER( fromanc2_paletteram_0_w );
WRITE16_HANDLER( fromanc2_paletteram_1_w );
READ16_HANDLER( fromancr_paletteram_0_r );
READ16_HANDLER( fromancr_paletteram_1_r );
WRITE16_HANDLER( fromancr_paletteram_0_w );
WRITE16_HANDLER( fromancr_paletteram_1_w );
READ16_HANDLER( fromanc4_paletteram_0_r );
READ16_HANDLER( fromanc4_paletteram_1_r );
WRITE16_HANDLER( fromanc4_paletteram_0_w );
WRITE16_HANDLER( fromanc4_paletteram_1_w );
WRITE16_HANDLER( fromanc2_videoram_0_w );
WRITE16_HANDLER( fromanc2_videoram_1_w );
WRITE16_HANDLER( fromanc2_videoram_2_w );
WRITE16_HANDLER( fromanc2_videoram_3_w );
WRITE16_HANDLER( fromancr_videoram_0_w );
WRITE16_HANDLER( fromancr_videoram_1_w );
WRITE16_HANDLER( fromancr_videoram_2_w );
WRITE16_HANDLER( fromanc4_v
ChunkController::ChunkController(GLfloat value1, GLfloat value2, QObject* parent) : QThread(parent)
	cellSize = 5.0f;
	bushSize = 0.75f;
	treeScaleCoefficient = 0.5f;
	xTrn = value1;
	zTrn = value2;
GLfloat ChunkController::getCellSize()
	return cellSize;
GLfloat ChunkController::getBushSize()
	return bushSize;
GLfloat ChunkController::getTreeScaleCoefficient()
	return treeScaleCoefficient;
Chunk* ChunkController::getChunk(int id)
	return (chunk + id);
void ChunkController::setXTrn(GLfloat value)
	xTrn = value;
void ChunkController::setZTrn(GLfloat value)
	zTrn = value;
void ChunkController::run()
	srand(time(NULL));
	if(-xTrn > (MAP_SIZE - 1) * cellSize * 0.5f)
	{
		chunk[0] = chunk[1];
		emit ready(0);
		
		chunk[3] = chunk[4];
		emit ready(3);
		
		chunk[6] = chunk[7];
		emit ready(6);
		
		chunk[1] = chunk[2];
		emit ready(1);
		
		chunk[4] = chunk[5];
		emit ready(4);
		
		chunk[7] = chunk[8];
		emit ready(7);
		
		chunk[2].clear();
		chunk[2].setSide(Chunk::Left, chunk[1].heightM

		chunk[2].generate();
		emit ready(2);
		
		chunk[5].clear();
		chunk[5].setSide(Chunk::Left, chunk[4].heightMap);
		chunk[5].setSide(Chunk::Bottom, chunk[2].heightMap);
		chunk[5].generate();
		emit ready(5);
		
		chunk[8].clear();
		chunk[8].setSide(Chunk::Left, chunk[7].heightMap);
		chunk[8].setSide(Chunk::Bottom, chunk[5].heightMap);
		chunk[8].generate();
		emit ready(8);
	}
	if(-xTrn < -(MAP_SIZE - 1) * cellSize * 0.5f)
	{
		chunk[2] = chunk[1];
		emit ready(2);
		
		chunk[5] = chunk[4];
		emit ready(5);
		
		chunk[8] = chunk[7];
		emit ready(8);
		
		chunk[1] = chunk[0];
		emit ready(1);
		
		chunk[4] = chunk[3];
		emit ready(4);
		
		chunk[7] = chunk[6];
		emit ready(7);
		
		chunk[0].clear();
		chunk[0].setSide(Chunk::Right, chunk[1].heightMap);
		chunk[0].generate();
		emit ready(0);
		
		chunk[3].clear();
		chunk[3].setSide(Chunk::Right, chunk[4].heightMap);
		chunk[3].setSide(Chunk::Bottom, chunk[0].heightMap);
		chunk[3].generate();
		emit ready(3);
		
		chunk[6].clear(

		chunk[6].setSide(Chunk::Right, chunk[7].heightMap);
		chunk[6].setSide(Chunk::Bottom, chunk[3].heightMap);
		chunk[6].generate();
		emit ready(6);
	}
	if(-zTrn > (MAP_SIZE - 1) * cellSize * 0.5f)
	{
		chunk[0] = chunk[3];
		emit ready(0);
		
		chunk[1] = chunk[4];
		emit ready(1);
		
		chunk[2] = chunk[5];
		emit ready(2);
		
		chunk[3] = chunk[6];
		emit ready(3);
		
		chunk[4] = chunk[7];
		emit ready(4);
		
		chunk[5] = chunk[8];
		emit ready(5);
		
		chunk[6].clear();
		chunk[6].setSide(Chunk::Bottom, chunk[3].heightMap);
		chunk[6].generate();
		emit ready(6);
		
		chunk[7].clear();
		chunk[7].setSide(Chunk::Left, chunk[6].heightMap);
		chunk[7].setSide(Chunk::Bottom, chunk[4].heightMap);
		chunk[7].generate();
		emit ready(7);
		
		chunk[8].clear();
		chunk[8].setSide(Chunk::Left, chunk[7].heightMap);
		chunk[8].setSide(Chunk::Bottom, chunk[5].heightMap);
		chunk[8].generate();
		emit ready(8);
	}
	if(-zTrn < -(MAP_SIZE - 1) * cellSize * 0.5f)
	{
		chunk[6] = chunk[3];
		emit 

		
		chunk[7] = chunk[4];
		emit ready(7);
		
		chunk[8] = chunk[5];
		emit ready(8);
		
		chunk[3] = chunk[0];
		emit ready(3);
		
		chunk[4] = chunk[1];
		emit ready(4);
		
		chunk[5] = chunk[2];
		emit ready(5);
		
		chunk[0].clear();
		chunk[0].setSide(Chunk::Top, chunk[3].heightMap);
		chunk[0].generate();
		emit ready(0);
		
		chunk[1].clear();
		chunk[1].setSide(Chunk::Top, chunk[4].heightMap);
		chunk[1].setSide(Chunk::Left, chunk[0].heightMap);
		chunk[1].generate();
		emit ready(1);
		
		chunk[2].clear();
		chunk[2].setSide(Chunk::Top, chunk[5].heightMap);
		chunk[2].setSide(Chunk::Left, chunk[1].heightMap);
		chunk[2].generate();
		emit ready(2);
	}
void ChunkController::generateMap()
{	
	for(int i = 0; i < 9; ++i)
	{
		chunk[i].clear();
	}
	chunk[0].generate();
	emit ready(0);
	chunk[1].setSide(Chunk::Left, chunk[0].heightMap);
	chunk[1].generate();
	emit ready(1);
	chunk[2].setSide(Chunk::Left, chunk[1].heightMap);
	chunk[2].generate();
	emit ready(2);
	chunk[3].setSide(C
/*
 * Copyright (c) 2012 Qualcomm Atheros, Inc.
 * All rights reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 *
 */
extern "C" {
    SW_API_DEF(SW_API_PT_DUPLEX_GET, athena_port_duplex_get), \
    SW_API_DEF(SW_API_PT_DUPLEX_SET, athena_port_duplex_set), \
    SW_API_DEF(SW_API_PT_SPEED_GET, athena_port_speed_get), \
    SW_API_DEF(SW_API_PT_SPEED_SET, athena_port_speed_set), \
    SW_API_DEF(SW_API_PT_AN_GET, athena_port_autoneg_status_get), \
    SW_API_DEF(SW_API_PT_AN_ENABLE, athena_port_autoneg_enable), \
    SW_API_DEF(SW_API_PT_AN_RESTART, athena_port_autoneg_restart), \
    SW_API_DEF(SW_API_PT_AN_ADV_GET, athena_port_autoneg_adv_get), \
    SW_API_DEF(SW_API_PT_AN_ADV_SET, athena_port_autoneg_adv_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_SET, athena_port_igmps_status_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_GET, athena_port_igmps_status_get), \
    SW_API_DEF(SW_API_PT_POWERSAVE_SET, athena_port_powersave_set), \
    SW_API_DEF(SW_API_PT_POWERSAVE_GET, athena

    SW_API_DEF(SW_API_PT_HIBERNATE_SET, athena_port_hibernate_set), \
    SW_API_DEF(SW_API_PT_HIBERNATE_GET, athena_port_hibernate_get),
    SW_API_DESC(SW_API_PT_DUPLEX_GET)  \
    SW_API_DESC(SW_API_PT_DUPLEX_SET)  \
    SW_API_DESC(SW_API_PT_SPEED_GET)  \
    SW_API_DESC(SW_API_PT_SPEED_SET)  \
    SW_API_DESC(SW_API_PT_AN_GET)  \
    SW_API_DESC(SW_API_PT_AN_ENABLE)  \
    SW_API_DESC(SW_API_PT_AN_RESTART) \
    SW_API_DESC(SW_API_PT_AN_ADV_GET) \
    SW_API_DESC(SW_API_PT_AN_ADV_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_GET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_SET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_GET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_SET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_GET)
    SW_API_DEF(SW_API_VLAN_ADD, athena_vlan_create), \
    SW_API_DEF(SW_API_VLAN_DEL, athena_vlan_delete), \
    SW_API_DEF(SW_API_VLAN_MEM_UPDATE, athena_vlan_member_update), \
    SW_API_DEF(SW_API_VLAN_FIND, athena_vlan_find), \
    SW_API_

    SW_API_DEF(SW_API_VLAN_APPEND, athena_vlan_entry_append),
    SW_API_DESC(SW_API_VLAN_ADD)  \
    SW_API_DESC(SW_API_VLAN_DEL)  \
    SW_API_DESC(SW_API_VLAN_MEM_UPDATE) \
    SW_API_DESC(SW_API_VLAN_FIND) \
    SW_API_DESC(SW_API_VLAN_NEXT) \
    SW_API_DESC(SW_API_VLAN_APPEND)
    SW_API_DEF(SW_API_PT_ING_MODE_GET, athena_port_1qmode_get), \
    SW_API_DEF(SW_API_PT_ING_MODE_SET, athena_port_1qmode_set), \
    SW_API_DEF(SW_API_PT_EG_MODE_GET, athena_port_egvlanmode_get), \
    SW_API_DEF(SW_API_PT_EG_MODE_SET, athena_port_egvlanmode_set), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_ADD, athena_portvlan_member_add), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_DEL, athena_portvlan_member_del), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_UPDATE, athena_portvlan_member_update), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_GET, athena_portvlan_member_get), \
    SW_API_DESC(SW_API_PT_ING_MODE_GET)  \
    SW_API_DESC(SW_API_PT_ING_MODE_SET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_GET)  \
    SW_API_DESC(SW_API_PT_EG_MO

    SW_API_DESC(SW_API_PT_VLAN_MEM_ADD) \
    SW_API_DESC(SW_API_PT_VLAN_MEM_DEL) \
    SW_API_DESC(SW_API_PT_VLAN_MEM_UPDATE)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_GET)
    SW_API_DEF(SW_API_FDB_ADD, athena_fdb_add), \
    SW_API_DEF(SW_API_FDB_DELALL, athena_fdb_del_all), \
    SW_API_DEF(SW_API_FDB_DELPORT,athena_fdb_del_by_port), \
    SW_API_DEF(SW_API_FDB_DELMAC, athena_fdb_del_by_mac), \
    SW_API_DEF(SW_API_FDB_FIRST,  athena_fdb_first), \
    SW_API_DEF(SW_API_FDB_NEXT,   athena_fdb_next),
    SW_API_DESC(SW_API_FDB_ADD)  \
    SW_API_DESC(SW_API_FDB_DELALL)  \
    SW_API_DESC(SW_API_FDB_DELPORT) \
    SW_API_DESC(SW_API_FDB_DELMAC)  \
    SW_API_DESC(SW_API_FDB_FIRST)   \
    SW_API_DESC(SW_API_FDB_NEXT)
    SW_API_DEF(SW_API_PT_MIB_GET, athena_get_mib_info),
    SW_API_DESC(SW_API_PT_MIB_GET)
    SW_API_DEF(SW_API_PHY_GET, athena_phy_get), \
    SW_API_DEF(SW_API_PHY_SET, athena_phy_set), \
    SW_API_DEF(SW_API_REG_GET, athena_reg_get), \
    SW_API_DEF(SW_API_REG_SET, at

    SW_API_DEF(SW_API_REG_FIELD_GET, athena_reg_field_get), \
    SW_API_DEF(SW_API_REG_FIELD_SET, athena_reg_field_set),
    SW_API_DESC(SW_API_PHY_GET)  \
    SW_API_DESC(SW_API_PHY_SET)  \
    SW_API_DESC(SW_API_REG_GET)  \
    SW_API_DESC(SW_API_REG_SET)  \
    SW_API_DESC(SW_API_REG_FIELD_GET) \
    SW_API_DESC(SW_API_REG_FIELD_SET)
    SW_API_DEF(SW_API_SWITCH_RESET, athena_reset), \
    SW_API_DEF(SW_API_SSDK_CFG, hsl_ssdk_cfg), \
    MIB_API \
    PORTCONTROL_API \
    PORTVLAN_API \
    VLAN_API \
    FDB_API \
    REG_API \
    SW_API_DEF(SW_API_MAX, NULL)
    SW_PARAM_DEF(SW_API_SWITCH_RESET, SW_UINT32, 4, SW_PARAM_IN, "Dev ID"), \
    SW_PARAM_DEF(SW_API_SSDK_CFG, SW_UINT32, 4, SW_PARAM_IN, "Dev ID"), \
    SW_PARAM_DEF(SW_API_SSDK_CFG, SW_SSDK_CFG, sizeof(ssdk_cfg_t), SW_PARAM_PTR|SW_PARAM_OUT, "ssdk configuration"), \
    MIB_API_PARAM \
    PORTCONTROL_API_PARAM \
    PORTVLAN_API_PARAM \
    VLAN_API_PARAM \
    FDB_API_PARAM \
    REG_API_PARAM \
    SW_PARAM_DEF(SW_A
/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2009 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/
namespace osgVolume {
class OSGVOLUME_EXPORT Locator : public osg::Object
    public:
        Locator() {}
        Locator(const osg::Matrixd& transform) { setTransform(transform); }
        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Locator(const Locator& locator,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY):
            osg::Object(locator, copyop),
            _transform(locator._transform) {}
      

        /** Set the transformation from local coordinates to model coordinates.*/
        void setTransform(const osg::Matrixd& transform) { _transform = transform; _inverse.invert(_transform); locatorModified(); }
        /** Set the transformation from local coordinates to model coordinates.*/
        const osg::Matrixd& getTransform() const { return _transform; }
        /** Set the extents of the local coords.*/
        void setTransformAsExtents(double minX, double minY, double maxX, double maxY, double minZ, double maxZ);
        virtual bool convertLocalToModel(const osg::Vec3d& /*local*/, osg::Vec3d& /*world*/) const;
        virtual bool convertModelToLocal(const osg::Vec3d& /*world*/, osg::Vec3d& /*local*/) const;
        static bool convertLocalCoordBetween(const Locator& source, const osg::Vec3d& sourceNDC,
                                             const Locator& destination, osg::Vec3d& destinationNDC)
        {
            osg::Vec3d model;
            if (!source.con

            if (!destination.convertModelToLocal(model, destinationNDC)) return false;
            return true;
        }
        bool computeLocalBounds(osg::Vec3d& bottomLeft, osg::Vec3d& topRight) const;
        bool computeLocalBounds(Locator& source, osg::Vec3d& bottomLeft, osg::Vec3d& topRight) const;
        /** Callback interface for enabling the monitoring of changes to the Locator.*/
        class LocatorCallback : virtual public osg::Object
        {
            public:
                LocatorCallback() {}
                LocatorCallback(const LocatorCallback& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY): osg::Object(rhs,copyop) {}
                META_Object(osgVolume, LocatorCallback);
                virtual void locatorModified(Locator* locator) {};
            protected:
                virtual ~LocatorCallback() {}
        };
        void addCallback(LocatorCallback* callback);
        void removeCallback(LocatorCallback* callback);
        typedef std::v
/*
* Copyright (c) 2010 Nokia Corporation and/or its subsidiary(-ies). 
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* Initial Contributors:
* Nokia Corporation - initial contribution.
* Contributors:
* Description:   VideoCollectionWrapper class implementation
* 
*/
/*
bool VideoCollectionWrapperData::mGetGenericModelFails = false;
bool VideoCollectionWrapperData::mGetAllVideosModelFails = false;
bool VideoCollectionWrapperData::mGetCollectionsModelFails = false;
bool VideoCollectionWrapperData::mGetCollectionContentModelFails = false;
VideoListDataModel *VideoCollectionWrapperData::mSourceModel = 0;
QPointer<VideoProxyModelGeneric> VideoCollectionWrapperData::mAllVideosModel = 0;
QPointer<VideoProxyModelGeneric> VideoCollectionWrapperData::mCollectionsModel = 0;
QPointer<VideoProxyModelGeneric> VideoCollectionWrapperData::mCollectionC

QPointer<VideoProxyModelGeneric> VideoCollectionWrapperData::mGenericModel = 0;*/
VideoCollectionWrapper &VideoCollectionWrapper::instance()
    static VideoCollectionWrapper _staticWrapper;
    return _staticWrapper;
VideoCollectionWrapper::VideoCollectionWrapper() 
VideoCollectionWrapper::~VideoCollectionWrapper()
    VideoCollectionWrapperData::reset();
VideoProxyModelGeneric* VideoCollectionWrapper::getGenericModel()
    VideoProxyModelGeneric *model = 0;
    if (!VideoCollectionWrapperData::mGetGenericModelFails)
    {
        VideoListDataModel *sourceModel = VideoCollectionWrapperData::mSourceModel;
        if (!sourceModel)
        {
            sourceModel = new VideoListDataModel;
            sourceModel->initialize();
            VideoCollectionWrapperData::mSourceModel = sourceModel;
        }
        model = VideoCollectionWrapperData::mGenericModel;
        if(!model && VideoCollectionWrapperData::mSourceModel)
        {
            model = new VideoProxyModelGeneric();


            VideoCollectionWrapperData::mGenericModel = model;
        }
    }
    
    return model;
VideoProxyModelGeneric* VideoCollectionWrapper::getAllVideosModel()
    VideoProxyModelGeneric *model = 0;
    if (!VideoCollectionWrapperData::mGetAllVideosModelFails)
    {
        VideoListDataModel *sourceModel = VideoCollectionWrapperData::mSourceModel;
        if (!sourceModel)
        {
            sourceModel = new VideoListDataModel;
            sourceModel->initialize();
            VideoCollectionWrapperData::mSourceModel = sourceModel;
        }
        model = VideoCollectionWrapperData::mAllVideosModel;
        if (!model)
        {
            model = new VideoProxyModelAllVideos();
                model->initialize(VideoCollectionWrapperData::mSourceModel);
            VideoCollectionWrapperData::mAllVideosModel = model;
        }
    }
    
    return model;
VideoProxyModelGeneric* VideoCollectionWrapper::getCollectionsModel()
    VideoProxyModelGeneric *model = 0;
  

    {
        VideoListDataModel *sourceModel = VideoCollectionWrapperData::mSourceModel;
        if (!sourceModel)
        {
            sourceModel = new VideoListDataModel;
            sourceModel->initialize();
            VideoCollectionWrapperData::mSourceModel = sourceModel;
        }
        model = VideoCollectionWrapperData::mCollectionsModel;
        if (!model)
        {
            model = new VideoProxyModelCollections();
            model->initialize(VideoCollectionWrapperData::mSourceModel);
            VideoCollectionWrapperData::mCollectionsModel = model;
        }
    }
    
    return model;
VideoProxyModelGeneric* VideoCollectionWrapper::getCollectionContentModel()
    VideoProxyModelGeneric *model = 0;
    if (!VideoCollectionWrapperData::mGetCollectionContentModelFails)
    {
        VideoListDataModel *sourceModel = VideoCollectionWrapperData::mSourceModel;
        if (!sourceModel)
        {
            sourceModel = new VideoListDataModel;
            sourceM
TEST(repo, failure) {
  ASSERT_THROW(Repository("/tmp/notfound"), GitException);
TEST(repo, success) {
  Repository repo("../test/testrepo");
  Repository rep(repo);
  rep = repo;
TEST(repo, get) {
  Repository repo("../test/testrepo");
  git_repository* bare = repo.get();
  ASSERT_NE(bare, nullptr);
TEST(repo, head) {
  Repository repo("../test/testrepo");
  Reference head = repo.head();
  ASSERT_NE(head.get(), nullptr);
  ASSERT_EQ(head.name(), "refs/heads/master");
TEST(repo, commits) {
  Repository repo("../test/testrepo");
  ASSERT_EQ(repo.getAllCommits().size(), 4);
TEST(repo, commitx) {
  Repository repo("../test/testrepo");
  auto commits = repo.getAllCommitsX();
  ASSERT_EQ(commits[0]->getAuthor(), "Tim Siebels"); 
  ASSERT_EQ(commits[0]->getAuthorMail(), "tim_siebels_aurich@yahoo.de");
  ASSERT_EQ(commits[0]->getFiles().size(), 2);  
  ASSERT_EQ(commits[0]->getFiles()[0].filename, "file.txt");
  ASSERT_EQ(commits[0]->getFiles()[0].linesChanged, 1);
TEST(repo, commitx_since_af
using namespace Rcpp ;
class SimVam { 
public:
    SimVam(List model_) {
        model=new VamModel(model_);
    };
    ~SimVam() {
        delete model;
    };
    DataFrame get_data() {
        return DataFrame::create(_["Time"]=model->time,_["Type"]=model->type);
    }
    DataFrame simulate(int nbsim) {
        init(nbsim);
        while(model->k < nbsim) {
            double timePM, timeCM = model->models->at(model->idMod)->virtual_age_inverse(model->family->inverse_cumulative_density(model->family->cumulative_density(model->models->at(model->idMod)->virtual_age(model->time[model->k]))-log(runif(1))[0]));
            int idMod;
            List timeAndTypePM;
            if(model->maintenance_policy != NULL) {
                
                NumericVector tmp=timeAndTypePM["time"];
                timePM=tmp[0];
            }
            if(model->maintenance_policy == NULL || timeCM < timePM) {
                model->time[model->k + 1]=timeCM;
                model->type[model->
Io::Io()
	:	mNumOpenedSerialHandler	(0),
		mNumOpenedIicHandler	(0),
		mNumOpenedGpioHandler	(0),
		mNumOpenedWebsocketHandler	(0)
SerialHandler *Io::getSerialHandler(const char *portName)
	int i;
	for (i=0; i<mNumOpenedSerialHandler; ++i)
	{
		if (strcmp(portName, mOpenedSerialHandler[i]->getPortName()) == 0)
		{
			return mOpenedSerialHandler[i];
		}
	}
	mOpenedSerialHandler[mNumOpenedSerialHandler] = new SerialHandler(portName);
	mNumOpenedSerialHandler++;
	return mOpenedSerialHandler[mNumOpenedSerialHandler-1];
IicHandler *Io::getIicHandler(const char *portName)
	int i;
	for (i=0; i<mNumOpenedIicHandler; ++i)
	{
		if (strcmp(portName, mOpenedIicHandler[i]->getPortName()) == 0)
		{
			return mOpenedIicHandler[i];
		}
	}
	mOpenedIicHandler[mNumOpenedIicHandler] = new IicHandler(portName);
	++mNumOpenedIicHandler;
	return mOpenedIicHandler[mNumOpenedIicHandler-1];
GpioHandler *Io::getGpioHandler(const char *gpioKey)
	int i;
	for (i=0; i<mNumOpenedGpioHandler; ++i)
	{
		if (strcmp(gpio
namespace recipes {
InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor& f)
    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std::cout << "InvokeTimer::InvokeTimer tid=" << std::this_thread::get_id() << " this=" << this << std::endl;
InvokeTimer* InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor& f) {
    return new InvokeTimer(evloop, timeout_ms, f);
InvokeTimer::~InvokeTimer() {
    std::cout << "InvokeTimer::~InvokeTimer tid=" << std::this_thread::get_id() << " this=" << this << std::endl;
void InvokeTimer::Start() {
    std::cout << "InvokeTimer::Start tid=" << std::this_thread::get_id() << " this=" << this << std::endl;
    timer_.reset(new TimerEventWatcher(loop_, std::bind(&InvokeTimer::OnTimerTriggered, this), timeout_ms_));
    timer_->Init();
    timer_->AsyncWait();
    std::cout << "InvokeTimer::Start(AsyncWait) tid=" << std::this_thread::get_id() << " timer=" << timer_.get() << " this=" << this <
/*
 * $Id: RepoIdSet.inl 4223 2011-02-04 23:01:46Z mitza $
 *
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSet::RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","RepoIdSet",6);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::insert_id(RepoId key, RepoId value)
  DBG_ENTRY_LVL("RepoIdSet","insert_id",6);
  return OpenDDS::DCPS::bind(map_, key, value);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::remove_id(RepoId id)
  DBG_ENTRY_LVL("RepoIdSet","remove_id",6);
  int result = unbind(map_, id);
  if (result != 0) {
    VDBG((LM_DEBUG, "(%P|%t) RepoId (%d) not found in map_.\n",id));
  }
  return result;
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSet::size() const
  DBG_ENTRY_LVL("RepoIdSet","size",6);
  return map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map()
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->map_;
ACE_INLINE const OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map() const
  DBG_ENTRY_LVL("RepoIdSet","map
/**
 * This file is part of the CernVM File System.
 */
namespace upload {
class IoDispatcher;
class ChunkDetector;
class Chunk;
typedef std::vector<Chunk*> ChunkVector;
/**
 * File to be processed by the processing pipe line. A File object is the only
 * input object for the processing. It is in charge of the Chunk handling and
 * holds file related meta data.
 */
class File : public AbstractFile {
 public:
  File(const std::string    &path,
       IoDispatcher         *io_dispatcher,
       ChunkDetector        *chunk_detector,
       shash::Algorithms     hash_algorithm,
       const shash::Suffix   hash_suffix = shash::kSuffixNone);
  ~File();
  bool MightBecomeChunked() const { return might_become_chunked_; }
  /**
   * This creates a next chunk which will be the successor of the current chunk
   *
   * @param   offset  the offset at which the new chunk should be created
   *                  Note: this implictly defines the size of the current chunk
   * @return  the predecessor 

   */
  Chunk* CreateNextChunk(const off_t offset);
  /**
   * Notifies that a given Chunk has been fully processed and committed.
   * @param chunk   The finalized chunk
   */
  void ChunkCommitted(Chunk *chunk);
  /**
   * After all Chunks have been produced, this makes sure that the last generated
   * Chunk will contain all remaining data of File.
   */
  void FullyDefineLastChunk();
  off_t FindNextCutMark(CharBuffer *buffer) {
    assert(chunk_detector_ != NULL);
    assert(might_become_chunked_);
    return chunk_detector_->FindNextCutMark(buffer);
  }
  bool HasBulkChunk()              const { return bulk_chunk_ != NULL;     }
  bool HasChunkDetector()          const { return chunk_detector_ != NULL; }
        Chunk*        bulk_chunk()        { return bulk_chunk_;  }
  const Chunk*        bulk_chunk()  const { return bulk_chunk_;  }
  const ChunkVector&  chunks()      const { return chunks_;      }
        shash::Suffix hash_suffix() const { return hash_suffix_; }
  Chunk* cu
TEST_F(DumpTest, dump_null_basic) {
    EXPECT_STREQ(
        ""
        ,
        t_cfg_dump(NULL));
TEST_F(DumpTest, dump_struct_basic) {
    EXPECT_STREQ(
        "{ a=1\n"
        ", b=2\n"
        "}"
        ,
        dump(
            "a: 1\n"
            "b: 2\n"
            ));
TEST_F(DumpTest, dump_struct_item_empty) {
    EXPECT_STREQ(
        "{}"
        ,
        dump("{}"));
TEST_F(DumpTest, dump_struct_item_one) {
    EXPECT_STREQ(
        "{ a=1 }"
        ,
        dump(
            "a: 1\n"
            ));
TEST_F(DumpTest, dump_sequence_basic) {
    EXPECT_STREQ(
        "[ 1\n"
        ", 2\n"
        "]"
        ,
        dump(
            "- 1\n"
            "- 2\n"
            ));
TEST_F(DumpTest, dump_sequence_item_empty) {
    EXPECT_STREQ(
        "[]"
        ,
        dump("[]"));
TEST_F(DumpTest, dump_sequence_item_one) {
    EXPECT_STREQ(
        "[ 1 ]"
        ,
        dump(
            "[1]\n"
            ));
TEST_F(DumpTest, dump_complex_struct_struct

    EXPECT_STREQ(
        "{ a=1\n"
        ", b={ c=2\n"
        "    , d=3\n"
        "    }\n"
        ", e=4\n"
        "}"
        ,
        dump(
            "a: 1\n"
            "b:\n"
            "  c: 2\n"
            "  d: 3\n"
            "e: 4"
            ));
TEST_F(DumpTest, dump_complex_struct_seq) {
    EXPECT_STREQ(
        "{ a=1\n"
        ", b=[ 2\n"
        "    , 3\n"
        "    ]\n"
        ", e=4\n"
        "}"
        ,
        dump(
            "a: 1\n"
            "b:\n"
            "  - 2\n"
            "  - 3\n"
            "e: 4"
            ));
TEST_F(DumpTest, dump_inline_null_basic) {
    EXPECT_STREQ(
        ""
        ,
        t_cfg_dump_inline(NULL));
TEST_F(DumpTest, dump_inline_struct_basic) {
    EXPECT_STREQ(
        "{ a=1, b=2 }"
        ,
        dump_inline(
            "a: 1\n"
            "b: 2\n"
            ));
TEST_F(DumpTest, dump_inline_struct_item_empty) {
    EXPECT_STREQ(
        "{}"
        ,
        dump_inline("{}"));
TEST_

    EXPECT_STREQ(
        "{ a=1 }"
        ,
        dump_inline(
            "a: 1\n"
            ));
TEST_F(DumpTest, dump_inline_sequence_basic) {
    EXPECT_STREQ(
        "[ 1, 2 ]"
        ,
        dump_inline(
            "- 1\n"
            "- 2\n"
            ));
TEST_F(DumpTest, dump_inline_sequence_item_empty) {
    EXPECT_STREQ(
        "[]"
        ,
        dump_inline("[]"));
TEST_F(DumpTest, dump_inline_sequence_item_one) {
    EXPECT_STREQ(
        "[ 1 ]"
        ,
        dump_inline(
            "[1]\n"
            ));
TEST_F(DumpTest, dump_inline_complex_struct_struct) {
    EXPECT_STREQ(
        "{ a=1, b={ c=2, d=3 }, e=4 }"
        ,
        dump_inline(
            "a: 1\n"
            "b:\n"
            "  c: 2\n"
            "  d: 3\n"
            "e: 4"
            ));
TEST_F(DumpTest, dump_inline_complex_struct_seq) {
    EXPECT_STREQ(
        "{ a=1, b=[ 2, 3 ], e=4 }"
        ,
        dump_inline(
            "a: 1\n"
            "b:\n"
            " 
/* $Id: TestDbmRecStream.cpp,v 1.1 2002/09/15 07:46:30 pgr Exp $ */
char const TestDbmRecStream::fileName[] = "HelloRecDB";
/*----------------------------------------------------TestDbmRecStream::title-+
|                                                                             |
+----------------------------------------------------------------------------*/
char const * TestDbmRecStream::title() {
   return "TestDbmRecStream";
/*-----------------------------------------TestDbmRecStream::TestDbmRecStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
TestDbmRecStream::TestDbmRecStream() {
   pStream = 0;
/*----------------------------------------TestDbmRecStream::~TestDbmRecStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
TestDbmRecStream::~TestDbmRecS

   delete pStream;
/*---------------------------------------------TestDbmRecStream::newOutStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
ostream * TestDbmRecStream::newOutStream() {
   if (pStream) delete pStream;
   pStream = new PalmDbmRecStream(fileName, dmModeWrite, 1, 0, 'Jaxo');
   return pStream;
/*----------------------------------------------TestDbmRecStream::newInStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
istream * TestDbmRecStream::newInStream() {
   if (pStream) delete pStream;
   pStream = new PalmDbmRecStream(fileName, dmModeReadOnly, 1, 0, 'Jaxo');
   return pStream;
/*-------------------------------------------TestDbmRecStream::newInOutStream-+
|                                                                             |
+-
void interval_loop(int interval_us, std::function<bool(float load_avg)> f)
	int64_t t_scheduled_tick_start = get_timeofday_us();
	t_scheduled_tick_start *= interval_us;
	float load_sum = 0;
	const int load_avg_length = interval_us < 500000 ? 5000000 / interval_us : 1;
	float *load_log = new float[load_avg_length];
	memset(load_log, 0, sizeof(float) * load_avg_length);
	int load_log_i = load_avg_length - 1;
	float last_load_avg = 0;
	for(;;){
		int64_t t_now = get_timeofday_us();
		t_scheduled_tick_start += interval_us;
		int64_t t_until_next_tick = t_scheduled_tick_start - t_now;
		if(t_until_next_tick < 0 || t_until_next_tick > interval_us){
			log_w("loop", "interval_loop(): Delayed by %" PRId64 "ms"
					" (%+.0f%% interval)", -t_until_next_tick / 1000,
					-100.0 * t_until_next_tick / interval_us);
			if(t_scheduled_tick_start < t_now - 100000){
				t_scheduled_tick_start = t_now;
				t_until_next_tick = 0;
			}
		}
		if(t_until_next_tick > 0)
			usleep(t_until_next_tick);
		int64
/*
 * ModelStoreItem.cpp
 *
 *  Created on: Aug 11, 2012
 *      Author: Vinayak Viswanathan
 */
namespace skydragonengine {
    ModelStoreItem::ModelStoreItem(
            const Resource& source,
            ModelType modelType):
                _modelSource(source),
                _modelType(modelType),
                _loaded(false) {
    }
    ModelStoreItem::ModelStoreItem(const Resource& source,
            ModelType modelType,
            const ModelLoaderParam& modelLoaderParam):
                        _modelSource(source),
                        _modelType(modelType),
                        _modelLoaderParam(modelLoaderParam),
                        _loaded(false) {
    }
    ModelStoreItem::~ModelStoreItem() {
    }
    const Resource& ModelStoreItem::GetSource() const {
        return _modelSource;
    }
    ModelType ModelStoreItem::GetModelType() const {
        return _modelType;
    }
    bool ModelStoreItem::IsLoaded() const {
        return _loaded;
    }
    void
	ChunkHandler::ChunkHandler(Vertex32 *pos)
	{
		position = pos;
		int chunk_x, chunk_y, chunk_z;
		
		for(int z = 0;  z < WORLD_SIZE; z++)
		{
			for(int y = 0;  y < WORLD_SIZE; y++)
			{		
				for(int x = 0;  x < WORLD_SIZE; x++)
				{
					chunk_x = position->x + x * CHUNK_SIZE * BLOCK_SIZE;
					chunk_y = position->y + y * CHUNK_SIZE * BLOCK_SIZE;
					chunk_z = position->z + z * CHUNK_SIZE * BLOCK_SIZE;
					
					if(y < 2)
						chunkList.push_back(new Chunk(chunk_x, chunk_y, chunk_z, x, y, z, false));
					else
						chunkList.push_back(new Chunk(chunk_x, chunk_y, chunk_z, x, y, z, true));
				}
			}
		}
		
		generateNeighbours();
		updateChunks();
	}
	ChunkHandler::~ChunkHandler()
	{
		clearChunkList();
	}
	Block *ChunkHandler::getBlockAtPosition(int x, int y, int z)
	{
		int chunk_x = floor(x / CHUNK_TOTAL_SIZE);
		int chunk_y = floor(y / CHUNK_TOTAL_SIZE);
		int chunk_z = floor(z / CHUNK_TOTAL_SIZE);
				
		int block_x = floor((x - (chunk_x * CHUNK_TOTAL_SIZE)) / BLOCK_SIZE);


		int block_z = floor((z - (chunk_z * CHUNK_TOTAL_SIZE)) / BLOCK_SIZE);
			
		return chunkList[getWorldIndex(chunk_x, chunk_y, chunk_z)]->blockList[block_z][block_y][block_x];
	}
	void ChunkHandler::clearChunkList()
	{
		for(uint32_t i = 0; i < chunkList.size(); i++)
		{
			delete chunkList[i];	
		}
		chunkList.clear();		
	}
	void ChunkHandler::updateChunks()
	{
		std::vector<Chunk *>::iterator it;
		for(it = chunkList.begin(); it != chunkList.end(); it++)
		{
			if((*it)->needsUpdate)
				(*it)->generateMesh();
		}	
	}
	void ChunkHandler::generateNeighbours()
	{
		Chunk *chunkP;
		for(int z = 0;  z < WORLD_SIZE; z++)
		{
			for(int y = 0;  y < WORLD_SIZE; y++)
			{		
				for(int x = 0;  x < WORLD_SIZE; x++)
				{
					chunkP = chunkList[getWorldIndex(x, y, z)];
					
						if(x == 0)
							chunkP->setLeftNeighbour(NULL);
						else
							chunkP->setLeftNeighbour(chunkList[getWorldIndex(x - 1, y, z)]);
						if(x == (WORLD_SIZE-1))
							chunkP->setRightNeighbour(NULL);
						else


						if(y == (WORLD_SIZE-1))
							chunkP->setUpNeighbour(NULL);
						else
							chunkP->setUpNeighbour(chunkList[getWorldIndex(x, y + 1, z)]);
						if(y == 0)
							chunkP->setDownNeighbour(NULL);
						else
							chunkP->setDownNeighbour(chunkList[getWorldIndex(x, y - 1, z)]);
						if(z == (WORLD_SIZE-1))
							chunkP->setFrontNeighbour(NULL);
						else
							chunkP->setFrontNeighbour(chunkList[getWorldIndex(x, y, z + 1)]);
						if(z == 0)
							chunkP->setBackNeighbour(NULL);
						else
							chunkP->setBackNeighbour(chunkList[getWorldIndex(x, y, z - 1)]);					
				}
			}
		}		
	}
	bool ChunkHandler::chunkInBounds(Chunk *chunkPointer)
	{
		if(chunkPointer != NULL)
		{
			if(chunkPointer->index.x >= 0 && chunkPointer->index.x < WORLD_SIZE &&
				chunkPointer->index.y >= 0 && chunkPointer->index.y < WORLD_SIZE &&
				chunkPointer->index.z >= 0 && chunkPointer->index.z < WORLD_SIZE)
				{
					return true;
				}
		}
		return false;
	}	
	void ChunkHandler::draw()
	{
		std
/*
 * chunk.cpp
 *
 *  Created on: Jul 18, 2008
 *      Author: vjeko
 */
namespace colony {
namespace storage {
chunk_data::chunk_data() :
    chunk_metadata(),
    data_ptr_(new data_type) {
chunk_data::chunk_data(std::string s) :
    chunk_metadata(),
    data_ptr_( new data_type ) {
  data_ptr_->assign( s.begin(), s.end() );
chunk_data::chunk_data(
    chunk_metadata::uid_type         uid,
    chunk_metadata::cuid_type        cuid) :
      chunk_metadata(uid, cuid),
      data_ptr_(new data_type) {}
chunk_data::chunk_data(key_type key) :
    chunk_metadata(key),
    data_ptr_(new data_type) {}
chunk_data::chunk_data(
    chunk_metadata::uid_type         uid,
    chunk_metadata::cuid_type        cuid,
    boost::shared_ptr<data_type>     data_ptr) :
      chunk_metadata(uid, cuid),
          data_ptr_(new data_type){
  (*data_ptr_) = (*data_ptr);
chunk_data::chunk_data(
    chunk_metadata                  metadata,
    boost::shared_ptr<data_type>    data_ptr) :
      chunk_metadata
class ChunkListTest : public CppUnit::TestFixture {
  CPPUNIT_TEST_SUITE(ChunkListTest);
  CPPUNIT_TEST(test_basic);
  CPPUNIT_TEST(test_get_release);
  CPPUNIT_TEST(test_blocking);
  CPPUNIT_TEST_SUITE_END();
public:
  void setUp() {}
  void tearDown() {}
  void test_basic();
  void test_get_release();
  void test_blocking();
};
torrent::Chunk* func_create_chunk(uint32_t index, int prot_flags);
uint64_t        func_free_diskspace(torrent::ChunkList* chunk_list);
void            func_storage_error(torrent::ChunkList* chunk_list, const std::string& message);
  torrent::ChunkManager* chunk_manager = new torrent::ChunkManager;     \
  torrent::ChunkList* chunk_list = new torrent::ChunkList;              \
  chunk_list->set_manager(chunk_manager);                               \
  chunk_list->slot_create_chunk() = std::bind(&func_create_chunk, std::placeholders::_1, std::placeholders::_2); \
  chunk_list->slot_free_diskspace() = std::bind(&func_free_diskspace, chunk_list); \
  chunk_list->
/**
* 
* @file
* @brief  Volume lookup table
* @author vitamin.caig@gmail.com
**/
namespace Devices
namespace AYM
  class MultiVolumeTable
  {
  public:
    MultiVolumeTable()
      : Table(nullptr)
      , Layout(nullptr)
    {
    }
    void SetParameters(ChipType type, LayoutType layout, const MixerType& mixer)
    {
      static const MultiSample IN_A = {{Sound::Sample::MAX, Sound::Sample::MID, Sound::Sample::MID}};
      static const MultiSample IN_B = {{Sound::Sample::MID, Sound::Sample::MAX, Sound::Sample::MID}};
      static const MultiSample IN_C = {{Sound::Sample::MID, Sound::Sample::MID, Sound::Sample::MAX}};
      const Sound::Sample::Type* const newTable = GetVolumeTable(type);
      const LayoutData* const newLayout = GetLayout(layout);
      if (Table != newTable
       || Layout != newLayout
       || !(Lookup[HIGH_LEVEL_A] == Mix(IN_A, mixer))
       || !(Lookup[HIGH_LEVEL_B] == Mix(IN_B, mixer))
       || !(Lookup[HIGH_LEVEL_C] == Mix(IN_C, mixer)))
      {
        Ta

        Layout = newLayout;
        FillLookupTable(mixer);
      }
    }
    Sound::Sample Get(uint_t in) const
    {
      return Lookup[in];
    }
  private:
    static const Sound::Sample::Type* GetVolumeTable(ChipType type)
    {
      static const Sound::Sample::Type AYVolumeTab[32] =
      {
        ToSample(0x0000), ToSample(0x0000), ToSample(0x0340), ToSample(0x0340), ToSample(0x04C0), ToSample(0x04C0), ToSample(0x06F2), ToSample(0x06F2),
        ToSample(0x0A44), ToSample(0x0A44), ToSample(0x0F13), ToSample(0x0F13), ToSample(0x1510), ToSample(0x1510), ToSample(0x227E), ToSample(0x227E),
        ToSample(0x289F), ToSample(0x289F), ToSample(0x414E), ToSample(0x414E), ToSample(0x5B21), ToSample(0x5B21), ToSample(0x7258), ToSample(0x7258),
        ToSample(0x905E), ToSample(0x905E), ToSample(0xB550), ToSample(0xB550), ToSample(0xD7A0), ToSample(0xD7A0), ToSample(0xFFFF), ToSample(0xFFFF)
      };
      static const Sound::Sample::Type YMVolumeTab[32] =
      {
        ToSample(0

        ToSample(0x0611), ToSample(0x0782), ToSample(0x0912), ToSample(0x0A36), ToSample(0x0C31), ToSample(0x0EB6), ToSample(0x1130), ToSample(0x13A0),
        ToSample(0x1751), ToSample(0x1BF5), ToSample(0x20E2), ToSample(0x2594), ToSample(0x2CA1), ToSample(0x357F), ToSample(0x3E45), ToSample(0x475E),
        ToSample(0x5502), ToSample(0x6620), ToSample(0x7730), ToSample(0x8844), ToSample(0xA1D2), ToSample(0xC102), ToSample(0xE0A2), ToSample(0xFFFF)
      };
      switch (type)
      {
      case TYPE_YM2149F:
        return YMVolumeTab;
      default:
        return AYVolumeTab;
      }
    }
    static Sound::Sample::Type ToSample(uint_t val)
    {
      return Sound::Sample::MID + val * (Sound::Sample::MAX - Sound::Sample::MID) / (Sound::Sample::MAX - Sound::Sample::MIN);
    }
    typedef std::array<uint_t, SOUND_CHANNELS> LayoutData;
    static const LayoutData* GetLayout(LayoutType type)
    {
      static const LayoutData LAYOUTS[] =
      {
      };
      return type == LAYOU

        ? nullptr
        : LAYOUTS + type;
    }
    typedef MixerType::InDataType MultiSample;
    void FillLookupTable(const MixerType& mixer)
    {
      for (uint_t idx = 0; idx != Lookup.size(); ++idx)
      {
        const MultiSample res =
        {{
          Table[idx & HIGH_LEVEL_A],
          Table[(idx >> BITS_PER_LEVEL) & HIGH_LEVEL_A],
          Table[idx >> 2 * BITS_PER_LEVEL]
        }};
        Lookup[idx] = Mix(res, mixer);
      }
    }
    Sound::Sample Mix(const MultiSample& in, const MixerType& mixer) const
    {
      if (Layout)
      {
        const MultiSample out =
        {{
          in[Layout->at(0)],
          in[Layout->at(1)],
          in[Layout->at(2)]
        }};
        return mixer.ApplyData(out);
      }
      {
        const Sound::Sample::Type avg = (int_t(in[0]) + in[1] + in[2]) / SOUND_CHANNELS;
        const MultiSample out = {{avg, avg, avg}};
        return mixer.ApplyData(out);
      }
    }
  private:
    const Sound::Sample::Type* Tabl
class HookTests : public AbstractModule, public zAPI::IBuildResponse, public zAPI::INetwork, public zAPI::IReceiveRequest, public zAPI::ISendResponse, public zAPI::IServerEvent, public zAPI::IWorkflow, public zAPI::IModuleEvent
    public:
        HookTests();
        virtual ~HookTests();
        int                         getPriority(zAPI::IModule::Event) const;
        zAPI::IModule::ChainStatus  onPreBuild(zAPI::IHttpRequest*, zAPI::IHttpResponse*);
        zAPI::IModule::ChainStatus  onPostBuild(zAPI::IHttpRequest*, zAPI::IHttpResponse*);
        zAPI::IClientSocket*        onAccept(SOCKET);
        zAPI::IModule::ChainStatus  onReceive(char*, size_t);
        zAPI::IModule::ChainStatus  onSend(char*, size_t);
        zAPI::IModule::ChainStatus  onPreReceive(zAPI::IHttpRequest*, zAPI::IHttpResponse*);
        zAPI::IModule::ChainStatus  onPostReceive(zAPI::IHttpRequest*, zAPI::IHttpResponse*);
        void                        setInput(zAPI::IModule*);
        zAPI::IModule::Ch
/**
 * @author William R. Otte <wotte@dre.vanderbilt.edu>
 * @author Johnny Willemsen (jwillemsen@remedy.nl)
 *
 * Wrapper facade for NDDS.
 */
inline void
operator<<= (::DDS::SampleInfo& sample_info, const ::DDS_SampleInfo& dds_sample_info)
  sample_info.sample_state = dds_sample_info.sample_state;
  sample_info.view_state = dds_sample_info.view_state;
  sample_info.instance_state = dds_sample_info.instance_state;
  sample_info.source_timestamp <<= dds_sample_info.source_timestamp;
  sample_info.instance_handle <<= dds_sample_info.instance_handle;
  sample_info.publication_handle <<= dds_sample_info.publication_handle;
  sample_info.disposed_generation_count = dds_sample_info.disposed_generation_count;
  sample_info.no_writers_generation_count = dds_sample_info.no_writers_generation_count;
  sample_info.sample_rank = dds_sample_info.sample_rank;
  sample_info.generation_rank = dds_sample_info.generation_rank;
  sample_info.absolute_generation_rank = dds_sample_info.absolute_generation
/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (directui@nokia.com)
**
** This file is part of systemui.
**
** If you have questions regarding the use of this file, please contact
** Nokia at directui@nokia.com.
**
** This library is free software; you can redistribute it and/or
** modify it under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation
** of this file.
**
****************************************************************************/
class StatusIndicatorModel : public MWidgetModel
    Q_OBJECT
    M_MODEL(StatusIndicatorModel)
    M_MODEL_PROPERTY(QVariant, value, Value, true, QVariant())
    M_MODEL_PROPERTY(bool, animate, Animate, true, false)
};
class PhoneNetworkSignalStrengthStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PhoneNetworkSignalSt

};
class PhoneNetworkTypeStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PhoneNetworkTypeStatusIndicatorModel)
};
class PhoneNetworkStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PhoneNetworkStatusIndicatorModel)
};
class BatteryStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(BatteryStatusIndicatorModel)
};
class AlarmStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(AlarmStatusIndicatorModel)
};
class BluetoothStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(BluetoothStatusIndicatorModel)
};
class GPSStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(GPSStatusIndicatorModel)
};
class PresenceStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PresenceStatusIndicatorModel)
};
class InternetConnectionStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(InternetConnectionStatusIndicatorModel)
};
class InputMethodStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(InputMet
namespace FM3D {
	template<class E>
	class EventHandlerBase {
	public:
		virtual void FireEvent(E* e) = 0;
	};
	template<class H, class E>
	class MethodEventHandler : EventHandlerBase<E> {
	protected:
		H* m_handler;
		void (H::*m_target)(E*);
	public:
		void FireEvent(E* e) override {
			((*m_handler).*m_target)(e);
		}
		MethodEventHandler(H* handler, void (H::*target)(E*)) : m_handler(handler), m_target(target) {
		}
	};
	template<class E>
	class FuncEventHandler : EventHandlerBase<E> {
	protected:
		void (*m_target)(E*);
	public:
		void FireEvent(E* e) override {
			m_target(e);
		}
		FuncEventHandler(void (*target)(E*)) : m_target(target) {
		}
	};
	template<class E>
	class EventSource {
		std::vector<EventHandlerBase<E>*> m_handler;
	public:
		~EventSource() {
			for (EventHandlerBase<E>*& e : m_handler) {
				delete e;
			}
		}
		void FireEvent(E* e) {
			for (EventHandlerBase<E>*& h : m_handler) {
				h->FireEvent(e);
			}
		}
		template<class H>
		void AddHandler(H* handler, v
namespace media {
namespace mp4 {
namespace {
const SampleToGroupEntry kCompactSampleToGroupTable[] =
    {{10, 8}, {9, 5}, {25, 7}, {48, 63}, {8, 2}};
class SampleToGroupIteratorTest : public testing::Test {
 public:
  SampleToGroupIteratorTest() {
    for (size_t i = 0; i < arraysize(kCompactSampleToGroupTable); ++i) {
      for (uint32 j = 0; j < kCompactSampleToGroupTable[i].sample_count; ++j) {
        sample_to_group_table_.push_back(
            kCompactSampleToGroupTable[i].group_description_index);
      }
    }
    sample_to_group_.entries.assign(
        kCompactSampleToGroupTable,
        kCompactSampleToGroupTable + arraysize(kCompactSampleToGroupTable));
    sample_to_group_iterator_.reset(
        new SampleToGroupIterator(sample_to_group_));
  }
 protected:
  std::vector<uint32> sample_to_group_table_;
  SampleToGroup sample_to_group_;
  scoped_ptr<SampleToGroupIterator> sample_to_group_iterator_;
 private:
  DISALLOW_COPY_AND_ASSIGN(SampleToGroupIteratorTest);
};
TEST_
Cima_adpcm_wav_decode::Cima_adpcm_wav_decode()
	m_data = NULL;
Cima_adpcm_wav_decode::~Cima_adpcm_wav_decode()
	delete[] m_data;
void Cima_adpcm_wav_decode::load(const byte* r, int cb_s, int c_channels, int chunk_size)
	int c_chunks = (cb_s + chunk_size - 1) / chunk_size ;
	mc_samples = (cb_s - sizeof(t_ima_adpcm_chunk_header) * c_channels * c_chunks << 1) + c_chunks * c_channels;
	delete[] m_data;
	mcb_data = mc_samples << 1;
	m_data = new short[mc_samples];
	short* w = m_data;
	int cs_remaining = mc_samples;
	while (cs_remaining)
	{
		if (c_channels == 1)
		{
			const t_ima_adpcm_chunk_header& chunk_header = *reinterpret_cast<const t_ima_adpcm_chunk_header*>(r);
			r += sizeof(t_ima_adpcm_chunk_header);
			*w++ = chunk_header.sample;
			cs_remaining--;
			int cs_chunk = min(cs_remaining, chunk_size - sizeof(t_ima_adpcm_chunk_header) << 1);
			aud_decode d;
			d.init(chunk_header.index, chunk_header.sample);
			d.decode_chunk(r, w, cs_chunk);
			r += cs_chunk >> 1;
			w += cs_chunk;
	

		}
		else
		{
			assert(c_channels == 2);
			const t_ima_adpcm_chunk_header& left_chunk_header = *reinterpret_cast<const t_ima_adpcm_chunk_header*>(r);
			r += sizeof(t_ima_adpcm_chunk_header);
			*w++ = left_chunk_header.sample;
			cs_remaining--;
			const t_ima_adpcm_chunk_header& right_chunk_header = *reinterpret_cast<const t_ima_adpcm_chunk_header*>(r);
			r += sizeof(t_ima_adpcm_chunk_header);
			*w++ = right_chunk_header.sample;
			cs_remaining--;
			int cs_chunk = min(cs_remaining, chunk_size - (sizeof(t_ima_adpcm_chunk_header) << 1) << 1);
			aud_decode left_d, right_d;
			left_d.init(left_chunk_header.index, left_chunk_header.sample);
			right_d.init(right_chunk_header.index, right_chunk_header.sample);
			while (cs_chunk >= 16)
			{
				short left_t[8], right_t[8];
				left_d.decode_chunk(r, left_t, 8);
				r += 4;
				right_d.decode_chunk(r, right_t, 8);
				r += 4;
				for (int i = 0; i < 8; i++)
				{
					*w++ = left_t[i];
					*w++ = right_t[i];
				}
				cs_chunk -= 1
Controller::Controller(MemRepository* repo){
	this->repo=repo;
void Controller::add(const Expense& e) throw (RepositoryException){
	try {
		this->val.validate(e);
		this->repo->add(e);
	} catch (RepositoryException &s){
		throw RepositoryException(s.getMsg());
	}
vector<Expense*> Controller::getAll()const{
	return this->repo->getAll();
int Controller::size()const{
	return this->repo->size();
Controller::~Controller(){
	delete this->repo;
void Controller::remove(int id){
	this->repo->remove(id);
void Controller::update(const int id,Expense& e) throw (RepositoryException){
	try{
		this->val.validate(e);
		this->repo->update(id,e);
	} catch (RepositoryException &s){
		throw RepositoryException(s.getMsg());
	}
vector<Expense*> Controller::sortByAmountA(){
	return this->repo->sortByAmountA();
vector<Expense*> Controller::sortByAmountD(){
	return this->repo->sortByAmountD();
vector<Expense*> Controller::sortByTypeA(){
	return this->repo->sortByTypeA();
vector<Expense*> Controller::sortByType
typedef struct _stream_t stream_t;
typedef struct  
	uint32 (__fastcall *readData)(void *object, void *buffer, uint32 len);
	uint32 (__fastcall *writeData)(void *object, void *buffer, uint32 len);
	uint32 (__fastcall *getSize)(void *object);
	void (__fastcall *setSize)(void *object, uint32 size);
	uint32 (__fastcall *getSeek)(void *object);
	void (__fastcall *setSeek)(void *object, sint32 seek, bool relative);
	void (__fastcall *initStream)(void *object, stream_t *stream);
	void (__fastcall *destroyStream)(void *object, stream_t *stream);
  uint32 *readData(void *object, void *buffer, uint32 len);
  uint32 *writeData(void *object, void *buffer, uint32 len);
  uint32 *getSize(void *object);
  void *setSize(void *object, uint32 size);
  uint32 *getSeek(void *object);
  void *setSeek(void *object, sint32 seek, bool relative);
  void *initStream(void *object, stream_t *stream);
  void *destroyStream(void *object, stream_t *stream);
	bool allowCaching;
}streamSettings_t;
typedef struct _str

	void *object;
	streamSettings_t *settings;
	uint8 bitBuffer[8];
	uint8 bitIndex;
	uint8 bitReadBuffer[8];
	uint8 bitReadBufferState;
	uint8 bitReadIndex;
}stream_t;
stream_t*	stream_create	(streamSettings_t *settings, void *object);
void		stream_destroy	(stream_t *stream);
char stream_readS8(stream_t *stream);
short stream_readS16(stream_t *stream);
int stream_readS32(stream_t *stream);
uint8 stream_readU8(stream_t *stream);
uint16 stream_readU16(stream_t *stream);
uint32 stream_readU32(stream_t *stream);
unsigned long long stream_readU64(stream_t *stream);
float stream_readFloat(stream_t *stream);
uint32 stream_readData(stream_t *stream, void *data, int len);
void stream_writeS8(stream_t *stream, char value);
void stream_writeS16(stream_t *stream, short value);
void stream_writeS32(stream_t *stream, int value);
void stream_writeU8(stream_t *stream, uint8 value);
void stream_writeU16(stream_t *stream, uint16 value);
void stream_writeU32(stream_t *stream, uint32 value);
void stream_wr
namespace masterclient {
CServiceLocator& CServiceLocator::get() {
	static CServiceLocator serv;
	return serv;
irr::scene::ISceneManager* CServiceLocator::getSceneManager() const {
	if (m_device == NULL) return NULL;
	return m_device->getSceneManager();
irr::IrrlichtDevice* CServiceLocator::getDevice() const {
	if (m_device == NULL) return NULL;
	return m_device;
irr::video::IVideoDriver* CServiceLocator::getDriver() const {
	if (m_device == NULL) return NULL;
	return m_device->getVideoDriver();
irr::scene::ISceneNode* CServiceLocator::getRootSceneNode() const {
	if (this->getSceneManager() != NULL){
		return this->getSceneManager()->getRootSceneNode();
	}
	return NULL;
irr::u32 CServiceLocator::getTime() const {
	if (m_device == NULL) return 0;
	return m_device->getTimer()->getRealTime();
CServiceLocator::CServiceLocator() {
	m_device = NULL;
CServiceLocator::~CServiceLocator() {
	m_device = NULL;
void CServiceLocator::setDevice(irr::IrrlichtDevice* _device) {
	m_device = _device;
} /
namespace Arabica
namespace SAX
/**
 * Provide an optional convenience implementation of Locator.
 *
 * <p>This class is available mainly for application writers, who
 * can use it to make a persistent snapshot of a locator at any
 * point during a document parse:</p>
 *
 * <pre>
 * Locator locator;
 * LocatorImpl startloc;
 *
 * void setLocator(const Locator& locator)
 * {
 *   this.locator = &locator;
 * }
 *
 * void startDocument ()
 * {
 *   startloc = locator;
 * }
 *</pre>
 *
 * <p>Normally, parser writers will not use this class, since it
 * is more efficient to provide location information only when
 * requested, rather than constantly updating a Locator object.</p>
 *
 * @since SAX 1.0
 * @author Jez Higgins,
 *         <a href="mailto:jez@jezuk.co.uk">jez@jezuk.co.uk</a>
 * @version 2.0
 * @see Locator Locator
 */
template<class string_type, class string_adaptor>
class LocatorImpl : public Locator<string_type, string_adaptor>
public:
  typedef Locator<string_type, string_adap

  
  LocatorImpl() : 
    publicId_(), 
    systemId_(), 
    lineNumber_(-1), 
    columnNumber_(-1) 
  { 
  LocatorImpl(const LocatorT& rhs) : 
    publicId_(rhs.getPublicId()), 
    systemId_(rhs.getSystemId()), 
    lineNumber_(rhs.getLineNumber()), 
    columnNumber_(rhs.getColumnNumber()) 
  { 
  virtual ~LocatorImpl() { }
  LocatorImpl& operator=(const LocatorT& rhs)
  {
    publicId_ = rhs.getPublicId();
    systemId_ = rhs.getSystemId(); 
    lineNumber_ = rhs.getLineNumber();
    columnNumber_ = rhs.getColumnNumber();
  /**
   * Return the saved public identifier.
   *
   * @return The public identifier as a string, or an empty string if none
   *         is available.
   */
  virtual string_type getPublicId() const { return publicId_; }
  /**
   * Return the saved system identifier.
   *
   * @return The system identifier as a string, or an empty string if none
   *         is available.
   */
  virtual string_type getSystemId() const { return systemId_; }
  /**
   * Return

   *
   * @return The line number as an integer, or -1 if none is available.
   */
  virtual size_t getLineNumber() const { return lineNumber_; }
  /**
   * Return the saved column number (1-based).
   *
   * @return The column number as an integer, or -1 if none is available.
   */
  virtual size_t getColumnNumber() const { return columnNumber_; }
  /**
   * Set the public identifier for this locator.
   *
   * @param publicId The new public identifier, or an empty string 
   *        if none is available.
   */
  void setPublicId(const string_type& publicId) { publicId_ = publicId; }
  /**
   * Set the system identifier for this locator.
   *
   * @param systemId The new system identifier, or an empty string 
   *        if none is available.
   */
  void setSystemId(const string_type& systemId) { systemId_ = systemId; }
  /**
   * Set the line number for this locator (1-based).
   *
   * @param lineNumber The line number, or -1 if none is available.
   */
  void setLineNumber(size_
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/**
 * Copyright (c) 2014,  Regents of the University of California.
 *
 * This file is part of NDN repo-ng (Next generation of NDN repository).
 * See AUTHORS.md for complete list of repo-ng authors and contributors.
 *
 * repo-ng is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * repo-ng is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 */
namespace repo {
namespace tlv {
using namespace ndn::tlv;
enum {
  RepoCommandParameter = 201,
  StartBlockId         = 204,
  EndBlockId   
/*!
	Copyright 2013 Autodesk, Inc.  All rights reserved.
	Use of this software is subject to the terms of the Autodesk license agreement
	provided at the time of installation or download, or which otherwise accompanies
	this software in either electronic or hard copy form.
*/
CAbcOCameraSample::CAbcOCameraSample()
void CAbcOCameraSample::SetFocalLength( double in_dFocalLength )
	m_CameraSample.setFocalLength( in_dFocalLength );
void CAbcOCameraSample::SetAperture( double in_dHorizAperture, double in_dVertAperture )
	m_CameraSample.setHorizontalAperture( in_dHorizAperture );
	m_CameraSample.setVerticalAperture( in_dVertAperture );
void CAbcOCameraSample::SetFilmOffset( double in_dHorizOffset, double in_dVertOffset )
	m_CameraSample.setHorizontalFilmOffset( in_dHorizOffset );
	m_CameraSample.setVerticalFilmOffset( in_dVertOffset );
void CAbcOCameraSample::SetLensSqueezeRatio( double in_dRatio )
	m_CameraSample.setLensSqueezeRatio( in_dRatio );
void CAbcOCameraSample::SetOverscan( double 

	m_CameraSample.setOverScanLeft( in_dLeft );
	m_CameraSample.setOverScanRight( in_dRight );
	m_CameraSample.setOverScanTop( in_dTop );
	m_CameraSample.setOverScanBottom( in_dBottom );
void CAbcOCameraSample::SetFStop( double in_dFStop )
	m_CameraSample.setFStop( in_dFStop );
void CAbcOCameraSample::SetFocusDistance( double in_dFocusDistance )
	m_CameraSample.setFocusDistance( in_dFocusDistance );
void CAbcOCameraSample::SetShutterOpen( double in_dTime )
	m_CameraSample.setShutterOpen( in_dTime );
void CAbcOCameraSample::SetShutterClose( double in_dTime )
	m_CameraSample.setShutterClose( in_dTime );
void CAbcOCameraSample::SetClippingPlanes( double in_dNear, double in_dFar )
	m_CameraSample.setNearClippingPlane( in_dNear );
	m_CameraSample.setFarClippingPlane( in_dFar );
void CAbcOCameraSample::SetChildBounds( const Alembic::Abc::Box3d& in_BBox )
	m_CameraSample.setChildBounds( in_BBox );
const Alembic::AbcGeom::CameraSample& CAbcOCameraSample::GetSample() const
	return m_CameraSample;
namespace game
    UnitModel::UnitModel(std::string modelName, std::string missileModelName, float maxHealth, float speed, std::string texture, bool hasAiFunction, bool hasPopFunction) : EntityModel(speed, texture, hasAiFunction, hasPopFunction)
    {
        m_maxHealth = maxHealth;
        m_missileModel = game::getMissileModel(missileModelName);
        registerUnitModel(modelName, this);
    }
    float UnitModel::getMaxHealth()
    {
        return m_maxHealth;
    }
    MissileModel* UnitModel::getMissileModel()
    {
        return m_missileModel;
    }
    std::map<std::string, UnitModel*> unitModels;
    void registerUnitModel(std::string modelName, UnitModel* model)
    {
        unitModels[modelName] = model;
    }
    UnitModel* getUnitModel(std::string modelName)
    {
        return unitModels[modelName];
    }
    void freeUnitModels()
    {
        for (std::map<std::string, UnitModel*>::iterator it = unitModels.begin(); it != unitModels.end(); it++)
            delete 
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoUser::RepoUser(const std::string &username,
                               const std::string &cleartextPassword,
                               const string &firstName,
                               const string &lastName,
                               const string &email,
                               const std::list<std::pair<st

                               const std::list<std::pair<std::string, std::string> > &roles,
                               const std::list<std::pair<string, string> > &groups,
                               const std::list<std::pair<string, string> > &apiKeys,
                               const RepoImage &avatar)
    : RepoBSON()
    mongo::BSONObjBuilder builder;
    RepoTranscoderBSON::append(
                REPO_LABEL_ID,
                boost::uuids::random_generator()(),
                builder);
    builder << REPO_LABEL_USER << username;
    mongo::BSONObjBuilder credentialsBuilder;
    credentialsBuilder << REPO_LABEL_CLEARTEXT << cleartextPassword;
    builder << REPO_LABEL_CREDENTIALS << credentialsBuilder.obj();
    mongo::BSONObjBuilder customDataBuilder;
    if (!firstName.empty())
        customDataBuilder << REPO_LABEL_FIRST_NAME << firstName;
    if (!lastName.empty())
        customDataBuilder << REPO_LABEL_LAST_NAME << lastName;
    if (!email.empty())
        cu

    if (!projects.empty())
        customDataBuilder.appendArray(REPO_LABEL_PROJECTS, toArray(projects, REPO_LABEL_OWNER, REPO_LABEL_PROJECT));
    if (!groups.empty())
        customDataBuilder << REPO_LABEL_GROUPS << toArray(groups, REPO_LABEL_OWNER, REPO_LABEL_GROUP);
    if (!apiKeys.empty())
        customDataBuilder << REPO_LABEL_API_KEYS << toArray(apiKeys, REPO_LABEL, REPO_LABEL_KEY);
    if (avatar.isOk())
        customDataBuilder << REPO_LABEL_AVATAR << avatar;
    builder << REPO_LABEL_CUSTOM_DATA << customDataBuilder.obj();
    if (!roles.empty())
        builder.appendArray(REPO_LABEL_ROLES, toArray(roles, REPO_LABEL_DB, REPO_LABEL_ROLE));
	mongo::BSONObj builtObj = builder.obj();
	RepoBSON::addFields(builtObj);
std::list<std::pair<std::string, std::string> > repo::core::RepoUser::getAPIKeysList() const
    mongo::BSONElement arrayElement = getEmbeddedElement(REPO_LABEL_CUSTOM_DATA,
                                                         REPO_LABEL_API_KEYS);
    return

repo::core::RepoImage repo::core::RepoUser::getAvatar() const
    RepoImage image;
    mongo::BSONElement bse = this->getCustomDataField(REPO_LABEL_AVATAR);
    if (!bse.eoo())
        image = RepoImage(bse.embeddedObject());
    return image;
std::list<std::pair<std::string, std::string> > repo::core::RepoUser::getProjectsList() const
    mongo::BSONElement arrayElement = getEmbeddedElement(REPO_LABEL_CUSTOM_DATA,
                                                         REPO_LABEL_PROJECTS);
    return RepoBSON::getArrayStringPairs(arrayElement, REPO_LABEL_OWNER, REPO_LABEL_PROJECT);
std::list<std::pair<std::string, std::string> > repo::core::RepoUser::getGroupsList() const
    mongo::BSONElement arrayElement = getEmbeddedElement(REPO_LABEL_CUSTOM_DATA,
                                                         REPO_LABEL_GROUPS);
    return RepoBSON::getArrayStringPairs(arrayElement, REPO_LABEL_OWNER, REPO_LABEL_GROUP);
std::list<std::pair<std::string, std::string> > repo::core::RepoU
namespace filerepo
RepoPath::RepoPath( const tstring &path )
    : repo_dir_(path)
RepoPath::RepoPath( const RepoPath &rp )
    *this = rp;
RepoPath::RepoPath()
tstring RepoPath::GetIndexFilePath()
    return AppendPath(repo_dir_, _T("index"));
tstring RepoPath::GetTagsDirPath()
    return AppendPath(repo_dir_, _T("tags\\"));
tstring RepoPath::GetVersionFilePath()
    return AppendPath(repo_dir_, _T("version"));
tstring RepoPath::GetManifestFilePath()
    return AppendPath(repo_dir_, _T("manifest"));
tstring RepoPath::GetTaggedIndexFilePath( int n )
    char buf[8] = {0};
    _itoa_s(n, buf, 10);
    std::string index = "index_";
    index += buf;
    tstring windex = utf8_to_16(index.c_str());
    return AppendPath(GetTagsDirPath(), windex);
RepoPath &RepoPath::operator=( const tstring &path )
    repo_dir_ = path;
    return *this;
RepoPath &RepoPath::operator=( const RepoPath &rp )
    repo_dir_ = rp.repo_dir_;
    return *this;
tstring RepoPath::Data() const
    return repo_dir_;
R
void BaseBookmarkModelObserver::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BaseBookmarkModelObserver::BookmarkModelBeingDeleted(
    BookmarkModel* model) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
                                                  int index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeRemoved(
    BookmarkModel* model,
    const BookmarkNode* parent,
    int old_index,
    const BookmarkNode* node,
    const std::set<GURL>& removed_urls) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkAllNodesRemoved
/*
 * $Id$
 *
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",6);
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0) {
    return 0;
  }
  return value._retn();
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",6);
  return this->map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0) {
    value = new RepoIdSet();
    if (OpenDDS::DCPS::bind(map_, key, value) != 0) {
      ACE_ERROR((LM_ERROR,
                 "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                 "the RepoIdSetMap.\n"));
      return 0;
 
/*
 * Copyright (c) 2007-2008 Atheros Communications, Inc.
 * All rights reserved.
 *
 */
extern "C" {
    SW_API_DEF(SW_API_PT_DUPLEX_GET, athena_port_duplex_get), \
    SW_API_DEF(SW_API_PT_DUPLEX_SET, athena_port_duplex_set), \
    SW_API_DEF(SW_API_PT_SPEED_GET, athena_port_speed_get), \
    SW_API_DEF(SW_API_PT_SPEED_SET, athena_port_speed_set), \
    SW_API_DEF(SW_API_PT_AN_GET, athena_port_autoneg_status_get), \
    SW_API_DEF(SW_API_PT_AN_ENABLE, athena_port_autoneg_enable), \
    SW_API_DEF(SW_API_PT_AN_RESTART, athena_port_autoneg_restart), \
    SW_API_DEF(SW_API_PT_AN_ADV_GET, athena_port_autoneg_adv_get), \
    SW_API_DEF(SW_API_PT_AN_ADV_SET, athena_port_autoneg_adv_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_SET, athena_port_igmps_status_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_GET, athena_port_igmps_status_get), \
    SW_API_DEF(SW_API_PT_POWERSAVE_SET, athena_port_powersave_set), \
    SW_API_DEF(SW_API_PT_POWERSAVE_GET, athena_port_powersave_get), \
    SW_API_DEF(

    SW_API_DEF(SW_API_PT_HIBERNATE_GET, athena_port_hibernate_get), 
    SW_API_DESC(SW_API_PT_DUPLEX_GET)  \
    SW_API_DESC(SW_API_PT_DUPLEX_SET)  \
    SW_API_DESC(SW_API_PT_SPEED_GET)  \
    SW_API_DESC(SW_API_PT_SPEED_SET)  \
    SW_API_DESC(SW_API_PT_AN_GET)  \
    SW_API_DESC(SW_API_PT_AN_ENABLE)  \
    SW_API_DESC(SW_API_PT_AN_RESTART) \
    SW_API_DESC(SW_API_PT_AN_ADV_GET) \
    SW_API_DESC(SW_API_PT_AN_ADV_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_GET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_SET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_GET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_SET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_GET)    
    SW_API_DEF(SW_API_VLAN_ADD, athena_vlan_create), \
    SW_API_DEF(SW_API_VLAN_DEL, athena_vlan_delete), \
    SW_API_DEF(SW_API_VLAN_MEM_UPDATE, athena_vlan_member_update), \
    SW_API_DEF(SW_API_VLAN_FIND, athena_vlan_find), \
    SW_API_DEF(SW_API_VLAN_NEXT, athena_vlan_next), \
    SW_API_DEF(SW_API_

    SW_API_DESC(SW_API_VLAN_ADD)  \
    SW_API_DESC(SW_API_VLAN_DEL)  \
    SW_API_DESC(SW_API_VLAN_MEM_UPDATE) \
    SW_API_DESC(SW_API_VLAN_FIND) \
    SW_API_DESC(SW_API_VLAN_NEXT) \
    SW_API_DESC(SW_API_VLAN_APPEND)
    SW_API_DEF(SW_API_PT_ING_MODE_GET, athena_port_1qmode_get), \
    SW_API_DEF(SW_API_PT_ING_MODE_SET, athena_port_1qmode_set), \
    SW_API_DEF(SW_API_PT_EG_MODE_GET, athena_port_egvlanmode_get), \
    SW_API_DEF(SW_API_PT_EG_MODE_SET, athena_port_egvlanmode_set), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_ADD, athena_portvlan_member_add), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_DEL, athena_portvlan_member_del), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_UPDATE, athena_portvlan_member_update), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_GET, athena_portvlan_member_get), \
    SW_API_DESC(SW_API_PT_ING_MODE_GET)  \
    SW_API_DESC(SW_API_PT_ING_MODE_SET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_GET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_SET)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_ADD) \
    SW_AP

    SW_API_DESC(SW_API_PT_VLAN_MEM_UPDATE)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_GET)
    SW_API_DEF(SW_API_FDB_ADD, athena_fdb_add), \
    SW_API_DEF(SW_API_FDB_DELALL, athena_fdb_del_all), \
    SW_API_DEF(SW_API_FDB_DELPORT,athena_fdb_del_by_port), \
    SW_API_DEF(SW_API_FDB_DELMAC, athena_fdb_del_by_mac), \
    SW_API_DEF(SW_API_FDB_FIRST,  athena_fdb_first), \
    SW_API_DEF(SW_API_FDB_NEXT,   athena_fdb_next),
    SW_API_DESC(SW_API_FDB_ADD)  \
    SW_API_DESC(SW_API_FDB_DELALL)  \
    SW_API_DESC(SW_API_FDB_DELPORT) \
    SW_API_DESC(SW_API_FDB_DELMAC)  \
    SW_API_DESC(SW_API_FDB_FIRST)   \
    SW_API_DESC(SW_API_FDB_NEXT)
    SW_API_DEF(SW_API_PT_MIB_GET, athena_get_mib_info),
    SW_API_DESC(SW_API_PT_MIB_GET)
    SW_API_DEF(SW_API_PHY_GET, athena_phy_get), \
    SW_API_DEF(SW_API_PHY_SET, athena_phy_set), \
    SW_API_DEF(SW_API_REG_GET, athena_reg_get), \
    SW_API_DEF(SW_API_REG_SET, athena_reg_set), \
    SW_API_DEF(SW_API_REG_FIELD_GET, athena_reg_field_get), \
    S

    SW_API_DESC(SW_API_PHY_GET)  \
    SW_API_DESC(SW_API_PHY_SET)  \
    SW_API_DESC(SW_API_REG_GET)  \
    SW_API_DESC(SW_API_REG_SET)  \
    SW_API_DESC(SW_API_REG_FIELD_GET) \
    SW_API_DESC(SW_API_REG_FIELD_SET)
    SW_API_DEF(SW_API_SWITCH_RESET, athena_reset), \
    SW_API_DEF(SW_API_SSDK_CFG, hsl_ssdk_cfg), \
    MIB_API \
    PORTCONTROL_API \
    PORTVLAN_API \
    VLAN_API \
    FDB_API \
    REG_API \
    SW_API_DEF(SW_API_MAX, NULL)
    SW_PARAM_DEF(SW_API_SWITCH_RESET, SW_UINT32, 4, SW_PARAM_IN, "Dev ID"), \
    SW_PARAM_DEF(SW_API_SSDK_CFG, SW_UINT32, 4, SW_PARAM_IN, "Dev ID"), \
    SW_PARAM_DEF(SW_API_SSDK_CFG, SW_SSDK_CFG, sizeof(ssdk_cfg_t), SW_PARAM_PTR|SW_PARAM_OUT, "ssdk configuration"), \
    MIB_API_PARAM \
    PORTCONTROL_API_PARAM \
    PORTVLAN_API_PARAM \
    VLAN_API_PARAM \
    FDB_API_PARAM \
    REG_API_PARAM \
    SW_PARAM_DEF(SW_API_MAX, SW_UINT32, 4, SW_PARAM_IN, "Dev ID"),
    REG_API \
    SW_API_DEF(SW_API_MAX, NULL),
    REG_API_PARAM \
    SW_P
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags
 *
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType
  LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOA

  LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
  LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_NORMAL_ALLOW_MIXED_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_ALLOW_MIXED_CONTENT | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_

  LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_RELOAD_ALLOW_MIXED_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_ALLOW_MIXED_CONTENT | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
  LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
  LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
  LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
  LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAG

  LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
  LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_REPLACE_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  /**
   * Load type for an error page. These loads are never triggered by users of
   * Docshell. Instead, Docshell triggers the load itself when a
   * consumer-triggered load failed.
   */
  LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool
IsValidLoadType(uint32_t aLoadType)
  switch (aLoadType) {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
 
/*
 * ClippingPlaneLocator - Constructor for ClippingPlaneLocator class.
 *
 * parameter locatorTool - Vrui::LocatorTool *
 * parameter ExampleVTKReader - ExampleVTKReader *
 */
ClippingPlaneLocator::ClippingPlaneLocator(Vrui::LocatorTool * locatorTool,
		ExampleVTKReader* ExampleVTKReader) :
	BaseLocator(locatorTool, ExampleVTKReader), clippingPlane(0) {
	/* Find a clipping plane index for this locator: */
	ClippingPlane * clippingPlanes = ExampleVTKReader->getClippingPlanes();
	for (int i=0; i<ExampleVTKReader->getNumberOfClippingPlanes(); ++i)
		if (!clippingPlanes[i].isAllocated()) {
			clippingPlane=&clippingPlanes[i];
			break;
		}
	/* Allocate the clipping plane: */
	if (clippingPlane!=0) {
		clippingPlane->setActive(false);
		clippingPlane->setAllocated(true);
	}
/*
 * ~ClippingPlaneLocator - Destructor for ClippingPlaneLocator class.
 */
ClippingPlaneLocator::~ClippingPlaneLocator(void) {
	if (clippingPlane!=0) {
		clippingPlane->setActive(false);
		clippingPlane->setAllocated

	}
/*
 * motionCallback
 *
 * parameter callbackData - Vrui::LocatorTool::MotionCallbackData *
 */
void ClippingPlaneLocator::motionCallback(
		Vrui::LocatorTool::MotionCallbackData* callbackData) {
	if (clippingPlane!=0&&clippingPlane->isActive()) {
		Vrui::Vector planeNormal=
				callbackData->currentTransformation.transform(Vrui::Vector(0,
						1, 0));
		Vrui::Point planePoint=callbackData->currentTransformation.getOrigin();
		clippingPlane->setPlane(Vrui::Plane(planeNormal, planePoint));
	}
/*
 * buttonPressCallback
 *
 * parameter callbackData - Vrui::LocatorTool::ButtonPressCallbackData *
 */
void ClippingPlaneLocator::buttonPressCallback(
		Vrui::LocatorTool::ButtonPressCallbackData* callbackData) {
	if (clippingPlane!=0)
		clippingPlane->setActive(true);
/*
 * buttonReleaseCallback
 *
 * parameter callbackData - Vrui::LocatorTool::ButtonReleaseCallbackData *
 */
void ClippingPlaneLocator::buttonReleaseCallback(
		Vrui::LocatorTool::ButtonReleaseCallbackData* callbackData) {
	
using namespace Config;
namespace Graphics
    /**
      * Constructeur
      */
    BuildingChunkItem::BuildingChunkItem(Chunk::Chunk *chunk) :
    _chunk(chunk)
    {
        _boundingRect = QRectF(0,0,BaseConfig::CHUNK_SIZE * BaseConfig::TILE_SIZE,BaseConfig::CHUNK_SIZE * BaseConfig::TILE_SIZE);
        _tiles.append(Provider::getBuilding("none").toImage());
        _tiles.append(Provider::getBuilding("house").toImage());
        _tiles.append(Provider::getBuilding("farmland").toImage());
        _tiles.append(Provider::getBuilding("road").toImage());
        int x,y;
        if (_chunk->getX() < 0)
        {
            _xChunk = (_chunk->getX() - BaseConfig::CHUNK_SIZE + 1);
            x = _xChunk * BaseConfig::TILE_SIZE;
        }
        else
        {
            _xChunk = _chunk->getX();
            x = _chunk->getX() * BaseConfig::TILE_SIZE;
        }
        if (_chunk->getY() < 0)
        {
            _yChunk = _chunk->getY() - BaseConfig::CHUNK_SIZE + 1;
            y = 

        }
        else
        {
            _yChunk = _chunk->getY();
            y = (_yChunk + 1) *  BaseConfig::TILE_SIZE;
        }
        setPos(x,y);
    }
    /**
      * Renvoie le boundingRect de l'objet
      */
    QRectF BuildingChunkItem::boundingRect() const
    {
        return _boundingRect;
    }
    /**
      * Change le chunk de l'objet.
      * Part du principe qu'il est à la même position
      */
    void BuildingChunkItem::setChunk(Chunk::Chunk *chunk)
    {
        _chunk = chunk;
        update();
    }
    /**
      * Repaint l'objet
      */
    void BuildingChunkItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
    {
        Q_UNUSED(option)
        Q_UNUSED(widget)
        qint32 current;
        for (int i = _xChunk; i < _xChunk + BaseConfig::CHUNK_SIZE; i++)
        {
            for (int j = _yChunk; j < _yChunk + BaseConfig::CHUNK_SIZE; j++)
            {
                current = _chunk->getBuilding(i,j).getType
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil -*- */
/*
 * Copyright (c) 2013, Regents of the University of California
 *                     Alexander Afanasyev
 *
 * BSD license, See the LICENSE file for more information
 *
 * Author: Alexander Afanasyev <alexander.afanasyev@ucla.edu>
 */
namespace ndn {
KeyLocator::KeyLocator ()
  : m_type (NOTSET)
  , m_data (0)
KeyLocator::KeyLocator (const KeyLocator &keyLocator)
  : m_type (keyLocator.getType ())
  , m_data (0)
  switch (m_type)
    {
    case NOTSET:
      break;
    case KEY:
      m_data = new Blob (keyLocator.getKey ());
      break;
    case CERTIFICATE:
      m_data = new Blob (keyLocator.getCertificate ());
      break;
    case KEYNAME:
      m_data = new Name (keyLocator.getKeyName ());
      break;
    }
KeyLocator::~KeyLocator ()
  deleteData ();
KeyLocator &
KeyLocator::operator = (const KeyLocator &keyLocator)
  if (this == &keyLocator)
    return *this;
  deleteData ();
  m_type = keyLocator.getType ();

  
  switch (m_type)
    {
    case NOTSET:
      break;
    case KEY:
      m_data = new Blob (keyLocator.getKey ());
      break;
    case CERTIFICATE:
      m_data = new Blob (keyLocator.getCertificate ());
      break;
    case KEYNAME:
      m_data = new Name (keyLocator.getKeyName ());
      break;
    }
  return *this;
void
KeyLocator::deleteData ()
  switch (m_type)
    {
      break;
    case KEY:
      delete reinterpret_cast<Blob*> (m_data);
      break;
    case CERTIFICATE:
      delete reinterpret_cast<Blob*> (m_data);
      break;
    case KEYNAME:
      delete reinterpret_cast<Name*> (m_data);
      break;
    }
void
KeyLocator::setType (KeyLocator::Type type)
  if (m_type == type)
    return;
  deleteData ();
  m_type = type;
  
  switch (m_type)
    {
    case NOTSET:
      m_data = 0;
    case KEY:
      m_data = new Blob;
      break;
    case CERTIFICATE:
      m_data = new Blob;
      break;
    case KEYNAME:
      m_data = new Name;
      break;
    }
const Blob

KeyLocator::getKey () const
  if (m_type != KEY)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("getKey called, but KeyLocator is not of type KeyLocator::KEY"));
  return *reinterpret_cast<const Blob*> (m_data);
Blob &
KeyLocator::getKey ()
  if (m_type != KEY)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("getKey called, but KeyLocator is not of type KeyLocator::KEY"));
  return *reinterpret_cast<Blob*> (m_data);
void
KeyLocator::setKey (const Blob &key)
  if (m_type != KEY)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("setKey called, but KeyLocator is not of type KeyLocator::KEY"));
  *reinterpret_cast<Blob*> (m_data) = key;
const Blob &
KeyLocator::getCertificate () const
  if (m_type != CERTIFICATE)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("getCertificate called, but KeyLocator is not of type KeyLocator

  return *reinterpret_cast<const Blob*> (m_data);
Blob &
KeyLocator::getCertificate ()
  if (m_type != CERTIFICATE)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("getCertificate called, but KeyLocator is not of type KeyLocator::CERTIFICATE"));
  return *reinterpret_cast<Blob*> (m_data);
void
KeyLocator::setCertificate (const Blob &certificate)
  if (m_type != CERTIFICATE)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("setCertificate called, but KeyLocator is not of type KeyLocator::CERTIFICATE"));
  *reinterpret_cast<Blob*> (m_data) = certificate;
const Name &
KeyLocator::getKeyName () const
  if (m_type != KEYNAME)
    BOOST_THROW_EXCEPTION (error::KeyLocator ()
                           << error::msg ("getKeyName called, but KeyLocator is not of type KeyLocator::KEYNAME"));
  return *reinterpret_cast<const Name*> (m_data);
Name &
KeyLocator::getKeyName ()
  if (m_type != KEYNAME)
    BOOST_THROW
/************************************************************************************************
  Computation_Model.cpp
  Contributor(s): E. Zeynep Erson
  Created on:      31-Jul-2007
  Description:	Computation_Models define the way the mathematical models are solved. Based on the mathematical model
				description, following types of computation models can be chosen:
				1. Continous time:
					a. Euler method
					b. Runge-Kutta method
				2. Discrete time:
				3. Discrete event:
*************************************************************************************************/
using namespace computational_layer;
Computation_Model::Computation_Model(){
	is_DE = false;
Computation_Model::~Computation_Model(){
bool Computation_Model::get_is_DE(){
	return is_DE;
double Computation_Model::run_Computation(double variable, Mathematical_Model* m){
	return 0.;
Mathematical_Model* Computation_Model::get_model(){
	return this->model;
void Computation_Model::set_model(Mathematical_Model *mod
using namespace jlj::util::concurrent;
NAMESPACE_BEGIN(jlj)
NAMESPACE_BEGIN(nio)
NAMESPACE_BEGIN(reactor)
ChunkBufferPoolI::~ChunkBufferPoolI() 
	logger->log(Level::FINEST, L"ChunkBufferPoolI::~ChunkBufferPoolI()");
	while (0 < idle->size())
	{
		ChunkBuffer chunk = idle->poll();
		destroyBuffer(chunk);
	}
ChunkBufferPoolI::ChunkBufferPoolI()
: initialsize(0)
, maxsize(20000)
, inuse(0)
, idle(new LinkedBlockingQueueI<ChunkBuffer>())
, logger(Logger::getLogger(Reactor::REACTORS_LOGGER_NAME))
	for (int i = 0; i < initialsize; ++i)
	{
		idle->put(createBuffer(DEFAULTCAPACITY));
	}
ChunkBuffer ChunkBufferPoolI::createBuffer(int capacity)
	ChunkBuffer chunk = new ChunkBufferI();
	chunk->capacity = capacity;
	chunk->position = 0;
	chunk->limit = capacity;
	chunk->buffer = new char[capacity];
	return chunk;
void ChunkBufferPoolI::destroyBuffer(ChunkBuffer chunk)
	delete [] chunk->buffer;
	delete chunk;
void ChunkBufferPoolI::clearBuffer(ChunkBuffer chunk)
	if (0 != chunk)
	{
		chunk->positio

		chunk->limit = chunk->capacity;
	}
ChunkBuffer ChunkBufferPoolI::get() throw (InterruptedException)
	ChunkBuffer chunk = 0;
	try
	{
		chunk = idle->remove();
	}
	catch (const NoSuchElementException&)
	{}
	if (0 == chunk)
	{
		if (maxsize > inuse)
		{
			logger->log(Level::WARNING, L"ChunkBufferPool : " + String(idle->size() + inuse) + L", idle : " + String(idle->size()) + L", inuse : " + String(inuse->get()));
			chunk = createBuffer(DEFAULTCAPACITY);
		}
		else
		{
			logger->log(Level::SEVERE, L"ChunkBufferPool exhausted : " + String(maxsize));
			chunk = idle->take(); 
		}
	}
	++inuse;
	if (logger->isLoggable(Level::FINEST))
	{
		logger->log(Level::FINEST, L"ChunkBufferPool get : " + String(idle->size()) + L", inuse : " + String(inuse->get()));
	}
	return chunk;
void ChunkBufferPoolI::makeIdle(ChunkBuffer& chunk) 
	if (0 != chunk)
	{
		clearBuffer(chunk);
		idle->put(chunk);
		--inuse;
		chunk = 0;
		if (logger->isLoggable(Level::FINEST))
		{
			logger->log(Level::FINEST, L"Chunk
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocSh

    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_

    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_F

    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    case LOAD_HISTORY:
    case LOAD_RELOAD_NORMAL:
    case LOAD_RELOAD_BYPASS_CACHE:
    case LOAD_RELOAD_BYPASS_PROXY:
    case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    case LOAD_LINK:
    case LOAD_REFRESH:
    case LOAD_RELOAD_CHARSET_CHANGE:
    case LOAD_BYPASS_HISTORY:
    case LOAD_STOP_CONTENT:
    case LOAD_STOP_CONTENT_AND_REPLACE:
    case LOAD_PUSHSTATE:
    case LOAD_ERROR_PAGE:
        return true;
    }
/*
 * RandomGithub: gitRepo.hpp
 * Copyright (C) 2014 Kyle Givler
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 */
/**
 * @file gitRepo.hpp
 * @author Kyle Givler
 */
class GitRepo
public:
  
  void setRepoId(unsigned int id) {this->id = id;}
  void setOwnerLogin(std::string in) { this->ownerLogin = in; }
  void setOwnerHtmlUrl(std::string in) { this->ownerHtmlUrl = in; }
  void setRepoName(std::string in) { this->repoName = in; }
  void setRepoFullName(std::stri
ModelManager * ModelManager::m_modelManager;
ModelManager * ModelManager::getInstance ()
	if(!m_modelManager)
		m_modelManager = new ModelManager();
	return m_modelManager;
ModelManager::ModelManager()
	drawingTemporaryModel = NULL;
void ModelManager::setDrawingTemporaryModel (Model *value)
	this->drawingTemporaryModel = value;
Model * ModelManager::getDrawingTemporaryModel ()
	return this->drawingTemporaryModel;
void ModelManager::deleteDrawingTemporaryModel ()
	this->drawingTemporaryModel = NULL;
void ModelManager::commitDrawing ()
	this->m_modelList.append (drawingTemporaryModel);
	drawingTemporaryModel = NULL;
void ModelManager::insert(int index, Model *model)
	m_modelList.insert(index, model);
void ModelManager::removeAt(int index)
	m_modelList.removeAt(index);
void ModelManager::removeLast ()
	m_modelList.removeLast ();
int ModelManager::indexOf(Model *model)
	return m_modelList.indexOf(model);
int ModelManager::size()
	return m_modelList.size();
Model *ModelManager::at(int index
namespace base {
namespace trace_event {
class MemoryAllocatorDump;
class ProcessMemoryDump;
namespace skia {
class SK_API SkiaTraceMemoryDumpImpl : public SkTraceMemoryDump {
 public:
  SkiaTraceMemoryDumpImpl(
      base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
      base::trace_event::ProcessMemoryDump* process_memory_dump);
  SkiaTraceMemoryDumpImpl(
      const std::string& dump_name_prefix,
      base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
      base::trace_event::ProcessMemoryDump* process_memory_dump);
  ~SkiaTraceMemoryDumpImpl() override;
  void dumpNumericValue(const char* dumpName,
                        const char* valueName,
                        const char* units,
                        uint64_t value) override;
  void setMemoryBacking(const char* dumpName,
                        const char* backingType,
                        const char* backingObjectId) override;
  void setDiscardableMemoryBacking(
      const char* dumpName,
      c
API_PATH_CONST(account_requisites);
API_PATH_CONST(accounts);
API_PATH_CONST(accounts_flat);
API_PATH_CONST(add_application);
API_PATH_CONST(add_pointer);
API_PATH_CONST(attach_card);
API_PATH_CONST(autopayment_method);
API_PATH_CONST(autopayments);
API_PATH_CONST(bank_info);
API_PATH_CONST(banners);
API_PATH_CONST(bills_to_pay);
API_PATH_CONST(subscription_bills);
API_PATH_CONST(cancel_invoice);
API_PATH_CONST(close_wallet);
API_PATH_CONST(config);
API_PATH_CONST(confirm);
API_PATH_CONST(country_calling_codes);
API_PATH_CONST(create_autopayment);
API_PATH_CONST(create_regular_payment);
API_PATH_CONST(create_shared_object);
API_PATH_CONST(create_subscription);
API_PATH_CONST(currencies);
API_PATH_CONST(delete_autopayment);
API_PATH_CONST(delete_subscription);
API_PATH_CONST(delete_regular_payment);
API_PATH_CONST(delete_template);
API_PATH_CONST(deposition_point_clusters);
API_PATH_CONST(deposition_partners);
API_PATH_CONST(detach);
API_PATH_CONST(detach_card);
API_PATH_CONST(edit_auto

API_PATH_CONST(edit_regular_payment);
API_PATH_CONST(edit_subscription);
API_PATH_CONST(feedback_email_topics);
API_PATH_CONST(feedback_phones);
API_PATH_CONST(friends);
API_PATH_CONST(get_contacts_synchronization);
API_PATH_CONST(get_inn_captcha);
API_PATH_CONST(get_push_notification_subscriptions);
API_PATH_CONST(get_provider_subscriptions);
API_PATH_CONST(get_subscription_list);
API_PATH_CONST(group_commission);
API_PATH_CONST(group_pay);
API_PATH_CONST(group_pay_fine);
API_PATH_CONST(grouped_requests);
API_PATH_CONST(identify);
API_PATH_CONST(identify_short);
API_PATH_CONST(image);
API_PATH_CONST(invoice);
API_PATH_CONST(limits);
API_PATH_CONST(list_regular_payments);
API_PATH_CONST(log);
API_PATH_CONST(messages);
API_PATH_CONST(mobile_auth);
API_PATH_CONST(mobile_link_device);
API_PATH_CONST(mobile_save_pin);
API_PATH_CONST(mobile_session);
API_PATH_CONST(nearest_region);
API_PATH_CONST(operations);
API_PATH_CONST(pay);
API_PATH_CONST(pay_fine);
API_PATH_CONST(pay_template);
API_

API_PATH_CONST(payment_items);
API_PATH_CONST(payment_receipt);
API_PATH_CONST(payments);
API_PATH_CONST(personal_info);
API_PATH_CONST(ping);
API_PATH_CONST(pointers);
API_PATH_CONST(providers);
API_PATH_CONST(providers_groups);
API_PATH_CONST(questionnaire);
API_PATH_CONST(regions);
API_PATH_CONST(register_for_push_notification);
API_PATH_CONST(reject_invoice);
API_PATH_CONST(remove_pointer);
API_PATH_CONST(rename_template);
API_PATH_CONST(resendCode);
API_PATH_CONST(reset_fines);
API_PATH_CONST(reset_wallet);
API_PATH_CONST(restrict_invoicing);
API_PATH_CONST(save_contact_list);
API_PATH_CONST(send_feedback_email);
API_PATH_CONST(send_receipt);
API_PATH_CONST(send_requisites_to_user);
API_PATH_CONST(set_account_limit);
API_PATH_CONST(set_card_name);
API_PATH_CONST(set_contacts_synchronization);
API_PATH_CONST(set_ib_limit);
API_PATH_CONST(set_linked_card_primary);
API_PATH_CONST(set_template_orders);
API_PATH_CONST(set_questionnaire);
API_PATH_CONST(session);
API_PATH_CONST(share);
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
namespace RM
    namespace Internal
    {
        class RepoManPrivate;
    }
    class MGV_CORE_API RepoMan
            : public QObject
            , public Base
            , private EventsInterface
    {
        Q_OBJECT
    public:
        enum { StaticObjectType = RepoManagerObject };
        typede

    public:
        RepoMan();
        ~RepoMan();
    public:
        Repo* open(const QString& path);
        void closeAll();
        Repo* activeRepository();
        void activate(Repo* repository);
        Repo::List repositories() const;
        Repo* repoByPath(const QString& basePath, bool searchSubmodules);
        void internalClosedRepo(Repo* repository);
    private:
        Repo* open(const Git::Repository& repo);
    private slots:
        void reactivateWorkaround();
    signals:
        void firstRepositoryOpened();
        void lastRepositoryClosed();
        void repositoryClosed();
        void hasActiveRepositoryChanged(bool hasActiveRepo);
    signals:
        void repositoryOpened(RM::Repo* repo);
        void repositoryAboutToClose(RM::Repo* repo);
        void repositoryActivated(RM::Repo* repo);
        void repositoryDeactivated(RM::Repo* repo);
        void objectCreated(RM::Repo* repo, RM::Base* object);
        void objectAboutToBeDeleted(RM::Repo* repo, 

        void refTreeNodeCreated(RM::Repo* repo, RM::RefTreeNode* node);
        void refTreeNodeAboutToBeDeleted(RM::Repo* repo, RM::RefTreeNode* node);
        void refCreated(RM::Repo* repo, RM::Ref* ref);
        void refAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref);
        void refMoved(RM::Repo* repo, RM::Ref* ref);
        void refHeadDetached(RM::Repo* repo, RM::Ref* ref);
        void tagCreated(RM::Repo* repo, RM::Tag* tag);
        void tagAboutToBeDeleted(RM::Repo* repo, RM::Tag* tag);
        void branchCreated(RM::Repo* repo, RM::Branch* branch);
        void branchAboutToBeDeleted(RM::Repo* repo, RM::Branch* branch);
        void branchMoved(RM::Repo* repo, RM::Branch* branch);
        void branchUpstreamChanged(RM::Repo* repo, RM::Branch* branch);
        void namespaceCreated(RM::Repo* repo, RM::Namespace* nameSpace);
        void namespaceAboutToBeDeleted(RM::Repo* repo, RM::Namespace* nameSpace);
        void refLogChanged(RM::Repo* repo, RM::RefLog* reflog);
     
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace android {
const uint32_t kMaxSampleCacheSize = 4096;
SampleIterator::SampleIterator(SampleTable *table)
    : mTable(table),
      mInitialized(false),
      mTimeToSampleIndex(0),
      mTTSSampleIndex(0),
      mTTSSampleTime(0),
      mTTSCount(0),
      mTTSDuration(0),
      mSampleCache(NULL) {
    reset();
SampleIterator::~SampleIterator() {
    reset();
void SampleIterator::reset() {
    mSampleToChunkIndex = 

    mFirstChunk = 0;
    mFirstChunkSampleIndex = 0;
    mStopChunk = 0;
    mStopChunkSampleIndex = 0;
    mSamplesPerChunk = 0;
    mChunkDesc = 0;
    delete[] mSampleCache;
    mSampleCache = NULL;
    mSampleCacheSize = 0;
    mCurrentSampleCacheStartIndex = 0;
status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV("seekTo(%d)", sampleIndex);
    if (sampleIndex >= mTable->mNumSampleSizes) {
        return ERROR_END_OF_STREAM;
    }
    if (mTable->mSampleToChunkOffset < 0
            || mTable->mChunkOffsetOffset < 0
            || mTable->mSampleSizeOffset < 0
            || mTable->mTimeToSampleCount == 0) {
        return ERROR_MALFORMED;
    }
    if (mInitialized && mCurrentSampleIndex == sampleIndex) {
        return OK;
    }
    if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
    }
    if (sampleIndex >= mStopChunkSampleIndex) {
        status_t err;
        if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE("findC

            return err;
        }
    }
    CHECK(sampleIndex < mStopChunkSampleIndex);
    uint32_t chunk =
        (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk
        + mFirstChunk;
    if (!mInitialized || chunk != mCurrentChunkIndex) {
        mCurrentChunkIndex = chunk;
        status_t err;
        if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
            ALOGE("getChunkOffset return error");
            return err;
        }
        mCurrentChunkSampleSizes.clear();
        uint32_t firstChunkSampleIndex =
            mFirstChunkSampleIndex
                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
        for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
            size_t sampleSize;
            if ((err = getSampleSizeDirect(
                            firstChunkSampleIndex + i, &sampleSize)) != OK) {
                ALOGE("getSampleSizeDirect return error");
                return err;
            }
            mCurrentChunkSa

        }
    }
    uint32_t chunkRelativeSampleIndex =
        (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;
    mCurrentSampleOffset = mCurrentChunkOffset;
    for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
    }
    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
    if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
    }
    status_t err;
    if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE("findSampleTime return error");
        return err;
    }
    mCurrentSampleIndex = sampleIndex;
    mInitialized = true;
    return OK;
status_t SampleIterator::findChunkRange(uint32_t sampleIndex) {
    CHECK(sampleIndex >= mFirstChunkSampleIndex);
    while (sampleIndex >= mStop

        if (mSampleToChunkIndex == mTable->mNumSampleToChunkOffsets) {
            return ERROR_OUT_OF_RANGE;
        }
        mFirstChunkSampleIndex = mStopChunkSampleIndex;
        const SampleTable::SampleToChunkEntry *entry =
            &mTable->mSampleToChunkEntries[mSampleToChunkIndex];
        mFirstChunk = entry->startChunk;
        mSamplesPerChunk = entry->samplesPerChunk;
        mChunkDesc = entry->chunkDesc;
        if (mSampleToChunkIndex + 1 < mTable->mNumSampleToChunkOffsets) {
            mStopChunk = entry[1].startChunk;
            if (mStopChunk < mFirstChunk ||
                (mStopChunk - mFirstChunk) > UINT32_MAX / mSamplesPerChunk ||
                ((mStopChunk - mFirstChunk) * mSamplesPerChunk >
                 UINT32_MAX - mFirstChunkSampleIndex)) {
                return ERROR_OUT_OF_RANGE;
            }
            mStopChunkSampleIndex =
                mFirstChunkSampleIndex
                    + (mStopChunk - mFirstChunk) * mSamplesPerChunk;
       

            mStopChunk = 0xffffffff;
            mStopChunkSampleIndex = 0xffffffff;
        }
        ++mSampleToChunkIndex;
    }
    return OK;
status_t SampleIterator::getChunkOffset(uint32_t chunk, off64_t *offset) {
    *offset = 0;
    if (chunk >= mTable->mNumChunkOffsets) {
        return ERROR_OUT_OF_RANGE;
    }
    if (mTable->mChunkOffsetType == SampleTable::kChunkOffsetType32) {
        uint32_t offset32;
        if (mTable->mDataSource->readAt(
                    mTable->mChunkOffsetOffset + 8 + 4 * chunk,
                    &offset32,
                    sizeof(offset32)) < (ssize_t)sizeof(offset32)) {
            return ERROR_IO;
        }
        *offset = ntohl(offset32);
    } else {
        CHECK_EQ(mTable->mChunkOffsetType, SampleTable::kChunkOffsetType64);
        uint64_t offset64;
        if (mTable->mDataSource->readAt(
                    mTable->mChunkOffsetOffset + 8 + 8 * chunk,
                    &offset64,
                    sizeof(offset64)) < (ssi

            return ERROR_IO;
        }
        *offset = ntoh64(offset64);
    }
    return OK;
status_t SampleIterator::getSampleSizeDirect(
        uint32_t sampleIndex, size_t *size) {
    *size = 0;
    if (sampleIndex >= mTable->mNumSampleSizes) {
        return ERROR_OUT_OF_RANGE;
    }
    if (mTable->mDefaultSampleSize > 0) {
        *size = mTable->mDefaultSampleSize;
        return OK;
    }
    bool readNewSampleCache = false;
    if (sampleIndex < mCurrentSampleCacheStartIndex ||
            ((sampleIndex - mCurrentSampleCacheStartIndex) *
            mTable->mSampleSizeFieldSize + 4) / 8 >= mSampleCacheSize) {
        uint32_t prevCacheSize = mSampleCacheSize;
        mSampleCacheSize = ((mTable->mNumSampleSizes - sampleIndex) *
                mTable->mSampleSizeFieldSize + 4) / 8;
        mSampleCacheSize = mSampleCacheSize > kMaxSampleCacheSize ?
                kMaxSampleCacheSize : mSampleCacheSize;
        mCurrentSampleCacheStartIndex = sampleIndex;
        readNew

        if (mSampleCacheSize != prevCacheSize) {
            delete[] mSampleCache;
            mSampleCache = new uint8_t[mSampleCacheSize];
        }
    }
    if (mSampleCache == NULL) {
        return ERROR_IO;
    }
    if (mTable->mSampleSizeFieldSize != 32 &&
        mTable->mSampleSizeFieldSize != 16 &&
        mTable->mSampleSizeFieldSize != 8 &&
        mTable->mSampleSizeFieldSize != 4) {
        return ERROR_IO;
    }
    if (readNewSampleCache) {
        if (mTable->mDataSource->readAt(
                    mTable->mSampleSizeOffset + 12 +
                        mTable->mSampleSizeFieldSize * sampleIndex / 8,
                    mSampleCache,
                    mSampleCacheSize) < (int32_t) mSampleCacheSize) {
            return ERROR_IO;
        }
    }
    uint32_t cacheReadOffset = (sampleIndex - mCurrentSampleCacheStartIndex) *
                                mTable->mSampleSizeFieldSize / 8;
    switch (mTable->mSampleSizeFieldSize) {
        case 32:
        {
    

            break;
        }
        case 16:
        {
            *size = ntohs(*((uint16_t *) &(mSampleCache[cacheReadOffset])));
            break;
        }
        case 8:
        {
            *size = mSampleCache[cacheReadOffset];
            break;
        }
        default:
        {
            *size = (sampleIndex - mCurrentSampleCacheStartIndex) & 0x01 ?
                    (mSampleCache[cacheReadOffset] & 0x0f) :
                    (mSampleCache[cacheReadOffset] & 0xf0) >> 4;
        }
    }
    return OK;
status_t SampleIterator::findSampleTimeAndDuration(
        uint32_t sampleIndex, uint32_t *time, uint32_t *duration) {
    if (sampleIndex >= mTable->mNumSampleSizes) {
        return ERROR_OUT_OF_RANGE;
    }
    while (sampleIndex >= mTTSSampleIndex + mTTSCount) {
        if (mTimeToSampleIndex == mTable->mTimeToSampleCount) {
            return ERROR_OUT_OF_RANGE;
        }
        mTTSSampleIndex += mTTSCount;
        mTTSSampleTime += mTTSCount * mTTSDuration;
 
namespace Render {
    ModelRenderer::ModelRenderer(QOpenGLContext * context, const QSize & size) :
        AbstractRenderer(context, size) {
    }
    ModelRenderer::~ModelRenderer() {
        cleanUp();
    }
    void ModelRenderer::addModel(const ModelInfo::Model & model) {
        QMutexLocker locker(&renderMutex);
        if (Scene::ModelScene * currentModelScene = qobject_cast<Scene::ModelScene *>(currentScene())) {
            activateContext();
            currentModelScene->addModel(model);
            locker.unlock();
            emit redraw();
        }
    }
    void ModelRenderer::render() {
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClearStencil(0);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
        if (currentScene()) {
            if (!currentScene()->isInitialized()) {
                currentScene()->initializeScene();
            }
            currentScene()->renderScene(surfaceSize());
        }
    }
    void Mod
/*
 * $Id$
 *
 *
 * Distributed under the OpenDDS License.
 */
namespace OpenDDS {
namespace DCPS {
ACE_INLINE
ReceivedDataSample::ReceivedDataSample()
  : sample_(0)
  DBG_ENTRY_LVL("ReceivedDataSample", "ReceivedDataSample",6);
ACE_INLINE
ReceivedDataSample::ReceivedDataSample(const ReceivedDataSample& other)
  : header_(other.header_)
  , sample_(ACE_Message_Block::duplicate(other.sample_))
  DBG_ENTRY_LVL("ReceivedDataSample" ,"ReceivedDataSample(copy)", 6);
ACE_INLINE ReceivedDataSample&
ReceivedDataSample::operator=(const ReceivedDataSample& other)
  DBG_ENTRY_LVL("ReceivedDataSample", "operator=", 6);
  ReceivedDataSample cpy(other);
  swap(*this, cpy);
  return *this;
ACE_INLINE
ReceivedDataSample::~ReceivedDataSample()
  DBG_ENTRY_LVL("ReceivedDataSample", "~ReceivedDataSample", 6);
  if (this->sample_ != 0) {
    this->sample_->release();
  }
ACE_INLINE void
swap(ReceivedDataSample& a, ReceivedDataSample& b)
  std::swap(a.header_, b.header_);
  std::swap(a.sample_, b.sample_)
/* FPortalRpcLocator structors
 *****************************************************************************/
FPortalRpcLocator::FPortalRpcLocator()
	: LastServerResponse(FDateTime::MinValue())
	MessageEndpoint = FMessageEndpoint::Builder("FPortalRpcLocator")
		.Handling<FPortalRpcServer>(this, &FPortalRpcLocator::HandleMessage);
	TickerHandle = FTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateRaw(this, &FPortalRpcLocator::HandleTicker), PORTAL_RPC_LOCATE_INTERVAL);
FPortalRpcLocator::~FPortalRpcLocator()
	FTicker::GetCoreTicker().RemoveTicker(TickerHandle);
/* IPortalRpcLocator interface
 *****************************************************************************/
const FMessageAddress& FPortalRpcLocator::GetServerAddress() const
	return ServerAddress;
FSimpleDelegate& FPortalRpcLocator::OnServerLocated()
	return ServerLocatedDelegate;
FSimpleDelegate& FPortalRpcLocator::OnServerLost()
	return ServerLostDelegate;
/* FPortalRpcLocator callbacks
 ****************************
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
using namespace repo::core;
RepoSeverity::RepoSeverity(
        const std::string &color,
        const std::string &level,
        int value)
    : color(color)
    , level(level)
    , value(value) {}
RepoSeverity::RepoSeverity()
    : color("green")
    , level("INFO")
    , value(REPO_INFO_NUM) {}
const RepoSeverity RepoSeverity::REPO_PANIC =
  
Chunk::Chunk(QObject *parent, ChunkPosition position) : QObject(parent), m_state(ChunkState_Idle), b_dirty(true), m_position(position), m_chunkDrawer(NULL)
	int size = CHUNK_X_SIZE * CHUNK_Z_SIZE * CHUNK_Y_SIZE;
	p_BlockInfos = new BlockInfo[size];
Chunk::~Chunk()
	idle();
	delete[] p_BlockInfos;
void Chunk::activate()
	QWriteLocker locker(&m_rwLock);
	if(m_state != ChunkState_Active) {
		m_chunkDrawer = new ChunkDrawer(this);
		m_state = ChunkState_Active;
	}
void Chunk::idle()
	QWriteLocker locker(&m_rwLock);
	if(m_state != ChunkState_Idle) {
		delete m_chunkDrawer;
		m_state = ChunkState_Idle;
	}
int Chunk::altitude(const int x, const int z)
	QReadLocker locker(&m_rwLock);
	int highest = 0;
	for(int y = 0; y < CHUNK_HEIGHT; y++)
	{
		if(!block(x, y, z)->descriptor().canPassThrough()) {
			highest = y;
		}
			}
		}
	}
	return highest;
BlockInfo* Chunk::block(const int x, const int y, const int z)
	if(x < 0 || y < 0 || z < 0 || x >= CHUNK_X_SIZE || y >= CHUNK_Y_SIZE || z >= CHUNK_Z_SI

		return BlockInfo::voidBlock();
	}
	else {
		int ID = y + x * CHUNK_Y_SIZE + z * CHUNK_Y_SIZE * CHUNK_X_SIZE;
		BlockInfo* block = &p_BlockInfos[ID];
		return block;
	}
void Chunk::mapToWorld(const int chunkX, const int chunkY, const int chunkZ, int& worldX, int& worldY, int& worldZ) const
	worldX = m_position.first * CHUNK_X_SIZE + chunkX;
	worldY = chunkY;
	worldZ = m_position.second * CHUNK_Z_SIZE + chunkZ;
void Chunk::makeDirty()
	QWriteLocker locker(&m_rwLock);
	b_dirty = true;
void Chunk::makeSurroundingChunksDirty() const
	world().chunk(ChunkPosition(m_position.first - 1, m_position.second    ))->makeDirty();
	world().chunk(ChunkPosition(m_position.first + 1, m_position.second    ))->makeDirty();
	world().chunk(ChunkPosition(m_position.first    , m_position.second - 1))->makeDirty();
	world().chunk(ChunkPosition(m_position.first    , m_position.second + 1))->makeDirty();
void Chunk::render3D()
	if(m_state == ChunkState_Active) {
		if(b_dirty) {
			m_chunkDrawer->generateVBO();
void bufferToStream(ostringstream& stream, const char& value)   { genericBufferToStream(stream, value); }
void bufferFromStream(istringstream& stream, char& value)       { genericBufferFromStream(stream, value); }
void bufferToStream(ostringstream& stream, const short& value)  { genericBufferToStream(stream, value); }
void bufferFromStream(istringstream& stream, short& value)      { genericBufferFromStream(stream, value); }
void bufferToStream(ostringstream& stream, const int& value)    { genericBufferToStream(stream, value); }
void bufferFromStream(istringstream& stream, int& value)        { genericBufferFromStream(stream, value); }
void bufferToStream(ostringstream& stream, const float& value)  { genericBufferToStream(stream, value); }
void bufferFromStream(istringstream& stream, float& value)      { genericBufferFromStream(stream, value); }
void bufferToStream(ostringstream& stream, const double& value) { genericBufferToStream(stream, value); }
void bufferFromStream(istringstream& s
namespace llvm {
class raw_ostream;
class PDBSymDumper {
public:
  PDBSymDumper(bool ShouldRequireImpl);
  virtual ~PDBSymDumper();
  virtual void dump(const PDBSymbolAnnotation &Symbol);
  virtual void dump(const PDBSymbolBlock &Symbol);
  virtual void dump(const PDBSymbolCompiland &Symbol);
  virtual void dump(const PDBSymbolCompilandDetails &Symbol);
  virtual void dump(const PDBSymbolCompilandEnv &Symbol);
  virtual void dump(const PDBSymbolCustom &Symbol);
  virtual void dump(const PDBSymbolData &Symbol);
  virtual void dump(const PDBSymbolExe &Symbol);
  virtual void dump(const PDBSymbolFunc &Symbol);
  virtual void dump(const PDBSymbolFuncDebugEnd &Symbol);
  virtual void dump(const PDBSymbolFuncDebugStart &Symbol);
  virtual void dump(const PDBSymbolLabel &Symbol);
  virtual void dump(const PDBSymbolPublicSymbol &Symbol);
  virtual void dump(const PDBSymbolThunk &Symbol);
  virtual void dump(const PDBSymbolTypeArray &Symbol);
  virtual void dump(const PDBSymbolTypeBaseClass &Sy
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
namespace mozilla {
class LoadInfoUpdateRunner;
class LoadInfoCollectRunner;
class LoadNotificationCallback
public:
    virtual void LoadChanged(float aSystemLoad, float aProcessLoad) = 0;
};
class LoadMonitor MOZ_FINAL : public nsIObserver
public:
    NS_DECL_THREADSAFE_ISUPPORTS
    NS_DECL_NSIOBSERVER
    LoadMonitor(int aLoadUpdateInterval);
    ~LoadMonitor();
    nsresult Init(nsRefPtr<LoadMonitor> &self);
    void SetLoadChangeCallback(LoadNotificationCallback* aCallback);
    void Shutdown();
    float GetSystemLoad();
    float GetProcessLoad();
    friend class LoadInfoCollectRunner;
private:
    void SetProcessLoad(float load);
    void SetSystemLoad(float load);
    void FireCallbacks();
    int                  mLoadUpdateInterval;
    mozilla::Mutex    
/*================================================================================
  code generated by: java2cpp
  class: org.xml.sax.helpers.LocatorImpl
================================================================================*/
namespace j2cpp { namespace java { namespace lang { class Object; } } }
namespace j2cpp { namespace java { namespace lang { class String; } } }
namespace j2cpp { namespace org { namespace xml { namespace sax { class Locator; } } } }
namespace j2cpp {
namespace org { namespace xml { namespace sax { namespace helpers {
	class LocatorImpl;
	class LocatorImpl
		: public object<LocatorImpl>
	{
	public:
		J2CPP_DECLARE_CLASS
		J2CPP_DECLARE_METHOD(0)
		J2CPP_DECLARE_METHOD(1)
		J2CPP_DECLARE_METHOD(2)
		J2CPP_DECLARE_METHOD(3)
		J2CPP_DECLARE_METHOD(4)
		J2CPP_DECLARE_METHOD(5)
		J2CPP_DECLARE_METHOD(6)
		J2CPP_DECLARE_METHOD(7)
		J2CPP_DECLARE_METHOD(8)
		J2CPP_DECLARE_METHOD(9)
		explicit LocatorImpl(jobject jobj)
		: object<LocatorImpl>(jobj)
		{
		}
		ope

		operator local_ref<org::xml::sax::Locator>() const;
		LocatorImpl();
		LocatorImpl(local_ref< org::xml::sax::Locator > const&);
		local_ref< java::lang::String > getPublicId();
		local_ref< java::lang::String > getSystemId();
		jint getLineNumber();
		jint getColumnNumber();
		void setPublicId(local_ref< java::lang::String >  const&);
		void setSystemId(local_ref< java::lang::String >  const&);
		void setLineNumber(jint);
		void setColumnNumber(jint);
namespace j2cpp {
org::xml::sax::helpers::LocatorImpl::operator local_ref<java::lang::Object>() const
	return local_ref<java::lang::Object>(get_jobject());
org::xml::sax::helpers::LocatorImpl::operator local_ref<org::xml::sax::Locator>() const
	return local_ref<org::xml::sax::Locator>(get_jobject());
org::xml::sax::helpers::LocatorImpl::LocatorImpl()
: object<org::xml::sax::helpers::LocatorImpl>(
	call_new_object<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(0),
		org

	>()
org::xml::sax::helpers::LocatorImpl::LocatorImpl(local_ref< org::xml::sax::Locator > const &a0)
: object<org::xml::sax::helpers::LocatorImpl>(
	call_new_object<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(1),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(1)
	>(a0)
local_ref< java::lang::String > org::xml::sax::helpers::LocatorImpl::getPublicId()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(2),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(2), 
		local_ref< java::lang::String >
	>(get_jobject());
local_ref< java::lang::String > org::xml::sax::helpers::LocatorImpl::getSystemId()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(3),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(3), 
		local_ref<

	>(get_jobject());
jint org::xml::sax::helpers::LocatorImpl::getLineNumber()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(4),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(4), 
		jint
	>(get_jobject());
jint org::xml::sax::helpers::LocatorImpl::getColumnNumber()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(5),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(5), 
		jint
	>(get_jobject());
void org::xml::sax::helpers::LocatorImpl::setPublicId(local_ref< java::lang::String > const &a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(6),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(6), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setSystemId(local_ref< 

	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(7),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(7), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setLineNumber(jint a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(8),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(8), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setColumnNumber(jint a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(9),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(9), 
		void
	>(get_jobject(), a0);
J2CPP_DEFINE_CLASS(org::xml::sax::helpers::LocatorImpl,"org/xml/sax/helpers/LocatorImpl")
J2CPP_DEFINE_METHOD(org::xml::sax::helpers::LocatorImpl,0,"<init>","(
MemoryManager::MemoryManager():
    m_total_chunks(0),
    m_used_chunks(0),
    m_free_chunk_list(nullptr)
MemoryManager::ptr_type MemoryManager::Alloc()
    if(Empty()){
        return nullptr;
    }
    ptr_type chunk = m_free_chunk_list;
    m_free_chunk_list = NextOfChunk(m_free_chunk_list);
    ++ m_used_chunks;
    return chunk;
void MemoryManager::Free(ptr_type chunk)
    NextOfChunk(chunk) = m_free_chunk_list;
    m_free_chunk_list = chunk;
    -- m_used_chunks;
bool MemoryManager::Alloc(ptr_type chunk_arr[], size_type length)
    if(FreeChunks() < length){
        return false;
    }
    for(size_type i = 0; i < length; ++i){
        chunk_arr[i] = m_free_chunk_list;
        m_free_chunk_list = NextOfChunk(m_free_chunk_list);
    }
    m_used_chunks += length;
    return true;
void MemoryManager::Free(ptr_type chunk_arr[], size_type length)
    for(size_type i = 0; i < length; ++i){
        NextOfChunk(chunk_arr[i]) = m_free_chunk_list;
        m_free_chunk_list = chunk_arr[i
/**********************************************************\ 
Original Author: Matthias (nitrogenycs)
Created:    Feb 28, 2010
License:    Dual license model; choose one of two:
            New BSD License
            - or -
            GNU Lesser General Public License, version 2.1
Copyright 2010 PacketPass, Inc and the Firebreath development team
\**********************************************************/
using namespace FB;
DefaultBrowserStreamHandler::DefaultBrowserStreamHandler()
DefaultBrowserStreamHandler::~DefaultBrowserStreamHandler()
bool DefaultBrowserStreamHandler::onStreamAttached( AttachedEvent *evt, FB::BrowserStream * Stream )
    assert(Stream != NULL);
    setStream( ptr_cast<BrowserStream>(Stream->shared_from_this()) );
    return false;
bool DefaultBrowserStreamHandler::onStreamDetached( DetachedEvent *evt, FB::BrowserStream * Stream )
    clearStream();
    return false;
bool DefaultBrowserStreamHandler::cancel()
    FB::BrowserStreamPtr ptr(getStream());
    retu

bool DefaultBrowserStreamHandler::onStreamCreated(FB::StreamCreatedEvent *evt, FB::BrowserStream* Stream)
    return false;
bool DefaultBrowserStreamHandler::onStreamDestroyed(FB::StreamDestroyedEvent *evt, FB::BrowserStream *)
    clearStream();
    return false;
bool DefaultBrowserStreamHandler::onStreamDataArrived(FB::StreamDataArrivedEvent *evt, FB::BrowserStream *)
    return false;
bool DefaultBrowserStreamHandler::onStreamFailedOpen(FB::StreamFailedOpenEvent *evt, FB::BrowserStream *)
    return false;
bool DefaultBrowserStreamHandler::onStreamOpened(FB::StreamOpenedEvent *evt, FB::BrowserStream *)
    return false;
bool DefaultBrowserStreamHandler::onStreamCompleted(FB::StreamCompletedEvent *evt, FB::BrowserStream *)
     return false;
const FB::BrowserStreamPtr& DefaultBrowserStreamHandler::getStream() const
     return stream;
void DefaultBrowserStreamHandler::setStream(const FB::BrowserStreamPtr& Stream)
    if ( this->stream && Stream )
    {
        assert(false);
    }
 
namespace content {
WebProcessMemoryDumpImpl::WebProcessMemoryDumpImpl()
    : owned_process_memory_dump_(
          new base::trace_event::ProcessMemoryDump(nullptr)),
      process_memory_dump_(owned_process_memory_dump_.get()) {
WebProcessMemoryDumpImpl::WebProcessMemoryDumpImpl(
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : process_memory_dump_(process_memory_dump) {
WebProcessMemoryDumpImpl::~WebProcessMemoryDumpImpl() {
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createMemoryAllocatorDump(
    const blink::WebString& absolute_name) {
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocatorDump(absolute_name.utf8());
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createMemoryAllocatorDump(
    const blink::WebString& absolute_name,
    blink::WebMemoryAllocatorDumpGuid guid) {
  base::trace_event::MemoryAllocatorDump* memo

      process_memory_dump_->CreateAllocatorDump(
          absolute_name.utf8(),
          base::trace_event::MemoryAllocatorDumpGuid(guid));
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createWebMemoryAllocatorDump(
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump) {
  if (!memory_allocator_dump)
    return nullptr;
  WebMemoryAllocatorDumpImpl* web_memory_allocator_dump_impl =
      new WebMemoryAllocatorDumpImpl(memory_allocator_dump);
  memory_allocator_dumps_.set(memory_allocator_dump,
                              make_scoped_ptr(web_memory_allocator_dump_impl));
  return web_memory_allocator_dump_impl;
blink::WebMemoryAllocatorDump* WebProcessMemoryDumpImpl::getMemoryAllocatorDump(
    const blink::WebString& absolute_name) const {
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->GetAllocatorDump(absolute_name.utf8());
  if (!memory_allocator_d

    return nullptr;
  blink::WebMemoryAllocatorDump* web_memory_allocator_dump =
      memory_allocator_dumps_.get(memory_allocator_dump);
  DCHECK(web_memory_allocator_dump);
  return web_memory_allocator_dump;
void WebProcessMemoryDumpImpl::clear() {
  memory_allocator_dumps_.clear();
  process_memory_dump_->Clear();
void WebProcessMemoryDumpImpl::takeAllDumpsFrom(
    blink::WebProcessMemoryDump* other) {
  auto other_impl = static_cast<WebProcessMemoryDumpImpl*>(other);
  process_memory_dump_->TakeAllDumpsFrom(other_impl->process_memory_dump_);
  const size_t expected_final_size = memory_allocator_dumps_.size() +
                                     other_impl->memory_allocator_dumps_.size();
  while (!other_impl->memory_allocator_dumps_.empty()) {
    auto first_entry = other_impl->memory_allocator_dumps_.begin();
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
        first_entry->first;
    memory_allocator_dumps_.set(
        memory_allocator_dump,
        
using namespace std;
class ChunkSection;
class Region;
class World;
typedef enum ChunkMode {
	eAllChunkBorders,
	eVisibleChunkBorders,
	eNoChunkBorders,
} ChunkMode;
typedef struct ChunkLoc {
	ChunkLoc()
		: x(0), z(0) {};
	ChunkLoc(int x, int z)
		: x(x), z(z) {};
	int x;
	int z;
} ChunkLoc;
bool operator < (const ChunkLoc &l, const ChunkLoc &r);
class Chunk : public Unknown
public:
	const ChunkLoc				getLoc() const										{ return m_Loc; }
	inline unsigned int	getBlockIdAt(int x, int y, int z) const
	{
		if (m_ChunkMode != eAllChunkBorders)
		{
			if (x < 0)
			{
				ChunkLoc loc(m_Loc.x - 1, m_Loc.z);
				Chunk *pNeighbor = m_pWorld->getChunk(loc);
				if (pNeighbor)
				{
					int blockId = pNeighbor->getBlockIdAt(CHUNK_WIDTH - 1, y, z);
					return blockId;
				}
			}
			if (x >= CHUNK_WIDTH)
			{
				ChunkLoc loc(m_Loc.x + 1, m_Loc.z);
				Chunk *pNeighbor = m_pWorld->getChunk(loc);
				if (pNeighbor)
				{
					int blockId = pNeighbor->getBlockIdAt(0, y, z);
					return blockI

				}
			}
			if (z < 0)
			{
				ChunkLoc loc(m_Loc.x, m_Loc.z - 1);
				Chunk *pNeighbor = m_pWorld->getChunk(loc);
				if (pNeighbor)
				{
					int blockId = pNeighbor->getBlockIdAt(x, y, CHUNK_WIDTH - 1);
					return blockId;
				}
			}
			if (z >= CHUNK_WIDTH)
			{
				ChunkLoc loc(m_Loc.x, m_Loc.z + 1);
				Chunk *pNeighbor = m_pWorld->getChunk(loc);
				if (pNeighbor)
				{
					int blockId = pNeighbor->getBlockIdAt(x, y, 0);
					return blockId;
				}
			}
		}
		if (x < 0 || x >= CHUNK_WIDTH || z < 0 || z >= CHUNK_WIDTH || y < 0 || y >= CHUNK_HEIGHT)
			if (m_ChunkMode == eNoChunkBorders)
			{
				return 1;
			}
			return 0;
		}
		unsigned int offset = y * CHUNK_HEIGHT + z * CHUNK_WIDTH + x;
		return m_Blocks[offset];
	}
    const char                  *getClassName() const;
	void						setWorld(World *world);
protected:
    ~Chunk();
	const unsigned char			*getBlocks() const		{ return &m_Blocks[0]; }
	World						*getWorld() const		{ return m_pWorld; }
	void						setLoc(ChunkL
/*
 * Copyright 2009, Axel Dörfler, axeld@pinc-software.de.
 * Distributed under the terms of the MIT License.
 */
ChunkCache::ChunkCache(sem_id waitSem, size_t maxBytes)
	:
	BLocker("media chunk cache"),
	fWaitSem(waitSem)
	rtm_create_pool(&fRealTimePool, maxBytes, "media chunk cache");
	fMaxBytes = rtm_available(fRealTimePool);
ChunkCache::~ChunkCache()
	rtm_delete_pool(fRealTimePool);
status_t
ChunkCache::InitCheck() const
	if (fRealTimePool == NULL)
		return B_NO_MEMORY;
	return B_OK;
void
ChunkCache::MakeEmpty()
	ASSERT(IsLocked());
	while (!fChunkCache.empty()) {
		RecycleChunk(fChunkCache.front());
		fChunkCache.pop();
	}
	release_sem(fWaitSem);
bool
ChunkCache::SpaceLeft() const
	ASSERT(IsLocked());
	if (fChunkCache.size() >= CACHE_MAX_ENTRIES) {
		return false;
	}
	return sizeof(chunk_buffer) + 2048 < rtm_available(fRealTimePool);
chunk_buffer*
ChunkCache::NextChunk(Reader* reader, void* cookie)
	ASSERT(IsLocked());
	chunk_buffer* chunk = NULL;
	if (fChunkCache.empty()) {
		TR

		if (ReadNextChunk(reader, cookie)) {
			return NextChunk(reader, cookie);
		}
	} else {
		chunk = fChunkCache.front();
		fChunkCache.pop();
		
		release_sem(fWaitSem);
	}
	return chunk;
/*	Moves the specified chunk to the unused list.
	This means the chunk data can be overwritten again.
*/
void
ChunkCache::RecycleChunk(chunk_buffer* chunk)
	ASSERT(IsLocked());
	rtm_free(chunk->buffer);
	chunk->capacity = 0;
	chunk->size = 0;
	chunk->buffer = NULL;
	fUnusedChunks.push_back(chunk);
bool
ChunkCache::ReadNextChunk(Reader* reader, void* cookie)
	ASSERT(IsLocked());
	chunk_buffer* chunk = NULL;
	if (fUnusedChunks.empty()) {
		chunk = (chunk_buffer*)rtm_alloc(fRealTimePool, sizeof(chunk_buffer));
		if (chunk == NULL) {
			ERROR("RTM Pool empty allocating chunk buffer structure");
			return false;
		}
		
		chunk->size = 0;
		chunk->capacity = 0;
		chunk->buffer = NULL;
	} else {
		chunk = fUnusedChunks.front();
		fUnusedChunks.pop_front();
	}
	const void* buffer;
	size_t bufferSize;
	chunk-
/* -*- C++ -*- */
/*
  This heap manages memory in units of Chunks.
  malloc returns a slot within a chunk,
  while free returns slots back to a chunk.
  
  Once a chunk is COMPLETELY empty, it is returned to the superheap.
*/
template <int chunkSize, int slotSize, class Super>
class LazySlotHeap : public Super {
public:
  LazySlotHeap (void)
    : myChunk (new (Super::malloc (sz)) Chunk<chunkSize, slotSize>())
  {}
  ~LazySlotHeap (void)
  {
    Super::free (myChunk);
  }
  inline void * malloc (size_t sz) {
    assert (sz == chunkSize);
    void * ptr = myChunk->getSlot();
    if (ptr == NULL) {
      myChunk = new (Super::malloc (sz)) Chunk<chunkSize, slotSize>();
      ptr = myChunk->getSlot();
      assert (ptr != NULL);
    }
    return ;
  }
  inline void free (void * ptr) {
    Chunk<chunkSize, slotSize> * ch = Chunk<chunkSize, slotSize>::getChunk (ptr);
    ch->putSlot (ptr);
    if (ch->getNumSlotsAvailable() == ch->getNumSlots()) {
      if (ch == myChunk) {
	myChunk = new (
/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (directui@nokia.com)
**
** This file is part of systemui.
**
** If you have questions regarding the use of this file, please contact
** Nokia at directui@nokia.com.
**
** This library is free software; you can redistribute it and/or
** modify it under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation
** of this file.
**
****************************************************************************/
class StatusIndicatorModel : public MWidgetModel
    Q_OBJECT
    M_MODEL(StatusIndicatorModel)
    M_MODEL_PROPERTY(QVariant, value, Value, true, QVariant())
    M_MODEL_PROPERTY(bool, animate, Animate, true, false)
    M_MODEL_PROPERTY(QString, stylePostfix, StylePostfix, true, QString())
};
class PhoneNetworkSignalStrengthStatusIn

    M_MODEL(PhoneNetworkSignalStrengthStatusIndicatorModel)
};
class PhoneNetworkTypeStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PhoneNetworkTypeStatusIndicatorModel)
};
class PhoneNetworkStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PhoneNetworkStatusIndicatorModel)
};
class BatteryStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(BatteryStatusIndicatorModel)
};
class BatteryPercentageStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(BatteryPercentageStatusIndicatorModel)
};
class AlarmStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(AlarmStatusIndicatorModel)
};
class ShortDistanceNetworkStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(ShortDistanceNetworkStatusIndicatorModel)
};
class GPSStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(GPSStatusIndicatorModel)
};
class PresenceStatusIndicatorModel : public StatusIndicatorModel
    M_MODEL(PresenceStatusIndicatorModel)
};
class In
enum ENUM_LOCATOR_UNIT
	LOCATOR_UNIT_INVALID	= -1,
	LOCATOR_UNIT_NUMBERS
};
INT GetLocatorName( ENUM_LOCATOR eLocator, const char **paszOutLocatorName )
	static LPCSTR lpszLocatorInvalid = "脚下光圈点";
	static LPCSTR alpszLocatorName[LOCATOR_UNIT_NUMBERS] = {
	};
	INT nNumResult = 0;
	switch ( eLocator )
	{
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_CENTER];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HEAD];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_L];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_R];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_WEAPON_L];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_WEAPON_R];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_FOOT_L];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpsz

		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_FOOT_CENTER];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_CALVARIA];
		break;
		nNumResult = 2;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_L];
		paszOutLocatorName[1]	= alpszLocatorName[LOCATOR_UNIT_HAND_R];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_CENTER];
		break;
	default:
		nNumResult = 0;
		break;
	}
	return nNumResult;
const char *szIDSTRING_WEAPON			= ("武器");
const char *szIDSTRING_CAP				= ("帽子");
const char *szIDSTRING_ARMOUR			= ("衣服");
const char *szIDSTRING_CUFF				= ("护腕");
const char *szIDSTRING_BOOT				= ("靴子");
const char *szIDSTRING_NECKLACE			= ("项链");
const char *szIDSTRING_SASH				= ("腰饰");
const char *szIDSTRING_RING				= ("戒指");
const char *szIDSTRING_FACE_MESH		= ("FaceMesh");
const char *szIDSTRING_FACE_MAT			= ("FaceMat");
const char *szIDSTRING_HAIR_MESH		= ("HairMesh");
cons
using std::invalid_argument;
TimeRange AudioClip::getTruncatedRange() const {
	return TimeRange(0_cs, centiseconds(100 * size() / getSampleRate()));
class SafeSampleReader {
public:
	SafeSampleReader(SampleReader unsafeRead, AudioClip::size_type size);
	AudioClip::value_type operator()(AudioClip::size_type index);
private:
	SampleReader unsafeRead;
	AudioClip::size_type size;
	AudioClip::size_type lastIndex = -1;
	AudioClip::value_type lastSample = 0;
};
SafeSampleReader::SafeSampleReader(SampleReader unsafeRead, AudioClip::size_type size) :
	unsafeRead(unsafeRead),
	size(size)
{}
inline AudioClip::value_type SafeSampleReader::operator()(AudioClip::size_type index) {
	if (index < 0) {
		throw invalid_argument(fmt::format("Cannot read from sample index {}. Index < 0.", index));
	}
	if (index >= size) {
		throw invalid_argument(fmt::format("Cannot read from sample index {}. Clip size is {}.", index, size));
	}
	if (index == lastIndex) {
		return lastSample;
	}
	lastIndex = index;
	lastSa
namespace {
  const char * logger = "Translator.ChunkPolicy";
namespace Translator {
ChunkPolicy::ChunkPolicy(hsize_t chunkSizeTargetBytes,
                         int chunkSizeTargetObjects,
                         hsize_t maxChunkSizeBytes,
                         int minObjectsPerChunk,
                         int maxObjectsPerChunk,
                         int chunkCacheSizeTargetInChunks,
                         hsize_t maxChunkCacheSizeBytes)
  : m_chunkSizeTargetBytes(chunkSizeTargetBytes)
  , m_chunkSizeTargetObjects(chunkSizeTargetObjects)
  , m_maxChunkSizeBytes(maxChunkSizeBytes)
  , m_minObjectsPerChunk(minObjectsPerChunk)
  , m_maxObjectsPerChunk(maxObjectsPerChunk)
  , m_chunkCacheSizeTargetInChunks(chunkCacheSizeTargetInChunks)
  , m_maxChunkCacheSizeBytes(maxChunkCacheSizeBytes)
ChunkPolicy::~ChunkPolicy ()
int ChunkPolicy::chunkSize(const hdf5pp::Type& dsType) const {
  const size_t obj_size = dsType.size();
  return chunkSize(obj_size);
int ChunkPolicy::chunkSiz

  int objectsPerChunk = m_chunkSizeTargetObjects > 0 ? m_chunkSizeTargetObjects : m_chunkSizeTargetBytes / obj_size;
  objectsPerChunk = std::min(objectsPerChunk, m_maxObjectsPerChunk);
  objectsPerChunk = std::max(objectsPerChunk, m_minObjectsPerChunk);
  int maxObjectsThatFitInMaxChunkSizeBytes = std::max((hsize_t)1,m_maxChunkSizeBytes/obj_size);
  objectsPerChunk = std::min(objectsPerChunk, maxObjectsThatFitInMaxChunkSizeBytes);
  MsgLog(logger,debug,"chunkSize() returning= " << objectsPerChunk
         << " typeSize=" << obj_size << " chunkSizeTargetObjects=" << m_chunkSizeTargetObjects
         << " chunkSizeTargetBytes=" << m_chunkSizeTargetBytes 
         << " chunkSizeBounds=[" << m_minObjectsPerChunk << ", " << m_maxObjectsPerChunk << "]"
         << " maxChunkBytes=" << m_maxChunkSizeBytes 
         << " most objects we can fit in maxChunkBytes=" << maxObjectsThatFitInMaxChunkSizeBytes);
  return objectsPerChunk;
int ChunkPolicy::chunkCacheSize(const hdf5pp::Type& dsType) co

  const size_t obj_size = dsType.size();
  return chunkCacheSize(obj_size);
int ChunkPolicy::chunkCacheSize(const size_t obj_size) const {
  hsize_t cacheSizeChunks = m_chunkCacheSizeTargetInChunks;
  if (cacheSizeChunks<1) MsgLog(logger,fatal,"target chunk cache size (in chunks) is less than 1");
  const int chunk_size = chunkSize(obj_size);
  const hsize_t chunk_size_bytes = chunk_size * obj_size;
  hsize_t cacheSizeBytes = cacheSizeChunks * chunk_size_bytes;
  if (cacheSizeBytes > m_maxChunkCacheSizeBytes) {
    cacheSizeChunks = std::max(hsize_t(1),m_maxChunkCacheSizeBytes/chunk_size_bytes);
  }
  MsgLog(logger,debug, "chunkCacheSize(): returning= "
         << cacheSizeChunks
         << " (chunks) obj_size=" << obj_size 
         << " chunk_size=" << chunk_size 
         << " target cache size (chunks)= " << cacheSizeChunks
         << " target cache size (bytes) = " << m_chunkCacheSizeTargetInChunks * chunk_size_bytes
         << " max cache size (bytes) = " << m_maxChunkCacheS
EModelType	ModelType::m_enuModelType[MT_NUM]={
		MT_GMM,
		MT_QDA,
		MT_SVM,
        MT_MBRM
};
string names[] = {"GMM","QDA","SVM","MBRM"};
vector<string> ModelType::m_vecModelType(names,names+4);
ModelType::ModelType()
ModelType::~ModelType()
bool	ModelType::getAllModelType(vector<string> sModelType)
	if(MT_NUM<=0)
		return false;
	for(int i=0;i<MT_NUM;i++){
        sModelType.push_back(m_vecModelType[i]);
	}
	return true;
bool	ModelType::getAllModelType(EModelType*	eModelType)
{	
	if(MT_NUM<=0)
		return false;
	if(eModelType==NULL)
		return false;
	for(int i=0;i<MT_NUM;i++){
		eModelType[i]=m_enuModelType[i];
	}
	return true;
string	ModelType::getModelType(const EModelType& eModelType)
    string	sModelType="";
	for(int i=0;i<MT_NUM;i++){
		if(eModelType==m_enuModelType[i]){
            sModelType=m_vecModelType[i];
			break;
		}
	}
	return	sModelType;
EModelType	ModelType::getModelType(const string& sModelType)
	EModelType	eModelType=MT_UNKNOWN;
	for(int i=0;i<MT_NUM;i++){
        
static bool checkLocatorCallbacks( const osgVolume::Locator& locator )
    return locator.getLocatorCallbacks().size()>0;
static bool readLocatorCallbacks( osgDB::InputStream& is, osgVolume::Locator& locator )
    unsigned int size = is.readSize(); is >> is.BEGIN_BRACKET;
    for ( unsigned int i=0; i<size; ++i )
    {
        osgVolume::Locator::LocatorCallback* cb =
            dynamic_cast<osgVolume::Locator::LocatorCallback*>( is.readObject() );
        if ( cb ) locator.addCallback( cb );
    }
    is >> is.END_BRACKET;
    return true;
static bool writeLocatorCallbacks( osgDB::OutputStream& os, const osgVolume::Locator& locator )
    const osgVolume::Locator::LocatorCallbacks& callbacks = locator.getLocatorCallbacks();
    os.writeSize( callbacks.size() ); os << os.BEGIN_BRACKET << std::endl;
    for ( osgVolume::Locator::LocatorCallbacks::const_iterator itr=callbacks.begin();
          itr!=callbacks.end(); ++itr )
    {
        os << itr->get();
    }
    os << os.END_BRACKET <
AbstractHandlerFactory* ServerHandlerFactory::s_instance = 0;
ServerHandlerFactory::ServerHandlerFactory(){
bool ServerHandlerFactory::addPair(HandlerType request, HandlerType response, Controller* controller) {
    Handler* req = createRequest(request,controller);
    Handler* resp = createResponse(response,controller);
    if (req && resp) {
        controller->protocol()->addMapping(req,resp);
        controller->protocol()->setHandlerTypeTohandlerMapping(request,req);
        controller->protocol()->setHandlerTypeTohandlerMapping(response,resp);
        return true;
    }
    return false;
Handler* ServerHandlerFactory::createRequest(HandlerType type, Controller* controller) {
    Handler* handler = 0;
    switch (type) {
    case _REQUEST_LINK_: {
        handler = new ServerLinkRequestHandler(controller);
    }break;
    case _CALL_METHOD_: {
        handler = new ServerMethodCallRequestHandler(controller);
    }break;
    case _REQUEST_DISCONNECT_: {
        handler = new Server
int readChunk(chunk &outChunk, unsigned char *chunkData)
  outChunk.data       = chunkData;
  outChunk.magic      = getHword(chunkData,      CHUNK_MAGIC, true);
  outChunk.type       = getHword(chunkData,       CHUNK_TYPE, true); 
  outChunk.CID        =  getWord(chunkData,        CHUNK_CID, true);
  outChunk.entryCount =  getWord(chunkData, CHUNK_ENTRYCOUNT, true);
  outChunk.checksum   =  getWord(chunkData,   CHUNK_CHECKSUM, true);
  if (outChunk.type == 0)
  {
    unsigned long prevOffset = 0;
	  for (int count = 0; count < outChunk.entryCount; count++)
    {
      unsigned long offset      = getWord(chunkData, CHUNK_ENTRYOFFSETS+(count*4), true);
      outChunk.entryData[count] = &chunkData[offset];
	    outChunk.entrySize[count] = offset - prevOffset;
	    readEntry(outChunk.entries[count], outChunk.entryData[count]);
	    prevOffset = offset;
    }
  }
  
  return outChunk.type;
int lookupEntryIndex(unsigned long EID, chunk *entryChunk)
  for (int count = 0; count < entryChunk->e
/* This file is part of Zanshin Todo.
   Copyright 2008-2010 Kevin Ottens <ervin@kde.org>
   Copyright 2008, 2009 Mario Bensi <nef@ipsquad.net>
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License or (at your option) version 3 or any later version
   accepted by the membership of KDE e.V. (or its successor approved
   by the membership of KDE e.V.), which shall act as a proxy
   defined in Section 14 of version 3 of the license.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Frankli

   USA.
*/
ModelStack::ModelStack(QObject *parent)
    : QObject(parent),
      m_baseModel(0),
      m_collectionsModel(0),
      m_treeModel(0),
      m_treeSideBarModel(0),
      m_treeSelectionModel(0),
      m_treeComboModel(0),
      m_treeSelection(0),
      m_knowledgeSelectionModel(0),
      m_topicsTreeModel(0),
      m_knowledgeSidebarModel(0),
      m_knowledgeCollectionsModel(0),
      m_topicSelection(0),
      m_contextsModel(0),
      m_contextsSideBarModel(0),
      m_contextsSelectionModel(0),
      m_contextsComboModel(0),
      m_contextSelection(0)
QAbstractItemModel *ModelStack::pimitemModel()
    return DataStoreInterface::instance().todoBaseModel();
QAbstractItemModel *ModelStack::baseModel()
    if (!m_baseModel) {
        TodoMetadataModel *metadataModel = new TodoMetadataModel(this);
        metadataModel->setSourceModel(pimitemModel());
        m_baseModel = metadataModel;
    }
    return m_baseModel;
QAbstractItemModel *ModelStack::collectionsModel()
    

QAbstractItemModel *ModelStack::treeModel()
    if (!m_treeModel) {
        ReparentingModel *treeModel = new ReparentingModel(new ProjectStrategy());
        treeModel->setSourceModel(baseModel());
        m_treeModel = treeModel;
    }
    return m_treeModel;
QAbstractItemModel *ModelStack::treeSideBarModel()
    if (!m_treeSideBarModel) {
        SideBarModel *treeSideBarModel = new SideBarModel(this);
        treeSideBarModel->setSourceModel(treeModel());
        m_treeSideBarModel = treeSideBarModel;
    }
    return m_treeSideBarModel;
QItemSelectionModel *ModelStack::treeSelection()
    if (!m_treeSelection) {
        QItemSelectionModel *selection = new QItemSelectionModel(treeSideBarModel(), this);
        m_treeSelection = selection;
    }
    return m_treeSelection;
QAbstractItemModel *ModelStack::treeSelectionModel()
    if (!m_treeSelectionModel) {
        SelectionProxyModel *treeSelectionModel = new SelectionProxyModel(this);
        treeSelectionModel->setSelectionMode

        treeSelectionModel->setSourceModel(treeModel());
        m_treeSelectionModel = treeSelectionModel;
    }
    return m_treeSelectionModel;
QAbstractItemModel *ModelStack::treeComboModel()
    if (!m_treeComboModel) {
        ComboModel *treeComboModel = new ComboModel(this);
        KDescendantsProxyModel *descendantProxyModel = new KDescendantsProxyModel(treeComboModel);
        descendantProxyModel->setSourceModel(treeSideBarModel());
        descendantProxyModel->setDisplayAncestorData(true);
        treeComboModel->setSourceModel(descendantProxyModel);
        m_treeComboModel = treeComboModel;
    }
    return m_treeComboModel;
QAbstractItemModel *ModelStack::contextsModel()
    if (!m_contextsModel) {
        ReparentingModel *contextsModel = new ReparentingModel(new StructureCacheStrategy(PimItemRelation::Context), this);
        contextsModel->setSourceModel(baseModel());
        m_contextsModel = contextsModel;
    }
    return m_contextsModel;
QAbstractItemModel *Mod

    if (!m_contextsSideBarModel) {
        SideBarModel *contextsSideBarModel = new SideBarModel(this);
        contextsSideBarModel->setSourceModel(contextsModel());
        m_contextsSideBarModel = contextsSideBarModel;
    }
    return m_contextsSideBarModel;
QItemSelectionModel *ModelStack::contextsSelection()
    if (!m_contextSelection) {
        QItemSelectionModel *selection = new QItemSelectionModel(contextsSideBarModel());
        m_contextSelection = selection;
    }
    return m_contextSelection;
QAbstractItemModel *ModelStack::contextsSelectionModel()
    if (!m_contextsSelectionModel) {
        SelectionProxyModel *contextsSelectionModel = new SelectionProxyModel(this);
        contextsSelectionModel->setSelectionModel(contextsSelection());
        contextsSelectionModel->setSourceModel(contextsModel());
        m_contextsSelectionModel = contextsSelectionModel;
    }
    return m_contextsSelectionModel;
QAbstractItemModel *ModelStack::contextsComboModel()
    if (!m_con

        ComboModel *contextsComboModel = new ComboModel(this);
        KDescendantsProxyModel *descendantProxyModel = new KDescendantsProxyModel(contextsComboModel);
        descendantProxyModel->setSourceModel(contextsSideBarModel());
        descendantProxyModel->setDisplayAncestorData(true);
        contextsComboModel->setSourceModel(descendantProxyModel);
        m_contextsComboModel = contextsComboModel;
    }
    return m_contextsComboModel;
QAbstractItemModel* ModelStack::knowledgeBaseModel()
    return DataStoreInterface::instance().noteBaseModel();
QAbstractItemModel *ModelStack::topicsTreeModel()
    if (!m_topicsTreeModel) {
        ReparentingModel *treeModel = new ReparentingModel(new StructureCacheStrategy(PimItemRelation::Topic), this);
        treeModel->setSourceModel(knowledgeBaseModel());
        m_topicsTreeModel = treeModel;
    }
    return m_topicsTreeModel;
QAbstractItemModel *ModelStack::knowledgeSideBarModel()
    if (!m_knowledgeSidebarModel) {
        SideB
/*************************************************************************
	> File Name: packet_handler.cpp
	> Author: cjj
	> Created Time: Thu 10 Apr 2014 09:36:30 AM CST
 ************************************************************************/
namespace game_server
struct PacketHandler
	PacketHandler(void (WorldSession::*_handler)(base::WorldPacket&)) : handler(_handler){}
	PacketHandler() : handler(NULL){}
	void (WorldSession::*handler)(base::WorldPacket &);
};
class PacketHandlerMgr
public:
	static PacketHandlerMgr * GetInstance()
	{
		static PacketHandlerMgr _instance;
		return &_instance;
	}
	void AddHandler(int opCodes, void (WorldSession::*_handler)(base::WorldPacket &))
	{
		map_handler.insert(std::make_pair(opCodes, PacketHandler(_handler)));
	}
	PacketHandler  GetHandler(int opCode)
	{
		std::map<int, PacketHandler>::iterator iter = map_handler.find(opCode);
		if(iter != map_handler.end())
		{
			return iter->second;
		}
		else
		{
			return PacketHandler();
		}
	}
private:
using namespace std;
struct Group {
    int t, m;
};
struct State {
    int n;
    Group v[20];
};
void compact(State& s, int invoke) {
    if (s.v[invoke].m >= 3) {
        int i;
        for(i = 1; invoke-i >= 0 && invoke+i < s.n; i++) {
            if (s.v[invoke-i].t != s.v[invoke+i].t ||
                s.v[invoke-i].m + s.v[invoke+i].m < 3)
                break;
        }
        if (invoke-i < 0 && invoke+i >= s.n) {
            s.n = 0;
        }
        else if (invoke-i >= 0) {
            s.n = invoke-i+1;
        }
        else {
            int pos = invoke+i;
            for(int j = 0; j < s.n-pos; j++)
                s.v[j] = s.v[pos+j];
            s.n = s.n - pos;
        }
    }
void search(int depth, const State& s, const vector<int>& h, int lim) {
    if (s.empty())
        throw lim;
    State t;
    for(int i = 0; i < s.n; i++) {
        
    }
int main() {
    int nCases;
    cin >> nCases;
    for(int iCase = 0; iCase < nCases; iCase++) {
        int n, k;
   
/*================================================================================
  code generated by: java2cpp
  class: javax.xml.transform.SourceLocator
================================================================================*/
namespace j2cpp { namespace java { namespace lang { class String; } } }
namespace j2cpp { namespace java { namespace lang { class Object; } } }
namespace j2cpp {
namespace javax { namespace xml { namespace transform {
	class SourceLocator;
	class SourceLocator
		: public object<SourceLocator>
	{
	public:
		J2CPP_DECLARE_CLASS
		J2CPP_DECLARE_METHOD(0)
		J2CPP_DECLARE_METHOD(1)
		J2CPP_DECLARE_METHOD(2)
		J2CPP_DECLARE_METHOD(3)
		explicit SourceLocator(jobject jobj)
		: object<SourceLocator>(jobj)
		{
		}
		operator local_ref<java::lang::Object>() const;
		local_ref< java::lang::String > getPublicId();
		local_ref< java::lang::String > getSystemId();
		jint getLineNumber();
		jint getColumnNumber();
namespace j2cpp {
javax::xml::transform::SourceLocat

	return local_ref<java::lang::Object>(get_jobject());
local_ref< java::lang::String > javax::xml::transform::SourceLocator::getPublicId()
	return call_method<
		javax::xml::transform::SourceLocator::J2CPP_CLASS_NAME,
		javax::xml::transform::SourceLocator::J2CPP_METHOD_NAME(0),
		javax::xml::transform::SourceLocator::J2CPP_METHOD_SIGNATURE(0), 
		local_ref< java::lang::String >
	>(get_jobject());
local_ref< java::lang::String > javax::xml::transform::SourceLocator::getSystemId()
	return call_method<
		javax::xml::transform::SourceLocator::J2CPP_CLASS_NAME,
		javax::xml::transform::SourceLocator::J2CPP_METHOD_NAME(1),
		javax::xml::transform::SourceLocator::J2CPP_METHOD_SIGNATURE(1), 
		local_ref< java::lang::String >
	>(get_jobject());
jint javax::xml::transform::SourceLocator::getLineNumber()
	return call_method<
		javax::xml::transform::SourceLocator::J2CPP_CLASS_NAME,
		javax::xml::transform::SourceLocator::J2CPP_METHOD_NAME(2),
		javax::xml::transform::SourceLocator::J2CPP_METHOD_
Spawner::Spawner(World &world) : _world(world)
Spawner::~Spawner()
int			Spawner::isChunkSpawnable(Chunk *chunk,
						  const std::vector<Client *> &clients UNUSED)
  const Vector2i	&pos = chunk->getPosition();
  for (unsigned int idx = 0; idx < Chunk::lod; ++idx)
    {
      const t_ChunkInfo	&cInfo = chunk->getChunkInfo(idx);
      int		dist = (cInfo.avHeight + MIDDLEHEIGHT)
	- (pos.y * static_cast<int>(Chunk::pHeight));
      if (dist >= 0 && dist < static_cast<int>(Chunk::pHeight))
	return idx;
    }
  return -1;
bool		Spawner::placePlayerOnSurface(Chunk *chunk,
						     unsigned int chunkPart,
						     Vector2u &chunkPos)
  const std::vector<TileType>	&tiles = chunk->getTiles();
  unsigned int	xPad;
  unsigned int	lodSize;
  lodSize = Chunk::width / Chunk::lod;
  xPad = chunkPart * lodSize;
  std::cout << "XPAD: " << xPad << std::endl;
  for (unsigned int pos = xPad; pos < xPad + lodSize; ++pos)
    {
      if (tiles[pos] != TileType::Empty)
	continue ;
      for (unsigned in

	{
	  if (tiles[y * Chunk::width + pos] == TileType::Empty &&
	      tiles[(y - 1) * Chunk::width + pos] != TileType::Empty)
	    {
	      chunkPos = {pos, y};
	      return true;
	    }
	}
    }
  return false;
void		Spawner::moveToSurface(Vector2i &chunkId,
					      const std::vector<Client *> &clients) const
  Chunk		*chunk;
  float		chunkMidDist;
  int		dist;
  while (true)
    {
      if (!_world.isChunkLoaded(chunkId))
	chunk = _world.loadChunk(chunkId, clients, chunkId);
      else
	chunk = _world.getChunk(chunkId);
      chunkMidDist = 0;
      for (unsigned int idx = 0; idx < Chunk::lod; ++idx)
	{
	  const t_ChunkInfo	&cInfo = chunk->getChunkInfo(idx);
	  dist = (cInfo.avHeight + MIDDLEHEIGHT)
	    - (chunkId.y * static_cast<int>(Chunk::pHeight));
	  chunkMidDist += dist;
	  if (dist >= 0 && dist < static_cast<int>(Chunk::pHeight))
	    return ;
	}
      chunkMidDist /= static_cast<float>(Chunk::lod);
      chunkMidDist /= static_cast<float>(Chunk::pHeight);
      if (chunk

	chunkMidDist -= 1;
      chunkMidDist = std::ceil(chunkMidDist);
      chunkId.y += chunkMidDist;
      std::cout << chunkId.y << " " << chunkMidDist << std::endl;
    }
void		Spawner::spawnClient(const std::vector<Client *> &clients,
					    Client *client)
  ClientEntity	&clEnt = client->getEntity();
  Vector2i	chunkId(0,0);
  Vector2u	plPos;
  Chunk		*chunk;
  int		chunkPart;
  std::cout << "New client -> Spawn init" << std::endl;
  for (int dist = 0; true; dist++)
    {
      for (int side = -dist; side <= dist; side += (dist * 2))
	{
	  chunkId.x = side;
	  moveToSurface(chunkId, clients);
	  chunk = _world.getChunk(chunkId);
	  if ((chunkPart = isChunkSpawnable(chunk, clients)) != -1)
	    if (placePlayerOnSurface(chunk, chunkPart, plPos) == true)
	      {
		clEnt.setChunkId(chunk->getPosition());
		clEnt.setPosition(Vector2f(static_cast<float>(plPos.x) / Chunk::width,
					   static_cast<float>(plPos.y) / Chunk::height));
		return ;
	      }
	  if (dist == 0)
	    break ;
	}

/**
 * @file VideoBuffer.cc
 * @author Yasser Seyyedi, Behnam Ahmadifar
 */
VideoBuffer::VideoBuffer(int NumOfBFrame,int BufferSize, int ChunkSize, int GopSize)
	gopSize = GopSize;
	numOfBFrame = NumOfBFrame;
	bufferSize = BufferSize;
	chunkSize = ChunkSize;
	lastSetChunk = 0;
	lastSetFrame = 0;
	chunkBuffer = new Chunk[bufferSize];
	for(int i = 0 ; i < bufferSize ; i++)
	{
		chunkBuffer[i].setValues(chunkSize);
		chunkBuffer[i].setChunkNumber(i);
	}
VideoBuffer::~VideoBuffer()
	delete[] chunkBuffer;
void VideoBuffer::updateBufferMap(BufferMap* BMap)
	for(int i=0 ; i < bufferSize ; i++)
	{
		if(chunkBuffer[i].isComplete())
			BMap->buffermap[i] = true;
		else
			BMap->buffermap[i] = false;
		BMap->chunkNumbers[i] = chunkBuffer[i].getChunkNumber();
	}
	BMap->setLastSetChunk(lastSetChunk);
std::ostream& operator<<(std::ostream& os, const VideoBuffer& v)
	for (int i=0 ; i < v.bufferSize ; i++)
	{
		os << v.chunkBuffer[i];
		if((i+1)%v.gopSize == 0)
			os << std::endl;
	}
	return os;
void 

	for(int j=0 ; j < 1 ; j++)
	{
		for(int i=0 ; i < bufferSize-1 ; i++)
		{
			chunkBuffer[i] = chunkBuffer[i+1];
		}
		Chunk ch;
		ch.setValues(chunkSize);
		ch.setChunkNumber(chunkBuffer[bufferSize-2].getChunkNumber()+1);
		chunkBuffer[bufferSize-1] = ch;
	}
void VideoBuffer::setFrame(VideoFrame vFrame)
	int ExtractedChunkNum = vFrame.getFrameNumber()/(chunkSize);
	while(ExtractedChunkNum > chunkBuffer[bufferSize-2].getChunkNumber())
			shiftChunkBuf();
	if(ExtractedChunkNum >=  chunkBuffer[0].getChunkNumber() &&
			ExtractedChunkNum <= chunkBuffer[bufferSize-1].getChunkNumber())
	{
		chunkBuffer[ExtractedChunkNum - chunkBuffer[0].getChunkNumber()].setFrame(vFrame);
		if(lastSetFrame < vFrame.getFrameNumber())
			lastSetFrame = vFrame.getFrameNumber();
		if(chunkBuffer[ExtractedChunkNum - chunkBuffer[0].getChunkNumber()].isComplete())
			lastSetChunk = ExtractedChunkNum;
	}
	/*else
		std::cout << "(ChunkBuffer::setFrame) ChunkBuffer Out of boundary!!!!!!!!" << std::endl;*/
VideoFrame

	int ExtractedChunkNum = FrameNumber/(chunkSize);
	if(ExtractedChunkNum >=  chunkBuffer[0].getChunkNumber() &&
			ExtractedChunkNum <= chunkBuffer[bufferSize-1].getChunkNumber())
		return chunkBuffer[ExtractedChunkNum - chunkBuffer[0].getChunkNumber()]
		                   .chunk[FrameNumber%chunkSize].getVFrame();
	/*else
	{
		std::cout << chunkBuffer[0].getChunkNumber() << "  to  "<< chunkBuffer[bufferSize-1].getChunkNumber()<< std::endl;
		std::cout << "ExtractedChunkNum : "<<ExtractedChunkNum <<std::endl;
		std::cout << "(VideoBuffer::getFrame) ChunkBuffer Out of boundary!!!!!!!!" << std::endl;
	}*/
Chunk VideoBuffer::getChunk(int ChunkNumber)
	if(ChunkNumber >=  chunkBuffer[0].getChunkNumber() &&
			ChunkNumber <= chunkBuffer[bufferSize-1].getChunkNumber())
	{
		return chunkBuffer[ChunkNumber - chunkBuffer[0].getChunkNumber()];
	}
	/*else
	{
		std::cout << chunkBuffer[0].getChunkNumber() << "  to  "<< chunkBuffer[bufferSize-1].getChunkNumber()<< std::endl;
		std::cout << "ChunkNu
using namespace engine;
using namespace sgl;
ChunkManager::ChunkManager(int x, int y, int z, const char *atlasName) : ChunkManager(x, y, z, 16, 1, atlasName)
ChunkManager::ChunkManager(int x, int y, int z, int blocksPerChunk, float blockSize, const char *atlasName) :
	_blockX(x),
	_blockY(y),
	_blockZ(z),
	_blocksPerChunk(blocksPerChunk),
	_blockSize(blockSize),
	_rebuildsPerFrame(5),
	_atlasName(atlasName),
	_renderDebug(false),
	_updateBoundingVolume(true)
	allocateChunks(blocksPerChunk, blockSize);
	_worldTransform.toTranslation(0, 0, 0);
void ChunkManager::update()
	if (_updateBoundingVolume)
	{
		updateChunkVolumes();
		_updateBoundingVolume = false;
	}
	rebuildChunks();
void ChunkManager::updateVisiblityList(Frustum& frustum)
	_chunkRenderSet.clear();
	int i, j, k;
	for (i = 0; i < _size; ++i)
	{
		for (j = 0; j < _size; ++j)
		{
			for (k = 0; k < _size; ++k)
			{
				Chunk& chunk = getChunk(i, j, k);
				Sphere& bounds = chunk.getBounds();
				Frustum::Side side = frustum.check

				if (side == Frustum::Side::INSIDE || side == Frustum::Side::INTERSECT)
				{
					if (chunk.isSetup())
					{
						_chunkRenderSet.insert(&chunk);
					}
					else
					{
						_chunkRebuildSet.insert(&chunk);
					}
				}
			}
		}
	}
void ChunkManager::translate(float x, float y, float z)
	_worldTransform.translate(x, y, z);
	_updateBoundingVolume = true;
void ChunkManager::rotate(float x, float y, float z)
	_worldTransform.rotate(x, y, z);
	_updateBoundingVolume = true;
void ChunkManager::scale(float s)
	_worldTransform.scale(s);
	_updateBoundingVolume = true;
void ChunkManager::render()
	ChunkSet::iterator iter;
	for (iter = _chunkRenderSet.begin(); iter != _chunkRenderSet.end(); ++iter)
	{
		Chunk* chunk = (*iter);
		
		if (chunk->shouldRender())
		{
			chunk->render();
		}
	}
void ChunkManager::updateChunkVolumes()
	int i, j, k;
	for (i = 0; i < _size; ++i)
		for (j = 0; j < _size; ++j)
			for (k = 0; k < _size; ++k)
			{
				Chunk& chunk = getChunk(i, j, k);
				chunk.calcu

			}
	_updateBoundingVolume = false;
Block ChunkManager::getBlockFromWorldPosition(const sgl::Vector3& p)
	return getBlockFromWorldPosition(p.x, p.y, p.z);
Block ChunkManager::getBlockFromWorldPosition(float x, float y, float z)
	float blockRenderSize = _blockSize * 2;
	int blockX = (int)(x / blockRenderSize);
	int blockY = (int)(y / blockRenderSize);
	int blockZ = (int)(z / blockRenderSize);
	return getBlock(blockX, blockY, blockZ);
Chunk& ChunkManager::getChunkFromWorldPosition(const sgl::Vector3& pos)
	return getChunkFromWorldPosition(pos.x, pos.y, pos.z);
Chunk& ChunkManager::getChunkFromWorldPosition(float x, float y, float z)
	float chunkRenderSize = (float)(_blocksPerChunk * _blockSize * 2);
	int chunkX = (int)(x / chunkRenderSize);
	int chunkY = (int)(y / chunkRenderSize);
	int chunkZ = (int)(z / chunkRenderSize);
	return getChunk(chunkX, chunkY, chunkZ);
Block ChunkManager::getBlock(int x, int y, int z)
	int chunkX = x / _blocksPerChunk;
	int chunkY = y / _blocksPerChunk;
	in

	int blockX = x % _blocksPerChunk;
	int blockY = y % _blocksPerChunk;
	int blockZ = z % _blocksPerChunk;
	Chunk& chunk = getChunk(chunkX, chunkY, chunkZ);
	return *chunk.getBlock(blockX, blockY, blockZ);
void ChunkManager::setBlock(int x, int y, int z, int t)
	int chunkX = x / _blocksPerChunk;
	int chunkY = y / _blocksPerChunk;
	int chunkZ = z / _blocksPerChunk;
	int blockX = x % _blocksPerChunk;
	int blockY = y % _blocksPerChunk;
	int blockZ = z % _blocksPerChunk;
	Chunk& chunk = getChunk(chunkX, chunkY, chunkZ);
	chunk.setBlock(blockX, blockY, blockZ, t);
void ChunkManager::setLightSource(int x, int y, int z, int r, int g, int b)
	int chunkX = x / _blocksPerChunk;
	int chunkY = y / _blocksPerChunk;
	int chunkZ = z / _blocksPerChunk;
	int blockX = x % _blocksPerChunk;
	int blockY = y % _blocksPerChunk;
	int blockZ = z % _blocksPerChunk;
	Chunk& chunk = getChunk(chunkX, chunkY, chunkZ);
	chunk.setLightSource(blockX, blockY, blockZ, r, g, b);
void ChunkManager::removeLight(int x, int y

	int chunkX = x / _blocksPerChunk;
	int chunkY = y / _blocksPerChunk;
	int chunkZ = z / _blocksPerChunk;
	int blockX = x % _blocksPerChunk;
	int blockY = y % _blocksPerChunk;
	int blockZ = z % _blocksPerChunk;
	Chunk& chunk = getChunk(chunkX, chunkY, chunkZ);
	chunk.removeLight(blockX, blockY, blockZ);
Chunk& ChunkManager::getChunk(int x, int y, int z)
	if (x < 0) x = 0;
	if (y < 0) y = 0;
	if (z < 0) z = 0;
	Chunk& chunk = *(_chunks[(x * _size) + (y * _size * _size) + z]);
	if (!chunk.hasLocation())
	{
		chunk.setLocation(x, y, z);
		chunk.calculateBounds(_worldTransform);
		setChunkNeighbors(chunk);
		chunk.setUpdateCallback(std::bind(&ChunkManager::updateCallback, this, std::placeholders::_1));
	}
	return chunk;
void ChunkManager::rebuildChunks()
	if (_chunkRebuildSet.size() == 0) return;
	int rebuiltCount = 0;
	ChunkList rebuilt;
	ChunkSet::iterator iter;
	for (iter = _chunkRebuildSet.begin(); rebuiltCount < _rebuildsPerFrame && iter != _chunkRebuildSet.end(); ++iter)
	{
		Chunk* 

		chunk->build();
		rebuilt.push_back(chunk);
		_chunkRenderSet.insert(chunk);
		rebuiltCount++;
	}
	ChunkList::iterator rebuiltIter;
	for (rebuiltIter = rebuilt.begin(); rebuiltIter != rebuilt.end(); ++rebuiltIter)
	{
		_chunkRebuildSet.erase(*rebuiltIter);
	}
void ChunkManager::updateCallback(Chunk* chunk)
	_chunkRebuildSet.insert(chunk);
int ChunkManager::getBlockX() const
	return _blockX;
int ChunkManager::getBlockY() const
	return _blockY;
int ChunkManager::getBlockZ() const
	return _blockZ;
sgl::Matrix4& ChunkManager::getWorldTransform()
	return _worldTransform;
void ChunkManager::setAtlasName(const std::string& name)
	_atlasName = name;
std::string ChunkManager::getAtlasName()
	return _atlasName;
void ChunkManager::setRenderDebug(bool d)
	_renderDebug = d;
bool ChunkManager::boundingVolumeOutOfDate()
	return _updateBoundingVolume;
void ChunkManager::allocateChunks(int chunkSize, float blockSize)
	int xSize = _blockX / chunkSize;
	int ySize = _blockY / chunkSize;
	int zSize = _b

	if (xSize >= ySize && xSize >= zSize) _size = xSize;
	if (ySize >= xSize && ySize >= zSize) _size = ySize;
	if (zSize >= ySize && zSize >= xSize) _size = zSize;
	int chunksToAllocate = _size * _size * _size;
	int i;
	for (i = 0; i < chunksToAllocate; ++i)
	{
		Chunk* chunk = new Chunk(chunkSize, blockSize);
		chunk->setAtlasName(_atlasName);
		_chunks.push_back(chunk);
	}
void ChunkManager::setChunkNeighbors(Chunk& chunk)
	Vector3 loc = chunk.getLocation();
	int x = (int)loc.x;
	int y = (int)loc.y;
	int z = (int)loc.z;
	if (x - 1 >= 0)
		chunk.left   = &getChunk(x - 1, y, z);
	if (x + 1 < _size)
		chunk.right  = &getChunk(x + 1, y, z);
	if (y + 1 < _size)
		chunk.top    = &getChunk(x, y + 1, z);
	if (y - 1 >= 0)
		chunk.bottom = &getChunk(x, y - 1, z);
	if (z - 1 >= 0)
		chunk.near   = &getChunk(x, y, z - 1);
	if (z + 1 < _size)
		chunk.far    = &getChunk(x, y, z + 1);
ChunkManager::~ChunkManager()
	ChunkList::iterator iter;
	for (iter = _chunks.begin(); iter != _chunks.end(); ++iter
using namespace Isis;
using namespace std;
int main(int argc, char *argv[]) {
  Isis::Preference::Preferences(true);
  QString fname = "$base/testData/isisTruth.cub";
  Isis::Cube cube;
  cube.open(fname);
  Isis::SampleManager sample(cube);
  cout << "Buffer Size:  " <<
       sample.SampleDimension() << " " <<
       sample.LineDimension() << " " <<
       sample.BandDimension() << endl;
  cout << endl;
  for(sample.begin(); !sample.end(); sample++) {
    cout << "  Current sample, line, band is:  "
         << sample.Sample() << " "
         << sample.Line() << " "
         << sample.Band() << endl;
  }
  cout << endl;
  Isis::SampleManager sampleReverse(cube, true);
  cout << "Buffer Size:  " <<
       sampleReverse.SampleDimension() << " " <<
       sampleReverse.LineDimension() << " " <<
       sampleReverse.BandDimension() << endl;
  cout << endl;
  for(sampleReverse.begin(); !sampleReverse.end(); sampleReverse++) {
    cout << "  Current sample, line, band is:  "
         << sa
field_sample::field_sample(nsecs_t timestamp)
: timestamp(timestamp)
, ball_set(false)
field_sample::~field_sample()
void field_sample::add_robot (bot_sample sample)
        robots.insert(std::make_pair(sample.get_id(), sample));
void field_sample::add_ball (ball_sample sample)
        this->ball = sample;
        this->ball_set = true;
bool field_sample::get_robot(e_robot id, const bot_sample* &sample) const
        if (robots.count(id) != 0) {
                sample = &robots.at(id);
                return true;
        }
                return false;
bool field_sample::get_ball (const ball_sample* &sample) const
        if (ball_set)
                sample = &this->ball;
        return ball_set;
int field_sample::get_sampled_bots_count() const
        return (int)robots.size();
bool field_sample::get_bot_sampled(e_robot rid) const
        return robots.count(rid) != 0;
bool field_sample::get_ball_sampled() const
        return ball_set;
nsecs_t field_sample::get_timestamp() const
  
/*
** $Id: lundump.c,v 1.60 2006/02/16 15:53:49 lhf Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;
static void error(LoadState* S, const char* why)
 luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
 luaD_throw(S->L,LUA_ERRSYNTAX);
static void LoadBlock(LoadState* S, void* b, size_t size)
 size_t r=luaZ_read(S->Z,b,size);
 IF (r!=0, "unexpected end");
static int LoadChar(LoadState* S)
 char x;
 LoadVar(S,x);
 return x;
static int LoadInt(LoadState* S)
 int x;
 LoadVar(S,x);
 IF (x<0, "bad integer");
 return x;
static lua_Number LoadNumber(LoadState* S)
 lua_Number x;
 LoadVar(S,x);
 return x;
static TString* LoadString(LoadState* S)
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S->L,S->b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
 }
static void LoadCode(LoadSt

 int n=LoadInt(S);
 f->code=luaM_newvector(S->L,n,Instruction);
 f->sizecode=n;
 LoadVector(S,f->code,n,sizeof(Instruction));
static Proto* LoadFunction(LoadState* S, TString* p);
static void LoadConstants(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->k=luaM_newvector(S->L,n,TValue);
 f->sizek=n;
 for (i=0; i<n; i++) setnilvalue(&f->k[i]);
 for (i=0; i<n; i++)
 {
  TValue* o=&f->k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S));
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S->L,o,LoadString(S));
	break;
   default:
	IF (1, "bad constant");
	break;
  }
 }
 n=LoadInt(S);
 f->p=luaM_newvector(S->L,n,Proto*);
 f->sizep=n;
 for (i=0; i<n; i++) f->p[i]=NULL;
 for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
static void LoadDebug(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->lineinfo=luaM_newvector(S->L,n,int);
 f->sizelineinfo=

 LoadVector(S,f->lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f->locvars=luaM_newvector(S->L,n,LocVar);
 f->sizelocvars=n;
 for (i=0; i<n; i++) f->locvars[i].varname=NULL;
 for (i=0; i<n; i++)
 {
  f->locvars[i].varname=LoadString(S);
  f->locvars[i].startpc=LoadInt(S);
  f->locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f->upvalues=luaM_newvector(S->L,n,TString*);
 f->sizeupvalues=n;
 for (i=0; i<n; i++) f->upvalues[i]=NULL;
 for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
static Proto* LoadFunction(LoadState* S, TString* p)
 Proto* f=luaF_newproto(S->L);
 setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
 f->source=LoadString(S); if (f->source==NULL) f->source=p;
 f->linedefined=LoadInt(S);
 f->lastlinedefined=LoadInt(S);
 f->nups=LoadByte(S);
 f->numparams=LoadByte(S);
 f->is_vararg=LoadByte(S);
 f->maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), "bad code");
 S->L->top--;
 return f;
static void LoadHeader(LoadState* S)
 char h[
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla browser.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications, Inc.
 * Portions created by the Initial Developer are Copyright (C) 1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Travis Bogard <travis@netscape.com>
 *
 * Alternatively, the contents of this file may

 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g

 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LO

    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOA

    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_FLAGS_NONE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CA
/** 使用示例：
@code
uint streamLength = 0;
Handle dataHandle = openStreamSystem("e:/newlife/program/bin/data");
if (!isValidHandle(dataHandle))
	return;
CStream* stream = openStream(dataHandle, "npc/npc1.dat");
if (stream)
	streamLength = stream->getLength();
closeStream(stream);
closeStreamSystem(dataHandle);
dataHandle = openStreamSystem("e:/newlife/program/bin/data.pkg");
if (!isValidHandle(dataHandle))
	return;
CStream* stream = openStream(dataHandle, "npc/npc1.dat");
if (stream)
	streamLength = stream->getLength();
closeStream(stream);
closeStreamSystem(dataHandle);
@endcode
 */
namespace xs{
/** 打开一个流系统
 @param streamSysPath 流路径（当传入文件时会当作包流开启，当传入目录时会当作目录流开启）
 @return 成功返回流系统的句柄，否则返回无效句柄
 */
Handle openStreamSystem(const char* streamSysPath);
/** 关闭一个流系统
 @param streamSysHandle 要关闭的流系统句柄
 @return 成功返回true，否则返回false
 */
bool closeStreamSystem(Handle streamSysHandle);
/** 检测流系统中是否存在指定的流对象
@param streamSysHandle 流系统句柄
@param streamName		指定的流的名字
@return 存在返回true，否则返回false
*/
bool findStre
/*
** $Id: ldump.c,v 1.19 2011/11/23 17:48:18 lhf Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 LuaThread* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  D->status=(*D->writer)(D->L,b,size,D->data);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(double x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const LuaString* s, DumpState* D)
 if (s==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(s->c_str(),size*sizeof(char),D);
 }
static void DumpFunction(const LuaProto* f, DumpState* D);
static void DumpConstants(const LuaProto* f, DumpState* D)
  int n = (int)f->constants.si

  DumpInt(n,D);
  for(int i=0; i < n; i++)
  {
    LuaValue v = f->constants[i];
    DumpChar(v.type(),D);
    if(v.isBool()) {
      DumpChar(v.getBool() ? 1 : 0,D);
    } else if(v.isNumber()) {
      DumpNumber(v.getNumber(),D);
    } else if(v.isString()) {
      DumpString(v.getString(),D);
    }
  }
  n = (int)f->subprotos_.size();
  DumpInt(n,D);
  for (int i=0; i < n; i++) {
    DumpFunction(f->subprotos_[i],D);
  }
static void DumpUpvalues(const LuaProto* f, DumpState* D)
 int i,n=(int)f->upvalues.size();
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpChar(f->upvalues[i].instack,D);
  DumpChar(f->upvalues[i].idx,D);
 }
static void DumpDebug(const LuaProto* f, DumpState* D)
 int i,n;
 DumpString((D->strip) ? NULL : f->source,D);
 n= (D->strip) ? 0 : (int)f->lineinfo.size();
 DumpVector(f->lineinfo.begin(),n,sizeof(int),D);
 n= (D->strip) ? 0 : (int)f->locvars.size();
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
/*
 * File automatically generated by
 * gengen 1.2 by Lorenzo Bettini 
 */
void
reset_group_gen_class::generate_reset_group(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  stream << "static void";
  stream << "\n";
  stream << indent_str;
  stream << "reset_group_";
  generate_string (name, stream, indent + indent_str.length ());
  stream << "(struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  if (! args_info->";
  generate_string (name, stream, indent + indent_str.length ());
  stream << "_group_counter)";
  stream << "\n";
  stream << indent_str;
  stream << "    return;";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (body, stream, indent +
/*
** $Id: ldump.cpp 53568 2010-10-18 17:12:00Z sev $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConstants(const

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOA

    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_NORMAL_ALLOW_MIXED_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_ALLOW_MIXED_CONTENT | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebN

    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_ALLOW_MIXED_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_ALLOW_MIXED_CONTENT | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavig

    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_REPLACE_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(uint32_t aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_B
/*
 * File automatically generated by
 * gengen 1.4.3 by Lorenzo Bettini 
 */
using std::string;
using std::ostream;
class genfunction_lua_gen_class
 protected:
  string assignfields;
  string geninstructions;
  string genname;
  string genparameters;
 public:
  genfunction_lua_gen_class()
  {
  }
  
  genfunction_lua_gen_class(const string &_assignfields, const string &_geninstructions, const string &_genname, const string &_genparameters) :
    assignfields (_assignfields), geninstructions (_geninstructions), genname (_genname), genparameters (_genparameters)
  {
  }
  virtual ~genfunction_lua_gen_class()
  {
  }
  static void
  generate_string(const string &s, ostream &stream, unsigned int indent)
  {
    if (!indent || s.find('\n') == string::npos)
      {
        stream << s;
        return;
      }
    string::size_type pos;
    string::size_type start = 0;
    string ind (indent, ' ');
    while ( (pos=s.find('\n', start)) != string::npos)
      {
        stream << s.substr (sta

        start = pos+1;
        if (start+1 <= s.size ())
          stream << ind;
      }
    if (start+1 <= s.size ())
      stream << s.substr (start);
  }
  virtual void generate_assignfields(ostream &stream, unsigned int indent) = 0;
  void set_assignfields(const string &_assignfields)
  {
    assignfields = _assignfields;
  }
  virtual void generate_geninstructions(ostream &stream, unsigned int indent) = 0;
  void set_geninstructions(const string &_geninstructions)
  {
    geninstructions = _geninstructions;
  }
  void set_genname(const string &_genname)
  {
    genname = _genname;
  }
  virtual void generate_genparameters(ostream &stream, unsigned int indent) = 0;
  void set_genparameters(const string &_genparameters)
  {
    genparameters = _genparameters;
  }
  void generate_genfunction_lua(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "\n";
    stream << indent_str;
    stream << "function generate_";
    s

    stream << "(stream, record, indent)";
    stream << "\n";
    stream << indent_str;
    stream << "  local id = {}";
    stream << "\n";
    stream << indent_str;
    stream << "  local indent_str = \"\"";
    stream << "\n";
    stream << indent_str;
    stream << "  for i = 1, indent do";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  indent_str = table.concat(id)";
    stream << "\n";
    stream << indent_str;
    stream << "  -- save context";
    stream << "\n";
    stream << indent_str;
    stream << "  local ctx = io.output()";
    stream << "\n";
    stream << indent_str;
    stream << "  io.output(stream)";
    stream << "\n";
    stream << indent_str;
    indent = 2;
    if (geninstructions.size () > 0)
      generate_string (geninstructions, stream, indent + indent_str.length ());
    else
      generate_geninstructions (stream, indent + ind

    indent = 0;
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  -- restore context";
    stream << "\n";
    stream << indent_str;
    stream << "  io.output(ctx)";
    stream << "\n";
    stream << indent_str;
    stream << "end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "function generatep_";
    stream << genname;
    stream << "(stream, indent";
    if (genparameters.size () > 0)
      generate_string (genparameters, stream, indent + indent_str.length ());
    else
      generate_genparameters (stream, indent + indent_str.length ());
    stream << ")";
    stream << "\n";
    stream << indent_str;
    stream << "  record = {}";
    stream << "\n";
    stream << indent_str;
    indent = 2;
    stream << "  ";
    if (assignfields.size () > 0)
      generate_string (assignfields, stream, indent + indent_str.length ());
    else
      generate_assignfields (stream, indent + inden
template <typename Type>
Type* lower_bound(Type* arrayBegin, Type* arrayEnd, Type key)
	std::less<Type> pred;
	size_t left = 0;
	size_t right = arrayEnd - arrayBegin;
	size_t mid;
	while (left < right)
	{
		mid = (left + right) >> 1;
		{
			left = mid + 1;
		}
		else
		{
			right = mid;
		}
	}
	return arrayBegin + left;
template <typename Type>
Type* upper_bound(Type* arrayBegin, Type* arrayEnd, Type key)
	std::less<Type> pred;
	size_t left = 0;
	size_t right = arrayEnd - arrayBegin;
	size_t mid;
	while (left < right)
	{
		mid = (left + right) >> 1;
		{
			left = mid + 1;
		}
		else
		{
			right = mid;
		}
	}
	return arrayBegin + left;
int _tmain(int argc, _TCHAR* argv[])
	std::vector<int> sample;
	sample.push_back(1);
	sample.push_back(2);
	sample.push_back(5);
	sample.push_back(9);
	sample.push_back(10);
	sample.push_back(21);
	int key;
	int* found;
	std::vector<int>::iterator answer;
	key = 1;
	found = lower_bound(&sample[0], &sample[0] + sample.size(), key);
	answer = std::lower_bo

	assert(answer == sample.end() ? (found == &sample[0]+sample.size()) : (*found == *answer));
	key = 8;
	found = lower_bound(&sample[0], &sample[0] + sample.size(), key);
	answer = std::lower_bound(sample.begin(), sample.end(), key);
	assert(answer == sample.end() ? (found == &sample[0]+sample.size()) : (*found == *answer));
	key = 39;
	found = lower_bound(&sample[0], &sample[0] + sample.size(), key);
	answer = std::lower_bound(sample.begin(), sample.end(), key);
	assert(answer == sample.end() ? (found == &sample[0]+sample.size()) : (*found == *answer));
	key = 2;
	found = upper_bound(&sample[0], &sample[0] + sample.size(), key);
	answer = std::upper_bound(sample.begin(), sample.end(), key);
	assert(answer == sample.end() ? (found == &sample[0]+sample.size()) : (*found == *answer));
	key = 10;
	found = upper_bound(&sample[0], &sample[0] + sample.size(), key);
	answer = std::upper_bound(sample.begin(), sample.end(), key);
	assert(answer == sample.end() ? (found == &sample[0]+sample.size
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
	namespace worker {
		/*!
		* Worker class to that fetches individual databases from given Mongo client.
		*/
		class CommitWorker : public RepoAbstractWorker {
			Q_OBJECT
		public:
			CommitWorker(
				repo::RepoController *controller, 
				const repo::RepoController::RepoToken *token,
				repo::core::model::RepoScene *scene);
			~CommitWorker();
			
typedef float chunk_t[CHUNK];
void generate( obj::pushdep<chunk_t> out, int n ) {
    for( int i=0; i < n; i += CHUNK ) {
	static chunk_t c;
	for( int j=0; j < CHUNK; ++j ) {
	    c[j] = i+j+1;
	}
	out.push( c );
    }
void delay( obj::popdep<chunk_t> in, obj::pushdep<chunk_t> out, int n ) {
    float prev = 0;
    while( !in.empty() ) {
	const chunk_t & ci = in.pop();
	for( int c=0; c < 2; ++c ) {
	    static chunk_t co;
	    for( int j=0; j < CHUNK; j += 2 ) {
		float f = ci[c*CHUNK/2+j/2];
		co[j] = f;
		co[j+1] = prev;
		prev = f;
	    }
	    out.push( co );
	}
    }
void filter( obj::popdep<chunk_t> in, obj::pushdep<chunk_t> out, float k, int n ) {
    while( !in.empty() ) {
	const chunk_t & ci = in.pop();
	static chunk_t co;
	for( int i=0; i < CHUNK; i += 2 ) {
	    float f0 = ci[i];
	    float f1 = ci[i+1];
	    float ei = f0 - k * f1;
	    float ebari = f1 - k * f0;
	    co[i] = ei;
	    co[i+1] = ebari;
	}
	out.push( co );
    }
void pf( const chunk_t ci ) {
    for( int i=0; 
/*
    Copyright (c) 2007-2009 FastMQ Inc.
    This file is part of 0MQ.
    0MQ is free software; you can redistribute it and/or modify it under
    the terms of the Lesser GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
    0MQ is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    Lesser GNU General Public License for more details.
    You should have received a copy of the Lesser GNU General Public License
*/
zmq::locator_t::locator_t (const char *hostname_)
    if (hostname_) {
        if (!strchr (hostname_, ':')) {
            char buf [256];
            zmq_snprintf (buf, 256, "%s:%d", hostname_,
                (int) default_locator_port);
            hostname_ = buf;
        }
        global_locator = new tcp_socket_t (hostname_, true);
     

    }
    else
        global_locator = NULL;
zmq::locator_t::~locator_t ()
    if (global_locator)
        delete global_locator;
void zmq::locator_t::register_endpoint (const char *name_,
    const char *location_)
    assert (global_locator);
    assert (strlen (name_) <= 255);
    assert (strlen (location_) <= 255);
    unsigned char cmd = create_id;
    global_locator->write (&cmd, 1);
    unsigned char size = (unsigned char) strlen (name_);
    global_locator->write (&size, 1);
    global_locator->write (name_, size);
    size = (unsigned char) strlen (location_);
    global_locator->write (&size, 1);
    global_locator->write (location_, size);
    global_locator->read (&cmd, 1);
    assert (cmd == create_ok_id);
void zmq::locator_t::resolve_endpoint (const char *name_, char *location_,
    size_t location_size_)
    assert (global_locator);
    unsigned char cmd = get_id;
    global_locator->write (&cmd, 1);
    unsigned char size = (unsigned char) strlen (name_);
    global_l
namespace diy
	namespace tds
	{
		TdsMatrix::TdsMatrix(void)
		{
			;
		}
		TdsMatrix::~TdsMatrix(void)
		{
			;
		}
		bool TdsMatrix::LoadFromChunkAndFStream(class TdsChunk& chunk, std::ifstream& in)
		{
			if (chunk.Type != TDS_MESH_MATRIX)
			{
				return false;
			}
			X.LoadFromChunkAndFStream(chunk, in);
			Y.LoadFromChunkAndFStream(chunk, in);
			Z.LoadFromChunkAndFStream(chunk, in);
			Origin.LoadFromChunkAndFStream(chunk, in);
			if (chunk.OnString)
			{
				char buffer[32];
				sprintf(buffer, "%.1f, %.1f, %.1f", X.X, X.Y, X.Z);
				chunk.OnString(buffer, chunk.User);
				sprintf(buffer, "%.1f, %.1f, %.1f", Y.X, Y.Y, Y.Z);
				chunk.OnString(buffer, chunk.User);
				sprintf(buffer, "%.1f, %.1f, %.1f", Z.X, Z.Y, Z.Z);
				chunk.OnString(buffer, chunk.User);
				sprintf(buffer, "%.1f, %.1f, %.1f", Origin.X, Origin.Y, Origin.Z);
				chunk.OnString(buffer, chunk.User);
			}
			return true;
		}
		TdsMatrix::operator glm::mat4(void)
		{
			return glm::mat4
				(
				glm::vec4(glm::
/*
 * Copyright (c) 2002-2005 The RapidSvn Group.
 * Copyright (c) 2005-2009 by Rajko Albrecht (ral@alwins-world.de)
 * Copyright (c) 2011 Tim Besard <tim.besard@gmail.com>
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program (in the file LGPL.txt); if not,
 * write to the Free Software Foundation, Inc., 51 Franklin St,
 * Fifth Floor, Boston, MA 02110-1301 USA
 */
namespace svn {
namespace repository

    struct CreateRepoParameterData
    {
        CreateRepoParameterData()
            :path(),fstype(QString::fromLatin1("fsfs")),_bdbnosync(false),_bdbautologremove(true),
            _pre_1_4_compat(false),_pre_1_5_compat(false),_pre_1_6_compat(false)
        {}
        QString path;
        QString fstype;
        bool _bdbnosync;
        bool _bdbautologremove;
        bool _pre_1_4_compat;
        bool _pre_1_5_compat;
        bool _pre_1_6_compat;
    };
    CreateRepoParameter::CreateRepoParameter()
    {
        _data = new CreateRepoParameterData();
    }
    CreateRepoParameter::~CreateRepoParameter()
    {
    }
    const QString&CreateRepoParameter::path()const
    {
        return _data->path;
    }
    CreateRepoParameter&CreateRepoParameter::path(const QString&path)
    {
        SETIT(path,path);
    }
    const QString&CreateRepoParameter::fstype()const
    {
        return _data->fstype;
    }
    CreateRepoParameter&CreateRepoParameter::fstype(const QString&fstype)

    {
        SETIT(fstype,fstype);
    }
    bool CreateRepoParameter::bdbnosync()const
    {
        return _data->_bdbnosync;
    }
    CreateRepoParameter&CreateRepoParameter::bdbnosync(bool nosync)
    {
        SETIT(_bdbnosync,nosync)
    }
    bool CreateRepoParameter::bdbautologremove()const
    {
        return _data->_bdbautologremove;
    }
    CreateRepoParameter&CreateRepoParameter::bdbautologremove(bool autologremove)
    {
        SETIT(_bdbautologremove,autologremove)
    }
    bool CreateRepoParameter::pre14_compat()const
    {
        return _data->_pre_1_4_compat;
    }
    CreateRepoParameter&CreateRepoParameter::pre14_compat(bool value)
    {
        SETIT(_pre_1_4_compat,value);
    }
    bool CreateRepoParameter::pre15_compat()const
    {
        return _data->_pre_1_5_compat;
    }
    CreateRepoParameter&CreateRepoParameter::pre15_compat(bool value)
    {
        SETIT(_pre_1_5_compat,value);
    }
    bool CreateRepoParameter::pre16_compat()const
    {
     
namespace Js {
    class AsmJsByteCodeDumper : public ByteCodeDumper
    {
    public:
        static void Dump(FunctionBody* body, const WAsmJs::TypedRegisterAllocator* typedRegister, AsmJsFunc* asmFunc);
        static void DumpConstants(AsmJsFunc* func, FunctionBody* body);
        static void DumpOp(OpCodeAsmJs op, LayoutSize layoutSize, ByteCodeReader& reader, FunctionBody* dumpFunction);
        static void DumpIntReg(RegSlot reg);
        static void DumpLongReg(RegSlot reg);
        static void DumpDoubleReg(RegSlot reg);
        static void DumpFloatReg(RegSlot reg);
        static void DumpR8Float(float value);
        static void DumpFloat32x4Reg(RegSlot reg);
        static void DumpInt32x4Reg(RegSlot reg);
        
        static void DumpUint32x4Reg(RegSlot reg);
        static void DumpInt16x8Reg(RegSlot reg);
        static void DumpUint16x8Reg(RegSlot reg);
        static void DumpInt8x16Reg(RegSlot reg);
        static void DumpUint8x16Reg(RegSlot reg);
        static
class Syncer : public Thread
public:
    Syncer() : Thread()
    {
    }
    void pullRepo(HostInfo &localHost,
                  HostInfo &remoteHost,
                  const std::string &uuid)
    {
        RepoInfo local = localHost.getRepo(uuid);
        RepoInfo remote = remoteHost.getRepo(uuid);
        RepoControl repo = RepoControl(local.getPath());
        DLOG("Local and Remote heads mismatch on repo %s", uuid.c_str());
        repo.open();
        if (!repo.hasCommit(remote.getHead())) {
            LOG("Pulling from %s:%s",
                remoteHost.getPreferredIp().c_str(),
                remote.getPath().c_str());
            repo.pull(remoteHost.getPreferredIp(), remote.getPath());
        }
        repo.close();
    }
    void checkRepo(HostInfo &infoSnapshot, const std::string &uuid)
    {
        map<string, HostInfo *> hostSnapshot;
        map<string, HostInfo *>::iterator it;
        RepoInfo localInfo = infoSnapshot.getRepo(uuid);
        hostSnapshot = hosts;
 
/* -*- C++ -*- */
/*
  This heap manages memory in units of Chunks.
  malloc returns a slot within a chunk,
  while free returns slots back to a chunk.
  We completely exhaust the first chunk before we ever get another one.
  Once a chunk (except for our current one) is COMPLETELY empty, it is returned to the superheap.
*/
template <int chunkSize, int slotSize, class Super>
class LazySlotHeap : public Super {
public:
  LazySlotHeap (void)
    : myChunk (new (Super::malloc (chunkSize)) Chunk<chunkSize, slotSize>())
  {}
  ~LazySlotHeap (void)
  {
    Super::free (myChunk);
  }
  inline void * malloc (size_t sz) {
    assert (sz <= slotSize);
    void * ptr = myChunk->getSlot();
    if (ptr == NULL) {
      myChunk = new (Super::malloc (chunkSize)) Chunk<chunkSize, slotSize>();
      ptr = myChunk->getSlot();
      assert (ptr != NULL);
    }
    return ptr;
  }
  inline void free (void * ptr) {
    Chunk<chunkSize, slotSize> * ch = Chunk<chunkSize, slotSize>::getChunk (ptr);
    ch->put
using namespace std;
class SaveModelStates{
public:
	SaveModelStates(string ModelName);
	~SaveModelStates();
private:
	ros::NodeHandle nh;
	ros::Subscriber modelStates_sub_;
	string modelName;
	FILE * f;
	void ReceiveModelStates(const gazebo::ModelStates& modelState);
};
SaveModelStates::SaveModelStates(string ModelName){
	string fileName = "record/" + ModelName + ".log";
	f = fopen(fileName.c_str(),"w");
	modelName = ModelName;
	modelStates_sub_ = nh.subscribe("gazebo/model_states",1,&SaveModelStates::ReceiveModelStates,this);
SaveModelStates::~SaveModelStates(){
	fclose(f);
void SaveModelStates::ReceiveModelStates(const gazebo::ModelStates& modelStates)
	for(unsigned int i=0;i<modelStates.name.size();i++)
	{
		if(modelStates.name[i]==modelName)
		{
			ROS_INFO("Name %s", modelStates.name[i].c_str());
			ROS_INFO("Pose %lf %lf %lf", modelStates.pose[i].position.x, modelStates.pose[i].position.y, modelStates.pose[i].position.z);
			fprintf(f,"%lf %lf %lf\n", modelStates.pose[i].positio
namespace ofxPatches {
	class EdgePrewitt : public Base3x3KernelEffect {	
	public:
		EdgePrewitt * create() { return new EdgePrewitt(); };
		
		EdgePrewitt(){
			name = "Prewitt Edge";
			
			fragmentShader += STRINGIFY(	
										vec4 sample[9];	
										void main(void){
											
											if(pass == 0){											
												for (int i = 0; i < 9; i++){												
													sample[i] = texture2DRect(tex0, gl_TexCoord[0].st + offset[i]);
												}
											}else{
												for (int i = 0; i < 9; i++){												
													sample[i] = texture2DRect(backbuffer, gl_TexCoord[0].st + offset[i]);
												}
											}
											
											vec4 horizEdge = sample[2] + sample[5] + sample[8] -
											(sample[0] + sample[3] + sample[6]);
											
											vec4 vertEdge = sample[0] + sample[1] + sample[2] -
											(sample[6] + sample[7] + sample[8]);
											
											gl_FragColor.rgb = sqrt((horizEdge.rgb * horizEdge.rgb) + 
																	(ver
ChunkManager::ChunkManager(ChunkRenderer* chunk_renderer) : _chunk_renderer(chunk_renderer) {
        ASSERT(_chunk_renderer, "null chunk renderer");
        Chunk* chunk = new Chunk();
        chunk->pos = glm::vec3(0, 0, 0);
        BuildChunk(chunk);
        _chunk_renderer->BuildMesh(chunk);
        _chunk_renderer->RegisterChunk(chunk);
        _chunks.push_back(chunk);
ChunkManager::~ChunkManager() {
    for(Chunk* chunk : _chunks) {
        delete chunk;
    }
void ChunkManager::BuildChunk(Chunk* chunk) {
    uint32_t chunkVoxelCount = k_chunkVoxelDims.x * k_chunkVoxelDims.y * k_chunkVoxelDims.z;
    chunk->voxels = new Voxel[chunkVoxelCount];
    chunk->num_voxels = chunkVoxelCount;
    uint32_t ground_voxel_count = 0;
    float z = chunk->pos.z + ((k_chunkDims.z / 2.f) - (k_voxelDims.z / 2.f));
    for (uint32_t k = 0; k < k_chunkVoxelDims.z; ++k) {
        float y = chunk->pos.y + ((k_chunkDims.y / 2.f) - (k_voxelDims.y / 2.f));
        for (uint32_t j = 0; j < k_chunkVoxelDi
/*
 *  Filename: 		Scenegraph.cpp
 *  Project:		crfStressTest
 *  Author:		Stefan Broder (brods1@bfh.ch)
 *  Creation Date:	29.05.2009
 *  Purpose:		Create a scene graph with (huge) models to test the performance
 *
 */
using namespace osg;
using namespace std;
Scenegraph::Scenegraph() {
Scenegraph::~Scenegraph() {
	delete _model_left, _model_center, _model_right, _model_bottom;
Node* Scenegraph::createScenegraph(std::string filename) {
	Group *scene = new Group;
	_isRotating = false;
	_model_left = new Model(filename);
	_model_center = new IlluminatedModel(filename, scene->getOrCreateStateSet());
	_model_right = new Model(filename);
	_model_bottom = new Model(filename);
	_model_left->setPosition(osg::Vec3d(-5.0, -1.0, -4.0));
	_model_center->setPosition(osg::Vec3d(0.0, -1.0, 0.0));
	_model_right->setPosition(osg::Vec3d(5.0, -1.0, -4.0));
	_model_bottom->setPosition(osg::Vec3d(0.0, -5.0, -4.0));
	_model_bottom->rotate_x(-90.0);
	scene->addChild(_model_left->getModel());
	scene->addChil
/*  YTP King - Easy to use sentence mixer
 *  Copyright (C) 2013  Alex "rainChu" Haddad et al.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
*/
	namespace ytpking
	{
	namespace smp
	{
class Sample;
class SampleUser;
class SampleManager
public:
	SampleManager( void );
	/** Destructor. All samples will safely be freed on destruct. */
	~SampleManager( void );
private:
	explicit SampleManager( SampleManager & );
	void operator=( const SampleManager & );
publi

	void
		loadAll( void );
	/** Register a SampleUser with this class.
	    Callbacks on this SampleUser will then be called.
	\param  sampleUser the SampleUser instance to be registered. */
	void
		registerSampleUser( SampleUser *sampleUser );
	/** Removes a SampleUser from this object.
	    This is done by the SampleUser's destructor, so this normally shouldn't need
		to be called.
	\param sampleUser The SampleUser to unregister. */
	void
		unregisterSampleUser( SampleUser *sampleUser );
	/** Get the currently active sample. */
	Sample
		*getSelectedSample( void ) const;
	/** Set the currently active sample. */
	void
		selectSample( Sample *sample );
	/** Adds a new Sample.
	    SampleUser::onAdd will be called.
	\param filename The filename of the sample.
	\param name     The name of the sample, such as "What's for dinner"
	\param speakerName The name of the speaker, e.g. The King
	\param nodeReference If NULL, the speaker will be created in the save DataFile. */
	Sample
		*addSample

					const Guid &guid,
		            SamplesDataFile::NodeReference *nodeReference = NULL );
	/** Deletes a Sample, freeing the memeory.
	    Once freed, all remaining pointers will dangle, be sure that any
		class using them has SampleUser::onDelete defined to do so.
	\param sample The sample to delete. */
	void
		deleteSample( Sample *sample );
	/** Renames a sample.
	\param sample The sample to rename.
	\param speechName   The new name. */
	void
		renameSample( Sample *sample, const char *speechName );
	/** Changes the speaker of sample.
	\param sample The sample to rename.
	\param speakerName   The new name. */
	void
		changeSpeaker( Sample *sample, const char *speakerName );
	void
		setSampleRange( Sample *sample, unsigned int start, unsigned int end );
	void
		setSampleStart( Sample *sample, unsigned int start );
	void
		setSampleEnd( Sample *sample, unsigned int end );
	Sample
		*getSampleByGuid( const char *guid ) const;
private:
	Sample          *m_selectedSample;
	typedef st
template <typename T>
class TimeWeightedAvg {
public:
    TimeWeightedAvg()
        : _firstSampleTime(0),
        _lastSample(),
        _lastSampleTime(0),
        _weightedSampleSumExcludingLastSample(0.0)
    {}
    void reset() {
        _firstSampleTime = 0;
        _lastSampleTime = 0;
        _weightedSampleSumExcludingLastSample = 0.0;
    }
    void  updateWithSample(T sample) {
        quint64 now = usecTimestampNow();
        if (_firstSampleTime == 0) {
            _firstSampleTime = now;
        } else {
            _weightedSampleSumExcludingLastSample = getWeightedSampleSum(now);
        }
        _lastSample = sample;
        _lastSampleTime = now;
    }
    double getAverage() const {
        if (_firstSampleTime == 0) {
            return 0.0;
        }
        quint64 now = usecTimestampNow();
        quint64 elapsed = now - _firstSampleTime;
        return getWeightedSampleSum(now) / (double)elapsed;
    }
    quint64 getElapsedUsecs() const {
        if (_firstSam
namespace Graphics
    /**
      * Gère l'affichage des batiments d'un chunk dans un QGraphicsItem
      * @brief Gère l'affichage des batiments d'un chunk
      * @author Sam101
      */
    class BuildingChunkItem : public QGraphicsItem
    {
        protected:
            /**
              * Position X du chunk
              */
            qint32 _xChunk;
            /**
              * Position Y du chunk
              */
            qint32 _yChunk;
            /**
              * Pointeur vers le Chunk
              */
            Chunk::Chunk *_chunk;
            /**
              * Tableau contenant les pixmap des batiments
              */
            QList<QImage> _tiles;
            /**
              * BoudingRect de l'objet
              */
            QRectF _boundingRect;
        public:
            /**
              * Constructeur
              */
            BuildingChunkItem(Chunk::Chunk *chunk);
            /**
              * Renvoie le boundingRect de l'objet
       
/*
 * lkcd_dump.h
 *  lkcd dump classes
 * 
 *  Copyright IBM Corp. 2004, 2006.
 *   
 *  Author(s): Michael Holzheu
 */
/* standard header definitions */
/* dump levels - type specific stuff added later */
/* dump compression options */
/* dump header flags */
/* dump page defines */
class LKCDDump : public Dump
public:
	LKCDDump(Dump*,const char*);
	virtual ~LKCDDump(void){}
	inline virtual void readMem(char* UNUSED(buf), int UNUSED(size)) {
		throw(DumpException("LKCDDump::readMem() not implemented!"));
	}
	inline int seekMem(uint64_t UNUSED(offset)){
		throw(DumpException("LKCDDump::seekMem() not implemented!"));
	}
	inline virtual uint64_t getMemSize() const
	{
		return dumpHeader.memory_size;
	}
	virtual struct timeval getDumpTime(void) const;
	virtual void writeDump(const char* fileName);
	virtual void copyRegsToPage(uint64_t offset, char *buf) = 0;
protected:
	struct _lkcd_dump_header {
		uint64_t magic_number; /* dump magic number,unique to verify */
				       /* dump */
		ui

		uint32_t header_size;  /* size of this header */
		uint32_t dump_level;   /* level of this dump */
		uint32_t page_size;    /* page size (e.g. 4K, 8K, 16K, etc.) */
		uint64_t memory_size;  /* size of entire physical memory */
		uint64_t memory_start; /* start of physical memory */
		uint64_t memory_end;   /* end of physical memory */
		/* the number of dump pages in this dump specifically */
		uint32_t num_dump_pages;
		char panic_string[DUMP_PANIC_LEN];
		/* timeval depends on machine, two long values */
		struct {uint64_t tv_sec;
			uint64_t tv_usec;
		} time; /* the time of the system crash */
		/* the NEW utsname (uname) information -- in character form */
		/* plus it helps us be more architecture independent	*/
		char utsname_sysname[UTS_LEN];
		char utsname_nodename[UTS_LEN];
		char utsname_release[UTS_LEN];
		char utsname_version[UTS_LEN];
		char utsname_machine[UTS_LEN];
		char utsname_domainname[UTS_LEN];
		uint64_t current_task;
		uint32_t dump_compress; /* compression t
/*
 *  sample.c
 *  Numerical Fibre Generator
 *
 *  Created by Tom Close, on 25/06/08.
 *  Copyright 2008 Tom Close.
 *  Distributed under the GNU General Public Licence.
 *
 *
 *
 *  This file is part of 'Numerical Fibre Generator'.
 *
 *  'Numerical Fibre Generator' is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  'Numerical Fibre Generator' is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *
 */
void init_sample(Sample *sample, int sample_i, Segment *segment) {
    
    double sample_fract;
    
    sample_fract = (double) sample_i / (d

    sample->sample_fract = sample_fract;
    
    sample->pos[X] = (segment->start_point).pos[X] * (1 - sample_fract)
            + (segment->end_point).pos[X] * sample_fract;
    sample->pos[Y] = (segment->start_point).pos[Y] * (1 - sample_fract)
            + (segment->end_point).pos[Y] * sample_fract;
    sample->pos[Z] = (segment->start_point).pos[Z] * (1 - sample_fract)
            + (segment->end_point).pos[Z] * sample_fract;
    
    sample->sample_i = sample_i;
    sample->segment = segment;
    
void print_sample(Sample *sample) {
    
    printf("\n\n-------- Start Sample --------\n\n");
    printf("Strand: %d, Segment %d, Sample %d: \n", sample->segment->strand->strand_i,
            sample->segment->segment_i, sample->sample_i);
    
    print_segment(sample->segment, "\t");
    
    printf("Coord [%g, %g, %g]\n\n", sample->pos[X], sample->pos[Y], sample->pos[Z]);
    
    if (sample->last_accessed_sample != NULL) {
        printf("Last Accessed sample [Strand %d, Seg %d, 
namespace Poco {
namespace XML {
LocatorImpl::LocatorImpl()
	_lineNumber   = 0;
	_columnNumber = 0;
LocatorImpl::LocatorImpl(const Locator& loc)
	_publicId     = loc.getPublicId();
	_systemId     = loc.getSystemId();
	_lineNumber   = loc.getLineNumber();
	_columnNumber = loc.getColumnNumber();
LocatorImpl::~LocatorImpl()
LocatorImpl& LocatorImpl::operator = (const Locator& loc)
	if (&loc != this)
	{
		_publicId     = loc.getPublicId();
		_systemId     = loc.getSystemId();
		_lineNumber   = loc.getLineNumber();
		_columnNumber = loc.getColumnNumber();
	}
	return *this;
XMLString LocatorImpl::getPublicId() const
	return _publicId;
XMLString LocatorImpl::getSystemId() const
	return _systemId;
int LocatorImpl::getLineNumber() const
	return _lineNumber;
int LocatorImpl::getColumnNumber() const
	return _columnNumber;
void LocatorImpl::setPublicId(const XMLString& publicId)
	_publicId = publicId;
void LocatorImpl::setSystemId(const XMLString& systemId)
	_systemId = systemId;
void LocatorImpl:
using std::map;
namespace base {
typedef HistogramBase::Count Count;
typedef HistogramBase::Sample Sample;
SampleMap::SampleMap() {}
SampleMap::~SampleMap() {}
void SampleMap::Accumulate(Sample value, Count count) {
  sample_counts_[value] += count;
  IncreaseSum(count * value);
  IncreaseRedundantCount(count);
Count SampleMap::GetCount(Sample value) const {
  map<Sample, Count>::const_iterator it = sample_counts_.find(value);
  if (it == sample_counts_.end())
    return 0;
  return it->second;
Count SampleMap::TotalCount() const {
  Count count = 0;
  for (map<Sample, Count>::const_iterator it = sample_counts_.begin();
       it != sample_counts_.end();
       ++it) {
    count += it->second;
  }
  return count;
scoped_ptr<SampleCountIterator> SampleMap::Iterator() const {
  return scoped_ptr<SampleCountIterator>(new SampleMapIterator(sample_counts_));
void SampleMap::ResetRedundantCount(Count count) {
  IncreaseRedundantCount(-redundant_count());
  IncreaseRedundantCount(count);
bool
using namespace std;
class   SmallObjAllocator
public:
	SmallObjAllocator( long  chunkSize ,
					   long   MaxObjectSize)
	{
		m_blockSize = chunkSize;
		if( MaxSize < MaxObjectSize )
		{
			MaxObjectSize = MaxSize;
		}
		m_ObjSize   = MaxObjectSize;
		m_alloChunk = NULL;
	}
	~SmallObjAllocator()
	{
		std::cout << " ~SmallObjAllocator() Chunk Size =%d " << m_chunk.size() << std::endl;
		Chunks::iterator i = m_chunk.begin();
		for ( ; i != m_chunk.end(); ++i)
		{
			delete *i;
		}
		m_chunk.clear();
	}
	void*  Allocate()
	{
		if ( !m_alloChunk || m_alloChunk->m_availSize == 0 )
		{
			Chunks::iterator i = m_chunk.begin();
			for ( ; ; ++i)
			{
				if ( i == m_chunk.end() )
				{
					m_chunk.push_back( new Chunk(m_blockSize,m_ObjSize) );
					m_alloChunk = m_chunk.back();
					
					break;
				}
				if ( (*i)->m_availSize > 0 )
				{
					m_alloChunk = *i;
					break;
				}
			}
		}
		assert( m_alloChunk != 0 );
		assert( m_alloChunk->m_availSize != 0 );
		return m_alloChunk->Allocate
/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 */
void
handle_version_gen_class::generate_handle_version(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (short_opt)
    {
      stream << "case 'V':	/* Print version and exit.  */";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "if (strcmp (long_options[option_index].name, \"version\") == 0) {";
      stream << "\n";
      stream << indent_str;
    }
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_print_version ();";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_free (&local_args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  exit (EXIT_SUCCESS);";
  if (( ! short_opt ))
    {
      stream << "\n";
      stream << indent_str;
 
bool Locator_readLocalData(osg::Object &obj, osgDB::Input &fr);
bool Locator_writeLocalData(const osg::Object &obj, osgDB::Output &fw);
REGISTER_DOTOSGWRAPPER(Locator_Proxy)
    new osgVolume::Locator,
    "Locator",
    "Object Locator",
    Locator_readLocalData,
    Locator_writeLocalData
);
bool Locator_readLocalData(osg::Object& obj, osgDB::Input &fr)
    osgVolume::Locator& locator = static_cast<osgVolume::Locator&>(obj);
    bool itrAdvanced = false;
    if (fr.matchSequence("Transform {"))
    {
        int tansform_entry = fr[0].getNoNestedBrackets();
        fr += 2;
        int row=0;
        int col=0;
        double v;
        osg::Matrixd matrix;
        while (!fr.eof() && fr[0].getNoNestedBrackets()>tansform_entry)
        {
            if (fr[0].getFloat(v))
            {
                matrix(row,col)=v;
                ++col;
                if (col>=4)
                {
                    col = 0;
                    ++row;
                }
                ++fr;

/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 */
void
generic_option_gen_class::generate_generic_option(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (has_short_option)
    {
      stream << "case '";
      generate_string (short_option, stream, indent + indent_str.length ());
      stream << "':	/* ";
      generate_string (option_comment, stream, indent + indent_str.length ());
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      if (( short_option == "?" ))
        {
          stream << "\n";
          stream << indent_str;
          stream << "  if (optopt) /* '?' represents an unrecognized option */";
          stream << "\n";
          stream << indent_str;
          stream << "    goto failure;";
          stream << "\n";
          stream << indent_str;
        }
    }
  else
    {
      stream << "/* ";
      generate_string (option_comment, stream, indent + indent_str.lengt

      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      generate_string (gen_else, stream, indent + indent_str.length ());
      stream << "if (strcmp (long_options[option_index].name, \"";
      generate_string (long_option, stream, indent + indent_str.length ());
      stream << "\") == 0)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
    }
  if (option_has_mode)
    {
      stream << "  args_info->";
      generate_string (group_var_name, stream, indent + indent_str.length ());
      stream << "_mode_counter += 1;";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  if (multiple)
    {
      if (option_has_type)
        {
          stream << "  if (update_multiple_arg_temp(&";
          generate_string (structure, stream, indent + indent_str.length ());
          stream << ", ";
          stream << "\n";
          stream << indent_st

          stream << "      &(local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given), optarg, ";
          generate_string (possible_values, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (arg_type, stream, indent + indent_str.length ());
          stream << ",";
          stream << "\n";
          stream << indent_str;
          stream << "      \"";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << "\", '";
          generate_string (short_option, stream, indent + indent_str.length ());
          stream << "',";
          stream << "\n";
          stream << indent_str;
          stream << "      additional_error))";
          stream << "\n";
          stream << indent_str;
          stream << "    goto failur

          stream << "\n";
          stream << indent_str;
        }
      else
        {
          stream << "  local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given++;";
          stream << "\n";
          stream << indent_str;
        }
      if (option_has_group)
        {
          stream << "  if (!args_info->";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_group)";
          stream << "\n";
          stream << indent_str;
          stream << "    {";
          stream << "\n";
          stream << indent_str;
          stream << "      args_info->";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_group = 1;";
          stream << "\n";
          stream << indent_str;
          stream << "      args_info->";
          generate_string (group_var_name, stream, indent + indent_str.length ());
 

          stream << "\n";
          stream << indent_str;
          stream << "    }";
          stream << "\n";
          stream << indent_str;
        }
    }
  else
    {
      if (option_has_group)
        {
          stream << "  if (args_info->";
          generate_string (group_var_name, stream, indent + indent_str.length ());
          stream << "_group_counter && override)";
          stream << "\n";
          stream << indent_str;
          stream << "    reset_group_";
          generate_string (group_var_name, stream, indent + indent_str.length ());
          stream << " (args_info);";
          stream << "\n";
          stream << indent_str;
          stream << "  args_info->";
          generate_string (group_var_name, stream, indent + indent_str.length ());
          stream << "_group_counter += 1;";
          stream << "\n";
          stream << indent_str;
        }
      stream << "\n";
      stream << indent_str;
      if (( arg_type == "ARG_FLAG" ))
        {
      

          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_flag), 0, &(args_info->";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given),";
          stream << "\n";
          stream << indent_str;
          stream << "      &(local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given), optarg, 0, 0, ";
          generate_string (arg_type, stream, indent + indent_str.length ());
          stream << ",";
          stream << "\n";
          stream << indent_str;
          stream << "      check_ambiguity, override, 1, 0, \"";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << "\", '";
          generate_string (short_option, stream, indent + indent_str.length ());
          stream << "',";
          stream << "\n";
          stream << indent_str;
          strea

          stream << "\n";
          stream << indent_str;
          stream << "    goto failure;";
          stream << "\n";
          stream << indent_str;
        }
      else
        {
          stream << "  if (update_arg(";
          if (( arg_type == "ARG_NO" ))
            {
              stream << " 0 ";
            }
          else
            {
              stream << " (void *)&(args_info->";
              generate_string (option_var_name, stream, indent + indent_str.length ());
              stream << "_arg)";
            }
          stream << ", ";
          stream << "\n";
          stream << indent_str;
          indent = 6;
          stream << "      ";
          if (( arg_type == "ARG_NO" ))
            {
              stream << " 0 ";
            }
          else
            {
              stream << " &(args_info->";
              generate_string (option_var_name, stream, indent + indent_str.length ());
              stream << "_orig)";
            }
          strea

          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given),";
          indent = 0;
          stream << "\n";
          stream << indent_str;
          stream << "      &(local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given), optarg, ";
          generate_string (possible_values, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (arg_type, stream, indent + indent_str.length ());
          stream << ",";
          stream << "\n";
          stream << indent_str;
          stream << "      check_ambiguity, override, 0, 0,";
          stream << "\n";
          stream << indent_str;
          stream << "      \"";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << 
int the_heap[HEAP_SIZE];
void* allocateMemory(uint32_t size_in_bytes) {
	while(chunk < HEAP_SIZE && the_heap[chunk] < size) {
		int block_size = the_heap[chunk];
		if (block_size < 0) {block_size = -block_size;}
		chunk = chunk + block_size + METADATA;	
	}
	if (chunk >= HEAP_SIZE) { return 0;}
	if (the_heap[chunk] - size >= MIN_CHUNK_SIZE) {
		uint32_t extra_size = the_heap[chunk] - size - METADATA;
		uint32_t extra_chunk = chunk + size + METADATA;
		the_heap[chunk] = the_heap[chunk + size + 1] =  size;
		the_heap[extra_chunk] = the_heap[extra_chunk + extra_size + 1] = extra_size;
	} else {
		size = the_heap[chunk];
	}
	the_heap[chunk] = -size;
	the_heap[chunk + size + 1] = -size;
	return &the_heap[chunk+1];
}	
void deallocateMemory(void* p) {
	int* block_address = (int*) p;
	the_heap[chunk] = -the_heap[chunk];
	the_heap[chunk + the_heap[chunk] + 1] = the_heap[chunk];
	uint32_t size = the_heap[chunk];
	uint32_t next_chunk = chunk + size + METADATA;
		uint32_t next_chunk_size = the_heap
void BaseBookmarkModelObserver::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BaseBookmarkModelObserver::BookmarkModelBeingDeleted(
    BookmarkModel* model) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
                                                  int index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeRemoved(
    BookmarkModel* model,
    const BookmarkNode* parent,
    int old_index,
    const BookmarkNode* node,
    const std::set<GURL>& removed_urls) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkAllNodesRemoved
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
namespace worker {
class RepoWorkerProjects : public RepoAbstractWorker
    Q_OBJECT
public:
    RepoWorkerProjects(
            repo::RepoController *controller,
            const repo::RepoController::RepoToken *token);
    ~RepoWorkerProjects();
signals:
    void databasesFetched(const std::list<std::string> &);
    void databasesWithProjectsFetched
Bool_t enable_afs               = @enable_afs@;
Bool_t enable_alien             = @enable_alien@;
Bool_t enable_asimage           = @enable_asimage@;
Bool_t enable_cern              = strlen("@altf77@") > 0;
Bool_t enable_chirp             = @enable_chirp@;
Bool_t enable_clarens           = @enable_clarens@;
Bool_t enable_dcache            = @enable_dcache@;
Bool_t enable_globus            = @enable_globus@;
Bool_t enable_krb5              = @enable_krb5@;
Bool_t enable_ldap              = @enable_ldap@;
Bool_t enable_mysql             = @enable_mysql@;
Bool_t enable_opengl            = @enable_opengl@;
Bool_t enable_oracle            = @enable_oracle@;
Bool_t enable_peac              = @enable_peac@;
Bool_t enable_pgsql             = @enable_pgsql@;
Bool_t enable_pythia6           = @enable_pythia6@;
Bool_t enable_python            = @enable_python@;
Bool_t enable_qt                = @enable_qt@;
Bool_t enable_ruby              = @enable_ruby@;
Bool_t enable_rfio              = @enabl

Bool_t enable_sapdb             = @enable_sapdb@;
Bool_t enable_srp               = @enable_srp@;
Bool_t enable_ssl               = @enable_ssl@;
Bool_t enable_table             = @enable_table@;
Bool_t enable_thread            = kTRUE;
Bool_t enable_xml               = @enable_xml@;
Bool_t enable_xrootd            = @enable_xrootd@;
void html()
   gSystem->Load("libEG");
   gSystem->Load("libFumili.so");
   gSystem->Load("libGX11.so");
   gSystem->Load("libGX11TTF.so");
   gSystem->Load("libGed.so");
   gSystem->Load("libGeom.so");
   gSystem->Load("libGeomPainter.so");
   gSystem->Load("libGpad.so");
   gSystem->Load("libGraf.so");
   gSystem->Load("libGraf3d.so");
   gSystem->Load("libGui.so");
   gSystem->Load("libGuiBld.so");
   gSystem->Load("libHist");
   gSystem->Load("libHist.so");
   gSystem->Load("libHistPainter");
   gSystem->Load("libHtml.so");
   gSystem->Load("libMLP.so");
   gSystem->Load("libMatrix.so");
   gSystem->Load("libMinuit.so");
   gSystem->Load("libNew.so");

   gSystem->Load("libPhysics");
   gSystem->Load("libPostscript.so");
   gSystem->Load("libProof");
   gSystem->Load("libQuadp.so");
   gSystem->Load("libRGL");
   gSystem->Load("libRint.so");
   gSystem->Load("libSrvAuth.so");
   gSystem->Load("libThread");
   gSystem->Load("libTree.so");
   gSystem->Load("libTreePlayer");
   gSystem->Load("libTreeViewer");
   gSystem->Load("libTreeViewer.so");
   gSystem->Load("libVMC.so");
   gSystem->Load("libX3d");
   gSystem->Load("libX3d.so");
   gSystem->Load("libXMLIO.so");
   if (enable_alien)             gSystem->Load("libRAliEn");
   if (enable_asimage)           gSystem->Load("libASImage");
   if (enable_cern)              gSystem->Load("libHbook");
   if (enable_chirp)             gSystem->Load("libChirp");
   if (enable_clarens) {
      gSystem->Load("libClarens");
      if (enable_peac) {
         gSystem->Load("libPeacGui");
         gSystem->Load("libPeac");
      }
   }
   if (enable_dcache)            gSystem->Load("libDCache");
  

   if (enable_krb5)              gSystem->Load("libKrb5Auth");
   if (enable_ldap)              gSystem->Load("libRLDAP");
   if (enable_mysql)             gSystem->Load("libMySQL");
   if (enable_opengl)            gSystem->Load("libRGL");
   if (enable_oracle)            gSystem->Load("libOracle");
   if (enable_pgsql)             gSystem->Load("libPgSQL");
   if (enable_pythia6)           gSystem->Load("libEGPythia6");
   if (enable_python)            gSystem->Load("libPyROOT");
   if (enable_qt) {
      gSystem->Load("libGQt");
      gSystem->Load("libQtRoot");
   }
   if (enable_ruby)              gSystem->Load("libRuby");
   if (enable_rfio)              gSystem->Load("libRFIO");
   if (enable_sapdb)             gSystem->Load("libSapDB");
   if (enable_srp)               gSystem->Load("libSRPAuth");
   if (enable_table)             gSystem->Load("libTable");
   if (enable_thread)            gSystem->Load("libThread");
   if (enable_xml)               gSystem->Load("libXMLParser"
void	ffl_dump_mini::dump( const ffl_tchar_t * name, ffl_dump_param_t * param )
	if( param != NULL && name != NULL )
	{
		HANDLE file = ::CreateFile( name,
			GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
			NULL );
		if( file != INVALID_HANDLE_VALUE )
		{
			write( file, param );
			::CloseHandle( file );
			file = INVALID_HANDLE_VALUE;
		}
	}
	return;
void	ffl_dump_mini::write( HANDLE file, ffl_dump_param_t * param )
	if( file != INVALID_HANDLE_VALUE && param != NULL )
	{
		HMODULE dbghelp = find_dll();
		if( dbghelp != NULL )
		{
			typedef	BOOL (WINAPI * mini_dump_write_dump_f)( HANDLE,
				DWORD,
				HANDLE,
				MINIDUMP_TYPE,
				const PMINIDUMP_EXCEPTION_INFORMATION,
				const PMINIDUMP_USER_STREAM_INFORMATION,
				const PMINIDUMP_CALLBACK_INFORMATION );
			mini_dump_write_dump_f dump_f = (mini_dump_write_dump_f) ::GetProcAddress( dbghelp, "MiniDumpWriteDump" );
			if( dump_f != NULL )
			{
				if( param->level == ffl_dump_lev

				{
					dump_type |= MiniDumpWithDataSegs;
				}
				if( param->level == ffl_dump_level_heavy )
				{
					dump_type |= MiniDumpWithFullMemory;
				}
				MINIDUMP_EXCEPTION_INFORMATION info;
				info.ThreadId			= param->dump_thread_id;
				info.ExceptionPointers	= param->exception_ptr;
				info.ClientPointers		= FALSE;
				dump_f(	::GetCurrentProcess(),
					::GetCurrentProcessId(),
					file,
					static_cast< MINIDUMP_TYPE >( dump_type ),
					param->exception_ptr ? &info : NULL,
					NULL,
					NULL );
			}
			::FreeLibrary( dbghelp );
			dbghelp = NULL;
		}
	}
	return;
HMODULE	ffl_dump_mini::find_dll()
	static const ffl_tchar_t dll_name[] = FFL_T( "dbghelp.dll" );
	HMODULE dbghelp = NULL;
	ffl_tchar_t path[MAX_PATH] = { 0, };
	if( ::GetModuleFileName( NULL, path, FFL_COUNTOF( path ) ) != 0 )
	{
		ffl_tchar_t * slash = NULL;
		if( (slash = ::_tcsrchr( path, FFL_T( '\\' ) )) != NULL )
		{
			size_t count = FFL_COUNTOF( path ) - (slash-path);
			ffl_strncpy( slash + 1, count - 1, 
using content::BrowserThread;
BookmarkModelTask::BookmarkModelTask(BookmarkModel* model)
    : model_(model) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(model_);
  model_->BlockTillLoaded();
BookmarkModel* BookmarkModelTask::model() const {
  return model_;
BookmarkModelObserverTask::BookmarkModelObserverTask(
    BookmarkModel* bookmark_model)
    : BookmarkModelTask(bookmark_model) {
  model()->AddObserver(this);
BookmarkModelObserverTask::~BookmarkModelObserverTask() {
  model()->RemoveObserver(this);
void BookmarkModelObserverTask::Loaded(BookmarkModel* model,
                                       bool ids_reassigned) {
void BookmarkModelObserverTask::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
void BookmarkModelObserverTask::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
   
CSinus::CSinus(void):CStdElement()
   ID_OBJECT = ID_SINUS;
	A = 1.0;
   W = 1.0;
   F = 0.0;
   GradToRadians = M_PI/180.0;
   dX = 0.0;
   dY = 0.0;
   ElName = "Ñèíóñîèäà";
   FSinProp = NULL;
void __fastcall CSinus::SetData(void)
	FSinProp = new TFSinProp(Application);
   if(GradToRadians == 1.0)
   	FSinProp->RGCorner->ItemIndex = 1;
   else
   	FSinProp->RGCorner->ItemIndex = 0;
   FSinProp->EA->Text = FloatToStr(A);
   FSinProp->EW->Text = FloatToStr(W);
   FSinProp->EF->Text = FloatToStr(F);
   FSinProp->EdX->Text = FloatToStr(dX);
   FSinProp->EdY->Text = FloatToStr(dY);
   FSinProp->ShowModal();
   if(FSinProp->ResultOk)
   {
      if(FSinProp->RGCorner->ItemIndex == 0)
   		GradToRadians = M_PI/180.0;
      else
   		GradToRadians = 1.0;
   	A = FSinProp->A;
   	W = FSinProp->W;
   	F = FSinProp->F;
   	dX = FSinProp->dX;
   	dY = FSinProp->dY;
   }
   FSinProp->Free();
void CSinus::FUNKCIJA(int index, int end, long double DT)
	long double X = real(In[index]) - dX;
   Out[in
/*
 * Copyright (c) 2013 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
using namespace std;
RepoControl::RepoControl(const string &path)
    : path(path), uuid(""), udsClient(0), udsRepo(0), localRepo(0)
RepoControl::~RepoControl()
void
RepoControl::open()
    try {
        udsClient = new UDS

        udsClient->connect();
        udsRepo = new UDSRepo(udsClient);
    } catch (SystemException e) {
        if (udsRepo)
            delete udsRepo;
        udsRepo = NULL;
    }
    localRepo = new LocalRepo();
    localRepo->open(path);
    if (udsRepo)
        uuid = udsRepo->getUUID();
    else
        uuid = localRepo->getUUID();
void
RepoControl::close()
    if (udsClient) {
        delete udsRepo;
        delete udsClient;
    }
    if (localRepo) {
        localRepo->close();
        delete localRepo;
    }
    udsClient = NULL;
    udsRepo = NULL;
    localRepo = NULL;
string
RepoControl::getPath()
    return path;
string
RepoControl::getUUID()
    ASSERT(uuid != "");
    return uuid;
string
RepoControl::getHead()
    if (udsRepo)
        return udsRepo->getHead().hex();
    return localRepo->getHead().hex();
bool
RepoControl::hasCommit(const string &objId)
    ObjectHash hash = ObjectHash::fromHex(objId);
    if (udsRepo)
        return udsRepo->hasObject(hash);
    re

string
RepoControl::pull(const string &host, const string &path)
    if (udsRepo) {
        strwstream pullReq;
        ObjectHash newHead;
        pullReq.writePStr("pull");
        pullReq.writePStr(host + ":" + path);
        strstream pullResp = udsRepo->callExt("FUSE", pullReq.str());
        if (pullResp.ended()) {
            WARNING("Unknown failure trying to pull from %s:%s",
                    host.c_str(), path.c_str());
            return "";
        }
        if (pullResp.readUInt8() == 1) {
            string error;
            pullResp.readPStr(error);
            WARNING("Failed to pull from %s:%s: %s",
                    host.c_str(), path.c_str(), error.c_str());
            return "";
        }
        pullResp.readHash(newHead);
        strwstream checkoutReq;
        checkoutReq.writePStr("checkout");
        checkoutReq.writeHash(newHead);
        checkoutReq.writeUInt8(/* force */0);
        strstream checkoutResp = udsRepo->callExt("FUSE", checkoutReq.str());

        if (checkoutResp.ended()) {
            WARNING("Unknown failure trying to checkout %s",
                    newHead.hex().c_str());
            return "";
        }
        if (checkoutResp.readUInt8() == 0) {
            string error;
            checkoutResp.readPStr(error);
            WARNING("Failed to checkout %s", error.c_str());
            return "";
        }
        LOG("RepoControl::pull: Update from %s:%s suceeded",
            host.c_str(), path.c_str());
        return "";
    }
    RemoteRepo::sp srcRepo(new RemoteRepo());
    if (!srcRepo->connect(host + ":" + path)) {
        LOG("RepoControl::pull: Failed to connect to source %s", host.c_str());
        return  "";
    }
    ObjectHash newHead = srcRepo->get()->getHead();
    localRepo->pull(srcRepo->get());
    localRepo->updateHead(newHead);
    LOG("RepoControl::pull: Update succeeded");
    return newHead.hex();
string
RepoControl::push(const string &host, const string &path)
    NOT_IMPLEMENTED(false);
WmiLocator::WmiLocator(IWbemLocator* locator, bool take) :
	ComPointer<IWbemLocator>(locator, take)
{}
bool WmiLocator::initialise()
	IWbemLocator* loc = 0;
    HRESULT hr = CoCreateInstance(
		CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
		IID_IWbemLocator, (LPVOID*)&loc);
	if (FAILED(hr))
	{
		qWarningFromHresult(hr, "WMI Locator creation failed");
		return false;
	}
	reset(loc);
	return true;
WmiService WmiLocator::connectServer(const QString& serviceNamespace) const
	if (!valid())
	{
		qWarning() << "Locator invalid";
		return WmiService();
	}
	IWbemServices* svc = 0;
	BStrScoped sns(serviceNamespace);
	HRESULT hr = get()->ConnectServer(sns, NULL, NULL, 0, NULL, 0, 0, &svc);
	if (FAILED(hr))
	{
		qWarningFromHresult(hr, "Can not connect to WMI server");
		return WmiService();
	}
	hr = CoSetProxyBlanket(
		svc,
		RPC_C_AUTHN_WINNT,
		RPC_C_AUTHZ_NONE,
		NULL,
		RPC_C_AUTHN_LEVEL_CALL,
		RPC_C_IMP_LEVEL_IMPERSONATE,
		NULL,
		EOAC_NONE
	);
	if (FAILED(hr))
	{
		svc->Release();
		qWarn
int main(int argc, char * argv[]){
    MemoryChunk* chunk;
    chunk = new MemoryChunk();
    int i = 12;
    chunk->set_content(0, &i, sizeof(int));
    int * p = (int *)chunk->begin();
    assert(chunk->size() == sizeof(int));
    printf("%d\n", *p);
    printf("%ld\n", chunk->capacity());
    p = & i;
    chunk->set_chunk(p, sizeof(int), NULL);
    short t = 5;
    chunk->set_content(sizeof(int), &t, sizeof(short));
    assert( sizeof(int) + sizeof(short) == chunk->size());
    printf("%ld\n", chunk->capacity());
    p = (int *)chunk->begin();
    short * p2 =(short *)(((char *) (chunk->begin())) + sizeof(int));
    printf("%d\t%d\n", *p, *p2);
    chunk->set_content(sizeof(int) + sizeof(short), &t, sizeof(short));
  
    assert( sizeof(int) + (sizeof(short) << 1) == chunk->size());
    printf("%ld\n", chunk->capacity());
    p = (int *)chunk->begin();
    p2 =(short *)(((char *) (chunk->begin())) + sizeof(int));
    printf("%d\t%d\t%d\n", *p, *p2, *(p2 + 1));
    chunk->set_size(si
namespace Sid {
  ApiRegistration* ApiRegistration::M_api_factory = 0;
  Api::Api(ModuleAPI* api, uint num_modules, Field* descriptors)
  : m_api(api),
    m_last_prop(0),
    m_num_modules(num_modules),
    m_descriptors(descriptors)
  {
  }
  Field* Api::get_property_desc(uint modid, uint propid, uint from_event)
  { 
    int evok = 0;
    Field* f = m_modprop2field.contains(modid, propid, evok);
    if (from_event && !evok)
      f = 0;
    return f;
  } 
  Field* Api::__get_property_desc(uint modid, uint propid) const
  { 
    if (modid <= m_num_modules) {
      for (uint b=0, e=m_api[modid].num_properties; b < e; ) {
        uint p = (b + e) / 2;
        uint key = m_api[modid].properties[p]->m_regular.m_tag;
        if (key == propid)
          return m_api[modid].properties[p];
        if (key < propid) 
          b = p+1;
        else 
          e = p;
      }
    }
    return 0;
  } 
  Api* Api::clone(const char* filter) const {
    Api* api = new Api(m_api, m_num_modules, m_d

    const char* begin = 0;
    if (filter && (begin = strstr(filter, "SkypeKit/SubscribedProperties=")) != 0) {
      uint modid, propid;
      for (const char* i=begin+strlen("SkypeKit/SubscribedProperties"); 
           i && sscanf(++i,"%u:%u",&modid,&propid) == 2; 
           i = strchr(i, ',')) {
        Field* f = __get_property_desc(modid,propid);
        if (f) { 
          api->m_modprop2field.add(modid,propid,f,1);
        }
      }
      int foo;
      for (uint m = 0; m <= m_num_modules; m++) {
        for (uint p=0, e=m_api[m].num_properties; p != e; p++) {
           uint propid = m_api[m].properties[p]->m_regular.m_tag;
           if (!api->m_modprop2field.contains(m,propid,foo)) {
             api->m_modprop2field.add(m,propid,m_api[m].properties[p],0);
           }
        }
      }
    } else {
      for (uint m = 0; m <= m_num_modules; m++) {
        for (uint p=0, e=m_api[m].num_properties; p != e; p++) {
            api->m_modprop2field.add(m,m_api[m].properties[p]
/**************************************************************************
**
**    Copyright (C) 2013 by Philip Schuchardt
**    www.cavewhere.com
**
**************************************************************************/
/**
  This class expands the survey chunk to allow editting.  When
  a survey chunk is selected in the cwSurveyChunkView, the chunk should
  be set using setSurveyChunk.  Once the chunk is set, a new empty chunk
  shot and station is appended.  This class will keep a new shot and station
  at all times.  It will remove empty station to keep the chunk trimmed.
  Once the survey chunk is unset, the survey chunk will be trimmed.  All empty
  station and shot are removed.
  */
class cwSurveyChunkTrimmer : public QObject
    Q_OBJECT
    Q_PROPERTY(cwSurveyChunk* chunk READ chunk WRITE setChunk NOTIFY chunkChanged)
public:
    explicit cwSurveyChunkTrimmer(QObject *parent = 0);
    
    cwSurveyChunk* chunk() const;
    void setChunk(cwSurveyChunk* chunk);
    static
namespace {
static TabModelList::TabModelVector& tab_models() {
  CR_DEFINE_STATIC_LOCAL(TabModelList::TabModelVector,
                         tab_model_vector, ());
  return tab_model_vector;
void TabModelList::AddTabModel(TabModel* tab_model) {
  DCHECK(tab_model);
  tab_models().push_back(tab_model);
void TabModelList::RemoveTabModel(TabModel* tab_model) {
  DCHECK(tab_model);
  TabModelList::iterator remove_tab_model =
      std::find(tab_models().begin(), tab_models().end(), tab_model);
  if (remove_tab_model != tab_models().end())
    tab_models().erase(remove_tab_model);
TabModel* TabModelList::GetTabModelWithProfile(
    Profile* profile) {
  if (!profile)
    return NULL;
  for (TabModelList::const_iterator i = TabModelList::begin();
      i != TabModelList::end(); ++i) {
    if (profile->IsSameProfile((*i)->GetProfile()))
      return *i;
  }
  return NULL;
TabModel* TabModelList::FindTabModelWithId(
    SessionID::id_type desired_id) {
  for (TabModelList::const_iterator i 
class Chunk;
class World
public:
	struct CameraIntersectionInfo
	{
		Block block;
		Direction direction;
		
		CameraIntersectionInfo(Block _block, Direction _direction): block(_block), direction(_direction) {}
	};
	World();
	virtual ~World();
	void update();
	void tick();
	void asyncDeleteTriangleCollector(TriangleCollector *collector);
	int getLoadedChunkCount() const { return chunks.size(); }
	void save();
	void asyncLoadChunk(Chunk *chunk);
	void asyncSaveChunk(Chunk *chunk);
	Block getBlock(int x, int y, int z);
	Block tryGetBlock(int x, int y, int z);
	Chunk *getChunk(int chunk_x, int chunk_y, int chunk_z);
	Chunk *tryGetChunk(int chunk_x, int chunk_y, int chunk_z);
	Chunk *getChunkForBlock(int x, int y, int z);
	Chunk *tryGetChunkForBlock(int x, int y, int z);
	Chunk *rawGetChunk(int chunk_x, int chunk_y, int chunk_z);
	bool getCameraIntersection(const Ray3D &ray, CameraIntersectionInfo **info);
	ConcurrentMemoryPool<Chunk> *getChunkMemoryPool() { return &chunkMemoryPool; }
priva
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
Q_DECLARE_METATYPE(repo::core::model::RepoRole)
Q_DECLARE_METATYPE(repo::core::model::RepoRoleSettings)
namespace repo {
namespace gui{
namespace widget {
	class RolesManagerWidget : public EditableTreeWidget
	{
		Q_OBJECT
			static const QString COLUMNS_SETTINGS;
		enum class Columns { ROLE, DATABASE, PERMISSIONS, PRIVILEGES, INHERITED_ROLES, MODUL

	public:
		explicit RolesManagerWidget(QWidget *parent = 0);
		~RolesManagerWidget();
		public slots:
		void addRole(const repo::core::model::RepoRole &role,
			const repo::core::model::RepoRoleSettings &settings);
		void copyItem()
		{
			showEditDialog(
				getRole(),
				getRoleSettings(),
				EditableTreeWidget::Action::COPY);
		}
		virtual void edit();
		virtual void edit(const QModelIndex &index);
		repo::core::model::RepoRole getRole() const;
		repo::core::model::RepoRole getRole(const QModelIndex &index) const;
		repo::core::model::RepoRoleSettings getRoleSettings() const;
		repo::core::model::RepoRoleSettings getRoleSettings(const QModelIndex &index) const;
		virtual void refresh()
		{
			refresh(repo::core::model::RepoRole(),
				repo::core::model::RepoRoleSettings(),
				repo::worker::RepoWorkerRoles::Command::INSERT);
		}
		void refresh(
			const repo::core::model::RepoRole &role,
			const repo::core::model::RepoRoleSettings &settings,
			repo::worker::RepoWorkerRoles::Com
namespace balls {
class SampleOptions : public OpenGLState {
  Q_OBJECT
  Q_PROPERTY(float sampleCoverage MEMBER m_sampleCoverage WRITE setSampleCoverage FINAL)
  Q_PROPERTY(bool invertSampleCoverage MEMBER m_invertSampleCoverage WRITE setInvertSampleCoverage FINAL)
  Q_PROPERTY(bool sampleAlphaToCoverage MEMBER m_sampleAlphaToCoverage WRITE setSampleAlphaToCoverage FINAL)
  Q_PROPERTY(bool sampleAlphaToOne MEMBER m_sampleAlphaToOne WRITE setSampleAlphaToOne FINAL)
  Q_PROPERTY(bool sampleCoverageEnabled MEMBER m_sampleCoverageEnabled WRITE setSampleCoverageEnabled FINAL)
  Q_PROPERTY(bool sampleShadingEnabled MEMBER m_sampleShadingEnabled WRITE setSampleShadingEnabled FINAL)
  Q_PROPERTY(bool sampleMaskEnabled MEMBER m_sampleMaskEnabled WRITE setSampleMaskEnabled FINAL)
  Q_PROPERTY(bool multisample MEMBER m_multisample WRITE setMultisample FINAL)
  Q_PROPERTY(float minSampleShading MEMBER m_minSampleShading WRITE setMinSampleShading FINAL)
public:
  explicit SampleOptions(OpenGLPoint
using namespace Tungsten;
ServiceLocator Tungsten::Services;
ServiceLocator::ServiceLocator(void)
	graphics=NULL;
ServiceLocator::~ServiceLocator(void)
IGraphicsService* ServiceLocator::Graphics()
{	
	if(graphics) return graphics;
	return NULL;
void ServiceLocator::SetGraphics(IGraphicsService* graphics)
	this->graphics=graphics;
IConfigurationService* ServiceLocator::Config()
	if(config) return config;
	return NULL;
void ServiceLocator::SetConfig(IConfigurationService* config)
	this->config=config;
ISpriteTextService* ServiceLocator::SpriteText()
	return spriteText;
void ServiceLocator::Refresh()
	spriteText->Clear();
	input->Refresh();
	graphics->Refresh();
void ServiceLocator::SetSpriteText(ISpriteTextService* spriteText)
	this->spriteText=spriteText;
InputService* ServiceLocator::Input()
	return input;	
void ServiceLocator::SetInput(InputService* input)
	this->input=input;
IImporterService* ServiceLocator::Import()
	return importer;
void ServiceLocator::SetImporter(IImporterService
/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
namespace qpid {
namespace amqp_0_10 {
template <class F>
struct ApplyVisitor<CommandVisitor, F>:
    public ApplyVisitorBase<CommandVisitor, F>
    virtual void visit(execution::Sync& x) { this->invoke(x); }
    virtual void visit(ex

    virtual void visit(execution::Exception& x) { this->invoke(x); }
    virtual void visit(message::Transfer& x) { this->invoke(x); }
    virtual void visit(message::Accept& x) { this->invoke(x); }
    virtual void visit(message::Reject& x) { this->invoke(x); }
    virtual void visit(message::Release& x) { this->invoke(x); }
    virtual void visit(message::Acquire& x) { this->invoke(x); }
    virtual void visit(message::Resume& x) { this->invoke(x); }
    virtual void visit(message::Subscribe& x) { this->invoke(x); }
    virtual void visit(message::Cancel& x) { this->invoke(x); }
    virtual void visit(message::SetFlowMode& x) { this->invoke(x); }
    virtual void visit(message::Flow& x) { this->invoke(x); }
    virtual void visit(message::Flush& x) { this->invoke(x); }
    virtual void visit(message::Stop& x) { this->invoke(x); }
    virtual void visit(tx::Select& x) { this->invoke(x); }
    virtual void visit(tx::Commit& x) { this->invoke(x); }
    virtual void visit(tx::Rollback& 

    virtual void visit(dtx::Select& x) { this->invoke(x); }
    virtual void visit(dtx::Start& x) { this->invoke(x); }
    virtual void visit(dtx::End& x) { this->invoke(x); }
    virtual void visit(dtx::Commit& x) { this->invoke(x); }
    virtual void visit(dtx::Forget& x) { this->invoke(x); }
    virtual void visit(dtx::GetTimeout& x) { this->invoke(x); }
    virtual void visit(dtx::Prepare& x) { this->invoke(x); }
    virtual void visit(dtx::Recover& x) { this->invoke(x); }
    virtual void visit(dtx::Rollback& x) { this->invoke(x); }
    virtual void visit(dtx::SetTimeout& x) { this->invoke(x); }
    virtual void visit(exchange::Declare& x) { this->invoke(x); }
    virtual void visit(exchange::Delete& x) { this->invoke(x); }
    virtual void visit(exchange::Query& x) { this->invoke(x); }
    virtual void visit(exchange::Bind& x) { this->invoke(x); }
    virtual void visit(exchange::Unbind& x) { this->invoke(x); }
    virtual void visit(exchange::Bound& x) { this->invoke(x); }
    

    virtual void visit(queue::Delete& x) { this->invoke(x); }
    virtual void visit(queue::Purge& x) { this->invoke(x); }
    virtual void visit(queue::Query& x) { this->invoke(x); }
    virtual void visit(file::Qos& x) { this->invoke(x); }
    virtual void visit(file::QosOk& x) { this->invoke(x); }
    virtual void visit(file::Consume& x) { this->invoke(x); }
    virtual void visit(file::ConsumeOk& x) { this->invoke(x); }
    virtual void visit(file::Cancel& x) { this->invoke(x); }
    virtual void visit(file::Open& x) { this->invoke(x); }
    virtual void visit(file::OpenOk& x) { this->invoke(x); }
    virtual void visit(file::Stage& x) { this->invoke(x); }
    virtual void visit(file::Publish& x) { this->invoke(x); }
    virtual void visit(file::Return& x) { this->invoke(x); }
    virtual void visit(file::Deliver& x) { this->invoke(x); }
    virtual void visit(file::Ack& x) { this->invoke(x); }
    virtual void visit(file::Reject& x) { this->invoke(x); }
    virtual void visit(str

    virtual void visit(stream::QosOk& x) { this->invoke(x); }
    virtual void visit(stream::Consume& x) { this->invoke(x); }
    virtual void visit(stream::ConsumeOk& x) { this->invoke(x); }
    virtual void visit(stream::Cancel& x) { this->invoke(x); }
    virtual void visit(stream::Publish& x) { this->invoke(x); }
    virtual void visit(stream::Return& x) { this->invoke(x); }
    virtual void visit(stream::Deliver& x) { this->invoke(x); }
};
template <class F>
struct ApplyVisitor<ConstCommandVisitor, F>:
    public ApplyVisitorBase<ConstCommandVisitor, F>
    virtual void visit(const execution::Sync& x) { this->invoke(x); }
    virtual void visit(const execution::Result& x) { this->invoke(x); }
    virtual void visit(const execution::Exception& x) { this->invoke(x); }
    virtual void visit(const message::Transfer& x) { this->invoke(x); }
    virtual void visit(const message::Accept& x) { this->invoke(x); }
    virtual void visit(const message::Reject& x) { this->invoke(x); }
    v

    virtual void visit(const message::Acquire& x) { this->invoke(x); }
    virtual void visit(const message::Resume& x) { this->invoke(x); }
    virtual void visit(const message::Subscribe& x) { this->invoke(x); }
    virtual void visit(const message::Cancel& x) { this->invoke(x); }
    virtual void visit(const message::SetFlowMode& x) { this->invoke(x); }
    virtual void visit(const message::Flow& x) { this->invoke(x); }
    virtual void visit(const message::Flush& x) { this->invoke(x); }
    virtual void visit(const message::Stop& x) { this->invoke(x); }
    virtual void visit(const tx::Select& x) { this->invoke(x); }
    virtual void visit(const tx::Commit& x) { this->invoke(x); }
    virtual void visit(const tx::Rollback& x) { this->invoke(x); }
    virtual void visit(const dtx::Select& x) { this->invoke(x); }
    virtual void visit(const dtx::Start& x) { this->invoke(x); }
    virtual void visit(const dtx::End& x) { this->invoke(x); }
    virtual void visit(const dtx::Commit& x)

    virtual void visit(const dtx::Forget& x) { this->invoke(x); }
    virtual void visit(const dtx::GetTimeout& x) { this->invoke(x); }
    virtual void visit(const dtx::Prepare& x) { this->invoke(x); }
    virtual void visit(const dtx::Recover& x) { this->invoke(x); }
    virtual void visit(const dtx::Rollback& x) { this->invoke(x); }
    virtual void visit(const dtx::SetTimeout& x) { this->invoke(x); }
    virtual void visit(const exchange::Declare& x) { this->invoke(x); }
    virtual void visit(const exchange::Delete& x) { this->invoke(x); }
    virtual void visit(const exchange::Query& x) { this->invoke(x); }
    virtual void visit(const exchange::Bind& x) { this->invoke(x); }
    virtual void visit(const exchange::Unbind& x) { this->invoke(x); }
    virtual void visit(const exchange::Bound& x) { this->invoke(x); }
    virtual void visit(const queue::Declare& x) { this->invoke(x); }
    virtual void visit(const queue::Delete& x) { this->invoke(x); }
    virtual void visit(const qu

    virtual void visit(const queue::Query& x) { this->invoke(x); }
    virtual void visit(const file::Qos& x) { this->invoke(x); }
    virtual void visit(const file::QosOk& x) { this->invoke(x); }
    virtual void visit(const file::Consume& x) { this->invoke(x); }
    virtual void visit(const file::ConsumeOk& x) { this->invoke(x); }
    virtual void visit(const file::Cancel& x) { this->invoke(x); }
    virtual void visit(const file::Open& x) { this->invoke(x); }
    virtual void visit(const file::OpenOk& x) { this->invoke(x); }
    virtual void visit(const file::Stage& x) { this->invoke(x); }
    virtual void visit(const file::Publish& x) { this->invoke(x); }
    virtual void visit(const file::Return& x) { this->invoke(x); }
    virtual void visit(const file::Deliver& x) { this->invoke(x); }
    virtual void visit(const file::Ack& x) { this->invoke(x); }
    virtual void visit(const file::Reject& x) { this->invoke(x); }
    virtual void visit(const stream::Qos& x) { this->invoke(x); }
void main(void);
void main(void)
  array C(1,3);
/*
  tensor A(3,3,2,3), B(3,3,2,3), C;
  tensor D(1,3), E(1,2), F(1,4);
  tensor G(2,3,2), H;
  char *dump;
  int i, j, k;
  FILE *skippy;
  skippy = fopen("tensor_test.txt","w");
  A.Set(-19,1,1,1);
  A.print("A",&dump);
  fprintf(skippy,"A.Set(-19,1,1,1)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
/*
  A.ScalarMult(1.0/19.0);
  A.print("A",&dump);
  fprintf(skippy,"A.ScalarMult(1.0/19.0)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  for( i = 0; i < 3; i++) for( j = 0; j < 2; j++) for( k = 0; k < 3; k++)
        B.Set(1,i,j,k);
  for( i = 0; i < 3; i++) D.Set(sqrt(i),i);
  for( j = 0; j < 2; j++) E.Set(-1+j,j);
  for( k = 0; k < 4; k++) F.Set(2*k,k);
  B.print("B",&dump);
  fprintf(skippy,"B.Set(1,i,j,k)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"B.max() = %g\n\n",B.max());
  D.print("D",&dump);
  fprintf(skippy,"D.Set(sqrt(i),i)\n");
  fprintf(skippy,"%s",

  fprintf(skippy,"D.max() = %g\n\n",D.max());
  E.print("E",&dump);
  fprintf(skippy,"E.Set(-1+j,j)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"E.max() = %g\n\n",E.max());
  F.print("F",&dump);
  fprintf(skippy,"F.Set(2*k,k)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"F.max() = %g\n\n",F.max());
  C = A + B;
  C.print("C",&dump);
  fprintf(skippy,"C = A + B\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  C = A + A + B;
  fprintf(skippy,"C = A + A + B\n");
  C.print("C",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  C = B - A;
  fprintf(skippy,"C = B - A\n");
  C.print("C",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  G = D*E;
  fprintf(skippy,"G = D*E\n");
  G.print("G",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"G.max() = %g\n\n",G.max());
  H = D*E*F;
  fprintf(skippy,"H = D*E*F\n");
  H.print("H",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(ski

  C = A.Contract(B,2,2);
  fprintf(skippy,"C = A.Contract(B,2,2)\n");
  C.print("C",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  A <= B;
  fprintf(skippy,"A <= B\n");
  A.print("A", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  B.ScalarMult(0.0);
  fprintf(skippy,"B.ScalarMult(0.0)\n");
  B.print("B", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"B.max() = %g\n\n",B.max());
  fprintf(skippy,"A <= B recheck\n");
  A.print("A", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  fprintf(skippy,"A has %d indices\n",A.NumIndices());
  int *range = A.Ranges();
  fprintf(skippy,"with ranges %d %d %d\n\n", range[0], range[1], range[2]);
  C = A*5.0;
  fprintf(skippy,"C = A*5.0\n");
  C.print("C", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  D <= C;
  fprintf(skippy,"D <= C\n");
  D.print("D", &dump);
  fprintf(skippy,"%s",dump);
  fp
InvokeClass::InvokeClass(QObject *parent):QObject(parent)
  m_acceptedSlots = acceptedSlots();
void InvokeClass::invokeSlot(QObject *object, const QString& slot, QStringList args)
  QString invokeName = slot;
  invokeName = invokeName.mid(invokeName.find('('));
  invokeName.prepend(QString::number(QSIGNAL_CODE) + "invoke");
  QString slotName = QString::number(QSLOT_CODE) + slot;  
  connect(this, invokeName.ascii(), object, slotName.ascii());
  if (args.count() == 0)  
    emit invoke();
  else
  {
    QString slotArgStr = slot.section(QRegExp("\\(|\\)"), 1);
    uint argNum = slotArgStr.contains(',') + 1;
    for (uint i = args.count(); i < argNum; i++)
      args << "";
    if (slotArgStr == m_acceptedSlots[0])
      emit invoke(args[0]);
    else if (slotArgStr == m_acceptedSlots[1])
      emit invoke(args[0], args[1]);
    else if (slotArgStr == m_acceptedSlots[2])
      emit invoke(args[0].upper()=="TRUE" || args[0] =="1"? true : false);
    else if (slotArgStr == m_acceptedSlots
/**
 *	This class implements a tool locator that sits on a terrain
 */
class TerrainToolLocator : public ChunkObstacleToolLocator
	Py_Header( TerrainToolLocator, ChunkObstacleToolLocator )
public:
	explicit TerrainToolLocator( PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3 & worldRay, Tool & tool );
	PY_FACTORY_DECLARE()
private:
	ClosestTerrainObstacle terrainCallback_;
	LOCATOR_FACTORY_DECLARE( TerrainToolLocator() )
};
/**
 *	This class implements a tool locator that sits on a terrain,
 *	finding quads of terrain, even if a hole is cut.
 */
class TerrainHoleToolLocator : public ChunkObstacleToolLocator
	Py_Header( TerrainHoleToolLocator, ChunkObstacleToolLocator )
public:
	explicit TerrainHoleToolLocator( PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3 & worldRay, Tool & tool );
	PY_FACTORY_DECLARE()
private:
	ClosestTerrainObstacle terrainCallback_;
	LOCATOR_FACTORY_DECLARE( TerrainHoleToolLocator() )
};
/**
 *	This c
void MemoryAllocator::operator () (uint32_t __heap, uint32_t __size) 
	MemoryChunk *chunk = (MemoryChunk *)__heap;
    /*
	for (memory_size_t i = 0; i < __size; i++) {
	    *((uint8_t *)__heap + i) = 0;
	}
    */
	chunk->size = __size - sizeof(MemoryChunk) - 4;
	this->poolFree.add(chunk);
    MemoryAllocator::MemoryAllocator (uint32_t __heap, uint32_t __size) 
	MemoryChunk *chunk = (MemoryChunk *)__heap;
	for (memory_size_t i = 0; i < __size; i++) {
	    *((uint8_t *)__heap + i) = 0;
	}
	chunk->size = __size;
	this->poolFree .add(chunk);
MemoryChunk *MemoryAllocator::separate (MemoryChunk *memo, memory_size_t size)
	MemoryChunk *chunk = (MemoryChunk *)0;
	chunk = (MemoryChunk *)((alloc_addr_t)memo + size + sizeof(MemoryChunk));
	chunk->size = memo->size - size - sizeof(MemoryChunk);
	memo->size = size;
	return chunk;
int32_t MemoryAllocator::sanitize (ArrayListBase <MemoryChunk> &List)
	if (List.size() < 2) {
		return -1;
	} else {}
	MemoryChunk *New = List.getLast()->nextLink, *Old = 

	while (New != (MemoryChunk *)0) {
	if ((alloc_addr_t)Old + Old->size + sizeof(MemoryChunk) == (alloc_addr_t)New) {
		Old->size += sizeof(MemoryChunk) + New->size;
		List.remove(New);
        this->sanitized++;
	}
	Old = New;
	New = New->prevLink;
	}	
	New = List.getFirst()->nextLink;
	Old = List.getFirst();
	while (New != (MemoryChunk *)0) {
	if ((alloc_addr_t)Old + Old->size + sizeof(MemoryChunk) == (alloc_addr_t)New) {
        Old->size += sizeof(MemoryChunk) + New->size;
        List.remove(New);
        this->sanitized++;
	}
	Old = New;
	New = New->nextLink;
	}	
    return 0;		
void *MemoryAllocator::New (memory_size_t size)
	 if (!size) return 0;
	 size |= MemoryAlignment;
	 __align(MemoryAlignment) MemoryChunk *chunk = this->poolFree.getFirst();
			while (chunk != (MemoryChunk *)0) {
				if (chunk->size >= size) {
					this->poolFree.remove(chunk);
					if (chunk->size >= size + sizeof(MemoryChunk) + sizeof(MemoryChunk) * 2) 
						this->poolFree.add(separate(chunk, size));
			
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
const std::string repo::core::RepoLogger::DEFAULT_LOG_EXTENSION = ".log";
repo::core::RepoLogger::RepoLogger()
    : coutStreamBuffer(0)
    , cerrStreamBuffer(0)
repo::core::RepoLogger::~RepoLogger()
{    
    if (coutStreamBuffer)
        delete coutStreamBuffer;
    if (cerrStreamBuffer)
        delete cerrStreamBuffer;
repo::core::RepoLogger &re

    static RepoLogger instance;
    return instance;
std::string repo::core::RepoLogger::getHtmlFormattedMessage(
        const std::string &message,
        const RepoSeverity &severity) const
    std::stringstream formatted;
    const struct tm *now = localtime(&t);
    formatted << normalize(now->tm_hour);
    formatted << ":";
    formatted << normalize(now->tm_min);
    formatted << ":";
    formatted << normalize(now->tm_sec);
    formatted << " - ";
    formatted << "<span style='color:";
    formatted << severity.getColor();
    formatted << "'>";
    formatted << severity;
    formatted << "</span> - ";
    if (severity.getValue() == RepoSeverity::REPO_DEBUG_NUM)
        formatted << "<code>" << message << "</code>";
    else
        formatted << message;
    formatted << "<br/>";
    return formatted.str();
std::string repo::core::RepoLogger::getFilename(
        const std::string &extension)
    std::stringstream fileNameStream;
    time_t t = time(0);
    const struct tm *

    fileNameStream << (now->tm_year + 1900);
    fileNameStream << "-";
    fileNameStream << normalize(now->tm_mon + 1);
    fileNameStream << "-";
    fileNameStream << normalize(now->tm_mday);
    fileNameStream << extension;
    std::string generated = fileNameStream.str();
    if (generated != filename)
    {
        filename = generated;
        log("Log: " + getFullFilePath(),
            RepoSeverity::REPO_NOTICE);
    }
    return filename;
std::string repo::core::RepoLogger::getFullFilePath()
    return getWorkingDirectory() + PATH_SEPARATOR + getFilename();
std::string repo::core::RepoLogger::getWorkingDirectory()
    char temp[FILENAME_MAX];
    return (getcwd(temp, FILENAME_MAX) ? std::string(temp) : std::string());
void repo::core::RepoLogger::log(
        const std::string &msg,
        const RepoSeverity &severity)
    std::string filename = getFilename();
    std::string formattedMessage = getHtmlFormattedMessage(msg, severity);
    notifyListeners(formattedMessage);

namespace {
RepoDetailDialog::RepoDetailDialog(const ServerRepo &repo, QWidget *parent)
    : QDialog(parent),
      repo_(repo)
    setupUi(this);
    setWindowTitle(tr("Library \"%1\"").arg(repo.name));
    setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint);
    mDesc->setText(repo.description);
    mTimeLabel->setText(translateCommitTime(repo.mtime));
    mOwnerLabel->setText(repo.owner);
    mSizeLabel->setText(readableFileSize(repo.size));
    LocalRepo lrepo;
    seafApplet->rpcClient()->getLocalRepo(repo.id, &lrepo);
    if (lrepo.isValid()) {
        lpathLabel->setVisible(true);
        mLpathLabel->setVisible(true);
        mLpathLabel->setText(QDir::toNativeSeparators(lrepo.worktree));
        if (lrepo.sync_state == LocalRepo::SYNC_STATE_ERROR) {
            mStatus->setText(lrepo.sync_error_str);
        } else {
            mStatus->setText(lrepo.sync_state_str);
        }
    } else {
        mStatus->setText(tr("This library is not downloaded yet"));
     

        mLpathLabel->setVisible(false);
    }
    mRepoIcon->setPixmap(repo_.getPixmap());
    mRepoName->setText(repo_.name);
    layout()->setContentsMargins(8, 9, 9, 4);
    layout()->setSpacing(5);
    resize(sizeHint());
    updateRepoStatus();
    refresh_timer_ = new QTimer(this);
    connect(refresh_timer_, SIGNAL(timeout()), this, SLOT(updateRepoStatus()));
    refresh_timer_->start(kRefrshRepoStatusInterval);
void RepoDetailDialog::updateRepoStatus()
    LocalRepo r;
    QString text;
    seafApplet->rpcClient()->getLocalRepo(repo_.id, &r);
    if (r.isValid()) {
        if (r.sync_state == LocalRepo::SYNC_STATE_ERROR) {
            text = "<p style='color:red'>" + tr("Error: ") + r.sync_error_str + "</p>";
        } else {
            text = r.sync_state_str;
            if (r.sync_state == LocalRepo::SYNC_STATE_ING) {
                int rate, percent;
                if (seafApplet->rpcClient()->getRepoTransferInfo(repo_.id, &rate, &percent) == 0) {
                    te
typedef void* dataStream_t;
typedef void* dataStreamIterator_t;
/* data buffer API */
void*                dataStreamBufferAllocate(chunkpool_t chunkpool, fallocator_t fallocator,  u_int32_t size);
void                 dataStreamBufferFree(void* buffer);
void                 dataStreamBufferPrint(void* buffer);
/* data stream API */
dataStream_t         dataStreamCreate(void);
void                 dataStreamDelete(dataStream_t dataStream);
u_int32_t            dataStreamGetSize(dataStream_t dataStream);
u_int32_t            dataStreamTotalSize(dataStream_t dataStream);
int                  dataStreamAppendData(dataStream_t dataStream, void* buffer, u_int32_t offset, u_int32_t length);
int                  dataStreamAppendDataStream(dataStream_t dataStream, dataStream_t toAppend);
int                  dataStreamFindEndOfLine(dataStream_t dataStream);
int                  dataStreamTruncateFromStart(dataStream_t dataStream, u_int32_t finalSize);
int                  dataStreamTruncateFro

void                 dataStreamPrint(dataStream_t dataStream);
dataStream_t         dataStreamSubStream(fallocator_t fallocator, dataStream_t dataStream, u_int32_t offset, u_int32_t length);
char*                dataStreamToString(dataStream_t dataStream);
/* data stream iterator API */
dataStreamIterator_t dataStreamIteratorCreate(fallocator_t fallocator, dataStream_t dataStream, u_int32_t offset, u_int32_t length);
void                 dataStreamIteratorDelete(fallocator_t fallocator, dataStreamIterator_t iterator);
u_int32_t            dataStreamIteratorGetSize(dataStreamIterator_t iterator);
u_int32_t            dataStreamIteratorGetBufferCount(dataStreamIterator_t iterator);
void*                dataStreamIteratorGetBufferAtIndex(dataStreamIterator_t iterator, u_int32_t index, u_int32_t* offset, u_int32_t* length);
char*                dataStreamIteratorGetString(fallocator_t fallocator, dataStreamIterator_t iterator, u_int32_t offset, u_int32_t length);
/* data stream clone API 
class AddModelCommand : public QUndoCommand
public:
    AddModelCommand(Model *model);
    void undo();
    void redo();
private:
    int modelIndex;
    Model *model;
};
class DeleteModelsCommand : public QUndoCommand
public:
    DeleteModelsCommand(QList<int> *modelsIndices);
    void undo();
    void redo();
private:
    QList<int> *modelsIndices;
    QList<Model *> modelList;
};
class MoveModelCommand : public QUndoCommand
public:
    MoveModelCommand(Model *model, float xMovement, float yMovement);
    void undo();
    void redo();
private:
    Model *model;
    float xMovement;
    float yMovement;
    float zMovement;
};
class RotateModelCommand : public QUndoCommand
public:
    RotateModelCommand(Model *model, float angle);
    void undo();
    void redo();
private:
    Model *model;
    float angle;
};
class ScaleModelCommand : public QUndoCommand
public:
    ScaleModelCommand(Model *model, float xScale, float yScale);
    void undo();
    void redo();
private:
    Model *mode
using namespace std;
int main (int argc, char *argv[]) {
  Isis::Preference::Preferences(true);
  string fname = "$base/testData/isisTruth.cub";
  Isis::Cube cube;
  cube.Open (fname);
  
  Isis::SampleManager sample(cube);
  cout << "Buffer Size:  " << 
          sample.SampleDimension() << " " <<
          sample.LineDimension() << " " <<
          sample.BandDimension() << endl;
  cout << endl;
  for (sample.begin(); !sample.end(); sample++) {
    cout << "  Current sample, line, band is:  "
         << sample.Sample() << " "
         << sample.Line() << " "
         << sample.Band() << endl;
  }
  cout << endl;
  Isis::SampleManager sampleReverse(cube,true);
  cout << "Buffer Size:  " << 
          sampleReverse.SampleDimension() << " " <<
          sampleReverse.LineDimension() << " " <<
          sampleReverse.BandDimension() << endl;
  cout << endl;
  for (sampleReverse.begin(); !sampleReverse.end(); sampleReverse++) {
    cout << "  Current sample, line, band is:  "
         <<
::qReal::Id
RepoIce::RepoApiI::toqRealId(const ::std::string& str)
	return qReal::Id::loadFromString(QString::fromStdString(str));
::std::string
RepoIce::RepoApiI::name(const ::std::string& id, const Ice::Current& )
	return repoApi.name( toqRealId(id) ).toStdString();
void
RepoIce::RepoApiI::setName(const ::std::string& id, const ::std::string& name, const Ice::Current& )
	repoApi.setName(qReal::Id::loadFromString(QString::fromStdString(id)),QString::fromStdString(name));
::RepoIce::IdList
RepoIce::RepoApiI::children(const ::std::string& id, const Ice::Current& )
	qReal::IdList list = repoApi.children(toqRealId(id));
	::RepoIce::IdList result;
	for (qReal::IdList::const_iterator i = list.begin(); i != list.end(); i++)
		result.push_back((*i).toString().toStdString());
	return result;
void
RepoIce::RepoApiI::addChild(const ::std::string& id, const ::std::string& child, const Ice::Current& )
	repoApi.addChild(toqRealId(id), toqRealId(child));
void
RepoIce::RepoApiI::removeChild(const ::s

	repoApi.removeChild(toqRealId(id), toqRealId(child));
void
RepoIce::RepoApiI::removeElement(const ::std::string& id, const Ice::Current& )
	repoApi.removeElement(toqRealId(id));
::RepoIce::IdList
RepoIce::RepoApiI::parents(const ::std::string& id, const Ice::Current& )
	qReal::IdList list = repoApi.parents(toqRealId(id));
	::RepoIce::IdList result;
	for (qReal::IdList::const_iterator i = list.begin(); i != list.end(); i++)
		result.push_back((*i).toString().toStdString());
	return result;
void
RepoIce::RepoApiI::addParent(const ::std::string& id, const ::std::string& parent, const Ice::Current& )
	repoApi.addParent(toqRealId(id), toqRealId(parent));
void
RepoIce::RepoApiI::removeParent(const ::std::string& id, const ::std::string& parent, const Ice::Current& )
	repoApi.removeParent(toqRealId(id), toqRealId(parent));
::RepoIce::IdList
RepoIce::RepoApiI::outgoingLinks(const ::std::string& id, const Ice::Current& )
	qReal::IdList list = repoApi.outgoingLinks(toqRealId(id));
	::RepoIce::

	for (qReal::IdList::const_iterator i = list.begin(); i != list.end(); i++)
		result.push_back((*i).toString().toStdString());
	return result;
::RepoIce::IdList
RepoIce::RepoApiI::incomingLinks(const ::std::string& id, const Ice::Current& )
	qReal::IdList list = repoApi.incomingLinks(toqRealId(id));
	::RepoIce::IdList result;
	for (qReal::IdList::const_iterator i = list.begin(); i != list.end(); i++)
		result.push_back((*i).toString().toStdString());
	return result;
::RepoIce::IdList
RepoIce::RepoApiI::links(const ::std::string& id, const Ice::Current& )
	qReal::IdList list = repoApi.links(toqRealId(id));
	::RepoIce::IdList result;
	for (qReal::IdList::const_iterator i = list.begin(); i != list.end(); i++)
		result.push_back((*i).toString().toStdString());
	return result;
::std::string
RepoIce::RepoApiI::typeName(const ::std::string& id, const Ice::Current& )
	return repoApi.typeName( toqRealId(id) ).toStdString();
::std::string
RepoIce::RepoApiI::property(const ::std::string& id, con

	return repoApi.property(toqRealId(id), QString::fromStdString(propertyName)).toString().toStdString();
::std::string
RepoIce::RepoApiI::stringProperty(const ::std::string& id, const ::std::string& propertyName, const Ice::Current& )
	return repoApi.stringProperty(toqRealId(id), QString::fromStdString(propertyName)).toStdString();
void
RepoIce::RepoApiI::setProperty(const ::std::string& id, const ::std::string& propertyName, const ::std::string& value, const Ice::Current& )
	repoApi.setProperty(toqRealId(id), QString::fromStdString(propertyName), QString::fromStdString(value));
void
RepoIce::RepoApiI::removeProperty(const ::std::string& id, const ::std::string& propertyName, const Ice::Current& )
	repoApi.removeProperty(toqRealId(id), QString::fromStdString(propertyName));
bool
RepoIce::RepoApiI::hasProperty(const ::std::string& id, const ::std::string& propertyName, const Ice::Current& )
	return repoApi.hasProperty(toqRealId(id), QString::fromStdString(propertyName));
::std::string
R

	return repoApi.from(toqRealId(id)).toString().toStdString();
void
RepoIce::RepoApiI::setFrom(const ::std::string& id, const ::std::string& from, const Ice::Current& )
	return repoApi.setFrom(toqRealId(id), toqRealId(from));
::std::string
RepoIce::RepoApiI::to(const ::std::string& id, const Ice::Current& )
	return repoApi.to(toqRealId(id)).toString().toStdString();
void
RepoIce::RepoApiI::setTo(const ::std::string& id, const ::std::string& to, const Ice::Current& )
	repoApi.setFrom(toqRealId(id), toqRealId(to));
::Ice::Double
RepoIce::RepoApiI::fromPort(const ::std::string& id, const Ice::Current& )
	return repoApi.fromPort(toqRealId(id));
void
RepoIce::RepoApiI::setFromPort(const ::std::string& id, ::Ice::Double fromPort, const Ice::Current& )
	repoApi.setFromPort(toqRealId(id), fromPort);
::Ice::Double
RepoIce::RepoApiI::toPort(const ::std::string& id, const Ice::Current& )
	return repoApi.toPort(toqRealId(id));
void
RepoIce::RepoApiI::setToPort(const ::std::string& id, ::Ice::Doubl
/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 */
void
check_modes_gen_class::generate_check_modes(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  stream << "if (args_info->";
  generate_string (mode1_name, stream, indent + indent_str.length ());
  stream << "_mode_counter && args_info->";
  generate_string (mode2_name, stream, indent + indent_str.length ());
  stream << "_mode_counter) {";
  stream << "\n";
  stream << indent_str;
  stream << "  int ";
  generate_string (mode1_name, stream, indent + indent_str.length ());
  stream << "_given[] = {";
  generate_string (mode1_given_fields, stream, indent + indent_str.length ());
  stream << " -1};";
  stream << "\n";
  stream << indent_str;
  stream << "  const char *";
  generate_string (mode1_name, stream, indent + indent_str.length ());
  stream << "_desc[] = {";
  generate_string (mode1_options, stream, indent + indent_str.length ());
  stream << " 0};";
  stream

  stream << indent_str;
  stream << "  int ";
  generate_string (mode2_name, stream, indent + indent_str.length ());
  stream << "_given[] = {";
  generate_string (mode2_given_fields, stream, indent + indent_str.length ());
  stream << " -1};";
  stream << "\n";
  stream << indent_str;
  stream << "  const char *";
  generate_string (mode2_name, stream, indent + indent_str.length ());
  stream << "_desc[] = {";
  generate_string (mode2_options, stream, indent + indent_str.length ());
  stream << " 0};";
  stream << "\n";
  stream << indent_str;
  stream << "  error_occurred += check_modes(";
  generate_string (mode1_name, stream, indent + indent_str.length ());
  stream << "_given, ";
  generate_string (mode1_name, stream, indent + indent_str.length ());
  stream << "_desc, ";
  generate_string (mode2_name, stream, indent + indent_str.length ());
  stream << "_given, ";
  generate_string (mode2_name, stream, indent + indent_str.length ());
  stream << "_desc);";
  stream << "\n";
  st
class ChunkData;
class ChunkIterator
  friend class ChunkStream;
public:
  ChunkIterator(int8u* data = NULL, size_t fileSize = 0, size_t filePos = 0);
  size_t getChunkSize();
  string getChunkType();
  unsigned long getCRC();
  
  ChunkIterator& operator++();
  bool operator==(const ChunkIterator& rhs);
  bool operator!=(const ChunkIterator& rhs);
  bool isValid();
  bool checkCRC();
  size_t read(void* buffer, size_t bytes);
  bool readCompressed(void* buffer, size_t bytes);
  bool readString(string &oString);  
  template <class C> bool read(C& oValue)
  {
    size_t bytesToRead = sizeof(C);
    return read(&oValue, bytesToRead) == bytesToRead;
  }
private:
  int8u* getReadPosition();  
  void readChunkSize();
  int8u* mData;
  size_t mSize;
  size_t mChunkPos;
  size_t mChunkSize;  
  size_t mChunkReadPos;
};
class ChunkData
  friend class ChunkIterator;
  friend class CacheManager;
public:
  ChunkData(void* memory, size_t size);
  ~ChunkData();
  
  bool isSignatureValid() const;

FoodLoad::FoodLoad(double maxLoad, double load)
	this->setMaxLoad(maxLoad);
	this->load = load;
FoodLoad::FoodLoad(const FoodLoad& foodLoad)
	this->setMaxLoad(foodLoad.getMaxLoad());
	this->loadFood(foodLoad.getLoad());
FoodLoad& FoodLoad::operator = (const FoodLoad& foodLoad)
	if (this != &foodLoad)
	{
		this->setMaxLoad(foodLoad.getMaxLoad());
		this->loadFood(foodLoad.getLoad());
	}
	return *this;
double FoodLoad::getMaxLoad() const
	return this->maxLoad;
double FoodLoad::getLoad() const
	return this->load;
bool FoodLoad::setMaxLoad(double maxLoad)
	if (maxLoad < 0 || maxLoad < this->load)
	{
		return false;
	}
	else
	{
		this->maxLoad = maxLoad;
		return true;
	}
double FoodLoad::loadFood(double load)
	if (load < 0)
	{
		return 0;
	}
	double free = this->maxLoad - this->load;
	if (free > load) {
		this->load += load;
		return load;
	}
	else
	{
		this->load = this->maxLoad;
		return free;
	}
double FoodLoad::unloadFood()
	double load = this->load;
	this->load = 0.0;
	return load;
do
  void visit(esprima::Node *node) { \
    indent += 2; \
    (void)(props); \
    visitChildren(node); \
    indent -= 2; \
    out << std::string(indent, ' ') << "}\n"; \
  }
struct DumpVisitor : esprima::Visitor {
  int indent;
  std::ostream &out;
  DumpVisitor(std::ostream &out) : indent(), out(out) {}
  DUMP(Program, NONE)
  DUMP(Identifier, PROP(name))
  DUMP(BlockStatement, NONE)
  DUMP(EmptyStatement, NONE)
  DUMP(ExpressionStatement, NONE)
  DUMP(IfStatement, NONE)
  DUMP(LabeledStatement, NONE)
  DUMP(BreakStatement, NONE)
  DUMP(ContinueStatement, NONE)
  DUMP(WithStatement, NONE)
  DUMP(SwitchCase, NONE)
  DUMP(SwitchStatement, NONE)
  DUMP(ReturnStatement, NONE)
  DUMP(ThrowStatement, NONE)
  DUMP(CatchClause, NONE)
  DUMP(TryStatement, NONE)
  DUMP(WhileStatement, NONE)
  DUMP(DoWhileStatement, NONE)
  DUMP(ForStatement, NONE)
  DUMP(ForInStatement, NONE)
  DUMP(DebuggerStatement, NONE)
  DUMP(FunctionDeclaration, NONE)
  DUMP(VariableDeclarator, NONE)
  DUMP(VariableDecl

  DUMP(ThisExpression, NONE)
  DUMP(ArrayExpression, NONE)
  DUMP(Property, PROP(kind))
  DUMP(ObjectExpression, NONE)
  DUMP(FunctionExpression, NONE)
  DUMP(SequenceExpression, NONE)
  DUMP(UnaryExpression, (PROP(operator_), PROP(prefix)))
  DUMP(BinaryExpression, PROP(operator_))
  DUMP(AssignmentExpression, PROP(operator_))
  DUMP(UpdateExpression, PROP(operator_))
  DUMP(LogicalExpression, PROP(operator_))
  DUMP(ConditionalExpression, NONE)
  DUMP(NewExpression, NONE)
  DUMP(CallExpression, NONE)
  DUMP(MemberExpression, PROP(computed))
  DUMP(NullLiteral, NONE)
  DUMP(RegExpLiteral, (PROP(pattern), PROP(flags)))
  DUMP(StringLiteral, PROP(value))
  DUMP(NumericLiteral, PROP(value))
  DUMP(BooleanLiteral, PROP(value))
};
int64_t microseconds() {
  struct timeval time;
  gettimeofday(&time, NULL);
  return time.tv_sec * (int64_t)1000000 + time.tv_usec;
void compile(const std::string &path, std::istream &input, std::ostream &output) {
  std::string code((std::istreambuf_iterator<c
IDataProviderSvc* RichG4SvcLocator::RichG4detSvc()
{ 
  static IDataProviderSvc* a_detSvc = 0 ;
  if( 0 == a_detSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("RichG4Svclocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service(RichG4SvcLocator::a_RichG4DataSvcName , a_detSvc, true );
      if( sc.isFailure() ) 
        { throw GaudiException("RichG4SvcLocator::Could not locate IDataProviderSvc='" 
                               + RichG4SvcLocator::a_RichG4DataSvcName + "'",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE); }
      if( 0 == a_detSvc ) 
        { throw GaudiException("RichG4SvcLocator::IDataProviderSvc*(" 
                               +  RichG4SvcLocator::a_RichG4DataSvcName + 
                            

                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      a_detSvc->addRef();
    }
  return a_detSvc ;
IMessageSvc* RichG4SvcLocator::RichG4MsgSvc ()
  static IMessageSvc* a_msgSvc = 0 ;
  if( 0 == a_msgSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("RichG4SvcLocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service( RichG4SvcLocator::a_RichG4MessageSvcName , a_msgSvc, true );
      if( sc.isFailure() ) 
        { throw GaudiException("RichG4SvcLocator::Could not locate IMessageSvc='" 
                               + RichG4SvcLocator::a_RichG4MessageSvcName  + "'",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE); }
      if( 0 == a_msgSvc ) 
        { throw Gau

                               +RichG4SvcLocator::a_RichG4MessageSvcName + 
                               "') points to NULL!" ,
                               "*DetDescException*" , 
                               StatusCode::FAILURE  ); }
      a_msgSvc->addRef();
    }
  return a_msgSvc ;
IHistogramSvc*   RichG4SvcLocator::RichG4HistoSvc()
  static IHistogramSvc* a_HistoSvc = 0 ;
  if( 0 == a_HistoSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("RichG4SvcLocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service( RichG4SvcLocator::a_RichG4HistoSvcName , a_HistoSvc,true  );
      if( sc.isFailure() ) 
        { throw GaudiException("RichG4SvcLocator::Could not locate IHistogramSvc='" 
                               + RichG4SvcLocator::a_RichG4HistoSvcName  + "'",
             

                               StatusCode::FAILURE); }
      if( 0 == a_HistoSvc ) 
        { throw GaudiException("RichG4SvcLocator::IHistogramSvc*(" 
                               +RichG4SvcLocator::a_RichG4HistoSvcName + 
                               "') points to NULL!" ,
                               "*DetDescException*" , 
                               StatusCode::FAILURE  ); }
      a_HistoSvc->addRef();
    }
  return a_HistoSvc ;
INTupleSvc*   RichG4SvcLocator::RichG4NtupleSvc()
  static INTupleSvc* a_NtupleSvc = 0 ;
  if( 0 == a_NtupleSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("RichG4SvcLocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service( RichG4SvcLocator::a_RichG4NtupSvcName , a_NtupleSvc,true  );
      if( sc.isFailure() ) 
        { throw GaudiExcept
int samplesAdded = 0;
int patchSamplesAdded = 0;
static unsigned short g_PatchIterationKey = 0;
bool SampleData_CompareFunc( SampleData_t const &src1, SampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int SampleData_KeyFunc( SampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<SampleData_t> g_SampleHashTable( SAMPLEHASH_NUM_BUCKETS, 
										  SAMPLEHASH_GROW_SIZE, 
										  SAMPLEHASH_INIT_SIZE, 
										  SampleData_CompareFunc, SampleData_KeyFunc );
UtlHashHandle_t SampleData_Find( sample_t *pSample )
	SampleData_t sampleData;	
	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	return g_SampleHashTable.Find( sampleData );
UtlHashHandle_t SampleData_InsertIntoHashTable( sample_t *pSample, SampleHandle_t sampleHandle )
	Samp

	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	UtlHashHandle_t handle = g_SampleHashTable.AllocEntryFromKey( sampleData );
	SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
	pSampleData->x = sampleData.x;
	pSampleData->y = sampleData.y;
	pSampleData->z = sampleData.z;
	pSampleData->m_Samples.AddToTail( sampleHandle );
	samplesAdded++;
	return handle;
UtlHashHandle_t SampleData_AddSample( sample_t *pSample, SampleHandle_t sampleHandle )
	UtlHashHandle_t handle = SampleData_Find( pSample );
	if( handle == g_SampleHashTable.InvalidHandle() )
	{
		handle = SampleData_InsertIntoHashTable( pSample, sampleHandle );
	}
	else
	{
		SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
		pSampleData->m_Samples.AddToTail( sampleHandle );
		samplesAdded++;
	}
	return handle;
void SampleData_Log( void )
	if

	{
		g_SampleHashTable.Log( "samplehash.txt" );
	}
bool PatchSampleData_CompareFunc( PatchSampleData_t const &src1, PatchSampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int PatchSampleData_KeyFunc( PatchSampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<PatchSampleData_t>	g_PatchSampleHashTable( SAMPLEHASH_NUM_BUCKETS,
												    SAMPLEHASH_GROW_SIZE,
													SAMPLEHASH_INIT_SIZE,
													PatchSampleData_CompareFunc, PatchSampleData_KeyFunc );
void GetPatchSampleHashXYZ( const Vector &vOrigin, int &x, int &y, int &z )
	x = ( int )( vOrigin.x / SAMPLEHASH_VOXEL_SIZE );
	y = ( int )( vOrigin.y / SAMPLEHASH_VOXEL_SIZE );
	z = ( int )( vOrigin.z / SAMPLEHASH_VOXEL_SIZE );
unsigned short IncrementPatchIterationKey()
	if ( g_PatchIterationKey == 0xFFFF )
	{
		g_PatchIterationKey = 1;
		for ( int i=0; i < patches.Count(); i++ )
			patches[i].m_IterationKey = 0;
	}
	else
	{
		g_P

	}
	return g_PatchIterationKey;
void PatchSampleData_AddSample( patch_t *pPatch, int ndxPatch )
	int patchSampleMins[3], patchSampleMaxs[3];
	GetPatchSampleHashXYZ( pPatch->mins, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	GetPatchSampleHashXYZ( pPatch->maxs, patchSampleMaxs[0], patchSampleMaxs[1], patchSampleMaxs[2] );
	GetPatchSampleHashXYZ( pPatch->origin, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	memcpy( patchSampleMaxs, patchSampleMins, sizeof( patchSampleMaxs ) );
	Assert( patchSampleMins[0] <= patchSampleMaxs[0] && patchSampleMins[1] <= patchSampleMaxs[1] && patchSampleMins[2] <= patchSampleMaxs[2] );
	patchSampleMins[0] = min( patchSampleMins[0], patchSampleMaxs[0] );
	patchSampleMins[1] = min( patchSampleMins[1], patchSampleMaxs[1] );
	patchSampleMins[2] = min( patchSampleMins[2], patchSampleMaxs[2] );
	int iterateCoords[3];
	for ( iterateCoords[0]=patchSampleMins[0]; iterateCoords[0] <= patchSampleMaxs[0]; iterateCoords[0]++ )
	{
		for
typedef OpenDDS::DCPS::DomainParticipantImpl::RepoIdSequence RepoIdSequence;
typedef OpenDDS::DCPS::RepoId RepoId;
namespace {
  namespace Factory {
    RepoId not_default_repo_id() {
      RepoId result;
      int i = 1;
      result.guidPrefix[ 0] =  i += 2;
      result.guidPrefix[ 1] =  i += 2;
      result.guidPrefix[ 2] =  i += 2;
      result.guidPrefix[ 3] =  i += 2;
      result.guidPrefix[ 4] =  i += 2;
      result.guidPrefix[ 5] =  i += 2;
      result.guidPrefix[ 6] =  i += 2;
      result.guidPrefix[ 7] =  i += 2;
      result.guidPrefix[ 8] =  i += 2;
      result.guidPrefix[ 9] =  i += 2;
      result.guidPrefix[10] =  i += 2;
      result.guidPrefix[11] =  i += 2;
      result.entityId.entityKey[0] = 0;
      result.entityId.entityKey[1] = 0;
      result.entityId.entityKey[2] = 0;
      result.entityId.entityKind = 123;
      return result;
    }
  };
  long entityKey(const RepoId& id) {
    long result = (((id.entityId.entityKey[0]  << 8) |
                     id.en

                     id.entityId.entityKey[2];
    return result;
  }
};
int
ACE_TMAIN(int, ACE_TCHAR*[])
    RepoId repoId;
    memset(&repoId, 0, sizeof(repoId));
    RepoIdSequence seq(repoId);
    TEST_ASSERT(entityKey(seq.next()) == 1);
    TEST_ASSERT(entityKey(seq.next()) == 2);
    TEST_ASSERT(entityKey(seq.next()) == 3);
    TEST_ASSERT(entityKey(seq.next()) == 4);
  }
    RepoId repoId = Factory::not_default_repo_id();
    RepoIdSequence seq(repoId);
    {
      RepoId result = seq.next();
      TEST_ASSERT(!memcmp(repoId.guidPrefix,
                          result.guidPrefix,
                          sizeof repoId.guidPrefix));
      TEST_ASSERT(entityKey(result) == 1);
      TEST_ASSERT(repoId.entityId.entityKind == result.entityId.entityKind);
    }
    {
      RepoId result = seq.next();
      TEST_ASSERT(!memcmp(repoId.guidPrefix,
                          result.guidPrefix,
                          sizeof repoId.guidPrefix));
      TEST_ASSERT(entityKey(result) == 2
/* ASE - Allegro Sprite Editor
 * Copyright (C) 2001-2011  David Capello
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
class Button;
typedef struct RepoDlg {	/* a window to shows repositories
				   (used for mask/paths repositories,
				   and the bookmarks) */
  /************************************************************

  /* from user */
  const char *config_section;
  const char *title;
  const char *use_text;
  /* fill the list box (you should add items to "repo_dlg->listbox") */
  void (*load_listbox)(struct RepoDlg *repo_dlg);
  /* when the dialog is closed (you should save the modified entries) */
  void (*save_listbox)(struct RepoDlg *repo_dlg);
  /* free the "user_data" of "repo_dlg->listitem", don't call
     jwidget_free(), it's called automatically */
  void (*free_listitem)(struct RepoDlg *repo_dlg);
  /* return false if to close the window, true to continue (use the
     "repo_dlg->listitem") */
  bool (*use_listitem)(struct RepoDlg *repo_dlg);
  bool (*add_listitem)(struct RepoDlg *repo_dlg, int *added);
  bool (*delete_listitem)(struct RepoDlg *repo_dlg, int *kill);
  void *user_data[4];
  /**********************************************************************/
  /* for the user */
  JWidget listbox;		/* list box */
  JWidget listitem;		/* selected list item */
  Button* button_use;		/*
/*
 * Copyright 2011, Haiku Inc. All rights reserved.
 * This file may be used under the terms of the MIT License.
 *
 * Authors:
 *		Jérôme Duval
 */
Chunk::Chunk(btrfs_chunk* chunk, fsblock_t offset)
	:
	fChunk(NULL),
	fInitStatus(B_OK)
	fChunkOffset = offset;
	fChunk = (btrfs_chunk*)malloc(sizeof(btrfs_chunk)
		+ chunk->StripeCount() * sizeof(btrfs_stripe));
	if (fChunk == NULL) {
		fInitStatus = B_NO_MEMORY;
		return;
	}
	memcpy(fChunk, chunk, sizeof(btrfs_chunk)
		+ chunk->StripeCount() * sizeof(btrfs_stripe));
	TRACE("chunk[0] length %" B_PRIu64 " owner %" B_PRIu64 " stripe_length %"
		B_PRIu64 " type %" B_PRIu64 " stripe_count %u sub_stripes %u "
		"sector_size %" B_PRIu32 "\n", chunk->Length(), chunk->Owner(),
		chunk->StripeLength(), chunk->Type(), chunk->StripeCount(),
		chunk->SubStripes(), chunk->SectorSize());
	for (int32 i = 0; i < chunk->StripeCount(); i++) {
		TRACE("chunk.stripe[%" B_PRId32 "].physical %" B_PRId64 " deviceid %"
			B_PRId64 "\n", i, chunk->stripes[i].Of
int count = 0;
void f_void_1(int i)
    count += i;
struct A_void_1
    void operator()(int i)
    {
        count += i;
    }
    void mem1() {++count;}
    void mem2() const {count += 2;}
};
void
test_void_1()
    int save_count = count;
    {
    int i = 2;
    boost::detail::invoke(f_void_1, i);
    BOOST_TEST(count == save_count + 2);
    save_count = count;
    }
    {
    int i = 2;
    boost::detail::invoke<void>(f_void_1, i);
    BOOST_TEST(count == save_count + 2);
    save_count = count;
    }
    {
    void (*fp)(int) = f_void_1;
    int i = 3;
    boost::detail::invoke(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    void (*fp)(int) = f_void_1;
    int i = 3;
    boost::detail::invoke<void>(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    void (*fp)(int) = f_void_1;
    int i = 3;
    boost::detail::invoke(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    void (

    int i = 3;
    boost::detail::invoke<void>(fp, i);
    BOOST_TEST(count == save_count+3);
    save_count = count;
    }
    {
    A_void_1 a0;
    int i = 4;
    boost::detail::invoke(a0, i);
    BOOST_TEST(count == save_count+4);
    save_count = count;
    }
    {
    A_void_1 a0;
    int i = 4;
    boost::detail::invoke<void>(a0, i);
    BOOST_TEST(count == save_count+4);
    save_count = count;
    }
    {
    void (A_void_1::*fp)() = &A_void_1::mem1;
    A_void_1 a;
    boost::detail::invoke(fp, a);
    BOOST_TEST(count == save_count+1);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke(fp, ap);
    BOOST_TEST(count == save_count+1);
    save_count = count;
    }
    {
    void (A_void_1::*fp)() = &A_void_1::mem1;
    A_void_1 a;
    boost::detail::invoke<void>(fp, a);
    BOOST_TEST(count == save_count+1);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke<void>(fp, ap);
    BOOST_TEST(count == save_count+1);
    save_count = coun

    }
    {
    void (A_void_1::*fp)() const = &A_void_1::mem2;
    A_void_1 a;
    boost::detail::invoke(fp, a);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke(fp, ap);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    }
    {
    void (A_void_1::*fp)() const = &A_void_1::mem2;
    A_void_1 a;
    boost::detail::invoke<void>(fp, a);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    A_void_1* ap = &a;
    boost::detail::invoke<void>(fp, ap);
    BOOST_TEST(count == save_count+2);
    save_count = count;
    }
int f_int_1(int i)
    return i + 1;
struct A_int_1
    A_int_1() : data_(5) {}
    int operator()(int i)
    {
        return i - 1;
    }
    int mem1() {return 3;}
    int mem2() const {return 4;}
    int data_;
};
void
test_int_1()
    {
    int i = 2;
    BOOST_TEST(boost::detail::invoke(f_int_1, i) == 3);
    BOOST_TEST(boost::detail::invoke<int>(f_int_1, i) == 3);
    }
    {

    int (*fp)(int) = f_int_1;
    int i = 3;
    BOOST_TEST(boost::detail::invoke(fp, i) == 4);
    BOOST_TEST(boost::detail::invoke<int>(fp, i) == 4);
    }
    {
    int i = 4;
    BOOST_TEST(boost::detail::invoke(A_int_1(), i) == 3);
    const A_int_1 ca;
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke<int>(a, i) == 3);
    BOOST_TEST(boost::detail::invoke<int>(A_int_1(), i) == 3);
    }
    {
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem1, a) == 3);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::mem1, a) == 3);
    A_int_1* ap = &a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem1, ap) == 3);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::mem1, ap) == 3);
    }
    {
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem2, A_int_1()) == 4);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::mem2, A_int_1()) == 4);
    A_int_1* ap = &a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::mem2, ap) == 4);
    BOOST_TEST(boost::detail::invo

    }
    {
    A_int_1 a;
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, a) == 5);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, a) == 5);
    A_int_1* ap = &a;
    boost::detail::invoke(&A_int_1::data_, a) = 6;
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, a) == 6);
    boost::detail::invoke<int>(&A_int_1::data_, a) = 6;
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, a) == 6);
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, ap) == 6);
    boost::detail::invoke(&A_int_1::data_, ap) = 7;
    BOOST_TEST(boost::detail::invoke(&A_int_1::data_, ap) == 7);
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, ap) == 7);
    boost::detail::invoke<int>(&A_int_1::data_, ap) = 8;
    BOOST_TEST(boost::detail::invoke<int>(&A_int_1::data_, ap) == 8);
    }
void f_void_2(int i, int j)
    count += i+j;
struct A_void_2
    void operator()(int i, int j)
    {
        count += i+j;
    }
    void mem1(int i) {count += i;}
    void mem2(int i) const 
namespace {
QString getStringFromJson(const json_t *json, const char* key)
    return QString::fromUtf8(json_string_value(json_object_get(json, key)));
ServerRepo ServerRepo::fromJSON(const json_t *json, json_error_t */* error */)
    ServerRepo repo;
    repo.id = getStringFromJson(json, "id");
    repo.name = getStringFromJson(json, "name");
    repo.description = getStringFromJson(json, "desc");
    repo.mtime = json_integer_value(json_object_get(json, "mtime"));
    repo.size = json_integer_value(json_object_get(json, "size"));
    repo.root = getStringFromJson(json, "root");
    repo.encrypted = json_is_true(json_object_get(json, "encrypted"));
    repo.type = getStringFromJson(json, "type");
    repo.owner = getStringFromJson(json, "owner");
    repo.permission = getStringFromJson(json, "permission");
    repo.readonly = (repo.permission == "r") ? true : false;
    repo._virtual = json_is_true(json_object_get(json, "virtual"));
    if (repo.type == "grepo") {
        repo.group_n
constexpr struct {
  constexpr auto&& operator()(auto&& arg) const noexcept {
    return (decltype(arg)&&)arg;
  }
} h;
struct A {
  int i = 13;
  constexpr int f() const noexcept { return 42; }
  constexpr int g(int i) { return 2 * i; }
};
constexpr int f() noexcept { return 13; }
constexpr int g(int i) { return 2 * i + 1; }
int main() {
  CHECK(fcc::invoke(f) == 13);
  CHECK(noexcept(fcc::invoke(f) == 13));
  CHECK(fcc::invoke(g, 2) == 5);
  CHECK(fcc::invoke(h, 42) == 42);
  CHECK(noexcept(fcc::invoke(h, 42) == 42));
  {
    int i = 13;
    CHECK(&fcc::invoke(h, i) == &i);
    CHECK(noexcept(&fcc::invoke(h, i) == &i));
  }
  CHECK(fcc::invoke(&A::f, A{}) == 42);
  CHECK(noexcept(fcc::invoke(&A::f, A{}) == 42));
  CHECK(fcc::invoke(&A::g, A{}, 2) == 4);
  {
    A a;
    const auto& ca = a;
    CHECK(fcc::invoke(&A::f, a) == 42);
    CHECK(noexcept(fcc::invoke(&A::f, a) == 42));
    CHECK(fcc::invoke(&A::f, ca) == 42);
    CHECK(noexcept(fcc::invoke(&A::f, ca) == 42));
    CHECK(fcc::

  }
  {
    A a;
    const auto& ca = a;
    CHECK(fcc::invoke(&A::f, &a) == 42);
    CHECK(noexcept(fcc::invoke(&A::f, &a) == 42));
    CHECK(fcc::invoke(&A::f, &ca) == 42);
    CHECK(noexcept(fcc::invoke(&A::f, &ca) == 42));
    CHECK(fcc::invoke(&A::g, &a, 2) == 4);
  }
  {
    auto up = std::make_unique<A>();
    CHECK(fcc::invoke(&A::f, up) == 42);
    CHECK(fcc::invoke(&A::g, up, 2) == 4);
  }
  {
    auto sp = std::make_shared<A>();
    CHECK(fcc::invoke(&A::f, sp) == 42);
    CHECK(noexcept(fcc::invoke(&A::f, sp) == 42));
    CHECK(fcc::invoke(&A::g, sp, 2) == 4);
  }
  CHECK(fcc::invoke(&A::i, A{}) == 13);
  CHECK(noexcept(fcc::invoke(&A::i, A{}) == 13));
  { int&& tmp = fcc::invoke(&A::i, A{}); (void)tmp; }
  {
    A a;
    const auto& ca = a;
    CHECK(fcc::invoke(&A::i, a) == 13);
    CHECK(noexcept(fcc::invoke(&A::i, a) == 13));
    CHECK(fcc::invoke(&A::i, ca) == 13);
    CHECK(noexcept(fcc::invoke(&A::i, ca) == 13));
    CHECK(fcc::invoke(&A::i, &a) == 13);
    CHECK(no

    CHECK(fcc::invoke(&A::i, &ca) == 13);
    CHECK(noexcept(fcc::invoke(&A::i, &ca) == 13));
    fcc::invoke(&A::i, a) = 0;
    CHECK(a.i == 0);
    fcc::invoke(&A::i, &a) = 1;
    CHECK(a.i == 1);
    static_assert(std::is_same<decltype(fcc::invoke(&A::i, ca)), const int&>{});
    static_assert(std::is_same<decltype(fcc::invoke(&A::i, &ca)), const int&>{});
  }
  {
    auto up = std::make_unique<A>();
    CHECK(fcc::invoke(&A::i, up) == 13);
    fcc::invoke(&A::i, up) = 0;
    CHECK(up->i == 0);
  }
  {
    auto sp = std::make_shared<A>();
    CHECK(fcc::invoke(&A::i, sp) == 13);
    fcc::invoke(&A::i, sp) = 0;
    CHECK(sp->i == 0);
  }
  
  {
    struct B { int i = 42; constexpr int f() const { return i; } };
    constexpr B b;
    static_assert(b.i == 42);
    static_assert(b.f() == 42);
    static_assert(fcc::invoke(&B::i, b) == 42);
    static_assert(fcc::invoke(&B::i, &b) == 42);
    static_assert(fcc::invoke(&B::i, B{}) == 42);
    static_assert(fcc::invoke(&B::f, b) == 42);

int  ncid=0;                 /* netCDF id */
NNTI_peer_t caller;
int varid=1;
int ndims=4;
int dims[4] = {3, 3, 3, 3};
MPI_Offset *new_chunk_start=NULL;
MPI_Offset *new_chunk_count=NULL;
MPI_Offset *new_chunk_stride=NULL;
void add_chunk(int *buf)
    int buf_len;
    int num_elements;
    aggregation_chunk_details_t *chunk;
    new_chunk_count=(MPI_Offset *)malloc(ndims*sizeof(MPI_Offset));
    new_chunk_stride=(MPI_Offset *)malloc(ndims*sizeof(MPI_Offset));
    new_chunk_count[0]=dims[0];new_chunk_count[1]=dims[1];new_chunk_count[2]=dims[2];new_chunk_count[3]=dims[3];
    new_chunk_stride[0]=1;new_chunk_stride[1]=1;new_chunk_stride[2]=1;new_chunk_stride[3]=1;
    buf_len=dims[0]*dims[1]*dims[2]*dims[3]*sizeof(int);
    num_elements=dims[0]*dims[1]*dims[2]*dims[3];
    add_participant_for_file(ncid,
                             &caller,
                             WRITE_AGGREGATE_INDEPENDENT);
    chunk = new aggregation_chunk_details_t;
    chunk->ncid = ncid;
    chunk->varid = vari

    chunk->ndims = ndims;
    chunk->buf = buf;
    chunk->atype = NC_INT;
    chunk->len   = buf_len;
    chunk->datatype      = MPI_INT;
    chunk->num_elements  = num_elements;
    chunk->start  = new_chunk_start;
    chunk->count  = new_chunk_count;
    chunk->stride = new_chunk_stride;
    add_participant_chunk(&caller, chunk);
/*
 * NB:  The dims of the individual chunks is the same as the dimensions
 * of the overall array in terms of chunks.  So if the dimensions of a chunk
 * is 3x3x3, then the overall array will have 3x3x3 chunks or 9x9x9 elements.
 */
int
main(int argc, char **argv)
    int test_chunk_count;
    int **chunk;
    int i=0,j=0,k=0,l=0;
    int buf_len;
    MPI_Init(&argc, &argv);
    netcdf_debug_level=LOG_ALL;
    /* initialize and enable logging */
    logger_init(netcdf_debug_level, NULL);
    test_chunk_count=1;
    buf_len=1;
    for (i=0;i<ndims;i++) {
        test_chunk_count *= dims[i];
        buf_len *= dims[i];
    }
    buf_len *= sizeof(int);
    
ClientHandler::ClientHandler(        
    CefRefPtr<ClientContextMenuHandler> contextMenuHandler,
    CefRefPtr<ClientDialogHandler> dialogHandler,
    CefRefPtr<ClientDisplayHandler> displayHandler,
    CefRefPtr<ClientDownloadHandler> downloadHandler,
    CefRefPtr<ClientFocusHandler> focusHandler,
    CefRefPtr<ClientGeolocationHandler> geolocationHandler,
    CefRefPtr<ClientJSDialogHandler> jsdialogHandler,
    CefRefPtr<ClientKeyboardHandler> keyboardHandler,
    CefRefPtr<ClientLifeSpanHandler> lifeSpanHandler,
    CefRefPtr<ClientLoadHandler> loadHandler,
    CefRefPtr<ClientRenderHandler> renderHandler,
    CefRefPtr<ClientRequestHandler> requestHandler) :   
            m_contextMenuHandler(contextMenuHandler),
            m_dialogHandler(dialogHandler),
            m_displayHandler(displayHandler),
            m_downloadHandler(downloadHandler),
            m_focusHandler(focusHandler),
            m_geolocationHandler(geolocationHandler),
            m_jsdialogHandler(jsdia

            m_keyboardHandler(keyboardHandler),
            m_lifeSpanHandler(lifeSpanHandler),
            m_loadHandler(loadHandler),
            m_renderHandler(renderHandler),
            m_requestHandler(requestHandler)
    m_lifeSpanHandler->SetNullBrowser(new NullBrowser(this));
ClientHandler::~ClientHandler(void)
CefRefPtr<CefContextMenuHandler> ClientHandler::GetContextMenuHandler()
    return m_contextMenuHandler.get();
CefRefPtr<CefDialogHandler> ClientHandler::GetDialogHandler()
    return m_dialogHandler.get();
CefRefPtr<CefDisplayHandler> ClientHandler::GetDisplayHandler()
    return m_displayHandler.get();
CefRefPtr<CefDownloadHandler> ClientHandler::GetDownloadHandler()
    return m_downloadHandler.get();
CefRefPtr<CefFocusHandler> ClientHandler::GetFocusHandler()
    return m_focusHandler.get();
CefRefPtr<CefGeolocationHandler> ClientHandler::GetGeolocationHandler()
    return m_geolocationHandler.get();
CefRefPtr<CefJSDialogHandler> ClientHandler::GetJSDialogHandler(
namespace memorychunk {
    MemoryChunk::MemoryChunk(size_t sz) {
        ptr = new int8_t[sz];
        this->sz = sz;
    }
    int8_t *MemoryChunk::MemoryAt(size_t offset) const {
        return (ptr + offset);
    }
    size_t MemoryChunk::ChunkSize() const {
        return sz;
    }
    void MemoryChunk::Copy(const MemoryChunk &xxx) {
        ptr = new int8_t[xxx.ChunkSize()];
        std::copy(xxx.ptr, xxx.ptr + sz, ptr);
        sz = xxx.ChunkSize();
    }
    MemoryChunk::MemoryChunk(const MemoryChunk &xxx) {
        Copy(xxx);
    }
    MemoryChunk::MemoryChunk(MemoryChunk &&xxx) {
        ptr = xxx.ptr;
        sz = xxx.ChunkSize();
        xxx.ptr = nullptr;
        xxx.sz = 0;
    }
    MemoryChunk &MemoryChunk::operator=(const MemoryChunk &xxx) {
        if (this == &xxx) {
            return *this;
        }
        delete[] ptr;
        Copy(xxx);
    }
    MemoryChunk &MemoryChunk::operator=(MemoryChunk &&xxx) {
        if (this == &xxx) {
            return xxx;
       
 namespace Hurricane {
 /*! \class        GenericLocator
  *  \brief        GenericLocator description (\b API)
  *
  *  \section      secGenericLocatorIntro  Introduction
  *
  *                Locators are powerful objects but present a major weakness. 
  *                You must handle them through a pointer variable and not 
  *                forget to release the allocated locator after use. 
\code
Locator<Net*>* locator = cellGetNets().GetLocator();
...
...
delete locator;
\endcode
  *                Fortunately, the type GenericLocator\c \<Type\> corrects this 
  *                weakness. Indeed a generic locator creates at its 
  *                construction (or by assignment) a clone of the given locator 
  *                and releases, when deleted (or when assigned to an other 
  *                locator) the previously allocated one. More, when initialized 
  *                with an already allocated locator, it takes in charge to 
  *                release it. There

\code
GenericLocator<Net*> locator = cellGetNets().GetLocator();
...
...
\endcode
  *  \remark       It's possible to bring within a GenericLocator\c \<Type\> 
  *                variable any kind of locator of elements of the same Type 
  *                (and also an other generic locator). 
  */
 /*! \section      secGenericLocatorUsageExamples  Usage examples
  *
  *                Let's take the examples used in the Locator class and see 
  *                what they become. 
  *
  *                The following example shows how to visit the nets of a given 
  *                cell. 
\code
if (cell) {
   GenericLocator<Net*> locator = CellGetNets().GetLocator();
   while (locator.IsValid()) {
      Net* net = locator.GetElement();
      assert(netGetCell() == cell);
      locator.Progress();
   }
\endcode
  *                And this one, how to print all net pairs. 
\code
if (cell) {
   GenericLocator<Net*> locator1 = CellGetNets().GetLocator();
   while (locator1.IsValid()) {
 

      GenericLocator<Net*> locator2 = locator1;
      while (locator2.IsValid()) {
         Net* net2 = locator2.GetElement();
         cerr << net1 << " " << net2 << endl;
         locator2.Progress();
      }
      locator1Progress();
   }
\endcode
  *  \remark       Those examples are used here to describe generic locator 
  *                behaviours. We will see later how code them in a much simpler 
  *                way with the for_each macros. 
  */
 /*! \section      secGenericLocatorHowWorksTheMacroFor_each  How works the macro for_each
  *
  *                When explaining Collection class we used some macros. We can 
  *                now describe the way they are implemented. 
  *
  *                <b>Macro for_each implementation</b> 
\code
/*******************************************/\
{\
   GenericLocator<Type> _locator = collection.GetLocator();\
   while (_locator.IsValid()) {\
      Type variable = _locator.GetElement();\
      _locator.Progress();
\endcode
  

  *                locator provided by the given collection. The remaining code 
  *                is classic. 
  *
  *
  *  \remark       The locator allocated by the GetLocator() call is released by 
  *                the destructor of the generic locator which, itself, will be 
  *                called automatically because it is allocated within the 
  *                execution stack. 
  *
  *                <b>Macro end_for implementation</b> This macro is mandatory 
  *                in order to close the lexical blocks opened by the for_each 
  *                macro. 
\code
/**************/\
   }\
\endcode
  *                <b>Important observation</b> When you write the following : 
\code
for_each(Net*, net, cellGetNets()) {
   end_for;
\endcode
  *                The body is processed between for_each and end_for macros, 
  *                therefore after the binding of the variable to its element, 
  *                but also once the locator has progressed. It is th
namespace chromeos {
static NetworkHandler* g_network_handler = NULL;
NetworkHandler::NetworkHandler()
    : task_runner_(base::ThreadTaskRunnerHandle::Get()) {
  CHECK(DBusThreadManager::IsInitialized());
  network_state_handler_.reset(new NetworkStateHandler());
  network_device_handler_.reset(new NetworkDeviceHandlerImpl());
  network_profile_handler_.reset(new NetworkProfileHandler());
  network_configuration_handler_.reset(new NetworkConfigurationHandler());
  managed_network_configuration_handler_.reset(
      new ManagedNetworkConfigurationHandlerImpl());
  prohibited_technologies_handler_.reset(new ProhibitedTechnologiesHandler());
  if (CertLoader::IsInitialized()) {
    auto_connect_handler_.reset(new AutoConnectHandler());
    network_cert_migrator_.reset(new NetworkCertMigrator());
    client_cert_resolver_.reset(new ClientCertResolver());
  }
  network_activation_handler_.reset(new NetworkActivationHandler());
  network_connection_handler_.reset(new NetworkConnectionHandle

  network_sms_handler_.reset(new NetworkSmsHandler());
  geolocation_handler_.reset(new GeolocationHandler());
NetworkHandler::~NetworkHandler() {
  network_state_handler_->Shutdown();
void NetworkHandler::Init() {
  network_state_handler_->InitShillPropertyHandler();
  network_device_handler_->Init(network_state_handler_.get());
  network_profile_handler_->Init();
  network_configuration_handler_->Init(network_state_handler_.get(),
                                       network_device_handler_.get());
  managed_network_configuration_handler_->Init(
      network_state_handler_.get(), network_profile_handler_.get(),
      network_configuration_handler_.get(), network_device_handler_.get(),
      prohibited_technologies_handler_.get());
  network_connection_handler_->Init(
      network_state_handler_.get(),
      network_configuration_handler_.get(),
      managed_network_configuration_handler_.get());
  if (network_cert_migrator_)
    network_cert_migrator_->Init(network_state_handle

  if (client_cert_resolver_) {
    client_cert_resolver_->Init(network_state_handler_.get(),
                                managed_network_configuration_handler_.get());
  }
  if (auto_connect_handler_) {
    auto_connect_handler_->Init(client_cert_resolver_.get(),
                                network_connection_handler_.get(),
                                network_state_handler_.get(),
                                managed_network_configuration_handler_.get());
  }
  prohibited_technologies_handler_->Init(
      managed_network_configuration_handler_.get(),
      network_state_handler_.get());
  network_sms_handler_->Init();
  geolocation_handler_->Init();
void NetworkHandler::Initialize() {
  CHECK(!g_network_handler);
  g_network_handler = new NetworkHandler();
  g_network_handler->Init();
void NetworkHandler::Shutdown() {
  CHECK(g_network_handler);
  delete g_network_handler;
  g_network_handler = NULL;
NetworkHandler* NetworkHandler::Get() {
  CHECK(g_network_handler)
 

  return g_network_handler;
bool NetworkHandler::IsInitialized() {
  return g_network_handler;
NetworkStateHandler* NetworkHandler::network_state_handler() {
  return network_state_handler_.get();
NetworkDeviceHandler* NetworkHandler::network_device_handler() {
  return network_device_handler_.get();
NetworkProfileHandler* NetworkHandler::network_profile_handler() {
  return network_profile_handler_.get();
NetworkConfigurationHandler* NetworkHandler::network_configuration_handler() {
  return network_configuration_handler_.get();
ManagedNetworkConfigurationHandler*
NetworkHandler::managed_network_configuration_handler() {
  return managed_network_configuration_handler_.get();
NetworkActivationHandler* NetworkHandler::network_activation_handler() {
  return network_activation_handler_.get();
NetworkConnectionHandler* NetworkHandler::network_connection_handler() {
  return network_connection_handler_.get();
NetworkSmsHandler* NetworkHandler::network_sms_handler() {
  return network_sms_
/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
**
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** Commercial Usage
**
** Licensees holding valid Qt Commercial licenses may use this file in
** accordance with the Qt Commercial License Agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Nokia.
**
** GNU Lesser General Public License Usage
**
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
**
** If you are unsure which license is appropriate for your use, please
**
********************************************************
/*
 * MONA
 * Copyright (C) 1997-2000 BRICS.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the  Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
 * USA.
 */
extern SymbolTable symbolTable;
void 
ASTComponent::dump()
  cout << name;
  if (path)
    path->dump();
  else
    cout << "[?]";
  cout << ":" << type;
void
ASTComponentList::dump()
  for (iterator i = begin(); i != end(); i++) 

    if (i != begin())
      cout << ",";
    (*i)->dump();
  }
void
ASTVariant::dump()
  cout << name;
  if (path)
    path->dump();
  else
    cout << "[?]";
  cout << "(";
  if (components)
    components->dump();
  cout << ")";
void
ASTVariantList::dump()
  for (iterator i = begin(); i != end(); i++) {
    if (i != begin())
      cout << ",";
    (*i)->dump();
  }
void
BitList::dump()
  cout << "[";
  for (iterator i = begin(); i != end(); i++)
    if (*i == Zero)
      cout << "0";
    else
      cout << "1";
  cout << "]";
void 
ASTList::dump()
  iterator i;
  for (i = begin(); i != end(); i++) {
    cout << ","; (*i)->dump();
  }
void 
ASTUniv::dump()
  cout << symbolTable.lookupSymbol(u);
void 
ASTTerm1_Var1::dump()
  cout << "Var1 " << symbolTable.lookupSymbol(n);
  
void 
ASTTerm1_Dot::dump()
  cout << "Dot("; t->dump(); cout << ",";
  BitList::iterator i;
  for (i = bits->begin(); i != bits->end(); i++)
    if (*i == Zero)
      cout << "0";
    else
      cout << "1";
  cou

    
void 
ASTTerm1_Up::dump()
  cout << "Up("; t->dump(); cout << ")";
    
void
ASTTerm1_Root::dump()
  if (univ == -1) {
    IdentList *univs = symbolTable.allUnivs();
    univ = univs->get(0);
    delete univs;
  }
  cout << "Root(" << symbolTable.lookupSymbol(univ) << ")";
void 
ASTTerm1_Int::dump()
  cout << "Int " << n;
    
void 
ASTTerm1_Plus::dump()
  cout << "Plus1("; t->dump(); cout << "," << n << ")";
    
void 
ASTTerm1_Minus::dump()
  cout << "Minus1("; t->dump(); cout << "," << n << ")";
    
void 
ASTTerm1_PlusModulo::dump()
  cout << "PlusModulo1("; t1->dump(); cout << ","  << n << ",";
  t2->dump(); cout << ")";
    
void 
ASTTerm1_MinusModulo::dump()
  cout << "MinusModulo1("; t1->dump(); cout << "," << n << ",";
  t2->dump(); cout << ")";
    
void 
ASTTerm1_Min::dump()
  cout << "Min("; T->dump(); cout << ")";
    
void 
ASTTerm1_Max::dump()
  cout << "Max("; T->dump(); cout << ")";
    
void 
ASTTerm1_TreeRoot::dump()
  cout << "TreeRoot("; T->dump(); cout << ")

    
void 
ASTTerm2_Var2::dump()
  cout << "Var2 " << symbolTable.lookupSymbol(n);
    
void 
ASTTerm2_VarTree::dump()
  cout << "Tree " << symbolTable.lookupSymbol(n);
    
void 
ASTTerm2_Dot::dump()
  cout << "Dot("; T->dump(); cout << ",";
  BitList::iterator i;
  for (i = bits->begin(); i != bits->end(); i++)
    if (*i == Zero)
      cout << "0";
    else
      cout << "1";
  cout << ")";
    
void 
ASTTerm2_Up::dump()
  cout << "Up("; T->dump(); cout << ")";
    
void 
ASTTerm2_Empty::dump()
  cout << "Empty";
    
void 
ASTTerm2_Union::dump()
  cout << "Union("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTTerm2_Inter::dump()
  cout << "Inter("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTTerm2_Setminus::dump()
  cout << "Setminus("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTTerm2_Set::dump()
  ASTList::iterator i;
  cout << "Set(";
  for (i = elements->begin(); i != elements->end();) {
    (*i)->dump();
    if (++i !

      cout << ",";
  }
  cout << ")";
    
void 
ASTTerm2_Plus::dump()
  cout << "Plus2("; T->dump(); cout << "," << n << ")";
    
void 
ASTTerm2_Minus::dump()
  cout << "Minus2("; T->dump(); cout << "," << n << ")";
    
void 
ASTTerm2_Interval::dump()
  cout << "Interval("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTTerm2_PresbConst::dump()
  cout << "PresbConst(" << value << ")"; 
void 
ASTTerm2_Formula::dump()
  cout << "Term2Formula(" << symbolTable.lookupSymbol(fresh) << ",";
  f->dump(); cout << ")";
void 
ASTForm_Var0::dump()
  cout << "Var0 " << symbolTable.lookupSymbol(n);
    
void 
ASTForm_True::dump()
  cout << "True";
    
void 
ASTForm_False::dump()
  cout << "False";
    
void 
ASTForm_In::dump()
  cout << "In("; t1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_Notin::dump()
  cout << "Notin("; t1->dump(); cout << ","; T2->dump(); cout << ")";
    
void
ASTForm_RootPred::dump()
  cout << "Root("; t->dump(); cout << ",["; ul->du

void 
ASTForm_EmptyPred::dump()
  cout << "EmptyPred("; T->dump(); cout << ")";
    
void 
ASTForm_FirstOrder::dump()
  cout << "FirstOrder("; t->dump(); cout << ")";
    
void 
ASTForm_Sub::dump()
  cout << "Sub("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_Equal1::dump()
  cout << "Equal1("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_Equal2::dump()
  cout << "Equal2("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_NotEqual1::dump()
  cout << "NotEqual1("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_NotEqual2::dump()
  cout << "NotEqual2("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_Less::dump()
  cout << "Less("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_LessEq::dump()
  cout << "LessEq("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_WellFormedTree::dump()
  cout << "WellFormedTree("; T->dump(); cout << ")";


void 
ASTForm_Impl::dump()
  cout << "Impl("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_Biimpl::dump()
  cout << "Biimpl("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_And::dump()
  cout << "And("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_IdLeft::dump()
  cout << "IdLeft("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_Or::dump()
  cout << "Or("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_Not::dump()
  cout << "Not("; f->dump(); cout << ")";
    
void 
ASTForm_Ex0::dump()
  cout << "Ex0("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_Ex1::dump()
  cout << "Ex1("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_Ex2::dump()
  cout << "Ex2("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_All0::dump()
  cout << "All0("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_All1::dump(

  cout << "All1("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_All2::dump()
  cout << "All2("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_Let0::dump()
  IdentList::iterator ident;
  FormList::iterator form;
  cout << "Let0(";
  for (ident = defIdents->begin(), form = defForms->begin(); 
       ident != defIdents->end(); ident++, form++) {
    cout << "(Var0 " << symbolTable.lookupSymbol(*ident) 
	 << ","; (*form)->dump(); cout << "),";
  }
  f->dump(); cout << ")";
    
void 
ASTForm_Let1::dump()
  IdentList::iterator ident;
  Term1List::iterator term;
  cout << "Let1(";
  for (ident = defIdents->begin(), term = defTerms->begin(); 
       ident != defIdents->end(); ident++, term++) {
    cout << "(Var1 " << symbolTable.lookupSymbol(*ident) 
      << ","; (*term)->dump(); cout << "),";
  }
  f->dump(); cout << ")";
    
void 
ASTForm_Let2::dump()
  IdentList::iterator ident;
  Term2List::iterator term;
  cout << "Let2(";
  for (ident = d

       ident != defIdents->end(); ident++, term++) {
    cout << "(Var2 " << symbolTable.lookupSymbol(*ident) 
      << ","; (*term)->dump(); cout << "),";
  }
  f->dump(); cout << ")";
    
void 
ASTForm_Call::dump()
  cout << "Call(" << symbolTable.lookupSymbol(n);
  args->dump();
  cout << ")";
void 
ASTForm_Import::dump()
  cout << "Import(\"" << file << "\"";
  Deque<char *>::iterator i;
  IdentList::iterator j;
  for (i = fileVars->begin(), j = idents->begin(); 
       i != fileVars->end(); i++, j++)
    cout << ",(" << *i << "," << symbolTable.lookupSymbol(*j) << ")";
  cout << ")";
void 
ASTForm_Export::dump()
  cout << "Export(\"" << file << "\","; f->dump(); cout << ")";
void 
ASTForm_Prefix::dump()
  cout << "Prefix("; f->dump(); cout << ")";
void 
ASTForm_Restrict::dump()
  cout << "Restrict("; f->dump(); cout << ")";
void 
ASTForm_InStateSpace1::dump()
  cout << "InStateSpace1("; t->dump(); 
  cout << ","; ss->dump(); cout << ")";
void 
ASTForm_InStateSpace2::dump()
  cou
class QModelIndex;
class ServerRepo;
class RepoCategoryItem;
class RepoItem;
class QTimer;
class RepoTreeView;
/**
 * Tree model for repos. There are two levels of items:
 *
 * The first level: (RepoCategory)
 *  - My Libraries
 *  - Shared Libraries
 *  - Group 1
 *  - Group 2
 *  - Group N
 *
 * The sencond level is the libraries belonging to the first level item (RepoItem)
 *
 *  - My Libraries
 *    - Notes
 *    - Musics
 *    - Logs
 */
class RepoTreeModel : public QStandardItemModel {
    Q_OBJECT
public:
    RepoTreeModel(QObject *parent=0);
    void setRepos(const std::vector<ServerRepo>& repos);
    void clear();
    void setTreeView(RepoTreeView *view) { tree_view_ = view; }
    RepoTreeView* treeView() { return tree_view_; }
    void updateRepoItemAfterSyncNow(const QString& repo_id);
private slots:
    void refreshLocalRepos();
private:
    void checkPersonalRepo(const ServerRepo& repo);
    void checkVirtualRepo(const ServerRepo& repo);
    void checkSharedRepo(const Serv
typedef uint8_t sample_t;
class GMCounterBase
public:
    virtual void addSample(sample_t value);
    virtual sample_t getSample(uint16_t index);
    
    virtual uint16_t getSampleCount();
    
    virtual sample_t getMaxSampleValue();
    
    virtual uint16_t getBinValue(uint8_t binId, uint8_t binTotal);
    
    virtual sample_t getMinSampleValue();
    
    virtual sample_t getMean(uint16_t sampleRange);
    virtual float getDose();
};
template <size_t ITEM_MAX, uint8_t AMOUNT_OF_PRRALLEL_TUBES>
class GMCounter: public GMCounterBase
public:
    GMCounter()
    {
    }
    virtual void addSample(sample_t value)
    {
        sample.add(value);
    }
    virtual sample_t getSample(uint16_t index)
    {
        return sample.get(index);
    }
    virtual uint16_t getSampleCount()
    {
        return sample.count();
    }
    virtual sample_t getMaxSampleValue()
    {
        sample_t maxValue = 0U;
        for(uint16_t i = 0U; i < sample.count(); i++)
        {
            if (sampl

            {
                maxValue = sample.get(i);
            }
        }
        return maxValue;
    }
    virtual sample_t getMean(uint16_t sampleRange)
    {
        uint16_t retValue = 0U;
        for(uint16_t i = 0U; i < sampleRange; i++)
        {
            retValue += sample.get(i);
        }
        retValue /= sampleRange;
        
        return sample_t(retValue);
    }
    virtual uint16_t getBinValue(uint8_t binId, uint8_t binTotal)
    {
        sample_t retValue = 0U;
        sample_t maximum = getMaxSampleValue();
        sample_t minimum = getMinSampleValue();
        sample_t binLength = float(maximum - minimum) / float(binTotal);
        sample_t start = minimum + (binId *  binLength);
        sample_t stop = start + binLength;
        for(uint16_t i = 0U; i < getSampleCount(); i++)
        {
            if ((getSample(i) >= start) && (getSample(i) < stop))
            {
                retValue++;
            }
        }
        return retValue;
    }
   

ClassImp(KVMemoryPool)
/* -->
<h2>KVMemoryPool</h2>
<h4>Memory pool</h4>
<!-- */
KVMemoryPool::KVMemoryPool(int nchunks, size_t bytes)
   fFirst = fLast = fLastChunkUsed = 0;
   for (int i = 0; i < nchunks; i++) {
      KVMemoryChunk* chunk = new KVMemoryChunk(bytes);
      if (!fFirst) fFirst = chunk;
      if (fLast) fLast->SetNext(chunk);
      fLast = chunk;
   }
   fLastChunkUsed = fFirst;
   fChunkSize = bytes;
void* KVMemoryPool::GetMemory(size_t bytes)
   void* p = fFirst->GetMemory(bytes);
   fLastChunkUsed = fFirst;
   if (!p) {
      do {
         fLastChunkUsed = fLastChunkUsed->Next();
         if (fLastChunkUsed) p = fLastChunkUsed->GetMemory(bytes);
      } while (!p && fLastChunkUsed);
   }
   if (!p) {
      size_t new_chunk = fChunkSize;
      while (new_chunk < bytes) new_chunk *= 2;
      fChunkSize = new_chunk;
      KVMemoryChunk* chunk = new KVMemoryChunk(fChunkSize);
      fLast->SetNext(chunk);
      fLast = chunk;
      fLastChunkUsed = chunk;
      p = fLastC
/* Generated file.  Do not edit */
VTE_SEQUENCE_HANDLER(vte_sequence_handler_AL)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DC)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DL)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DO)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_IC)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_LE)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_RI)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_SF)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_SR)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_UP)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ae)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_al)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_application_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_as)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bt)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cS)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cd)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ce)
VTE_SEQUENCE_HANDLER(vte_sequ

VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_cursor_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cm)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cs)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ct)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_character_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_lower_left)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_preceding_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cv)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dec_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler

VTE_SEQUENCE_HANDLER(vte_sequence_handler_decset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_delete_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_do)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_eA)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ec)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ei)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_characters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_display)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_form_feed)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_fs)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_full_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ho)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_horizontal_and_vertical_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ic)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_im)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_index)
VTE_SE

VTE_SEQUENCE_HANDLER(vte_sequence_handler_insert_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_kb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ke)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ks)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_le)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_line_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ll)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_local_charset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_md)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_me)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mh)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mk)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mp)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_nd)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_noop)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_normal_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_nw)
VTE_SEQUENCE_HANDL

VTE_SEQUENCE_HANDLER(vte_sequence_handler_request_terminal_parameters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_restore_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_id)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_status)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reverse_index)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_save_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_screen_alignment_test)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_down)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_se)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_primary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_secondary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_and_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_title)
VTE_SEQUENCE_HANDLER(vte_sequence_hand

VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sf)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_so)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_soft_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ta)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_tab_clear)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ts)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_uc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ue)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_us)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_utf_8_charset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_vb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ve)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_vertical_tab)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_vi)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_vs)
VTE_SEQUENC
void main(void);
void main(void)
  tensor A(3,3,2,3);
  tensor B(3,3,2,3);
  tensor C;
  tensor D(1,3), E(1,2), F(1,4);
  tensor G(2,3,2), H;
  char *dump;
  dump = NULL;
  int i, j, k;
  FILE *skippy;
  skippy = fopen("tensor_test.txt","w");
  A.Set(-19,1,1,1);
  A.print("A",&dump);
  fprintf(skippy,"A.Set(-19,1,1,1)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  A.ScalarMult(1.0/19.0);
  A.print("A",&dump);
  fprintf(skippy,"A.ScalarMult(1.0/19.0)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  for( i = 0; i < 3; i++) for( j = 0; j < 2; j++) for( k = 0; k < 3; k++)
        B.Set(1,i,j,k);
  for( i = 0; i < 3; i++) D.Set(sqrt(i),i);
  for( j = 0; j < 2; j++) E.Set(-1+j,j);
  for( k = 0; k < 4; k++) F.Set(2*k,k);
  B.print("B",&dump);
  fprintf(skippy,"B.Set(1,i,j,k)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"B.max() = %g\n\n",B.max());
  D.print("D",&dump);
  fprintf(skippy,"D.Set(sqrt(i),i)\n");
  fprintf(s

  fprintf(skippy,"D.max() = %g\n\n",D.max());
  E.print("E",&dump);
  fprintf(skippy,"E.Set(-1+j,j)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"E.max() = %g\n\n",E.max());
  F.print("F",&dump);
  fprintf(skippy,"F.Set(2*k,k)\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"F.max() = %g\n\n",F.max());
  C = A + B;
  C.print("C",&dump);
  fprintf(skippy,"C = A + B\n");
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  C = A + A + B;
  fprintf(skippy,"C = A + A + B\n");
  C.print("C",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  C = B - A;
  fprintf(skippy,"C = B - A\n");
  C.print("C",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  G = D*E;
  fprintf(skippy,"G = D*E\n");
  G.print("G",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"G.max() = %g\n\n",G.max());
  H = D*E*F;
  fprintf(skippy,"H = D*E*F\n");
  H.print("H",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(ski

  C = A.Contract(B,2,2);
  fprintf(skippy,"C = A.Contract(B,2,2)\n");
  C.print("C",&dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  A <= B;
  fprintf(skippy,"A <= B\n");
  A.print("A", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  B.ScalarMult(0.0);
  fprintf(skippy,"B.ScalarMult(0.0)\n");
  B.print("B", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"B.max() = %g\n\n",B.max());
  fprintf(skippy,"A <= B recheck\n");
  A.print("A", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"A.max() = %g\n\n",A.max());
  fprintf(skippy,"A has %d indices\n",A.NumIndices());
  int *range = A.Ranges();
  fprintf(skippy,"with ranges %d %d %d\n\n", range[0], range[1], range[2]);
  C = A*5.0;
  fprintf(skippy,"C = A*5.0\n");
  C.print("C", &dump);
  fprintf(skippy,"%s",dump);
  fprintf(skippy,"C.max() = %g\n\n",C.max());
  D <= C;
  fprintf(skippy,"D <= C\n");
  D.print("D", &dump);
  fprintf(skippy,"%s",dump);
  fp
namespace syrup {
    template<typename T, int N, int I, int O>
    struct linear_model {
        Matrix<T, N, N> A;
        Matrix<T, N, I> B;
        Matrix<T, O, N> C;
        Matrix<T, N, 1> x;
        Matrix<T, I, 1> u;
    };
    template<typename T, int N, int I, int O>
    struct linear_filter {
        Matrix<T, N, N> P, Q;
        Matrix<T, N, O> K;
        linear_model<T, N, I, O> *model;
        linear_filter(linear_model<T, N, I, O>* const m) : model(m) {};
    };
    template<typename T, int N, int I, int O>
    struct linear_controller {
        Matrix<T, I, N> L;
        linear_model<T, N, I, O> *model;
        linear_controller(linear_model<T, N, I, O>* const m) : model(m) {};
    };
    template<typename T, int N, int I, int O>
    void lq(linear_controller<T, N, I, O>& c) {
        c.model->u = -c.L * c.model->x;
    }
    template<typename T, int N, int I, int O>
    void kalman(linear_filter<T, N, I, O>& f, const Matrix<T, O, 1>& y) {
        f.model->x += f.K*(y -
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
LitstrRepoProxy::LitstrRepoProxy(Repo& repo)
    : RepoProxy(repo)
    , m_insertLitstrLocal(repo, RepoIdLocal)
    , m_insertLitstrCentral(r

    , m_getLitstrsLocal(repo, RepoIdLocal)
    , m_getLitstrsCentral(repo, RepoIdCentral) {
  m_insertLitstr[RepoIdLocal] = &m_insertLitstrLocal;
  m_insertLitstr[RepoIdCentral] = &m_insertLitstrCentral;
  m_getLitstrs[RepoIdLocal] = &m_getLitstrsLocal;
  m_getLitstrs[RepoIdCentral] = &m_getLitstrsCentral;
void LitstrRepoProxy::createSchema(int repoId, RepoTxn& txn) {
  std::stringstream ssCreate;
  ssCreate << "CREATE TABLE " << m_repo.table(repoId, "Litstr")
           << "(litstrId INTEGER, litstr TEXT,"
              " PRIMARY KEY (litstrId));";
  txn.exec(ssCreate.str());
void LitstrRepoProxy::load() {
  for (int repoId = RepoIdCount - 1; repoId >= 0; --repoId) {
    if (!getLitstrs(repoId).get()) {
      break;
    }
  }
void LitstrRepoProxy::InsertLitstrStmt::insert(RepoTxn& txn,
                                               Id litstrId,
                                               const StringData* litstr) {
  if (!prepared()) {
    std::stringstream ssInsert;
    ssInsert 
/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2011 Nokia Corporation and/or its subsidiary(-ies).
**
** Contact: Nokia Corporation (info@qt.nokia.com)
**
**
** GNU Lesser General Public License Usage
**
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** Please review the following information to ensure the GNU Lesser General
** Public License version 2.1 requirements will be met:
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
**
** Other Usage
**
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
** If you have questions regarding the use of this file, please contact
** Nokia at info@qt.nokia.com.
**
****
ChunkManager::ChunkManager()
void ChunkManager::AsyncChunkLoad(int chunkX, int chunkY, int chunkZ)
  
void ChunkManager::AsyncChunkUnload(Chunk** chunks, int num)
  if(loadLive == false)
  {
  }
void ChunkManager::UnloadChunk(Chunk* chunk)
  static int chunkX(0), chunkY(0), chunkZ(0);
  unloadMutex.lock();
  chunkX = (int)chunk->WorldPosition().x;
  chunkY = (int)chunk->WorldPosition().y;
  chunkZ = (int)chunk->WorldPosition().z;
  std::stringstream fNameStream;
  fNameStream << chunkX << "_" << chunkY << "_" << chunkZ << ".dat";
  writeStream.open(fNameStream.str().c_str(), std::ios::binary | std::ios::beg | std::ios::out);
  writeStream.put(ChunkTags::Start);
  writeStream.put(ChunkTags::Position);
  writeStream.put(sizeof(int) * 3);
  int pos[3] = { chunkX, chunkY, chunkZ };
  writeStream.write((char*)pos, sizeof(int) * 3);
  
  writeStream.put(ChunkTags::ChunkSize);
  writeStream.put(sizeof(int));
  writeStream.put(gkChunkSize);
  writeStream.put(ChunkTags::BlockData);
  int bBlock
char a01[1] = { 1 };
char a02[1] = { { 1 } };
char a05[2] = { 1, 2 };
char a06[2] = { { 1 }, 2 };
char a07[2] = { 1, { 2 } };
char a08[2] = { { 1 }, { 2 } };
char a09[2] = { 1 };
char a10[2][3] = { 1, 2, 3, 4, 5, 6 };
char a11[2][3] = { { 1, 2, 3 }, 4, 5, 6 };
char a12[2][3] = { 1, 2, 3, { 4, 5, 6 } };
char a13[2][3] = { { 1, 2, 3 }, { 4, 5, 6 } };
char a14[2][3] = { { { 1 }, { 2 }, { 3 } }, { { 4 }, { 5 }, { 6 } } };
char a15[2][3] = { { { 1 }, 2, 3 }, 4, 5, 6 };
char a16[2][3] = { 1, { 2 }, 3, 4, 5, 6 };
char a20[2][2][2] = { 1, 2, 3, 4, 5, 6, 7, 8 };
char a21[2][2][2] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };
char a22[2][2][2] = { { { 1, 2 }, { 3, 4 } }, { { 5, 6 }, { 7, 8 } } };
char a23[2][2][2] = { { { { 1 }, { 2 } }, { { 3 }, { 4 } } }, { { { 5 }, { 6 } }, { { 7 }, { 8 } } } };
char a24[2][2][2] = { { 1 }, { 5, 6, 7, 8 } };
char a25[2][2][2] = { { { 1 } }, { 5, 6, 7, 8 } };
char a26[2][2][2] = { { 1, 2 }, { 5, 6, 7, 8 } };
char a27[2][2][2] = { { { 1 }, { 3 } }, { 5, 6, 7, 8 } };
st
BookstoreController::BookstoreController(BookstoreRepository& repos,
	BookValidator& valid, CartRepository& repoCart,
	CartValidator& validCart) :
	repo(repos), valid(valid), repoCart(repoCart), validCart(validCart) {
void BookstoreController::undo() {
	if (undoActions.empty()) {
		throw ValidatorException("Nu mai exista operatii.");
	}
	undoActions.back()->doUndo();
	undoActions.pop_back();
vector<Book>& BookstoreController::getAll() {
	return repo.getAll();
void BookstoreController::add(string title, string author, string subject,
	int year) {
	int id = repo.getLastId();
	Book book(id, title, author, subject, year);
	valid.validate(book);
	repo.addBook(book);
	undoActions.push_back(std::make_unique<UndoAdd>(repo, book));
void BookstoreController::del(int id) {
	Book book = repo.getById(id);
	repo.deleteBook(book);
	undoActions.push_back(std::make_unique<UndoDelete>(repo, book));
void BookstoreController::update(int id, string title, string author,
	string subject, int year) {
	Book b

	Book oldBook = repo.getById(id);
	valid.validate(book);
	repo.updateBook(book);
	undoActions.push_back(std::make_unique<UndoUpdate>(repo, oldBook, book));
bool BookstoreController::existId(int id) {
	return repo.existId(id);
Book BookstoreController::existTitle(string title) {
	return repo.existTitle(title);
Book BookstoreController::getBookById(int id) {
	return repo.getById(id);
vector<Book> BookstoreController::filterByTitle(string title) {
	return repo.filterBy(1, title);
vector<Book>& BookstoreController::filterByYear(string year) {
	return repo.filterBy(2, year);
vector<Book>& BookstoreController::sortByTitle() {
	return repo.sortBy(1);
vector<Book>& BookstoreController::sortByAuthor() {
	return repo.sortBy(2);
vector<Book>& BookstoreController::sortByYearAndSubject() {
	return repo.sortBy(3);
void BookstoreController::addBookCart(Book book) {
	repoCart.add(book);
vector<Book>& BookstoreController::getAllCart() {
	return repoCart.getAll();
void BookstoreController::emptyCart() 
/**
 * @file SampleSetWrapper.cpp
 * @brief implements of SampleSetWrapper class
 *
 * @author S.Tanaka
 * @date 2008.01.07
 * 
 * Copyright(C) 2006-2014 Eisai Co., Ltd. All rights reserved.
 */
using namespace kome::clr;
SampleSetWrapper::SampleSetWrapper( kome::objects::SampleSet& sampleSet ) : m_sampleSet( sampleSet ) {
SampleSetWrapper::~SampleSetWrapper() {
kome::objects::SampleSet& SampleSetWrapper::getSampleSet() {
	return m_sampleSet;
int SampleSetWrapper::getSampleSetId() {
	return m_sampleSet.getSampleSetId();
void SampleSetWrapper::setFilePath( System::String^ path ) {
	m_sampleSet.setFilePath( ClrObjectTool::convertString( path ).c_str() );
System::String^ SampleSetWrapper::getFilePath() {
	return ClrObjectTool::convertString( m_sampleSet.getFilePath(), NULL );
System::String^ SampleSetWrapper::getFileName() {
	return ClrObjectTool::convertString( m_sampleSet.getFileName(), NULL );
bool SampleSetWrapper::isOpened() {
	return m_sampleSet.isOpened();
void SampleSetWrapper::cl

	m_sampleSet.clearSamples();
void SampleSetWrapper::addSample( SampleWrapper^ sample ) {
	kome::objects::Sample* s = NULL;
	if( sample != nullptr ) {
		s = &( sample->getSample() );
	}
	m_sampleSet.addSample( s );
unsigned int SampleSetWrapper::getNumberOfSamples() {
	return m_sampleSet.getNumberOfSamples();
SampleWrapper^ SampleSetWrapper::getSample( unsigned int index ) {
	kome::objects::Sample* sample = m_sampleSet.getSample( index );
	SampleWrapper^ s = ClrObjectTool::createSampleWrapper( sample );
	return s;
bool SampleSetWrapper::openFile( System::String^ path ) {	
	std::string p = ClrObjectTool::convertString( path );
	return m_sampleSet.openFile( p.c_str() );
bool SampleSetWrapper::closeFile() {
	return m_sampleSet.closeFile();
void SampleSetWrapper::startLoadingTimer() {
	kome::objects::SampleSet::startLoadingTimer();
void SampleSetWrapper::stopLoadingTimer() {
	kome::objects::SampleSet::stopLoadingTimer();
double SampleSetWrapper::getTotalLoadingTime() {
	return kome::object
namespace GameWorld {
ChunkStorage::ChunkStorage(World& level) :
	mLevel(level), mTerraGen(0)
	mRegionMap.fill(static_cast<WorldRegion*>(0));
	mTerraGen = new TerrainGenerator(mLevel);
ChunkStorage::~ChunkStorage()
	if (mTerraGen) {
		delete mTerraGen;
	}
void ChunkStorage::shutdown()
	for (auto regionIt = mRegionMap.begin(); regionIt != mRegionMap.end(); ++regionIt) {
		if (*regionIt != 0) {
			(*regionIt)->saveToDisk();
		}
	}
Chunk* ChunkStorage::getChunkAbs(wCoord x, wCoord y, wCoord z)
	return getPillarAbs(x, z).getChunkAbs(y);
ChunkPillar& ChunkStorage::getPillarAbs(wCoord x, wCoord z)
	return getRegion(getChunkCoordXZ(x), getChunkCoordXZ(z)).getPillar(getChunkIndexXZ(x), getChunkIndexXZ(z));
Chunk* ChunkStorage::getChunkLocal(wCoord x, wCoord y, wCoord z)
	return getPillarLocal(x, z).getChunkLocal(getChunkIndexYLocal(y));
ChunkPillar& ChunkStorage::getPillarLocal(wCoord x, wCoord z)
	return getRegion(x, z).getPillar(getChunkIndexXZLocal(x), getChunkIndexXZLocal(z));
WorldRegion&

	x = getRegionCoord(x);
	z = getRegionCoord(z);
	size_t index = getRegionIndex(x, z);
	WorldRegion* curRegion = mRegionMap[index];
	if (curRegion == 0 || !curRegion->checkCoords(x, z)) {
		if (curRegion != 0) {
			delete curRegion;
		}
		curRegion = new WorldRegion(mLevel, *this, x, z);
		mRegionMap[index] = curRegion;
	}
	return *curRegion;
void ChunkStorage::updateChunkLocal(wCoord x, wCoord y, wCoord z)
	Chunk* curChunk = getChunkLocal(x, y, z);
	curChunk->update(true);
void ChunkStorage::updateChunkAbs(wCoord x, wCoord y, wCoord z)
	Chunk* curChunk = getChunkAbs(x, y, z);
	curChunk->update(true);
void ChunkStorage::cubeModifiedAbs(wCoord x, wCoord y, wCoord z)
	updateChunkAbs(x, y, z);
	if (getCubeIndexXZ(x) == ChunkSizeX - 1) updateChunkAbs(x + ChunkSizeX, y             , z             );
	if (getCubeIndexXZ(x) == 0)				 updateChunkAbs(x - ChunkSizeX, y             , z             );
	if (getCubeIndexY(y)  == ChunkSizeY - 1) updateChunkAbs(x             , y + ChunkSizeY, z       
namespace base {
typedef HistogramBase::Count Count;
typedef HistogramBase::Sample Sample;
SampleMap::SampleMap() : SampleMap(0) {}
SampleMap::SampleMap(uint64_t id) : HistogramSamples(id) {}
SampleMap::~SampleMap() {}
void SampleMap::Accumulate(Sample value, Count count) {
  sample_counts_[value] += count;
  IncreaseSum(static_cast<int64_t>(count) * value);
  IncreaseRedundantCount(count);
Count SampleMap::GetCount(Sample value) const {
  std::map<Sample, Count>::const_iterator it = sample_counts_.find(value);
  if (it == sample_counts_.end())
    return 0;
  return it->second;
Count SampleMap::TotalCount() const {
  Count count = 0;
  for (const auto& entry : sample_counts_) {
    count += entry.second;
  }
  return count;
scoped_ptr<SampleCountIterator> SampleMap::Iterator() const {
  return scoped_ptr<SampleCountIterator>(new SampleMapIterator(sample_counts_));
bool SampleMap::AddSubtractImpl(SampleCountIterator* iter,
                                HistogramSamples::Operator op) 
ACEXML_INLINE
ACEXML_Parser_Context::ACEXML_Parser_Context()
  : instream_ (0),
    locator_ (0)
ACEXML_INLINE
ACEXML_Parser_Context::ACEXML_Parser_Context (ACEXML_InputSource* instream,
                                              ACEXML_LocatorImpl* locator)
  : instream_ (instream),
    locator_ (locator)
ACEXML_INLINE
ACEXML_Parser_Context::ACEXML_Parser_Context (const ACEXML_Parser_Context& src)
  : instream_ (src.instream_),
    locator_ (src.locator_)
ACEXML_INLINE bool
ACEXML_Parser_Context::operator!= (const ACEXML_Parser_Context& src)
  return (this->instream_ != src.instream_ && this->locator_ != src.locator_);
ACEXML_INLINE ACEXML_Parser_Context&
ACEXML_Parser_Context::operator= (const ACEXML_Parser_Context& src)
  ACEXML_Parser_Context tmp (src);
  std::swap (this->instream_, tmp.instream_);
  std::swap (this->locator_, tmp.locator_);
  return *this;
ACEXML_INLINE ACEXML_InputSource*
ACEXML_Parser_Context::getInputSource (void)
  return this->instream_;
ACEXML_INLINE ACEX
/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   Steve Plimpton, sjplimp@sandia.gov
   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.
   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------
   Contributing author:  Axel Kohlmeyer (Temple U)
------------------------------------------------------------------------- */
using namespace LAMMPS_NS;
/* ---------------------------------------------------------------------- */
void WriteDump::command(int narg, char **arg)
  if (narg < 3) error->all(FLERR,"Illegal write_dump command");
  int modindex;
 
/*
** $Id: ldump.cpp,v 1.1 2009-10-17 00:11:44 sbirmanns Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConsta

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
namespace blink {
namespace {
void dumpMemoryTotals(blink::WebProcessMemoryDump* memoryDump)
    String dumpName = String::format("blink_gc");
    WebMemoryAllocatorDump* allocatorDump = memoryDump->createMemoryAllocatorDump(dumpName);
    allocatorDump->addScalar("size", "bytes", Heap::allocatedSpace());
    dumpName.append("/allocated_objects");
    WebMemoryAllocatorDump* objectsDump = memoryDump->createMemoryAllocatorDump(dumpName);
    objectsDump->addScalar("size", "bytes", Heap::allocatedObjectSize() + Heap::markedObjectSize());
BlinkGCMemoryDumpProvider* BlinkGCMemoryDumpProvider::instance()
    DEFINE_STATIC_LOCAL(BlinkGCMemoryDumpProvider, instance, ());
    return &instance;
BlinkGCMemoryDumpProvider::~BlinkGCMemoryDumpProvider()
bool BlinkGCMemoryDumpProvider::onMemoryDump(WebMemoryDumpLevelOfDetail levelOfDetail, blink::WebProcessMemoryDump* memoryDump)
    if (levelOfDetail == WebMemoryDumpLevelOfDetail::Light) {
        dumpMemoryTotals(memoryDump);
        return true;

/*
	Cocoon - A GUI for Git.
	Copyright (C) 2009  Riyad Preukschas <riyad@informatik.uni-bremen.de>
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	You should have received a copy of the GNU General Public License
*/
class RepoStatusCachingTest : public GitTestBase
	Q_OBJECT
	private slots:
		void initTestCase() {
			GitTestBase::initTestCase();
			cloneFrom("RepoStatusCachingTestRepo");
		}
		void testStatusCachingSame() {
			QVERIFY(repo->d->commits.isEmpty());
			Git::Status *status1 = repo->status();
			QCOMPARE(status1->files().size(), 1);
			QVERIFY(repo
using namespace std;
World::World() {
	chunks = vector<Chunk>(1, Chunk(0, 0));
World::~World() {
bool World::newChunk(int x, int y) {
	if (getChunkIndex(x, y) == -1) {
		chunks.push_back(Chunk(x, y));
		return true;
	}
	return false;
Material World::get(int x, int y) {
	int subChunkX, subChunkY, chunkX, chunkY;
	if (x < chunkWidth && x > -chunkWidth) {
		subChunkX = x % chunkWidth;
	} else {
		subChunkX = x;
	}
	if (y < chunkHeight && y > -chunkHeight) {
		subChunkY = y % chunkHeight;
	} else {
		subChunkY = y;
	}
	chunkX = (x - subChunkX) / chunkWidth;
	chunkY = (y - subChunkY) / chunkHeight;
	if (getChunkIndex(chunkX , chunkY) != -1) {
		return chunks[getChunkIndex(chunkX , chunkY)].terrain[subChunkX][subChunkY];
	} else {
		return (Material) -1;
	}
int* World::getAbsCoords(int chunkIndex, int x, int y) {
	int absCoords[2];
	int chunkX = chunks[chunkIndex].xpos;
	int chunkY = chunks[chunkIndex].ypos;
	absCoords[0] = (chunkX * chunkWidth) + x;
	absCoords[1] = (chunkY * chunkHeight) + 

	int* coordsToReturn = absCoords;
	return coordsToReturn;
int* World::getChunkCoords(int x, int y) {
	int chunkCoords[3];
	int subChunkX = x % chunkWidth;
	int subChunkY = y % chunkHeight;
	int chunkX = x - subChunkX;
	int chunkY = y - subChunkY;
	chunkCoords[0] = getChunkIndex(chunkX, chunkY);
	chunkCoords[1] = subChunkX;
	chunkCoords[2] = subChunkY;
	int* coordsToReturn = chunkCoords;
	return coordsToReturn;
Chunk World::getChunkByIndex(int index) {
	return chunks.at(index);
int World::numOfChunks() {
	return chunks.size();
int World::getChunkIndex(int x, int y) {
	for (vector<Chunk>::size_type i = 0; i != chunks.size(); i++) {
		if (chunks[i].xpos == x && chunks[i].ypos == y) {
			return i;
		}
	}
	return -1;
int World::chunkIndexAbove(int chunkIndex) {
	for (vector<Chunk>::size_type i = 0; i != chunks.size(); i++) {
		if (chunks[chunkIndex].xpos == chunks[i].xpos && chunks[chunkIndex].ypos == chunks[i].ypos - 1) {
			return i;
		}
	}
	return - 1;
int World::chunkIndexBelow(int chu
namespace blink {
namespace {
void dumpMemoryTotals(blink::WebProcessMemoryDump* memoryDump)
    String dumpName = String::format("blink_gc");
    WebMemoryAllocatorDump* allocatorDump = memoryDump->createMemoryAllocatorDump(dumpName);
    allocatorDump->AddScalar("size", "bytes", Heap::allocatedSpace());
    dumpName.append("/allocated_objects");
    WebMemoryAllocatorDump* objectsDump = memoryDump->createMemoryAllocatorDump(dumpName);
    objectsDump->AddScalar("size", "bytes", Heap::allocatedObjectSize() + Heap::markedObjectSize());
BlinkGCMemoryDumpProvider* BlinkGCMemoryDumpProvider::instance()
    DEFINE_STATIC_LOCAL(BlinkGCMemoryDumpProvider, instance, ());
    return &instance;
BlinkGCMemoryDumpProvider::~BlinkGCMemoryDumpProvider()
bool BlinkGCMemoryDumpProvider::onMemoryDump(WebMemoryDumpLevelOfDetail levelOfDetail, blink::WebProcessMemoryDump* memoryDump)
    if (levelOfDetail == WebMemoryDumpLevelOfDetail::Low) {
        dumpMemoryTotals(memoryDump);
        return true;
  
namespace alib
	/* Private Functions */
	void JsonStreamWriter::writeObjectHeader(const char* name)
	{
		if (_itemWritten)
			writeSeperator();
		_stream.write("\""); _stream.write(name); _stream.write("\"");
		_stream.write(":");
	}
	void JsonStreamWriter::writeSeperator() { _stream.write(','); }
	/*********************/
	/* Public Functions */
		/* Constructors */
	JsonStreamWriter::JsonStreamWriter(Stream& stream) :_stream(stream) {}
		/****************/
		/* Functions */
	void JsonStreamWriter::begin()
	{
		_stream.write("{");
		_itemWritten = false;
	}
	void JsonStreamWriter::end() { _stream.write("}"); }
	void JsonStreamWriter::writeObject(const char* name, const char* value)
	{
		if (!name)return;
		writeObjectHeader(name);
		_stream.write("\"");
		if (value)
			_stream.write(value);
		_stream.write("\"");
		_itemWritten = true;
	}
	void JsonStreamWriter::writeObject(const char* name, int value)
	{
		if (!name)return;
		writeObjectHeader(name);
		_stream.write("\"");
		_stream.w
namespace base {
typedef HistogramBase::Count Count;
typedef HistogramBase::Sample Sample;
SampleMap::SampleMap() {}
SampleMap::~SampleMap() {}
void SampleMap::Accumulate(Sample value, Count count) {
  sample_counts_[value] += count;
  IncreaseSum(count * value);
  IncreaseRedundantCount(count);
Count SampleMap::GetCount(Sample value) const {
  std::map<Sample, Count>::const_iterator it = sample_counts_.find(value);
  if (it == sample_counts_.end())
    return 0;
  return it->second;
Count SampleMap::TotalCount() const {
  Count count = 0;
  for (const auto& entry : sample_counts_) {
    count += entry.second;
  }
  return count;
scoped_ptr<SampleCountIterator> SampleMap::Iterator() const {
  return scoped_ptr<SampleCountIterator>(new SampleMapIterator(sample_counts_));
bool SampleMap::AddSubtractImpl(SampleCountIterator* iter,
                                HistogramSamples::Operator op) {
  Sample min;
  Sample max;
  Count count;
  for (; !iter->Done(); iter->Next()) {
    iter->Ge
/*
				Copyright <SWGEmu>
		See file COPYING for copying conditions.*/
PetTrainingConversationObserverImplementation::PetTrainingConversationObserverImplementation(uint32 convoTemplateCRC) :
	ConversationObserverImplementation(convoTemplateCRC) {
	registerScreenHandler(PetTrainingScreenHandler::STARTSCREENHANDLERID, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETATTACKCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETCLEARPOINTSCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETCOMMANDREPAIR, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFOLLOWCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFOLLOWOTHERCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFORMATION1COMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFORMATION2COMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFRIENDC
void GameWorld::draw(RenderTarget& target, RenderStates states) const
	for (auto chunk : Chunks)
	{
		target.draw(*chunk);
	}
	target.draw(*DebugDraw::GetInstance());
	DebugDraw::GetInstance()->clearArray();
void GameWorld::update(float DeltaTime)
	for (auto object : GameObjects)
	{
		object->update(DeltaTime);
	}
void GameWorld::createChunks(int sizex, int sizey)
	leftChunk = 0;
	topChunk = 0;
	botChunk = sizey-1;
	rightChunk = sizex - 1;
	for (int i = 0; i < sizex; i++)
	{
		for (int j = 0; j < sizey; j++)
		{
			Chunk *newChunk = new Chunk();			
			newChunk->load(i, j, true);
			Chunks.push_back(newChunk);
		}
	}
	TerrainCenter.x =( sizex*ChunkSize*TileSize)/2 ;
	TerrainCenter.y = (sizey*ChunkSize*TileSize) / 2;
Chunk* GameWorld::getChunk(Vector2f position)const
	Chunk * chosenchunk = nullptr;
	for (auto chunk : Chunks)
	{
		if (chunk->Top() < position.y && chunk->Bottom() > position.y)
		{
			if (chunk->Left() < position.x && chunk->Right() > position.x)
			{
				chosenchunk = chun

				return chosenchunk;
				break;
			}
		}
	}
	return chosenchunk;
Chunk* GameWorld::getChunkFromCoords(int x, int y)const
	Chunk * chosenchunk = nullptr;
	Vector2f position;
	position.x = x*ChunkSize*TileSize + 5;
	position.y = y*ChunkSize*TileSize + 5;
	chosenchunk = getChunk(position);
	return chosenchunk;
bool GameWorld::saveChunks()
	for (auto chunk : Chunks)
	{
		chunk->save();
	}
	return true;
void GameWorld::checkChunkBounds(Vector2f topleft, Vector2f botright)
	float left = leftChunk * TileSize*ChunkSize;
	float right = rightChunk + 1 * TileSize*ChunkSize;
	float bot = botChunk * TileSize*ChunkSize;
	float top = topChunk * TileSize*ChunkSize;
	Chunk * thechunk = nullptr;
	if (topleft.x < TerrainCenter.x - 2*TileSize*ChunkSize)
	{
		bool moved = false;
		for (int i = topChunk; i <= botChunk; i++)
		{
			thechunk = getChunkFromCoords(rightChunk, i);
			if (thechunk)
			{
				thechunk->save();
				thechunk->clear();
				thechunk->load(leftChunk - 1, i, true);
				moved = true;

template <typename R, typename T1, typename T2>
struct GenericInterfaceFuncInvoker2
	typedef R (*Func)(void*, T1, T2, const MethodInfo*);
	static inline R Invoke (const MethodInfo* method, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetGenericInterfaceInvokeData (method, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3>
struct GenericInterfaceActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (const MethodInfo* method, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetGenericInterfaceInvokeData (method, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct GenericInterfaceActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, c
/*=========================================================================
  Library   : Image Registration Toolkit (IRTK)
  Module    : $Id$
  Copyright : Imperial College, Department of Computing
              Visual Information Processing (VIP), 2008 onwards
  Date      : $Date$
  Version   : $Revision$
  Changes   : $Author$
Copyright (c) IXICO LIMITED
All rights reserved.
See COPYRIGHT for details
=========================================================================*/
irtkLocator::irtkLocator()
  cell = vtkGenericCell::New();
int irtkLocator::FindClosestPoint(double *xyz)
  if (loc_type == 0) {
    cell_locator->FindClosestPoint(xyz, &closestPoint[0], cell, (vtkIdType&) cellId, subId,
                                   dist2);
    xyz[0] = closestPoint[0];
    xyz[1] = closestPoint[1];
    xyz[2] = closestPoint[2];
    return cellId;
  } else if (loc_type == 1) {
    temp_id = point_locator->FindClosestPoint(xyz);
    _dataset->GetPoint(temp_id, xyz);
    return temp_id;
  } 

    temp_id = kd_locator->FindClosestPoint(xyz);
    _dataset->GetPoint(temp_id, xyz);
    return temp_id;
  } else {
    return 0;
  }
void irtkLocator::SelectLocatorType(int type)
  if (type==0) {
    cell_locator = vtkCellLocator::New();
    cell_locator->CacheCellBoundsOn();
    cell_locator->SetNumberOfCellsPerBucket(5);
    loc_type=0;
  } else if (type==1) {
    point_locator = vtkPointLocator::New();
    point_locator->SetNumberOfPointsPerBucket(5);
    loc_type=1;
  } else if (type==2) {
    kd_locator = vtkKDTreePointLocator::New();
    kd_locator = vtkKDTreePointLocator::New();
    kd_locator->SetNumberOfPointsPerBucket(50);
    loc_type=2;
  } else {
    cerr << "Unkown locator" << endl;
    exit(1);
  }
void irtkLocator::SetElementsPerBucket(int elements)
  if (loc_type == 0) {
    cell_locator->SetNumberOfCellsPerBucket(elements);
  }
  if (loc_type == 1) {
    point_locator->SetNumberOfPointsPerBucket(elements);
  }
  if (loc_type == 2) {
    kd_locator->SetNumberOfPoin
namespace bard {
namespace {
struct StackTrace {
  void* frames[8];
};
template <uint32_t kInvokeValue>
using InvokeHelper =
    detail::InvokeFunctionWithStackIdHelper<kInvokeValue,
                                            bool(bool, StackTrace*),
                                            bool,
                                            bool,
                                            StackTrace*>;
bool ParrotImpl(bool input, StackTrace* stack_trace) {
  CaptureStackBackTrace(1, arraysize(stack_trace->frames), stack_trace->frames,
                        nullptr);
  return input;
bool Dummy(bool input, StackTrace* stack_trace) {
  return false;
bool Parrot(uint32_t stack_id, bool input, StackTrace* stack_trace) {
  return InvokeFunctionWithStackId(stack_id, ParrotImpl, input, stack_trace);
template <uint32_t kInvokeValue>
struct GetInvokeFunctionExtents {
  static void Do(void const** invoke_helper_begins,
                 void const** invoke_helper_ends) {
    InvokeHelper<kIn

                                   false, nullptr);
    invoke_helper_begins[kInvokeValue] = detail::kInvokeFunctionBegin;
    invoke_helper_ends[kInvokeValue] = detail::kInvokeFunctionEnd;
  }
};
TEST(InvokeFunctionWithStackIdTest, ExpectedStackId) {
  void const* invoke_helper_begins[16] = {};
  void const* invoke_helper_ends[16] = {};
  GetInvokeFunctionExtents<0x0>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x1>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x2>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x3>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x4>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x5>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x6>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<0x7>::Do(invoke_helper_begins, invoke_helper_ends);
  GetInvokeFunctionExtents<
/*
 * InvocationWrapper.cpp
 *
 *  Created on: May 6, 2013
 *      Author: Bakhshi
 */
InvocationWrapper::InvocationWrapper(QObject* parent) :
		QObject(parent) {
QString InvocationWrapper::mimeType() const {
	return mInvokeRequest.mimeType();
void InvocationWrapper::setMimeType(const QString& mimeType) {
	if (mimeType != mInvokeRequest.mimeType()) {
		mInvokeRequest.setMimeType(mimeType);
		emit mimeTypeChanged(mimeType);
	}
QUrl InvocationWrapper::uri() const {
	return mInvokeRequest.uri();
void InvocationWrapper::setUri(const QUrl& uri) {
	if (uri != mInvokeRequest.uri()) {
		mInvokeRequest.setUri(uri);
		emit uriChanged(uri);
	}
QString InvocationWrapper::invokeActionId() const {
	return mInvokeRequest.action();
void InvocationWrapper::setInvokeActionId(const QString& actionId) {
	if (actionId != mInvokeRequest.action()) {
		mInvokeRequest.setAction(actionId);
		emit invokeActionIdChanged(actionId);
	}
QString InvocationWrapper::invokeTargetId() const {
	return mInvokeRequest.targe
/* 
 * Triplane Classic - a side-scrolling dogfighting game.
 * Copyright (C) 1996,1997,2009  Dodekaedron Software Creations Oy
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 *
 * tjt@users.sourceforge.net
 */
sb_mod_file *triplane_mod;
sb_mod_file *aces_mod;
sb_sample *sample_itexp[3];
sb_sample *sample_bomb[4];
sb_sample *sample_hitti;
sb_sample *sample_konsu[4];
sb_sample *sample_propelli;
sb_sample *sample_hit[4];
sb_sample *sample_aagun;
sb_sample *sample_spla

sb_sample *sample_spcrash;
sb_sample *sample_hurr;
sb_sample *sample_itshot;
sb_sample *sample_crash[2];
sb_sample *sample_alku;
sb_sample *sample_die[9];
int alku_sample_over = 0;
int sfx_loaded = 0;
int music_loaded = 0;
void kkbase_sound(int type, int kkbase_x) {
    if (config.ground_i_sounds && config.sound_on && config.sfx_on) {
        if (type)
            play_2d_sample(sample_itshot, player_x_8[solo_country], kkbase_x);
        else
            play_2d_sample(sample_aagun, player_x_8[solo_country], kkbase_x);
    }
void itgun_sound(int itgun_x) {
    if (config.ground_i_sounds && config.sound_on && config.sfx_on) {
        play_2d_sample(sample_itexp[wrandom(3)], player_x_8[solo_country], itgun_x);
    }
void load_all_samples(void) {
    int l;
    sample_itexp[0] = sample_load("Itexp1");
    sample_itexp[0]->left_volume = SAMPLE_VOLUME;
    sample_itexp[0]->right_volume = SAMPLE_VOLUME;
    sample_itexp[1] = sample_load("Itexp2");
    sample_itexp[1]->left_volume = SAMPLE_V

    sample_itexp[1]->right_volume = SAMPLE_VOLUME;
    sample_itexp[2] = sample_load("Itexp3");
    sample_itexp[2]->left_volume = SAMPLE_VOLUME;
    sample_itexp[2]->right_volume = SAMPLE_VOLUME;
    sample_bomb[1] = sample_load("Bomb1");
    sample_bomb[1]->left_volume = SAMPLE_VOLUME;
    sample_bomb[1]->right_volume = SAMPLE_VOLUME;
    sample_bomb[2] = sample_load("Bomb2");
    sample_bomb[2]->left_volume = SAMPLE_VOLUME;
    sample_bomb[2]->right_volume = SAMPLE_VOLUME;
    sample_bomb[3] = sample_load("Bomb3");
    sample_bomb[3]->left_volume = SAMPLE_VOLUME;
    sample_bomb[3]->right_volume = SAMPLE_VOLUME;
    sample_konsu[1] = sample_load("Guns1");
    sample_konsu[1]->left_volume = SAMPLE_VOLUME;
    sample_konsu[1]->right_volume = SAMPLE_VOLUME;
    sample_konsu[2] = sample_load("Guns2");
    sample_konsu[2]->left_volume = SAMPLE_VOLUME;
    sample_konsu[2]->right_volume = SAMPLE_VOLUME;
    sample_konsu[3] = sample_load("Guns3");
    sample_konsu[3]->left_volume = SAMPLE_

    sample_konsu[3]->right_volume = SAMPLE_VOLUME;
    sample_hit[0] = sample_load("Hit1");
    sample_hit[0]->left_volume = SAMPLE_VOLUME;
    sample_hit[0]->right_volume = SAMPLE_VOLUME;
    sample_hit[1] = sample_load("Hit2");
    sample_hit[1]->left_volume = SAMPLE_VOLUME;
    sample_hit[1]->right_volume = SAMPLE_VOLUME;
    sample_hit[2] = sample_load("Hit3");
    sample_hit[2]->left_volume = SAMPLE_VOLUME;
    sample_hit[2]->right_volume = SAMPLE_VOLUME;
    sample_hit[3] = sample_load("Hit4");
    sample_hit[3]->left_volume = SAMPLE_VOLUME;
    sample_hit[3]->right_volume = SAMPLE_VOLUME;
    sample_aagun = sample_load("Aagun");
    sample_aagun->left_volume = SAMPLE_VOLUME;
    sample_aagun->right_volume = SAMPLE_VOLUME;
    sample_splash[0] = sample_load("Spla1");
    sample_splash[0]->left_volume = SAMPLE_VOLUME;
    sample_splash[0]->right_volume = SAMPLE_VOLUME;
    sample_splash[1] = sample_load("Spla2");
    sample_splash[1]->left_volume = SAMPLE_VOLUME;
    sample_splas

    sample_splash[2] = sample_load("Spla3");
    sample_splash[2]->left_volume = SAMPLE_VOLUME;
    sample_splash[2]->right_volume = SAMPLE_VOLUME;
    sample_hurr = sample_load("Hurr");
    sample_hurr->left_volume = SAMPLE_VOLUME;
    sample_hurr->right_volume = SAMPLE_VOLUME;
    sample_itshot = sample_load("Itshot");
    sample_itshot->left_volume = SAMPLE_VOLUME;
    sample_itshot->right_volume = SAMPLE_VOLUME;
    sample_spcrash = sample_load("Spcra1");
    sample_spcrash->left_volume = SAMPLE_VOLUME;
    sample_spcrash->right_volume = SAMPLE_VOLUME;
    sample_crash[0] = sample_load("Crash1");
    sample_crash[0]->left_volume = SAMPLE_VOLUME;
    sample_crash[0]->right_volume = SAMPLE_VOLUME;
    sample_crash[1] = sample_load("Crash2");
    sample_crash[1]->left_volume = SAMPLE_VOLUME;
    sample_crash[1]->right_volume = SAMPLE_VOLUME;
    sample_alku = sample_load("Alku");
    sample_alku->left_volume = 32;
    sample_alku->right_volume = 32;
    sample_die[0] = sample_load("D

    sample_die[1] = sample_load("Die2");
    sample_die[2] = sample_load("Die3");
    sample_die[3] = sample_load("Die4");
    sample_die[4] = sample_load("Die5");
    sample_die[5] = sample_load("Die6");
    sample_die[6] = sample_load("Die7");
    sample_die[7] = sample_load("Die8");
    sample_die[8] = sample_load("Die9");
    for (l = 0; l < 9; l++) {
        sample_die[l]->left_volume = SAMPLE_VOLUME - 8;
        sample_die[l]->right_volume = SAMPLE_VOLUME - 8;
    }
void load_sfx(void) {
    sfx_loaded = 1;
    load_all_samples();
void load_music(void) {
    music_loaded = 1;
    triplane_mod = sdl_load_mod_file("music1");
    aces_mod = sdl_load_mod_file("maces");
void clear_sfx(void) {
    int l;
    sfx_loaded = 0;
    sdl_free_sample(sample_itexp[0]);
    sdl_free_sample(sample_itexp[1]);
    sdl_free_sample(sample_itexp[2]);
    sdl_free_sample(sample_bomb[1]);
    sdl_free_sample(sample_bomb[2]);
    sdl_free_sample(sample_bomb[3]);
    sdl_free_sample(sample_konsu[1]);
  
namespace Attr
    DefineFloat4(ModelPos, 'mpos', ReadWrite);
    DefineInt(ModelInt, 'mint', ReadWrite);
    DefineBool(ModelBool, 'mbol', ReadWrite);
    DefineString(ModelString, 'mstr', ReadWrite);
    DefineInt(ModelNodeInt, 'mnin', ReadWrite);
    DefineString(ModelNodeString, 'mnst', ReadWrite);
namespace Test
ImplementClass(Test::ModelLoadSaveTest, 'MLST', Test::TestCase);
using namespace Models;
using namespace IO;
/**
*/
void
ModelLoadSaveTest::TestModel(const Ptr<Model>& model)
/*
    FIXME
    this->Verify(model.isvalid());
    this->Verify(model->Attributes().Contains(Attr::ModelPos));
    this->Verify(model->Attributes().Contains(Attr::ModelInt));
    this->Verify(model->Attributes().Contains(Attr::ModelBool));
    this->Verify(model->Attributes().Contains(Attr::ModelString));
    this->Verify(model->Attributes().GetVector3(Attr::ModelPos) == Math::vector3(1.0f, 2.0f, 3.0f));
    this->Verify(model->Attributes().GetInt(Attr::ModelInt) == 23);
    this->Verify(model->Attri

    this->Verify(model->Attributes().GetString(Attr::ModelString) == "Bla Bla");
    this->Verify(model->GetNodes().Size() == 3);
    this->Verify(model->HasNode("Node0"));
    this->Verify(model->HasNode("Node1"));
    this->Verify(model->HasNode("Node2"));
    const Ptr<ModelNode>& node0 = model->LookupNode("Node0");
    const Ptr<ModelNode>& node1 = model->LookupNode("Node1");
    const Ptr<ModelNode>& node2 = model->LookupNode("Node2");
    this->Verify(node0->GetName() == "Node0");
    this->Verify(!node0->HasParent());
    this->Verify(node0->IsAttachedToModel());
    this->Verify(node0->GetModel() == model);
    this->Verify(node0->GetChildren().Size() == 1);
    this->Verify(node0->GetChildren()[0] == node1);
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node0->Attributes().GetInt(Attr::ModelNodeInt) == 24);
    this->Verify(node0->Attributes().GetString(Attr::ModelNod

    this->Verify(node1->GetName() == "Node1");
    this->Verify(node1->HasParent());
    this->Verify(node1->GetParent() == node0);
    this->Verify(node1->IsAttachedToModel());
    this->Verify(node1->GetModel() == model);
    this->Verify(node1->GetChildren().Size() == 0);
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node1->Attributes().GetInt(Attr::ModelNodeInt) == 25);
    this->Verify(node1->Attributes().GetString(Attr::ModelNodeString) == "Blob");
    this->Verify(node2->GetName() == "Node2");
    this->Verify(!node2->HasParent());
    this->Verify(node2->IsAttachedToModel());
    this->Verify(node2->GetModel() == model);
    this->Verify(node2->GetChildren().Size() == 0);
    this->Verify(node2->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node2->Attributes().GetString(Attr::ModelNodeString) == "Blah");
*/
/**
*/
void
ModelLoadSaveTest::TestPartialMo

/*
    FIXME
    this->Verify(model.isvalid());
    this->Verify(model->Attributes().Contains(Attr::ModelPos));
    this->Verify(model->Attributes().Contains(Attr::ModelInt));
    this->Verify(model->Attributes().Contains(Attr::ModelBool));
    this->Verify(model->Attributes().Contains(Attr::ModelString));
    this->Verify(model->Attributes().GetVector3(Attr::ModelPos) == Math::vector3(1.0f, 2.0f, 3.0f));
    this->Verify(model->Attributes().GetInt(Attr::ModelInt) == 23);
    this->Verify(model->Attributes().GetBool(Attr::ModelBool) == true);
    this->Verify(model->Attributes().GetString(Attr::ModelString) == "Bla Bla");
    this->Verify(model->GetNodes().Size() == 2);
    this->Verify(model->HasNode("Node0"));
    this->Verify(model->HasNode("Node1"));
    const Ptr<ModelNode>& node0 = model->LookupNode("Node0");
    const Ptr<ModelNode>& node1 = model->LookupNode("Node1");
    this->Verify(node0->GetName() == "Node0");
    this->Verify(!node0->HasParent());
    this->Verify(node0->

    this->Verify(node0->GetModel() == model);
    this->Verify(node0->GetChildren().Size() == 1);
    this->Verify(node0->GetChildren()[0] == node1);
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node0->Attributes().GetInt(Attr::ModelNodeInt) == 24);
    this->Verify(node0->Attributes().GetString(Attr::ModelNodeString) == "Blub Blub");
    this->Verify(node1->GetName() == "Node1");
    this->Verify(node1->HasParent());
    this->Verify(node1->GetParent() == node0);
    this->Verify(node1->IsAttachedToModel());
    this->Verify(node1->GetModel() == model);
    this->Verify(node1->GetChildren().Size() == 0);
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node1->Attributes().GetInt(Attr::ModelNodeInt) == 25);
    this->Verify(node1->Attributes().GetString(Attr::ModelNodeSt

*/
/**
*/
void
ModelLoadSaveTest::Run()
/*
    FIXME
    Ptr<IO::Server> ioServer = IO::Server::Create();
    ioServer->RegisterUriScheme("file", IO::FileStream::RTTI);
    Ptr<ModelServer> modelServer = ModelServer::Create();
    const URI srcFile = "home:work/testdata/modelloadsavetest.xml";
    const URI xmlDestFile = "home:intermediate/testdata/modelloadsavetest.xml";
    const URI binDestFile = "home:intermediate/testdata/modelloadsavetest.n3";
    if (ioServer->FileExists(xmlDestFile))
    {
        ioServer->DeleteFile(xmlDestFile);
        this->Verify(!ioServer->FileExists(xmlDestFile));
    }
    if (ioServer->FileExists(binDestFile))
    {
        ioServer->DeleteFile(binDestFile);
        this->Verify(!ioServer->FileExists(binDestFile));
    }
    
    bool modelLoaded = modelServer->LoadModels(srcFile);
    this->Verify(modelLoaded);
    if (modelLoaded)
    {
        this->Verify(modelServer->HasModel("ModelLoadSaveTest"));
        Ptr<Model> model = modelServer->LookupM

        this->Verify(model->GetName() == "ModelLoadSaveTest");
        this->TestModel(model);
        
        bool xmlModelSaved = modelServer->SaveModel(model, xmlDestFile, XmlModelWriter::RTTI);
        this->Verify(xmlModelSaved);
        this->Verify(ioServer->FileExists(xmlDestFile));
        bool binModelSaved = modelServer->SaveModel(model, binDestFile, BinaryModelWriter::RTTI);
        this->Verify(binModelSaved);
        this->Verify(ioServer->FileExists(binDestFile));
        modelServer->DiscardModel("ModelLoadSaveTest");
        this->Verify(!modelServer->HasModel("ModelLoadSaveTest"));
        model = 0;
        modelLoaded = modelServer->LoadModels(xmlDestFile);
        if (modelLoaded)
        {
            this->Verify(modelServer->HasModel("ModelLoadSaveTest"));
            model = modelServer->LookupModel("ModelLoadSaveTest");
            this->Verify(model->GetName() == "ModelLoadSaveTest");
            this->TestModel(model);
            modelServer->DiscardModel

            this->Verify(!modelServer->HasModel("ModelLoadSaveTest"));
            model = 0;
        }
        modelLoaded = modelServer->LoadModels(binDestFile);
        if (modelLoaded)
        {
            this->Verify(modelServer->HasModel("ModelLoadSaveTest"));
            model = modelServer->LookupModel("ModelLoadSaveTest");
            this->Verify(model->GetName() == "ModelLoadSaveTest");
            this->TestModel(model);
            modelServer->DiscardModel("ModelLoadSaveTest");
            this->Verify(!modelServer->HasModel("ModelLoadSaveTest"));
            model = 0;
        }
        modelLoaded = modelServer->LoadModels(srcFile);
        this->Verify(modelLoaded);
        model = modelServer->LookupModel("ModelLoadSaveTest");
        Ptr<Model> clone0 = modelServer->CloneModel(model, "Clone0");
        this->Verify(clone0->GetName() == "Clone0");
        this->TestModel(clone0);
        Ptr<Model> clone1 = modelServer->CloneModelFragment(model, "Node0", "Clone1");
int has_NV_path_rendering = 0;
void
initializeNVPR(const char *programName)
    LOAD_PROC(PFNGLGENPATHSNVPROC, glGenPathsNV);
    LOAD_PROC(PFNGLDELETEPATHSNVPROC, glDeletePathsNV);
    LOAD_PROC(PFNGLISPATHNVPROC, glIsPathNV);
    LOAD_PROC(PFNGLPATHCOMMANDSNVPROC, glPathCommandsNV);
    LOAD_PROC(PFNGLPATHCOORDSNVPROC, glPathCoordsNV);
    LOAD_PROC(PFNGLPATHSUBCOMMANDSNVPROC, glPathSubCommandsNV);
    LOAD_PROC(PFNGLPATHSUBCOORDSNVPROC, glPathSubCoordsNV);
    LOAD_PROC(PFNGLPATHSTRINGNVPROC, glPathStringNV);
    LOAD_PROC(PFNGLPATHGLYPHSNVPROC, glPathGlyphsNV);
    LOAD_PROC(PFNGLPATHGLYPHRANGENVPROC, glPathGlyphRangeNV);
    LOAD_PROC(PFNGLWEIGHTPATHSNVPROC, glWeightPathsNV);
    LOAD_PROC(PFNGLCOPYPATHNVPROC, glCopyPathNV);
    LOAD_PROC(PFNGLINTERPOLATEPATHSNVPROC, glInterpolatePathsNV);
    LOAD_PROC(PFNGLTRANSFORMPATHNVPROC, glTransformPathNV);
    LOAD_PROC(PFNGLPATHPARAMETERIVNVPROC, glPathParameterivNV);
    LOAD_PROC(PFNGLPATHPARAMETERINVPROC, glPathParameteriNV);
    LOAD

    LOAD_PROC(PFNGLPATHPARAMETERFNVPROC, glPathParameterfNV);
    LOAD_PROC(PFNGLPATHDASHARRAYNVPROC, glPathDashArrayNV);
    LOAD_PROC(PFNGLSTENCILFILLPATHNVPROC, glStencilFillPathNV);
    LOAD_PROC(PFNGLSTENCILSTROKEPATHNVPROC, glStencilStrokePathNV);
    LOAD_PROC(PFNGLSTENCILFILLPATHINSTANCEDNVPROC, glStencilFillPathInstancedNV);
    LOAD_PROC(PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC, glStencilStrokePathInstancedNV);
    LOAD_PROC(PFNGLPATHCOLORGENNVPROC, glPathColorGenNV);
    LOAD_PROC(PFNGLPATHTEXGENNVPROC, glPathTexGenNV);
    LOAD_PROC(PFNGLPATHFOGGENNVPROC, glPathFogGenNV);
    LOAD_PROC(PFNGLCOVERFILLPATHNVPROC, glCoverFillPathNV);
    LOAD_PROC(PFNGLCOVERSTROKEPATHNVPROC, glCoverStrokePathNV);
    LOAD_PROC(PFNGLCOVERFILLPATHINSTANCEDNVPROC, glCoverFillPathInstancedNV);
    LOAD_PROC(PFNGLCOVERSTROKEPATHINSTANCEDNVPROC, glCoverStrokePathInstancedNV);
    LOAD_PROC(PFNGLGETPATHPARAMETERIVNVPROC, glGetPathParameterivNV);
    LOAD_PROC(PFNGLGETPATHPARAMETERFVNVPROC, glGetPathPar

    LOAD_PROC(PFNGLGETPATHCOMMANDSNVPROC, glGetPathCommandsNV);
    LOAD_PROC(PFNGLGETPATHCOORDSNVPROC, glGetPathCoordsNV);
    LOAD_PROC(PFNGLGETPATHDASHARRAYNVPROC, glGetPathDashArrayNV);
    LOAD_PROC(PFNGLGETPATHMETRICSNVPROC, glGetPathMetricsNV);
    LOAD_PROC(PFNGLGETPATHMETRICRANGENVPROC, glGetPathMetricRangeNV);
    LOAD_PROC(PFNGLGETPATHSPACINGNVPROC, glGetPathSpacingNV);
    LOAD_PROC(PFNGLGETPATHCOLORGENIVNVPROC, glGetPathColorGenivNV);
    LOAD_PROC(PFNGLGETPATHCOLORGENFVNVPROC, glGetPathColorGenfvNV);
    LOAD_PROC(PFNGLGETPATHTEXGENIVNVPROC, glGetPathTexGenivNV);
    LOAD_PROC(PFNGLGETPATHTEXGENFVNVPROC, glGetPathTexGenfvNV);
    LOAD_PROC(PFNGLISPOINTINFILLPATHNVPROC, glIsPointInFillPathNV);
    LOAD_PROC(PFNGLISPOINTINSTROKEPATHNVPROC, glIsPointInStrokePathNV);
    LOAD_PROC(PFNGLGETPATHLENGTHNVPROC, glGetPathLengthNV);
    LOAD_PROC(PFNGLPOINTALONGPATHNVPROC, glPointAlongPathNV);
    LOAD_PROC(PFNGLPATHSTENCILFUNCNVPROC, glPathStencilFuncNV);
    LOAD_PROC(PFNGLPATHST
namespace Dynamo {
    
    IPaint *CreateIPaint( const Useless::WidgetPainter & );
    struct CXmlChunk: IXmlChunk, CInterface
    {
        XMLProgram::IChunkPtr _pChunk;
        CXmlChunk( XMLProgram::IChunk *pChunk ): _pChunk( pChunk )
        {
        }
        ~CXmlChunk()
        {
        }
        bool GetAttr( const std::string &name, int *pInt )
        {
            TextAnsi wname( name );
            XMLFactory::Attr< int, false, wchar_t > attr( wname );
            if ( (*_pChunk) >> attr && 0 != pInt )
            {
                (*pInt) = *attr;
                return true;
            }
            else
            {
                return false;
            }
        }
        bool GetAttr( const std::string &name, double *pFloat )
        {
            TextAnsi wname( name );
            XMLFactory::Attr< double, false, wchar_t > attr( wname );
            if ( (*_pChunk) >> attr && 0 != pFloat )
            {
                (*pFloat) = *attr;
                ret

            }
            else
            {
                return false;
            }
        }
        bool GetAttr( const std::string &name, std::basic_string< wchar_t > *pText )
        {
            TextAnsi wname( name );
            XMLFactory::Attr< TextUtf8, false, wchar_t > attr( wname );
            if ( (*_pChunk) >> attr && 0 != pText )
            {
                (*pText) = TextUtf8( attr.str() );
                return true;
            }
            else
            {
                return false;
            }
        }
        
        int AsInt()
        {
            return XMLProgram::value_of< int >( _pChunk.get() );
        }
        
        float AsFloat()
        {
            return XMLProgram::value_of< float >( _pChunk.get() );
        }
        
        IPaint * AsIPaint()
        {
            if ( XMLProgram::WidgetPainterProxy *proxy = dynamic_cast< XMLProgram::WidgetPainterProxy *>( _pChunk.get() ))
            {
                return CreateIPain

            }
            else
            {
                return NULL;
            }
        }
        
        std::basic_string< wchar_t > AsText()
        {
            return XMLProgram::value_of< TextUtf8 >( _pChunk.get() );
        }
        IXmlChunk* GetChunk( const std::string &name )
        {
            if ( XMLProgram::IChunk *pChunk = _pChunk->GetChunk( TextAnsi( name )))
            {
                return new CXmlChunk( pChunk );
            }
            else
            {
                return 0;
            }
        }
        
        IXmlChunk*  GetChunk( unsigned int code )
        {
            if ( XMLProgram::IChunk *pChunk = _pChunk->GetChunk( code ))
            {
                return new CXmlChunk( pChunk );
            }
            else
            {
                return 0;
            }
        }
        void SetChunk( const std::string &name, IXmlChunk *pChunk )
        {
            Hand< IXmlChunk > guard( pChunk );
            if ( CXmlChunk

            {
                _pChunk->SetChunk( TextAnsi( name ), pCChunk->_pChunk.get() );
            }
        }
        void Execute( IXmlScope *pScope );
        
        bool IsEmpty()
        {
            return XMLProgram::IsEmpty( _pChunk.get() );
        }
    };
    struct CXmlScope : IXmlScope, CInterface
    {
        XMLProgram::ExecutionState _state;
        XMLProgram::IBlockPtr      _guardian;
        CXmlScope( XMLProgram::ExecutionState &state ): _state( state )
        {
        }
        ~CXmlScope()
        {
        }
        void SetResult( IXmlChunk *pChunk )
        {
            Hand< IXmlChunk > guard( pChunk );
            if ( CXmlChunk *pCChunk = dynamic_cast< CXmlChunk *>( pChunk ))
            {
                _state.SetResult( pCChunk->_pChunk.get() );
            }
        }
        
        IXmlChunk* GetChunk( const std::string &name )
        {
            XMLProgram::IChunk *pChunk = XMLProgram::GetChunk( TextAnsi( name ), _state );
          

            {
                return new CXmlChunk( pChunk );
            }
            else
            {
                return 0;
            }
        }
        void SetChunk( const std::string &name, IXmlChunk *pChunk )
        {
            Hand< IXmlChunk > guard( pChunk );
            if ( CXmlChunk *pCChunk = dynamic_cast< CXmlChunk *>( pChunk ))
            {
                XMLProgram::IChunk *pParent = 0;
                XMLProgram::IChunk *pChunk = XMLProgram::GetChunk( TextAnsi( name ), _state, &pParent );
                if ( 0 != pParent )
                {
                    pParent->SetChunk( TextAnsi( name ), pCChunk->_pChunk.get() );
                }
            }
        }
        void AddChunk( const std::string &name, IXmlChunk *pChunk )
        {
            Hand< IXmlChunk > guard( pChunk );
            if ( CXmlChunk *pCChunk = dynamic_cast< CXmlChunk *>( pChunk ))
            {
                _state._currentBlock->AddChunk( TextAnsi( name ), pCChunk->_pCh

            }
        }
        
        void AddMethod( const std::string &name, IXmlHook *pHook );
        
        IXmlScope*  NewScope()
        {
            CXmlScope *pNewScope = new CXmlScope( _state );
            pNewScope->_guardian = pNewScope->_state._currentBlock = new XMLProgram::XMLCodeBlock;
            pNewScope->_state._prevState = &_state;
            return pNewScope;
        }
    };
    
    void CXmlChunk::Execute( IXmlScope *pScope )
    {
        Hand< IXmlScope > guard( pScope );
        if ( CXmlScope * pCScope = dynamic_cast< CXmlScope *>( pScope ))
        {
            _pChunk->Execute( XMLFactory::Node(), pCScope->_state );
        }
    }
    struct CXmlMethodHook : XMLProgram::IChunk
    {
        Hand< IXmlHook > _pHook;
        CXmlMethodHook( IXmlHook *pHook ): _pHook( pHook )
        {
        }
        ~CXmlMethodHook()
        {
            _pHook = 0;
        }
        bool Execute( XMLProgram::ExecutionState &state )
        {
            Hand

            _pHook->Apply( pScope.get() );
            return true;
        }
        bool Execute( XMLFactory::Node node, XMLProgram::ExecutionState &state )
        {
            Hand< CXmlScope > pScope = new CXmlScope( state );
            _pHook->Apply( pScope.get() );
			state.SetResult( pScope->_state.GetResult() );
            return true;
        }
    };
        
    void CXmlScope::AddMethod( const std::string &name, IXmlHook *pHook )
    {
        _state._currentBlock->AddChunk( TextAnsi( name ), new CXmlMethodHook( pHook ));
    }
    struct CXmlProgram : IXmlProgram, CInterface
    {
        XMLProgram::IFiniteStateMachine *_pFSM;
        CXmlProgram( XMLProgram::IFiniteStateMachine *pFSM ): _pFSM( pFSM )
        {
        }
        ~CXmlProgram()
        {
        }
        
        IXmlScope*  NewScope( XMLProgram::ExecutionState &state )
        {
            return new CXmlScope( state );
        }
        
        IXmlScope*  GetScope()
        {
            return 

        }
        IXmlChunk*  NewInt( int value )
        {
            return new CXmlChunk( XMLProgram::make_value_chunk( value ));
        }
        IXmlChunk*  NewFloat( double value )
        {
            return new CXmlChunk( XMLProgram::make_value_chunk( value ));
        }
        IXmlChunk*  NewText( const std::basic_string< wchar_t > &value )
        {
            return new CXmlChunk( XMLProgram::make_value_chunk( value ));
        }
        IXmlChunk*  NewList()
        {
            return new CXmlChunk( new XMLProgram::XMLEmpty() );
        }
        IXmlChunk* Append( IXmlChunk *pListChunk, IXmlChunk *pChunk )
        {
            Hand< IXmlChunk > guard1( pListChunk );
            Hand< IXmlChunk > guard2( pChunk );
            if ( pChunk->IsEmpty() )
            {
                return pListChunk;
            }
            if ( CXmlChunk *pCChunk = dynamic_cast< CXmlChunk *>( pChunk ))
            {
                if ( CXmlChunk *pCListChunk = dynamic_cast< CXmlC

                {
                    if ( pCListChunk->IsEmpty() )
                    {
                        XMLProgram::XMLListChunk *pList = new XMLProgram::XMLListChunk( pCChunk->_pChunk.get(), pCListChunk->_pChunk.get() );
                        pCListChunk->_pChunk = pList;
                        return pCListChunk;
                    }
                    else
                    {
                        XMLProgram::XMLListChunk *pList0 = dynamic_cast< XMLProgram::XMLListChunk *>( pCListChunk->_pChunk.get() );
                        if ( XMLProgram::IsEmpty( pList0->_tail.get() ))
                        {
                            XMLProgram::XMLListChunk *pList = new XMLProgram::XMLListChunk( pCChunk->_pChunk.get(), new XMLProgram::XMLEmpty() );
                            pList0->SetTail( pList );
                            return new CXmlChunk( pList );
                        }
                        else
                        {
                            t
namespace ccdsp {
struct SampleTime {
  SampleTime() {}
  SampleTime(int64 t) : time_(t) {}
  SampleTime(int32 t) : time_(t) {}
  SampleTime(int16 t) : time_(t) {}
  SampleTime(int8 t) : time_(t) {}
  SampleTime(uint64 t) : time_(t) {}
  SampleTime(uint32 t) : time_(t) {}
  SampleTime(uint16 t) : time_(t) {}
  SampleTime(uint8 t) : time_(t) {}
  SampleTime(RealTime t, SampleRate r)
      : time_(static_cast<int64>((*t) * (*r))) {
  }
  const int64 operator*() const { return time_; }
  SampleTime& operator++() { ++time_; return *this; }
  SampleTime& operator--() { --time_; return *this; }
  SampleTime operator++(int) { return time_++; }
  SampleTime operator--(int) { return time_--; }
  SampleTime& operator-=(SampleTime t) { time_ -= *t; return *this; }
  SampleTime& operator+=(SampleTime t) { time_ += *t; return *this; }
  template <typename T> SampleTime& operator*=(T t) { time_ *= t; return *this; }
  template <typename T> SampleTime& operator/=(T t) { time_ /= t; return *this; }
 p
namespace Common {
	Sample::Sample() : index(-1), label(-1), nrDims(0), dims(nullptr) {}
	Sample::Sample(const int i, const int l, const int n)
		: index(i), label(l), nrDims(n) {
		dims = allocateSampleDimsMemory(nrDims, __FILE__, __LINE__);
	}
	Sample::Sample(const int i, const int l, const int n, const SampleDim* sampleDimsArray)
		: index(i), label(l), nrDims(n) {
		dims = allocateSampleDimsMemory(nrDims, __FILE__, __LINE__);
		copySampleDims(sampleDimsArray, nrDims, dims);
	}
	Sample::~Sample() {
		freeSampleDimsMemory(dims, __FILE__, __LINE__);
	}
	Sample::Sample(const Sample& other) : index(other.index), label(other.label), nrDims(other.nrDims) {
		dims = allocateSampleDimsMemory(nrDims, __FILE__, __LINE__);
		copySampleDims(other.dims, other.nrDims, dims);
	}
	Sample& Sample::operator=(const Sample& s) {
		if (this != &s)	{
			SampleDim* newSampleDims = allocateSampleDimsMemory(s.nrDims, __FILE__, __LINE__);
			copySampleDims(s.dims, s.nrDims, newSampleDims);
			freeSampleDimsM

			index = s.index;
			label = s.label;
			nrDims = s.nrDims;
			dims = newSampleDims;
		}
		return *this;
	}
	bool Sample::operator==(const Sample& s) const {
			return false;
		}
		if (dims[0] == s.dims[0]) {
			int dimIndex = 1;
			while (dimIndex < nrDims) {
				if (dims[dimIndex] != s.dims[dimIndex])
					return false;
				dimIndex++;
			}
			return true;
		}
		return false;
	}
	bool Sample::operator!=(const Sample& s) const {
		return !operator==(s);
	}
	SampleDim& Sample::operator[](int i) { return dims[i]; }
	const SampleDim& Sample::operator[](int i) const { return dims[i]; }
	void Sample::copySampleDims(const SampleDim* src, int nrDims, SampleDim* dst) {
		size_t size = (nrDims) * sizeof(SampleDim);
		memcpy(dst, src, size);
	}
	std::ostream& operator<<(std::ostream& out, const Sample& s) {
		return out << s.dims << " " << s.index << " " << s.label << " " << s.nrDims;
	}
	void swapSamples(Sample& s1, Sample& s2) {
		Sample tempSample(s1);
		s1 = s2;
		s2 = tempSample;
	}
			
/**
 * This file is distributed under the University of Illinois Open Source
 * License. See LICENSE for details.
 *
 * \file LockUnlockPairs
 * \author Markus Kusano
 * 2013-04-01
 *
 * Finds function local std::mutex::lock and std::mutex::unlock calls. Requires
 * alias analysis information to be provided.
 */
using namespace llvm;
class LockUnlockPairs {
    public:
        struct CallCallLockPair {
            CallInst *lockCall;
            CallInst *unlockCall;
        };
        struct CallInvokeLockPair {
            CallInst *lockCall;
            InvokeInst *unlockInvoke;
        };
        struct InvokeInvokeLockPair {
            InvokeInst *lockInvoke;
            InvokeInst *unlockInvoke;
        };
        struct InvokeCallLockPair {
            InvokeInst *lockInvoke;
            CallInst *unlockCall;
        };
        void enumerate(Module &M, AliasAnalysis &AA);
        unsigned getNumPairs() const;
        unsigned getNumCallCallPairs() const;
        unsigned getNu

        unsigned getNumInvokeCallPairs() const;
        unsigned getNumInvokeInvokePairs() const;
        void printDebugInfo() const;
	int calcDistanceBetween(Instruction *inst1, Instruction *inst2) const;
        CallCallLockPair *getCallCallPair(unsigned index);
        CallInvokeLockPair *getCallInvokePair(unsigned index);
        InvokeCallLockPair *getInvokeCallPair(unsigned index);
        InvokeInvokeLockPair *getInvokeInvokePair(unsigned index);
    private:
        bool isMatch(Function *funcName);
        void findPairs(std::vector<CallInst *> &calls, std::vector<InvokeInst *> &invokes, 
                AliasAnalysis &AA);
        bool isLockUnlockPair(Function *lockFunc, Function *otherFunc, AliasAnalysis &AA, Value *mut1, Value *mut2);
        bool isLockUnlockPair(CallInst *lockCall, CallInst *otherCall, AliasAnalysis &AA);
        bool isLockUnlockPair(CallInst *lockCall, InvokeInst *otherInvoke, AliasAnalysis &AA);
        bool isLockUnlockPair(InvokeInst *lockCall, In
/**********************************************************************
 *  Copyright (c) 2008-2015, Alliance for Sustainable Energy.
 *  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 **********************************************************************/
using namespa

using namespace openstudio::model;
TEST_F(ModelFixture, ModelObjectList_DefaultConstructor)
  ::testing::FLAGS_gtest_death_test_style = "threadsafe";
  ASSERT_EXIT ( 
  {  
    Model model;
    ModelObjectList testObject = ModelObjectList(model);
    exit(0); 
  } ,
    ::testing::ExitedWithCode(0), "" );
TEST_F(ModelFixture, ModelObjectList_Remove)
  Model model;
  ModelObjectList testObject = ModelObjectList(model);
  Connection connection = Connection(model);
  testObject.addModelObject(connection);
  std::vector<ModelObjectList> modelObjectLists = model.getModelObjects<ModelObjectList>();
  EXPECT_EQ(1, modelObjectLists.size());
  std::vector<Connection> modelObjects = model.getModelObjects<Connection>();
  EXPECT_EQ(1, modelObjects.size());
  testObject.remove();
  modelObjectLists = model.getModelObjects<ModelObjectList>();
  EXPECT_EQ(0, modelObjectLists.size());
  modelObjects = model.getModelObjects<Connection>();
  EXPECT_EQ(0, modelObjects.size());
TEST_F(ModelFixture, Mode

  Model model;
  ModelObjectList testObject = ModelObjectList(model);
  Connection connection = Connection(model);
  testObject.addModelObject(connection);
  std::vector<ModelObject> modelObjects = testObject.modelObjects();
  ModelObjectList testObjectClone = testObject.clone(model).cast<ModelObjectList>();
  std::vector<ModelObject> modelObjectsClone = testObjectClone.modelObjects();
  std::vector<Connection> connObjects = model.getModelObjects<Connection>();
  EXPECT_EQ(2, connObjects.size());
  EXPECT_EQ(1, modelObjectsClone.size());
  EXPECT_NE(modelObjectsClone[0].handle(), modelObjects[0].handle());
TEST_F(ModelFixture, ModelObjectList_CloneTwoModels)
  Model model;
  ModelObjectList testObject = ModelObjectList(model);
  Connection connection = Connection(model);
  testObject.addModelObject(connection);
  std::vector<ModelObject> modelObjects = testObject.modelObjects();
  ModelObjectList testObjectClone = testObject.clone(model).cast<ModelObjectList>();
  Model model2;
  Mode

  std::vector<ModelObject> modelObjectsClone2 = testObjectClone2.modelObjects();
  std::vector<Connection> connObjects = model.getModelObjects<Connection>();
  std::vector<Connection> connObjects2 = model2.getModelObjects<Connection>();
  EXPECT_EQ(2, connObjects.size());
  EXPECT_EQ(1, connObjects2.size());
  EXPECT_EQ(1, modelObjectsClone2.size());
  EXPECT_NE(testObjectClone2, testObjectClone);
  EXPECT_NE(testObjectClone2.handle(), testObjectClone.handle());
  EXPECT_NE(modelObjects[0].handle(), modelObjectsClone2[0].handle());
TEST_F(ModelFixture, ModelObjectList_ModelObjects)
  Model model;
  ModelObjectList testObject = ModelObjectList(model);
  std::vector<ModelObject> modelObjects = testObject.modelObjects();
  EXPECT_TRUE(modelObjects.empty());
TEST_F(ModelFixture, ModelObjectList_AddModelObject)
  Model model;
  ModelObjectList testObject = ModelObjectList(model);
  Connection connection = Connection(model);
  EXPECT_TRUE(testObject.addModelObject(connection));
  std::vecto

  EXPECT_EQ(1, modelObjects.size());
TEST_F(ModelFixture, ModelObjectList_RemoveModelObject)
  Model model;
  ModelObjectList testObject = ModelObjectList(model);
  Connection connection1 = Connection(model);
  Connection connection2 = Connection(model);
  testObject.addModelObject(connection1);
  testObject.addModelObject(connection2);
  testObject.removeModelObject(connection1);
  std::vector<Connection> testModelObjects = model.getModelObjects<Connection>();
  EXPECT_EQ(2, testModelObjects.size());
  std::vector<ModelObject> modelObjects = testObject.modelObjects();
  EXPECT_EQ(1, modelObjects.size());
  EXPECT_EQ(connection2.handle(), modelObjects[0].handle());
  testObject.removeModelObject(connection2);
  testModelObjects = model.getModelObjects<Connection>();
  modelObjects = testObject.modelObjects();
  EXPECT_EQ(2, testModelObjects.size());
  EXPECT_TRUE(modelObjects.empty());
TEST_F(ModelFixture, ModelObjectList_RemoveAllModelObjects)
  Model model;
  ModelObjectList testObj
ACE_INLINE
TAO::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY("RepoIdSetMap","RepoIdSetMap");
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY("RepoIdSetMap","find");
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      return 0;
    }
  return value._retn();
ACE_INLINE ssize_t
TAO::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY("RepoIdSetMap","size");
  return this->map_.current_size();
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY("RepoIdSetMap","find_or_create");
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      value = new RepoIdSet();
      if (this->map_.bind(key, value) != 0)
        {
           ACE_ERROR((LM_ERROR,
                      "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                      "the RepoIdSetMap.\n"));
           return 0;
        }
    }
  return value._retn();
ACE_INLINE TAO::DCPS::RepoIdSetMap::MapType&
TAO:
namespace Network
    /**
      * Envoyé du serveur au client, stocke les informations
      * sur un chunk
      * @brief Stocke les informations sur un chunk
      * @author Sam101
      */
    class ChunkDataMessage : public AbstractMessage
    {
        public:
            /**
              * MagicNumber de ChunkDataMessage
              */
            static const qint32 MAGICNUMBER_CHUNKDATA = 0x4213;
        protected:
            /**
              * Données du chunk
              */
            Chunk::Chunk _chunk;
        public:
            /**
              * Constructeur sans paramètres
              */
            ChunkDataMessage();
            /**
              * Constructeur
              */
            ChunkDataMessage(const Chunk::Chunk &chunk);
            /**
              * Renvoie le chunk
              */
            Chunk::Chunk& getChunk();
            /**
              * Renvoie le chunk, surchargé constant
              */
            const Chunk::Chunk& getC
namespace Stream
	class COutputStreamHelper : public Stream::IOutputStreamHelper
	{
	public:
		COutputStreamHelper(Stream::IOutputStream& rOutputStream);
		virtual ~COutputStreamHelper(void);
		virtual Stream::boolean setBufferSize(Stream::uint64 ui64BufferSize);
		virtual Stream::uint64 getBufferSize(void);
		virtual Stream::uint64 getBufferFill(void);
		virtual Stream::boolean open(void);
		virtual Stream::boolean isOpened(void);
		virtual Stream::boolean isFinished(void);
		virtual Stream::boolean close(void);
		virtual Stream::uint64 sendBuffer(Stream::uint8* pBuffer, const Stream::uint64 ui64BufferSize);
		virtual Stream::boolean setEndianness(const Stream::EEndianness& eEndianness);
		virtual Stream::EEndianness getEndianness(void);
		virtual Stream::boolean sendUInteger8(Stream::uint8 uiValue);
		virtual Stream::boolean sendUInteger16(Stream::uint16 uiValue);
		virtual Stream::boolean sendUInteger32(Stream::uint32 uiValue);
		virtual Stream::boolean sendUInteger64(Stream::uint64

