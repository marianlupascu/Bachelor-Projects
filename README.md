# Bachelor's-Projects

  

> This repository contains college projects -- screenshots/gif & source.

Thesis - [Style Extractor and Distance Between Styles](https://github.com/marianlupascu/Undergraduate-Thesis)

## [Year 3](Bachelors%20Year%203)
- _Software Engineering_ – [GetInStyle](https://github.com/marianlupascu/GetInStyle)
- _Web Development_ – [JiraCloneMVC](https://github.com/marianlupascu/JiraCloneMVC)
- _Deep learning_ – [Google Landmark Recognition Challenge](https://github.com/marianlupascu/Google-Landmark-Recognition-Challenge)

Click too see screenshots & details:

<details><summary><i>Computer Vision</i> - Seam Carving for Content-Aware Image Resizing</summary>

`Matlab` Image operator called seam carving that supports content-aware image resizing for both reduction and expansion. A seam is an optimal 8-connected path of pixels on a single image from top to bottom, or left to right, where optimality is defined by an image energy function. By repeatedly carving out or inserting seams in one direction we can change the aspect ratio of an image. By applying these operators in both directions we can retarget the image to a new size. The selection and order of seams protect the content of the image, as defined by the energy function. Seam carving can also be used for image content enhancement and object removal. We support various visual saliency measures for defining the energy of an image, and can also include user input to guide the process.
![demo1reduction](Bachelors%20Year%203/Computer%20Vision/printScreen4.PNG?raw=true)
![demo2reduction](Bachelors%20Year%203/Computer%20Vision/printScreen6.PNG?raw=true)
![contentEnhancement](Bachelors%20Year%203/Computer%20Vision/printScreen7.PNG?raw=true)
![removingObjects](Bachelors%20Year%203/Computer%20Vision/printScreen9.1.PNG?raw=true) 
</details>

<details><summary><i>Computer Vision</i> - Image Quilting for Texture Synthesis and Transfer</summary>

`Matlab` Image-based method of generating novel visual appearance in which a new image is synthesized by stitching together small patches of existing images. We call this process image quilting. First, we use quilting as a fast and very simple texture synthesis algorithm which produces surprisingly good results for a wide range of textures. Second, we extend the algorithm to perform texture transfer – rendering an object with a texture taken from a different object.
![textureSynthesis](Bachelors%20Year%203/Computer%20Vision/printScreen11.PNG?raw=true)
![textureTransfer](Bachelors%20Year%203/Computer%20Vision/printScreen12.PNG?raw=true) 
</details>

<details><summary><i>Computer Vision</i> - Training dictionaries for rare representations. Eliminate noise and restore images</summary>

`Matlab` Implementing and testing the algorithms for noise elimination (denoising) and restoration (inpainting) in an image based on the training of a dictionary for rare representations.
![inpainting](Bachelors%20Year%203/Computer%20Vision/printScreen13.PNG?raw=true) 
</details>

<details><summary><i>Computer Vision</i> - Making Mosaic Images</summary>

`Matlab` Algorithms for obtaining mosaic images - that is, obtained by pasting several smaller images that form the illusion of a whole. The mosaics are implemented with both a square and a hexagonal shape. This algorithm is based on the differences between the colors of the patches in the image and the colors of the mosaic images.
![mosaic1](Bachelors%20Year%203/Computer%20Vision/printScreen1.PNG?raw=true)
![mosaic2](Bachelors%20Year%203/Computer%20Vision/printScreen3.PNG?raw=true) 
</details>
  
<details><summary><i>Simulation techniques</i> - Statistical simulation of a queue</summary>

`R` The simulation is based on Poisson processes and simulates the waiting time in a queue depending on the time of arrival in the store.
![demo](Bachelors%20Year%203/Simulation%20techniques/printScreen.PNG) 
</details>
<details><summary>Other Classes</summary>
  <li> Declarative Programming </li>
  <li> Compilation techniques </li>
  <li> Cryptography and security </li>
  <li> Partial Derivatives and Differential Equations </li>
  <li> Database Management Systems </li>
  <li> Numerical Calculus </li>
  <li> Optimization techniques </li>
</details>

## [Year 2](Bachelors%20Year%202)

- _Software Development Methods_ – [ROTL](https://github.com/marianlupascu/ROTL)

Click too see screenshots & details:

<details><summary><i>Advanced Object Programming</i> - SpaceChat</summary>

`Java` :earth_africa: **SpaceChat** is a chat that involves a server and multiple clients who can communicate with each other via the server. The server is created on a specific port and clients can connect to it. The options of each client include: viewing all clients, log out, send a message. :boom:
![demo1](Bachelors%20Year%202/Advanced%20Object%20Programming/ChatJavaFX/presentGif.gif?raw=true)
![demo2](Bachelors%20Year%202/Advanced%20Object%20Programming/ChatJavaFX/ClientChatWindow.gif?raw=true)
![demo3](Bachelors%20Year%202/Advanced%20Object%20Programming/ChatJavaFX/ClientLogin.gif?raw=true)
![demo4](Bachelors%20Year%202/Advanced%20Object%20Programming/ChatJavaFX/ServerInterface.gif?raw=true) 
</details>

<details><summary><i>Advanced Object Programming</i> - WolfBank ATM</summary>

`Java` :coffee: **WolfBank ATM** is a Remote Method Invocation (RMI) application implemented in Java that involves the existence of a server and multiple clients. A client (unique accountId) can go to an ATM and use 3 operations:
- double deposit(accountId, int amount)
- double widthdraw(accountId, int amount)
- double inquiry(int accountId)

Also, I consider that multiple clients with the same accountId can request widthdraw/operations. :boom:
![demo1](Bachelors%20Year%202/Advanced%20Object%20Programming/MinimalBankSystem/present.gif?raw=true)
![demo2](Bachelors%20Year%202/Advanced%20Object%20Programming/MinimalBankSystem/client.gif?raw=true)
![demo3](Bachelors%20Year%202/Advanced%20Object%20Programming/MinimalBankSystem/server.gif?raw=true) 
</details>
 
<details><summary><i>Computational Geometry</i> - Convex Hull Graham's Scan Andrews version</summary>

`Java` Graham's scan is a method of finding the convex hull of a finite set of points in the plane with time complexity O(n log n). The Andrews variant involves two-stage construction: first determine the infinitely superior convection (drawn with green, the final version and red what was tested) and the inferior convex winders (drawn in blue, the final version and in yellow what was tested and do not belongs the convex lower convex).

![demo1](Bachelors%20Year%202/Computational%20Geometry/Convex%20Hull%20Graham%20Scan%20Andrews%20version/start.PNG?raw=true)
![demo2](Bachelors%20Year%202/Computational%20Geometry/Convex%20Hull%20Graham%20Scan%20Andrews%20version/in%20work.PNG?raw=true)
![demo3](Bachelors%20Year%202/Computational%20Geometry/Convex%20Hull%20Graham%20Scan%20Andrews%20version/final.PNG?raw=true)

>Contributors:
>  * Gorneanu Andrei
>  * Dospra Cristian 

</details>

<details><summary><i>Operating Systems</i> - Round-Robin-Scheduler</summary>

`C` To schedule processes fairly, a **round-robin scheduler** generally employs time-sharing, giving each job a time slot or quantum (its allowance of CPU time), and interrupting the job if it is not completed by then. The job is resumed next time a time slot is assigned to that process. If the process terminates or changes its state to waiting during its attributed time quantum, the scheduler selects the first process in the ready queue to execute. In the absence of time-sharing, or if the quanta were large relative to the sizes of the jobs, a process that produced large jobs would be favoured over other processes.

Round-robin algorithm is starvatin-free and a pre-emptive algorithm as the scheduler forces the process out of the CPU once the time quota expires. We have predefined three types of users for which quantum time differs depending on the importance: a user has 1000 clock beats while an administrator has 3000 clock beats

![demo1](Bachelors%20Year%202/Operating%20Systems/Round-Robin-Scheduler/start.PNG?raw=true)
![demo2](Bachelors%20Year%202/Operating%20Systems/Round-Robin-Scheduler/final.PNG?raw=true)
>Contributors:
>  * Costan Miriam
>  * Gorneanu Andrei

</details>
  
<details><summary><i>Web Techniques</i> - Site to buy / download movies</summary>

`HTML + CSS` A site to download / buy movies on subscriptions. At the moment, he has just a description and details for only eight movies.

![demo1](Bachelors%20Year%202/Web%20Techniques/CSS%20Project/screenshots/header.PNG?raw=true)
![demo2](Bachelors%20Year%202/Web%20Techniques/CSS%20Project/screenshots/about.PNG?raw=true)
![demo3](Bachelors%20Year%202/Web%20Techniques/CSS%20Project/screenshots/movies.PNG?raw=true)
![demo4](Bachelors%20Year%202/Web%20Techniques/CSS%20Project/screenshots/pricing.PNG?raw=true)
![demo5](Bachelors%20Year%202/Web%20Techniques/CSS%20Project/screenshots/contact.PNG?raw=true)
![demo6](Bachelors%20Year%202/Web%20Techniques/CSS%20Project/screenshots/1movie.PNG?raw=true)
</details>

<details><summary><i>Web Techniques</i> - Game with MARVEL characters</summary>

`javascript` The game contains five levels, each of which is related to a Marvel series movie. The protagonist is Emma Frost. The objective of the game is to pass all 5 levels. In each level you can draw positive characters from the top right of the game, only if the negative character is from that movie (for example, if you are level 1 - which is related to Spider Man - then you can shoot Spider Man and il you can place anywhere you want in the game space, be careful that there are more favorable places than others, if you try to shoot character other than the level you will not be left.). Positive characters drawn from the window where they are cycling random films have the ability to automatically shoot the antagonist with a nuclear weapon. And the player can lightning with more damage than the atomic weapon of positive characters. You know that every thundering lightning consumes you out of life, and any contact with the negative character is eating your life.

![demo1](Bachelors%20Year%202/Web%20Techniques/marvel.gif?raw=true)
![demo2](Bachelors%20Year%202/Web%20Techniques/JS%20Project/screenshots/menu.PNG?raw=true)
![demo3](Bachelors%20Year%202/Web%20Techniques/JS%20Project/screenshots/game.PNG?raw=true)
![demo4](Bachelors%20Year%202/Web%20Techniques/JS%20Project/screenshots/credits.PNG?raw=true)
![demo5](Bachelors%20Year%202/Web%20Techniques/JS%20Project/screenshots/options.PNG?raw=true)
![demo6](Bachelors%20Year%202/Web%20Techniques/JS%20Project/screenshots/tutorial.PNG?raw=true)
</details>

<details><summary><i>Robotics with Arduino</i> - M&M Sorter</summary>

`Arduino` Initially, colored candies are held in a charger and fall in turn (they are taken over by a stepper-motor).
Then it is analyzed by the color sensor that detects its color.
Then the servomotor picks up the candy, rotates to the candy color container.
Sorting is done in 2 stages, namely: the first stage, which involves the sorting of yellow and brown colors, and the remaining candy will be put in all the recipes, then if they are 5 consecutive rows in the color sensor the absence of the bumble beans can pass at Stage 2, alerting the user by moving the redistribution bridge of the candy 5 times. Step 2 involves sorting the other three colors: red, green and blue. :boom:

<div  style="float: left;">
<img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Robotics%20with%20Arduino/M&M%20Sorter/4.jpg?raw=true"  width="49%"/>
<img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Robotics%20with%20Arduino/M&M%20Sorter/5.jpg?raw=true"  width="49%"/>
</div>
<div  style="float: left;">
<img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Robotics%20with%20Arduino/M&M%20Sorter/6.jpg?raw=true"  width="99%"/>
</div>
<div  style="float: left;">
<img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Robotics%20with%20Arduino/M&M%20Sorter/1.jpg?raw=true"  width="32.8%"/>
<img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Robotics%20with%20Arduino/M&M%20Sorter/2.jpg?raw=true"  width="32.8%"/>
<img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Robotics%20with%20Arduino/M&M%20Sorter/3.jpg?raw=true"  width="32.8%"/>
</div>
</details>

<details><summary><i>Robotics with Arduino</i> - Led matrix Game</summary>

`Arduino` The game is a deviation from Flappy Bird. There are only 9 levels + level 10 in which the boss comes. A level ranging from 1 min to 3-4 mins at the last level that keeps the boss up until all his life is consumed. The boss is invincible, the goal is to survive as long as the score is gathered with the Euclidean distance from bird to boss.

Well, the start is input from the user, the joystick selects rules, credits or start-game. The end will be the same: at the end it shows the information about how it was played (score, lives, level) and this information disappears with a user input. He has difficulty, lives and score.
![demo1](Bachelors%20Year%202/Robotics%20with%20Arduino/Led%20matrix/img1.jpg?raw=true)
![demo2](Bachelors%20Year%202/Robotics%20with%20Arduino/Led%20matrix/img2.jpg?raw=true)
![demo3](Bachelors%20Year%202/Robotics%20with%20Arduino/Led%20matrix/img3.jpg?raw=true)
</details>

<details><summary><i>Probabilities & Statistics</i> - Modelling Linear Regression</summary>

`R` Using the Cars93 dataset in the MASS library, we implement a linear regression model. We estimate the regression parameters and comment on the results. We apply three methods to evaluate the accuracy of the model and make a prediction.
>Contributors:
>  * Banu Alexandru
>  * Costan Miriam

</details>

<details><summary><i>Probabilities & Statistics</i> - Modelling Linear Regression</summary>

`R` Graphic representation for probability density and distribution function for a set of parameters for Student, Fisher and Chi-square distributions, indicating their properties and then testing statistical assumptions.
>Contributors:
>  * Banu Alexandru
>  * Costan Miriam

</details>

<details><summary>Other Classes</summary>
  <li> Calculability & Complexity </li>
  <li> Logic Programming </li>
  <li> Databases </li>
  <li> Advanced Programming Techniques </li>
  <li> Computer Network </li>
  <li> Artificial Intelligence </li>
</details>

## [Year 1](Bachelors%20Year%201)

- _Object-Oriented Programming_ – [Chess-Game](https://github.com/marianlupascu/Chess-Game)

Click too see screenshots & details:

<details><summary><i>Formal Languages and Automata</i> - CYK Parsing</summary>

`C++` The **Cocke–Younger–Kasami** algorithm (alternatively called **CYK**, or **CKY**) is a parsing algorithm for context-free grammars, named after its inventors, John Cocke, Daniel Younger and Tadao Kasami. It employs bottom-up parsing and dynamic programming. The algorithm requires the context-free grammar to be rendered into Chomsky normal form (CNF), because it tests for possibilities to split the current sequence in half. Any context-free grammar that does not generate the extineiden 27 production rules of the forms ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/13dc432701b1477bc9ba32b0d71c58ecf2d44d9e) and ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/d006db33dce212be6b03190185ee63f78a27a055).

![demo](Bachelors%20Year%201/Formal%20Languages%20and%20Automata/CYK%20Parsing%20-Cocke-Younger-Kasami/CYK-Parsing.PNG?raw=true)

>Grammar is :
>S->AB | BC
>A->BA | a
>B->CC | b
>C->AB | a

</details>

<details><summary><i>Formal Languages and Automata</i> - Chomsky Normal Form</summary>

`C++` Transform a Context-free grammar into it is **Chomsky Normal Form (CNF)**, in four steps.
</details>

<details><summary><i>Formal Languages and Automata</i> - DFA Minimal</summary>

`C++` For any given DFA **A**, we can build a DFA **A′** that accepts the same language using the minimum number of states needed. Since **A** has more states than **A′**, we need to figure out which states we have to remove.
</details>
  
<details><summary><i>Geometry</i> - Gauss Elimination Method Algorithm</summary>

`C++` The Gauss Elimination Method Algorithm has as input a 2 nd polynomial in n variables represented as a matrix and has as output the square shape of this polynomial.
![demo](Bachelors%20Year%201/Geometry/Gauss%20Elimination%20Method%20Algorithm/Gauss_method.PNG?raw=true)
</details>

<details><summary><i>Geometry</i> - Gram-Schmidt Process Algorithm</summary>

`C++` Gram–Schmidt process is a method for orthonormalising a set of vectors in an inner product space, most commonly the Euclidean space Rn equipped with the standard inner product. The Gram–Schmidt process takes a finite, linearly independent set S = {v1, ..., vk} for k ≤ n and generates an orthogonal set S′ = {u1, ..., uk} that spans the same k-dimensional subspace of R^n as S
![demo](Bachelors%20Year%201/Geometry/Gram-Schmidt%20Process%20Algorithm/Gram-Schmidt.PNG?raw=true)
</details>
  
<details><summary>Other Classes</summary>
  <li> Graph Theory </li>
  <li> Mathematical and Computational Logic </li>
  <li> Mathematical Analysis/Calculus </li>
  <li> (Linear) Algebra </li>
  <li> Procedural Programming </li>
  <li> Psychopedagogy (years 1 - 2) </li>
  <li> Computer Systems Architecture </li>
  <li> Algorithms and Data Structures </li>
</details>

<p  align="center">
<span>Lupascu Marian </span>  <img  src="https://github.com/marianlupascu/School-Projects/blob/master/Bachelors%20Year%202/Web%20Techniques/CSS%20Project/img/mini-logo.png?raw=true">
</p>