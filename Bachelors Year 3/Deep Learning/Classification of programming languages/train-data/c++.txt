namespace grace {
	FormattedStream& operator<<(FormattedStream& stream, const char *cstr) {
		stream.write((const byte*)cstr, strlen(cstr));
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, const String& str) {
		stream.write((const byte*)str.data(), str.size());
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, bool b) {
		stream << (b ? "true" : "false");
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, uint8 n) {
		stream << format("%u", n);
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, uint16 n) {
		stream << format("%u", n);
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, uint32 n) {
		stream << format("%u", n);
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, uint64 n) {
		stream << format("%llu", n);
		return stream;
	}
	FormattedStream& operator<<(FormattedStream& stream, char c) {
		stream.write((const byte*)&c, 1);
		return s
namespace Extentities
	ObjectGenerator<Extentity> generator;
	HandlerFactory<EntityHandler, int> handler;
	void RegisterStdHandler()
	{
		puts("init: register Extentities");
		handler.Register<EntityHandler>(NOTUSED);
		handler.Register<EntityHandlerLight>(LIGHT);
		handler.Register<EntityHandlerMapmodel>(MAPMODEL);
		handler.Register<EntityHandlerPlayerstart>(PLAYERSTART);
		handler.Register<EntityHandlerEnvmap>(ENVMAP);
		handler.Register<EntityHandlerParticles>(PARTICLES);
		handler.Register<EntityHandlerMapsound>(MAPSOUND);
		handler.Register<EntityHandlerSpotlight>(SPOTLIGHT);
		handler.Register<EntityHandlerTeleport>(TELEPORT);
		handler.Register<EntityHandlerTeledest>(TELEDEST);
		handler.Register<EntityHandlerMonster>(MONSTER);
		handler.Register<EntityHandlerJumppad>(JUMPPAD);
		handler.Register<EntityHandlerBox>(BOX);
		handler.Register<EntityHandlerBarrel>(BARREL);
		handler.Register<EntityHandlerPlatform>(PLATFORM);
		handler.Register<EntityHandlerElevator>(ELEVATOR);
		han
namespace OpenDDS
  namespace DCPS
  {
    class RepoIdSetMap;
    class OpenDDS_Dcps_Export RepoIdSetMap
    {
      public:
        typedef std::map<RepoId, RepoIdSet_rch, GUID_tKeyLessThan> MapType;
        RepoIdSetMap();
        virtual ~RepoIdSetMap();
        int        insert(RepoId key, RepoId value);
        RepoIdSet* find(RepoId key);
        int        remove(RepoId key, RepoId value);
        RepoIdSet* remove_set(RepoId key);
        int release_publisher(RepoId subscriber_id, RepoId publisher_id);
        size_t size() const;
        MapType& map();
        const MapType& map() const;
        size_t marshaled_size ();
        
        ACE_Message_Block* marshal (bool byte_order);
        int demarshal (ACE_Message_Block* acks, bool byte_order);
        
        void get_keys (RepoIdSet& keys);
        void operator= (const RepoIdSetMap &);
        void clear ();
        void dump ();
    private:
        RepoIdSet* find_or_create(RepoId key);
        MapType  map_;
    
/*
    YUMRepoManager, a manager for the configuration files of YUM and his repositories.
    Copyright (C) 2011-2012  JosuÃ© V. Herrera
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
*/
class RepoData
public:
    explicit RepoData();
    enum RepoLabel {
        Name,
        Comment,
        FailoverMethod,
        SkipIfUnavailable,
        BaseURL,
        MetaLink,
        Proxy,
        ProxyUsername,
        ProxyPassword,
        Speed,
        Include,
      
*  @file        Sample.hpp
*  @author      Peter Goldsborough
*  @date        27/09/2014
*  @brief       Sample structure.
*  @details     This file defines structs for holding two-channel samples.
*************************************************************************************************/
*  @brief       Struct holding two double values for stereo audio.
*  @details     Multiplication, dvision, additon and subtraction between Samples all possible.
*****************************************************************************************************/
struct Sample
    Sample(double val = 0)
    : left(val), right(val)
    { }
    
    Sample(double lf, double ri)
    : left(lf), right(ri)
    { }
    
    Sample(const Sample& other)
    {
        if (&other != this)
        {
            this->left = other.left;
            this->right = other.right;
        }
    }
    
    Sample& operator= (const Sample& other)
    {
        if (this != &other)
        {
            left = othe

            right = other.right;
        }
        
        return *this;
    }
    
    Sample& operator*= (const Sample& other)
    {
        left *= other.left;
        right *= other.right;
        
        return *this;
    }
    
    Sample operator* (const Sample& other)
    {
        Sample ret(*this);
        
        ret.left *= other.left;
        
        ret.right *= other.right;
        
        return ret;
    }
    
    Sample& operator/= (const Sample& other)
    {
        left /= other.left;
        right /= other.right;
        
        return *this;
    }
    
    Sample operator/ (const Sample& other)
    {
        Sample ret(*this);
        
        ret.left /= other.left;
        
        ret.right /= other.right;
        
        return ret;
    }
    
    Sample& operator += (const Sample& other)
    {
        left += other.left;
        right += other.right;
        
        return *this;
    }
    
    Sample operator+ (const Sample& other)
    {
        Sam
NodeRepo::NodeRepo (const NodeRepo::tree_type& tree)
    : _tree(tree)
NodeRepo::~NodeRepo ()
NodeRepo& NodeRepo::insert (const Node& node)
    (this->_tree).insert(node);
    return *this;
NodeRepo& NodeRepo::optimize ()
    (this->_tree).optimize();
    return *this;
NodeRepo::node_list_type NodeRepo::findWithinSphere (
        NodeRepo::node_type ref, double radius) const
    NodeRepo::node_list_type nodes_in_range = this->findWithinRange(
            ref, radius);
    NodeRepo::node_list_type nodes;
    std::copy_if(
            nodes_in_range.begin(),
            nodes_in_range.end(),
            std::back_inserter(nodes),
            [&ref, &radius](const Node& node){
                return node.distanceTo(ref) < radius;
            });
    return nodes;
NodeRepo::node_list_type NodeRepo::findWithinRange (
        NodeRepo::node_type ref, double range) const
    NodeRepo::node_list_type nodes;
    (this->_tree).find_within_range(ref, range, std::back_inserter(nodes));
    return 
Repository* GameInitializer::initializeRepository()
	Repository *repo = new Repository();
	return repo;
sf::RenderWindow* GameInitializer::initializerWindow()
	sf::RenderWindow *window = new sf::RenderWindow(sf::VideoMode(800, 600), "Bist Gaim evrr");
	sf::Vector2u windowSize = window->getSize();
    window->setVerticalSyncEnabled(true);
	return window;
std::list<System*> GameInitializer::initializeGameSystems(sf::RenderWindow *window, Repository *repo)
	std::list<System*> systemList;
	LoadingSystem *loadingSystem = new LoadingSystem(repo);
	systemList.push_back(loadingSystem);
	InputSystem *inputSystem = new InputSystem(repo);
	systemList.push_back(inputSystem);
	MenuActionSystem *menuActionSystem = new MenuActionSystem(repo);
	systemList.push_back(menuActionSystem);
	PhysicsSystem *physicsSystem = new PhysicsSystem(repo);
	systemList.push_back(physicsSystem);
	CollisionSystem *collisionSystem = new CollisionSystem(repo);
	systemList.push_back(collisionSystem);
	ScoreSystem *scoresyst
struct InterfaceActionInvoker0
	typedef void (*Action)(void*, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct InterfaceFuncInvoker0
	typedef R (*Func)(void*, const RuntimeMethod*);
	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct InterfaceActionInvoker1
	typedef void (*Action)(void*, T1, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1)
	{
		const VirtualI

		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R, typename T1>
struct InterfaceFuncInvoker1
	typedef R (*Func)(void*, T1, const RuntimeMethod*);
	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct InterfaceActionInvoker2
	typedef void (*Action)(void*, T1, T2, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct InterfaceFuncInvoker2
	ty

	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3>
struct InterfaceActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct InterfaceFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const RuntimeMethod*);
	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInte

	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct InterfaceActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct InterfaceFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const RuntimeMethod*);
	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		const V

		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const RuntimeMethod*);
	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_

		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct InterfaceActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct InterfaceActionInvoker7
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, const RuntimeMethod*);
	static inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T

	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct InterfaceFuncInvoker8
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, T8, const RuntimeMethod*);
	static inline R Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)
	{
		const VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct InterfaceFuncInvoker9
	typedef R (
extern "C"
	void bkl2d_globalInit(bkl2d_init_struct *s)
	{
		Live2D::init();
		if (s)
		{
			readDataFromFile = s->_readDataFromFile;
			freeData = s->_freeData;
			loadTextureFromFile = s->_loadTextureFromFile;
			freeTexture = s->_freeTexture;
			playSound = s->_playSound;
			stopSound = s->_stopSound;
			getRealTimeVolumeOfSound = s->_getRealTimeVolumeOfSound;
			sendError = s->_sendError;
		}
	}
	void bkl2d_globalDestroy()
	{
		BKL2D_Model::destroyAll();
		Live2D::dispose();
	}
	int32_t bkl2d_newModel(const char *file)
	{
		return BKL2D_Model::create(file);
	}
	void bkl2d_getModelCanvasSize(int32_t id, float *w, float *h)
	{
		BKL2D_Model *model = BKL2D_Model::modelFromID(id);
		if (model)
		{
			model->getCanvasSize(w, h);
			return;
		}
		*w = 0;
		*h = 0;
	}
	void bkl2d_freeModel(int32_t id)
	{
		BKL2D_Model::destroy(id);
	}
	void bkl2d_setMatrix(int32_t id, float *matrix)
	{
		BKL2D_Model *model = BKL2D_Model::modelFromID(id);
		if (model)
		{
			model->setMatrix(matrix);
		}
	
namespace graphics
class sample
public:
    constexpr sample(double) noexcept;
    constexpr sample() noexcept : sample{0.0} {}
    constexpr double value() const noexcept { return value_; }
    explicit constexpr operator double() const noexcept { return value_; }
    constexpr sample operator*(sample other) const noexcept;
    constexpr sample& operator*=(sample) noexcept;
private:
    double value_;
};
constexpr sample interpolate(sample a, sample weight, sample b) noexcept;
constexpr bool operator==(sample a, sample b) noexcept;
constexpr bool operator!=(sample a, sample b) noexcept;
constexpr bool operator<(sample a, sample b) noexcept;
constexpr bool operator<=(sample a, sample b) noexcept;
constexpr bool operator>(sample a, sample b) noexcept;
constexpr bool operator>=(sample a, sample b) noexcept;
constexpr sample operator+(sample, sample) noexcept;
constexpr sample& operator+=(sample&, sample) noexcept;
constexpr sample operator-(sample, sample) noexcept;
constexpr sample& ope

constexpr sample operator/(sample, sample) noexcept;
constexpr sample& operator/=(sample&, sample) noexcept;
namespace
constexpr double saturate(double value) noexcept
    if (value < 0.0) return 0.0;
    if (value > 1.0) return 1.0;
    return value;
constexpr sample::sample(double value) noexcept
        : value_{saturate(value)}
{}
constexpr sample interpolate(sample a, sample weight, sample b) noexcept
    return sample{(1 - weight.value()) * a.value() + weight.value() * b.value()};
constexpr sample sample::operator*(sample other) const noexcept
    sample result;
    return result;
constexpr sample& sample::operator*=(sample other) noexcept
    return *this;
constexpr sample operator+(sample a, sample b) noexcept {
    return sample{a.value() + b.value()};
constexpr sample& operator+=(sample& target, sample other) noexcept {
    return target = target + other;
constexpr sample operator-(sample a, sample b) noexcept {
    return sample{a.value() - b.value()};
constexpr sample& ope
namespace TAO
  namespace DCPS
  {
    class RepoIdSetMap;
    class TAO_DdsDcps_Export RepoIdSetMap
    {
      public:
        typedef ACE_Hash_Map_Manager_Ex<RepoId,
                                        RepoIdSet_rch,
                                        ACE_Hash<RepoId>,
                                        ACE_Equal_To<RepoId>,
                                        ACE_Null_Mutex>        MapType;
        RepoIdSetMap();
        virtual ~RepoIdSetMap();
        int        insert(RepoId key, RepoId value);
        RepoIdSet* find(RepoId key);
        int        remove(RepoId key, RepoId value);
        RepoIdSet* remove_set(RepoId key);
        int release_publisher(RepoId subscriber_id, RepoId publisher_id);
        size_t size() const;
        MapType& map();
        const MapType& map() const;
        size_t marshaled_size ();
        
        ACE_Message_Block* marshal (bool byte_order);
        bool is_subset (RepoIdSetMap& map, RepoId id);
        
        int demar
Chunk::Chunk(){
    chunk = new int[CHUNK_W*CHUNK_H]{0};
    chunkSize = 200;
void Chunk::populate(int ch[CHUNK_H][CHUNK_W]){
    int k = 0;
    for (int i = 0; i < CHUNK_H; i++){
        for (int j = 0; j < CHUNK_W; j++){
            chunk[k++] = ch[j][i];
        }
    chunkSize += k;
    }
void Chunk::print(){
    for (int i = 0; i < chunkSize; i++){
        std::cout << chunk[i] << ' ';
        if (!(i % CHUNK_W)) {
            std::cout << '\n';
        }
    }
void Chunk::set(int i, int j, int val){
    chunk[(i*CHUNK_W)+j] = val;
int Chunk::get(int i, int j){
    return chunk[(i*CHUNK_W)+j];
int Chunk::sumCardNeighbors(int i, int j){
    return chunk[(i*CHUNK_W)+j-1] + chunk[(i*CHUNK_W)+j+1] + chunk[((i+1)*CHUNK_W)+j]
    + chunk[((i-1)*CHUNK_W)+j];
float Chunk::tileGlobalX(int i, int j){
    return (index.first * Chunk::width * TILE_X) + (j*TILE_X);
float Chunk::tileGlobalY(int i, int j){
    return (index.second * height * TILE_Y) + (i*TILE_Y);
    std::pair <float,float> coor
/** 
 *
 * \author Tristan Vanderbruggen
 *
 */
namespace MFB {
  template <template <typename T> class Model> class Driver;
  template <typename Object> class Sage;
  struct api_t;
};
namespace MDCG {
/*!
 * \addtogroup grp_mdcg_model
 * @{
*/
class ModelBuilder {
  public:
    typedef unsigned model_id_t;
  private:
    MFB::Driver<MFB::Sage> & p_mfb_driver;
    std::vector<Model::model_t> p_models;
  private:
    
    template <Model::model_elements_e kind>
    void toDotNode(std::ostream & out, Model::element_t<kind> * element) const;
    template <Model::model_elements_e kind>
    void setParentFromScope(Model::model_t & model, Model::element_t<kind> * element, SgSymbol * symbol);
  
    void add(Model::model_t & model, const MFB::api_t * api);
    void add(Model::model_t & model, SgNamespaceSymbol * namespace_symbol);
    void add(Model::model_t & model, SgVariableSymbol * variable_symbol);
    void add(Model::model_t & model, SgFunctionSymbol * function_symbol);
    void add(Mod
namespace chi {
/**
 * @addtogroup Sounds
 * @{
 */
class SdlSample;
/**
 * @ingroup Resources
 */
template<>
class ResourceManager<SdlSample> : public ResourceManager<Sample> {
public:
	static Factory<SdlSample> *factory;
};
/**
 * @ingroup @SDL
 */
class SdlSample : public Sample {
public:
	SdlSample();
	SdlSample(const SdlSample &counter);
	SdlSample(const Sample &counter);
	/**
	 * Load a sample from a resource location.
	 *
	 * @param uri
	 *   The location of the sample resource to load.
	 */
	SdlSample(const std::string &uri);
	~SdlSample();
	Sample &operator =(const Sample &sample);
	SdlSample &operator =(const SdlSample &sample);
	SdlSample &copyFrom(const SdlSample &sample);
	/**
	 * Play a sample.
	 *
	 * @param loops
	 *   Number of times to repeat.
	 * @param channel
	 *   %Sound channel to play the sample on.
	 */
	int play(int loops = 0, int channel = AnyChannel);
	static Factory<SdlSample> *factory;
private:
	Mix_Chunk *sample;
};
/**
 * @ingroup Resources
 * @ingroup S
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
multiple_fill_array_gen_class::generate_multiple_fill_array(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  stream << "if (local_args_info.";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given && ";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_list)";
  stream << "\n";
  stream << indent_str;
  stream << "  {";
  stream << "\n";
  stream << indent_str;
  stream << "    struct ";
  generate_string (list_name, stream, indent + indent_str.length ());
  stream << "_list *tmp;";
  stream << "\n";
  stream << indent_str;
  stream << "    args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_arg = (";
  generate_string (type, stream, indent + indent_str.length ());
  stream << " *) realloc (args_info->";
  generate_string (option_var_n

  stream << "_arg, (args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given + local_args_info.";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given) * sizeof (";
  generate_string (type, stream, indent + indent_str.length ());
  stream << "));";
  stream << "\n";
  stream << indent_str;
  stream << "    args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_orig = (char **) realloc (args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_orig, (args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given + local_args_info.";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given) * sizeof (char *));";
  stream << "\n";
  stream << indent_str;
  stream << "    for (i = (local_args_info.";
  generate_strin

  stream << "_given - 1); i >= 0; --i)";
  stream << "\n";
  stream << indent_str;
  stream << "      {";
  stream << "\n";
  stream << indent_str;
  stream << "        tmp = ";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_list;";
  stream << "\n";
  stream << indent_str;
  stream << "        args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_arg [i + args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given] = ";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_list->arg;";
  stream << "\n";
  stream << indent_str;
  stream << "        args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_orig [i + args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given] = ";
  generate_string (option_var_name,
using namespace std;
class C3dsFileFormat
public:
	C3dsFileFormat() {}
protected:
	typedef struct _chunk3ds
	{
		unsigned short	Flag;
		long			Size;
	} chunk3ds;
	typedef struct _Transform3dsMatrix
	{
		float _11, _12, _13;
		float _21, _22, _23;
		float _31, _32, _33;
	} Transform3dsMatrix;
	typedef struct _Translate3dsMatrix
	{
		float _11, _12, _13;
	} Translate3dsMatrix;
	class ViewPortLayout
	{
	public:
		ViewPortLayout(unsigned short Style, short Active, short Unknow1, short Swap, 
					   short Unknow2, short Swap_prior, short Swap_view) : style(Style),
																		   active(Active),
																		   unknow1(Unknow1),
																		   swap(Swap),
																		   unknow2(Unknow2),
																		   swap_prior(Swap_prior),
																		   swap_view(Swap_view) {}
		unsigned short	style;
	    short			active;
		short			unknow1;
	    short			swap;
		short			unknow2;
	    short			swap_prior;
	    short			swap_view;
	};
	enum {CameraNameSize = 11};
	class View

	{
	public:
		ViewPortData(short Flags, short Axis_lockout, short Win_x, short Win_y, short Win_w, short Win_h,
					 short Win_view, float Zoom, float Worldcenter_x, float Worldcenter_y, float Worldcenter_z,
					 float Horiz_ang, float Vert_ang, char *CameraName) : flags(Flags), axis_lockout(Axis_lockout),
																		  win_x(Win_x), win_y(Win_y),
																		  win_w(Win_w), win_h(Win_h),
																		  win_view(Win_view), zoom(Zoom),
																		  worldcenter_x(Worldcenter_x),
																		  worldcenter_y(Worldcenter_y),
																		  worldcenter_z(Worldcenter_z),
																		  horiz_ang(Horiz_ang), vert_ang(Vert_ang),
																		  camera_name(CameraName) {}
		short	flags, axis_lockout;
		short	win_x, win_y, win_w, win_h, win_view;
		float	zoom; 
		float	worldcenter_x, worldcenter_y, worldcenter_z;
		float	horiz_ang, vert_ang;
		string	camera_name;
	};
	enum {
		CHUNK_VERSION	= 0x0002,
	    CHUNK_RGBF      = 0x0010,
	    CHUNK_RGBB    

		CHUNK_PERCENTW	= 0x0030,
		CHUNK_PERCENTF	= 0x0031,
	    CHUNK_PRJ       = 0xC23D,
	    CHUNK_MLI       = 0x3DAA,
	    CHUNK_MAIN      = 0x4D4D,
	        CHUNK_OBJMESH   = 0x3D3D,
				CHUNK_ONEUNIT	= 0x0100,
	            CHUNK_BKGCOLOR  = 0x1200,
	            CHUNK_AMBCOLOR  = 0x2100,
				CHUNK_DEFAULT_VIEW = 0x3000,
					CHUNK_VIEW_TOP = 0x3010,
					CHUNK_VIEW_BOTTOM = 0x3020,
					CHUNK_VIEW_LEFT = 0x3030,
					CHUNK_VIEW_RIGHT = 0x3040,
					CHUNK_VIEW_FRONT = 0x3050,
					CHUNK_VIEW_BACK = 0x3060,
					CHUNK_VIEW_USER = 0x3070,
					CHUNK_VIEW_CAMERA = 0x3080,
		    CHUNK_MESHV	=	0x3D3E,
	            CHUNK_OBJBLOCK  = 0x4000,
	                CHUNK_TRIMESH   = 0x4100,
	                    CHUNK_VERTLIST  = 0x4110,
	                    CHUNK_VERTFLAGS = 0x4111,
	                    CHUNK_FACELIST  = 0x4120,
	                    CHUNK_FACEMAT   = 0x4130,
	                    CHUNK_MAPLIST   = 0x4140,
	                    CHUNK_SMOOLIST  = 0x4150,
	                    CHUNK_TRMATR

	                    CHUNK_MESHCOLOR = 0x4165,
	                    CHUNK_TXTINFO   = 0x4170,
	                CHUNK_LIGHT     = 0x4600,
	                    CHUNK_SPOTLIGHT = 0x4610,
	                CHUNK_CAMERA    = 0x4700,
	                CHUNK_HIERARCHY = 0x4F00,
	        CHUNK_VIEWPORT_LAYOUT_OLD	= 0x7000,
				CHUNK_VIEWPORT_DATA_OLD	= 0x7010,
					CHUNK_VIEWPORT_SIZE = 0x7020,
						CHUNK_NETWORK_VIEW = 0X7030,
	        CHUNK_VIEWPORT_LAYOUT	= 0x7001,
				CHUNK_VIEWPORT_DATA	= 0x7011,
				CHUNK_VIEWPORT_DATA3 = 0x7012,
			CHUNK_MATERIAL  = 0xAFFF,
	            CHUNK_MATNAME   = 0xA000,
	            CHUNK_AMBIENT   = 0xA010,
	            CHUNK_DIFFUSE   = 0xA020,
	            CHUNK_SPECULAR  = 0xA030,
				CHUNK_SHINE		= 0xA040,
				CHUNK_SHINE_STR	= 0xA041,
				CHUNK_ALPHA		= 0xA050,
				CHUNK_ALPHAFALL	= 0xA052,
				CHUNK_ALPHA_BLUR= 0xA053,
				CHUNK_SELFLITE	= 0xA084,
				CHUNK_WIRETICK  = 0xA087,
			    CHUNK_INTRANC	= 0xA08A,
			    CHUNK_RENDERMODE= 0xA100,
	            C

	            CHUNK_BUMPMAP   = 0xA230,
	            CHUNK_MAPFILE   = 0xA300,
				CHUNK_M_OPTIONS	= 0xA351,
				CHUNK_M_BLUR	= 0xA353,
				CHUNK_U_SCALE	= 0xA354,
				CHUNK_V_SCALE	= 0xA356,
				CHUNK_U_OFFSET	= 0xA358,
				CHUNK_V_OFFSET	= 0xA35A,
				CHUNK_M_ROTATE	= 0xA35C,
	        CHUNK_KEYFRAMER = 0xB000,
	            CHUNK_AMBIENTKEY    = 0xB001,
	            CHUNK_TRACKINFO = 0xB002,
	                CHUNK_TRACKOBJNAME  = 0xB010,
	                CHUNK_TRACKPIVOT    = 0xB013,
	                CHUNK_TRACKPOS      = 0xB020,
	                CHUNK_TRACKROTATE   = 0xB021,
	                CHUNK_TRACKSCALE    = 0xB022,
	                CHUNK_TRACKMORPH    = 0xB026,
	                CHUNK_TRACKHIDE     = 0xB029,
	                CHUNK_OBJNUMBER     = 0xB030,
	            CHUNK_TRACKCAMERA = 0xB003,
	                CHUNK_TRACKFOV  = 0xB023,
	                CHUNK_TRACKROLL = 0xB024,
	            CHUNK_TRACKCAMTGT = 0xB004,
	            CHUNK_TRACKLIGHT  = 0xB005,
	            CHUNK_
void GridPadCull::setupDefaults() {
  callGridOp = true;
  callPostChunkOp = true;
void GridPadCull::Algorithm(glm::i32vec3 chunkId,
                            glm::i32vec3 voxelWorldPosition, Chunk *inChunk,
                            Chunk *outChunk, u_int32_t dataIndex,
                            uint32_t channel, bool internalAccessible) {
  bool lValueFalse = false;
  bool lValueTrue = true;
  if (outChunk->chunkData[dataIndex] > 0.0005) {
    outChunk->empty = false;
  } else {
    outChunk->voxelCount--;
  }
void GridPadCull::PostChunkOp(Chunk *&inChunk, Chunk *&outChunk,
                              glm::i32vec3 chunkIdSecondary) {
  bool padded = false;
  if (outChunk->voxelCount == 0) {
    outChunk->empty = true;
  } else {
    outChunk->timeCreated = gridObjectPtr->simTime;
    {
      for (int i = -1 * chunksToPad; i <= chunksToPad; i++) {
        for (int j = -1 * chunksToPad; j <= chunksToPad; j++) {
          for (int k = -1 * chunksToPad; k <= chunksToPad; k++) {
 

                    (int)chunkIdSecondary.x + i, (int)chunkIdSecondary.y + j,
                    (int)chunkIdSecondary.z + k)) {
              currentTargetChannelObject->GetChunk((int)chunkIdSecondary.x + i,
                                                   (int)chunkIdSecondary.y + j,
                                                   (int)chunkIdSecondary.z + k)
                  ->okayToDelete = false;
            } else {
              currentTargetChannelObject->CreateChunk(
                  (int)chunkIdSecondary.x + i, (int)chunkIdSecondary.y + j,
                  (int)chunkIdSecondary.z + k);
              padded = true;
            }
          }
        }
      }
    }
  }
  if ((gridObjectPtr->simTime - outChunk->timeCreated) > 0.5) {
    outChunk->okayToDelete = true;
  }
  if ((outChunk->empty == true && outChunk->okayToDelete == true)) {
    currentTargetChannelObject->DeleteChunk(
        chunkIdSecondary.x, chunkIdSecondary.y, chunkIdSecondary.z);
  } else {
    if 
/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2011 Nokia Corporation and/or its subsidiary(-ies).
**
** Contact: Nokia Corporation (info@qt.nokia.com)
**
**
** GNU Lesser General Public License Usage
**
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** Please review the following information to ensure the GNU Lesser General
** Public License version 2.1 requirements will be met:
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
**
** Other Usage
**
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
** If you have questions regarding the use of this file, please contact
** Nokia at info@qt.nokia.com.
**
****

namespace Debugger {
namespace Internal {
QDataStream &operator<<(QDataStream &stream, const ThreadData &d)
    stream << (qint64)d.id;
    stream << d.address;
    stream << d.function;
    stream << d.fileName;
    stream << d.state;
    stream << d.lineNumber;
    stream << d.name;
    return stream;
QDataStream &operator>>(QDataStream &stream, ThreadData &d)
    qint64 id;
    stream >> id;
    d.id = id;
    stream >> d.address;
    stream >> d.function;
    stream >> d.fileName;
    stream >> d.state;
    stream >> d.lineNumber;
    stream >> d.name;
    return stream;
QDataStream &operator<<(QDataStream &stream, const Threads &threads)
    stream << (quint64)threads.count();
    for (int i = 0; i < threads.count(); i++)
    {
        const ThreadData &d = threads.at(i);
        stream << d;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, Threads &threads)
    quint64 count;
    stream >> count;
    threads.clear();
    for (quint64 i = 0; i < count; ++i)
 

        ThreadData d;
        stream >> d;
        threads.append(d);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrame &s)
    stream << (quint64)s.level;
    stream << s.function;
    stream << s.file;
    stream << s.from;
    stream << s.to;
    stream << s.line;
    stream << s.address;
    stream << s.usable;
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrame &s)
    quint64 level;
    stream >> level;
    s.level = level;
    stream >> s.function;
    stream >> s.file;
    stream >> s.from;
    stream >> s.to;
    stream >> s.line;
    stream >> s.address;
    stream >> s.usable;
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrames &frames)
    stream << (quint64)frames.count();
    for (int i = 0; i < frames.count(); i++)
    {
        const StackFrame &s = frames.at(i);
        stream << s;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrames &frames)
    qui

    stream >> count;
    frames.clear();
    for (quint64 i = 0; i < count; ++i)
    {
        StackFrame s;
        stream >> s;
        frames.append(s);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointResponse &s)
    stream << s.number;
    stream << s.condition;
    stream << s.ignoreCount;
    stream << s.fileName;
    stream << s.fullName;
    stream << s.lineNumber;
    stream << s.threadSpec;
    stream << s.functionName;
    stream << s.address;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointResponse &s)
    stream >> s.number;
    stream >> s.condition;
    stream >> s.ignoreCount;
    stream >> s.fileName;
    stream >> s.fullName;
    stream >> s.lineNumber;
    stream >> s.threadSpec;
    stream >> s.functionName;
    stream >> s.address;
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointParameters &s)
    stream << s.fileName;
    stream << s.condition;
    stream << quint64(s

    stream << quint64(s.lineNumber);
    stream << quint64(s.address);
    stream << s.functionName;
    stream << int(s.pathUsage);
    stream << s.tracepoint;
    stream << s.module;
    stream << s.command;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointParameters &s)
    quint64 t;
    QString str;
    QByteArray ba;
    bool b;
    stream >> str; s.fileName = str;
    stream >> ba; s.condition = ba;
    stream >> t; s.ignoreCount = t;
    stream >> t; s.lineNumber = t;
    stream >> t; s.address = t;
    stream >> str; s.functionName = str;
    stream >> t; s.pathUsage = static_cast<BreakpointPathUsage>(t);
    stream >> b; s.tracepoint = b;
    stream >> str ; s.module = str;
    stream >> str ; s.command = str;
    return stream;
QDataStream &operator<<(QDataStream &stream, const WatchData &wd)
    stream << wd.id;
    stream << wd.iname;
    stream << wd.exp;
    stream << wd.name;
    stream << wd.value;
    stream << wd.editvalue;
    stream << wd.

    stream << wd.valuetooltip;
    stream << wd.typeFormats;
    stream << wd.type;
    stream << wd.displayedType;
    stream << wd.variable;
    stream << wd.address;
    stream << wd.size;
    stream << wd.hasChildren;
    stream << wd.generation;
    stream << wd.valueEnabled;
    stream << wd.valueEditable;
    stream << wd.error;
    stream << wd.state;
    stream << wd.changed;
    return stream;
QDataStream &operator>>(QDataStream &stream, WatchData &wd)
    stream >> wd.id;
    stream >> wd.iname;
    stream >> wd.exp;
    stream >> wd.name;
    stream >> wd.value;
    stream >> wd.editvalue;
    stream >> wd.editformat;
    stream >> wd.valuetooltip;
    stream >> wd.typeFormats;
    stream >> wd.type;
    stream >> wd.displayedType;
    stream >> wd.variable;
    stream >> wd.address;
    stream >> wd.size;
    stream >> wd.hasChildren;
    stream >> wd.generation;
    stream >> wd.valueEnabled;
    stream >> wd.valueEditable;
    stream >> wd.error;
    stream >> wd.state;
  Author: Niels A.D
{%MainUnit lpinterpreter.pas}
ocIncCall_Var: DoIncCall_Var();
ocIncCall_PVar: DoIncCall_PVar();
ocIncCall_Ptr: DoIncCall_Ptr();
ocInvokeImported_Var: DoInvokeImported_Var();
ocInvokeImported_PVar: DoInvokeImported_PVar();
ocInvokeImported_Ptr: DoInvokeImported_Ptr();
ocInvokeImported_Var_Stk: DoInvokeImported_Var_Stk();
ocInvokeImported_Var_PStk: DoInvokeImported_Var_PStk();
ocInvokeImported_Var_Var: DoInvokeImported_Var_Var();
ocInvokeImported_Var_PVar: DoInvokeImported_Var_PVar();
ocInvokeImported_Var_Ptr: DoInvokeImported_Var_Ptr();
ocInvokeImported_PVar_Stk: DoInvokeImported_PVar_Stk();
ocInvokeImported_PVar_PStk: DoInvokeImported_PVar_PStk();
ocInvokeImported_PVar_Var: DoInvokeImported_PVar_Var();
ocInvokeImported_PVar_PVar: DoInvokeImported_PVar_PVar();
ocInvokeImported_PVar_Ptr: DoInvokeImported_PVar_Ptr();
ocInvokeImported_Ptr_Stk: DoInvokeImported_Ptr_Stk();
ocInvokeImported_Ptr_PStk: DoInvokeImported_Ptr_PStk();
ocInvokeImported_Ptr_Var: DoInvokeImported_P
namespace chromeos {
static NetworkHandler* g_network_handler = NULL;
NetworkHandler::NetworkHandler()
    : task_runner_(base::ThreadTaskRunnerHandle::Get()) {
  CHECK(DBusThreadManager::IsInitialized());
  network_state_handler_.reset(new NetworkStateHandler());
  network_device_handler_.reset(new NetworkDeviceHandlerImpl());
  network_profile_handler_.reset(new NetworkProfileHandler());
  network_configuration_handler_.reset(new NetworkConfigurationHandler());
  managed_network_configuration_handler_.reset(
      new ManagedNetworkConfigurationHandlerImpl());
  prohibited_technologies_handler_.reset(new ProhibitedTechnologiesHandler());
  if (CertLoader::IsInitialized()) {
    auto_connect_handler_.reset(new AutoConnectHandler());
    network_cert_migrator_.reset(new NetworkCertMigrator());
    client_cert_resolver_.reset(new ClientCertResolver());
  }
  network_activation_handler_.reset(new NetworkActivationHandler());
  network_connection_handler_.reset(new NetworkConnectionHandle

  network_sms_handler_.reset(new NetworkSmsHandler());
  geolocation_handler_.reset(new GeolocationHandler());
NetworkHandler::~NetworkHandler() {
  network_state_handler_->Shutdown();
void NetworkHandler::Init() {
  network_state_handler_->InitShillPropertyHandler();
  network_device_handler_->Init(network_state_handler_.get());
  network_profile_handler_->Init();
  network_configuration_handler_->Init(network_state_handler_.get(),
                                       network_device_handler_.get());
  managed_network_configuration_handler_->Init(
      network_state_handler_.get(), network_profile_handler_.get(),
      network_configuration_handler_.get(), network_device_handler_.get(),
      prohibited_technologies_handler_.get());
  network_connection_handler_->Init(
      network_state_handler_.get(),
      network_configuration_handler_.get(),
      managed_network_configuration_handler_.get());
  if (network_cert_migrator_)
    network_cert_migrator_->Init(network_state_handle

  if (client_cert_resolver_) {
    client_cert_resolver_->Init(network_state_handler_.get(),
                                managed_network_configuration_handler_.get());
  }
  if (auto_connect_handler_) {
    auto_connect_handler_->Init(client_cert_resolver_.get(),
                                network_connection_handler_.get(),
                                network_state_handler_.get(),
                                managed_network_configuration_handler_.get());
  }
  prohibited_technologies_handler_->Init(
      managed_network_configuration_handler_.get(),
      network_state_handler_.get());
  network_sms_handler_->Init();
  geolocation_handler_->Init();
void NetworkHandler::Initialize() {
  CHECK(!g_network_handler);
  g_network_handler = new NetworkHandler();
  g_network_handler->Init();
void NetworkHandler::Shutdown() {
  CHECK(g_network_handler);
  delete g_network_handler;
  g_network_handler = NULL;
NetworkHandler* NetworkHandler::Get() {
  CHECK(g_network_handler)
 

  return g_network_handler;
bool NetworkHandler::IsInitialized() {
  return g_network_handler;
NetworkStateHandler* NetworkHandler::network_state_handler() {
  return network_state_handler_.get();
NetworkDeviceHandler* NetworkHandler::network_device_handler() {
  return network_device_handler_.get();
NetworkProfileHandler* NetworkHandler::network_profile_handler() {
  return network_profile_handler_.get();
NetworkConfigurationHandler* NetworkHandler::network_configuration_handler() {
  return network_configuration_handler_.get();
ManagedNetworkConfigurationHandler*
NetworkHandler::managed_network_configuration_handler() {
  return managed_network_configuration_handler_.get();
NetworkActivationHandler* NetworkHandler::network_activation_handler() {
  return network_activation_handler_.get();
NetworkConnectionHandler* NetworkHandler::network_connection_handler() {
  return network_connection_handler_.get();
NetworkSmsHandler* NetworkHandler::network_sms_handler() {
  return network_sms_
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
generic_option_gen_class::generate_generic_option(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (has_short_option)
    {
      stream << "case '";
      generate_string (short_option, stream, indent + indent_str.length ());
      stream << "':	/* ";
      generate_string (option_comment, stream, indent + indent_str.length ());
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "/* ";
      generate_string (option_comment, stream, indent + indent_str.length ());
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      generate_string (gen_else, stream, indent + indent_str.length ());
      stream << "if (strcmp (long_options[option_index].name, \"";
      generate_string (long_option, stream, indent + indent_str.length ());
      stream << "\") == 0)";
      stream << "\n";
      

      stream << "{";
      stream << "\n";
      stream << indent_str;
    }
  stream << "  if (local_args_info.";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given)";
  stream << "\n";
  stream << indent_str;
  stream << "    {";
  stream << "\n";
  stream << indent_str;
  stream << "      fprintf (stderr, \"%s: `--";
  generate_string (long_option, stream, indent + indent_str.length ());
  stream << "'";
  if (has_short_option)
    {
      stream << " (`-";
      generate_string (short_option, stream, indent + indent_str.length ());
      stream << "')";
    }
  stream << " option given more than once%s\\n\", ";
  generate_string (package_var_name, stream, indent + indent_str.length ());
  stream << ", (additional_error ? additional_error : \"\"));";
  stream << "\n";
  stream << indent_str;
  stream << "      goto failure;";
  stream << "\n";
  stream << indent_str;
  stream << "    }";
  stream << "\n";
  stream << indent_str;
  if (op

    {
      stream << "  if ((found = check_possible_values((optarg ? optarg : ";
      if (( defaultval != "" ))
        {
          stream << "\"";
          generate_string (defaultval, stream, indent + indent_str.length ());
          stream << "\" ";
        }
      else
        {
          stream << "0 ";
        }
      stream << "), ";
      generate_string (option_values, stream, indent + indent_str.length ());
      stream << ")) < 0)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      fprintf (stderr, \"%s: %s argument, \\\"%s\\\", for option `--";
      generate_string (long_option, stream, indent + indent_str.length ());
      stream << "'";
      if (has_short_option)
        {
          stream << " (`-";
          generate_string (short_option, stream, indent + indent_str.length ());
          stream << "')";
        }
      stream << "%s\\n\", ";
      generate_string (pac

      stream << ", (found == -2) ? \"ambiguous\" : \"invalid\", optarg, (additional_error ? additional_error : \"\"));";
      stream << "\n";
      stream << indent_str;
      stream << "      goto failure;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
    }
  stream << "  if (args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given && ! override)";
  stream << "\n";
  stream << indent_str;
  stream << "    continue;";
  stream << "\n";
  stream << indent_str;
  stream << "  local_args_info.";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given = 1;";
  stream << "\n";
  stream << indent_str;
  stream << "  args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given = 1;";
  generate_string (update_group_count, stream, indent + indent_str.length ());
  stream 
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
RepoStateWidget::RepoStateWidget()
    repo = NULL;
    setupUi();
    RM::RepoMan& rm = MacGitver::repoMan();
    connect(&rm,    &RM::RepoMan::refMoved,
            this,   &RepoStateWidget::onUpdateHEAD);
    connect(&rm,    &RM::RepoMan::repositoryActivated,
            this,   &RepoStateWidget::repos

    connect(&rm,    &RM::RepoMan::repositoryDeactivated,
            this,   &RepoStateWidget::repositoryDeactivated);
void RepoStateWidget::repositoryActivated(RM::Repo* info)
    if( repo != info )
    {
        repo = info;
        setRepoState();
    }
void RepoStateWidget::repositoryDeactivated(RM::Repo* info)
    if( repo == info )
    {
        repo = NULL;
        setRepoState();
    }
void RepoStateWidget::setRepoState()
    txtState->hide();
    txtRepo->setText( repo ? repo->displayAlias() : QString() );
    onUpdateHEAD( repo, NULL );
void RepoStateWidget::onUpdateHEAD(RM::Repo* ownerRepo, RM::Ref* ref)
    if ( ownerRepo != repo ) {
        return;
    }
    if ( ref && ref->name() != QStringLiteral("HEAD") ) {
        return;
    }
    txtBranch->setText( repo ? repo->branchDisplay() : QString() );
static inline QLabel* pixmapLabel(const char* name)
    Heaven::IconRef iconRef(name, 16);
    QLabel* l = new QLabel;
    l->setPixmap(iconRef.icon().pixmap());
    return l;
class World;
struct Chunk
    Chunk() {}
    Chunk(World *world, signed int x, signed int y);
    signed int x;
    signed int y;
	/*
	float x;
	float y;
	*/
	Cell cells[CHUNK_SIZE * CHUNK_SIZE];
    WeakSet<Particle*> particles;
    GLuint tex;
    Chunk *neighbors[4];
    Chunk *neighbor(World *world, Direction i);
    Chunk *find_chunk(signed int tx, signed int ty);
    void set_pixel(signed int px, signed int py);
public:
    void *operator new(std::size_t s)
	{
		assert(s == sizeof(Chunk));
		if (next_chunk == CHUNK_ALLOC_SIZE)
		{
			chunks.push_back(new Chunk[CHUNK_ALLOC_SIZE]);
			next_chunk = 0;
		}
		allocated++;
        return chunks.back() + next_chunk++;
	}
    void operator delete(void *chunk, std::size_t s)
	{
		allocated--;
		if (!allocated)
		{
			std::vector<Chunk*>::iterator i = chunks.begin();
			while (i != chunks.end())
			{
				delete[] *i;
				i++;
			}
            chunks.clear();
			next_chunk = CHUNK_ALLOC_SIZE;
		}
	}
protected:
	static std::vector<Chunk*> ch
using ::memorychunk::MemoryChunk;
using ::std::make_unique;
using ::std::move;
using ::std::fill;
using ::std::swap;
using ::std::vector;
class MemoryChunkTests : public ::testing::Test, MemLeakTest {
};
TEST_F(MemoryChunkTests, IsAbleToCreateChunkAndDestroyItAsLocalVariable) {
  {
    MemoryChunk chunk{64};
    fill(chunk.MemoryAt(0), chunk.MemoryAt(63) + 1, 77);
    EXPECT_EQ(77, *chunk.MemoryAt(0));
    EXPECT_EQ(77, *chunk.MemoryAt(45));
    EXPECT_EQ(77, *chunk.MemoryAt(63));
  }
TEST_F(MemoryChunkTests, IsAbleToCreateChunkAndDestroyItAsHeapVariable) {
  MemoryChunk *pchunk = new MemoryChunk{1024};
  *pchunk->MemoryAt(0) = 88;
  *pchunk->MemoryAt(1023) = 99;
  EXPECT_EQ(88, *pchunk->MemoryAt(0));
  EXPECT_EQ(99, *pchunk->MemoryAt(1023));
  delete pchunk;
TEST_F(MemoryChunkTests, IsAbleToMoveChunks) {
  MemoryChunk chunk{1024};
  int8_t *ptr = chunk.MemoryAt(0);
  MemoryChunk moved_chunk = move(chunk);
  EXPECT_EQ(nullptr, chunk.MemoryAt(0));
  EXPECT_EQ(0, chunk.ChunkSize());
  EX

  EXPECT_EQ(ptr, moved_chunk.MemoryAt(0));
TEST_F(MemoryChunkTests, IsAbleToCopyConstructChunks) {
  MemoryChunk chunk{1024};
  int8_t *ptr = chunk.MemoryAt(0);
  fill(chunk.MemoryAt(0), chunk.MemoryAt(1023) + 1, 111);
  MemoryChunk copied_chunk{chunk};
  EXPECT_NE(nullptr, chunk.MemoryAt(0));
  EXPECT_NE(nullptr, copied_chunk.MemoryAt(0));
  EXPECT_EQ(1024, chunk.ChunkSize());
  EXPECT_EQ(1024, copied_chunk.ChunkSize());
  EXPECT_EQ(ptr, chunk.MemoryAt(0));
  EXPECT_NE(ptr, copied_chunk.MemoryAt(0));
  EXPECT_EQ(111, *chunk.MemoryAt(768));
  EXPECT_EQ(111, *copied_chunk.MemoryAt(768));
  fill(chunk.MemoryAt(0), chunk.MemoryAt(1023) + 1, 55);
  EXPECT_EQ(55, *chunk.MemoryAt(333));
  EXPECT_EQ(111, *copied_chunk.MemoryAt(333));
  fill(copied_chunk.MemoryAt(0), copied_chunk.MemoryAt(1023) + 1, 67);
  EXPECT_EQ(55, *chunk.MemoryAt(333));
  EXPECT_EQ(67, *copied_chunk.MemoryAt(333));
TEST_F(MemoryChunkTests, IsAbleToCopyMoveChunks) {
  MemoryChunk chunk{2048};
  int8_t *ptr = chunk.Memory

  fill(chunk.MemoryAt(0), chunk.MemoryAt(2047) + 1, 13);
  MemoryChunk copied_chunk{move(chunk)};
  EXPECT_EQ(nullptr, chunk.MemoryAt(0));
  EXPECT_NE(nullptr, copied_chunk.MemoryAt(0));
  EXPECT_EQ(0, chunk.ChunkSize());
  EXPECT_EQ(2048, copied_chunk.ChunkSize());
  EXPECT_EQ(ptr, copied_chunk.MemoryAt(0));
  EXPECT_EQ(13, *copied_chunk.MemoryAt(768));
TEST_F(MemoryChunkTests, IsAbleToCopyAssignChunks) {
  MemoryChunk chunk{1024};
  int8_t *ptr = chunk.MemoryAt(0);
  fill(chunk.MemoryAt(0), chunk.MemoryAt(1023) + 1, 111);
  MemoryChunk copied_chunk = chunk;
  EXPECT_NE(nullptr, chunk.MemoryAt(0));
  EXPECT_NE(nullptr, copied_chunk.MemoryAt(0));
  EXPECT_EQ(1024, chunk.ChunkSize());
  EXPECT_EQ(1024, copied_chunk.ChunkSize());
  EXPECT_EQ(ptr, chunk.MemoryAt(0));
  EXPECT_NE(ptr, copied_chunk.MemoryAt(0));
  EXPECT_EQ(111, *chunk.MemoryAt(768));
  EXPECT_EQ(111, *copied_chunk.MemoryAt(768));
  fill(chunk.MemoryAt(0), chunk.MemoryAt(1023) + 1, 55);
  EXPECT_EQ(55, *chunk.MemoryAt(333)

  EXPECT_EQ(111, *copied_chunk.MemoryAt(333));
  fill(copied_chunk.MemoryAt(0), copied_chunk.MemoryAt(1023) + 1, 67);
  EXPECT_EQ(55, *chunk.MemoryAt(333));
  EXPECT_EQ(67, *copied_chunk.MemoryAt(333));
TEST_F(MemoryChunkTests, IsSelfAssignableAware) {
  int8_t *ptr;
  {
    MemoryChunk chunk{512};
    ptr = chunk.MemoryAt(0);
    chunk = chunk;
    EXPECT_EQ(512, chunk.ChunkSize());
    EXPECT_EQ(ptr, chunk.MemoryAt(0));
    fill(chunk.MemoryAt(0), chunk.MemoryAt(511) + 1, 33);
    EXPECT_EQ(33, *chunk.MemoryAt(44));
  }
  {
    MemoryChunk chunk2{512};
    EXPECT_EQ(512, chunk2.ChunkSize());
  }
TEST_F(MemoryChunkTests, IsSelfMoveAssignableAware) {
  int8_t *ptr;
  {
    MemoryChunk chunk{512};
    ptr = chunk.MemoryAt(0);
    chunk = move(chunk);
    EXPECT_EQ(512, chunk.ChunkSize());
    EXPECT_EQ(ptr, chunk.MemoryAt(0));
    fill(chunk.MemoryAt(0), chunk.MemoryAt(511) + 1, 33);
    EXPECT_EQ(33, *chunk.MemoryAt(44));
  }
TEST_F(MemoryChunkTests, IsAbleToSwapChunks) {
  {
    Memo

    MemoryChunk chunk2{256};
    int8_t *ptr = chunk.MemoryAt(0);
    int8_t *ptr2 = chunk2.MemoryAt(0);
    swap(chunk, chunk2);
    EXPECT_EQ(256, chunk.ChunkSize());
    EXPECT_EQ(768, chunk2.ChunkSize());
    EXPECT_EQ(ptr2, chunk.MemoryAt(0));
    EXPECT_EQ(ptr, chunk2.MemoryAt(0));
    fill(chunk.MemoryAt(0), chunk.MemoryAt(255) + 1, 63);
    EXPECT_EQ(63, *chunk.MemoryAt(44));
    fill(chunk2.MemoryAt(0), chunk2.MemoryAt(767) + 1, 41);
    EXPECT_EQ(41, *chunk2.MemoryAt(46));
  }
TEST_F(MemoryChunkTests, IsAbleEmplaceChunksIntoVector) {
  vector <MemoryChunk> chunks;
  chunks.emplace_back(4096);
  chunks.emplace_back(256);
  MemoryChunk &chunk = chunks[0];
  MemoryChunk &chunk2 = chunks[1];
  int8_t *ptr = chunk.MemoryAt(0);
  int8_t *ptr2 = chunk2.MemoryAt(0);
  swap(chunk, chunk2);
  EXPECT_EQ(256, chunks[0].ChunkSize());
  EXPECT_EQ(4096, chunks[1].ChunkSize());
  EXPECT_EQ(ptr2, chunk.MemoryAt(0));
  EXPECT_EQ(ptr, chunk2.MemoryAt(0));
  fill(chunk.MemoryAt(0), chunk.Memory
struct InterfaceActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct InterfaceFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct InterfaceActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
	

		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R, typename T1>
struct InterfaceFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct InterfaceActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct InterfaceFuncInvoker2
	typede

	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3>
struct InterfaceActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct InterfaceFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface

	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct InterfaceActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct InterfaceFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvo

		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5

	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct InterfaceActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct InterfaceActionInvoker7
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline void Invoke

	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct InterfaceFuncInvoker8
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, T8, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct InterfaceFuncInvoker9
	ty
namespace ppapi {
enum ApiID {
  API_ID_NONE = 0,
  API_ID_PPB_AUDIO = 1,
  API_ID_PPB_AUDIO_CONFIG,
  API_ID_PPB_AUDIO_INPUT_DEV,
  API_ID_PPB_BROKER,
  API_ID_PPB_BUFFER,
  API_ID_PPB_CONTEXT_3D,
  API_ID_PPB_CORE,
  API_ID_PPB_CURSORCONTROL,
  API_ID_PPB_FILE_CHOOSER,
  API_ID_PPB_FILE_IO,
  API_ID_PPB_FILE_REF,
  API_ID_PPB_FILE_SYSTEM,
  API_ID_PPB_FLASH,
  API_ID_PPB_FLASH_CLIPBOARD,
  API_ID_PPB_FLASH_FILE_FILEREF,
  API_ID_PPB_FLASH_FILE_MODULELOCAL,
  API_ID_PPB_FLASH_MENU,
  API_ID_PPB_FLASH_NETCONNECTOR,
  API_ID_PPB_FONT,
  API_ID_PPB_GRAPHICS_2D,
  API_ID_PPB_GRAPHICS_3D,
  API_ID_PPB_IMAGE_DATA,
  API_ID_PPB_INSTANCE,
  API_ID_PPB_INSTANCE_PRIVATE,
  API_ID_PPB_OPENGLES2,
  API_ID_PPB_PDF,
  API_ID_PPB_SURFACE_3D,
  API_ID_PPB_TCPSOCKET_PRIVATE,
  API_ID_PPB_TESTING,
  API_ID_PPB_TEXT_INPUT,
  API_ID_PPB_UDPSOCKET_PRIVATE,
  API_ID_PPB_URL_LOADER,
  API_ID_PPB_URL_RESPONSE_INFO,
  API_ID_PPB_VAR_ARRAY_BUFFER,
  API_ID_PPB_VAR_DEPRECATED,
  API_ID_PPB_VIDEO_CAPTURE_DEV,
  
namespace llvm {
class raw_ostream;
namespace pdb {
class PDBSymDumper {
public:
  PDBSymDumper(bool ShouldRequireImpl);
  virtual ~PDBSymDumper();
  virtual void dump(const PDBSymbolAnnotation &Symbol);
  virtual void dump(const PDBSymbolBlock &Symbol);
  virtual void dump(const PDBSymbolCompiland &Symbol);
  virtual void dump(const PDBSymbolCompilandDetails &Symbol);
  virtual void dump(const PDBSymbolCompilandEnv &Symbol);
  virtual void dump(const PDBSymbolCustom &Symbol);
  virtual void dump(const PDBSymbolData &Symbol);
  virtual void dump(const PDBSymbolExe &Symbol);
  virtual void dump(const PDBSymbolFunc &Symbol);
  virtual void dump(const PDBSymbolFuncDebugEnd &Symbol);
  virtual void dump(const PDBSymbolFuncDebugStart &Symbol);
  virtual void dump(const PDBSymbolLabel &Symbol);
  virtual void dump(const PDBSymbolPublicSymbol &Symbol);
  virtual void dump(const PDBSymbolThunk &Symbol);
  virtual void dump(const PDBSymbolTypeArray &Symbol);
  virtual void dump(const PDBSymbolT
using namespace RepoIce;
class RepoServer : virtual public Ice::Application {
	public:
		virtual int run(int, char * []) {
			shutdownOnInterrupt();
			
			RepoApiI::_adapter = communicator()->createObjectAdapterWithEndpoints("RepoApiAdapter", "default -p 6667");
			qrRepo::RepoApi repoApi("../qrgui/save");
			Ice::ObjectPtr servant = new ::RepoIce::RepoApiI(repoApi);
			RepoApiI::_adapter->add(servant, communicator()->stringToIdentity("RepoApi") );
			RepoApiI::_adapter->activate();
			communicator()->waitForShutdown();
			if (interrupted()) {
				qDebug() << appName() << ": received signal, shutting down" << endl;
			}
			RepoApiI::_adapter = 0;
			return 0;
		}
};
int main(int argc, char **argv)
	QTextStream out(stdout);
	qrRepo::RepoApi repoApi("../qrgui/save");
	qReal::Id diagramId = repoApi.children(qReal::ROOT_ID).at(0);
	qReal::IdList list = repoApi.children(diagramId);
	out << repoApi.name(diagramId) << " " << list.size() << endl;
	out << "String representation: " << diagramId
namespace lldb {
class LLDB_API SBAddress;
class LLDB_API SBBlock;
class LLDB_API SBBreakpoint;
class LLDB_API SBBreakpointLocation;
class LLDB_API SBBroadcaster;
class LLDB_API SBCommand;
class LLDB_API SBCommandInterpreter;
class LLDB_API SBCommandInterpreterRunOptions;
class LLDB_API SBCommandPluginInterface;
class LLDB_API SBCommandReturnObject;
class LLDB_API SBCommunication;
class LLDB_API SBCompileUnit;
class LLDB_API SBData;
class LLDB_API SBDebugger;
class LLDB_API SBDeclaration;
class LLDB_API SBError;
class LLDB_API SBEvent;
class LLDB_API SBEventList;
class LLDB_API SBExecutionContext;
class LLDB_API SBExpressionOptions;
class LLDB_API SBFileSpec;
class LLDB_API SBFileSpecList;
class LLDB_API SBFrame;
class LLDB_API SBFunction;
class LLDB_API SBHostOS;
class LLDB_API SBInstruction;
class LLDB_API SBInstructionList;
class LLDB_API SBLanguageRuntime;
class LLDB_API SBLaunchInfo;
class LLDB_API SBLineEntry;
class LLDB_API SBListener;
class LLDB_API SBModule;
class LLDB_API SBM
extern "C" {
	Oni_ModelPtr Oni_Model_new(){
		Oni::Model* model = new Oni::Model();
		
		return (Oni_ModelPtr)model;
	}
	void Oni_Model_delete(Oni_ModelPtr obj){
		printf("======DELETING MODEL\n");
		Oni::Model* model = (Oni::Model*)(obj);
		
		delete model;
	}
	void Oni_Model_markgc(Oni_ModelPtr obj){
		printf("======MARK FOR COLLECTION\n");
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->setVisible(false);
	}
	void Oni_Model_initialize(Oni_ModelPtr obj, Ogre_WindowPtr obj2, char* name, char* filename, Ogre_NodePtr parent){
		Oni::Model* model = (Oni::Model*)(obj);
		GameApplication* game = (GameApplication*)obj2;
		
		std::string cpp_name(name);
		std::string cpp_filename(filename);
		
		Ogre::Node* parentNode = (Ogre::Node*)(parent);
		
		model->initialize(game->getSceneMgr(), cpp_name, cpp_filename, parentNode);
	}
	void Oni_Model_update(Oni_ModelPtr obj, double dt){
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->update(dt);
	}
	const char* Oni_Model_getName(Oni_ModelP

		Oni::Model* model = (Oni::Model*)(obj);
		
		return model->getName().c_str();
	}
	Ogre_NodePtr Oni_Model_getParentNode(Oni_ModelPtr obj){
		Oni::Model* model = (Oni::Model*)(obj);
		
		Ogre::Node* node = model->getEntity()->getParentNode();
		return (Ogre_NodePtr)(node);
	}
	void Oni_Model_attachObjectToBone(Oni_ModelPtr obj, char* name, Oni_ModelPtr obj2){
		Oni::Model* model = (Oni::Model*)(obj);
		Oni::Model* otherModel = (Oni::Model*)(obj2);
		
		std::string cpp_name(name);
		model->attachObjectToBone(cpp_name, otherModel);
	}
	void Oni_Model_detachObjectFromBone(Oni_ModelPtr obj, Oni_ModelPtr obj2){
		Oni::Model* model = (Oni::Model*)(obj);
		Oni::Model* otherModel = (Oni::Model*)(obj2);
		
		model->detachObjectFromBone(otherModel);
	}
	int Oni_Model_isAttachedToBone(Oni_ModelPtr obj){
		Oni::Model* model = (Oni::Model*)(obj);
		
		if(model->isAttachedToBone())
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
	double Oni_Model_getBoundingBoxWidth(Oni_ModelPtr obj){
		Oni::Mo

		
		return model->getBoundingBoxWidth();
	}
	double Oni_Model_getBoundingBoxDepth(Oni_ModelPtr obj){
		Oni::Model* model = (Oni::Model*)(obj);
		
		return model->getBoundingBoxDepth();
	}
	double Oni_Model_getBoundingBoxHeight(Oni_ModelPtr obj){
		Oni::Model* model = (Oni::Model*)(obj);
		
		return model->getBoundingBoxHeight();
	}
	int Oni_Model_getVisible(Oni_ModelPtr obj){
		Oni::Model* model = (Oni::Model*)(obj);
		
		if(model->getVisible())
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
	void Oni_Model_setVisible(Oni_ModelPtr obj, int visible){
		Oni::Model* model = (Oni::Model*)(obj);
		
		if(visible)
		{
			model->setVisible(true);
		}
		else
		{
			model->setVisible(false);
		}
	}
	int Oni_Model_getCastShadows(Oni_ModelPtr obj){
		Oni::Model* model = (Oni::Model*)(obj);
		
		if(model->getCastShadows()){
			return 1;
		}
		else{
			return 0;
		}
	}
	void Oni_Model_setCastShadows(Oni_ModelPtr obj, int enabled){
		Oni::Model* model = (Oni::Model*)(obj);
		
		if(enabled){
		

		}
		else{
			model->setCastShadows(false);
		}
	}
	void Oni_Model_getPosition(Oni_ModelPtr obj, double* vector){
		Oni::Model* model = (Oni::Model*)(obj);
		
		Ogre::Vector3 position = model->getPosition();
		
		vector[0] = position.x;
		vector[1] = position.y;
		vector[2] = position.z;
	}
	void Oni_Model_setPosition(Oni_ModelPtr obj, double x, double y, double z){
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->setPosition(x,y,z);
	}
	void Oni_Model_translate(Oni_ModelPtr obj, double x, double y, double z, OniTransformSpace ts){
		Oni::Model* model = (Oni::Model*)(obj);
		
		switch(ts){
			case LOCAL:
				model->translate(x,y,z, Ogre::Node::TS_LOCAL);
				break;
			case PARENT:
				model->translate(x,y,z, Ogre::Node::TS_PARENT);
				break;
			case WORLD:
				model->translate(x,y,z, Ogre::Node::TS_WORLD);
				break;
		}
	}
	void Oni_Model_scale(Oni_ModelPtr obj, double x, double y, double z){
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->scale(x,y,z);
	}
	void Oni_Mode

		Oni::Model* model = (Oni::Model*)(obj);
		
		Ogre::Vector3 scale = model->getScale();
		
		vector[0] = scale.x;
		vector[1] = scale.y;
		vector[2] = scale.z;
	}
	void Oni_Model_setScale(Oni_ModelPtr obj, double x, double y, double z){
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->setScale(x,y,z);
	}
	void Oni_Model_resetOrientation(Oni_ModelPtr obj)
	{
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->resetOrientation();
	}
	void Oni_Model_setOrientation(Oni_ModelPtr obj, double w, double x, double y, double z)
	{
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->setOrientation(w,x,y,z);
	}
	void Oni_Model_rotate(Oni_ModelPtr obj, double w, double x, double y, double z)
	{
		Oni::Model* model = (Oni::Model*)(obj);
		
		Ogre::Quaternion quat = Ogre::Quaternion(w,x,y,z);
		model->rotate(quat);
	}
	void Oni_Model_pitch(Oni_ModelPtr obj, double radians){
		Oni::Model* model = (Oni::Model*)(obj);
		
		model->pitch(Ogre::Radian(radians));
	}
	void Oni_Model_yaw(Oni_ModelPt
class IChannelLocatorObserver;
class ChannelLocatorConnection : public IChannelLocatorConnection,
                                 public omni_thread
    enum EConnectionStatus{ CONNECTED, DISCONNECTED, RESTARTED };
public:
    ChannelLocatorConnection( const std::string& channel_locator_address );
    ~ChannelLocatorConnection();
    virtual void* run_undetached( void* );
    virtual std::string get_channel_locator_ior();
    virtual TA_Base_Core::IChannelLocator_var get_channel_locator();
    virtual CosNA::EventChannel_var get_channel( const std::string& name );
    virtual void register_observer( IChannelLocatorObserver* observer );
    virtual void deregister_observer( IChannelLocatorObserver* observer );
    void terminate();
public:
    void notify_observer( EConnectionStatus status );
public:
    volatile bool m_running;
    boost::log::sources::logger m_log;
    std::string m_channel_locator_address;
    std::string m_channel_locator_ior;
    TA_Base_Core::IChannelLocator_var 
longSample conv_split_unrolled4_sep_result(sample* data, sample* coeffs, int len, int last_idx)
{      
    sample *dp = data;
    sample *cp = coeffs;
    longSample a[4] = {0.0, 0.0, 0.0, 0.0};
   
    dp = data+last_idx;
    int cnt = len - last_idx;
    for (; cnt >= 4; cnt -= 4)
    {
        a[0] += (longSample)*dp++ * (longSample)*cp++;
        a[1] += (longSample)*dp++ * (longSample)*cp++;
        a[2] += (longSample)*dp++ * (longSample)*cp++;
        a[3] += (longSample)*dp++ * (longSample)*cp++;
    }   
    while (cnt--)
    {
        a[0] += (longSample)*dp++ * (longSample)*cp++; 
    }
    
    dp = data;
    cnt = last_idx;
    for (; cnt >= 4; cnt -= 4)
    {
        a[0] += (longSample)*dp++ * (longSample)*cp++;
        a[1] += (longSample)*dp++ * (longSample)*cp++;
        a[2] += (longSample)*dp++ * (longSample)*cp++;
        a[3] += (longSample)*dp++ * (longSample)*cp++;
    }
    while (cnt--)
    {
        a[1] += (longSample)*dp++ * (longSample)*cp++; 
    }
    r

RegisterImplementation r1("convSplitU4SRLD", conv_split_unrolled4_sep_result, 4, true, true);
longSample conv_split_unrolled4_sep_result_no_long(sample* data, sample* coeffs, int len, int last_idx)
{      
    sample *dp = data;
    sample *cp = coeffs;
    longSample a[4] = {0.0, 0.0, 0.0, 0.0};
   
    dp = data+last_idx;
    int cnt = len - last_idx;
    for (; cnt >= 4; cnt -= 4)
    {
        a[0] += *dp++ * *cp++;
        a[1] += *dp++ * *cp++;
        a[2] += *dp++ * *cp++;
        a[3] += *dp++ * *cp++;
    }   
    while (cnt--)
    {
        a[0] += *dp++ * *cp++; 
    }
    
    dp = data;
    cnt = last_idx;
    for (; cnt >= 4; cnt -= 4)
    {
        a[0] += *dp++ * *cp++;
        a[1] += *dp++ * *cp++;
        a[2] += *dp++ * *cp++;
        a[3] += *dp++ * *cp++;
    }
    while (cnt--)
    {
        a[1] += *dp++ * *cp++; 
    }
    return a[0] + a[1] + a[2] + a[3];
RegisterImplementation r2("convSplitU4SRNLD", conv_split_unrolled4_sep_result_no_long, 4, true, false);


{      
    sample *dp = data;
    sample *cp = coeffs;
    longSample a[2] = {0.0, 0.0};
   
    dp = data+last_idx;
    int cnt = len - last_idx;
    for (; cnt >= 2; cnt -= 2)
    {
        a[0] += (longSample)*dp++ * (longSample)*cp++;
        a[1] += (longSample)*dp++ * (longSample)*cp++;
    }   
    if (cnt)
    {
        a[0] += (longSample)*dp++ * (longSample)*cp++; 
    }
    
    dp = data;
    cnt = last_idx;
    for (; cnt >= 2; cnt -= 2)
    {
        a[0] += (longSample)*dp++ * (longSample)*cp++;
        a[1] += (longSample)*dp++ * (longSample)*cp++;
    }
    if (cnt)
    {
        a[1] += (longSample)*dp++ * (longSample)*cp++; 
    }
    return a[0] + a[1];
RegisterImplementation r3("convSplitU2SRNLD", conv_split_unrolled2_sep_result, 2, true, true);
longSample conv_split_unrolled4_no_sep_result(sample* data, sample* coeffs, int len, int last_idx)
{      
    sample *dp = data;
    sample *cp = coeffs;
    longSample a = 0.0;
   
    dp = data+last_idx;
    int cnt = 

    for (; cnt >= 4; cnt -= 4)
    {
        a += (longSample)*dp++ * (longSample)*cp++;
        a += (longSample)*dp++ * (longSample)*cp++;
        a += (longSample)*dp++ * (longSample)*cp++;
        a += (longSample)*dp++ * (longSample)*cp++;
    }   
    while (cnt--)
    {
        a += (longSample)*dp++ * (longSample)*cp++; 
    }
    
    dp = data;
    cnt = last_idx;
    for (; cnt >= 4; cnt -= 4)
    {
        a += (longSample)*dp++ * (longSample)*cp++;
        a += (longSample)*dp++ * (longSample)*cp++;
        a += (longSample)*dp++ * (longSample)*cp++;
        a += (longSample)*dp++ * (longSample)*cp++;
    }
    while (cnt--)
    {
        a += (longSample)*dp++ * (longSample)*cp++; 
    }
    return a;
RegisterImplementation r4("convSplitU4SRNLD", conv_split_unrolled4_no_sep_result, 4, false, true);
longSample conv_split(sample* data, sample* coeffs, int len, int last_idx)
{      
    sample *dp = data;
    sample *cp = coeffs;
    longSample a = 0.0;
   
    dp = data+la

    int cnt = len - last_idx;
    for (; cnt >= 1; cnt -= 1)
    {
        a += (longSample)*dp++ * (longSample)*cp++;
    }   
    dp = data;
    cnt = last_idx;
    for (; cnt >= 1; cnt -= 1)
    {
        a += (longSample)*dp++ * (longSample)*cp++;   
    }
    return a;
RegisterImplementation r5("convSplit", conv_split, 1, false, true);
longSample conv_dummy_FPU(sample* data, sample* coeffs, int len, int last_idx)
    longSample a = 0;
    sample* dp = data;
    sample* cp = coeffs;
    int data_idx = last_idx;
    for (int i = 0; i < len; ++i)
    {
        a += (longSample)dp[data_idx] * (longSample)cp[i];
		if (data_idx >= len)
			data_idx = 0;
    }
    return a;
RegisterImplementation r6("conv_dummy_FPU", conv_dummy_FPU, 1, false, true);
longSample conv_dummy(sample* data, sample* coeffs, int len, int last_idx)
	longSample a = 0;
    sample* dp = data;
    sample* cp = coeffs;
    int data_idx = last_idx;
    for (int i = 0; i < len; ++i)
    {
        a += dp[data_idx] * cp[
InvokeTimer::InvokeTimer(EventLoop* evloop, Duration timeout, const Functor& f, bool periodic)
    : loop_(evloop)
	, timeout_(timeout)
	, functor_(f)
	, periodic_(periodic) 
    
InvokeTimer::InvokeTimer(EventLoop* evloop, Duration timeout, Functor&& f, bool periodic)
    : loop_(evloop)
	, timeout_(timeout)
	, functor_(std::move(f)), periodic_(periodic) 
   
std::shared_ptr<InvokeTimer> InvokeTimer::Create(EventLoop* evloop, Duration timeout, const Functor& f, bool periodic) {
    std::shared_ptr<InvokeTimer> it(new InvokeTimer(evloop, timeout, f, periodic));
    it->self_ = it;
    return it;
std::shared_ptr<InvokeTimer> InvokeTimer::Create(EventLoop* evloop, Duration timeout, Functor&& f, bool periodic) {
    std::shared_ptr<InvokeTimer> it(new InvokeTimer(evloop, timeout, std::move(f), periodic));
    it->self_ = it;
    return it;
InvokeTimer::~InvokeTimer() {
   
void InvokeTimer::Start() {
    auto f = [this]() {
        timer_.reset(new TimerEventWatcher(loop_, std::bind(&Invo
/* ASE - Allegro Sprite Editor
 * Copyright (C) 2001-2011  David Capello
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
static void fill_listbox(RepoDlg *repo_dlg);
static void kill_listbox(RepoDlg *repo_dlg);
static int repo_listbox_type();
static bool repo_listbox_msg_proc(JWidget widget, Message* msg);
static void use_comm

static void add_command(Button* widget, RepoDlg* repo_dlg);
static void delete_command(Button* widget, RepoDlg* repo_dlg);
void ji_show_repo_dlg(RepoDlg *repo_dlg)
  Frame* window = new Frame(false, repo_dlg->title);
  Box* box1 = new Box(JI_HORIZONTAL);
  Box* box2 = new Box(JI_VERTICAL);
  View* view = new View();
  repo_dlg->listbox = jlistbox_new();
  repo_dlg->button_use = new Button(repo_dlg->use_text);
  repo_dlg->button_add = new Button("&Add");
  repo_dlg->button_delete = new Button("&Delete");
  Button* button_close = new Button("&Close");
  jwidget_add_hook(repo_dlg->listbox, repo_listbox_type(),
		   repo_listbox_msg_proc, repo_dlg);
  repo_dlg->button_use->Click.connect(Bind<void>(&use_command, repo_dlg->button_use, repo_dlg));
  repo_dlg->button_add->Click.connect(Bind<void>(&add_command, repo_dlg->button_add, repo_dlg));
  repo_dlg->button_delete->Click.connect(Bind<void>(&delete_command, repo_dlg->button_delete, repo_dlg));
  button_close->Click.connect(Bind<void>(&Fra

  jwidget_magnetic(repo_dlg->button_use, true);
  jwidget_expansive(view, true);
  view->attachToView(repo_dlg->listbox);
  jwidget_set_min_size(view, JI_SCREEN_W*25/100, JI_SCREEN_H*25/100);
  /* fill the list */
  fill_listbox(repo_dlg);
  jlistbox_select_index(repo_dlg->listbox, 0);
  /* no items? */
  if (jlistbox_get_selected_index(repo_dlg->listbox) != 0) {
    repo_dlg->button_use->setEnabled(false);
    repo_dlg->button_delete->setEnabled(false);
  }
  /* hierarchy */
  box2->addChild(repo_dlg->button_use);
  box2->addChild(repo_dlg->button_add);
  box2->addChild(repo_dlg->button_delete);
  box2->addChild(button_close);
  box1->addChild(box2);
  box1->addChild(view);
  window->addChild(box1);
  /* default position */
  window->remap_window();
  window->center_window();
  /* load window configuration */
  load_window_pos(window, repo_dlg->config_section);
  /* open window */
  window->open_window_fg();
  /* kill the list */
  kill_listbox(repo_dlg);
  /* save window configurati

  save_window_pos(window, repo_dlg->config_section);
  jwidget_free(window);
static void fill_listbox(RepoDlg *repo_dlg)
  /* no item selected (ID=0) */
  repo_dlg->listitem = 0;
  /* load the entries */
  if (repo_dlg->load_listbox)
    (*repo_dlg->load_listbox)(repo_dlg);
  View::getView(repo_dlg->listbox)->updateView();
static void kill_listbox(RepoDlg *repo_dlg)
  JWidget listbox = repo_dlg->listbox;
  JWidget listitem;
  JLink link, next;
  /* save the entries */
  if (repo_dlg->save_listbox)
    (*repo_dlg->save_listbox) (repo_dlg);
  /* remove all items */
  JI_LIST_FOR_EACH_SAFE(listbox->children, link, next) {
    listitem = reinterpret_cast<JWidget>(link->data);
    repo_dlg->listbox->removeChild(listitem);
    if (repo_dlg->free_listitem) {
      repo_dlg->listitem = listitem;
      (*repo_dlg->free_listitem) (repo_dlg);
    }
    jwidget_free(listitem);
  }
static int repo_listbox_type()
  static int type = 0;
  if (!type)
    type = ji_register_widget_type();
  return typ

static bool repo_listbox_msg_proc(JWidget widget, Message* msg)
  RepoDlg* repo_dlg = reinterpret_cast<RepoDlg*>(jwidget_get_data(widget, repo_listbox_type()));
  switch (msg->type) {
    case JM_DESTROY:
      /* do nothing (don't free repo_dlg) */
      break;
    case JM_SIGNAL:
      switch (msg->signal.num) {
	case JI_SIGNAL_LISTBOX_CHANGE:
	  repo_dlg->listitem = jlistbox_get_selected_child(widget);
	  repo_dlg->button_use->setEnabled(true);
	  repo_dlg->button_delete->setEnabled(true);
	  break;
	case JI_SIGNAL_LISTBOX_SELECT:
	  if (repo_dlg->use_listitem)
	    if (!(*repo_dlg->use_listitem)(repo_dlg))
	      widget->closeWindow();
	  break;
      }
      break;
  }
  return false;
static void use_command(Button* widget, RepoDlg* repo_dlg)
  if (repo_dlg->use_listitem) {
    if (!(*repo_dlg->use_listitem)(repo_dlg))
      widget->closeWindow();
  }
static void add_command(Button* widget, RepoDlg* repo_dlg)
  int ret, added;
  if (repo_dlg->add_listitem) {
    added = false;
  

    if (added) {
      /* update the list-box */
      View::getView(repo_dlg->listbox)->updateView();
      /* select the last item */
      jlistbox_select_index(repo_dlg->listbox,
			    jlist_length(repo_dlg->listbox->children)-1);
    }
    if (!ret)
      widget->closeWindow();
  }
static void delete_command(Button* widget, RepoDlg* repo_dlg)
  int ret, kill, index, last;
  if (repo_dlg->delete_listitem) {
    kill = false;
    ret = (*repo_dlg->delete_listitem) (repo_dlg, &kill);
    if (kill) {
      index = jlistbox_get_selected_index(repo_dlg->listbox);
      /* delete "repo_dlg->listitem" */
      repo_dlg->listbox->removeChild(repo_dlg->listitem);
      if (repo_dlg->free_listitem)
	(*repo_dlg->free_listitem) (repo_dlg);
      jwidget_free(repo_dlg->listitem);
      /* disable buttons */
      if (!repo_dlg->listbox->children) {
	repo_dlg->button_use->setEnabled(false);
	repo_dlg->button_delete->setEnabled(false);
      }
      /* select other item */
      else {
	last = 
Trap::Trap():m_pathName("/")
{	
	m_repoManager = nullptr;
	initRepoManager();
Trap::~Trap()
	if(m_repoManager != nullptr)
		delete m_repoManager;
void Trap::initRepoManager()
	try
	{
		if(m_repoManager != nullptr)
			delete m_repoManager;
		m_repoManager = new zypp::RepoManager(zypp::RepoManagerOptions(zypp::Pathname(m_pathName)));
	}
	catch (const std::exception &e)
	{
		std::cout << "[INFO] : repoManager cannot be set, exception caught : " << e.what() << std::endl;
	}
std::string Trap::getPackagesFromName(std::string name, std::string repoAlias)
	m_buildString = "";
	try
	{
		
		zypp::ZYpp::Ptr zyppPtr = zypp::ZYppFactory::instance().getZYpp();
		
		zypp::Pathname sysRoot( m_pathName );
		zyppPtr->initializeTarget( sysRoot, false );
		zyppPtr->target()->load();
		zypp::PoolQuery query;
		query.setCaseSensitive(false);
		query.setMatchGlob();
		
		zypp::Capability cap = zypp::Capability::guessPackageSpec( name );
		std::string newName = cap.detail().name().asString();
		query.addDepen

		query.addDependency( zypp::sat::SolvAttr::provides , newName, cap.detail().op(), cap.detail().ed(), zypp::Arch(cap.detail().arch()) );
		
		if(repoAlias != "")
		{
			query.addRepo(repoAlias);
		}
		zyppPtr->resolver()->resolvePool();
		
			
		zypp::invokeOnEach(query.poolItemBegin(), query.poolItemEnd(), m_result);
		
		if(m_resultString.size() > 0)
			m_resultString.substr(0, m_resultString.size()-1);
	}
	catch (const std::exception &e)
	{
		std::cerr << "[ERROR] Exception caught in Trapp::getPackagesFromName : "<< e.what() << std::endl;
		return "";
	}
	return m_resultString;
std::string Trap::lastQueryResult()
	return m_resultString;
void Trap::setPathName(std::string pathName)
	if(m_pathName != pathName)
	{
		if(pathName[0] != '/')
		{
			char cCurrentPath[FILENAME_MAX];
			if (!GetCurrentDir(cCurrentPath, sizeof(cCurrentPath)))
			{
				std::cerr << "[ERROR] When trying to get the current directory : "<< errno << std::endl;
			}
			else
			{
				std::cout << "[INFO] : Changing

				cCurrentPath[sizeof(cCurrentPath) - 1] = '\0';
				pathName = std::string(cCurrentPath) + std::string("/") + pathName;
			}
		}
		m_pathName = pathName;
		
		initRepoManager();
		
	}
std::string Trap::getPathName()
	return m_pathName;
void Trap::addBuildResult(std::string addString)
	m_buildString += addString;
void Trap::setBuildResult(std::string buildString)
	m_buildString = buildString;
void Trap::saveQueryResult()
	m_resultString = m_buildString;
	m_resultString = m_resultString.substr(0,m_resultString.size()-1);
bool Trap::isRepositoryExists(std::string repoAlias)
	return m_repoManager->hasRepo(repoAlias);
bool Trap::addRepo(std::string repoAlias, std::string repoURL, std::string gpgCheckURL)
	if(m_repoManager->hasRepo(repoAlias))
		m_repoManager->removeRepository(m_repoManager->getRepo(repoAlias));
	if(m_repoManager->hasService(repoAlias))
		m_repoManager->removeService(repoAlias);
	try
	{
		zypp::repo::ServiceType stype = m_repoManager->probeService(repoURL);
		
		{
			zyp

			service.setType(stype);
			service.setAlias(repoAlias);
			service.setName(repoAlias);
			service.setUrl(repoURL);
			service.setEnabled(true);
			if(m_repoManager->hasService(repoAlias))
				m_repoManager->modifyService(repoAlias, service);
			else
				m_repoManager->addService(service);
			
			initRepoManager();
		}
		{
			zypp::RepoInfo repo;
			repo.setBaseUrl(repoURL);
			repo.setEnabled(true);
			repo.setAutorefresh(false);
			if(gpgCheckURL != "")
			{
				repo.setGpgCheck(true);
				repo.setGpgKeyUrl(zypp::Url(gpgCheckURL));
			}
			repo.setKeepPackages(false);
			repo.setAlias(repoAlias);
			repo.setName(repoAlias);
			repo.setProbedType(m_repoManager->probe(repoURL));
			
			if(m_repoManager->hasRepo(repoAlias))
				m_repoManager->modifyRepository(repo);
			else
				m_repoManager->addRepository(repo);
				
			initRepoManager();
		}
	}
	catch(const std::exception &e)
	{
		std::cerr << "[ERROR] Exception caught in Trapp::addRepo : "<< e.what() << std::endl;
		return false;


	return true;
bool Trap::checkRepo(std::string repoURL)
	try
	{
		if (m_repoManager->probe(repoURL).asString() != std::string("NONE"))
			return true;
		return false;
	}
	catch (const std::exception &e)
	{
		std::cerr << "[INFO] in Trap::checkRepo, unable to reach : " << repoURL << " (verify you are connected to the network) : Exception Caught :" << e.what() << std::endl;
		return false;
	}
bool Trap::refreshRepo(std::string repoAlias)
	zypp::KeyRing::setDefaultAccept(zypp::KeyRing::ACCEPT_UNSIGNED_FILE | zypp::KeyRing::TRUST_AND_IMPORT_KEY);
	bool refreshSuccessfull = false;
	try 
	{
		zypp::Pathname path( m_pathName );
		zypp::ZYppFactory::instance().getZYpp()->initializeTarget( path, false );
		
		if(m_repoManager->hasService(repoAlias))
		{
			zypp::ServiceInfo service = m_repoManager->getService(repoAlias);
			m_repoManager->refreshService(service);
		}
		
		initRepoManager();
		zypp::RepoInfo repo = m_repoManager->getRepositoryInfo(repoAlias);
		
		for(zypp::RepoInfo::urls_const

		{
			try
			{
				
				if(m_repoManager->checkIfToRefreshMetadata (repo, *it) == zypp::RepoManager::REFRESH_NEEDED)
				{
					m_repoManager->refreshMetadata(repo, zypp::RepoManager::RefreshIfNeeded);
					m_repoManager->cleanCache(repo);
					m_repoManager->buildCache(repo, zypp::RepoManager::BuildIfNeeded);
					initRepoManager();
					refreshSuccessfull = true;
					break;
				}
			}
			catch(const std::exception &e)
			{
				std::cerr << "[ERROR] in Trap::refreshRepo : " << *it << " doesn't look good : Exception Caught :" << e.what() << std::endl;
			}
		}
		initRepoManager();
	}
	catch (const std::exception &e)
	{
		std::cerr << "[ERROR] in Trap::refreshRepo : Exception Caught :" << e.what() << std::endl;
	}
	return refreshSuccessfull;
std::string Trap::getAllPackages(std::string repoAlias)
	return getPackagesFromName("",repoAlias);
void Trap::clean()
	for(zypp::RepoManager::RepoConstIterator it = m_repoManager->repoBegin(); it !=  m_repoManager->repoEnd(); it = m_repoManager->
/* -*- C++ -*- */
/*
  This heap manages memory in units of Chunks.
  malloc returns a slot within a chunk,
  while free returns slots back to a chunk.
  We completely exhaust the first chunk before we ever get another one.
  Once a chunk is COMPLETELY empty, it is returned to the superheap.
*/
template <int chunkSize, int slotSize, class Super>
class LazySlotHeap : public Super {
public:
  LazySlotHeap (void)
    : myChunk (new (Super::malloc (chunkSize)) Chunk<chunkSize, slotSize>())
  {}
  virtual ~LazySlotHeap (void)
  {
    Super::free (myChunk);
  }
  inline void * malloc (size_t sz) {
    assert (sz <= chunkSize);
    void * ptr = myChunk->getSlot();
    if (ptr == NULL) {
      myChunk = new (Super::malloc (chunkSize)) Chunk<chunkSize, slotSize>();
      ptr = myChunk->getSlot();
      assert (ptr != NULL);
    }
    return ptr;
  }
  inline void free (void * ptr) {
    Chunk<chunkSize, slotSize> * ch = Chunk<chunkSize, slotSize>::getChunk (ptr);
    ch->putSlot (ptr);
    if (
/* vi: set sw=4 ts=4:
 *
 * Copyright (C) 2001 - 2007 Christian Hohnstaedt.
 *
 * All rights reserved.
 */
class pki_base;
class load_base
	public:
		QString filter;
		QString caption;
		load_base();
		virtual ~load_base();
		virtual pki_base *loadItem(QString s);
		virtual pki_base *newItem();
};
class load_key: public load_base
	public:
		load_key();
		pki_base *newItem();
};
class load_req: public load_base
	public:
		load_req();
		pki_base *newItem();
};
class load_cert: public load_base
	public:
		load_cert();
		pki_base *newItem();
};
class load_pkcs7: public load_base
	public:
		load_pkcs7();
		pki_base *newItem();
};
class load_pkcs12: public load_base
	public:
		load_pkcs12();
		pki_base *loadItem(QString s);
};
class load_temp: public load_base
	public:
		load_temp();
		pki_base *newItem();
};
class load_crl: public load_base
	public:
		load_crl();
		pki_base *newItem();
};
class load_db: public load_base
	public:
		load_db();
};
class load_pkcs11: public load_base
	public:
	
/*  YTP King - Easy to use sentence mixer
 *  Copyright (C) 2013  Alex "rainChu" Haddad et al.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
*/
	namespace ytpking
	{
	namespace smp
	{
SampleUser::SampleUser( SampleManager &manager ) :
	m_manager( &manager )
	manager.registerSampleUser( this );
SampleUser::~SampleUser( void )
	m_manager->unregisterSampleUser( this );
void
SampleUser::onAddSample( char const *sampleName, char const *speakerName, Sample *add
namespace manipulation_location_generator
	UniformSampling::UniformSampling(double sample_dist_table, double sample_angle_table, long int seed)
		: sample_dist_table_(sample_dist_table), sample_angle_table_(sample_angle_table)
	{
	    if(seed == 0)
	        srand48(time(NULL));
	    else
	        srand48(seed);
	}
	UniformSampling::~UniformSampling()
	{
	}
	geometry_msgs::Pose UniformSampling::generateSample()
	{
		geometry_msgs::Pose sample;
		double x, y;
		double sample_range_x = table_height_ + 2 * sample_dist_table_;
		double sample_range_y = table_width_ + 2 * sample_dist_table_;
		bool valid_sample = false;
		while (!valid_sample)
		{
			x = drand48() * sample_range_x - table_height_ / 2 - sample_dist_table_;
			y = drand48() * sample_range_y - table_width_ / 2 - sample_dist_table_;
			if (isSampleValid(x, y))
				valid_sample = true;
		}
		double yaw = atan2(0 - y, 0 - x);
		double sample_range = sample_angle_table_;
		double noise = drand48() * sample_range - sample_angle_tabl
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
class LitstrRepoProxy : public RepoProxy {
public:
  explicit LitstrRepoProxy(Repo& repo);
  ~LitstrRepoProxy() {}
  void createSchema(int re
template <typename R, typename T1, typename T2>
struct GenericVirtFuncInvoker2
	typedef R (*Func)(void*, T1, T2, const MethodInfo*);
	static inline R Invoke (const MethodInfo* method, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetGenericVirtualInvokeData(method, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3>
struct GenericVirtActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (const MethodInfo* method, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetGenericVirtualInvokeData(method, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct GenericVirtActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	s
void BaseBookmarkModelObserver::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BaseBookmarkModelObserver::BookmarkModelBeingDeleted(
    BookmarkModel* model) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
                                                  int index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeRemoved(
    BookmarkModel* model,
    const BookmarkNode* parent,
    int old_index,
    const BookmarkNode* node,
    const std::set<GURL>& removed_urls) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkAllUserNodesRem
void Epikon::Protocol::Command::sendToSocket(QTcpSocket* socket) const
    QByteArray block;
    QDataStream out(&block, QIODevice::WriteOnly);
    out.setVersion(QDataStream::Qt_4_6);
    out << (quint16)0;
    this->writeToDataStream(out);
    out.device()->seek(0);
    quint16 sz = (quint16)(block.size() - sizeof(quint16));
    out << sz;
    quint64 written = socket->write(block);
    if (written!=block.size()){
        qWarning() << "Could not send command " << this << " size:" << block.size() << " sent:" << written << " buffer:" <<  block;
        return;
    }
    qDebug() << "Sending Command " << this << " type:" << m_type << " size:" << written << "buffer:" << block.toHex();
void Epikon::Protocol::Command::readFromDataStream(QDataStream& stream)
    stream >> m_sendtime;
void Epikon::Protocol::Command::writeToDataStream(QDataStream& stream) const
    stream << m_type;
    stream << m_sendtime;
void Epikon::Protocol::Hello::readFromDataStream(QDataStream& stream)
    Command::r

    stream >> m_id;
void Epikon::Protocol::Hello::writeToDataStream(QDataStream& stream) const
    Command::writeToDataStream(stream);
    stream << m_id;
void Epikon::Protocol::Attack::readFromDataStream(QDataStream& stream)
    Command::readFromDataStream(stream);
    stream >>  m_fromplanet >> m_toplanet >> m_fromplayer >> m_toplayer >> m_numships >>  m_sendtime;
void Epikon::Protocol::Attack::writeToDataStream(QDataStream& stream) const
    Command::writeToDataStream(stream);
    stream <<  m_fromplanet << m_toplanet << m_fromplayer << m_toplayer << m_numships <<  m_sendtime;
QDataStream & operator<< (QDataStream& stream, const Epikon::Protocol::CommandType& cmd){
    quint16 out = cmd;
    stream << out;
    return stream;
QDataStream & operator>> (QDataStream& stream, enum Epikon::Protocol::CommandType& cmd){
    quint16 in;
    stream >> in;
    cmd = Epikon::Protocol::CommandType(in);
    return stream;
QDataStream & operator<< (QDataStream& stream, const Epikon::Protocol::Com
/* 
 * File:   ChunkFactory.cpp
 * Author: paul
 * 
 * Created on February 11, 2012, 6:43 PM
 */
namespace PrimeFinder
    ChunkFactory::ChunkFactory(): 
        chunks(std::list<Chunk *>()),
        nextOffset(START_CHUNK_OFFSET),
        currentChunk(chunks.begin()),
        maxPrimeNum(0)
    {
        
    }
    ChunkFactory::ChunkFactory(const ChunkFactory& orig) 
    {
        
    }
    ChunkFactory::~ChunkFactory() 
    {
        
    }
    
    void ChunkFactory::allocate()
    {
        this->chunks.push_back(new Chunk(this->nextOffset, this->maxPrimeNum));
        
        this->nextOffset += CHUNK_SIZE;
        
        this->currentChunk = chunks.begin();
        this->currentCheckChunk = chunks.begin();
                
    }
    
    long ChunkFactory::getMaxPrimeNum()
    {
        return maxPrimeNum;
    }
        
    long ChunkFactory::reset()
    {
        this->currentChunk = chunks.begin();
        
        for ( std::list<Chunk *>::iterator iter = chunks.begin();

        {
            (*iter)->reset();
        }
        
        return (*this->currentChunk)->reset();
        
    }
        
    long ChunkFactory::next()
    {
        std::list<Chunk *>::iterator chunk = this->currentChunk;
       
        if ( (*chunk)->hasNext() )
        {
            return (*chunk)->next();
        }
        else
        {
            return (*(++this->currentChunk))->reset();
        }
        
    }
        
    bool ChunkFactory::check(long i)
    {
    	if (   (*this->currentCheckChunk)->checkBound(i) )
    	{
    		return (*this->currentCheckChunk)->check(i);
    	}
    	else
    	{
    		for ( std::list<Chunk *>::iterator iter = chunks.begin(); iter != chunks.end(); ++iter )
    		{
    			if ( (*iter)->checkBound(i) )
    			{
    				this->currentCheckChunk = iter;
    				return (*iter)->check(i);
    			}
    		}
    	}
    }
        
    void ChunkFactory::setUnprime(long i)
    {
        (*this->currentCheckChunk)->setUnprime(i);
    }
    
   
/*
 * è·åç³»ç»cpu,loadç¸å³ä¿¡æ¯çç±»
 * created by guangchao.tian@opi-corp.com
 * 2010-03-19
 */
namespace xce {
namespace sysinfo{
using namespace std;
enum LOAD_TYPE
	LOAD_ONE = 1,
	LOAD_FIVE = 5,
	LOAD_FIFTEEN = 15
};
class SysInfo : public MyUtil::Singleton<SysInfo>
	public:
		/*
		 *  æè¿°ï¼åå§åçæ¶åè¯»åä¸æ¬¡cpuä¸ªæ°ä¿¡æ¯
		 */
		SysInfo()
		{
			_cpuNum = 0;
			FILE *f=popen("cat /proc/cpuinfo |grep processor |wc -l","r");
			fscanf(f,"%d",&_cpuNum);
			pclose(f);
		}
		
	public:
		/*
		 * æè¿°ï¼æ ¹æ®å½åloadåcpuä¸ªæ°çæ¯å¼å¤æ­å½åç³»ç»æ¯å¦highload
		 * åæ°ï¼type è¡¨ç¤ºè·åloadçç±»åï¼åä¸ºæ1åéï¼5åéå15åéï¼
		 *		 maxLoadPercentè¡¨ç¤ºhighloadçéå¼ï¼å¦æä½¿ç¨é»è®¤å¼0ï¼åè®¤ä¸ºè¶è¿1ä¸ºhighload
		 * è¿åå¼ï¼æ¯è¿åtrue,å¦è¿åfalse
		 */
		bool isHighLoadByPercent(LOAD_TYPE type ,double maxLoadPercent = 0)
		{
			double loadNow = 0; 
			getLoad(type, loadNow);
		
			if( maxLoadPercent == (double)0)
			{
				return (loadNow / getCpuNum()) > 1;
			}else
			{
				return (loadNow / getCpuNum()) > maxLoadPercent;
			}
			return true;
		}
		
		/*
		 * æè¿°ï¼æ ¹æ®å½åloadæ°çå¤æ­å½åç³»ç»æ¯å¦highload
		 * åæ°ï¼type 

		 *		 maxLoadè¡¨ç¤ºhighloadçéå¼ï¼å¦æä½¿ç¨é»è®¤å¼0ï¼åè®¤ä¸ºè¶è¿cpuä¸ªæ°ä¸ºhighload
		 * è¿åå¼ï¼æ¯è¿åtrue,å¦è¿åfalse
		 */
		bool isHighLoadByNum(LOAD_TYPE type, double maxLoad = 0)
		{
			double loadNow = 0; 
			getLoad(type, loadNow);
		
			if(maxLoad == (double)0)
			{
				return loadNow > getCpuNum();
			}else
			{
				return loadNow > maxLoad;
			}
			return true;
		}
		
		/*
		 * æè¿°ï¼è·å¾ç³»ç»cpuçä¸ªæ°
		 * è¿åå¼ï¼cpuä¸ªæ°
		 */
		int getCpuNum()
		{
			return _cpuNum;
		}
		/*
		 * æè¿°ï¼è·å¾ç³»ç»å½å1åéçload
		 * åæ°ï¼loadä¸ºå¤é¨è°ç¨ä¼ è¿æ¥çå¼ç¨ï¼å°æå½åçloadå¼èµç»è¯¥åæ°
		 * è¿åå¼ï¼ä¸ºæ¯å¦åå¾loadæå
		 */
		bool getLoadOne(double& load)
		{
			if(getLoad(LOAD_ONE,load))
			{
				return true;
			}
			return false;
		}
		
		/*
		 * æè¿°ï¼è·å¾ç³»ç»å½å5åéçload
		 * åæ°ï¼loadä¸ºå¤é¨è°ç¨ä¼ è¿æ¥çå¼ç¨ï¼å°æå½åçloadå¼èµç»è¯¥åæ°
		 * è¿åå¼ï¼ä¸ºæ¯å¦åå¾loadæå
		 */
		bool getLoadFive(double& load)
		{
			if(getLoad(LOAD_FIVE,load))
			{
				return true;
			}
			return false;
		}
		/*
		 * æè¿°ï¼è·å¾ç³»ç»å½å15åéçload
		 * åæ°ï¼loadä¸ºå¤é¨è°ç¨ä¼ è¿æ¥çå¼ç¨ï¼å°æå½åçloadå¼èµç»è¯¥åæ°
		 * è¿åå¼ï¼ä¸ºæ¯å¦åå¾loadæå
		 */
		bool getLoadFifteen(double& load)
		{
			if
/**
 * @addtogroup KdCoreApi
 * @{
 */
/**
 * @brief   The KdCoreApiHelperStream header file.
 *
 * Definitions of KdCoreApiHelperStream class.
 *
 * Copyright (c) 2013 Shenzhen Imagin Technology CO., LTD.
 * ALL rights reserved.
 *
 * $Revision$
 * $Date$
 * $Id$
 *
 * Modify Logs:
 *
 */
CORE_API_BEGIN_DECLS
typedef CoreApiObj CoreApiHelperStreamObj;
CORE_API_EXPORT CoreApiHelperStreamObj core_api_helper_stream_ref(CoreApiHelperStreamObj stream);
CORE_API_EXPORT void core_api_helper_stream_unref_later(CoreApiHelperStreamObj stream);
CORE_API_EXPORT void core_api_helper_stream_set(CoreApiHelperStreamObj stream, CoreApiAsyncCallerCb *cb, CoreApiAsyncCallerObj *caller);
CORE_API_EXPORT void core_api_helper_stream_edit_codec(CoreApiHelperStreamObj stream, CoreApiVCodec codec);
CORE_API_EXPORT void core_api_helper_stream_edit_size(CoreApiHelperStreamObj stream, CoreApiVSize size);
CORE_API_EXPORT void core_api_helper_stream_edit_h264(CoreApiHelperStreamObj stream, CoreApiH264InfoObj info)
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
using std::string;
using std::ostream;
class genstringfun_gen_class
 protected:
 public:
  genstringfun_gen_class()
  {
  }
  
  void generate_genstringfun(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "\n";
    stream << indent_str;
    stream << "static void";
    stream << "\n";
    stream << indent_str;
    stream << "generate_string(const char *s, FILE *stream, unsigned int indent)";
    stream << "\n";
    stream << indent_str;
    stream << "{";
    stream << "\n";
    stream << indent_str;
    stream << "  const char *sub = s;";
    stream << "\n";
    stream << indent_str;
    stream << "  char *indent_str;";
    stream << "\n";
    stream << indent_str;
    stream << "  unsigned int i;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  if (!indent || strchr (s, '\\n') == 0)

    stream << "\n";
    stream << indent_str;
    stream << "    {";
    stream << "\n";
    stream << indent_str;
    stream << "      fprintf (stream, \"%s\", s);";
    stream << "\n";
    stream << indent_str;
    stream << "      return;";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  indent_str = (char *) malloc (indent + 1);";
    stream << "\n";
    stream << indent_str;
    stream << "  for (i = 0; i < indent; ++i)";
    stream << "\n";
    stream << indent_str;
    stream << "    indent_str[i] = ' ';";
    stream << "\n";
    stream << indent_str;
    stream << "  indent_str[indent] = '\\0';";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  while ( (sub=strchr (s, '\\n')) != 0 )";
    stream << "\n";
    stream << indent_str;
    stream << "    {";
    stream << "\n";
    stream << inde
namespace ow
ChunkGenerator::ChunkGenerator()
    mDefaultTileset = "";
ChunkGenerator::ChunkGenerator(std::string const& filename)
    mDefaultTileset = filename;
void ChunkGenerator::setMap(Map* map)
    mMap = map;
void ChunkGenerator::setDefaultTileset(std::string const& filename)
    mDefaultTileset = filename;
void ChunkGenerator::createChunk(Chunk& chunk, sf::Vector2i pos)
    if (mMap != nullptr)
    {
        chunk.setTileset(mMap->getTileset(mDefaultTileset));
        chunk.setPos(pos);
        chunk.clearLayers();
        chunk.addLayer();
        for (unsigned int i = 0; i < static_cast<unsigned int>(chunk.getSize().x); i++)
        {
            for (unsigned int j = 0; j < static_cast<unsigned int>(chunk.getSize().y); j++)
            {
                chunk.getLayer(0)->setTileId(i,j,8);
            }
        }
        chunk.saveToFile(mMap->getDirectory() + std::to_string(pos.x) + "_" + std::to_string(pos.y) + ".chunk");
    }
    else
    {
        std::cout << "ChunkG
namespace media {
int SampleFormatToBytesPerChannel(SampleFormat sample_format) {
  switch (sample_format) {
    case kUnknownSampleFormat:
      return 0;
    case kSampleFormatU8:
      return 1;
    case kSampleFormatS16:
    case kSampleFormatPlanarS16:
      return 2;
    case kSampleFormatS24:
    case kSampleFormatS32:
    case kSampleFormatF32:
    case kSampleFormatPlanarF32:
    case kSampleFormatPlanarS32:
      return 4;
  }
  NOTREACHED() << "Invalid sample format provided: " << sample_format;
  return 0;
const char* SampleFormatToString(SampleFormat sample_format) {
  switch(sample_format) {
    case kUnknownSampleFormat:
      return "Unknown sample format";
    case kSampleFormatU8:
      return "Unsigned 8-bit with bias of 128";
    case kSampleFormatS16:
      return "Signed 16-bit";
    case kSampleFormatS24:
      return "Signed 24-bit";
    case kSampleFormatS32:
      return "Signed 32-bit";
    case kSampleFormatF32:
      return "Float 32-bit";
    case kSampleF

      return "Signed 16-bit planar";
    case kSampleFormatPlanarF32:
      return "Float 32-bit planar";
    case kSampleFormatPlanarS32:
      return "Signed 32-bit planar";
  }
  NOTREACHED() << "Invalid sample format provided: " << sample_format;
  return "";
bool IsPlanar(SampleFormat sample_format) {
  switch (sample_format) {
    case kSampleFormatPlanarS16:
    case kSampleFormatPlanarF32:
    case kSampleFormatPlanarS32:
      return true;
    case kUnknownSampleFormat:
    case kSampleFormatU8:
    case kSampleFormatS16:
    case kSampleFormatS24:
    case kSampleFormatS32:
    case kSampleFormatF32:
      return false;
  }
  NOTREACHED() << "Invalid sample format provided: " << sample_format;
  return false;
bool IsInterleaved(SampleFormat sample_format) {
  switch (sample_format) {
    case kSampleFormatU8:
    case kSampleFormatS16:
    case kSampleFormatS24:
    case kSampleFormatS32:
    case kSampleFormatF32:
      return true;
    case kUnknownSampleFormat:
    case k
const unsigned char C_Game::GetCubeType(const int h, const int i, const int j)
    int diffX = 0;
    int diffY = 0;
    if(h < 0) diffX = 1;
    if(i < 0) diffY = 1;
    int a = (h+diffX)/CHUNK_SIZE;
    if(h < 0)
        a--;
    int b = (i+diffY)/CHUNK_SIZE;
    if(i < 0)
        b--;
    MinecraftChunk *ch = GetChunk(a, b);
    int xx = h + diffX - (int)((h+diffX)/CHUNK_SIZE) * CHUNK_SIZE;
    if(h < 0)
    {
        if(xx <= 0)
                xx = CHUNK_SIZE - 1 + xx;
    }
    int yy = i + diffY - (int)((i+diffY)/CHUNK_SIZE) * CHUNK_SIZE;
    if(i < 0)
    {
        if(yy <= 0)
                yy = CHUNK_SIZE - 1 + yy;
    }
    return ch->_chunkMap[xx][yy][j];
void C_Game::CheckChunksCubesVisibility(const int x, const int y)
    MinecraftChunk *ch = GetChunk(x, y);
    if(ch == NULL)
        return;
    if(!ch->_hidden)
        return;
    unsigned char tab[CHUNK_SIZE+2][CHUNK_SIZE+2][CHUNK_ZVALUE+2];
    for(int h=0;h<CHUNK_SIZE+2;h++)
        for(int i=0;i<CHUNK_SIZE+2;i++)
 

                tab[h][i][j] = CUBE_DIRT;
    for(int h=0;h<CHUNK_SIZE;h++)
        for(int i=0;i<CHUNK_SIZE;i++)
            for(int j=0;j<CHUNK_ZVALUE;j++)
                tab[1+h][1+i][1+j] = ch->_chunkMap[h][i][j];
    for(int h=1;h<CHUNK_SIZE+1;h++)
    {
        for(int i=1;i<CHUNK_SIZE+1;i++)
        {
            for(int j=1;j<CHUNK_ZVALUE+1;j++)
            {
                if(tab[h][i][j] != CUBE_AIR)
                {
                    if( (h-1 >= 0 && tab[h-1][i][j] == CUBE_AIR) || ( h+1 < CHUNK_SIZE && tab[h+1][i][j] == CUBE_AIR)
                    || ( i-1 >= 0 && tab[h][i-1][j] == CUBE_AIR) || ( i+1 < CHUNK_SIZE && tab[h][i+1][j] == CUBE_AIR)
                    || ( j-1 >= 0 && tab[h][i][j-1] == CUBE_AIR) || ( j+1 < CHUNK_ZVALUE && tab[h][i][j+1] == CUBE_AIR) )
                    {
                        tabCube temp;
                        temp.x = h-1 + x*CHUNK_SIZE;
                        temp.y = i-1 + y * CHUNK_SIZE;
                        temp.z = j-1;
 

                    }
                }
            }
        }
    }
    ch->_hidden = false;
void C_Game::CreateRandomChunk(const int a, const int b)
    if(GetChunk(a, b) != NULL)
        return;
    MinecraftChunk *temp = new MinecraftChunk;
    temp->x = a;
    temp->y = b;
    temp->_hidden = true;
    _chunks.push_back(temp);
    for(int h=0;h<CHUNK_SIZE;h++)
    {
        for(int i=0;i<CHUNK_SIZE;i++)
        {
            for(int j=0;j<CHUNK_ZVALUE;j++)
            {
                _chunks.back()->_chunkMap[h][i][j] = (rand() % (NB_TYPE_CUBE-1)) +1;
            }
        }
    }
    for(int h=0;h<CHUNK_SIZE;h++)
        for(int i=0;i<CHUNK_SIZE;i++)
            for(int j=CHUNK_ZVALUE/2;j<CHUNK_ZVALUE;j++)
                _chunks.back()->_chunkMap[h][i][j] = CUBE_AIR;
MinecraftChunk* C_Game::GetChunk(const int x, const int y)
    for(unsigned int i=0;i<_chunks.size();i++)
        if(_chunks[i]->x == x && _chunks[i]->y == y)
            return _chunks[i];
    return NULL;
void

    MinecraftChunk *ch = GetChunk(x, y);
    if(ch == NULL)
        return;
    unsigned char tab[CHUNK_SIZE+2][CHUNK_SIZE+2][CHUNK_ZVALUE+2];
    for(int h=0;h<CHUNK_SIZE+2;h++)
        for(int i=0;i<CHUNK_SIZE+2;i++)
            for(int j=0;j<CHUNK_ZVALUE+2;j++)
                tab[h][i][j] = CUBE_DIRT;
    for(int h=0;h<CHUNK_SIZE;h++)
        for(int i=0;i<CHUNK_SIZE;i++)
            for(int j=0;j<CHUNK_ZVALUE;j++)
                tab[1+h][1+i][1+j] = ch->_chunkMap[h][i][j];
    for(int h=1;h<CHUNK_SIZE+1;h++)
    {
        for(int i=1;i<CHUNK_SIZE+1;i++)
        {
            for(int j=1;j<CHUNK_ZVALUE+1;j++)
            {
                if(tab[h][i][j] != CUBE_AIR)
                {
                    if( (h-1 >= 0 && tab[h-1][i][j] == CUBE_AIR) || ( h+1 < CHUNK_SIZE && tab[h+1][i][j] == CUBE_AIR)
                    || ( i-1 >= 0 && tab[h][i-1][j] == CUBE_AIR) || ( i+1 < CHUNK_SIZE && tab[h][i+1][j] == CUBE_AIR)
                    || ( j-1 >= 0 && tab[h][i][j-1] == CUBE_AIR)
/*
 * =====================================================================================
 *
 *       Filename:  Sample.cpp
 *
 *    Description:  Class Definition of sample classes
 *
 *        Version:  1.0
 *        Created:  Saturday 24 May 2014 04:31:53  CEST
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Nair Deebul  (deebuls), deebul.nair@smail.inf.h-brs.de
 *   Organization:  
 *
 * =====================================================================================
 */
/*
 *--------------------------------------------------------------------------------------
 *       Class:  Sample
 *      Method:  Sample
 * Description:  constructor
 *--------------------------------------------------------------------------------------
 */
Sample::Sample ()
    weight = 0.0;
}  /* -----  end of method Sample::Sample  (constructor)  ----- */
/*
 *--------------------------------------------------------------------------------------
 *       Class:  Sample
 *      

 * Description:  Parametrized constructor
 *--------------------------------------------------------------------------------------
 */
Sample::Sample (cPoint *iPoint, double weight):Point(iPoint)
  Point = iPoint;
  weight = iWeight;
}		/* -----  end of method Sample::Sample  ----- */
/*
 *--------------------------------------------------------------------------------------
 *       Class:  Sample
 *      Method:  get_weight
 *--------------------------------------------------------------------------------------
 */
inline double
Sample::get_weight (  ) const
  return weight;
}		/* -----  end of method Sample::get_weight  ----- */
/*
 *--------------------------------------------------------------------------------------
 *       Class:  Sample
 *      Method:  set_weight
 *--------------------------------------------------------------------------------------
 */
inline void
Sample::set_weight ( double value )
  weight	= value;
  return ;
}		/* -----  end of method Sample::set_weight
/**
* @file OdometrySelfLocator.h
* @author <a href="mailto:mellmann@informatik.hu-berlin.de">Heinrich Mellmann</a>
* Implementation of class OdometrySelfLocator
*/
OdometrySelfLocator::OdometrySelfLocator()
  DEBUG_REQUEST_REGISTER("OdometrySelfLocator:draw_position","draw robot's position (self locator)", false);
  DEBUG_REQUEST_REGISTER("OdometrySelfLocator:reset","reset the robot's position", false);
void OdometrySelfLocator::execute()
  getRobotPose() += getOdometryData() - lastRobotOdometry;
  lastRobotOdometry = getOdometryData();
  DEBUG_REQUEST("OdometrySelfLocator:draw_position",
    FIELD_DRAWING_CONTEXT;
    PEN("0000FF", 20);
    CIRCLE(getRobotPose().translation.x, getRobotPose().translation.y, 150);
    ARROW(getRobotPose().translation.x,  getRobotPose().translation.y, 
          getRobotPose().translation.x + 50*cos(getRobotPose().rotation), 
          getRobotPose().translation.y + 50*sin(getRobotPose().rotation));
  );
  DEBUG_REQUEST("OdometrySelfLocator:reset",
    
namespace HeadFirstDesignPatterns {
    namespace ChainOfResponsibility {
        namespace GumballEMailHandler {
            class Client {
            private:
                std::auto_ptr< Handler > _lastHandler;
            private:
                std::auto_ptr< Handler > _newHandler;
            private:
                std::auto_ptr< Handler > _hateHandler;
            private:
                std::auto_ptr< Handler > _fanHandler;
            private:
                std::auto_ptr< Handler > _spamHandler;
            private:
            private:
            public:
                Client() :
                    _lastHandler(new LastHandler()),
                    _newHandler(new NewLocationHandler(_lastHandler.get())),
                    _hateHandler(new ComplaintHandler(_newHandler.get())),
                    _fanHandler(new FanHandler(_hateHandler.get())),
                    _spamHandler(new SpamHandler(_fanHandler.get())) {
                }
            public:
         
namespace streams
   template < class Stream, class S, size_t D >
   void write( Stream & stream, cg::point_t<S, D> const & point )
   {
      stream.write( &point, sizeof(point) );
   }
   template < class Stream, class S, size_t D >
   void read( Stream & stream, cg::point_t<S, D> & point )
   {
      stream.read( point );
   }
	template < class Stream, class S >
   void write( Stream & stream, cg::color_t<S> const & c)
   {
      stream.write( &c, sizeof(c) );
   }
	template < class Stream, class S >
   void read( Stream & stream, cg::color_t<S> & c )
   {
      stream.read( c );
   }
	template < class Stream, class S >
   void write( Stream & stream, cg::colora_t<S> const & c)
   {
      stream.write( &c, sizeof(c) );
   }
	template < class Stream, class S >
   void read( Stream & stream, cg::colora_t<S> & c )
   {
      stream.read( c );
   }
   template < class Stream, class S, size_t D >
   void write( Stream & stream, cg::segment_t<S, D> const & seg )
   {
      stream.write( &

   }
   template < class Stream, class S, size_t D >
   void read( Stream & stream, cg::segment_t<S, D> & seg )
   {
      stream.read( seg );
   }
   template < class Stream, typename S >
   void write( Stream & stream, const cg::cpr_t < S > & data )
   {
      write( stream, data.course );
      write( stream, data.pitch  );
      write( stream, data.roll   );
   }
   template < class Stream, typename S >
   void read ( Stream & stream, cg::cpr_t < S > & data )
   {
      read ( stream, data.course );
      read ( stream, data.pitch  );
      read ( stream, data.roll   );
   }
   template < class Stream, typename S >
   void write( Stream & stream, const cg::dcpr_t < S > & data )
   {
      write( stream, data.dcourse );
      write( stream, data.dpitch  );
      write( stream, data.droll   );
   }
   template < class Stream, typename S >
   void read ( Stream & stream, cg::dcpr_t < S > & data )
   {
      read ( stream, data.dcourse );
      read ( stream, data.dpitch  );
      rea

   }
   template <class Stream, typename S >
   void write(Stream & stream, cg::range_t<S> const& data)
   {
      stream.write(&data, sizeof(data));
   }
   template <class Stream, typename S >
   void read(Stream & stream, cg::range_t<S>& data)
   {
      stream.read(data);
   }
   template <class Stream, typename S, size_t D >
   void write(Stream & stream, cg::rectangle_t<S,D> const& data)
   {
      stream.write(&data, sizeof(data));
   }
   template <class Stream, typename S, size_t D >
   void read(Stream & stream, cg::rectangle_t<S,D> & data)
   {
      stream.read(data);
   }
   template <class Stream>
   void write(Stream & stream, cg::glb_point_2 const& data)
   {
      stream.write(&data, sizeof(data));
   }
   template <class Stream>
   void write(Stream & stream, cg::glb_point_3 const& data)
   {
      stream.write(&data, sizeof(data));
   }
   template <class Stream>
   void read(Stream & stream, cg::glb_point_2 & data)
   {
      stream.read(data);
   }
   template <cl
/**
* @file
* @brief  Mixer test
* @author vitamin.caig@gmail.com
**/
namespace Sound
  Gain CreateGain(double l, double r)
  {
    return Gain(Gain::Type(l), Gain::Type(r));
  }
  
  const Gain GAINS[] = {
    CreateGain(0.0, 0.0),
    CreateGain(1.0, 1.0),
    CreateGain(1.0, 0.0),
    CreateGain(0.0, 1.0),
    CreateGain(0.5, 0.5),
    CreateGain(0.1, 0.9)
  };
  
  const String GAIN_NAMES[] = {
    "empty", "full", "left", "right", "middle", "-10dB,-0.45dB"
  };
  
  const Gain INVALID_GAIN = CreateGain(2.0, 3.0);
  const Sample::Type INPUTS[] = {
    Sample::MIN,
    Sample::MID,
    Sample::MAX
  };
  
  const String INPUT_NAMES[] = {
    "min", "mid", "max"
  };
  
  const Sample OUTS[] = {
     Sample(Sample::MID, Sample::MID),
     Sample(Sample::MID, Sample::MID),
     Sample(Sample::MID, Sample::MID),
     Sample(Sample::MIN, Sample::MIN),
     Sample(Sample::MID, Sample::MID),
     Sample(Sample::MAX, Sample::MAX),
     Sample(Sample::MIN, Sample::MID),
     Sample(Sample::

     Sample(Sample::MAX, Sample::MID),
     Sample(Sample::MID, Sample::MIN),
     Sample(Sample::MID, Sample::MID),
     Sample(Sample::MID, Sample::MAX),
     Sample((Sample::MID+Sample::MIN)/2, (Sample::MID+Sample::MIN)/2),
     Sample(Sample::MID, Sample::MID),
     Sample((Sample::MID+Sample::MAX)/2, (Sample::MID+Sample::MAX)/2),
     Sample(Sample::MID+(int_t(Sample::MIN)-Sample::MID)/10, Sample::MID+9*(int_t(Sample::MIN)-Sample::MID)/10),
     Sample(Sample::MID, Sample::MID),
     Sample(Sample::MID+(int_t(Sample::MAX)-Sample::MID)/10, Sample::MID+9*(int_t(Sample::MAX)-Sample::MID)/10),
  };
  template<class Res>
  typename Res::Type MakeSample(Sample::Type in)
  {
    typename Res::Type res;
    res.assign(in);
    return res;
  }
  template<unsigned Channels>
  typename FixedChannelsMatrixMixer<Channels>::Matrix MakeMatrix(const Gain& mg)
  {
    typename FixedChannelsMatrixMixer<Channels>::Matrix res;
    res.assign(mg);
    return res;
  }
  bool ShowIfError(const Error& e

  {
    if (e)
    {
      std::cerr << e.ToString();
    }
    return e;
  }
  bool Check(Sample::Type data, Sample::Type ref)
  {
    return Math::Absolute(int_t(data) - ref) <= THRESHOLD;
  }
  void Check(const Sample& data, const Sample& ref)
  {
    if (Check(data.Left(), ref.Left()) && Check(data.Right(), ref.Right()))
    {
      std::cout << " passed\n";
    }
    else
    {
      std::cout << " failed\n";
      throw MakeFormattedError(THIS_LINE, "Value=<%1%,%2%> while expected=<%3%,%4%>",
        data.Left(), data.Right(), ref.Left(), ref.Right());
    }
  }
  template<unsigned Channels>
  void TestMixer()
  {
    std::cout << "**** Testing for " << Channels << " channels ****\n";
    const typename FixedChannelsMatrixMixer<Channels>::Ptr mixer = FixedChannelsMatrixMixer<Channels>::Create();
    
    std::cout << "--- Test for invalid matrix---\n";
    try
    {
      mixer->SetMatrix(MakeMatrix<Channels>(INVALID_GAIN));
      throw "Failed";
    }
    catch (const Error& e)

    {
      std::cout << " Passed\n";
      std::cerr << e.ToString();
    }
    catch (const std::string& str)
    {
      throw Error(THIS_LINE, str);
    }
    
    assert(boost::size(OUTS) == boost::size(GAINS) * boost::size(INPUTS));
    assert(boost::size(GAINS) == boost::size(GAIN_NAMES));
    assert(boost::size(INPUTS) == boost::size(INPUT_NAMES));
    
    const Sample* result(OUTS);
    for (unsigned matrix = 0; matrix != boost::size(GAINS); ++matrix)
    {
      std::cout << "--- Test for " << GAIN_NAMES[matrix] << " matrix ---\n";
      mixer->SetMatrix(MakeMatrix<Channels>(GAINS[matrix]));
      for (unsigned input = 0; input != boost::size(INPUTS); ++input, ++result)
      {
        std::cout << "Checking for " << INPUT_NAMES[input] << " input: ";
        Check(mixer->ApplyData(MakeSample<MultichannelSample<Channels> >(INPUTS[input])), *result);
      }
    }
    std::cout << "Parameters:" << std::endl;
    for (uint_t inChan = 0; inChan != Channels; ++inChan)
    {
    
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
class Listener : public RM::EventsInterface
    Q_DECLARE_TR_FUNCTIONS(RepoManLogger)
public:
    Listener(Log::Channel channel);
    ~Listener();
public:
    void repositoryOpened(RM::Repo* repo);
    void repositoryAboutToClose(RM::Repo* repo);
    void repositoryActivated(RM::Repo* repo);
    void rep

    void objectCreated(RM::Repo* repo, RM::Base* object);
    void objectAboutToBeDeleted(RM::Repo* repo, RM::Base* object);
    void refTreeNodeCreated(RM::Repo* repo, RM::RefTreeNode* node);
    void refTreeNodeAboutToBeDeleted(RM::Repo* repo, RM::RefTreeNode* node);
    void refCreated(RM::Repo* repo, RM::Ref* ref);
    void refAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref);
    void refMoved(RM::Repo* repo, RM::Ref* ref);
    void refHeadDetached(RM::Repo* repo, RM::Ref* ref);
    void tagCreated(RM::Repo* repo, RM::Tag* tag);
    void tagAboutToBeDeleted(RM::Repo* repo, RM::Tag* tag);
    void branchCreated(RM::Repo* repo, RM::Branch* branch);
    void branchAboutToBeDeleted(RM::Repo* repo, RM::Branch* branch);
    void branchMoved(RM::Repo* repo, RM::Branch* branch);
    void branchUpstreamChanged(RM::Repo* repo, RM::Branch* branch);
    void namespaceCreated(RM::Repo* repo, RM::Namespace* nameSpace);
    void namespaceAboutToBeDeleted(RM::Repo* repo, RM::Namespace* nameSpace);

/*******************************************************************************
 *         Copyright 2003 & onward LASMEA UMR 6602 CNRS/Univ. Clermont II
 *         Copyright 2009 & onward LRI    UMR 8623 CNRS/Univ Paris Sud XI
 *
 *          Distributed under the Boost Software License, Version 0x01.0.
 *                 See accompanying file LICENSE.txt or copy at
 ******************************************************************************/
NT2_TEST_CASE_TPL(load, BOOST_SIMD_TYPES)
  using boost::simd::load;
  T data[5] = {0,1,2,3,4};
  NT2_TEST_EQUAL( (load<T,-4>(&data[0],4)), T(0) );
  NT2_TEST_EQUAL( (load<T,-4>(&data[0],5)), T(1) );
  NT2_TEST_EQUAL( (load<T,-4>(&data[0],6)), T(2) );
  NT2_TEST_EQUAL( (load<T,-4>(&data[0],7)), T(3) );
  NT2_TEST_EQUAL( (load<T,-4>(&data[0],8)), T(4) );
  NT2_TEST_EQUAL( (load<T,-3>(&data[0],3)), T(0) );
  NT2_TEST_EQUAL( (load<T,-3>(&data[0],4)), T(1) );
  NT2_TEST_EQUAL( (load<T,-3>(&data[0],5)), T(2) );
  NT2_TEST_EQUAL( (load<T,-3>(&data[0

  NT2_TEST_EQUAL( (load<T,-3>(&data[0],7)), T(4) );
  NT2_TEST_EQUAL( (load<T,-2>(&data[0],2)), T(0) );
  NT2_TEST_EQUAL( (load<T,-2>(&data[0],3)), T(1) );
  NT2_TEST_EQUAL( (load<T,-2>(&data[0],4)), T(2) );
  NT2_TEST_EQUAL( (load<T,-2>(&data[0],5)), T(3) );
  NT2_TEST_EQUAL( (load<T,-2>(&data[0],6)), T(4) );
  NT2_TEST_EQUAL( (load<T,-1>(&data[0],1)), T(0) );
  NT2_TEST_EQUAL( (load<T,-1>(&data[0],2)), T(1) );
  NT2_TEST_EQUAL( (load<T,-1>(&data[0],3)), T(2) );
  NT2_TEST_EQUAL( (load<T,-1>(&data[0],4)), T(3) );
  NT2_TEST_EQUAL( (load<T,-1>(&data[0],5)), T(4) );
  NT2_TEST_EQUAL( load<T>(&data[0],0), T(0) );
  NT2_TEST_EQUAL( load<T>(&data[0],1), T(1) );
  NT2_TEST_EQUAL( load<T>(&data[0],2), T(2) );
  NT2_TEST_EQUAL( load<T>(&data[0],3), T(3) );
  NT2_TEST_EQUAL( load<T>(&data[0],4), T(4) );
  NT2_TEST_EQUAL( (load<T,0>(&data[0],0)), T(0) );
  NT2_TEST_EQUAL( (load<T,0>(&data[0],1)), T(1) );
  NT2_TEST_EQUAL( (load<T,0>(&data[0],2)), T(2) );
  NT2_TEST_EQUAL( (load<T,0>(&data[0],3

  NT2_TEST_EQUAL( (load<T,0>(&data[0],4)), T(4) );
  NT2_TEST_EQUAL( (load<T,1>(&data[0],-1)), T(0) );
  NT2_TEST_EQUAL( (load<T,1>(&data[0],0)) , T(1) );
  NT2_TEST_EQUAL( (load<T,1>(&data[0],1)) , T(2) );
  NT2_TEST_EQUAL( (load<T,1>(&data[0],2)) , T(3) );
  NT2_TEST_EQUAL( (load<T,1>(&data[0],3)) , T(4) );
  NT2_TEST_EQUAL( (load<T,2>(&data[0],-2)), T(0) );
  NT2_TEST_EQUAL( (load<T,2>(&data[0],-1)), T(1) );
  NT2_TEST_EQUAL( (load<T,2>(&data[0],0)) , T(2) );
  NT2_TEST_EQUAL( (load<T,2>(&data[0],1)) , T(3) );
  NT2_TEST_EQUAL( (load<T,2>(&data[0],2)) , T(4) );
  NT2_TEST_EQUAL( (load<T,3>(&data[0],-3)), T(0) );
  NT2_TEST_EQUAL( (load<T,3>(&data[0],-2)), T(1) );
  NT2_TEST_EQUAL( (load<T,3>(&data[0],-1)), T(2) );
  NT2_TEST_EQUAL( (load<T,3>(&data[0],0)) , T(3) );
  NT2_TEST_EQUAL( (load<T,3>(&data[0],1)) , T(4) );
  NT2_TEST_EQUAL( (load<T,4>(&data[0],-4)), T(0) );
  NT2_TEST_EQUAL( (load<T,4>(&data[0],-3)), T(1) );
  NT2_TEST_EQUAL( (load<T,4>(&data[0],-2)), T(2) );
  NT2_TEST_E
class ChunkRegistry : public ::testing::Test
protected:
  virtual
  void
  SetUp()
  {
    small_chunk = chunk::create (256);
    large_chunk = chunk::create (1 << 14);
    small_ptr = small_chunk->data();
    large_ptr = large_chunk->data();
    ch_reg.add (small_chunk);
    ch_reg.add (large_chunk);
  }
  virtual
  void
  TearDown()
  {
    chunk::destroy (small_chunk);
    chunk::destroy (large_chunk);
  }
  void *small_ptr;
  void *large_ptr;
  chunk *small_chunk;
  chunk *large_chunk;
  chunk_registry ch_reg;
};
TEST_F(ChunkRegistry, AllocatedInRange) {
  ASSERT_TRUE (ch_reg.in_range (small_chunk->data()));
TEST_F(ChunkRegistry, MidChunkInRange) {
  ASSERT_TRUE (ch_reg.in_range ((void*)((char*)large_chunk->data() + (1 << 13))));
TEST_F(ChunkRegistry, AfterChunkNotInRange) {
  ASSERT_FALSE (ch_reg.in_range ((void*)((char*)large_chunk->data() + (1 << 16))));
TEST_F(ChunkRegistry, FetchChunkObjectPtr) {
  chunk* chunk = ch_reg.find_chunk (large_ptr);
  ASSERT_NE (chunk, nullptr);
  A

TEST_F(ChunkRegistry, FetchHeaderInteriorPtr) {
  chunk* chunk= ch_reg.find_chunk ((char*)large_ptr + (1 << 13));
  ASSERT_EQ (chunk, nullptr);
TEST_F(ChunkRegistry, BackPointerIso) {
  chunk* chunk = ch_reg.find_chunk (large_ptr);
  ASSERT_NE (chunk, nullptr);
  ASSERT_EQ (*chunk->back_ptr, chunk);
TEST_F(ChunkRegistry, MarkTrue) {
  ch_reg.mark (large_ptr);
  ASSERT_TRUE (ch_reg.is_marked (large_ptr));
TEST_F(ChunkRegistry, MarkFalse) {
  ASSERT_FALSE (ch_reg.is_marked (large_ptr));
TEST_F(ChunkRegistry, BasePtrIsValid) {
  auto chunk = ch_reg.find_chunk (large_ptr);
  ASSERT_NE (chunk, nullptr);
  ASSERT_TRUE (chunk->valid (large_ptr));
TEST_F(ChunkRegistry, NextPtrIsValid) {
  auto chunk = ch_reg.find_chunk (small_ptr);
  ASSERT_NE (chunk, nullptr);
  ASSERT_TRUE (chunk->valid ((char*)small_ptr + 256UL));
TEST_F(ChunkRegistry, MidObjectInvalidPtr) {
  auto chunk = ch_reg.find_chunk (large_ptr);
  ASSERT_NE (chunk, nullptr);
  ASSERT_FALSE (chunk->valid ((char*)large_ptr + 240UL));
/*
** $Id: lundump.cpp 53568 2010-10-18 17:12:00Z sev $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;
static void error(LoadState* S, const char* why)
 luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
 luaD_throw(S->L,LUA_ERRSYNTAX);
static void LoadBlock(LoadState* S, void* b, size_t size)
 size_t r=luaZ_read(S->Z,b,size);
 UNUSED(r);
 IF (r!=0, "unexpected end");
static int LoadChar(LoadState* S)
 char x;
 LoadVar(S,x);
 return x;
static int LoadInt(LoadState* S)
 int x;
 LoadVar(S,x);
 IF (x<0, "bad integer");
 return x;
static lua_Number LoadNumber(LoadState* S)
 lua_Number x;
 LoadVar(S,x);
 return x;
static TString* LoadString(LoadState* S)
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S->L,S->b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
 }
static void LoadC

 int n=LoadInt(S);
 f->code=luaM_newvector(S->L,n,Instruction);
 f->sizecode=n;
 LoadVector(S,f->code,n,sizeof(Instruction));
static Proto* LoadFunction(LoadState* S, TString* p);
static void LoadConstants(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->k=luaM_newvector(S->L,n,TValue);
 f->sizek=n;
 for (i=0; i<n; i++) setnilvalue(&f->k[i]);
 for (i=0; i<n; i++)
 {
  TValue* o=&f->k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S));
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S->L,o,LoadString(S));
	break;
   default:
	error(S,"bad constant");
	break;
  }
 }
 n=LoadInt(S);
 f->p=luaM_newvector(S->L,n,Proto*);
 f->sizep=n;
 for (i=0; i<n; i++) f->p[i]=NULL;
 for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
static void LoadDebug(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->lineinfo=luaM_newvector(S->L,n,int);
 f->sizelineinfo

 LoadVector(S,f->lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f->locvars=luaM_newvector(S->L,n,LocVar);
 f->sizelocvars=n;
 for (i=0; i<n; i++) f->locvars[i].varname=NULL;
 for (i=0; i<n; i++)
 {
  f->locvars[i].varname=LoadString(S);
  f->locvars[i].startpc=LoadInt(S);
  f->locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f->upvalues=luaM_newvector(S->L,n,TString*);
 f->sizeupvalues=n;
 for (i=0; i<n; i++) f->upvalues[i]=NULL;
 for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
static Proto* LoadFunction(LoadState* S, TString* p)
 Proto* f=luaF_newproto(S->L);
 setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
 f->source=LoadString(S); if (f->source==NULL) f->source=p;
 f->linedefined=LoadInt(S);
 f->lastlinedefined=LoadInt(S);
 f->nups=LoadByte(S);
 f->numparams=LoadByte(S);
 f->is_vararg=LoadByte(S);
 f->maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), "bad code");
 S->L->top--;
 return f;
static void LoadHeader(LoadState* S)
 char h[
extern MDS * mds;
void RepoMonitor::updateRepo(const std::string &path)
    RepoControl repo = RepoControl(path);
    RepoInfo info;
    try {
        repo.open();
    } catch (SystemException &e) {
        WARNING("Failed to open repository %s: %s", path.c_str(), e.what());
        return;
    }
    RWKey::sp key = MDS::instance().infoLock.writeLock();
    if (MDS::instance().myInfo.hasRepo(repo.getUUID())) {
        info = MDS::instance().myInfo.getRepo(repo.getUUID());
    } else {
        info = RepoInfo(repo.getUUID(), repo.getPath());
    }
    info.updateHead(repo.getHead());
    MDS::instance().myInfo.updateRepo(repo.getUUID(), info);
    LOG("Checked %s: %s %s", path.c_str(), repo.getHead().c_str(), repo.getUUID().c_str());
    repo.close();
    return;
void RepoMonitor::run()
    std::list<std::string> repos = MDS::instance().rc.getRepos();
    std::list<std::string>::iterator it;
    while (!interruptionRequested()) {
        for (it = repos.begin(); it != repos.end(); it++)
int samplesAdded = 0;
int patchSamplesAdded = 0;
static unsigned short g_PatchIterationKey = 0;
bool SampleData_CompareFunc( SampleData_t const &src1, SampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int SampleData_KeyFunc( SampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<SampleData_t> g_SampleHashTable( SAMPLEHASH_NUM_BUCKETS, 
										  SAMPLEHASH_GROW_SIZE, 
										  SAMPLEHASH_INIT_SIZE, 
										  SampleData_CompareFunc, SampleData_KeyFunc );
UtlHashHandle_t SampleData_Find( sample_t *pSample )
	SampleData_t sampleData;	
	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	return g_SampleHashTable.Find( sampleData );
UtlHashHandle_t SampleData_InsertIntoHashTable( sample_t *pSample, SampleHandle_t sampleHandle )
	Samp

	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	UtlHashHandle_t handle = g_SampleHashTable.AllocEntryFromKey( sampleData );
	SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
	pSampleData->x = sampleData.x;
	pSampleData->y = sampleData.y;
	pSampleData->z = sampleData.z;
	pSampleData->m_Samples.AddToTail( sampleHandle );
	samplesAdded++;
	return handle;
UtlHashHandle_t SampleData_AddSample( sample_t *pSample, SampleHandle_t sampleHandle )
	UtlHashHandle_t handle = SampleData_Find( pSample );
	if( handle == g_SampleHashTable.InvalidHandle() )
	{
		handle = SampleData_InsertIntoHashTable( pSample, sampleHandle );
	}
	else
	{
		SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
		pSampleData->m_Samples.AddToTail( sampleHandle );
		samplesAdded++;
	}
	return handle;
void SampleData_Log( void )
	if

	{
		g_SampleHashTable.Log( "samplehash.txt" );
	}
bool PatchSampleData_CompareFunc( PatchSampleData_t const &src1, PatchSampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int PatchSampleData_KeyFunc( PatchSampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<PatchSampleData_t>	g_PatchSampleHashTable( SAMPLEHASH_NUM_BUCKETS,
												    SAMPLEHASH_GROW_SIZE,
													SAMPLEHASH_INIT_SIZE,
													PatchSampleData_CompareFunc, PatchSampleData_KeyFunc );
void GetPatchSampleHashXYZ( const Vector &vOrigin, int &x, int &y, int &z )
	x = ( int )( vOrigin.x / SAMPLEHASH_VOXEL_SIZE );
	y = ( int )( vOrigin.y / SAMPLEHASH_VOXEL_SIZE );
	z = ( int )( vOrigin.z / SAMPLEHASH_VOXEL_SIZE );
unsigned short IncrementPatchIterationKey()
	if ( g_PatchIterationKey == 0xFFFF )
	{
		g_PatchIterationKey = 1;
		for ( int i=0; i < g_Patches.Count(); i++ )
			g_Patches[i].m_IterationKey = 0;
	}
	else
	{
	

	}
	return g_PatchIterationKey;
void PatchSampleData_AddSample( CPatch *pPatch, int ndxPatch )
	int patchSampleMins[3], patchSampleMaxs[3];
	GetPatchSampleHashXYZ( pPatch->mins, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	GetPatchSampleHashXYZ( pPatch->maxs, patchSampleMaxs[0], patchSampleMaxs[1], patchSampleMaxs[2] );
	GetPatchSampleHashXYZ( pPatch->origin, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	memcpy( patchSampleMaxs, patchSampleMins, sizeof( patchSampleMaxs ) );
	Assert( patchSampleMins[0] <= patchSampleMaxs[0] && patchSampleMins[1] <= patchSampleMaxs[1] && patchSampleMins[2] <= patchSampleMaxs[2] );
	patchSampleMins[0] = min( patchSampleMins[0], patchSampleMaxs[0] );
	patchSampleMins[1] = min( patchSampleMins[1], patchSampleMaxs[1] );
	patchSampleMins[2] = min( patchSampleMins[2], patchSampleMaxs[2] );
	int iterateCoords[3];
	for ( iterateCoords[0]=patchSampleMins[0]; iterateCoords[0] <= patchSampleMaxs[0]; iterateCoords[0]++ )
	{
		for 
/* Copyright 2014-2015 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
typedef enum __attr_packed___
  OPERAND_LITERAL,
  OPERAND_TMP
} operand_type;
typedef struct
  operand_type type;
  union
  {
    idx_t uid;
    lit_cpointer_t lit_id;
  } data;
} operand;
typedef enum __attr_packed___
  VARG_FUNC_DECL,
  VARG_FUNC_EXPR,
  VARG_ARRAY_DECL,
  VARG_OBJ_DECL,
  VARG_CONSTRUCT_EXPR,
  VARG_CALL_EXPR
} varg_list_type;
operand empty_operand (void);
operand literal_operand (lit_cpointer_t);
operand eval_r

operand jsp_create_operand_for_in_special_reg (void);
bool operand_is_empty (operand);
void dumper_init (void);
void dumper_free (void);
void dumper_new_statement (void);
void dumper_new_scope (void);
void dumper_finish_scope (void);
void dumper_start_varg_code_sequence (void);
void dumper_finish_varg_code_sequence (void);
extern bool dumper_is_eval_literal (operand);
void dump_boolean_assignment (operand, bool);
operand dump_boolean_assignment_res (bool);
void dump_string_assignment (operand, lit_cpointer_t);
operand dump_string_assignment_res (lit_cpointer_t);
void dump_number_assignment (operand, lit_cpointer_t);
operand dump_number_assignment_res (lit_cpointer_t);
void dump_regexp_assignment (operand, lit_cpointer_t);
operand dump_regexp_assignment_res (lit_cpointer_t);
void dump_smallint_assignment (operand, idx_t);
operand dump_smallint_assignment_res (idx_t);
void dump_undefined_assignment (operand);
operand dump_undefined_assignment_res (void);
void dump_null_assignment (opera

operand dump_null_assignment_res (void);
void dump_variable_assignment (operand, operand);
operand dump_variable_assignment_res (operand);
void dump_varg_header_for_rewrite (varg_list_type, operand);
operand rewrite_varg_header_set_args_count (uint8_t);
void dump_call_additional_info (opcode_call_flags_t, operand);
void dump_varg (operand);
void dump_prop_name_and_value (operand, operand);
void dump_prop_getter_decl (operand, operand);
void dump_prop_setter_decl (operand, operand);
void dump_prop_getter (operand, operand, operand);
operand dump_prop_getter_res (operand, operand);
void dump_prop_setter (operand, operand, operand);
void dump_function_end_for_rewrite (void);
void rewrite_function_end (varg_list_type);
void dump_this (operand);
operand dump_this_res (void);
void dump_post_increment (operand, operand);
operand dump_post_increment_res (operand);
void dump_post_decrement (operand, operand);
operand dump_post_decrement_res (operand);
void dump_pre_increment (operand, operand)

operand dump_pre_increment_res (operand);
void dump_pre_decrement (operand, operand);
operand dump_pre_decrement_res (operand);
void dump_unary_plus (operand, operand);
operand dump_unary_plus_res (operand);
void dump_unary_minus (operand, operand);
operand dump_unary_minus_res (operand);
void dump_bitwise_not (operand, operand);
operand dump_bitwise_not_res (operand);
void dump_logical_not (operand, operand);
operand dump_logical_not_res (operand);
void dump_multiplication (operand, operand, operand);
operand dump_multiplication_res (operand, operand);
void dump_division (operand, operand, operand);
operand dump_division_res (operand, operand);
void dump_remainder (operand, operand, operand);
operand dump_remainder_res (operand, operand);
void dump_addition (operand, operand, operand);
operand dump_addition_res (operand, operand);
void dump_substraction (operand, operand, operand);
operand dump_substraction_res (operand, operand);
void dump_left_shift (operand, operand, operand);
ope

void dump_right_shift (operand, operand, operand);
operand dump_right_shift_res (operand, operand);
void dump_right_shift_ex (operand, operand, operand);
operand dump_right_shift_ex_res (operand, operand);
void dump_less_than (operand, operand, operand);
operand dump_less_than_res (operand, operand);
void dump_greater_than (operand, operand, operand);
operand dump_greater_than_res (operand, operand);
void dump_less_or_equal_than (operand, operand, operand);
operand dump_less_or_equal_than_res (operand, operand);
void dump_greater_or_equal_than (operand, operand, operand);
operand dump_greater_or_equal_than_res (operand, operand);
void dump_instanceof (operand, operand, operand);
operand dump_instanceof_res (operand, operand);
void dump_in (operand, operand, operand);
operand dump_in_res (operand, operand);
void dump_equal_value (operand, operand, operand);
operand dump_equal_value_res (operand, operand);
void dump_not_equal_value (operand, operand, operand);
operand dump_not_equal_val

void dump_equal_value_type (operand, operand, operand);
operand dump_equal_value_type_res (operand, operand);
void dump_not_equal_value_type (operand, operand, operand);
operand dump_not_equal_value_type_res (operand, operand);
void dump_bitwise_and (operand, operand, operand);
operand dump_bitwise_and_res (operand, operand);
void dump_bitwise_xor (operand, operand, operand);
operand dump_bitwise_xor_res (operand, operand);
void dump_bitwise_or (operand, operand, operand);
operand dump_bitwise_or_res (operand, operand);
void start_dumping_logical_and_checks (void);
void dump_logical_and_check_for_rewrite (operand);
void rewrite_logical_and_checks (void);
void start_dumping_logical_or_checks (void);
void dump_logical_or_check_for_rewrite (operand);
void rewrite_logical_or_checks (void);
void dump_conditional_check_for_rewrite (operand);
void rewrite_conditional_check (void);
void dump_jump_to_end_for_rewrite (void);
void rewrite_jump_to_end (void);
void start_dumping_assignment_express

operand dump_prop_setter_or_variable_assignment_res (operand, operand);
operand dump_prop_setter_or_addition_res (operand, operand);
operand dump_prop_setter_or_multiplication_res (operand, operand);
operand dump_prop_setter_or_division_res (operand, operand);
operand dump_prop_setter_or_remainder_res (operand, operand);
operand dump_prop_setter_or_substraction_res (operand, operand);
operand dump_prop_setter_or_left_shift_res (operand, operand);
operand dump_prop_setter_or_right_shift_res (operand, operand);
operand dump_prop_setter_or_right_shift_ex_res (operand, operand);
operand dump_prop_setter_or_bitwise_and_res (operand, operand);
operand dump_prop_setter_or_bitwise_xor_res (operand, operand);
operand dump_prop_setter_or_bitwise_or_res (operand, operand);
void dumper_set_break_target (void);
void dumper_set_continue_target (void);
void dumper_set_next_interation_target (void);
opcode_counter_t
dump_simple_or_nested_jump_for_rewrite (bool is_simple_jump,
                        

opcode_counter_t
rewrite_simple_or_nested_jump_and_get_next (opcode_counter_t jump_oc,
                                            opcode_counter_t target_oc);
void dump_continue_iterations_check (operand);
void start_dumping_case_clauses (void);
void dump_case_clause_check_for_rewrite (operand, operand);
void dump_default_clause_check_for_rewrite (void);
void rewrite_case_clause (void);
void rewrite_default_clause (void);
void finish_dumping_case_clauses (void);
void dump_delete (operand, operand, bool, locus);
operand dump_delete_res (operand, bool, locus);
void dump_typeof (operand, operand);
operand dump_typeof_res (operand);
opcode_counter_t dump_with_for_rewrite (operand);
void rewrite_with (opcode_counter_t);
void dump_with_end (void);
opcode_counter_t dump_for_in_for_rewrite (operand);
void rewrite_for_in (opcode_counter_t);
void dump_for_in_end (void);
void dump_try_for_rewrite (void);
void rewrite_try (void);
void dump_catch_for_rewrite (operand);
void rewrite_catch (void);

using std::stringstream;
namespace tut
    
/**
 * Testing reporter.
 */
struct reporter_test
    test_result tr1;
    test_result tr2;
    test_result tr3;
    test_result tr4;
    test_result tr5;
    reporter_test() 
        : tr1("foo", 1, "", test_result::ok),
          tr2("foo", 2, "", test_result::fail),
          tr3("foo", 3, "", test_result::ex),
          tr4("foo", 4, "", test_result::warn),
          tr5("foo", 5, "", test_result::term)
    {
    }
};
typedef test_group<reporter_test> tg;
typedef tg::object object;
tg reporter_test("default reporter");
template<>
template<>
void object::test<1>()
    stringstream ss;
    ss << tr1 << tr2 << tr3 << tr4 << tr5;
    ensure_equals("operator << formatter", ss.str(), ".[2=F][3=X][4=W][5=T]");
template<>
template<>
void object::test<2>()
    stringstream ss;
    reporter repo(ss);
    ensure_equals("ok count", repo.ok_count, 0);
    ensure_equals("fail count", repo.failures_count, 0);
    ensure_equals("ex count", repo.exception

    ensure_equals("warn count", repo.warnings_count, 0);
    ensure_equals("term count", repo.terminations_count, 0);
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.test_completed(tr2);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    ensure_equals("ok count", repo.ok_count, 1);
    ensure_equals("fail count", repo.failures_count, 2);
    ensure_equals("ex count", repo.exceptions_count, 3);
    ensure_equals("warn count", repo.warnings_count, 4);
    ensure_equals("term count", repo.terminations_count, 5);
    ensure(!repo.all_ok());
template<>
template<>
void object::test<3>()
    std::stringstream ss;
    tut::reporter repo(ss);
/*
 * ResourceLocator.h
 *
 *
 *  Created on: Aug 17, 2011
 *      Author: Martin Uhrin
 */
namespace sstbx {
namespace io {
class ResourceLocator
public:
  static const ::std::string ID_DELIMITER;
  ResourceLocator();
  /* implicit */ ResourceLocator(const ::boost::filesystem::path & path);
  ResourceLocator(const ::boost::filesystem::path & path, const ::std::string & resourceId);
  bool set(const ::std::string & locatorString);
  ::std::string string() const;
  const ::boost::filesystem::path & path() const;
  void setPath(const ::boost::filesystem::path & path);
  const ::std::string & id() const;
  void setId(const ::std::string & resourceId);
  bool empty() const;
  ResourceLocator & operator =(const ResourceLocator & rhs);
  ResourceLocator & makeRelative(const ::boost::filesystem::path & from);
private:
  ::boost::filesystem::path myPath;
  ::std::string myResourceId;
};
ResourceLocator absolute(const ResourceLocator & loc);
ResourceLocator relative(const ResourceLocator & to);
namespace obj
  class mPool : NonCopy
  {
  PRIVATE:
    struct Chunk
    {
      byte* block;
      byte* current;
      Chunk* next;
      Chunk (std::size_t size, Chunk* nextchunk_ = NULL)
        : block(new byte[size]), current(block), next(nextchunk_) {
      };
      
      ~Chunk () {
        delete[] block;
        if (next) delete next;
      }
      std::size_t used () const {
        return
          reinterpret_cast<std::size_t>(current) -
          reinterpret_cast<std::size_t>(block);
      }
    };
    
  PRIVATE:
    std::size_t size_;
    Chunk* chunk_;
  PRIVATE:
    std::size_t rest () const {
      return (size_ - chunk_->used());
    }
    
    void chunk_inc (Chunk* chunk, std::size_t size) {
      chunk->current =
        reinterpret_cast<byte*>
          (reinterpret_cast<std::size_t>(chunk->current) + size);
    }
    
  PUBLIC:
    enum { DEFAULT_SIZE = 4092 };
    
    mPool (std::size_t size = DEFAULT_SIZE) :
      size_(size), chunk_(new Chunk(size)) {};
 
/**
 *  @file LB_CPU_Load_Average_Monitor.h
 *
 *  @author Ossama Othman <ossama@uci.edu>
 */
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
/**
 * @class TAO_LB_CPU_Load_Average_Monitor
 *
 * @brief LoadMonitor implementation that monitors the overall CPU
 *        load on a given host.
 *
 * Loads returned from this load monitor are the average number of
 * processes in the "run" queue over a ***FIXME*** seconds averaged
 * over the number of processors.  For example, a load of 2 on a dual
 * CPU host is returned as an average load of 1 by this CPU load
 * monitor, a load of 5 on a quad CPU host will be reported as a load
 * of 1.25 (i.e. 5/4), and so on and so forth.
 */
class TAO_LoadBalancing_Export TAO_LB_CPU_Load_Average_Monitor
  : public virtual POA_CosLoadBalancing::LoadMonitor
public:
  /**
   * If no location is supplied the hostname or IP address is used by
   * default.
   */
  TAO_LB_CPU_Load_Average_Monitor (const ACE_TCHAR * location_id = 0,
                                   cons
namespace {
QString getStringFromJson(const json_t *json, const char* key)
    return QString::fromUtf8(json_string_value(json_object_get(json, key)));
ServerRepo ServerRepo::fromJSON(const json_t *json, json_error_t */* error */)
    ServerRepo repo;
    repo.id = getStringFromJson(json, "id");
    repo.name = getStringFromJson(json, "name");
    repo.description = getStringFromJson(json, "desc");
    repo.mtime = json_integer_value(json_object_get(json, "mtime"));
    repo.size = json_integer_value(json_object_get(json, "size"));
    repo.root = getStringFromJson(json, "root");
    repo.encrypted = json_is_true(json_object_get(json, "encrypted"));
    repo.type = getStringFromJson(json, "type");
    repo.owner = getStringFromJson(json, "owner");
    repo.permission = getStringFromJson(json, "permission");
    repo._virtual = json_is_true(json_object_get(json, "virtual"));
    if (repo.type == "grepo") {
        repo.group_name = repo.owner;
        repo.group_id = json_integer_value(
/*
** $Id$
** save bytecodes to file
** See Copyright Notice in lua.h
*/
static void DumpWord(int i, FILE* D) {
 byte out[2];
 WRITE_BE_UINT16(out, i);
 DumpBlock(out,2,D);
static void DumpLong(long i, FILE* D) {
 byte out[4];
 WRITE_BE_UINT32(out, i);
 DumpBlock(out,4,D);
/* LUA_NUMBER */
/* assumes sizeof(long)==4 and sizeof(float)==4 (IEEE) */
static void DumpFloat(float f, FILE* D) {
	byte out[4];
	WRITE_LE_UINT32(out, *(uint32*)(&f));
	DumpBlock(out, 4, D);
static void DumpCode(TProtoFunc* tf, FILE* D) {
 int size=CodeSize(tf);
 if (NotWord(size))
  fprintf(stderr,"luac: warning: "
	"\"%s\":%d code too long for 16-bit machines (%d bytes)\n",
	fileName(tf),tf->lineDefined,size);
 DumpLong(size,D);
 DumpBlock(tf->code,size,D);
static void DumpString(char* s, int size, FILE* D) {
 if (s == NULL)
  DumpWord(0,D);
 else {
  if (NotWord(size))
   luaL_verror("string too long (%d bytes): \"%.32s...\"",size,s);
  DumpWord(size,D);
  for(int i = 0; i < size; ++i)
	  fputc(s[i] ^ 0xFF, D);


static void DumpTString(TaggedString* s, FILE* D) {
 if (s == NULL) DumpString(NULL,0,D); else DumpString(s->str,s->u.s.len+1,D);
static void DumpLocals(TProtoFunc* tf, FILE* D) {
 int n;
 LocVar* lv;
 for (n=0,lv=tf->locvars; lv && lv->line>=0; lv++) ++n;
 DumpWord(n,D);
 for (lv=tf->locvars; lv && lv->line>=0; lv++) {
  DumpWord(lv->line,D);
  DumpTString(lv->varname,D);
 }
static void DumpFunction(TProtoFunc* tf, FILE* D);
static void DumpSubFunctions(TProtoFunc* tf, FILE* D) {
	int i,n;
	n = tf->nconsts;
	for (i=0; i<n; i++) {
		TObject* o=tf->consts+i;
		if (ttype(o) == LUA_T_PROTO) {
			DumpWord(i,D);
			DumpFunction(tfvalue(o),D);
		}
	}
	fputc('$',D);
static void DumpConstants(TProtoFunc* tf, FILE* D) {
 int i,n;
 n = tf->nconsts;
 DumpWord(n,D);
 for (i=0; i<n; i++) {
  TObject* o=tf->consts+i;
  switch (ttype(o)) {
   case LUA_T_NUMBER:
	fputc('N',D);
	DumpNumber(nvalue(o),D);
	break;
   case LUA_T_STRING:
	fputc('S',D);
	DumpTString(tsvalue(o),D);
	break;
   case LUA_T_PROT
using namespace Upp;
CONSOLE_APP_MAIN
	SetLanguage(LNG_ENGLISH);
	DUMP(Format("%d, %s", 123, "TEXT"));
	DUMP(Format("%2:s, %1:d", 123, "TEXT"));
	DUMP(Format("%010d", 123));
	DUMP(Format("%0*d", 11, 123));
	DUMP(Format("|%20<d|", 123));
	DUMP(Format("|%20>d|", 123));
	DUMP(Format("|%20=d|", 123));
	DUMP(Format("%d`pt", 123));
	DUMP(Format("%[empty]~d, %[empty]~d", 123, Null));
	DUMP(Format("%`", 123));
	DUMP(Format("%c", 65));
	DUMP(Format("%d", 123));
	DUMP(Format("%i", 123));
	DUMP(Format("%o", 123));
	DUMP(Format("%x", 123));
	DUMP(Format("%X", 123));
	DUMP(Format("%e", 1234567.89));
	DUMP(Format("%E", 1234567.89));
	DUMP(Format("%f", 1234567.89));
	DUMP(Format("%g", 1234567.89));
	DUMP(Format("%G", 1234567.89));
	DUMP(Format("%n", 1234567.89));
	DUMP(Format("%,n", 1234567.89));
	DUMP(Format("%ne", 1234567.89));
	DUMP(Format("%nf", 1234567.89e30));
	DUMP(Format("%nl", 1234567.89));
	DUMP(Format("%@nl", 1234567.89));
	DUMP(Format("%@,nl", 1234567.89));
	DUMP(Format("%v", 1234567.89))

	DUMP(Format("%ve", 1234567.89));
	DUMP(Format("%vf", 1234567.89e30));
	DUMP(Format("%vl", 1234567.89));
	DUMP(Format("%[1:one;2:two;3:three;another]s", 2));
	DUMP(Format("%[1:one;2:two;3:three;another]s", 20));
	DUMP(Format("%[3%1:one;2:two;3:three;another]s", 20));
	DUMP(Format("%month", 6));
	DUMP(Format("%Month", 6));
	DUMP(Format("%MONTH", 6));
	DUMP(Format("%mon", 6));
	DUMP(Format("%Mon", 6));
	DUMP(Format("%MON", 6));
	DUMP(Format("%day", 6));
	DUMP(Format("%Day", 6));
	DUMP(Format("%DAY", 6));
	DUMP(Format("%dy", 6));
	DUMP(Format("%Dy", 6));
	DUMP(Format("%DY", 6));
	DUMP(Format("%tw", 0));
	DUMP(Format("%tw", 5));
	DUMP(Format("%tw", 15));
	DUMP(Format("%0tw", 15));
	DUMP(Format("%a", 1));
	DUMP(Format("%a", 123));
	DUMP(Format("%A", 1));
	DUMP(Format("%A", 123));
	DUMP(Format("%r", 8));
	DUMP(Format("%R", 1231));
	DUMP(Format("%`", GetSysDate()));
	DUMP(Format("%`", GetSysTime()));
	DUMP(Format("%`", "text"));
	SetLanguage(LNG_('C', 'S', 'C', 'Z'));
	DUMP(Format("%`", GetS
/****************************************************************************/
/*                                                                          */
/*      æä»¶å:    BLZChunkFile.cpp                                         */
/*      åå»ºæ¥æ:  2010å¹´02æ09æ¥                                           */
/*      ä½è:      Sagasarate                                               */
/*                                                                          */
/*      æ¬è½¯ä»¶çæå½Sagasarate(sagasarate@sina.com)ææ                     */
/*      ä½ å¯ä»¥å°æ¬è½¯ä»¶ç¨äºä»»ä½åä¸åéåä¸è½¯ä»¶å¼åï¼ä½                      */
/*      å¿é¡»ä¿çæ­¤çæå£°æ                                                  */
/*                                                                          */
/****************************************************************************/
namespace D3DLib{
CBLZChunkFile::CBLZChunkFile(void)
	m_pData=NULL;
	m_DataSize=0;
	m_IsSelfRelease=false;
CBLZChunkFile::~CBLZChunkFile(void)
	Close();
BOOL CBLZChunkFile::Load(IFile

	Close();
	UINT DataSize=(UINT)pFile->GetSize();
	if(DataSize<sizeof(BLZ_CHUNK_HEADER))
		return FALSE;
	BYTE * pData=new BYTE[DataSize];	
	pFile->Seek(0,IFileAccessor::seekBegin);
	if(pFile->Read(pData,DataSize)<DataSize)
	{
		delete[] pData;
		return FALSE;
	}
	m_IsSelfRelease=true;
	return Load(pData,DataSize);
BOOL CBLZChunkFile::Load(BYTE * pData,UINT DataSize)
	m_pData=pData;
	m_DataSize=DataSize;
	BLZ_CHUNK_HEADER * pChunk=(BLZ_CHUNK_HEADER *)m_pData;
	UINT ChunkSize=m_DataSize;
	while(pChunk->ChunkSize+sizeof(BLZ_CHUNK_HEADER)<=ChunkSize)
	{		
		CChunkList * pChunkList=m_Chunks.New(pChunk->ChunkID);
		if(pChunkList)
		{
			pChunkList->Add(pChunk);
		}
		ChunkSize-=pChunk->ChunkSize+sizeof(BLZ_CHUNK_HEADER);
		if(ChunkSize<sizeof(BLZ_CHUNK_HEADER))
		{
			break;
		}
		pChunk=(BLZ_CHUNK_HEADER *)((BYTE *)pChunk+sizeof(BLZ_CHUNK_HEADER)+pChunk->ChunkSize);
	}
	void * Pos=m_Chunks.GetFirstObjectPos();
	while(Pos)
	{
		UINT Key;
		CChunkList * pChunkList=m_Chunks.GetNextObject(Pos,
SignalHandler *SignalHandler::instance = NULL;
EventHandler *SignalHandler::handlers[NSIG];
SignalHandler::SignalHandler() {
SignalHandler *SignalHandler::get_instance() {
    if (instance == NULL) {
        instance = new SignalHandler();
    }
    return instance;
void SignalHandler::destroy() {
    if (instance != NULL) {
        delete(instance);
        instance = NULL;
    }
EventHandler *SignalHandler::register_handler(int signal_number, EventHandler *handler) {
    EventHandler *old_handler = SignalHandler::handlers[signal_number];
    SignalHandler::handlers[signal_number] = handler;
    struct sigaction action;
    memset(&action, 0, sizeof(action));
    action.sa_handler = SignalHandler::dispatcher;
    sigemptyset(
    sigaddset(&action.sa_mask, signal_number);
    return old_handler;
void SignalHandler::dispatcher(int signal_number) {
    if (SignalHandler::handlers[signal_number] != 0) {
        SignalHandler::handlers[signal_number]->handle_signal(signal_number);
    }
i
char prompt_func( const char * str, const char * opts )
   return 'Y';
void model_status( Model * model, StatusTypeE type, unsigned ms, const char * fmt, ... )
Model * loadModel( const char * filename )
   Md3Filter f;
   Model * model = new Model;
   Model::ModelErrorE err = f.readFile( model, filename );
   if ( err != Model::ERROR_NONE )
   {
      fprintf( stderr, "%s: %s\n", filename, Model::errorToString( err ) );
      delete model;
      return NULL;
   }
   return model;
int main( int argc, char * argv[] )
   if ( argc < 2 )
   {
      fprintf( stderr, "No model files specified\n" );
      return -1;
   }
   msg_register_prompt( prompt_func, prompt_func, prompt_func );
   for ( int a = 1; a < argc; a++ )
   {
      printf( "testing normal calculation for %s\n", argv[a] );
      Model * model = loadModel( argv[a] );
      if ( model )
      {
         unsigned int acount = model->getAnimCount( Model::ANIMMODE_FRAME );
         for ( unsigned int anim = 0; anim < acount; anim++ 
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
EventCatcher::EventCatcher()
    RM::Events::addReceiver(this);
EventCatcher::~EventCatcher()
    RM::Events::delReceiver(this);
void EventCatcher::clear()
    entries.clear();
EventCatcher::EventLogEntries EventCatcher::allEvents() const
    return entries;
int EventCatcher::eventCount() const
    retur

int EventCatcher::eventCount(EventTypes type)
    int count = 0;
    foreach (const EventLogEntry& ele, entries) {
        if (ele.type == type) {
            count++;
        }
    }
    return count;
int EventCatcher::eventCount(EventTypes type, RM::Base* p1) const
    int count = 0;
    foreach (const EventLogEntry& ele, entries) {
        if (ele.type == type && ele.params.count() == 1 && ele.params[0] == p1) {
            count++;
        }
    }
    return count;
int EventCatcher::eventCount(EventTypes type, RM::Base* p1, RM::Base* p2) const
    int count = 0;
    foreach (const EventLogEntry& ele, entries) {
        if (ele.type == type && ele.params.count() == 2 && ele.params[0] == p1 &&
                ele.params[1] == p2) {
            count++;
        }
    }
    return count;
void EventCatcher::recordEvent(EventTypes type, RM::Base* p1)
    EventLogEntry ele;
    ele.type = type;
    ele.params << p1;
    entries << ele;
void EventCatcher::recordEvent(EventTypes type, RM::

    EventLogEntry ele;
    ele.type = type;
    ele.params << p1 << p2;
    entries << ele;
void EventCatcher::repositoryOpened(RM::Repo* repo)
    recordEvent(ecRepoOpened, repo);
void EventCatcher::repositoryAboutToClose(RM::Repo* repo)
    recordEvent(ecRepoAboutToClose, repo);
void EventCatcher::repositoryActivated(RM::Repo* repo)
    recordEvent(ecRepoActivated, repo);
void EventCatcher::repositoryDeactivated(RM::Repo* repo)
    recordEvent(ecRepoDeactivated, repo);
void EventCatcher::refTreeNodeCreated(RM::Repo* repo, RM::RefTreeNode* node)
    recordEvent(ecRefTreeNodeCreated, repo, node);
void EventCatcher::refTreeNodeAboutToBeDeleted(RM::Repo* repo, RM::RefTreeNode* node)
    recordEvent(ecRefTreeNodeAboutToBeRemoved, repo, node);
void EventCatcher::refCreated(RM::Repo* repo, RM::Ref* ref)
    recordEvent(ecRefCreated, repo, ref);
void EventCatcher::refAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref)
    recordEvent(ecRefAboutToBeRemoved, repo, ref);
void EventCatcher::refMoved

    recordEvent(ecRefMoved, repo, ref);
void EventCatcher::refHeadDetached(RM::Repo* repo, RM::Ref* ref)
    recordEvent(ecRefHeadDetached, repo, ref);
void EventCatcher::tagCreated(RM::Repo* repo, RM::Tag* tag)
    recordEvent(ecTagCreated, repo, tag);
void EventCatcher::tagAboutToBeDeleted(RM::Repo* repo, RM::Tag* tag)
    recordEvent(ecTagAboutToBeDeleted, repo, tag);
void EventCatcher::branchCreated(RM::Repo* repo, RM::Branch* branch)
    recordEvent(ecBranchCreated, repo, branch);
void EventCatcher::branchAboutToBeDeleted(RM::Repo* repo, RM::Branch* branch)
    recordEvent(ecBranchAboutToBeDeleted, repo, branch);
void EventCatcher::branchMoved(RM::Repo* repo, RM::Branch* branch)
    recordEvent(ecBranchMoved, repo, branch);
void EventCatcher::branchUpstreamChanged(RM::Repo* repo, RM::Branch* branch)
    recordEvent(ecBranchUpstreamChanged, repo, branch);
void EventCatcher::namespaceCreated(RM::Repo* repo, RM::Namespace* nameSpace)
    recordEvent(ecNamespaceCreated, repo, nameSpa

void EventCatcher::namespaceAboutToBeDeleted(RM::Repo* repo, RM::Namespace* nameSpace)
    recordEvent(ecNamespaceAboutToBeRemoved, repo, nameSpace);
void EventCatcher::refLogChanged(RM::Repo* repo, RM::RefLog* reflog)
    recordEvent(ecRefLogChanged, repo, reflog);
void EventCatcher::refLogNewEntry(RM::Repo* repo, RM::RefLog* reflog)
    recordEvent(ecRefLogNewEntry, repo, reflog);
void EventCatcher::stageCreated(RM::Repo* repo, RM::Ref* ref)
    recordEvent(ecStageCreated, repo, ref);
void EventCatcher::stageAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref)
    recordEvent(ecStageAboutToBeRemoved, repo, ref);
void EventCatcher::remoteCreated(RM::Repo* repo, RM::Remote* remote)
    recordEvent(ecRemoteCreated, repo, remote);
void EventCatcher::remoteAboutToBeDeleted(RM::Repo* repo, RM::Remote* remote)
    recordEvent(ecRemoteAboutToBeRemoved, repo, remote);
void EventCatcher::remoteModified(RM::Repo* repo, RM::Remote* remote)
    recordEvent(ecRemoteModified, repo, remote);
void EventCa
/*
 * Copyright Â© 2000-2003 Ingo Weinhold <ingo_weinhold@gmx.de>
 * All rights reserved. Distributed under the terms of the MIT licensce.
 */
template<int BYTES_PER_SAMPLE>
class SampleBuffer {
 protected:
	typedef	uint8				sample_block_t[BYTES_PER_SAMPLE];
 public:
	inline						SampleBuffer(void* buffer)
									: fBuffer((sample_block_t*)buffer) { }
	inline	void				operator+=(int samples) {
		fBuffer += samples;
	}
	inline	void				operator-=(int samples) {
		fBuffer -= samples;
	}
	inline	void				operator++(int) {
		fBuffer++;
	}
	inline	void				operator--(int) {
		fBuffer--;
	}
	inline	void*				operator+(int samples) {
		return fBuffer + samples;
	}
	inline	void*				operator-(int samples) {
		return fBuffer + samples;
	}
 protected:
			sample_block_t*		fBuffer;
};
template<typename sample_t>
class FloatSampleBuffer : public SampleBuffer<sizeof(float)> {
 public:
	inline						FloatSampleBuffer(void* buffer)
									: SampleBuffer<sizeof(float)>(buffer) {
	}
	inline	sample_t			ReadS

		return *((float*)fBuffer);
	}
	inline	void				WriteSample(sample_t value) {
		*((float*)fBuffer) = value;
	}
};
template<typename sample_t>
class IntSampleBuffer : public SampleBuffer<sizeof(int)> {
 public:
	inline						IntSampleBuffer(void* buffer)
									: SampleBuffer<sizeof(int)>(buffer) {
	}
	inline	sample_t			ReadSample() const {
		return (sample_t)*((int*)fBuffer) / (sample_t)0x7fffffff;
	}
	inline	void				WriteSample(sample_t value) {
		*((int*)fBuffer) = int(value * (sample_t)0x7fffffff);
	}
};
template<typename sample_t>
class ShortSampleBuffer : public SampleBuffer<sizeof(short)> {
 public:
	inline						ShortSampleBuffer(void* buffer)
									: SampleBuffer<sizeof(short)>(buffer) {
	}
	inline	sample_t			ReadSample() const {
		return (sample_t)*((short*)fBuffer) / (sample_t)32767;
	}
	inline	void				WriteSample(sample_t value) {
		*((short*)fBuffer) = short(value * (sample_t)32767);
	}
};
template<typename sample_t>
class UCharSampleBuffer : public SampleBuffer<sizeof(
/***************************************************************************
openBibleViewer - Bible Study Tool
Copyright (C) 2009-2012 Paul Walger <metaxy@walger.name>
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
*****************************************************************************/
Api::Api(QObject *parent) :
    QObject(parent), m_notesApi(nullptr), m_moduleApi(nullptr), m_searchApi(nullptr)
void Api::init()
    m_moduleApi = new ModuleApi(this);
    setAll(m_moduleApi);
    m_no
/**
*  Copyright (C) 2014 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
	namespace worker {
		class HistoryWorker : public RepoAbstractWorker
		{
			Q_OBJECT
		public:
			HistoryWorker(
				repo::RepoController  *controller,
				const repo::RepoController::RepoToken *token,
				const QString &database,
				const QString& project);
			~HistoryWorker();
		signals:
			void revisionFetched(repo::core::model::RevisionNode *);
	
/******************************************************************************
 * api_header.hpp
 *
 * Copyright (c) Daniel Davidson
 *
 * Distributed under the Boost Software License
 *******************************************************************************/
/*! 
 * \file api_header.hpp
 *
 * \brief 
 * 
 */
namespace fcs {
namespace examples {
namespace enums {
  enum API_first {
    API_first_0,
    API_first_1,
    API_first_2,
    API_first_3,
    API_first_4,
    API_first_5
  };
  enum { API_FIRST_NUMBER_ENTRIES = 6 };
  inline char const* to_c_str(API_first e) {
    char const* values[] = {
      "API_first_0",
      "API_first_1",
      "API_first_2",
      "API_first_3",
      "API_first_4",
      "API_first_5"
    };
    size_t index(e);
    return ((index < API_FIRST_NUMBER_ENTRIES)? values[index] : "INVALID_API_FIRST");
  }
  inline std::ostream& operator<<(std::ostream &out, API_first e) {
    return out << to_c_str(e);
  }
  enum API_second {
    API_second_0,
   

    API_second_2,
    API_second_3,
    API_second_4,
    API_second_5,
    API_second_6
  };
  enum { API_SECOND_NUMBER_ENTRIES = 7 };
  inline void from_c_str(char const* txt, API_second &value) {
    if(0 == std::strcmp("API_second_0", txt)) {
      value = API_second_0;
      return;
    }
    if(0 == std::strcmp("API_second_1", txt)) {
      value = API_second_1;
      return;
    }
    if(0 == std::strcmp("API_second_2", txt)) {
      value = API_second_2;
      return;
    }
    if(0 == std::strcmp("API_second_3", txt)) {
      value = API_second_3;
      return;
    }
    if(0 == std::strcmp("API_second_4", txt)) {
      value = API_second_4;
      return;
    }
    if(0 == std::strcmp("API_second_5", txt)) {
      value = API_second_5;
      return;
    }
    if(0 == std::strcmp("API_second_6", txt)) {
      value = API_second_6;
      return;
    }
    std::string msg("No API_second value corresponding to: ");
    msg += txt;
    throw std::runtime_error(txt);
  }
  inline c

    char const* values[] = {
      "API_second_0",
      "API_second_1",
      "API_second_2",
      "API_second_3",
      "API_second_4",
      "API_second_5",
      "API_second_6"
    };
    size_t index(e);
    return ((index < API_SECOND_NUMBER_ENTRIES)? values[index] : "INVALID_API_SECOND");
  }
  inline std::ostream& operator<<(std::ostream &out, API_second e) {
    return out << to_c_str(e);
  }
  enum API_mask_first {
    API_masked_first_0 = 1,
    API_masked_first_1 = 2,
    API_masked_first_2 = 4,
    API_masked_first_3 = 8,
    API_masked_first_4 = 16,
    API_masked_first_5 = 32,
    API_masked_first_6 = 64
  };
  enum { API_MASK_FIRST_NUMBER_ENTRIES = 7 };
  inline bool test_api_mask_first(int value, API_mask_first e) {
    return (e & value) == e;
  }
  inline void set_api_mask_first(int &value, API_mask_first e) {
    value |= e;
  }
  inline void clear_api_mask_first(int &value, API_mask_first e) {
    value &= ~e;
  }
  inline void dump_api_mask_first(std::ostream &o

    out << '(';
    if(test_api_mask_first(e, API_masked_first_0)) {
      out << "API_masked_first_0,";
    }
    if(test_api_mask_first(e, API_masked_first_1)) {
      out << "API_masked_first_1,";
    }
    if(test_api_mask_first(e, API_masked_first_2)) {
      out << "API_masked_first_2,";
    }
    if(test_api_mask_first(e, API_masked_first_3)) {
      out << "API_masked_first_3,";
    }
    if(test_api_mask_first(e, API_masked_first_4)) {
      out << "API_masked_first_4,";
    }
    if(test_api_mask_first(e, API_masked_first_5)) {
      out << "API_masked_first_5,";
    }
    if(test_api_mask_first(e, API_masked_first_6)) {
      out << "API_masked_first_6,";
    }
    out << ')';
  }
  enum API_mask_second {
    API_masked_second_0 = 1,
    API_masked_second_1 = 2,
    API_masked_second_2 = 4,
    API_masked_second_3 = 8,
    API_masked_second_4 = 16,
    API_masked_second_5 = 32,
    API_masked_second_6 = 64
  };
  enum { API_MASK_SECOND_NUMBER_ENTRIES = 7 };
  inline bool te

    return (e & value) == e;
  }
  inline void set_api_mask_second(int &value, API_mask_second e) {
    value |= e;
  }
  inline void clear_api_mask_second(int &value, API_mask_second e) {
    value &= ~e;
  }
  inline void dump_api_mask_second(std::ostream &out, int e) {
    out << '(';
    if(test_api_mask_second(e, API_masked_second_0)) {
      out << "API_masked_second_0,";
    }
    if(test_api_mask_second(e, API_masked_second_1)) {
      out << "API_masked_second_1,";
    }
    if(test_api_mask_second(e, API_masked_second_2)) {
      out << "API_masked_second_2,";
    }
    if(test_api_mask_second(e, API_masked_second_3)) {
      out << "API_masked_second_3,";
    }
    if(test_api_mask_second(e, API_masked_second_4)) {
      out << "API_masked_second_4,";
    }
    if(test_api_mask_second(e, API_masked_second_5)) {
      out << "API_masked_second_5,";
    }
    if(test_api_mask_second(e, API_masked_second_6)) {
      out << "API_masked_second_6,";
    }
    out << ')';
  }
  en

    API_wa_42 = 42,
    API_wa_77 = 77
  };
  enum { API_WITH_ASSIGNMENTS_NUMBER_ENTRIES = 2 };
  inline void from_c_str(char const* txt, API_with_assignments &value) {
    if(0 == std::strcmp("API_wa_42", txt)) {
      value = API_wa_42;
      return;
    }
    if(0 == std::strcmp("API_wa_77", txt)) {
      value = API_wa_77;
      return;
    }
    std::string msg("No API_with_assignments value corresponding to: ");
    msg += txt;
    throw std::runtime_error(txt);
  }
  inline char const* to_c_str(API_with_assignments e) {
    switch(e) {
      case API_wa_42: return "API_wa_42";
      case API_wa_77: return "API_wa_77";
    }
    return "INVALID_API_WITH_ASSIGNMENTS";
  }
  inline std::ostream& operator<<(std::ostream &out, API_with_assignments e) {
    return out << to_c_str(e);
  }
  enum API_shorten_long_name {
    API_shorten_long_name_0,
    API_shorten_long_name_1,
    API_shorten_long_name_2,
    API_shorten_long_name_3,
    API_shorten_long_name_4,
    API_shorten_long_na
class AssetLocatorTestSuite : public Test::Suite
public:
    AssetLocatorTestSuite( cards::AssetLocator* assetLocator, std::string className )
        : mAssetLocator( assetLocator )
    {
        mClassMsg = std::string("Class: ") + className;
        mAssetTag = new cards::AssetTagImpl( "foo" );
        location0 = "bar0";
        location1 = "bar1";
        
        TEST_ADD(AssetLocatorTestSuite::addAndRetrieveLOD)
        TEST_ADD(AssetLocatorTestSuite::addAndRetrieveSecondLOD)
        TEST_ADD(AssetLocatorTestSuite::removeAndRetrieveLOD)
        TEST_ADD(AssetLocatorTestSuite::updateAndRetrieveLOD)
        TEST_ADD(AssetLocatorTestSuite::removeToCleanupAsset)
    }
    ~AssetLocatorTestSuite()
    {
        delete mAssetTag;
    }    
private:
    std::string mClassMsg;
    cards::AssetLocator* mAssetLocator;
    cards::AssetTag* mAssetTag;
    std::string location0;
    std::string location1;
    void addAndRetrieveLOD()
    {
        mAssetLocator->addLevelOfDetailLocation( mAs

        cards::AssetLocator::Locations expected;
        expected.push_back( location0 );
        TEST_ASSERT_MSG( expected == mAssetLocator->getFilepath( mAssetTag ), mClassMsg.c_str() );
    }
    void addAndRetrieveSecondLOD()
    {
        mAssetLocator->addLevelOfDetailLocation( mAssetTag, 1, location1 );
        cards::AssetLocator::Locations expected;
        expected.push_back( location0 );
        expected.push_back( location1 );
        TEST_ASSERT_MSG( expected == mAssetLocator->getFilepath( mAssetTag ), mClassMsg.c_str() );
    }
    void removeAndRetrieveLOD()
    {
        mAssetLocator->removeLevelOfDetailLocation( mAssetTag, 1 );
        cards::AssetLocator::Locations expected;
        expected.push_back( location0 );
        TEST_ASSERT_MSG( expected == mAssetLocator->getFilepath( mAssetTag ), mClassMsg.c_str() );
    }
    void updateAndRetrieveLOD()
    {
        mAssetLocator->updateLevelOfDetailLocation( mAssetTag, 0, location1 );
        cards::AssetLocator::Loca
inline Stream::Stream() : m_precision(6)
	resetManipulators();
inline Stream& Stream::operator >> (c8& value)
	read(&value,1);
	return *this;
inline Stream& Stream::operator >> (u8& value)
	value = static_cast<u8>(readUint());
	return *this;
inline Stream& Stream::operator >> (s8& value)
	value = static_cast<s8>(readUint());
	return *this;
inline Stream& Stream::operator >> (u16& value)
	value = static_cast<u16>(readUint());
	return *this;
inline Stream& Stream::operator >> (s16& value)
	value = static_cast<s16>(readUint());
	return *this;
inline Stream& Stream::operator >> (u32& value)
	value = static_cast<u32>(readUint());
	return *this;
inline Stream& Stream::operator >> (s32& value)
	value = static_cast<s32>(readUint());
	return *this;
inline Stream& Stream::operator >> (u64& value)
	value = static_cast<u64>(readUint());
	return *this;
inline Stream& Stream::operator >> (s64& value)
	value = static_cast<s64>(readUint());
	return *this;
inline Stream& Stream::operator >> (f32& value

	value = readFloat();
	return *this;
inline int Stream::size()
	int current = tell();
	seek(End, 0);
	int size = tell();
	seek(Start, current);
	return size;
inline void Stream::intToAscii(s64 value)
	uintToAscii(static_cast<u64>(value), m_hex, m_width, m_fillchar, true);
inline Stream& Stream::operator << (Stream& (*_f)(Stream&))
	return _f(*this);
inline Stream& Stream::operator << (DataPtr<u8> buffer)
	write(buffer.objects(), buffer.count());
	return *this;
template<typename Argument> inline Stream& Stream::operator << (const Manipulator<Argument>& manipulator)
	return manipulator.m_function(*this, manipulator.m_argument);
template<class T> inline bool Stream::read(DataPtr<T> buffer)
	return read(reinterpret_cast<u8*>(buffer.objects()), sizeof(T) * buffer.count());
template<class T> inline bool Stream::write(DataPtr<T> buffer)
	return uint(write(reinterpret_cast<const u8*>(buffer.objects()), sizeof(T) * buffer.count())) == (sizeof(T) * buffer.count()) ? true : false;
inline void St

	m_hex = false;
	m_precision = 6;
	m_width = 0;
	m_fillchar = ' ';
inline void Stream::setHex(bool hex)
	m_hex = hex;
inline void Stream::setPrecision(uint precision)
	m_precision = precision;
inline void Stream::setWidth(uint width)
	m_width = width;
inline void Stream::setFill(c8 fillchar)
	m_fillchar = fillchar;
inline Stream& _setprecision(Stream& stream, uint precision)
	stream.setPrecision(precision);
	return stream;
inline Stream::Manipulator<uint> setprecision(uint precision)
	return Stream::Manipulator<uint>(_setprecision, precision);
inline Stream& _setw(Stream& stream, uint width)
	stream.setWidth(width);
	return stream;
inline Stream::Manipulator<uint> setw(uint width)
	return Stream::Manipulator<uint>(_setw, width);
inline Stream& _setfill(Stream& stream, c8 fillchar)
	stream.setFill(fillchar);
	return stream;
inline Stream::Manipulator<c8> setfill(c8 fillchar)
	return Stream::Manipulator<c8>(_setfill, fillchar);
inline Stream& flush(Stream& stream)
	stream.flush();
	retu
/*
				Copyright <SWGEmu>
		See file COPYING for copying conditions.*/
PetTrainingConversationObserverImplementation::PetTrainingConversationObserverImplementation(ConversationTemplate* conversationTemplate) :
	ConversationObserverImplementation(conversationTemplate) {
	registerScreenHandler(PetTrainingScreenHandler::STARTSCREENHANDLERID, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETATTACKCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETCLEARPOINTSCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETCOMMANDREPAIR, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFOLLOWCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFOLLOWOTHERCOMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFORMATION1COMMAND, &screenHandler);
	registerScreenHandler(PetTrainingScreenHandler::PETFORMATION2COMMAND, &screenHandler);
	registerScreenHandler(PetTrainingSc
DbService::DbService()
    scientistRepo = ScientistRepository();
    computerRepo = ComputerRepository();
    connectRepo = ConnectRepository();
void DbService::addS(Scientist s)
    scientistRepo.add(s);
void DbService::addC(Computer c)
    computerRepo.add(c);
void DbService::addID(int scientist_id, int computer_id)
    connectRepo.add(scientist_id, computer_id);
list <Scientist> DbService::get_allScientists()
    return scientistRepo.get_allscientists();
list<Computer> DbService::get_allComputers()
    return computerRepo.get_allcomputers();
list<Connect> DbService::get_allConnections()
    return connectRepo.get_allconnections();
list <Scientist> DbService::sort_scientists(int col, int mod)
    return scientistRepo.sort_function(col, mod);
list<Computer> DbService::sort_computers(int col, int mod)
    return computerRepo.sort_function(col, mod);
list<Connect> DbService::sort_connections(int col, int mod)
    return connectRepo.sort_function(col, mod);
list <Scientist> DbService::s

    return scientistRepo.search_function(s);
list<Computer> DbService::search_computers(string s)
    return computerRepo.search_function(s);
list<Connect> DbService::search_connections(string s)
    return connectRepo.search_function(s);
list <Scientist> DbService::sort_and_search_scientists(int col, int mod, string s)
    return scientistRepo.sort_and_search_function(col, mod, s);
list<Computer> DbService::sort_and_search_computers(int col, int mod, string s)
    return computerRepo.sort_and_search_function(col, mod, s);
list <Connect> DbService::sort_and_search_connections(int col, int mod, string s)
    return connectRepo.sort_and_search_function(col, mod, s);
list<Scientist> DbService::edit_scientists_imagePath(Scientist scientist, string newPath)
    return scientistRepo.edit_function_imagePath(scientist, newPath);
list<Computer> DbService::edit_computers_imagePath(Computer computer, string newPath)
    return computerRepo.edit_function_imagePath(computer, newPath);
list<Scienti
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
istream& repo::core::RepoCSV::readLine(
        istream& stream,
        std::list<std::string>& tokenizedLine)
    tokenizedLine.clear();
    std::string line;
    getline(stream, line);
    std::stringstream ss(line);
    std::string field;
    while (std::getline(ss, field, delimiter))
        tokenizedLine.push_back(field);
    return stream;
is

        std::list<std::list<string> >& data)
    data.clear();
    std::list<std::string> tokenizedLine;
    while(readLine(stream, tokenizedLine))
        data.push_back(tokenizedLine);
    return stream;
repo::core::RepoNodeAbstractSet repo::core::RepoCSV::readMetadata(
        const std::string& path,
        std::list<string>& headers,
		const char delimeter)
    RepoNodeAbstractSet metadata;
    ifstream file(path);
	setDelimiter(delimeter);
    std::list<std::string> tokens;
    while(file.good() && readLine(file, tokens))
    {
        if (headers.empty())
            headers = tokens;
        else if (!tokens.empty())
            metadata.insert(new RepoNodeMetadata(headers, tokens, *tokens.begin()));
    }
    file.close();
    return metadata;
void repo::core::RepoCSV::print(std::list<std::list<string> > &matrix)
    for (std::list<string> line : matrix)
    {
        for (std::string token : line)
            std::cerr << token << ", ";
        std::cerr << std::endl;
    }
namespace omega {
CodeMethodInvokeExpression::~CodeMethodInvokeExpression() {}
CodeMethodInvokeExpression::CodeMethodInvokeExpression() : CodeExpression() {
  this->m_method = nullptr;
  this->m_parameters = new CodeExpressionCollection();
CodeExpressionCollection* CodeMethodInvokeExpression::parameters() {
  return this->m_parameters;
CodeMethodReferenceExpression* CodeMethodInvokeExpression::method() {
  return this->m_method;
void CodeMethodInvokeExpression::method(CodeMethodReferenceExpression* value) {
  this->m_method = value;
void CodeMethodInvokeExpression::accept(ICodeObjectVisitor* visitor) {
  visitor->visit(this);
bool CodeMethodInvokeExpression::type_of(CodeObjectKind kind) {
  return kind == CodeObjectKind::CodeMethodInvokeExpression ||
         CodeExpression::type_of(kind);
void CodeMethodInvokeExpression::scope(CodeScope* scope) {
  CodeExpression::scope(scope);
  if (this->m_method != nullptr) this->m_method->scope(scope);
  for (auto x : *this->m_parameters) x->scope
ChunkByChunkFileReader::ChunkByChunkFileReader(const char fileName[])
    : m_lastChunk(0)
    , m_nextChunkToRead(0)
    m_inputFile.open(fileName, std::ios::in);
    m_inputFile.exceptions ( std::ifstream::failbit | std::ifstream::badbit );
    if ( !m_inputFile.is_open() )
    {
        std::cerr << "Could not open file [" << fileName << "]" << std::endl;
        exit(-1);
    }
    m_inputFile.seekg(0, std::ios::end);
    m_fileSize = m_inputFile.tellg();
    m_lastChunk = numberOfChunks() - 1;
    m_inputFile.seekg(std::ios::beg);
    m_begin = ChunkByChunkFileReaderIterator(this, 0);
    m_end = ChunkByChunkFileReaderIterator(this, m_lastChunk + 1);
    Log::get() << "Constructing reader for file [" << fileName << "]" << Log::Endl;
    Log::get() << "File size: " << m_fileSize << Log::Endl;
    Log::get() << "Last chunk: " << m_lastChunk << Log::Endl;
    Log::get() << "Chunk ByteSize: " << ChunkByteSize << Log::Endl;
unsigned int ChunkByChunkFileReader::numberOfChunks()
    retu

                std::ceil(
                    static_cast<float>(m_fileSize) / static_cast<float>(ChunkByteSize)
                    )
                );
FileChunk ChunkByChunkFileReader::readNextChunk()
    FileChunk chunk;
    chunk.init();
    if (m_nextChunkToRead == m_lastChunk)
    {
        unsigned int remaining = m_fileSize - m_lastChunk * ChunkByteSize;
        m_inputFile.read(chunk.dataPtr(), remaining);
        chunk.setSize(remaining);
    }
    else
    {
        m_inputFile.read(chunk.dataPtr(), ChunkByteSize);
        chunk.setSize(ChunkByteSize);
    }
    ++m_nextChunkToRead;
    Log::get() << "[" << chunk.data() << "] " << chunk.size() << " bytes read" << Log::Endl;
    return chunk;
FileChunk ChunkByChunkFileReader::chunkAt(unsigned int chunkNo)
    FileChunk returnValue;
    if (chunkNo <= m_lastChunk)
    {
        if (chunkNo == m_nextChunkToRead)
        {
            returnValue = readNextChunk();
        }
        else
        {
            std::cerr << "Tr
/**
**    Copyright (c) 2011 by Nils Fenner
**
**    This file is part of MsPiggit.
**
**    MsPiggit is free software: you can redistribute it and/or modify
**    it under the terms of the GNU General Public License as published by
**    the Free Software Foundation, either version 3 of the License, or
**    (at your option) any later version.
**
**    MsPiggit is distributed in the hope that it will be useful,
**    but WITHOUT ANY WARRANTY; without even the implied warranty of
**    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**    GNU General Public License for more details.
**
**    You should have received a copy of the GNU General Public License
*/
RepoWindow::RepoWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::RepoWindow)
    , _repoView(new RepoView())
    ui->setupUi(this);
    setupMainMenu();
    setCentralWidget(_repoView);
    ui->treeSubmodules->setAttribute(Qt::WA_MacShowFocusRect, 0);
    ui->treeSubmodules->setModel(&_repoModel);
 

    connect(ModelAccess::instance().commitModelPtr(), SIGNAL(initialized()), this, SLOT(initializeRepoStatus()));
RepoWindow::~RepoWindow()
    delete ui;
void RepoWindow::setupMainMenu()
    QMenu * m = ui->menuBar->addMenu("Repository");
    QAction * a = m->addAction("Open ...", this, SLOT(openRepository()));
    a->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_O));
    a->setShortcutContext(Qt::ApplicationShortcut);
void RepoWindow::openRepository()
    QFileDialog *fd = new QFileDialog(this);
    fd->setFilter(QDir::Dirs | QDir::NoDotAndDotDot | QDir::Hidden);
    fd->setFileMode(QFileDialog::Directory);
    fd->setDirectory(QDir::home());
    fd->setWindowTitle( tr("Open a Git repository") );
    fd->open(this, SLOT(onOpenRepository()));
void RepoWindow::onOpenRepository()
    QFileDialog *fd = dynamic_cast<QFileDialog *>(sender());
    Q_ASSERT(fd != 0);
    if ( fd->selectedFiles().isEmpty() )
        return;
    setupRepoView(fd->selectedFiles().first());
void RepoWindow::initi

    ui->statusBar->showMessage(tr("%1 commits in repository").arg(ModelAccess::instance().commitModel().rowCount()));
void RepoWindow::setupRepoView(QString path)
    using namespace LibQGit2;
    if (path.isEmpty() || !checkDirExists(path))
        return;
    QGitRepository repo;
    if ( !repo.discoverAndOpen(path) )
    {
        QMessageBox::critical( this, tr("Unable to open repository.")
                               , QString("Unable to open repository:\n%2").arg(QGitError::lastMessage())
                               );
    }
    updateWindowTitle( repo );
    _repoModel.initialize( repo );
    ModelAccess::instance().reinitialize( repo );
void RepoWindow::updateWindowTitle(const LibQGit2::QGitRepository &repo)
    QString repoText;
    if (repo.isNull())
    {
        repoText = tr("<< no repository >>");
    }
    else
    {
        repoText = repo.name();
        if (repo.isBare())
            repoText += QString(" (BARE)");
    }
    setWindowTitle( QString("Repository:
namespace okey
	ErrorHandler* ErrorHandler::_pHandler = ErrorHandler::defaultHandler();
	FastMutex ErrorHandler::_mutex;
	ErrorHandler::ErrorHandler()
	{
	}
	ErrorHandler::~ErrorHandler()
	{
	}
	void ErrorHandler::exception(const Exception& exc)
	{
	}
	void ErrorHandler::exception(const std::exception& exc)
	{
	}
	void ErrorHandler::exception()
	{
	}
	void ErrorHandler::handle(const Exception& exc)
	{
		FastMutex::ScopedLock lock(_mutex);
		try
		{
			_pHandler->exception(exc);
		}
		catch (...)
		{
		}
	}
	void ErrorHandler::handle(const std::exception& exc)
	{
		FastMutex::ScopedLock lock(_mutex);
		try
		{
			_pHandler->exception(exc);
		}
		catch (...)
		{
		}
	}
	void ErrorHandler::handle()
	{
		FastMutex::ScopedLock lock(_mutex);
		try
		{
			_pHandler->exception();
		}
		catch (...)
		{
		}
	}
	ErrorHandler* ErrorHandler::set(ErrorHandler* pHandler)
	{
		FastMutex::ScopedLock lock(_mutex);
		ErrorHandler* pOld = _pHandler;
		_pHandler = pHandler;
		return pOld;
	}
	ErrorHandler*
/*---------------------------------------------------------------------\
|                          ____ _   __ __ ___                          |
|                         |__  / \ / / . \ . \                         |
|                           / / \ V /|  _/  _/                         |
|                          / /__ | | | | | |                           |
|                         /_____||_| |_| |_|                           |
|                                                                      |
\---------------------------------------------------------------------*/
namespace zypp
  namespace repo
  {
    class RepoMirrorList
    {
      public:
	RepoMirrorList( const Url & url_r, const Pathname & metadatapath_r, bool mirrorListForceMetalink_r );
        RepoMirrorList( const Url & url_r )
	: RepoMirrorList( url_r, Pathname(), false )
	{}
        const std::vector<Url> & getUrls() const
        { return _urls; }
        std::vector<Url> & getUrls()
        { return _urls; }

/*
 * MONA
 * Copyright (C) 1997-2013 Aarhus University.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the  Free Software
 * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335,
 * USA.
 */
using std::cout;
extern SymbolTable symbolTable;
void 
ASTComponent::dump()
  cout << name;
  if (path)
    path->dump();
  else
    cout << "[?]";
  cout << ":" << type;
void
ASTComponentList::dump()
  for (iterator

    if (i != begin())
      cout << ",";
    (*i)->dump();
  }
void
ASTVariant::dump()
  cout << name;
  if (path)
    path->dump();
  else
    cout << "[?]";
  cout << "(";
  if (components)
    components->dump();
  cout << ")";
void
ASTVariantList::dump()
  for (iterator i = begin(); i != end(); i++) {
    if (i != begin())
      cout << ",";
    (*i)->dump();
  }
void
BitList::dump()
  cout << "[";
  for (iterator i = begin(); i != end(); i++)
    if (*i == Zero)
      cout << "0";
    else
      cout << "1";
  cout << "]";
void 
ASTList::dump()
  iterator i;
  for (i = begin(); i != end(); i++) {
    cout << ","; (*i)->dump();
  }
void 
ASTUniv::dump()
  cout << symbolTable.lookupSymbol(u);
void 
ASTTerm1_Var1::dump()
  cout << "Var1 " << symbolTable.lookupSymbol(n);
  
void 
ASTTerm1_Dot::dump()
  cout << "Dot("; t->dump(); cout << ",";
  BitList::iterator i;
  for (i = bits->begin(); i != bits->end(); i++)
    if (*i == Zero)
      cout << "0";
    else
      cout << "1";
  cou

    
void 
ASTTerm1_Up::dump()
  cout << "Up("; t->dump(); cout << ")";
    
void
ASTTerm1_Root::dump()
  if (univ == -1)
    cout << "Root";
  else
    cout << "Root(" << symbolTable.lookupSymbol(univ) << ")";
void 
ASTTerm1_Int::dump()
  cout << "Int " << n;
    
void 
ASTTerm1_Plus::dump()
  cout << "Plus1("; t->dump(); cout << "," << n << ")";
    
void 
ASTTerm1_Minus::dump()
  cout << "Minus1("; t->dump(); cout << "," << n << ")";
    
void 
ASTTerm1_PlusModulo::dump()
  cout << "PlusModulo1("; t1->dump(); cout << ","  << n << ",";
  t2->dump(); cout << ")";
    
void 
ASTTerm1_MinusModulo::dump()
  cout << "MinusModulo1("; t1->dump(); cout << "," << n << ",";
  t2->dump(); cout << ")";
    
void 
ASTTerm1_Min::dump()
  cout << "Min("; T->dump(); cout << ")";
    
void 
ASTTerm1_Max::dump()
  cout << "Max("; T->dump(); cout << ")";
    
void 
ASTTerm1_TreeRoot::dump()
  cout << "TreeRoot("; T->dump(); cout << ")";
    
void 
ASTTerm2_Var2::dump()
  cout << "Var2 " << symbolTable

    
void 
ASTTerm2_VarTree::dump()
  cout << "Tree " << symbolTable.lookupSymbol(n);
    
void 
ASTTerm2_Dot::dump()
  cout << "Dot("; T->dump(); cout << ",";
  BitList::iterator i;
  for (i = bits->begin(); i != bits->end(); i++)
    if (*i == Zero)
      cout << "0";
    else
      cout << "1";
  cout << ")";
    
void 
ASTTerm2_Up::dump()
  cout << "Up("; T->dump(); cout << ")";
    
void 
ASTTerm2_Empty::dump()
  cout << "Empty";
    
void 
ASTTerm2_Union::dump()
  cout << "Union("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTTerm2_Inter::dump()
  cout << "Inter("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTTerm2_Setminus::dump()
  cout << "Setminus("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTTerm2_Set::dump()
  ASTList::iterator i;
  cout << "Set(";
  for (i = elements->begin(); i != elements->end();) {
    (*i)->dump();
    if (++i != elements->end()) 
      cout << ",";
  }
  cout << ")";
    
void 
ASTTerm2_Plus:

  cout << "Plus2("; T->dump(); cout << "," << n << ")";
    
void 
ASTTerm2_Minus::dump()
  cout << "Minus2("; T->dump(); cout << "," << n << ")";
    
void 
ASTTerm2_Interval::dump()
  cout << "Interval("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTTerm2_PresbConst::dump()
  cout << "PresbConst(" << value << ")"; 
void 
ASTTerm2_Formula::dump()
  cout << "Term2Formula(" << symbolTable.lookupSymbol(fresh) << ",";
  f->dump(); cout << ")";
void 
ASTForm_Var0::dump()
  cout << "Var0 " << symbolTable.lookupSymbol(n);
    
void 
ASTForm_True::dump()
  cout << "True";
    
void 
ASTForm_False::dump()
  cout << "False";
    
void 
ASTForm_In::dump()
  cout << "In("; t1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_Notin::dump()
  cout << "Notin("; t1->dump(); cout << ","; T2->dump(); cout << ")";
    
void
ASTForm_RootPred::dump()
  cout << "Root("; t->dump(); cout << ",["; ul->dump(); cout << ")"; 
void 
ASTForm_EmptyPred::dump()
  cout << "EmptyPre

    
void 
ASTForm_FirstOrder::dump()
  cout << "FirstOrder("; t->dump(); cout << ")";
    
void 
ASTForm_Sub::dump()
  cout << "Sub("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_Equal1::dump()
  cout << "Equal1("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_Equal2::dump()
  cout << "Equal2("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_NotEqual1::dump()
  cout << "NotEqual1("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_NotEqual2::dump()
  cout << "NotEqual2("; T1->dump(); cout << ","; T2->dump(); cout << ")";
    
void 
ASTForm_Less::dump()
  cout << "Less("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_LessEq::dump()
  cout << "LessEq("; t1->dump(); cout << ","; t2->dump(); cout << ")";
    
void 
ASTForm_WellFormedTree::dump()
  cout << "WellFormedTree("; T->dump(); cout << ")";
    
void 
ASTForm_Impl::dump()
  cout << "Impl("; f1->dump(); cout << ","; f2->

    
void 
ASTForm_Biimpl::dump()
  cout << "Biimpl("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_And::dump()
  cout << "And("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_IdLeft::dump()
  cout << "IdLeft("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_Or::dump()
  cout << "Or("; f1->dump(); cout << ","; f2->dump(); cout << ")";
    
void 
ASTForm_Not::dump()
  cout << "Not("; f->dump(); cout << ")";
    
void 
ASTForm_Ex0::dump()
  cout << "Ex0("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_Ex1::dump()
  cout << "Ex1("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_Ex2::dump()
  cout << "Ex2("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_All0::dump()
  cout << "All0("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_All1::dump()
  cout << "All1("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_All2::d

  cout << "All2("; vl->dump(); cout << ","; f->dump(); cout << ")";
    
void 
ASTForm_Let0::dump()
  IdentList::iterator ident;
  FormList::iterator form;
  cout << "Let0(";
  for (ident = defIdents->begin(), form = defForms->begin(); 
       ident != defIdents->end(); ident++, form++) {
    cout << "(Var0 " << symbolTable.lookupSymbol(*ident) 
	 << ","; (*form)->dump(); cout << "),";
  }
  f->dump(); cout << ")";
    
void 
ASTForm_Let1::dump()
  IdentList::iterator ident;
  Term1List::iterator term;
  cout << "Let1(";
  for (ident = defIdents->begin(), term = defTerms->begin(); 
       ident != defIdents->end(); ident++, term++) {
    cout << "(Var1 " << symbolTable.lookupSymbol(*ident) 
      << ","; (*term)->dump(); cout << "),";
  }
  f->dump(); cout << ")";
    
void 
ASTForm_Let2::dump()
  IdentList::iterator ident;
  Term2List::iterator term;
  cout << "Let2(";
  for (ident = defIdents->begin(), term = defTerms->begin(); 
       ident != defIdents->end(); ident++, term++) {
 

      << ","; (*term)->dump(); cout << "),";
  }
  f->dump(); cout << ")";
    
void 
ASTForm_Call::dump()
  cout << "Call(" << symbolTable.lookupSymbol(n);
  args->dump();
  cout << ")";
void 
ASTForm_Import::dump()
  cout << "Import(\"" << file << "\"";
  Deque<char *>::iterator i;
  IdentList::iterator j;
  for (i = fileVars->begin(), j = idents->begin(); 
       i != fileVars->end(); i++, j++)
    cout << ",(" << *i << "," << symbolTable.lookupSymbol(*j) << ")";
  cout << ")";
void 
ASTForm_Export::dump()
  cout << "Export(\"" << file << "\","; f->dump(); cout << ")";
void 
ASTForm_Prefix::dump()
  cout << "Prefix("; f->dump(); cout << ")";
void 
ASTForm_Restrict::dump()
  cout << "Restrict("; f->dump(); cout << ")";
void 
ASTForm_InStateSpace1::dump()
  cout << "InStateSpace1("; t->dump(); 
  cout << ","; ss->dump(); cout << ")";
void 
ASTForm_InStateSpace2::dump()
  cout << "InStateSpace2("; T->dump(); 
  cout << ","; ss->dump(); cout << ")";
void 
ASTForm_SomeType::dump()
  cou
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
class LitstrRepoProxy : public RepoProxy {
public:
  explicit LitstrRepoProxy(Repo& repo);
  ~LitstrRepoProxy() {}
  void createSchema(int re
extern FILE *output;
void dump_table_assembly     (MonoImage *m);
void dump_table_assemblyref  (MonoImage *m);
void dump_table_class_layout (MonoImage *m);
void dump_table_constant     (MonoImage *m);
void dump_table_customattr   (MonoImage *m);
void dump_table_declsec      (MonoImage *m);
void dump_table_property     (MonoImage *m);
void dump_table_property_map (MonoImage *m);
void dump_table_event        (MonoImage *m);
void dump_table_file         (MonoImage *m);
void dump_table_moduleref    (MonoImage *m);
void dump_table_module       (MonoImage *m);
void dump_table_method       (MonoImage *m);
void dump_table_methodimpl   (MonoImage *m);
void dump_table_methodsem    (MonoImage *m);
void dump_table_field        (MonoImage *m);
void dump_table_manifest     (MonoImage *m);
void dump_table_memberref    (MonoImage *m);
void dump_table_param        (MonoImage *m);
void dump_table_typedef      (MonoImage *m);
void dump_table_typeref      (MonoImage *m);
void dump_table_typespec     (Mono
Stream_Viewer_Window::Stream_Viewer_Window(QWidget* parent)
    : QWidget(parent)
    m_ui.setupUi(this);
    setAttribute(Qt::WA_DeleteOnClose);
void Stream_Viewer_Window::init(silk::Comms& comms, std::string const& stream_path, uint32_t stream_rate, silk::stream::Type stream_type)
    m_comms = &comms;
    m_stream_path = stream_path;
    m_stream_rate = stream_rate;
    m_stream_type = stream_type;
    setWindowTitle(("Stream - " + m_stream_path).c_str());
    IStream_Viewer_Widget* viewer = nullptr;
    switch (m_stream_type.get_semantic())
    {
    case silk::stream::Semantic::ACCELERATION: viewer = new Acceleration_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::ADC: viewer = new ADC_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::ANGULAR_VELOCITY: viewer = new Angular_Velocity_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::BATTERY_STATE: viewer = new Battery_State_Stream_Viewer_Widget(this); break;
    case silk::stre

    case silk::stream::Semantic::CURRENT: viewer = new Current_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::DISTANCE: viewer = new Distance_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::FLOAT: viewer = new Float_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::FORCE: viewer = new Force_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::FRAME: viewer = new Frame_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::GPS_INFO: viewer = new GPS_Info_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::LINEAR_ACCELERATION: viewer = new Linear_Acceleration_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::MAGNETIC_FIELD: viewer = new Magnetic_Field_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::MULTIROTOR_COMMANDS: viewer = new Multirotor_Commands_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::MULTIROTOR_STATE: viewer = new

    case silk::stream::Semantic::POSITION: viewer = new Position_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::PRESSURE: viewer = new Pressure_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::PROXIMITY: viewer = new Proximity_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::PWM: viewer = new PWM_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::TEMPERATURE: viewer = new Temperature_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::TORQUE: viewer = new Torque_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::THROTTLE: viewer = new Throttle_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::VELOCITY: viewer = new Velocity_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::VIDEO: viewer = new Video_Stream_Viewer_Widget(this); break;
    case silk::stream::Semantic::VOLTAGE: viewer = new Voltage_Stream_Viewer_Widget(this); break;
    }
    if 
HRESULT XCrashDump::Initialize(const TCHAR* lpszDumpFileName_no_suffix)
    CDumpCore::Instance()->SetOriginalFileName(_T("CrashDump"));
    CDumpCore::Instance()->SetDumpSwitch(enDumpLog, FALSE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpBasicInfo, FALSE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpModuleList, FALSE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpProcessList, FALSE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpRegister, FALSE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpCallStack, TRUE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpMiniDump, TRUE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpCallStack, TRUE);
    CDumpCore::Instance()->SetDumpSwitch(enDumpCallStack, FALSE);
    CDumpCore::Instance()->StartDumpDaemon();
    return S_OK;
HRESULT XCrashDump::DumpMiniDump(PEXCEPTION_POINTERS p)
    CDumpCore::Instance()->DumpDirectForTest(p);
    return S_OK;
HRESULT XCrashDump::EnsureHookIsWorking()
    CDumpCore::Instance()->InstallExceptionFilter(
/* hippo-com-ipc-locator.cpp: HippoIpcLocator implementation via COM for Windows
 *
 * Copyright Red Hat, Inc. 2006
 **/
class HippoComIpcLocatorImpl : public HippoComIpcLocator {
public:
    HippoComIpcLocatorImpl();
    ~HippoComIpcLocatorImpl();
    virtual HippoIpcController *getController(const char *serverName);
    virtual void releaseController(HippoIpcController *controller);
    virtual HippoIpcController *createController(const char *serverName);
private:
    HippoIpcController *doGetController(const char *serverName);
    void doReleaseController(HippoIpcController *controller);
};
HippoIpcLocator *
HippoComIpcLocator::getInstance()
    return HippoComIpcHub::getInstance()->getLocator();
HippoComIpcLocator *
HippoComIpcLocator::createInstance()
    return new HippoComIpcLocatorImpl();
HippoComIpcLocatorImpl::HippoComIpcLocatorImpl()
HippoComIpcLocatorImpl::~HippoComIpcLocatorImpl()
HippoIpcController *
HippoComIpcLocatorImpl::getController(const char *serverName)
    HippoT
yumprior() {
if [[ -f /etc/yum.repos.d/public-yum-ol6.repo ]]; then
        OLSEXISTS='y'
fi
if [[ "$OLSEXISTS" = [yY] || "$OLS" = [yY] ]]; then
        cp -p /etc/yum.repos.d/public-yum-ol6.repo /etc/yum.repos.d/public-yum-ol6.repo.OLD
        
        if [ -n "$(grep ^priority /etc/yum.repos.d/public-yum-ol6.repo)" ]
                then
                PRIOREXISTS=1
                else
                        echo setting yum priorities for public-yum-ol6.repo
                ex -s /etc/yum.repos.d/public-yum-ol6.repo << EOF
:/\[ol6_latest/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_addons/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_ga_base/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_u1_base/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_u2_base/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_u3_base/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_u4_base/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_u5_base/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_UEKR3_latest/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_UEK_latest/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_U

:a
priority=1
:w
:/\[ol6_playground_latest/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_MySQL/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_gdm_multiseat/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_ofed_UEK/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_MySQL56/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_spacewalk20_server/ , /gpgkey/
:a
priority=1
:w
:/\[ol6_spacewalk20_client/ , /gpgkey/
:a
priority=1
:w
:q
EOF
        cecho "*************************************************" $boldgreen
        cecho "Fixing public-yum-ol6.repo YUM Priorities" $boldgreen
        cecho "*************************************************" $boldgreen
        cat /etc/yum.repos.d/public-yum-ol6.repo
        echo ""
        fi
else
        
        cp -p /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.OLD
        
        if [ -n "$(grep ^priority /etc/yum.repos.d/CentOS-Base.repo)" ]
                then
	       PRIOREXISTS=1
                else
                        echo setting yum priorities for CentOS-Base.repo
           

:/\[base/ , /gpgkey/
:a
priority=1
:w
:/\[updates/ , /gpgkey/
:a
priority=1
:w
:/\[addons/ , /gpgkey/
:a
priority=1
:/\[extras/ , /gpgkey/
:a
priority=1
:/\[centosplus/ , /gpgkey/
:a
priority=2
:/\[contrib/ , /gpgkey/
:a
priority=2
:w
:q
EOF
        
        cecho "*************************************************" $boldgreen
        cecho "Fixing CentOS-Base.repo YUM Priorities" $boldgreen
        cecho "*************************************************" $boldgreen
        cat /etc/yum.repos.d/CentOS-Base.repo
        echo ""
        fi
        
        
        if [ -f /etc/yum.repos.d/CentOS-CR.repo ]; then
        cp -p /etc/yum.repos.d/CentOS-CR.repo /etc/yum.repos.d/CentOS-CR.OLD
        if [ -n "$(grep ^priority /etc/yum.repos.d/CentOS-CR.repo)" ]
                then
	       PRIOREXISTS=1
                else
                        echo setting yum priorities for CentOS-CR.repo
                ex -s /etc/yum.repos.d/CentOS-CR.repo << EOF
:/\[cr/ , /gpgkey/
:a
priority=1
:w
:q

EOF
        
        cecho "*************************************************" $boldgreen
        cecho "Fixing CentOS-CR.repo YUM Priorities" $boldgreen
        cecho "*************************************************" $boldgreen
        cat /etc/yum.repos.d/CentOS-CR.repo
        echo ""
        fi
        
        
yumpriorepel() {
cp -p /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.OLD
if [ -n "$(grep ^priority /etc/yum.repos.d/epel.repo)" ]
        then
PRIOREXISTS=1
        else
                echo setting yum priorities for epel.repo
                ex -s /etc/yum.repos.d/epel.repo << EOF
:/\[epel\]/ , /gpgkey/
:a
priority=3
exclude=varnish
:w
:q
EOF
cecho "*************************************************" $boldgreen
cecho "Fixing epel.repo YUM Priorities" $boldgreen
cecho "*************************************************" $boldgreen
cat /etc/yum.repos.d/epel.repo
echo ""
fi
yumpriorrpmforge() {
cp -p /etc/yum.repos.d/rpmforge.repo /etc/yum.repos.d/rpmforge.OLD
if [ -n "$

        then
PRIOREXISTS=1
        else
                echo setting yum priorities for rpmforge.repo
                ex -s /etc/yum.repos.d/rpmforge.repo << EOF
:/\[rpmforge\]/ , /gpgcheck/
:a
priority=5
:w
:q
EOF
cecho "*************************************************" $boldgreen
cecho "Fixing rpmforge.repo YUM Priorities" $boldgreen
cecho "*************************************************" $boldgreen
cat /etc/yum.repos.d/rpmforge.repo
echo ""
fi
yumpriorcentalt() {
cp -p /etc/yum.repos.d/centalt.repo /etc/yum.repos.d/centalt.OLD
if [ -n "$(grep ^priority /etc/yum.repos.d/centalt.repo)" ]
        then
PRIOREXISTS=1
        else
                echo setting yum priorities for centalt.repo
                ex -s /etc/yum.repos.d/centalt.repo << EOF
:/\[CentALT\]/ , /gpgkey/
:a
priority=9
:w
:q
EOF
cecho "*************************************************" $boldgreen
cecho "Fixing centalt.repo YUM Priorities" $boldgreen
cecho "*************************************************" $boldgree

sed -i 's/enabled=1/enabled=0/g' /etc/yum.repos.d/centalt.repo
cat /etc/yum.repos.d/centalt.repo
echo ""
fi
yumpriorpercona() {
if [ -f /etc/yum.repos.d/percona-release.repo ]; then
cp -p /etc/yum.repos.d/percona-release.repo /etc/yum.repos.d/percona-release.OLD
if [ -n "$(grep ^priority /etc/yum.repos.d/percona-release.repo)" ]
        then
PRIOREXISTS=1
        else
                echo setting yum priorities for percona-release.repo
                ex -s /etc/yum.repos.d/percona-release.repo << EOF
:/\[percona-release-\$basearch\]/ , /gpgcheck/
:a
priority=11
exclude=Percona-SQL* Percona-Server* Percona-XtraDB-Cluster*
:w
:q
EOF
sed -i 's/enabled = 1/enabled = 0/g' /etc/yum.repos.d/percona-release.repo
cecho "*************************************************" $boldgreen
cecho "Fixing percona-release.repo YUM Priorities" $boldgreen
cecho "*************************************************" $boldgreen
cat /etc/yum.repos.d/percona-release.repo
echo ""
fi
fi
yumpriorvarnish() {
cp -p /e

if [ -n "$(grep ^priority /etc/yum.repos.d/varnish.repo)" ]
        then
PRIOREXISTS=1
        else
                echo setting yum priorities for varnish.repo
                ex -s /etc/yum.repos.d/varnish.repo << EOF
:/\[rpmforge\]/ , /gpgcheck/
:a
priority=2
:w
:q
EOF
sed -i 's/enabled=1/enabled=0/g' /etc/yum.repos.d/varnish.repo
cecho "*************************************************" $boldgreen
cecho "Fixing varnish.repo YUM Priorities" $boldgreen
cecho "*************************************************" $boldgreen
cat /etc/yum.repos.d/varnish.repo
echo ""
fi
yumprioraxivo() {
if [[ "$AXIVOREPO_DISABLE" = [nN] ]]; then
cp -p /etc/yum.repos.d/axivo.repo /etc/yum.repos.d/axivo.OLD
if [ -n "$(grep ^priority /etc/yum.repos.d/axivo.repo)" ]
        then
PRIOREXISTS=1
        else
                echo setting yum priorities for axivo.repo
                ex -s /etc/yum.repos.d/axivo.repo << EOF
:/\[axivo\]/ , /gpgkey/
:a
priority=13
exclude=nginx* php* mariadb* memcached* xtrabackup

using namespace std;
struct NodeChunk {
    string * val;
    NodeChunk * next;
};
struct Stack {
    int chunkSize;
    int topElt;
    NodeChunk *firstChunk;
};
NodeChunk *createNewNodeChunk(int N) {
    assert(N > 0);
    NodeChunk *chunk = new NodeChunk;
    chunk->next = NULL;
    chunk->val = new string[N];
    return chunk;
void initStack(int chunkSize, Stack& s) {
    s.chunkSize = chunkSize;
    s.topElt = chunkSize - 1;
    s.firstChunk = NULL;
bool isEmpty(Stack s) {
    return s.firstChunk == NULL;
void push(string val, Stack& s) {
    s.topElt++;
    if (s.topElt == s.chunkSize) {
        NodeChunk *chunk = createNewNodeChunk(s.chunkSize);
        chunk->val[0] = val;
        chunk->next = s.firstChunk;
        s.firstChunk = chunk;
        s.topElt = 0;
    } else s.firstChunk->val[s.topElt] = val;
void pop(Stack& s) {
    assert(!isEmpty(s));
    s.topElt--;
    if (s.topElt == -1) {
        NodeChunk *chunk = s.firstChunk;
        s.firstChunk = s.firstChunk->next;
    
class RepoTest : public testing::Test
protected:
    virtual void SetUp()
    {
        system("cp -r ../testrepo/ ../tmptestrepo/");
    }
    virtual void TearDown() {
        system("rm -rf ../tmptestrepo/");
    }
    AcGit::Repository *repo;
};
TEST_F(RepoTest, test_repo) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
TEST_F(RepoTest, explicit_git_test_repo) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo/.git");
    ASSERT_TRUE (repo != nullptr);
TEST_F(RepoTest, explicit_git_test_folder_does_not_exist) {
    AcGit::Repository *repo;
    EXPECT_THROW(repo  = new AcGit::Repository("../tmptestrepo.git"), AcGit::GitException);
TEST_F(RepoTest, down_folder_test_repo) {
    system("mkdir -p ../tmptestrepo/newfolder");
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo/newfolder/");
    ASSERT_TRUE (repo != nullptr);
TEST_F(RepoTest, explicit_down_folder_git_test_repo_does_not_exist) {
 

    AcGit::Repository *repo;
    EXPECT_THROW(repo = new AcGit::Repository("../tmptestrepo/newfolder/.git"), AcGit::GitException);
TEST_F(RepoTest, test_for_BranchAgent) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
    AcGit::IBranches *branchAgent = repo->BranchAgent();
    ASSERT_TRUE(branchAgent != nullptr);
TEST_F(RepoTest, test_for_TagsAgent) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
    AcGit::ITags *tagsAgent = repo->TagsAgent();
    ASSERT_TRUE(tagsAgent != nullptr);
TEST_F(RepoTest, test_for_CommitsAgent) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
    AcGit::ICommits *commitsAgent = repo->CommitsAgent();
    ASSERT_TRUE(commitsAgent != nullptr);
TEST_F(RepoTest, test_for_hasWorkingTreeChangesTrue) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE 

    bool hasWorkingTreeChanges = repo->HasWorkingTreeChanges();
    EXPECT_EQ(hasWorkingTreeChanges, true);
TEST_F(RepoTest, test_for_hasAHeadCommit) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
    AcGit::Commit *commit = repo->HeadCommit();
    ASSERT_TRUE(commit != nullptr);
TEST_F(RepoTest, test_for_ConfigurationAgent) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
    AcGit::Configuration *config = repo->ConfigurationAgent();
    ASSERT_TRUE(config != nullptr);
TEST_F(RepoTest, test_for_topLevelDirectory) {
    AcGit::Repository *repo = new AcGit::Repository("../tmptestrepo");
    ASSERT_TRUE (repo != nullptr);
    QString dir = repo->GitTopLevelDirectory();
    EXPECT_EQ(dir.endsWith("tmptestrepo/.git/"), true);
int main (int argc, char **argv)
    testing::InitGoogleTest(&argc, argv);
    testing::TestEventListeners& listeners = testing::UnitTest::GetInsta
namespace ZuoPar {
template <class _ScoreContextType>
class MetaFeatureParameterCollection {
public:
  typedef MetaFeatureParameterMap<UnigramMetaFeature,  _ScoreContextType> uf_map_t;
  typedef MetaFeatureParameterMap<BigramMetaFeature,   _ScoreContextType> bf_map_t;
  typedef MetaFeatureParameterMap<TrigramMetaFeature,  _ScoreContextType> tf_map_t;
  typedef MetaFeatureParameterMap<QuadgramMetaFeature, _ScoreContextType> qf_map_t;
  typedef MetaFeatureParameterMap<QuingramMetaFeature, _ScoreContextType> q5f_map_t;
  typedef MetaFeatureParameterMap<HexgramMetaFeature,  _ScoreContextType> hf_map_t;
  typedef MetaFeatureParameterMap<std::string,         _ScoreContextType> sf_map_t;
  MetaFeatureParameterCollection() {}
  /**
   * Convert the pointwised feature collections into vector.
   *
   *  @param[in]  ctx           The score context
   *  @param[in]  scale         Increase the value in sparse_vector by scale.
   *  @param[out] sparse_vector The sparse vector.
   */
  void vectoriz

      SparseVector* sparse_vector) const {
    int gid = 0;
    for (const uf_map_t& repo: ufeat_map_repo) { repo.vectorize(ctx, scale, gid++, sparse_vector); }
    for (const bf_map_t& repo: bfeat_map_repo) { repo.vectorize(ctx, scale, gid++, sparse_vector); }
    for (const tf_map_t& repo: tfeat_map_repo) { repo.vectorize(ctx, scale, gid++, sparse_vector); }
    for (const qf_map_t& repo: qfeat_map_repo) { repo.vectorize(ctx, scale, gid++, sparse_vector); }
    for (const q5f_map_t& repo: q5feat_map_repo){ repo.vectorize(ctx, scale, gid++, sparse_vector);}
    for (const hf_map_t& repo: hfeat_map_repo) { repo.vectorize(ctx, scale, gid++, sparse_vector); }
    for (const sf_map_t& repo: sfeat_map_repo) { repo.vectorize(ctx, scale, gid++, sparse_vector); }
  }
  /**
   * Convert the pointwised feature collections into vector.
   *
   *  @param[in]  ctx           The score context
   *  @param[in]  act           The action
   *  @param[in]  scale         Increase the value in sparse_ve

   *  @param[out] sparse_vector The version 2 sparse vector.
   */
  void vectorize2(const _ScoreContextType& ctx, floatval_t scale,
      SparseVector2* sparse_vector) const {
    int gid = 0;
    for (const uf_map_t& repo: ufeat_map_repo) { repo.vectorize2(ctx, scale, gid++, sparse_vector); }
    for (const bf_map_t& repo: bfeat_map_repo) { repo.vectorize2(ctx, scale, gid++, sparse_vector); }
    for (const tf_map_t& repo: tfeat_map_repo) { repo.vectorize2(ctx, scale, gid++, sparse_vector); }
    for (const qf_map_t& repo: qfeat_map_repo) { repo.vectorize2(ctx, scale, gid++, sparse_vector); }
    for (const q5f_map_t& repo: q5feat_map_repo){ repo.vectorize2(ctx, scale, gid++, sparse_vector);}
    for (const hf_map_t& repo: hfeat_map_repo) { repo.vectorize2(ctx, scale, gid++, sparse_vector); }
    for (const sf_map_t& repo: sfeat_map_repo) { repo.vectorize2(ctx, scale, gid++, sparse_vector); }
  }
  int diff_norm(const _ScoreContextType& ctx1, const _ScoreContextType& ctx2) const {
 

    for (const uf_map_t& repo: ufeat_map_repo) { retval += repo.diff_norm(ctx1, ctx2); }
    for (const bf_map_t& repo: bfeat_map_repo) { retval += repo.diff_norm(ctx1, ctx2); }
    for (const tf_map_t& repo: tfeat_map_repo) { retval += repo.diff_norm(ctx1, ctx2); }
    for (const qf_map_t& repo: qfeat_map_repo) { retval += repo.diff_norm(ctx1, ctx2); }
    for (const q5f_map_t& repo: q5feat_map_repo){ retval += repo.diff_norm(ctx1, ctx2); }
    for (const hf_map_t& repo: hfeat_map_repo) { retval += repo.diff_norm(ctx1, ctx2); }
    for (const sf_map_t& repo: sfeat_map_repo) { retval += repo.diff_norm(ctx1, ctx2); }
    return retval;
  }
  /**
   * Get score for the state context.
   *
   *  @param[in]  ctx   The input state context.
   *  @param[in]  avg   The average parameter.
   *  @return     floatval_t  The score of applying the action act to the state
   *                           context.
   */
  floatval_t score(const _ScoreContextType& ctx, bool avg) const {
    floatval_t

    for (const uf_map_t& repo: ufeat_map_repo) { ret += repo.score(ctx, avg); }
    for (const bf_map_t& repo: bfeat_map_repo) { ret += repo.score(ctx, avg); }
    for (const tf_map_t& repo: tfeat_map_repo) { ret += repo.score(ctx, avg); }
    for (const qf_map_t& repo: qfeat_map_repo) { ret += repo.score(ctx, avg); }
    for (const q5f_map_t& repo:q5feat_map_repo){ ret += repo.score(ctx, avg); }
    for (const hf_map_t& repo: hfeat_map_repo) { ret += repo.score(ctx, avg); }
    for (const sf_map_t& repo: sfeat_map_repo) { ret += repo.score(ctx, avg); }
    return ret;
  }
  /**
   * Update the model with the state context.
   *
   *  @param[in]  ctx       The input state context.
   *  @param[in]  act       The action.
   *  @param[in]  timestamp The updated timestamp.
   *  @param[in]  scale     The updated scale.
   */
  void update(const _ScoreContextType& ctx, int timestamp, floatval_t scale) {
    for (uf_map_t& repo: ufeat_map_repo) { repo.update(ctx, timestamp, scale); }
    f

    for (tf_map_t& repo: tfeat_map_repo) { repo.update(ctx, timestamp, scale); }
    for (qf_map_t& repo: qfeat_map_repo) { repo.update(ctx, timestamp, scale); }
    for (q5f_map_t& repo:q5feat_map_repo){ repo.update(ctx, timestamp, scale); }
    for (hf_map_t& repo: hfeat_map_repo) { repo.update(ctx, timestamp, scale); }
    for (sf_map_t& repo: sfeat_map_repo) { repo.update(ctx, timestamp, scale); }
  }
  /**
   * flush the score.
   */
  void flush(int timestamp) {
    for (uf_map_t& repo: ufeat_map_repo) { repo.flush(timestamp); }
    for (bf_map_t& repo: bfeat_map_repo) { repo.flush(timestamp); }
    for (tf_map_t& repo: tfeat_map_repo) { repo.flush(timestamp); }
    for (qf_map_t& repo: qfeat_map_repo) { repo.flush(timestamp); }
    for (q5f_map_t& repo:q5feat_map_repo){ repo.flush(timestamp); }
    for (hf_map_t& repo: hfeat_map_repo) { repo.flush(timestamp); }
    for (sf_map_t& repo: sfeat_map_repo) { repo.flush(timestamp); }
  }
  /**
   * Save the model into the output stre

   *
   *  @param[out] os    The output stream.
   *  @return     bool  If successfully saved, return true; otherwise return
   *                    false.
   */
  bool save(std::ostream& os) const {
    boost::archive::text_oarchive oa(os);
    for (const uf_map_t& repo: ufeat_map_repo) { repo.save(oa); }
    for (const bf_map_t& repo: bfeat_map_repo) { repo.save(oa); }
    for (const tf_map_t& repo: tfeat_map_repo) { repo.save(oa); }
    for (const qf_map_t& repo: qfeat_map_repo) { repo.save(oa); }
    for (const q5f_map_t& repo:q5feat_map_repo){ repo.save(oa); }
    for (const hf_map_t& repo: hfeat_map_repo) { repo.save(oa); }
    for (const sf_map_t& repo: sfeat_map_repo) { repo.save(oa); }
    return true;
  }
  /**
   * Load the model fron input stream.
   *
   *  @param[in]  is    The input stream.
   *  @return     bool  If successfully loaded, return true; otherwise return
   *                    false.
   */
  bool load(std::istream& is) {
    boost::archive::text_iarchive i
using testing::_;
namespace base {
namespace trace_event {
class MemoryDumpManagerTest : public testing::Test {
 public:
  void SetUp() override {
    mdm_.reset(new MemoryDumpManager());
    MemoryDumpManager::SetInstanceForTesting(mdm_.get());
    ASSERT_EQ(mdm_, MemoryDumpManager::GetInstance());
    MemoryDumpManager::GetInstance()->Initialize();
  }
  void TearDown() override {
    MemoryDumpManager::SetInstanceForTesting(nullptr);
    mdm_.reset();
    TraceLog::DeleteForTesting();
  }
 protected:
  const char* const kTraceCategory = MemoryDumpManager::kTraceCategory;
  void EnableTracing(const char* category) {
    TraceLog::GetInstance()->SetEnabled(
        CategoryFilter(category), TraceLog::RECORDING_MODE, TraceOptions());
  }
  void DisableTracing() { TraceLog::GetInstance()->SetDisabled(); }
  scoped_ptr<MemoryDumpManager> mdm_;
 private:
  ShadowingAtExitManager at_exit_manager_;
};
class MockDumpProvider : public MemoryDumpProvider {
 public:
  MOCK_METHOD1(DumpInto, voi

};
TEST_F(MemoryDumpManagerTest, SingleDumper) {
  MockDumpProvider mdp;
  mdm_->RegisterDumpProvider(&mdp);
  EnableTracing("foo-and-bar-but-not-memory");
  EXPECT_CALL(mdp, DumpInto(_)).Times(0);
  mdm_->RequestDumpPoint(DumpPointType::EXPLICITLY_TRIGGERED);
  DisableTracing();
  EnableTracing(kTraceCategory);
  EXPECT_CALL(mdp, DumpInto(_)).Times(3);
  for (int i = 0; i < 3; ++i)
    mdm_->RequestDumpPoint(DumpPointType::EXPLICITLY_TRIGGERED);
  DisableTracing();
  mdm_->UnregisterDumpProvider(&mdp);
  EnableTracing(kTraceCategory);
  EXPECT_CALL(mdp, DumpInto(_)).Times(0);
  mdm_->RequestDumpPoint(DumpPointType::EXPLICITLY_TRIGGERED);
  TraceLog::GetInstance()->SetDisabled();
TEST_F(MemoryDumpManagerTest, UnregisterDumperWhileTracing) {
  MockDumpProvider mdp;
  mdm_->RegisterDumpProvider(&mdp);
  EnableTracing(kTraceCategory);
  EXPECT_CALL(mdp, DumpInto(_)).Times(1);
  mdm_->RequestDumpPoint(DumpPointType::EXPLICITLY_TRIGGERED);
  mdm_->UnregisterDumpProvider(&mdp);
  EXPECT_CAL
HANDLE_LOAD_COMMAND(LC_SEGMENT              , 0x00000001u)
HANDLE_LOAD_COMMAND(LC_SYMTAB               , 0x00000002u)
HANDLE_LOAD_COMMAND(LC_SYMSEG               , 0x00000003u)
HANDLE_LOAD_COMMAND(LC_THREAD               , 0x00000004u)
HANDLE_LOAD_COMMAND(LC_UNIXTHREAD           , 0x00000005u)
HANDLE_LOAD_COMMAND(LC_LOADFVMLIB           , 0x00000006u)
HANDLE_LOAD_COMMAND(LC_IDFVMLIB             , 0x00000007u)
HANDLE_LOAD_COMMAND(LC_IDENT                , 0x00000008u)
HANDLE_LOAD_COMMAND(LC_FVMFILE              , 0x00000009u)
HANDLE_LOAD_COMMAND(LC_PREPAGE              , 0x0000000Au)
HANDLE_LOAD_COMMAND(LC_DYSYMTAB             , 0x0000000Bu)
HANDLE_LOAD_COMMAND(LC_LOAD_DYLIB           , 0x0000000Cu)
HANDLE_LOAD_COMMAND(LC_ID_DYLIB             , 0x0000000Du)
HANDLE_LOAD_COMMAND(LC_LOAD_DYLINKER        , 0x0000000Eu)
HANDLE_LOAD_COMMAND(LC_ID_DYLINKER          , 0x0000000Fu)
HANDLE_LOAD_COMMAND(LC_PREBOUND_DYLIB       , 0x00000010u)
HANDLE_LOAD_COMMAND(LC_ROUTINES             , 0x00000011

HANDLE_LOAD_COMMAND(LC_SUB_FRAMEWORK        , 0x00000012u)
HANDLE_LOAD_COMMAND(LC_SUB_UMBRELLA         , 0x00000013u)
HANDLE_LOAD_COMMAND(LC_SUB_CLIENT           , 0x00000014u)
HANDLE_LOAD_COMMAND(LC_SUB_LIBRARY          , 0x00000015u)
HANDLE_LOAD_COMMAND(LC_TWOLEVEL_HINTS       , 0x00000016u)
HANDLE_LOAD_COMMAND(LC_PREBIND_CKSUM        , 0x00000017u)
HANDLE_LOAD_COMMAND(LC_LOAD_WEAK_DYLIB      , 0x80000018u)
HANDLE_LOAD_COMMAND(LC_SEGMENT_64           , 0x00000019u)
HANDLE_LOAD_COMMAND(LC_ROUTINES_64          , 0x0000001Au)
HANDLE_LOAD_COMMAND(LC_UUID                 , 0x0000001Bu)
HANDLE_LOAD_COMMAND(LC_RPATH                , 0x8000001Cu)
HANDLE_LOAD_COMMAND(LC_CODE_SIGNATURE       , 0x0000001Du)
HANDLE_LOAD_COMMAND(LC_SEGMENT_SPLIT_INFO   , 0x0000001Eu)
HANDLE_LOAD_COMMAND(LC_REEXPORT_DYLIB       , 0x8000001Fu)
HANDLE_LOAD_COMMAND(LC_LAZY_LOAD_DYLIB      , 0x00000020u)
HANDLE_LOAD_COMMAND(LC_ENCRYPTION_INFO      , 0x00000021u)
HANDLE_LOAD_COMMAND(LC_DYLD_INFO            , 0x0000002
/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 */
void
option_arg_gen_class::generate_option_arg(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (long_long_arg)
    {
      stream << "\n";
      stream << indent_str;
      generate_string (type, stream, indent + indent_str.length ());
      stream << " ";
      generate_string (name, stream, indent + indent_str.length ());
      stream << "_arg;	/**< ";
      stream << "@";
      stream << "brief ";
      generate_string (desc, stream, indent + indent_str.length ());
      if (has_default)
        {
          stream << " (default=";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ")";
        }
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      generate_string (longtype, stream, indent + indent_str.length ());
      stream << " ";


      stream << "_arg;	/**< ";
      stream << "@";
      stream << "brief ";
      generate_string (desc, stream, indent + indent_str.length ());
      if (has_default)
        {
          stream << " (default=";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ")";
        }
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      generate_string (origtype, stream, indent + indent_str.length ());
      stream << " ";
      generate_string (name, stream, indent + indent_str.length ());
      stream << "_orig;	/**< ";
      stream << "@";
      stream << "brief ";
      generate_string (desc, stream, indent + indent_str.length ());
      stream << " original value given at command line.  */";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      if (flag_arg)
        {
          generate_string (type, stream, indent + indent_str.length ())

          stream << " ";
          generate_string (name, stream, indent + indent_str.length ());
          stream << "_flag;	/**< ";
          stream << "@";
          stream << "brief ";
          generate_string (desc, stream, indent + indent_str.length ());
          stream << " (default=";
          if (default_on)
            {
              stream << "on";
            }
          else
            {
              stream << "off";
            }
          stream << ").  */";
          stream << "\n";
          stream << indent_str;
        }
      else
        {
          if (has_arg)
            {
              if (has_enum)
                {
                  stream << "enum enum_";
                  generate_string (name, stream, indent + indent_str.length ());
                  stream << " ";
                  if (multiple)
                    {
                      stream << "*";
                    }
                  generate_string (name, stream, indent + indent_str.lengt

                  stream << "_arg;	/**< ";
                  stream << "@";
                  stream << "brief ";
                  generate_string (desc, stream, indent + indent_str.length ());
                  if (has_default)
                    {
                      stream << " (default='";
                      generate_string (default_value, stream, indent + indent_str.length ());
                      stream << "')";
                    }
                  stream << ".  */";
                  stream << "\n";
                  stream << indent_str;
                }
              else
                {
                  generate_string (type, stream, indent + indent_str.length ());
                  stream << " ";
                  generate_string (name, stream, indent + indent_str.length ());
                  stream << "_arg;	/**< ";
                  stream << "@";
                  stream << "brief ";
                  generate_string (desc, stream, indent + indent_str.le

                  if (has_default)
                    {
                      stream << " (default='";
                      generate_string (default_value, stream, indent + indent_str.length ());
                      stream << "')";
                    }
                  stream << ".  */";
                  stream << "\n";
                  stream << indent_str;
                }
              generate_string (origtype, stream, indent + indent_str.length ());
              stream << " ";
              generate_string (name, stream, indent + indent_str.length ());
              stream << "_orig;	/**< ";
              stream << "@";
              stream << "brief ";
              generate_string (desc, stream, indent + indent_str.length ());
              stream << " original value given at command line.  */";
              stream << "\n";
              stream << indent_str;
            }
        }
    }
  if (multiple)
    {
      stream << "unsigned int ";
      generate_string (n
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
Q_DECLARE_METATYPE(repo::core::model::RepoProjectSettings)
namespace repo {
namespace gui{
namespace widget {
	class ProjectsManagerWidget : public EditableTreeWidget
	{
		Q_OBJECT
			static const QString COLUMNS_SETTINGS;
		enum class Columns { PROJECT, OWNER, TYPE, DESCRIPTION };
	public:
		explicit ProjectsManagerWidget(QWidget *parent = 0);
		~P

		public slots:
		void copyItem()
		{
			showEditDialog(getProjectSettings(), Action::COPY);
		}
		void addProjectSettings(repo::core::model::RepoProjectSettings);
		virtual void edit()
		{
			showEditDialog(getProjectSettings(), Action::EDIT);
		}
		void edit(const QModelIndex &index)
		{
			showEditDialog(getProjectSettings(index), Action::EDIT);
		}
		repo::core::model::RepoProjectSettings getProjectSettings();
		repo::core::model::RepoProjectSettings getProjectSettings(const QModelIndex &index);
		void refresh()
		{
			refresh(repo::core::model::RepoProjectSettings(), false);
		}
		void refresh(
			const repo::core::model::RepoProjectSettings &settings,
			bool isDelete);
		void removeItem();
		void showEditDialog()
		{
			showEditDialog(repo::core::model::RepoProjectSettings(), Action::ADD);
		}
		void showEditDialog(
			const repo::core::model::RepoProjectSettings &,
			const EditableTreeWidget::Action action);
	public:
		void setDBConnection(repo::RepoController *controller,
		
/************************************************************************
Author:		Dan Strycharske
Date:       02.12.12
File:       ModelComponent.cpp
Brief:      ModelComponent class implementation.
/************************************************************************/
ModelComponent::ModelComponent() : ComponentDisciple()
	mModel = new Model;
	mModel->mParent = this->mParentRef;
ModelComponent::ModelComponent(const ModelComponent& comp) : ComponentDisciple(comp)
	mModel = new Model;
	mModel->mParent = comp.getModel()->mParent;
ModelComponent::~ModelComponent()
/************************************************************************/
/* Public - Member methods
/************************************************************************/
const Model* ModelComponent::getModel() const
{ 
	return mModel; 
LUA_START_DEFINE_CLASS(ModelComponent)
LUA_NAME_METHOD(ModelComponent, "SetOffsetPos", LSetOffsetPos )
LUA_END_DEFINE_CLASS
LUA_DEFINE_METHOD(ModelComponent, LSetOffsetPos)
	if( !ls ) 
/*  Project Starshatter 4.5
	Destroyer Studios LLC
	Copyright Â© 1997-2004. All Rights Reserved.
	SUBSYSTEM:    Stars
	FILE:         LoadScreen.cpp
	AUTHOR:       John DiCamillo
*/
LoadScreen::LoadScreen()
: screen(0), load_dlg(0), cmp_load_dlg(0), isShown(false)
{ }
LoadScreen::~LoadScreen()
	TearDown();
void
LoadScreen::Setup(Screen* s)
	if (!s)
	return;
	screen        = s;
	DataLoader* loader = DataLoader::GetLoader();
	loader->UseFileSystem(true);
	FormDef load_def("LoadDlg", 0);
	load_def.Load("LoadDlg");
	load_dlg = new(__FILE__,__LINE__) LoadDlg(screen, load_def);
	FormDef cmp_load_def("CmpLoadDlg", 0);
	cmp_load_def.Load("CmpLoadDlg");
	cmp_load_dlg = new(__FILE__,__LINE__) CmpLoadDlg(screen, cmp_load_def);
	loader->UseFileSystem(Starshatter::UseFileSystem());
	ShowLoadDlg();
void
LoadScreen::TearDown()
	if (screen) {
		if (load_dlg)     screen->DelWindow(load_dlg);
		if (cmp_load_dlg) screen->DelWindow(cmp_load_dlg);
	}
	delete load_dlg;
	delete cmp_load_dlg;
	load_dlg       = 

	cmp_load_dlg   = 0;
	screen         = 0;
void
LoadScreen::ExecFrame()
	Game::SetScreenColor(Color::Black);
	if (load_dlg && load_dlg->IsShown())
	load_dlg->ExecFrame();
	if (cmp_load_dlg && cmp_load_dlg->IsShown())
	cmp_load_dlg->ExecFrame();
bool
LoadScreen::CloseTopmost()
	return false;
void
LoadScreen::Show()
	if (!isShown) {
		ShowLoadDlg();
		isShown = true;
	}
void
LoadScreen::Hide()
	if (isShown) {
		HideLoadDlg();
		isShown = false;
	}
void
LoadScreen::ShowLoadDlg()
	if (load_dlg)     load_dlg->Hide();
	if (cmp_load_dlg) cmp_load_dlg->Hide();
	Starshatter* stars = Starshatter::GetInstance();
	if (stars && cmp_load_dlg) {
		if (stars->GetGameMode() == Starshatter::CLOD_MODE ||
				stars->GetGameMode() == Starshatter::CMPN_MODE) {
			cmp_load_dlg->Show();
			Mouse::Show(false);
			return;
		}
	}
	if (load_dlg) {
		load_dlg->Show();
		Mouse::Show(false);
	}
void
LoadScreen::HideLoadDlg()
	if (load_dlg && load_dlg->IsShown())
	load_dlg->Hide();
	if (cmp_load_dlg && cmp_load_dlg->
/*
 * Copyright 2013 PaweÅ Dziepak, pdziepak@quarnos.org.
 * Distributed under the terms of the MIT License.
 */
const int32 kMaxLoad = 1000;
const bigtime_t kLoadMeasureInterval = 1000;
const bigtime_t kIntervalInaccuracy = kLoadMeasureInterval / 4;
static inline int32
compute_load(bigtime_t& measureTime, bigtime_t& measureActiveTime, int32& load,
	bigtime_t now)
	if (measureTime == 0) {
		measureTime = now;
		return -1;
	}
	bigtime_t deltaTime = now - measureTime;
	if (deltaTime < kLoadMeasureInterval)
		return -1;
	int32 oldLoad = load;
	ASSERT(oldLoad >= 0 && oldLoad <= kMaxLoad);
	int32 newLoad = measureActiveTime * kMaxLoad;
	newLoad /= max_c(deltaTime, 1);
	newLoad = max_c(min_c(newLoad, kMaxLoad), 0);
	measureActiveTime = 0;
	measureTime = now;
	deltaTime += kIntervalInaccuracy;
	int n = deltaTime / kLoadMeasureInterval;
	ASSERT(n > 0);
	if (n > 10)
		load = newLoad;
	else {
		newLoad *= (1 << n) - 1;
		load = (load + newLoad) / (1 << n);
		ASSERT(load >= 0 && load <= kMaxLoad)
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
RepoTreeRawModule::RepoTreeRawModule()
void RepoTreeRawModule::initialize()
    MacGitver::self().registerView("RepoTreeRaw",
                                   tr( "Raw Repo Tree" ),
                                   &RepoTreeRawModule::createRepoTreeRawView);
void RepoTreeRawModule::deinitialize()
   
/*
 *    Copyright 2011 Sven Mikael Persson
 *
 *    THIS SOFTWARE IS DISTRIBUTED UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE v3 (GPLv3).
 *
 *    This file is part of ReaK.
 *
 *    ReaK is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    ReaK is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with ReaK (as LICENSE in the root folder).  
 */
namespace ReaK {
namespace rtti {
  
so_type_repo& so_type_repo::getInstance() {
  static const unsigned int t = 0;
  static so_type* static_TypeMap = new detail::dummy_so_

  static so_type_repo RKSharedObjTypeRepo(static_TypeMap);
  return RKSharedObjTypeRepo;
};
so_type_repo& getRKSharedObjTypeRepo() {
  return so_type_repo::getInstance();
};
so_type_repo::so_type_repo(so_type* aTypeMap) : shared_object_base(), mTypeMap(aTypeMap) { next = this; prev = this; };
so_type_repo::~so_type_repo() {
  if(next != this) {
    prev->next = next;
  };
  
  delete mTypeMap;
};
bool RK_CALL so_type_repo::isInRing(so_type_repo* aRepo) {
  so_type_repo* p = this;
  while(p->next != this) {
    if(p->next == aRepo)
      return true;
    p = p->next;
  };
  return false;
};
void RK_CALL so_type_repo::merge( so_type_repo* aRepo ) {
  if(aRepo == NULL)
    return;
  if(isInRing(aRepo))
    return;
    prev = aRepo->prev;
    aRepo->prev = this;
    next = aRepo;
    prev->next = this;
    aRepo->prev = prev;
    prev = aRepo;
    aRepo->next = this;
    aRepo->prev->next = aRepo;
    so_type_repo* p = aRepo;
    while(p->next != aRepo) {
      so_type_repo* pn = p->next;
/*
** $Id: ldump.cc,v 1.1 2007-01-29 09:58:48 vaiofloh Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConstant

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
/***********************************************************************
ChunkedArray - Data structure to store lists of elements in page-aligned
chunks of memory.
Copyright (c) 2005 Oliver Kreylos
This file is part of the Miscellaneous Support Library (Misc).
The Miscellaneous Support Library is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
The Miscellaneous Support Library is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along
with the Miscellaneous Support Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA
****

namespace Misc {
template <class ContentParam,size_t pageSizeParam =8192>
class ChunkedArray
	{
	/* Embedded classes: */
	public:
	private:
	struct Chunk;
		{
		/* Elements: */
		public:
		
		/* Constructors and destructors: */
		ChunkHeader(void)
			:succ(0),numElements(0)
			{
			}
		};
		{
		/* Elements: */
		public:
		char mem[pageSize-sizeof(ChunkHeader)];
		
		/* Methods: */
		const Content& operator[](size_t index) const
			{
			return reinterpret_cast<const Content*>(mem)[index];
			}
		Content& operator[](size_t index)
			{
			return reinterpret_cast<Content*>(mem)[index];
			}
		const Content* getAddress(size_t index) const
			{
			return reinterpret_cast<const Content*>(mem)+index;
			}
		Content* getAddress(size_t index)
			{
			return reinterpret_cast<Content*>(mem)+index;
			}
		};
	public:
	class const_iterator;
	class iterator
		{
		friend class ChunkedArray;
		friend class const_iterator;
		
		/* Elements: */
		private:
		
		/* Constructors and destructors: */
		publi

			:chunk(0),index(0)
			{
			}
		private:
			:chunk(sChunk),index(0)
			{
			}
		
		/* Methods: */
		public:
		bool operator==(const iterator& other) const
			{
			return chunk==other.chunk&&index==other.index;
			}
		bool operator!=(const iterator& other) const
			{
			return chunk!=other.chunk||index!=other.index;
			}
		Content& operator*(void) const
			{
			return (*chunk)[index];
			}
		Content* operator->(void) const
			{
			return chunk->getAddress(index);
			}
		iterator& operator++(void)
			{
			++index;
			if(index==chunk->header.numElements)
				{
				chunk=chunk->header.succ;
				index=0;
				}
			return *this;
			}
		iterator operator++(int)
			{
			iterator result(*this);
			++index;
			if(index==chunk->header.numElements)
				{
				chunk=chunk->header.succ;
				index=0;
				}
			return result;
			}
		};
	class const_iterator
		{
		friend class ChunkedArray;
		
		/* Elements: */
		private:
		
		/* Constructors and destructors: */
		public:
			:chunk(0),index(0)
			{
			

			:chunk(source.chunk),index(source.index)
			{
			}
		private:
			:chunk(sChunk),index(0)
			{
			}
		
		/* Methods: */
		public:
		bool operator==(const const_iterator& other) const
			{
			return chunk==other.chunk&&index==other.index;
			}
		bool operator==(const iterator& other) const
			{
			return chunk==other.chunk&&index==other.index;
			}
		bool operator!=(const const_iterator& other) const
			{
			return chunk!=other.chunk||index!=other.index;
			}
		bool operator!=(const iterator& other) const
			{
			return chunk!=other.chunk||index!=other.index;
			}
		const Content& operator*(void) const
			{
			return (*chunk)[index];
			}
		const Content* operator->(void) const
			{
			return chunk->getAddress(index);
			}
		const_iterator& operator++(void)
			{
			++index;
			if(index==chunk->header.numElements)
				{
				chunk=chunk->header.succ;
				index=0;
				}
			return *this;
			}
		const_iterator operator++(int)
			{
			const_iterator result(*this);
			++index;
			if(index==

				{
				chunk=chunk->header.succ;
				index=0;
				}
			return result;
			}
		};
	/* Elements: */
	private:
	/* Constructors and destructors: */
	public:
		:firstChunk(0),lastChunk(0)
		{
		}
	private:
	public:
		{
		clear();
		}
	/* Methods: */
		{
		return firstChunk==0;
		}
		{
		size_t result=0;
		for(const Chunk* chPtr=firstChunk;chPtr!=0;chPtr=chPtr->header.succ)
			result+=chPtr->header.numElements;
		return result;
		}
		{
		return (*lastChunk)[lastChunk->header.numElements-1];
		}
		{
		return (*lastChunk)[lastChunk->header.numElements-1];
		}
		{
		/* Check for empty array first: */
		if(lastChunk==0)
			{
			/* Create the first chunk: */
			firstChunk=new Chunk;
			lastChunk=firstChunk;
			}
		
		/* Check if there is room in the last chunk: */
		if(lastChunk->header.numElements==chunkSize)
			{
			/* Create a new chunk: */
			lastChunk->header.succ=new Chunk;
			lastChunk=lastChunk->header.succ;
			}
		
		/* Append the new element to the last chunk: */
		new(lastChunk->ge

		
		/* Increase the element count of the last chunk: */
		++lastChunk->header.numElements;
		}
		{
		/* Decrease the element count of the last chunk: */
		--lastChunk->header.numElements;
		
		/* Destroy the last element: */
		(*lastChunk)[lastChunk->header.numElements].~Content();
		
		/* Remove last chunk if it is empty: */
		if(lastChunk->header.numElements==0)
			{
			/* Find pointer to but-last chunk: */
			Chunk* chPtr1=0;
			for(Chunk* chPtr2=firstChunk;chPtr2!=lastChunk;chPtr1=chPtr2,chPtr2=chPtr2->header.succ)
				;
			
			/* Remove last chunk: */
			delete lastChunk;
			lastChunk=chPtr1;
			
			/* Check for empty array: */
			if(lastChunk==0)
				firstChunk=0;
			}
		}
		{
		while(firstChunk!=0)
			{
			Chunk* succ=firstChunk->header.succ;
			
			/* Destroy all elements in the chunk: */
			for(size_t i=0;i<firstChunk->header.numElements;++i)
				(*firstChunk)[i].~Content();
			
			/* Delete the chunk: */
			delete firstChunk;
			
			firstChunk=succ;
			}
		lastChunk=0;
		}


		return const_iterator(firstChunk);
		}
		{
		return iterator(firstChunk);
		}
		{
		return const_iterator();
		}
		{
		return iterator();
		}
	template <class FunctorParam>
		{
		/* Iterate through all chunks: */
		for(const Chunk* chunkPtr=firstChunk;chunkPtr!=0;chunkPtr=chunkPtr->header.succ)
			{
			/* Iterate through all elements in the chunk: */
			for(size_t i=0;i<chunkPtr->header.numElements;++i)
				{
				/* Apply the functor to the element: */
				functor((*chunkPtr)[i]);
				}
			}
		}
	template <class FunctorParam>
		{
		/* Iterate through all chunks: */
		for(Chunk* chunkPtr=firstChunk;chunkPtr!=0;chunkPtr=chunkPtr->header.succ)
			{
			/* Iterate through all elements in the chunk: */
			for(size_t i=0;i<chunkPtr->header.numElements;++i)
				{
				/* Apply the functor to the element: */
				functor((*chunkPtr)[i]);
				}
			}
		}
	template <class FunctorParam>
		{
		/* Iterate through all chunks: */
		for(const Chunk* chunkPtr=firstChunk;chunkPtr!=0;chunkPtr=chunkPtr->he
struct Frame
	int Texture;
	int CentreX;
	int CentreY;
	int UVCoords[4][2];
};
class Sprite_Header_Chunk : public Chunk_With_Children
public:
	Sprite_Header_Chunk(Chunk_With_Children* const parent,const char*,size_t const);
	Sprite_Header_Chunk(const char* file_name, Chunk_With_Children * parent = NULL);
	Sprite_Header_Chunk()
	: Chunk_With_Children(0,"SPRIHEAD"){}
	Sprite_Header_Chunk(Chunk_With_Children* parent)
	: Chunk_With_Children(parent,"SPRIHEAD"){}
										 
	int write_file(const char* fname);
	virtual BOOL output_chunk(HANDLE &hand);
};
class PC_Sprite_Chunk : public Chunk_With_Children
public:
	PC_Sprite_Chunk(Sprite_Header_Chunk* parent,const char*,size_t);
	PC_Sprite_Chunk(Sprite_Header_Chunk* parent)
	: Chunk_With_Children(parent,"SPRITEPC"){}
};
class Saturn_Sprite_Chunk : public Chunk_With_Children
public:
	Saturn_Sprite_Chunk(Sprite_Header_Chunk* parent,const char*,size_t);
	Saturn_Sprite_Chunk(Sprite_Header_Chunk* parent)
	: Chunk_With_Children(parent,"SPRITESA"){}


class Playstation_Sprite_Chunk : public Chunk_With_Children
public:
	Playstation_Sprite_Chunk(Sprite_Header_Chunk* parent,const char*,size_t);
	Playstation_Sprite_Chunk(Sprite_Header_Chunk* parent)
	: Chunk_With_Children(parent,"SPRITEPS"){}
};
class Sprite_Action_Chunk  : public Chunk
public:
	Sprite_Action_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Action_Chunk(Chunk_With_Children* parent);
	~Sprite_Action_Chunk(); 
	virtual BOOL output_chunk (HANDLE &hand);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	int Action;
	int NumYaw;
	int NumPitch;
	int NumFrames;
	Frame*** FrameList;
	int Flags;
	int FrameTime;
	 
};
class Sprite_Size_Chunk  : public Chunk
public:
	Sprite_Size_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Size_Chunk(Chunk_With_Children* parent);
	virtual BOOL output_chunk (HANDLE &hand);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	double scale;
	doub

	double maxx;
	int radius;
	int Flags ;
};
class Sprite_Extent_Chunk  : public Chunk
public:
	Sprite_Extent_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Extent_Chunk(Chunk_With_Children* parent);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	double minx;
	double maxx; 
	double miny;
	double maxy;
	int spare1,spare2;
};
class Sprite_Version_Number_Chunk  : public Chunk
public:
	Sprite_Version_Number_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Version_Number_Chunk(Chunk_With_Children* parent);
	virtual BOOL output_chunk (HANDLE &hand);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	int version_num;
};
class Sprite_Bitmap_Scale_Chunk : public Chunk
public :
	Sprite_Bitmap_Scale_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Bitmap_Scale_Chunk(Chunk_With_Children* parent);
	~Sprite_Bitmap_Scale_Chunk();
	virtual size_t size_chunk();
	virtual void fill_dat
/*
 * File automatically generated by
 * gengen 1.4.1 by Lorenzo Bettini 
 */
void
handle_version_gen_class::generate_handle_version(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (short_opt)
    {
      stream << "case 'V':	/* Print version and exit.  */";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "if (strcmp (long_options[option_index].name, \"version\") == 0) {";
      stream << "\n";
      stream << indent_str;
    }
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_print_version ();";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (parser_name, stream, indent + indent_str.length ());
  stream << "_free (&local_args_info);";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  stream << "  exit (EXIT_SUCCESS);";
  if (( ! short_opt ))
    {
      stream << "\n";
      stream << indent_str;
   
static ELEMDESC s_mElemDesc[] = 
	{{{NULL}, VT_VARIANT}, {NULL, 0x11}},
	{0}
};
static CBTypeInfo::METHOD_ENTRY s_mData[] =
	{L"Item", {0x00000000, NULL, &s_mElemDesc[0], FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 1, 1, 28, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"Count", {0x60020001, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 32, 0, {{{NULL}, VT_I4}}, 0}},
	{L"_NewEnum", {0xFFFFFFFC, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 36, 0, {{{NULL}, VT_UNKNOWN}}, 1}},
	{L"Items", {0x60020002, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 40, 0, {{{NULL}, VT_VARIANT}}, 0}}
};
static HRESULT _Invoke(PVOID pvInstance, MEMBERID memid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult)
	IStringList* pObject = (IStringList*)pvInstance;
	HRESULT hr;
	UINT cArgs = pDispParams->cArgs;
	UINT cArgs1 = cArgs - pDispParams->cNamedArgs;
	hr;cArgs;cArgs1;
	{
		if(cArgs1 > 1)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_OPT(VT_VARIANT, 
static bool checkLocatorCallbacks( const osgVolume::Locator& locator )
    return locator.getLocatorCallbacks().size()>0;
static bool readLocatorCallbacks( osgDB::InputStream& is, osgVolume::Locator& locator )
    unsigned int size = is.readSize(); is >> is.BEGIN_BRACKET;
    for ( unsigned int i=0; i<size; ++i )
    {
        osgVolume::Locator::LocatorCallback* cb =
            dynamic_cast<osgVolume::Locator::LocatorCallback*>( is.readObject() );
        if ( cb ) locator.addCallback( cb );
    }
    is >> is.END_BRACKET;
    return true;
static bool writeLocatorCallbacks( osgDB::OutputStream& os, const osgVolume::Locator& locator )
    const osgVolume::Locator::LocatorCallbacks& callbacks = locator.getLocatorCallbacks();
    os.writeSize( callbacks.size() ); os << os.BEGIN_BRACKET << std::endl;
    for ( osgVolume::Locator::LocatorCallbacks::const_iterator itr=callbacks.begin();
          itr!=callbacks.end(); ++itr )
    {
        os << itr->get();
    }
    os << os.END_BRACKET <
namespace glm
	namespace virtrev_glmext
	{
		namespace xstream
		{
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec2<T> const & vec)
			{
				stream << "<glm_vec2 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec3<T> const & vec)
			{
				stream << "<glm_vec3 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec4<T> const & vec)
			{
				stream << "<glm_vec4 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "w=\"" << vec.w << "\" ";
				stream << "/>";
				return stream;
			}
			

			std::ostream & operator << (std::ostream & stream, glm::detail::tmat2x2<T> const & mat)
			{
				stream << "<glm_mat2>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat2>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat3x3<T> const & mat)
			{
				stream << "<glm_mat3>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << g

				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 2)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 2)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 2)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat3>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat4x4<T> const & mat)
			{
				stream << "<glm_mat4>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "w=\"" << glm::row(mat, 0)[3] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "w=\"" <<
namespace android {
class BpDumpTunnel : public BpInterface<IDumpTunnel> {
public:
    BpDumpTunnel(const sp<IBinder>& impl)
        :   BpInterface<IDumpTunnel>(impl) {
    }
    virtual ~BpDumpTunnel();
    virtual status_t kickDump(String8& result, const char* prefix) {
        Parcel data, reply;
        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
        data.writeString8(result);
        data.writeCString(prefix);
        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
        if (err != NO_ERROR) {
            ALOGE("kickDump could not contact remote\n");
            return err;
        }
        result = reply.readString8();
        err = reply.readInt32();
        return err;
    }
};
BpDumpTunnel::~BpDumpTunnel() {}
IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
    switch (code) {
        case DUMPTUNNEL_DUMP: {
            CHECK_I

            String8 result;
            const char* prefix = NULL;
            result = data.readString8();
            prefix = data.readCString();
            status_t ret = kickDump(result, prefix);
            reply->writeString8(result);
            reply->writeInt32(ret);
            return NO_ERROR;
        }
    }
    return BBinder::onTransact(code, data, reply, flags);
ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
DumpTunnelHelper::DumpTunnelHelper() :
    mSoHandle(NULL),
    mRegDumpPtr(NULL),
    mUnregDumpPtr(NULL)
    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
    typedef bool (*UnregDumpPrototype)(const String8&);
    mSoHandle = dlopen("libgui_ext.so", RTLD_LAZY);
    if (mSoHandle) {
        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
        if (NULL == mRegDumpPtr) {
            ALOGE("finding regDump(
namespace se_pulseaudio {
	PaStream::PaStream(PaContext &c, VorbisSound& sound, int volume, bool shouldLoop) 
		: context_(c), currentSection_(0), bytesWritten_(0), bytesRead_(0), vorbisFile_(0), shouldLoop_(shouldLoop) {
		static int streamId = 0;
		pa_sample_format_t format = PA_SAMPLE_S16LE;
		int channels = sound.channels();
		int samplerate = sound.sampleRate();
		const pa_sample_spec ss = {
			format,
			samplerate,
			channels
		};
		sprintf(name_, "%s_%d_stream", c.name(), streamId++);
		stream_ = pa_stream_new(c.context(), name_, &ss, NULL);
		if(stream_) {
			LogDetail("Stream created!  Getting there!");
		}
		pa_stream_set_write_callback(stream_, PaStream::stream_write_callback, this);
		pa_stream_set_state_callback(stream_, PaStream::stream_state_callback, this);
		pa_volume_t v = PA_VOLUME_NORM* volume / 256;
		pa_cvolume cv;
		pa_stream_connect_playback(stream_, NULL, NULL, (pa_stream_flags_t)0, pa_cvolume_set(&cv, ss.channels, v), NULL);
		sound_ = &sound;
		context_.inc

	}
	PaStream::~PaStream() {
		LogDetail("Destroy stream " << name_);
		if(sound_ && vorbisFile_) {
			sound_->close(vorbisFile_);
			currentSection_ = 0;
		}
		pa_stream_unref(stream_);
		context_.decStreamRef(this);
	}
	void PaStream::play() {
		currentSection_ = 0;
		bytesWritten_ = bytesRead_ = 0;
		vorbisFile_ = sound_->open();
		LogDetail("New stream " << name_);
		doStreamWrite();
	}
	void PaStream::stop() {
		LogDetail("Corking stream");
		pa_stream_cork(stream_, 1, stream_corked_callback, this);
	}
	void PaStream::doStreamWrite() {
		if(PA_STREAM_READY == pa_stream_get_state(stream_)) {
			size_t writableSize = pa_stream_writable_size(stream_);
			while(doStreamWrite(writableSize) > 0) {
				writableSize = pa_stream_writable_size(stream_);
			}
		}
	}
	int PaStream::doStreamWrite(size_t length) {
		if(!sound_ || length == 0) {
			return 0;
		}
		if(bytesWritten_ >= bytesRead_) {
			bytesWritten_ = 0;
			bytesRead_ = bytesRead_ = sound_->read(pcmout_, sizeof(pcmout_), vorbisFil

		}
		if (bytesRead_ < 0) {
			LogWarning("Error in stream");
			sound_ = 0;
			return 0;
		}
		if(bytesRead_ == 0) {
			isDraining_ = true;
			pa_stream_drain(stream_, stream_drained_callback, this);
			return 0;
		}
		if(PA_STREAM_READY == pa_stream_get_state(stream_)) {
			const size_t writableSize = pa_stream_writable_size(stream_);
			const size_t writeSize = (bytesRead_ - bytesWritten_ < writableSize ? bytesRead_ - bytesWritten_ : writableSize);
			if(writeSize > 0) {
				pa_stream_write(stream_, pcmout_ + bytesWritten_, writeSize, NULL, 0, PA_SEEK_RELATIVE);
			}
			bytesWritten_ += writeSize;
			return writeSize;
		}
	}
	void PaStream::stream_write_callback(pa_stream *stream, size_t length, void *userdata) {
		PaStream* s = (PaStream*)userdata;
		Assert(stream);
		Assert(length > 0);
		Assert(stream == s->stream_);
		s->doStreamWrite();
	}
	void PaStream::stream_drained_callback(pa_stream *stream, int success, void *userdata) {
		AssertWarning(success, "Stream drain failed");


		s->isDraining_ = false;
		LogDetail("Stream drained");
		pa_stream_disconnect(s->stream_);
		if(s->context().streamListener()) {
			s->context().streamListener()->streamEnded(s);
		}
	}
	void PaStream::stream_corked_callback(pa_stream *stream, int success, void *userdata) {
		AssertWarning(success, "Corking sound returned failure");
		PaStream* s = (PaStream*)userdata;
		s->isDraining_ = false;
		LogDetail("Stream stopped");
		pa_stream_disconnect(s->stream_);
		if(s->context().streamListener()) {
			s->context().streamListener()->streamStopped(s);
		}
	}
	void PaStream::stream_state_callback(pa_stream *stream, void *userdata) {
		Assert(stream);
		PaStream* s = (PaStream*)userdata;
		Assert(s && s->stream_ == stream);
		switch (pa_stream_get_state(stream)) {
		case PA_STREAM_CREATING:
			LogDetail("PA_STREAM_CREATING");
			break;
		case PA_STREAM_TERMINATED:
			LogDetail("PA_STREAM_TERMINATED");
			delete s;
			break;
		case PA_STREAM_READY:
			s->play();
			LogDetail("PA_STREAM_RE
namespace {
SINGLETON_IMPL(RepoService)
RepoService::RepoService(QObject *parent)
    : QObject(parent)
    refresh_timer_ = new QTimer(this);
    connect(refresh_timer_, SIGNAL(timeout()), this, SLOT(refresh()));
    list_repo_req_ = NULL;
    in_refresh_ = false;
void RepoService::start()
    refresh_timer_->start(kRefreshReposInterval);
void RepoService::stop()
    refresh_timer_->stop();
void RepoService::refresh()
    if (in_refresh_) {
        return;
    }
    const std::vector<Account>& accounts = seafApplet->accountManager()->accounts();
    if (accounts.empty()) {
        in_refresh_ = false;
        return;
    }
    in_refresh_ = true;
    if (list_repo_req_) {
        delete list_repo_req_;
    }
    list_repo_req_ = new ListReposRequest(accounts[0]);
    connect(list_repo_req_, SIGNAL(success(const std::vector<ServerRepo>&)),
            this, SLOT(onRefreshSuccess(const std::vector<ServerRepo>&)));
    connect(list_repo_req_, SIGNAL(failed(const ApiError&)),
            

    list_repo_req_->send();
void RepoService::onRefreshSuccess(const std::vector<ServerRepo>& repos)
    in_refresh_ = false;
    server_repos_ = repos;
    emit refreshSuccess(repos);
void RepoService::onRefreshFailed(const ApiError& error)
    in_refresh_ = false;
    emit refreshFailed(error);
void RepoService::refresh(bool force)
    if (!force || !in_refresh_) {
        refresh();
        return;
    }
    in_refresh_ = false;
    refresh();
ServerRepo
RepoService::getRepo(const QString& repo_id) const
    int i, n = server_repos_.size();
    for (i = 0; i < n; i++) {
        ServerRepo repo = server_repos_[i];
        if (repo.id == repo_id) {
            return repo;
        }
    }
    return ServerRepo();
void RepoService::openLocalFile(const QString& repo_id,
                                const QString& path_in_repo,
                                QWidget *dialog_parent)
    LocalRepo r;
    seafApplet->rpcClient()->getLocalRepo(repo_id, &r);
    if (r.isValid()) {
      
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla browser.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications, Inc.
 * Portions created by the Initial Developer are Copyright (C) 1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Travis Bogard <travis@netscape.com>
 *
 * Alternatively, the contents of this file may

 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g

 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LO

    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOA

    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_FLAGS_NONE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CA
/*================================================================================
  code generated by: java2cpp
  class: org.xml.sax.helpers.LocatorImpl
================================================================================*/
namespace j2cpp { namespace java { namespace lang { class String; } } }
namespace j2cpp { namespace java { namespace lang { class Object; } } }
namespace j2cpp { namespace org { namespace xml { namespace sax { class Locator; } } } }
namespace j2cpp {
namespace org { namespace xml { namespace sax { namespace helpers {
	class LocatorImpl;
	class LocatorImpl
		: public object<LocatorImpl>
	{
	public:
		J2CPP_DECLARE_CLASS
		J2CPP_DECLARE_METHOD(0)
		J2CPP_DECLARE_METHOD(1)
		J2CPP_DECLARE_METHOD(2)
		J2CPP_DECLARE_METHOD(3)
		J2CPP_DECLARE_METHOD(4)
		J2CPP_DECLARE_METHOD(5)
		J2CPP_DECLARE_METHOD(6)
		J2CPP_DECLARE_METHOD(7)
		J2CPP_DECLARE_METHOD(8)
		J2CPP_DECLARE_METHOD(9)
		explicit LocatorImpl(jobject jobj)
		: object<LocatorImpl>(jobj)
		{
		}
		ope

		operator local_ref<org::xml::sax::Locator>() const;
		LocatorImpl();
		LocatorImpl(local_ref< org::xml::sax::Locator > const&);
		local_ref< java::lang::String > getPublicId();
		local_ref< java::lang::String > getSystemId();
		jint getLineNumber();
		jint getColumnNumber();
		void setPublicId(local_ref< java::lang::String >  const&);
		void setSystemId(local_ref< java::lang::String >  const&);
		void setLineNumber(jint);
		void setColumnNumber(jint);
namespace j2cpp {
org::xml::sax::helpers::LocatorImpl::operator local_ref<java::lang::Object>() const
	return local_ref<java::lang::Object>(get_jobject());
org::xml::sax::helpers::LocatorImpl::operator local_ref<org::xml::sax::Locator>() const
	return local_ref<org::xml::sax::Locator>(get_jobject());
org::xml::sax::helpers::LocatorImpl::LocatorImpl()
: object<org::xml::sax::helpers::LocatorImpl>(
	call_new_object<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(0),
		org

	>()
org::xml::sax::helpers::LocatorImpl::LocatorImpl(local_ref< org::xml::sax::Locator > const &a0)
: object<org::xml::sax::helpers::LocatorImpl>(
	call_new_object<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(1),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(1)
	>(a0)
local_ref< java::lang::String > org::xml::sax::helpers::LocatorImpl::getPublicId()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(2),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(2), 
		local_ref< java::lang::String >
	>(get_jobject());
local_ref< java::lang::String > org::xml::sax::helpers::LocatorImpl::getSystemId()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(3),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(3), 
		local_ref<

	>(get_jobject());
jint org::xml::sax::helpers::LocatorImpl::getLineNumber()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(4),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(4), 
		jint
	>(get_jobject());
jint org::xml::sax::helpers::LocatorImpl::getColumnNumber()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(5),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(5), 
		jint
	>(get_jobject());
void org::xml::sax::helpers::LocatorImpl::setPublicId(local_ref< java::lang::String > const &a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(6),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(6), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setSystemId(local_ref< 

	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(7),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(7), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setLineNumber(jint a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(8),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(8), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setColumnNumber(jint a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(9),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(9), 
		void
	>(get_jobject(), a0);
J2CPP_DEFINE_CLASS(org::xml::sax::helpers::LocatorImpl,"org/xml/sax/helpers/LocatorImpl")
J2CPP_DEFINE_METHOD(org::xml::sax::helpers::LocatorImpl,0,"<init>","(
namespace saturn {
	bool ModelAnimationSystem::animating = true;
	ModelAnimationSystem::ModelAnimationSystem() : time(0.0f) {
		name = "ModelAnimationSystem";
	}
	void ModelAnimationSystem::update(Space *space, float dt) {
		time += dt;
		bool shouldAnimate = false;
		float interval = 1.0f / 45.0f;
		float interval = 1.0f / 60.0f;
		if (time > interval - .00000001f) {
			shouldAnimate = true;
			time -= interval;
		}
		if (!ModelAnimationSystem::animating) {
			shouldAnimate = false;
		}
		for (std::size_t i = 0; i < space->entities.size(); ++i) {
			Entity& entity = *space->entities[i];
			if (entity.hasComponent("Model")) {
				std::vector<Component*> models = entity.getComponents("Model");
				
				for (std::size_t j = 0; j < models.size(); ++j) {
					Model* model = (Model*)models[j];
					
					if (model->animating) {
						ModelAnimation* animation = model->getCurrentAnimation();
						
						if (model->transitioning || (!animation->stillFrame && model->animationDelay < .0001f)) 
/*
 * File:   testChunkClass.cpp
 * Author: Keo
 *
 * Created on 27.10.2013, 18:39:26
 */
CPPUNIT_TEST_SUITE_REGISTRATION(testChunkClass);
testChunkClass::testChunkClass()
testChunkClass::~testChunkClass()
void testChunkClass::setUp()
void testChunkClass::tearDown()
void testChunkClass::testChunk()
    sf::Vector3i p0(2, 3, 4);
    sf::Vector3i blockPosition(16, 16, 10);
    Chunk chunk(p0);
    CPPUNIT_ASSERT_EQUAL(AIR, chunk.getBlock(blockPosition));
    
    chunk.placeBlock(blockPosition, GRASS);
    CPPUNIT_ASSERT_EQUAL(GRASS, chunk.getBlock(blockPosition));
void testChunkClass::testName()
    sf::Vector3i p(1,4,5);
    CPPUNIT_ASSERT_EQUAL(std::string("1-4-5.chunk"),Chunk::getChunkName(p));
void testChunkClass::testSaveAndLoad()
    /*sf::Vector3i p(1,4,5);
    Chunk chunk(p);
    chunk.placeBlock(p,GRASS);
    chunk.save();
    
    Chunk chunkLoad;
    
    CPPUNIT_ASSERT_EQUAL(GRASS, chunkLoad.getBlock(p));*/
    CPPUNIT_FAIL("Test not yet implemented!");
void testChunkClass::
/*-----------------------------------------------------------------------
 * File: bioapi_typecast.htp
 *
 *-----------------------------------------------------------------------
 */
/* API Functions */
extern "C" {
/*************************************************************************/
/*** This file is automatically generated. Do not hand edit **************/
/*************************************************************************/
/*************************************************************************/
/*** BioAPI Core Functions ***********************************************/
/*************************************************************************/
typedef BioAPI_RETURN (BioAPI *BioAPI_Init_ptr)(
						const BioAPI_VERSION *Version,
						uint32 Reserved1,
						const void *Reserved2,
						uint32 Reserved3,
						const void *Reserved4 );
typedef BioAPI_RETURN (BioAPI *BioAPI_Terminate_ptr)(
						void );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleLoad_ptr)(
						cons

						uint32 Reserved,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleUnload_ptr)(
						const BioAPI_UUID *ModuleGuid,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleAttach_ptr)(
						const BioAPI_UUID *ModuleGuid,
						const BioAPI_VERSION *Version,
						const BioAPI_MEMORY_FUNCS *MemoryFuncs,
						uint32 DeviceID,
						uint32 Reserved1,
						uint32 Reserved2,
						uint32 Reserved3,
						BioAPI_FUNC_NAME_ADDR *FunctionTable,
						uint32 NumFunctionTable,
						const void *Reserved4,
						BioAPI_HANDLE_PTR NewModuleHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleDetach_ptr)(
						BioAPI_HANDLE ModuleHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_QueryDevice_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_SERVICE_UID_PTR ServiceUID );
/**************************************************************

/*** BioAPI Service Provider APIs ***************************************/
/************************************************************************/
typedef BioAPI_RETURN (BioAPI *BioAPI_FreeBIRHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_GetBIRFromHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_PTR *BIR );
typedef BioAPI_RETURN (BioAPI *BioAPI_GetHeaderFromHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_HEADER_PTR Header );
typedef BioAPI_RETURN (BioAPI *BioAPI_EnableEvents_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_MODULE_EVENT_MASK *Events );
typedef BioAPI_RETURN (BioAPI *BioAPI_SetGUICallbacks_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_GUI_STREAMING_CALLBACK GuiStreamingCallback,
						void *GuiStreamingCallbackCtx,
						BioAPI_GUI_STATE_CALLBACK GuiStateCallback,
						void *GuiSta

typedef BioAPI_RETURN (BioAPI *BioAPI_SetStreamCallback_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_STREAM_CALLBACK StreamCallback,
						void *StreamCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_StreamInputOutput_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DATA_PTR InMessage,
						BioAPI_DATA_PTR OutMessage );
typedef BioAPI_RETURN (BioAPI *BioAPI_Capture_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR CapturedBIR,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_CreateTemplate_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload );
typedef BioAPI_RETURN (BioAPI *BioAPI_Process_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						BioAPI_BIR_HANDLE_PTR ProcessedBIR );
type

						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE *AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload );
typedef BioAPI_RETURN (BioAPI *BioAPI_IdentifyMatch_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout );
typedef BioAPI_RETURN (BioAPI *BioAPI_Enroll_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpos

						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Verify_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Identify_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint3

						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Import_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_DATA *InputData,
						BioAPI_BIR_BIOMETRIC_DATA_FORMAT InputFormat,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR ConstructedBIR );
typedef BioAPI_RETURN (BioAPI *BioAPI_SetPowerMode_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_POWER_MODE PowerMode );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbOpen_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbClose_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbCreate_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
		

typedef BioAPI_RETURN (BioAPI *BioAPI_DbDelete_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbSetCursor_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbFreeCursor_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbStoreBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *BIRToStore,
						BioAPI_DB_HANDLE DbHandle,
						BioAPI_UUID_PTR Uuid );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbGetBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_BIR_HANDLE_PTR RetrievedBIR,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbGetNextBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_CURSOR_PTR Cursor,
						
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
class Fixture;
namespace RM
    class Repo;
/**
 * @brief   Copy a Test-Repository and remove it after usage
 */
class TempRepo
public:
    TempRepo(Fixture* fixture, const char* name);
    ~TempRepo();
public:
    operator QString() const
    {
        return mTempRepoDir;
    }
private:
    QString mTe
namespace voxel_grid{
    
    template <typename tag>
    std::ostream& operator<<(std::ostream& os, const coord<tag>& coord){
      os << "(" << coord.x << ", " << coord.y << ", " << coord.z << ")";
      return os;
    }
    world_coord to_world_coord(const chunk_coord& chunk){
        return {
            chunk.x * chunk_size,
            chunk.y * chunk_size,
            chunk.z * chunk_size
        };
    }
    world_coord to_world_coord(const chunk_coord& chunk, const intra_chunk_coord& intra_chunk){
        return {
            (chunk.x * chunk_size) + intra_chunk.x,
            (chunk.y * chunk_size) + intra_chunk.y,
            (chunk.z * chunk_size) + intra_chunk.z
        };
    }
    std::pair<chunk_coord, intra_chunk_coord> from_world_coord(const world_coord& coord){
        auto to_chunk = [](const int v){
            if(v < 0){
                return (v + 1) / chunk_size - 1;
            } else {
                return v / chunk_size;
            }
        };
        au
using namespace kaynine;
bool MemoryPool::reserve(const unsigned kbytes) {
	discard();
	data_ = ::malloc(kbytes * 1024);
	if (!data_)
		return false;
	first_ = biggest_ = smallest_ = new (alignUp(data_)) Chunk;
	last_ = new (alignDown((unsigned)data_ + kbytes * 1024 - sizeof(Chunk))) Chunk;
	reset();
	return true;
void MemoryPool::reset() {
	first_->prev = 0;
	first_->next = last_;
	last_->prev = first_;
	last_->next = 0;
	first_->smaller = first_->bigger = 0;
	last_->markOccupied();
void MemoryPool::discard() {
	if (data_) {
		::free(data_);
		data_ = 0;
	}
	first_ = last_ = biggest_ = smallest_ = 0;
void* MemoryPool::allocate(const unsigned bytes) {
	assert(data_ && bytes);
	Chunk* chunk = findFreeChunk(bytes);
	if (!chunk)
		return 0;
	unlinkBySize(chunk);
	chunk->markOccupied();
	void* leftover = alignUp((unsigned)chunk + sizeof(Chunk) + bytes);
	if (leftover != (void*)chunk->next) {
		Chunk* leftChunk = new (leftover) Chunk;
		leftChunk->next = chunk->next;
		if (leftChunk->next)


		leftChunk->prev = chunk;
		chunk->next = leftChunk;
		linkBySize(leftChunk);
	}
	DEBUG_ONLY(checkStructure());
	return chunk + 1;
void MemoryPool::deallocate(void* data) {
	assert(data_ && data);
	Chunk* chunk = reinterpret_cast<Chunk*>(data) - 1;
	assert(chunk >= first_ && chunk < last_);
	Chunk* check = chunk->prev;
	if (check && (check->bigger != check || check->smaller != check)) {
		check->next = chunk->next;
		chunk->next->prev = check;
		chunk = check;
		unlinkBySize(chunk);
	}
	check = chunk->next;
	if (check && (check->bigger != check || check->smaller != check)) {
		check->next->prev = chunk;
		chunk->next = check->next;
		unlinkBySize(check);
	}
	linkBySize(chunk);
	DEBUG_ONLY(checkStructure());
void MemoryPool::logStructure(Logger& logger, bool contents UNUSED(= false), bool empty UNUSED(= false)) const {
	logger.write(_T("\n|=== Memory Pool == %p =================================|"), data_);
	logger.write(_T("\n| chunk |  size   |  start   |   less   |   more   |   data

	logger.write(_T("\n|-------------------------------------------------------------|"));
	unsigned iChunk = 0;
	for (Chunk* chunk = first_; chunk && chunk->next; chunk = chunk->next, ++iChunk) {
		if (chunk->isOccupied()) {
			logger.write(_T("\n| %5d | %7d | %p | %p |"), iChunk, chunk->dataSize(), chunk, chunk->data());
			if (contents)
				logContents(logger, chunk);
		} else {
			logger.write(_T("\n| %5d | %7d | %p | %p | %p |          |"), iChunk, chunk->dataSize(), chunk, chunk->smaller, chunk->bigger);
			if (contents && empty)
				logContents(logger, chunk);
		}
	}
	logger.write(_T("\n|=============================================================|\n"), data_);
void MemoryPool::logContents(Logger& logger, Chunk* chunk) const {
	const unsigned colInts = 4;
	const unsigned contentsInts = 8 * colInts;
	for (unsigned i = 0; i < chunk->dataSize() / sizeof(unsigned); ++i) {
		if (i && i % contentsInts == 0)
			logger.write(_T("\n|                                                        

		if (i % colInts == 0)
			logger.write(_T(" "));
		logger.write(_T("%08x "), ((unsigned*)chunk->data())[i]);
	}
inline MemoryPool::Chunk* MemoryPool::findFreeChunk(const unsigned bytes) const {
	Chunk* freeChunk = 0;
	for (Chunk* check = biggest_; check; check = check->smaller) {
		assert(check->bigger != check && check->smaller != check);
		if (check->dataSize() < bytes)
			break;
		freeChunk = check;
	}
	return freeChunk;
inline void MemoryPool::linkBySize(Chunk* chunk) {
	assert(chunk);
	if (!biggest_ || !smallest_) {
		assert(!biggest_ && !smallest_);
		chunk->bigger = 0;
		chunk->smaller = 0;
		biggest_ = chunk;
		smallest_ = chunk;
	}
	else if (chunk->dataSize() < smallest_->dataSize()) {
		chunk->bigger = smallest_;
		chunk->smaller = 0;
		chunk->bigger->smaller = chunk;
		smallest_ = chunk;
	}
	else if (chunk->dataSize() > biggest_->dataSize()) {
		chunk->bigger = 0;
		chunk->smaller = biggest_;
		chunk->smaller->bigger = chunk;
		biggest_ = chunk;
	}
	else {
		Chunk* bigger 
/*
 * mirco_mempage_heap.c
 *  Created on: 2012-12-21
 *      Author: qianqians
 * mirco_mempage_heap 
 */
size_t chunk_size = 1024*64;
bool flag(mirco_mempage_heap * _heap){
	return _heap->_flag.test_and_set();
void clear(mirco_mempage_heap * _heap){
	_heap->_flag.clear();
void * _mirco_mempage_heap_alloc_big(struct mirco_mempage_heap * _heap, size_t size){
	void * ret = _malloc(_heap->chunk, size);
	if (ret == 0){	
		size_t _chunksize = ((size+sizeof(struct chunk)+sizeof(struct chunk*)+sizeof(size_t))*2+chunk_size-1)/chunk_size*chunk_size;
		size_t _old_chunksize = _heap->chunk->size;
		if (_chunksize <= _old_chunksize){
			do{
				if (_heap->chunk->count.load() == 0){
					_heap->chunk->slide = sizeof(struct chunk);
					break;
				}else{
					_heap->chunk->rec_flag.store(1);
					char flag = 1;
					if (_heap->chunk->count.load() == 0){
						if (_heap->chunk->rec_flag.compare_exchange_weak(flag, 0)){
							_heap->chunk->slide = sizeof(struct chunk);
							break;
						}
					}
	

				_heap->chunk = _chunk(_heap->_father_heap, _old_chunksize);
			}while(0);
		}else{
			if (_heap->chunk->count.load() == 0){
				_recover_chunk(_heap->_father_heap, _heap->chunk);
			}else{
				_heap->chunk->rec_flag.store(1);
				char flag = 1;
				if (_heap->chunk->count.load() == 0){
					if (_heap->chunk->rec_flag.compare_exchange_weak(flag, 2)){
						_recover_chunk(_heap->_father_heap, _heap->chunk);
					}
				}
			}
			_heap->chunk = _chunk(_heap->_father_heap, _chunksize);
		}
		ret = _malloc(_heap->chunk, size);
	}
	return ret;
void * _mirco_mempage_heap_alloc_small(struct mirco_mempage_heap * _heap, size_t size){
	void * ret = _malloc(_heap->chunk_small, size);
	if (ret == 0){	
		do{
			if (_heap->chunk_small->count.load() != 0){
				_heap->chunk_small->rec_flag.store(1);
				if (_heap->chunk_small->count.load() == 0){
					char flag = 1;
					if (!_heap->chunk_small->rec_flag.compare_exchange_weak(flag, 0)){
						_heap->chunk_small = _chunk(_heap->_father_heap, chunk_s
namespace KBEngineClient{
void KBundle::newmessage( KMessage& msg )
		
	fini(false);
	this->msgtypePtr = &msg;
	numMessage += 1;
	KMessage& msgtype = *( msgtypePtr);
	writeUint16(msgtype.id);
	if(msgtype.msglen == -1)
	{
		writeUint16(0);
		messageLength = 0;
	}
KBundle::KBundle():streamPtr(0),msgtypePtr(0),numMessage(0),messageLength(0)
	streamPtr = new MemoryStream();
KBundle::~KBundle()
void KBundle::send(KNetworkInterface networkInterface)
	fini(true);
			
	for(int i=0; i<streamList.size(); i++)
	{
		streamPtr = streamList[i];
		MemoryStream& stream = *streamPtr;
		networkInterface.send( stream.data() ,stream.size() );
	}
	streamList.clear();
	streamPtr = new MemoryStream();
		
void KBundle::checkStream(int v)
	if(!streamPtr || v > streamPtr->fillfree2() )
	{
		if(streamPtr && v > streamPtr->fillfree2() )
			streamList.push_back(streamPtr);
		streamPtr = new MemoryStream();
	}
	messageLength += v;
		
void KBundle::writeInt8(int8 v)
	checkStream(1);
	MemoryStream& stream = *streamPt

	stream<<v;
void KBundle::writeInt16(int16 v)
	checkStream(2);
	MemoryStream& stream = *streamPtr;
	stream<<v;
			
void KBundle::writeInt32(int32 v)
	checkStream(4);
	MemoryStream& stream = *streamPtr;
	stream<<v;
void KBundle::writeInt64(int64 v)
	checkStream(8);
	MemoryStream& stream = *streamPtr;
	stream<<v;
		
void KBundle::writeUint8(uint8 v)
	checkStream(1);
	MemoryStream& stream = *streamPtr;
	stream<<v;
void KBundle::writeUint16(uint16 v)
	checkStream(2);
	MemoryStream& stream = *streamPtr;
	stream<<v;
			
void KBundle::writeUint32(uint32 v)
	checkStream(4);
	MemoryStream& stream = *streamPtr;
	stream<<v;
void KBundle::writeUint64(uint64 v)
	checkStream(8);
	MemoryStream& stream = *streamPtr;
	stream<<v;
		
void KBundle::writeFloat(float v)
	checkStream(4);
	MemoryStream& stream = *streamPtr;
	stream<<v;
void KBundle::writeDouble(double v)
	checkStream(8);
	MemoryStream& stream = *streamPtr;
	stream<<v;
		
void KBundle::writeString(const std::string v)
	checkStream( v.length()

	MemoryStream& stream = *streamPtr;
	stream << v;
		
void KBundle::writeBlob(char* v,int size)
	checkStream( size + 4 );
	MemoryStream& stream = *streamPtr;
	stream<<(uint32)size;
	if(size > 0)
		stream<<v;
void KBundle::fini(bool issend)
	if(numMessage > 0)
	{
		writeMsgLength();
		if(streamPtr != 0)
			streamList.push_back(streamPtr);
	}
			
	if(issend)
	{
		numMessage = 0;
		msgtypePtr =0;
	}
void KBundle::writeMsgLength()
		KMessage& msgtype = *( msgtypePtr);
		if(msgtype.msglen != -1)
			return;
		MemoryStream& stream = *(streamPtr);
		if(stream.opsize() >= messageLength)
		{
			int idx = (int)stream.opsize() - messageLength - 2;
			stream.data()[idx] = (uint8)(messageLength & 0xff);
			stream.data()[idx + 1] = (uint8)(messageLength >> 8 & 0xff);
		}
		else
		{
			int size = messageLength - (int)stream.opsize();
			CCAssert( streamList.size() > 0 ,"");
			uint8* data = streamList[numMessage - 1]->data();
				
			int idx = stream.size() - size - 2;
				
			data[idx] = (uint8)(mess
template <typename Handler>
class CustomAllocHandler
    public:
        CustomAllocHandler(HandlerAllocator& allocator, Handler handler) :
            allocator_(allocator), handler_(handler)
        {
        }
        template <typename ...Args>
        void operator()(Args&&... args)
        {
            handler_(std::forward<Args>(args)...);
        }
        friend void* asio_handler_allocate(std::size_t size,
                                           CustomAllocHandler<Handler>* handler)
        {
            return handler->allocator_.Allocate(size);
        }
        friend void asio_handler_deallocate(void* pointer, std::size_t,
                                        CustomAllocHandler<Handler>* handler)
        {
            handler->allocator_.Deallocate(pointer);
        }
    private:
        HandlerAllocator& allocator_;
        Handler handler_;
};
template <typename Handler>
inline CustomAllocHandler<Handler> MakeCustomAllocHandler(
                        HandlerAl
WorldChunk::WorldChunk():
    chunk_x(0), chunk_y(0), chunk_z(0)
    for( int x=0; x<CHUNK_SIZE; x++ )
    {
        for( int y=0; y<CHUNK_SIZE; y++ )
        {
            for( int z=0; z<CHUNK_SIZE; z++ )
            {
                this->data[x][y][z] = false;
                if( (x+z)/2 == y )
                    this->data[x][y][z] = true;
            }
        }
    }
WorldChunk::~WorldChunk()
void WorldChunk::render()
    for( int x=0; x<CHUNK_SIZE; x++ )
    {
        for( int y=0; y<CHUNK_SIZE; y++ )
        {
            for( int z=0; z<CHUNK_SIZE; z++ )
            {
                if( this->data[x][y][z] )
                {
                    renderCube(glm::vec3(this->chunk_x+x, this->chunk_y+y, this->chunk_z+z));
                }
            }
        }
    }
void WorldChunk::checkCollides(GameContext* context)
    glm::vec3 pos = context->camera_position;
    int x = -(int)pos.x;
    int y = -(int)pos.y-2;
    int z = -(int)pos.z;
    if( x >= CHUNK_SIZE || y >= CHU
template<class T>
class SAChunk
public:
    SAChunk<T> *        next;
    uint32              startIndex;
    T *                 data[];
};
template<class T>
class SparseArray
private:
    ArenaAllocator *    alloc;
    uint32              chunkSize;
    SAChunk<T> *        firstChunk;
public:
    static SparseArray<T> * New(ArenaAllocator *allocator, uint32 chunkSize)
    {
        SparseArray<T> * array;
        if (!Math::IsPow2(chunkSize))
        {
            chunkSize = Math::NextPowerOf2(chunkSize);
        }
        UInt32Math::MulAdd<sizeof(T*), sizeof(SAChunk<T>)>(chunkSize);
        array = Anew(allocator, SparseArray<T>);
        array->alloc = allocator;
        array->chunkSize = chunkSize;
        array->firstChunk = NULL;
        return array;
    }
    void Set(uint32 index, T *element)
    {
        SAChunk<T> * chunk, **pPrev = &(this->firstChunk);
        uint32 indexInChunk = (index % this->chunkSize);
        for (chunk = this->firstChunk; chunk; chunk = chunk->

        {
            if (index < chunk->startIndex)
            {
                chunk = NULL;
                break;
            }
            if (index < chunk->startIndex + this->chunkSize)
            {
                break;
            }
            pPrev = &(chunk->next);
        }
        if (chunk == NULL)
        {
            chunk = (SAChunk<T> *)this->alloc->AllocZero(sizeof(SAChunk<T>) + (chunkSize * sizeof(T *)));
            chunk->startIndex = index - indexInChunk;
            UInt32Math::Add(chunk->startIndex, chunkSize);
            chunk->next = *pPrev;
            *pPrev = chunk;
        }
        chunk->data[indexInChunk] = element;
    }
    T * Get(uint32 index)
    {
        SAChunk<T> * chunk;
        uint32 indexInChunk = (index % this->chunkSize);
        for (chunk = this->firstChunk; chunk; chunk = chunk->next)
        {
            if (index < chunk->startIndex)
            {
                return NULL;
            }
            if (index < chunk->sta

            {
                return chunk->data[indexInChunk];
            }
        }
        return NULL;
    }
    SparseArray<T> * Copy()
    {
        SparseArray<T> * newSA = SparseArray<T>::New(this->alloc, this->chunkSize);
        SAChunk<T> * chunk, *pred = NULL;
        for (chunk = this->firstChunk; chunk; chunk = chunk->next)
        {
            SAChunk<T> *newChunk = (SAChunk<T> *)this->alloc->Alloc(sizeof(SAChunk<T>) + (sizeof(T *) * this->chunkSize));
            newChunk->startIndex = chunk->startIndex;
            js_memcpy_s(newChunk->data, sizeof(T *) * this->chunkSize, chunk->data, sizeof(T *) * this->chunkSize);
            if (pred)
            {
                pred->next = newChunk;
            }
            else
            {
                newSA->firstChunk = newChunk;
            }
            pred = newChunk;
        }
        if (pred)
        {
            pred->next = NULL;
        }
        else
        {
            newSA->firstChunk = NULL;
     

        return newSA;
    }
    void And(SparseArray<T> *this2)
    {
        SAChunk<T> * chunk, *pred = NULL;
        SAChunk<T> * chunk2;
        AssertMsg(this->chunkSize == this2->chunkSize, "Anding incompatible arrays");
        chunk2 = this2->firstChunk;
        for (chunk = this->firstChunk; chunk; chunk = chunk->next)
        {
            while (chunk2 && chunk->startIndex > chunk2->startIndex)
            {
                chunk2 = chunk2->next;
            }
            if (chunk2 == NULL || chunk->startIndex < chunk2->startIndex)
            {
                if (pred)
                {
                    pred->next = chunk->next;
                }
                else
                {
                    this->firstChunk = chunk->next;
                }
                continue;
            }
            AssertMsg(chunk->startIndex == chunk2->startIndex, "Huh??");
            for (int i = 0; i < this->chunkSize; i++)
            {
                if (chunk->data[i])
 
/*
 *  TestHandlerFactory.cpp
 *  Ape
 *
 *  Created by Romko on 5/27/10.
 *  Copyright 2010 Romko Goofique independent. All rights reserved.
 *
 */
APE_EXPORT(TestHandlerFactory, Ape::Web::Test::TestHandlerFactory, Ape::Http::Server::Handling::IHttpHandlerFactory)
namespace Ape {
	namespace Web {
		namespace Test {
			using namespace Ape;
			using namespace Ape::Net;
			using namespace Ape::Http::Server;
			using namespace Ape::Http::Server::Handling;
			
			TestHandlerFactory::TestHandlerFactory() {
				printf("TestHandlerFactory::TestHandlerFactory()\n");
			}
			TestHandlerFactory::~TestHandlerFactory() {}
			
			void TestHandlerFactory::Init(HttpServer* server) {
				printf("TestHandlerFactory::Init(server)\n");
				m_Server = server;
			}
			IHttpHandler* TestHandlerFactory::CreateHandler(HttpWorker* worker) {
				printf("TestHandlerFactory::CreateHandler(worker)\n");
				return new TestHandler(m_Server, worker);
			}
			void TestHandlerFactory::DisposeHandler(IHttpHandler* handl
static const ChunkID pntsChunkID((uint8 *)"PNTS");
PntsChunk::PntsChunk(Chunk *_parent, Chunk *_rootChunk) : Chunk(_parent, _rootChunk, pntsChunkID)
PntsChunk::~PntsChunk()
uint32 PntsChunk::GetLength()
	return(Chunk::GetLength());
void PntsChunk::Encode(uint8 *data)
	return;
void PntsChunk::Decode(const uint8 *data, const uint32 maxLength)
	/* The child factory has already checked that there's enough space for the ID 
	 * and the length.  Now we just need to check that there's actually
	 * enough room for all of the required data.
	 */
	uint32 length;
	length = *((uint32 *)(data + 4)) + 4 + ChunkID::length;
	if(length > maxLength) {
		throw CFE_OutOfData("Data too short while decoding PNTS chunk");
	}
Chunk * PntsChunk::ChildFactory(ChunkID &_id, const uint32 maxLength)
	return(NULL);
ConstelRootChunk::ConstelRootChunk(Chunk *_parent, Chunk *_rootChunk) : Chunk(_parent, _rootChunk, constellationChunkID)
ConstelRootChunk::~ConstelRootChunk()
uint32 ConstelRootChunk::GetLength()
	return
template<typename NodePayLoad, typename EdgePayLoad>
Edge<NodePayLoad, EdgePayLoad>::Edge(Node<NodePayLoad, EdgePayLoad>* vertFrom, Node<NodePayLoad, EdgePayLoad>* vertTo, EdgePayLoad weight) {
	this->vertFrom = vertFrom;
	this->vertTo = vertTo;
	this->weight = weight;
template<typename NodePayLoad, typename EdgePayLoad>
Node<NodePayLoad, EdgePayLoad>* Edge<NodePayLoad, EdgePayLoad>::getVertFrom() const {
	return vertFrom;
template<typename NodePayLoad, typename EdgePayLoad>
Node<NodePayLoad, EdgePayLoad>* Edge<NodePayLoad, EdgePayLoad>::getVertTo() const {
	return vertTo;
template<typename NodePayLoad, typename EdgePayLoad>
EdgePayLoad Edge<NodePayLoad, EdgePayLoad>::getWeight() const {
	return weight;
template<typename NodePayLoad, typename EdgePayLoad>
bool Edge<NodePayLoad, EdgePayLoad>::connects(Node<NodePayLoad, EdgePayLoad>* nodeFirst, Node<NodePayLoad, EdgePayLoad>* nodeSecond) const {
	return ((nodeFirst == this->vertFrom && nodeSecond == this->vertTo) || (nodeFirst == this->v
World::World(int p, int q)
    this->p = p;
    this->q = q;
    
    int r = 1;
    for (int dp = -r; dp <= r; dp++)
    {
        for (int dq = -r; dq <= r; dq++)
        {
            int a = p + dp;
            int b = q + dq;
            Chunk *chunk = 0;/*findChunk(a, b);
            if (chunk) {
                if (chunk->dirty) {
                    genChunkBuffer(chunk);
                }
            }
            else if (chunks->size() < MAX_CHUNKS) */{
                push_back(new Chunk(a, b));
                chunk = (*this)[this->size()-1];
                createChunk(chunk, a, b);
                genChunkBuffer(chunk);
            }
        }
    }
Chunk* World::getChunk(int p, int q)
    return 0;
void World::createChunk(Chunk *chunk, int p, int q)
    initChunk(chunk, p, q);
    
    WorkerItem _item;
    WorkerItem *item = &_item;
    item->p = chunk->p;
    item->q = chunk->q;
    item->block_maps[1][1] = &chunk->map;
    item->light_maps[1][1] = &chunk->lights;
   

    
void World::initChunk(Chunk *chunk, int p, int q)
    chunk->p = p;
    chunk->q = q;
    chunk->faces = 0;
    chunk->sign_faces = 0;
    chunk->buffer = 0;
    chunk->sign_buffer = 0;
    dirtyChunk(chunk);
    int dx = p * CHUNK_SIZE - 1;
    int dy = 0;
    int dz = q * CHUNK_SIZE - 1;
    chunk->lights = Map(dx, dy, dz, 0xf);
void World::dirtyChunk(Chunk *chunk)
    chunk->dirty = 1;
    if (hasLights(chunk)) {
        for (int dp = -1; dp <= 1; dp++) {
            for (int dq = -1; dq <= 1; dq++) {
                Chunk *other = findChunk(chunk->p + dp, chunk->q + dq);
                if (other) {
                    other->dirty = 1;
                }
            }
        }
    }
void World::genChunkBuffer(Chunk *chunk)
    WorkerItem _item;
    WorkerItem *item = &_item;
    item->p = chunk->p;
    item->q = chunk->q;
    for (int dp = -1; dp <= 1; dp++) {
        for (int dq = -1; dq <= 1; dq++) {
            Chunk *other = chunk;
            if (dp || dq) {
           

            }
            if (other) {
                item->block_maps[dp + 1][dq + 1] = &other->map;
                item->light_maps[dp + 1][dq + 1] = &other->lights;
            }
            else {
                item->block_maps[dp + 1][dq + 1] = 0;
                item->light_maps[dp + 1][dq + 1] = 0;
            }
        }
    }
    item->computeChunk(this);
    item->generateChunk(chunk);
    chunk->dirty = 0;
int World::hasLights(Chunk *chunk)
    if (!SHOW_LIGHTS) {
        return 0;
    }
    for (int dp = -1; dp <= 1; dp++) {
        for (int dq = -1; dq <= 1; dq++) {
            Chunk *other = chunk;
            if (dp || dq) {
                other = findChunk(chunk->p + dp, chunk->q + dq);
            }
            if (!other) {
                continue;
            }
            Map *map = &other->lights;
            if (map->size) {
                return 1;
            }
        }
    }
    return 0;
Chunk *World::findChunk(int p, int q)
    for (int i = 0; i < si
class QStandardItem;
class QModelIndex;
class QWidget;
class ServerRepo;
class RepoItem;
class RepoCategoryItem;
class RepoItemDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit RepoItemDelegate(QObject *parent=0);
    void paint(QPainter *painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const;
    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const;
    void showRepoItemToolTip(const RepoItem *item,
                             const QPoint& global_pos,
                             QWidget *viewport,
                             const QRect& rect) const;
private:
    void matchCurrentItem(const QStyleOptionViewItem& option,
                          const ServerRepo& repo) const;
    QStandardItem* getItem(const QModelIndex &index) const;
    void paintRepoItem(QPainter *painter,
                       const QStyleOptionViewItem& opt,
                       cons
class ImR_Locator_ORB_Runner : public ACE_Task_Base
public:
  ImR_Locator_ORB_Runner (ImR_Locator_Loader& service)
    : service_ (service)
  {
  }
  virtual int svc ()
  {
    this->service_.run ();
    return 0;
  }
private:
  ImR_Locator_Loader& service_;
};
ImR_Locator_Loader::ImR_Locator_Loader()
int
ImR_Locator_Loader::init (int argc, ACE_TCHAR *argv[])
  try
    {
      int err = this->opts_.init (argc, argv);
      if (err != 0)
        return -1;
      err = this->service_.init (this->opts_);
      if (err != 0)
        return -1;
      ACE_ASSERT(this->runner_.get () == 0);
      this->runner_.reset(new ImR_Locator_ORB_Runner (*this));
      this->runner_->activate ();
    }
  catch (const CORBA::Exception&)
    {
      return -1;
    }
  return 0;
int
ImR_Locator_Loader::fini (void)
  ACE_ASSERT(this->runner_.get () != 0);
  try
    {
      int ret = this->service_.fini ();
      this->runner_->wait ();
      this->runner_.reset (0);
      return ret;
    }
  catch (const CO
template <typename T>
struct sample_type_traits_base
    typedef T sample_type;
    typedef T* sample_type_pointer;
};
template <typename T>
struct sample_type_traits : public sample_type_traits_base<T>
};
template <>
struct sample_type_traits<char>
    static const sampleType sample_type_enum = CHAR_ST;
};
template <>
struct sample_type_traits<unsigned char>
    static const sampleType sample_type_enum = UCHAR_ST;
};
template <>
struct sample_type_traits<unsigned short>
    static const sampleType sample_type_enum = USHORT_ST;
};
template <>
struct sample_type_traits<short>
    static const sampleType sample_type_enum = SHORT_ST;
};
template <>
struct sample_type_traits<unsigned int>
    static const sampleType sample_type_enum = UINT32_ST;
};
template <>
struct sample_type_traits<int>
    static const sampleType sample_type_enum = INT32_ST;
};
template <>
struct sample_type_traits<float>
    static const sampleType sample_type_enum = FLOAT_ST;
};
template <>
struct sample_type_traits
WorldGenerator::WorldGenerator(void)
WorldGenerator::~WorldGenerator(void)
void WorldGenerator::GenerateChunkData(Chunk& chunk)
	float height[Chunk::WIDTH*Chunk::WIDTH];
	for (int i = 0; i<Chunk::WIDTH*Chunk::WIDTH; i++) height[i] = 3.0f;
	{
		glm::vec2 vecs0 = getVector(SEED, (chunk.chunkCoord.x >> j), (chunk.chunkCoord.y >> j));
		glm::vec2 vecs1 = getVector(SEED, (chunk.chunkCoord.x >> j), (chunk.chunkCoord.y >> j) + 1);
		glm::vec2 vecs2 = getVector(SEED, (chunk.chunkCoord.x >> j) + 1, (chunk.chunkCoord.y >> j));
		glm::vec2 vecs3 = getVector(SEED, (chunk.chunkCoord.x >> j) + 1, (chunk.chunkCoord.y >> j) + 1);
		for (int x = 0;x<Chunk::WIDTH;x++)
		{
			for (int y= 0; y<Chunk::WIDTH;y++)
			{
				float posX = (float)(Chunk::WIDTH * (positiveMod(chunk.chunkCoord.x , noiseScale)) + x)/Chunk::WIDTH/noiseScale;
				float posY = (float)(Chunk::WIDTH * (positiveMod(chunk.chunkCoord.y , noiseScale)) + y)/Chunk::WIDTH/noiseScale;
				float dots0 = posX * vecs0.x + posY * vecs0.y;
				float

				float dots2 = (1.0f - posX) * vecs2.x + posY * vecs2.y;
				float dots3 = (1.0f - posX) * vecs3.x + (1.0f - posY) * vecs3.y;
				float lerp1 = dots0 - (dots0 - dots1) * posY;
				float lerp2 = dots2 - (dots2 - dots3) * posY;
				height[x + y*Chunk::WIDTH] += (j*2 + 1) * (lerp1 - (lerp1 - lerp2)*posX);
			}
		}
	}
	for (int x = 0; x<Chunk::WIDTH; x++)
	{
		for (int y = 0; y<Chunk::WIDTH; y++)
		{
			int h =(int)( 10*height[x + y*Chunk::WIDTH] + 12.0f) - chunk.chunkCoord.z * Chunk::WIDTH;
			for (int z =0; z<Chunk::WIDTH; z++)
			{
				if (z>h && z + chunk.chunkCoord.z == 0)
					chunk.BlockData[chunk.BlockAt(x,y,z)] = WATER;
				else if (z>h)
					chunk.BlockData[chunk.BlockAt(x,y,z)] = AIR;
				else if (z==h)
					chunk.BlockData[chunk.BlockAt(x,y,z)] = GRASS;
				else if (z>h-3)
					chunk.BlockData[chunk.BlockAt(x,y,z)] = DIRT;
				else 
					chunk.BlockData[chunk.BlockAt(x,y,z)] = STONE;
			} 
		}
	}
int WorldGenerator::randNumGen(int baseSeed, int x)
	if (x==0) 
		return baseS
namespace lldb {
class LLDB_API SBAddress;
class LLDB_API SBBlock;
class LLDB_API SBBreakpoint;
class LLDB_API SBBreakpointLocation;
class LLDB_API SBBroadcaster;
class LLDB_API SBCommand;
class LLDB_API SBCommandInterpreter;
class LLDB_API SBCommandInterpreterRunOptions;
class LLDB_API SBCommandPluginInterface;
class LLDB_API SBCommandReturnObject;
class LLDB_API SBCommunication;
class LLDB_API SBCompileUnit;
class LLDB_API SBData;
class LLDB_API SBDebugger;
class LLDB_API SBDeclaration;
class LLDB_API SBError;
class LLDB_API SBEvent;
class LLDB_API SBEventList;
class LLDB_API SBExecutionContext;
class LLDB_API SBExpressionOptions;
class LLDB_API SBFileSpec;
class LLDB_API SBFileSpecList;
class LLDB_API SBFrame;
class LLDB_API SBFunction;
class LLDB_API SBHostOS;
class LLDB_API SBInstruction;
class LLDB_API SBInstructionList;
class LLDB_API SBLanguageRuntime;
class LLDB_API SBLaunchInfo;
class LLDB_API SBLineEntry;
class LLDB_API SBListener;
class LLDB_API SBMemoryRegionInfo;
class LL

class LLDB_API SBModule;
class LLDB_API SBModuleSpec;
class LLDB_API SBModuleSpecList;
class LLDB_API SBProcess;
class LLDB_API SBQueue;
class LLDB_API SBQueueItem;
class LLDB_API SBSection;
class LLDB_API SBSourceManager;
class LLDB_API SBStream;
class LLDB_API SBStringList;
class LLDB_API SBStructuredData;
class LLDB_API SBSymbol;
class LLDB_API SBSymbolContext;
class LLDB_API SBSymbolContextList;
class LLDB_API SBTarget;
class LLDB_API SBThread;
class LLDB_API SBThreadCollection;
class LLDB_API SBThreadPlan;
class LLDB_API SBType;
class LLDB_API SBTypeCategory;
class LLDB_API SBTypeEnumMember;
class LLDB_API SBTypeEnumMemberList;
class LLDB_API SBTypeFilter;
class LLDB_API SBTypeFormat;
class LLDB_API SBTypeMemberFunction;
class LLDB_API SBTypeNameSpecifier;
class LLDB_API SBTypeSummary;
class LLDB_API SBTypeSummaryOptions;
class LLDB_API SBTypeSynthetic;
class LLDB_API SBTypeList;
class LLDB_API SBValue;
class LLDB_API SBValueList;
class LLDB_API SBVariablesOptions;
class LLDB_API
/*========================================================================= 
  Program: Multimod Application Framework RELOADED 
  Module: $RCSfile: vtkMAFCellLocator.h,v $ 
  Language: C++ 
  Date: $Date: 2011-05-26 08:33:31 $ 
  Version: $Revision: 1.1.2.2 $ 
  Authors: Simone Brazzale
  ========================================================================== 
  Copyright (c) 2008 CINECA
  See the COPYINGS file for license details 
  =========================================================================
  vtkMAFCellLocator is equivalent to the standard vtkCellLocator
  but it implements a new function imported from VTK 5.2.
*/
/**
    class name: vtkMAFCellLocator
    Spatial search object to quickly locate cells in 3D.
*/
class VTK_vtkMED_EXPORT vtkMAFCellLocator : public vtkCellLocator
public:
  /** create object  instance. */
  static vtkMAFCellLocator *New();
  /**  RTTI Macro. */
  vtkTypeRevisionMacro(vtkMAFCellLocator, vtkCellLocator);	
public:
  void FindCellsAlongLine(d
/*
** $Id: ldump.cc,v 1.1 2007-01-29 09:58:48 vaiofloh Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConstant

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
using std::stringstream;
using std::string;
using namespace zypp;
static string service = "<repoindex arch=\"i386\" distver=\"11\">"
  "<repo alias=\"company-foo\" name=\"Company's Foo\""
  "      path=\"products/foo\" distro_target=\"sle-%{distver}-%{arch}\" priority=\"20\"/>"
  "<repo alias=\"company-bar\" name=\"Company's Bar\""
  "      path=\"products/bar\" distro_target=\"sle-%{distver}-%{arch}\" enabled=\"tRUe\" autorefresh=\"FaLsE\"/>"
  "<repo alias=\"company-foo-upd\" name=\"Company's Foo Updates\""
  "      path=\"products/foo/updates\" distro_target=\"sle-%{distver}-%{arch}\" priority=\"1\"/>"
  "</repoindex>";
struct RepoCollector : private base::NonCopyable
  bool collect( const RepoInfo &repo )
  {
    repos.push_back(repo);
    return true;
  }
  RepoInfoList repos;
};
BOOST_AUTO_TEST_CASE(read_index_file)
  {
    stringstream input(service);
    RepoCollector collector;
    parser::RepoindexFileReader parser( input, bind( &RepoCollector::collect, &collector, _1 ) );
  
using namespace LibQGit2;
class TestInit : public QObject
    Q_OBJECT
public:
    TestInit();
    ~TestInit();
private slots:
    void initTestCase();
    void init();
    void initBare();
private:
    LibQGit2::Repository *repo;
    const QString repoPath;
};
TestInit::TestInit() :
    repo(0),
    repoPath(QString(VALUE_TO_STR(TEST_DIR)) + "/repo")
void TestInit::initTestCase()
    QVERIFY(!repo);
    repo = new LibQGit2::Repository();
    QVERIFY(repo);
void TestInit::init()
    QVERIFY(removeDir(repoPath));
    QVERIFY(!QDir(repoPath).exists());
    QDir().mkdir(repoPath);
    QVERIFY(QDir(repoPath).exists());
    try {
        repo->init(repoPath, false);
    } catch (const LibQGit2::Exception& ex) {
        QFAIL(ex.what());
    }
    QVERIFY(QDir(repoPath).exists());
    QVERIFY(QFile(repoPath + "/.git").exists());
    QVERIFY(QFile(repoPath + "/.git/HEAD").exists());
void TestInit::initBare()
    QVERIFY(removeDir(repoPath));
    QVERIFY(!QDir(repoPath).exists());
    QDir().m
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
class Listener : public RM::EventsInterface
    Q_DECLARE_TR_FUNCTIONS(RepoManLogger)
public:
    Listener(Log::Channel channel);
    ~Listener();
public:
    void repositoryOpened(RM::Repo* repo);
    void repositoryAboutToClose(RM::Repo* repo);
    void repositoryActivated(RM::Repo* repo);
    void repo

    void objectCreated(RM::Repo* repo, RM::Base* object);
    void objectAboutToBeDeleted(RM::Repo* repo, RM::Base* object);
    void refTreeNodeCreated(RM::Repo* repo, RM::RefTreeNode* node);
    void refTreeNodeAboutToBeDeleted(RM::Repo* repo, RM::RefTreeNode* node);
    void refCreated(RM::Repo* repo, RM::Ref* ref);
    void refAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref);
    void refMoved(RM::Repo* repo, RM::Ref* ref);
    void refHeadDetached(RM::Repo* repo, RM::Ref* ref);
    void tagCreated(RM::Repo* repo, RM::Tag* tag);
    void tagAboutToBeDeleted(RM::Repo* repo, RM::Tag* tag);
    void branchCreated(RM::Repo* repo, RM::Branch* branch);
    void branchAboutToBeDeleted(RM::Repo* repo, RM::Branch* branch);
    void branchMoved(RM::Repo* repo, RM::Branch* branch);
    void branchUpstreamChanged(RM::Repo* repo, RM::Branch* branch);
    void namespaceCreated(RM::Repo* repo, RM::Namespace* nameSpace);
    void namespaceAboutToBeDeleted(RM::Repo* repo, RM::Namespace* nameSpace);

/*
** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConsta

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
poly::poly(){
	a=0;
	x=0;
	void display(poly* sample ){
	for (int i=0;i<MAX;i++){
		std::cout<<"a:"<<sample[i].a<<"   "<<"x:"<<sample[i].x<<std::endl;
	}
	}
	void set(poly* poly_s,int x,double a){
		poly_s->a=a;
		poly_s->x=x;
	}
	poly* search(poly* sample,int x)
	{
		for(int i=0;i<=MAX;i++)
		{
			if (sample[i].x==x)
				return sample+i;
		}
		return NULL;
	}
	void insert(poly* sample,int x,double a){
		for (int i = 0; i < MAX; i++)
			if ((sample+i)->a==0){
				(sample+i)->a=a;
				(sample+i)->x=x;
				break;
			}
	}
	void godie(poly*sample,int x){
		poly *index;
		do{
			index=search(sample,x);
			for(int i=0;(index-sample+i)<=MAX;i++)
			{
				if (!index) break;
				if((index-sample+i+1)==MAX)
					{index[i].a=0;
					index[i].x=0;
					break;
					}
				index[i].a=index[i+1].a;
				index[i].x=index[i+1].x;
			}
		}while(index!=NULL);
	}
	void change(poly*  sample,int x,double a)
	{
		search(sample,x)->a=a;
	}
	void sort(poly* sample)
	{
		double a;int x;
		for (int i = 0; i < MAX-
/*
** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;
static void error(LoadState* S, const char* why)
 luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
 luaD_throw(S->L,LUA_ERRSYNTAX);
static void LoadBlock(LoadState* S, void* b, size_t size)
 size_t r=luaZ_read(S->Z,b,size);
 IF (r!=0, "unexpected end");
static int LoadChar(LoadState* S)
 char x;
 LoadVar(S,x);
 return x;
static int LoadInt(LoadState* S)
 int x;
 LoadVar(S,x);
 IF (x<0, "bad integer");
 return x;
static lua_Number LoadNumber(LoadState* S)
 lua_Number x;
 LoadVar(S,x);
 return x;
static TString* LoadString(LoadState* S)
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S->L,S->b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
 }
static void LoadCode

 int n=LoadInt(S);
 f->code=luaM_newvector(S->L,n,Instruction);
 f->sizecode=n;
 LoadVector(S,f->code,n,sizeof(Instruction));
static Proto* LoadFunction(LoadState* S, TString* p);
static void LoadConstants(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->k=luaM_newvector(S->L,n,TValue);
 f->sizek=n;
 for (i=0; i<n; i++) setnilvalue(&f->k[i]);
 for (i=0; i<n; i++)
 {
  TValue* o=&f->k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S)!=0);
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S->L,o,LoadString(S));
	break;
   default:
	error(S,"bad constant");
	break;
  }
 }
 n=LoadInt(S);
 f->p=luaM_newvector(S->L,n,Proto*);
 f->sizep=n;
 for (i=0; i<n; i++) f->p[i]=NULL;
 for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
static void LoadDebug(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->lineinfo=luaM_newvector(S->L,n,int);
 f->sizelinei

 LoadVector(S,f->lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f->locvars=luaM_newvector(S->L,n,LocVar);
 f->sizelocvars=n;
 for (i=0; i<n; i++) f->locvars[i].varname=NULL;
 for (i=0; i<n; i++)
 {
  f->locvars[i].varname=LoadString(S);
  f->locvars[i].startpc=LoadInt(S);
  f->locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f->upvalues=luaM_newvector(S->L,n,TString*);
 f->sizeupvalues=n;
 for (i=0; i<n; i++) f->upvalues[i]=NULL;
 for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
static Proto* LoadFunction(LoadState* S, TString* p)
 Proto* f;
 if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,"code too deep");
 f=luaF_newproto(S->L);
 setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
 f->source=LoadString(S); if (f->source==NULL) f->source=p;
 f->linedefined=LoadInt(S);
 f->lastlinedefined=LoadInt(S);
 f->nups=LoadByte(S);
 f->numparams=LoadByte(S);
 f->is_vararg=LoadByte(S);
 f->maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), "bad code");
 

 S->L->nCcalls--;
 return f;
static void LoadHeader(LoadState* S)
 char h[LUAC_HEADERSIZE];
 char s[LUAC_HEADERSIZE];
 luaU_header(h);
 LoadBlock(S,s,LUAC_HEADERSIZE);
 IF (memcmp(h,s,LUAC_HEADERSIZE)!=0, "bad header");
/*
** load precompiled chunk
*/
Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
 LoadState S;
 if (*name=='@' || *name=='=')
  S.name=name+1;
 else if (*name==LUA_SIGNATURE[0])
  S.name="binary string";
 else
  S.name=name;
 S.L=L;
 S.Z=Z;
 S.b=buff;
 LoadHeader(&S);
 return LoadFunction(&S,luaS_newliteral(L,"=?"));
 luaO_pushfstring(L, "%s: precompiled chunk", S.name);
 luaD_throw(L, LUA_ERRSYNTAX);
 return 0;
/*
* make header
*/
void luaU_header (char* h)
 int x=1;
 memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);
 h+=sizeof(LUA_SIGNATURE)-1;
 *h++=(char)LUAC_VERSION;
 *h++=(char)LUAC_FORMAT;
 *h++=(char)*(char*)&x;				/* endianness */
 *h++=(char)sizeof(int);
 *h++=(char)sizeof(size_t);
 *h++=(char)sizeof(Instruction);
 *h++=(char)sizeof(l
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_ALLOW_POPUPS | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags
 *
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType
  LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_NORMAL_RE

  LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
  LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_NORMAL_ALLOW_MIXED_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_ALLOW_MIXED_CONTENT | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_

  LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_RELOAD_ALLOW_MIXED_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_ALLOW_MIXED_CONTENT | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
  LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
  LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
  LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
  LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
  LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAG

  LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
  LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_FLAGS_NONE),
  LOAD_REPLACE_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
  /**
   * Load type for an error page. These loads are never triggered by users of
   * Docshell. Instead, Docshell triggers the load itself when a
   * consumer-triggered load failed.
   */
  LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL,
                                   LOAD_FLAGS_ERROR_PAGE)
};
static inline bool
IsValidLoadType(uint32_t aLoadType)
  switch (aLoadType) {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LO
namespace fcgid { namespace details {
standard_handler::standard_handler() :
	mask_(http_method_mask::none), handler_()
standard_handler::~standard_handler() {
standard_handler::standard_handler(standard_handler const &other) :
	mask_(other.mask_), handler_(other.handler_)
standard_handler&
standard_handler::operator = (standard_handler const &other) {
	standard_handler copy(other);
	swap(copy);
	return *this;
void
standard_handler::swap(standard_handler &other) throw () {
	using std::swap;
	swap(mask_, other.mask_);
	swap(handler_, other.handler_);
standard_handler::standard_handler(boost::shared_ptr<request_handler> const &handler, http_method_mask const &m) :
	mask_(m), handler_(handler)
void
standard_handler::handle(boost::shared_ptr<standard_handler::context_type> ctx, logger &log) const {
	handler_->handle_request(ctx->request(), ctx->response(), log);
standard_handler::operator standard_handler::bool_convertible const* () const {
	return handler_ ? reinterpret_cast<bool_converti
void doDalitzAcc(Int_t seed = 9){
   gSystem->Load("libPhysics.so");
   gSystem->Load("libRooFit.so");
  gROOT->LoadMacro("twoDStyle.C");
  gROOT->LoadMacro("histoUtils.C");
  twoDStyle();
  gROOT->LoadMacro("AbsComplexBrackets.C+");
  gROOT->LoadMacro("AbsComplex.C+");
  gROOT->LoadMacro("AbsComplexPdf.C+");
  gROOT->LoadMacro("dataThrowerAway.C+");
  gROOT->LoadMacro("ComplexProxy.C+");
  gROOT->LoadMacro("ComplexBW.C+");
  gROOT->LoadMacro("DcyAmplitude.C+");
  gROOT->LoadMacro("DcyGSAmplitude.C+");
  gROOT->LoadMacro("DcyNonRes.C+");
  gROOT->LoadMacro("DbleAmplitude.C+");
  gROOT->LoadMacro("Resonance.C+");
  gROOT->LoadMacro("ComplexSum.C+");
  gROOT->LoadMacro("ComplexProd.C+");
  gROOT->LoadMacro("RooAbsPhaseSpace.C+");
  gROOT->LoadMacro("Roo3BodyPhaseSpaceAcc.C+");
  gROOT->LoadMacro("Calculate4BodyProps.h+");
  gROOT->LoadMacro("SpinFactorThreeBody.C+");
  gROOT->LoadMacro("SpinFactor.C+");
  gROOT->LoadMacro("SpinFactors.C+");
  gROOT->LoadMacro("BlattWeisskopf.C+");
  gROO
using namespace Myway;
VertexStream::VertexStream()
    Memzero(mInstances, sizeof(int) * MAX_VERTEX_STREAM);
	mStart = 0;
	mCount = 0;
VertexStream::~VertexStream()
void VertexStream::SetDeclaration(VertexDeclarationPtr decl)
    mDeclaration = decl;
VertexDeclarationPtr VertexStream::GetDeclaration() const
    return mDeclaration;
void VertexStream::Bind(int number, VertexBufferPtr stream, int unused, int instance)
    assert (number < MAX_VERTEX_STREAM);
    mStreams[number] = stream;
	mInstances[number] = instance;
VertexBufferPtr VertexStream::GetStream(int index) const
    return mStreams[index];
int VertexStream::GetStreamInstance(int index) const
	return mInstances[index];
void VertexStream::SetCount(int size)
    mCount = size;
int VertexStream::GetCount() const
    return mCount;
VertexStream::VertexStream(const VertexStream & r)
    *this = r;
VertexStream & VertexStream::operator =(const VertexStream & r)
	mStart = r.GetStart();
    mCount = r.GetCount();
    mDeclaration =
/*
** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConsta

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
/*
 * $Id$
 *
 *
 * Distributed under the OpenDDS License.
 */
namespace OpenDDS {
namespace DCPS {
ACE_INLINE
WriterDataSampleList::WriterDataSampleList()
  : head_(0),
    tail_(0),
    size_(0)
ACE_INLINE
void WriterDataSampleList::reset()
  head_ = tail_ = 0;
  size_ = 0;
ACE_INLINE
ssize_t
WriterDataSampleList::size() const
  return size_;
ACE_INLINE
DataSampleElement*
WriterDataSampleList::head() const
  return head_;
ACE_INLINE
DataSampleElement*
WriterDataSampleList::tail() const
  return tail_;
ACE_INLINE
void
WriterDataSampleList::enqueue_tail(const DataSampleElement* sample)
  DataSampleElement* mSample = const_cast<DataSampleElement*>(sample);
  
  ++size_ ;
  if (head_ == 0) {
    head_ = tail_ = mSample ;
  } else {
    tail_->next_writer_sample_ = mSample ;
    mSample->previous_writer_sample_ = tail_;
    tail_ = mSample;
  }
ACE_INLINE
bool
WriterDataSampleList::dequeue_head(DataSampleElement*& stale)
  stale = head_;
  if (head_ == 0) {
    return false;
  } else {
  
int testSoundGenerator() {
    SoundGenerator  *test = new SoundGenerator();
    BitRep          *sample = new BitRep(6,10);
    int             key;
    test->init();
    sample->setBit(0,0,true);
    sample->setBit(1,0,false);
    sample->setBit(2,0,false);
    sample->setBit(3,0,false);
    sample->setBit(4,0,false);
    sample->setBit(5,0,false);
    sample->setBit(6,0,false);
    sample->setBit(7,0,false);
    sample->setBit(8,0,true);
    sample->setBit(9,0,false);
    sample->setBit(0,1,true);
    sample->setBit(1,1,false);
    sample->setBit(2,1,false);
    sample->setBit(3,1,false);
    sample->setBit(4,1,false);
    sample->setBit(5,1,false);
    sample->setBit(6,1,false);
    sample->setBit(7,1,true);
    sample->setBit(8,1,false);
    sample->setBit(9,1,false);
    sample->setBit(0,2,true);
    sample->setBit(1,2,false);
    sample->setBit(2,2,false);
    sample->setBit(3,2,false);
    sample->setBit(4,2,false);
    sample->setBit(5,2,false);
    sample->setBit(6,2,true);
 

    sample->setBit(8,2,false);
    sample->setBit(9,2,false);
    sample->setBit(0,3,true);
    sample->setBit(1,3,false);
    sample->setBit(2,3,false);
    sample->setBit(3,3,false);
    sample->setBit(4,3,false);
    sample->setBit(5,3,true);
    sample->setBit(6,3,false);
    sample->setBit(7,3,false);
    sample->setBit(8,3,false);
    sample->setBit(9,3,false);
    sample->setBit(0,4,false);
    sample->setBit(1,4,true);
    sample->setBit(2,4,false);
    sample->setBit(3,4,false);
    sample->setBit(4,4,true);
    sample->setBit(5,4,false);
    sample->setBit(6,4,false);
    sample->setBit(7,4,false);
    sample->setBit(8,4,false);
    sample->setBit(9,4,false);
    sample->setBit(0,5,false);
    sample->setBit(1,5,false);
    sample->setBit(2,5,true);
    sample->setBit(3,5,true);
    sample->setBit(4,5,false);
    sample->setBit(5,5,false);
    sample->setBit(6,5,false);
    sample->setBit(7,5,false);
    sample->setBit(8,5,false);
    sample->setBit(9,5,false);
    printf("=
/*
** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;
static void error(LoadState* S, const char* why)
 luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
 luaD_throw(S->L,LUA_ERRSYNTAX);
static void LoadBlock(LoadState* S, void* b, size_t size)
 size_t r=luaZ_read(S->Z,b,size);
 IF (r!=0, "unexpected end");
static int LoadChar(LoadState* S)
 char x;
 LoadVar(S,x);
 return x;
static int LoadInt(LoadState* S)
 int x;
 LoadVar(S,x);
 IF (x<0, "bad integer");
 return x;
static lua_Number LoadNumber(LoadState* S)
 lua_Number x;
 LoadVar(S,x);
 return x;
static TString* LoadString(LoadState* S)
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S->L,S->b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
 }
static void LoadCode

 int n=LoadInt(S);
 f->code=luaM_newvector(S->L,n,Instruction);
 f->sizecode=n;
 LoadVector(S,f->code,n,sizeof(Instruction));
static Proto* LoadFunction(LoadState* S, TString* p);
static void LoadConstants(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->k=luaM_newvector(S->L,n,TValue);
 f->sizek=n;
 for (i=0; i<n; i++) setnilvalue(&f->k[i]);
 for (i=0; i<n; i++)
 {
  TValue* o=&f->k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S)!=0);
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S->L,o,LoadString(S));
	break;
   default:
	error(S,"bad constant");
	break;
  }
 }
 n=LoadInt(S);
 f->p=luaM_newvector(S->L,n,Proto*);
 f->sizep=n;
 for (i=0; i<n; i++) f->p[i]=NULL;
 for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
static void LoadDebug(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->lineinfo=luaM_newvector(S->L,n,int);
 f->sizelinei

 LoadVector(S,f->lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f->locvars=luaM_newvector(S->L,n,LocVar);
 f->sizelocvars=n;
 for (i=0; i<n; i++) f->locvars[i].varname=NULL;
 for (i=0; i<n; i++)
 {
  f->locvars[i].varname=LoadString(S);
  f->locvars[i].startpc=LoadInt(S);
  f->locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f->upvalues=luaM_newvector(S->L,n,TString*);
 f->sizeupvalues=n;
 for (i=0; i<n; i++) f->upvalues[i]=NULL;
 for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
static Proto* LoadFunction(LoadState* S, TString* p)
 Proto* f;
 if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,"code too deep");
 f=luaF_newproto(S->L);
 setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
 f->source=LoadString(S); if (f->source==NULL) f->source=p;
 f->linedefined=LoadInt(S);
 f->lastlinedefined=LoadInt(S);
 f->nups=LoadByte(S);
 f->numparams=LoadByte(S);
 f->is_vararg=LoadByte(S);
 f->maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), "bad code");
 

 S->L->nCcalls--;
 return f;
static void LoadHeader(LoadState* S)
 char h[LUAC_HEADERSIZE];
 char s[LUAC_HEADERSIZE];
 luaU_header(h);
 LoadBlock(S,s,LUAC_HEADERSIZE);
 IF (memcmp(h,s,LUAC_HEADERSIZE)!=0, "bad header");
/*
** load precompiled chunk
*/
Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
 LoadState S;
 if (*name=='@' || *name=='=')
  S.name=name+1;
 else if (*name==LUA_SIGNATURE[0])
  S.name="binary string";
 else
  S.name=name;
 S.L=L;
 S.Z=Z;
 S.b=buff;
 LoadHeader(&S);
 return LoadFunction(&S,luaS_newliteral(L,"=?"));
 luaO_pushfstring(L, "%s: precompiled chunk", S.name);
 luaD_throw(L, LUA_ERRSYNTAX);
 return 0;
/*
* make header
*/
void luaU_header (char* h)
 int x=1;
 memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);
 h+=sizeof(LUA_SIGNATURE)-1;
 *h++=(char)LUAC_VERSION;
 *h++=(char)LUAC_FORMAT;
 *h++=(char)*(char*)&x;				/* endianness */
 *h++=(char)sizeof(int);
 *h++=(char)sizeof(size_t);
 *h++=(char)sizeof(Instruction);
 *h++=(char)sizeof(l
extern "C" {
struct my_c_api;
typedef int(*callback)(void*, my_c_api*);
struct my_c_api {
    int x;
    void* data;
    callback cb;
};
void init_api(my_c_api* api) {
    api->x = 10;
    api->data = 0;
    api->cb = 0;
void add_callback(my_c_api* api, callback c, void* data) {
    api->cb = c;
    api->data = data;
void delete_callback(my_c_api* api, callback c, void* data) {
    if(api->cb == c && api->data == data) {
        api->cb = 0;
        api->data = 0;
    }
void do_api_stuff(my_c_api* api) {
    if(api && api->cb) {
        api->x = api->cb(api->data, api);
    }
template<typename T>
int do_callback(void* data, my_c_api* api) {
    auto* ptr = static_cast<T*>(data);
    return (*ptr)(*api);
template<typename Function>
void modern_callback(my_c_api* api, const Function& f) {
    add_callback(api, do_callback<Function>, static_cast<void*>(const_cast<Function*>(&f)));
template<typename Function>
void remove_callback(my_c_api* api, const Function& f) {
    delete_callback(api,
namespace SpacialLocation
	void WiiSpacialLocator::Process()
	{
		if (!m_wiimoteCollection) throw "You must call SetWiimoteHid before anything else!";
		
		FindWiimotes();
		m_wiimoteCollection->Process();
	}
	void WiiSpacialLocator::FindWiimotes()
	{
		m_wiimoteCollection->FindAllWiimotes();
		
		size_t i = 0;
		while(WiimoteDriver::Wiimote* wiimote = m_wiimoteCollection->GetNextWiimote(i))
		{
			m_wiimotes[wiimote->GetUid()] = wiimote;
		}
	}
	float WiiSpacialLocator::GetPitch()
	{
		if (m_wiimotes.empty()) return 0.0f;
		
		WiimoteDriver::Wiimote& wiimote = *m_wiimotes.begin()->second;
		
		return ((float)(384 - wiimote.GetDots()[0].y) * -22.5f) / 384.0f;
	}
	float WiiSpacialLocator::GetYaw()
	{
		if (m_wiimotes.empty()) return 0.0f;
		
		WiimoteDriver::Wiimote& wiimote = *m_wiimotes.begin()->second;
		
		return ((float)(512 - wiimote.GetDots()[0].x) * 22.5f) / 512.0f;
	}
	float WiiSpacialLocator::GetRoll()
	{
		return 0;
	}
	WiiSpacialLocator& WiiSpacialLocator::operator=(const Wi

	{
		return *new WiiSpacialLocator(m_wiimoteCollection);
	}
	void WiiSpacialLocator::UpPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::LeftPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::RightPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::DownPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::APressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::BPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::PlusPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::MinusPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::HomePressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::OnePressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::TwoPressed(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::UpReleased(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::LeftReleased(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::RightReleased(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::DownReleased(size_t /*id*/)
	{
		
	}
	void WiiSpacialLocator::ARel
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/**
 * Copyright (c) 2014,  Regents of the University of California.
 *
 * This file is part of NDN repo-ng (Next generation of NDN repository).
 * See AUTHORS.md for complete list of repo-ng authors and contributors.
 *
 * repo-ng is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * repo-ng is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 */
namespace repo {
namespace tests {
class RepoStorageFixture
public:
  RepoStorageFixture()
    : store(make_shared<SqliteStorage>("unittestdb
asm (".text");
__handler__(0);
__handler__(1);
__handler__(2);
__handler__(3);
__handler__(4);
__handler__(5);
__handler__(6);
__handler__(7);
__handler__(9);
__handler_error__(8);
__handler_error__(10);
__handler_error__(11);
__handler_error__(12);
__handler_error__(13);
__handler_error__(14);
/* __handler__(8); */
/* __handler__(10); */
/* __handler__(11); */
/* __handler__(12); */
/* __handler__(13); */
/* __handler__(14); */
__handler__(15);
__handler__(16);
__handler__(17);
__handler__(18);
__handler__(19);
__handler__(20);
__handler__(21);
__handler__(22);
__handler__(23);
__handler__(24);
__handler__(25);
__handler__(26);
__handler__(27);
__handler__(28);
__handler__(29);
__handler__(30);
__handler__(31);
/* __handler_irq__(32); */
/* __handler_irq__(33); */
/* __handler_irq__(34); */
/* __handler_irq__(35); */
/* __handler_irq__(36); */
/* __handler_irq__(37); */
/* __handler_irq__(38); */
/* __handler_irq__(39); */
/* __handler_irq__(40); */
/* __handler_irq__(41); */
/* __han

/* __handler_irq__(43); */
/* __handler_irq__(44); */
/* __handler_irq__(45); */
/* __handler_irq__(46); */
/* __handler_irq__(47); */
__handler__(32);
__handler__(33);
__handler__(34);
__handler__(35);
__handler__(36);
__handler__(37);
__handler__(38);
__handler__(39);
__handler__(40);
__handler__(41);
__handler__(42);
__handler__(43);
__handler__(44);
__handler__(45);
__handler__(46);
__handler__(47);
__handler__(48);
__handler__(49);
__handler__(50);
__handler__(51);
__handler__(52);
__handler__(53);
__handler__(54);
__handler__(55);
__handler__(56);
__handler__(57);
__handler__(58);
__handler__(59);
__handler__(60);
__handler__(61);
__handler__(62);
__handler__(63);
__handler__(64);
__handler__(65);
__handler__(66);
__handler__(67);
__handler__(68);
__handler__(69);
__handler__(70);
__handler__(71);
__handler__(72);
__handler__(73);
__handler__(74);
__handler__(75);
__handler__(76);
__handler__(77);
__handler__(78);
__handler__(79);
__handler__(80);
__handler__(81);
__handler__(82

__handler__(83);
__handler__(84);
__handler__(85);
__handler__(86);
__handler__(87);
__handler__(88);
__handler__(89);
__handler__(90);
__handler__(91);
__handler__(92);
__handler__(93);
__handler__(94);
__handler__(95);
__handler__(96);
__handler__(97);
__handler__(98);
__handler__(99);
__handler__(100);
__handler__(101);
__handler__(102);
__handler__(103);
__handler__(104);
__handler__(105);
__handler__(106);
__handler__(107);
__handler__(108);
__handler__(109);
__handler__(110);
__handler__(111);
__handler__(112);
__handler__(113);
__handler__(114);
__handler__(115);
__handler__(116);
__handler__(117);
__handler__(118);
__handler__(119);
__handler__(120);
__handler__(121);
__handler__(122);
__handler__(123);
__handler__(124);
__handler__(125);
__handler__(126);
__handler__(127);
__handler__(128);
__handler__(129);
__handler__(130);
__handler__(131);
__handler__(132);
__handler__(133);
__handler__(134);
__handler__(135);
__handler__(136);
__handler__(137);
__handler__(138);
__handle

__handler__(140);
__handler__(141);
__handler__(142);
__handler__(143);
__handler__(144);
__handler__(145);
__handler__(146);
__handler__(147);
__handler__(148);
__handler__(149);
__handler__(150);
__handler__(151);
__handler__(152);
__handler__(153);
__handler__(154);
__handler__(155);
__handler__(156);
__handler__(157);
__handler__(158);
__handler__(159);
__handler__(160);
__handler__(161);
__handler__(162);
__handler__(163);
__handler__(164);
__handler__(165);
__handler__(166);
__handler__(167);
__handler__(168);
__handler__(169);
__handler__(170);
__handler__(171);
__handler__(172);
__handler__(173);
__handler__(174);
__handler__(175);
__handler__(176);
__handler__(177);
__handler__(178);
__handler__(179);
__handler__(180);
__handler__(181);
__handler__(182);
__handler__(183);
__handler__(184);
__handler__(185);
__handler__(186);
__handler__(187);
__handler__(188);
__handler__(189);
__handler__(190);
__handler__(191);
__handler__(192);
__handler__(193);
__handler__(194);
__handler

__handler__(196);
__handler__(197);
__handler__(198);
__handler__(199);
__handler__(200);
__handler__(201);
__handler__(202);
__handler__(203);
__handler__(204);
__handler__(205);
__handler__(206);
__handler__(207);
__handler__(208);
__handler__(209);
__handler__(210);
__handler__(211);
__handler__(212);
__handler__(213);
__handler__(214);
__handler__(215);
__handler__(216);
__handler__(217);
__handler__(218);
__handler__(219);
__handler__(220);
__handler__(221);
__handler__(222);
__handler__(223);
__handler__(224);
__handler__(225);
__handler__(226);
__handler__(227);
__handler__(228);
__handler__(229);
__handler__(230);
__handler__(231);
__handler__(232);
__handler__(233);
__handler__(234);
__handler__(235);
__handler__(236);
__handler__(237);
__handler__(238);
__handler__(239);
__handler__(240);
__handler__(241);
__handler__(242);
__handler__(243);
__handler__(244);
__handler__(245);
__handler__(246);
__handler__(247);
__handler__(248);
__handler__(249);
__handler__(250);
__handler
/*
 * ModelManager.cpp
 *
 *  Created on: Jan 17, 2013
 *      Author: cws
 */
ModelManager::ModelManager() {
void ModelManager::addTimeUpdater(TimeUpdater* timeUpdater) {
	_timeUpdaters.push_back(timeUpdater);
void ModelManager::addTimeModel(TimeModel* timeModel) {
	_timeModels.push_back(timeModel);
void ModelManager::addChangeModel(TimeModel* timeModel,
		ChangeModel* changeModel) {
	_timeModelChangeModelMap[timeModel].push_back(changeModel);
void ModelManager::addUpdater(ChangeModel* changeModel, Updater* updater) {
	_changeModelChangeUpdaterMap[changeModel].push_back(updater);
std::vector<TimeModel*> * ModelManager::getTimeModels() {
	return &_timeModels;
std::vector<TimeUpdater*> * ModelManager::getTimeUpdater() {
	return &_timeUpdaters;
std::vector<ChangeModel*> * ModelManager::getChangeModels(TimeModel* timeModel) {
	return &_timeModelChangeModelMap[timeModel];
std::vector<ChangeModel*> * ModelManager::getChangeModels(
		std::set<TimeModel*> timeModels) {
	std::vector<ChangeMode
namespace glm
	namespace virtrev_glmext
	{
		namespace xstream
		{
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec2<T> const & vec)
			{
				stream << "<glm_vec2 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec3<T> const & vec)
			{
				stream << "<glm_vec3 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec4<T> const & vec)
			{
				stream << "<glm_vec4 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "w=\"" << vec.w << "\" ";
				stream << "/>";
				return stream;
			}
			

			std::ostream & operator << (std::ostream & stream, glm::detail::tmat2x2<T> const & mat)
			{
				stream << "<glm_mat2>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat2>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat3x3<T> const & mat)
			{
				stream << "<glm_mat3>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << g

				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 2)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 2)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 2)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat3>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat4x4<T> const & mat)
			{
				stream << "<glm_mat4>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "w=\"" << glm::row(mat, 0)[3] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "w=\"" <<
const Chunk& WorldData::getChunk( int x, int y ) const {
    return chunks[x + xOffset][ y + yOffset];
const Tile& WorldData::getTile( int x, int y ) const {
    const Chunk& chunk = getChunk( 
		    (int) floor( ((float) x) / CHUNK_SIDE ),
            (int) floor( ((float) y) / CHUNK_SIDE ) );
    return chunk.getAbsoluteTile(x, y);
const Tile& WorldData::getTile( sf::Vector2i in ) const {
    return getTile( in.x, in.y );
void WorldData::digTile( int x, int y, Player& player ) {
    int chunksX = (int) floor( ((float) x) / CHUNK_SIDE );
    int chunksY = (int) floor( ((float) y) / CHUNK_SIDE );
    chunks[chunksX + xOffset][ chunksY + yOffset]
            .digAbsoluteTile( x, y, player );
WorldData::WorldData(void) {
    xOffset = 10;
    yOffset = 10;
    for( int i = 0; i < 20; i++ ) {
        for( int j = 0; j < 10; j++ ) {
            chunks[i][j] = Chunk::Chunk( 
                    sf::Vector2i( ( i - xOffset ) * CHUNK_SIDE, 
            chunks[i][j+10] = Chunk::Chunk( 
       
namespace media {
namespace mp4 {
namespace {
const SampleToGroupEntry kCompactSampleToGroupTable[] =
    {{10, 8}, {9, 5}, {25, 7}, {48, 63}, {8, 2}};
class SampleToGroupIteratorTest : public testing::Test {
 public:
  SampleToGroupIteratorTest() {
    for (size_t i = 0; i < arraysize(kCompactSampleToGroupTable); ++i) {
      for (uint32_t j = 0; j < kCompactSampleToGroupTable[i].sample_count;
           ++j) {
        sample_to_group_table_.push_back(
            kCompactSampleToGroupTable[i].group_description_index);
      }
    }
    sample_to_group_.entries.assign(
        kCompactSampleToGroupTable,
        kCompactSampleToGroupTable + arraysize(kCompactSampleToGroupTable));
    sample_to_group_iterator_.reset(
        new SampleToGroupIterator(sample_to_group_));
  }
 protected:
  std::vector<uint32_t> sample_to_group_table_;
  SampleToGroup sample_to_group_;
  std::unique_ptr<SampleToGroupIterator> sample_to_group_iterator_;
 private:
  DISALLOW_COPY_AND_ASSIGN(SampleToGroupIte
/*
    _____               __  ___          __            ____        _      __
   / ___/__ ___ _  ___ /  |/  /__  ___  / /_____ __ __/ __/_______(_)__  / /_
                                               /___/             /_/
                                             
  See Copyright Notice in gmMachine.h
*/
gmMemChain::gmMemChain(unsigned int a_elementSize, unsigned int a_numElementsInChunk)
  m_chunkSize = a_numElementsInChunk * a_elementSize;
  m_elementSize = a_elementSize;
  m_rootChunk = NULL;
  m_currentChunk = NULL;
gmMemChain::~gmMemChain()
  FreeChunks();
void gmMemChain::FreeChunks()
  if(m_rootChunk)
  {
    MemChunk *curChunk;
    curChunk = m_rootChunk;
    while(curChunk)
    {
      MemChunk *chunkToFree;
      
      chunkToFree = curChunk;
      curChunk = curChunk->m_nextChunk;
      
      delete [] (char*)chunkToFree;
    }
  }
void gmMemChain::ResetAndFreeMemory()
  FreeChunks();
  m_rootChunk = NULL;
  m_currentChunk = NULL;
void gmMemChain::Presize(int a_kby

  int numChunks = ((a_kbytes + 1) * 1024) / m_chunkSize;
  MemChunk *curChunk;
  curChunk = m_rootChunk;
  while(curChunk)
  {
    --numChunks;
    curChunk = curChunk->m_nextChunk;
  }
  MemChunk * currentChunk = m_currentChunk;
  while(numChunks > 0)
  {
    NewChunk();
    --numChunks;
  }
  if(currentChunk)
  {
    m_currentChunk = currentChunk;
  }
gmMemChain::MemChunk* gmMemChain::NewChunk()
  MemChunk* newChunk;
  if(m_currentChunk && m_currentChunk->m_nextChunk)
  {
    newChunk = m_currentChunk->m_nextChunk;
    newChunk->m_curAddress = newChunk->m_minAddress;    
    m_currentChunk = newChunk;
  }
  {
    char * mem = (char *) GM_NEW( char[sizeof(MemChunk) + m_chunkSize] );
    newChunk = (MemChunk *) mem;
  
    newChunk->m_minAddress = mem + sizeof(MemChunk);
    newChunk->m_lastAddress = (void*)((unsigned int)newChunk->m_minAddress + m_chunkSize);
    newChunk->m_curAddress = newChunk->m_minAddress;
    newChunk->m_lastChunk = m_currentChunk;
    newChunk->m_nextChunk = N

    if(m_currentChunk)
    {
      m_currentChunk->m_nextChunk = newChunk;
    }
    m_currentChunk = newChunk;
    if(!m_rootChunk)
    {
      m_rootChunk = m_currentChunk;
    }
  }
  return newChunk;
void* gmMemChain::Alloc()
  void *retPtr;
  
  if(!m_rootChunk)
  {
    NewChunk();
  }
  if(((gmuptr)m_currentChunk->m_curAddress + m_elementSize) > (gmuptr)m_currentChunk->m_lastAddress)
  {
    NewChunk();    
  }
  retPtr = m_currentChunk->m_curAddress;
  m_currentChunk->m_curAddress = (void*)((gmuptr)m_currentChunk->m_curAddress + m_elementSize);
  return retPtr;
void* gmMemChain::AllocBytes(unsigned int a_numBytes, unsigned int a_alignNumBytes)
  void *retPtr;
  
  if(!m_rootChunk)
  {
    NewChunk();
  }
  retPtr = _gmAlignMem(m_currentChunk->m_curAddress, a_alignNumBytes);
  if(((gmuptr)retPtr + a_numBytes) > (gmuptr)m_currentChunk->m_lastAddress)
  {
    NewChunk();    
    
    retPtr = _gmAlignMem(m_currentChunk->m_curAddress, a_alignNumBytes);
  }
  
  m_currentChunk->m_cu
namespace TAO
  namespace DCPS
  {
    ACE_INLINE
    DataSampleListElement::DataSampleListElement (
      PublicationId           publication_id,
      TransportSendListener*  send_listner,
      PublicationInstance*    handle,
      TransportSendElementAllocator* allocator)
      : sample_ (0),
        publication_id_ (publication_id), 
        group_id_ (0),
        previous_sample_ (0),
        next_sample_ (0),
        next_instance_sample_ (0),
        next_send_sample_ (0),
        send_listener_ (send_listner),
        space_available_ (false),
        handle_(handle),
        transport_send_element_allocator_(allocator)
    {
    }
    ACE_INLINE
    DataSampleListElement::~DataSampleListElement ()
    {
      if (sample_ != 0)
        {
          sample_->release ();
        }
    }
    ACE_INLINE
    DataSampleList::DataSampleList() 
      : head_( 0), 
        tail_( 0), 
        size_( 0) 
    { 
    }
    ACE_INLINE
    void DataSampleList::reset ()
    {
      head_ = ta

      size_ = 0;
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_sample (DataSampleListElement* sample)
    {
      sample->previous_sample_ = 0;
      sample->next_sample_ = 0;
      
      ++size_ ;
      if( head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          tail_->next_sample_ = sample ;
          sample->previous_sample_ = tail_;
          tail_ = sample;
        }    
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_sample_;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else 
            {
              head_->previous_sample_ = 0;
            }
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_send_

    {
      sample->previous_sample_ = 0;
      sample->next_sample_ = 0;
      sample->next_send_sample_ = 0;
      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          sample->previous_sample_ = tail_;
          tail_->next_sample_ = sample;
          tail_->next_send_sample_ = sample ;
          tail_ = sample ;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_send_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_send_sample_ ;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else 
            {
              head_->previous_sample_ = 0;
            }
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_instance_sample (DataSampleListElement* sample

    {
      sample->next_instance_sample_ = 0;
      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          tail_->next_instance_sample_ = sample ;
          tail_ = sample ;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_instance_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        { 
          return false;
        }
      else 
        {
          --size_ ;
          head_ = head_->next_instance_sample_ ;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          return true;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_next_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_sample (stale);
        }
      bool found = false;
      for( DataSampleListElement* item 

           item != 0 ;
           item = item->next_sample_ )
        {
          if (item == stale)
            {
              found = true;
              break;
            }
        }
      if (found)
        {
          -- size_ ;
          
          if( stale->previous_sample_ != 0) 
            {
              stale->previous_sample_->next_sample_ = stale->next_sample_ ;
            } 
          else 
            {
              head_ = stale->next_sample_ ;
              if (head_ != 0)
                {
                  head_->previous_sample_ = 0;
                }
            }
          if( stale->next_sample_ != 0) 
            {
              stale->next_sample_->previous_sample_ = stale->previous_sample_ ;
            } 
          else 
            {
              tail_ = stale->previous_sample_ ;
            }
        }
      return found;
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_next_instance_sample (DataSampleListElement* stale)
    {
      if (hea

        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_instance_sample (stale);
        }
      bool found = false;
      DataSampleListElement* previous = head_;
      for( DataSampleListElement* item = head_->next_instance_sample_ ;
        item != 0 ;
        item = item->next_instance_sample_ )
        {
          if (item == stale)
            {
              found = true;  
              previous->next_instance_sample_ = stale->next_instance_sample_;
              -- size_ ;
              break;
            }
          previous = item;
        }
      
      return found;
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_next_send_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_send_sample (stale);
        }
      bool found = false;
      for( DataSampleListElement* item = head_->

        item != 0 ;
        item = item->next_send_sample_ )
        {
          if (item == stale)
            {
              found = true;
              break;
            }
        }
      
      if (found)
        {
          size_ --;
          stale->previous_sample_->next_sample_ = stale->next_sample_ ;
          stale->previous_sample_->next_send_sample_ = stale->next_send_sample_ ;
          if( stale->next_sample_ != 0) 
            {
              stale->next_sample_->previous_sample_ = stale->previous_sample_ ;
            } 
          else 
            {
              tail_ = stale->previous_sample_ ;
            }
        }
      return found;
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_send_sample (DataSampleList list)
     {
       DataSampleListElement* cur = list.head_;
       if (list.size_ > 1 && cur->next_send_sample_ == 0)
        {
          for (ssize_t i = 0; i < list.size_; i ++)
            {
              cur->next_send_sample_ = cu
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOA

    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_ALLOW

    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_F

    LOAD_REPLACE_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(uint32_t aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    case LOAD_HISTORY:
    case LOAD_RELOAD_NORMAL:
    case LOAD_RELOAD_BYPASS_CACHE:
    case LOAD_RELOAD_BYPASS_PROXY:
    case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    case LOAD_RELOAD_ALLOW_MIXED_CONTENT:
    case LOAD_LINK:
    case LOAD_REFRESH:
  
using namespace qReal;
using namespace models;
Models::Models(QString const &workingCopy, EditorManager const &editorManager)
	qrRepo::RepoApi *repoApi = new qrRepo::RepoApi(workingCopy);
	mGraphicalModel = new models::details::GraphicalModel(repoApi, editorManager);
	mLogicalModel = new models::details::LogicalModel(repoApi, editorManager);
	mRepoApi = repoApi;
	mLogicalModel->connectToGraphicalModel(mGraphicalModel);
	mGraphicalModel->connectToLogicalModel(mLogicalModel);
	mRepoApi = repoApi;
Models::~Models()
	delete mGraphicalModel;
	delete mLogicalModel;
	delete mRepoApi;
QAbstractItemModel* Models::graphicalModel() const
	return mGraphicalModel;
QAbstractItemModel* Models::logicalModel() const
	return mLogicalModel;
GraphicalModelAssistApi &Models::graphicalModelAssistApi() const
	return mGraphicalModel->graphicalModelAssistApi();
LogicalModelAssistApi &Models::logicalModelAssistApi() const
	return mLogicalModel->logicalModelAssistApi();
qrRepo::RepoControlInterface &Models::repo
/**************************************************************************
** This file is part of Cangote
** (C)2/24/2013 2013 Bruno Cabral (and other contributing authors)
**
** Cangote is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published
** by the Free Software Foundation; either version 3, or (at your
** option) any later version.
**
** Cangote is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with Cangote; see the file COPYING.  If not, write to the
** Free Software Foundation, Inc., 59 Temple Place - Suite 330,
** Boston, MA 02111-1307, USA.
**************************************************************************/
class SearchModel;
class NetworkPeer

class DownloadsModel;
class SharedFilesModel;
class PublishModel;
class Models : public QObject
    Q_OBJECT
    Q_PROPERTY(SearchModel * searchModel READ searchModel NOTIFY searchModelChanged)
    Q_PROPERTY(NetworkPeersModel * networkModel READ networkModel NOTIFY networkModelChanged)
    Q_PROPERTY(DownloadsModel * downloadsModel READ downloadsModel NOTIFY downloadsModelChanged)
    Q_PROPERTY(SharedFilesModel * sharedModel READ sharedModel NOTIFY sharedModelChanged)
    Q_PROPERTY(PublishModel * publishModel READ publishModel NOTIFY publishModelChanged)
public:
    explicit Models(QObject *parent = 0);
    ~Models();
    SearchModel* searchModel() const
    { return m_search; }
    NetworkPeersModel* networkModel() const
    { return m_network; }
    DownloadsModel* downloadsModel() const
    { return m_downloads; }
    
    SharedFilesModel* sharedModel() const
    { return m_shared; }
    PublishModel* publishModel() const
    { return m_publish; }
signals:
    void searchModelC
using bookmarks::BookmarkModel;
using bookmarks::BookmarkNode;
using content::BrowserThread;
BookmarkModelTask::BookmarkModelTask(BookmarkModel* model)
    : model_(model) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(model_);
  model_->BlockTillLoaded();
BookmarkModel* BookmarkModelTask::model() const {
  return model_;
BookmarkModelObserverTask::BookmarkModelObserverTask(
    BookmarkModel* bookmark_model)
    : BookmarkModelTask(bookmark_model) {
  model()->AddObserver(this);
BookmarkModelObserverTask::~BookmarkModelObserverTask() {
  model()->RemoveObserver(this);
void BookmarkModelObserverTask::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BookmarkModelObserverTask::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
void BookmarkModelObserverTask::BookmarkNodeAdded(BookmarkModel
                                                                                                                                                                                                                                struct Dump : std::ofstream { Dump(const char* name, const char* text) : f(new std::ofstream(name)) { (*f) << text; } Dump(Dump&& rhs) : f(std::move(rhs.f)) {} std::unique_ptr<std::ofstream> f; }; Dump files[] = { Dump("main.cpp", R"delim(
int main()
    std::cout << sum(3, 4) << std::endl;
}    
                                                                                                                                                                                                                                                )delim"), Dump("a.h", R"delim(
int sum(int, int);
                                                                                                                                                                                            

                                                                                
int sum(int a, int b) { return a + b; }
                                                                                                                                                                                                                                                )delim") };
                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                
                                                                                                                                                
namespace git
  class GitRepoStateSnapshot {
  public:
    GitRepoStateSnapshot(std::string &repoPath);
    ~GitRepoStateSnapshot() {
      if (currentBranchHandle)
	git_reference_free(currentBranchHandle);
      if (repoHandle)
	git_repository_free(repoHandle);
    }
    std::string getBranchName() const { return currentBranchName; }
    int getNumGenerationsAhead() const { return numCommitsAhead; }
    int getNumGenerationsBehind() const { return numCommitsBehind; }
    bool repoIsClean() const { return repoClean; }
    bool repoContainsUntrackedFiles() const {return containsUntrackedFiles; }
    bool isGitRepo() const { return gitRepoFound; }
  private:
    git_reference *currentBranchHandle = 0;
    git_repository *repoHandle = 0;
  
    size_t numCommitsAhead, numCommitsBehind;
    std::string currentBranchName;
    bool repoClean;
    bool containsUntrackedFiles;
    bool gitRepoFound;
    void openGitRepo(std::string &repoPath);
    void computeCurrentBranchName();
    void comp

    void computeRepoClean();
    int computeNumUntrackedFiles(git_status_list *status);
    git_commit *branchToCommit(git_reference *branch);
  };
  GitRepoStateSnapshot::GitRepoStateSnapshot(std::string &repoPath) {
    openGitRepo(repoPath);
    if (gitRepoFound) {
      computeCurrentBranchName();
      computeGenerationDelta();
      computeRepoClean();
    }
  }
  void GitRepoStateSnapshot::openGitRepo(std::string &repoPath) {
    int error = 0;
    while (repoPath.length() > 1) {
      error = git_repository_open(&repoHandle, repoPath.c_str());
      if (error >= 0) {
	gitRepoFound = true;
	return;
      }
      repoPath.erase(repoPath.rfind("/"));
    }
  }
  void GitRepoStateSnapshot::computeCurrentBranchName() {
    const char *branch_name;
    if (git_repository_head_detached(repoHandle)) {
      currentBranchHandle = nullptr;
      currentBranchName = "(detached head)";
      return;
    }
    int ret;
    ret = git_repository_head(&currentBranchHandle, repoHandle);
    if

      currentBranchHandle = nullptr;
      currentBranchName = "(no branch)";
      return;
    }
    git_branch_name(&branch_name, currentBranchHandle);
    currentBranchName = branch_name;
  }
  void GitRepoStateSnapshot::computeGenerationDelta() {
      return;
    git_commit *localHead, *upstreamHead;
    
    int ret;
    git_reference *upstream;
    ret = git_branch_upstream(&upstream, currentBranchHandle);
    if (ret) {
      numCommitsAhead = 0;
      numCommitsBehind = 0;
      return;
    }
    localHead = branchToCommit(currentBranchHandle);
    upstreamHead = branchToCommit(upstream);
    const git_oid *localOid, *upstreamOid;
    localOid = git_commit_id(localHead);
    upstreamOid = git_commit_id(upstreamHead);
    git_graph_ahead_behind(&numCommitsBehind, &numCommitsAhead, repoHandle, localOid, upstreamOid);
    git_commit_free(localHead);
    git_commit_free(upstreamHead);
    git_reference_free(upstream);
  }
  git_commit *GitRepoStateSnapshot::branchToCommit(git_ref

    int error = 0;
    
    git_object *commit_obj;
    error = git_reference_peel(&commit_obj, branch, GIT_OBJ_COMMIT);
    if (error) 
      return nullptr;
    const git_oid *oid = git_object_id(commit_obj);
    
    git_commit *commit;
    error = git_commit_lookup(&commit, repoHandle, oid);
    git_object_free(commit_obj);
    if (error)
      return nullptr;
    return commit;
  }
  void GitRepoStateSnapshot::computeRepoClean() {
    git_status_list *status;
    git_status_options opts;
    opts.version = GIT_STATUS_OPTIONS_VERSION;
    opts.flags = GIT_STATUS_OPT_INCLUDE_UNTRACKED;
    opts.show = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;
    opts.pathspec.count = 0;
    git_status_list_new(&status, repoHandle, &opts);
    int modifiedCount = git_status_list_entrycount(status);
    int untrackedCount = computeNumUntrackedFiles(status);
    containsUntrackedFiles = (untrackedCount > 0);
    repoClean = (modifiedCount == untrackedCount);
    git_status_list_free(status);
  }
  int GitRe

    const git_status_entry *entry;
    int num_entries = git_status_list_entrycount(status);
    int i, untrackedCount = 0;
    for (i = 0; i < num_entries; ++i) {
      entry = git_status_byindex(status, i);
      if (entry->status == GIT_STATUS_WT_NEW)
    	untrackedCount++;
    }
    return untrackedCount;
  }
  std::string getSegment()
  {
    char cpath[MAXPATHLEN];
    if( getcwd(cpath, sizeof(cpath)/sizeof(char)) == NULL )
      return std::string();
    std::string path = cpath;
    GitRepoStateSnapshot repoState(path);
    
    std::string *returnString = new std::string();
    if (repoState.isGitRepo()) {
      ColorCombination &separatorColors = repoState.repoIsClean() ? repo_clean_separator : repo_dirty_separator;
      ColorCombination &textColors = repoState.repoIsClean() ? repo_clean : repo_dirty;
      returnString->append(separatorColors.getColorCode());
      returnString->append(special("separator"));
      returnString->push_back(' ');
      returnString->append(te

      
      returnString->append(special("git_branch"));
      returnString->push_back(' ');
      returnString->append(repoState.getBranchName());
      
      if (repoState.getNumGenerationsAhead() > 0) {
	returnString->push_back(' ');
	returnString->append(std::to_string(repoState.getNumGenerationsAhead()));
	returnString->append(special("git_ahead"));
      }
      if (repoState.getNumGenerationsBehind() > 0) {
	returnString->push_back(' ');
	returnString->append(std::to_string(repoState.getNumGenerationsBehind()));
	returnString->append(special("git_behind"));
      }
      if (repoState.repoContainsUntrackedFiles())
	returnString->append(" +");
      returnString->push_back(' ');
      separatorColors.inverse();
      returnString->append(separatorColors.getColorCode());
      returnString->append(special("separator"));
    }
    else {
      returnString->append(ColorCombination( &lightgray, &darkgray ).getColorCode());
      returnString->push_back(' ');
      returnString->a
/*
 * lkcd_dump.h
 *  lkcd dump classes
 * 
 *  Copyright IBM Corp. 2004, 2006.
 *   
 *  Author(s): Michael Holzheu
 */
/* standard header definitions */
/* dump levels - type specific stuff added later */
/* dump compression options */
/* dump header flags */
/* dump page defines */
class LKCDDump : public Dump
public:
	LKCDDump(Dump*,const char*);
	virtual ~LKCDDump(void){}
	inline virtual void readMem(char* UNUSED(buf), int UNUSED(size)) {
		throw(DumpException("LKCDDump::readMem() not implemented!"));
	}
	inline int seekMem(uint64_t UNUSED(offset)){
		throw(DumpException("LKCDDump::seekMem() not implemented!"));
	}
	inline virtual uint64_t getMemSize() const
	{
		return dumpHeader.memory_size;
	}
	virtual struct timeval getDumpTime(void) const;
	virtual void writeDump(const char* fileName);
	virtual void copyRegsToPage(uint64_t offset, char *buf) = 0;
protected:
	struct _lkcd_dump_header {
		uint64_t magic_number; /* dump magic number,unique to verify */
				       /* dump */
		ui

		uint32_t header_size;  /* size of this header */
		uint32_t dump_level;   /* level of this dump */
		uint32_t page_size;    /* page size (e.g. 4K, 8K, 16K, etc.) */
		uint64_t memory_size;  /* size of entire physical memory */
		uint64_t memory_start; /* start of physical memory */
		uint64_t memory_end;   /* end of physical memory */
		/* the number of dump pages in this dump specifically */
		uint32_t num_dump_pages;
		char panic_string[DUMP_PANIC_LEN];
		/* timeval depends on machine, two long values */
		struct {uint64_t tv_sec;
			uint64_t tv_usec;
		} time; /* the time of the system crash */
		/* the NEW utsname (uname) information -- in character form */
		/* plus it helps us be more architecture independent	*/
		char utsname_sysname[UTS_LEN];
		char utsname_nodename[UTS_LEN];
		char utsname_release[UTS_LEN];
		char utsname_version[UTS_LEN];
		char utsname_machine[UTS_LEN];
		char utsname_domainname[UTS_LEN];
		uint64_t current_task;
		uint32_t dump_compress; /* compression t

		uint32_t dump_flags;    /* any additional flags */
		uint32_t dump_device;   /* any additional flags */
		uint64_t s390_asm_magic;
		uint16_t cpu_cnt;
		uint32_t lowcore_ptr[512];
	} __attribute__((packed));
	struct _lkcd_dump_header_asm {
		uint64_t	magic_number;
		uint32_t	version;
		uint32_t	header_size;
		uint16_t	cpu_cnt;
		uint16_t	real_cpu_cnt;
		uint32_t	lc_vec[512];
	} __attribute__((packed));
	struct _dump_page {
		uint64_t address; /* the address of this dump page */
		uint32_t size;    /* the size of this dump page */
		uint32_t flags;   /* flags (DUMP_COMPRESSED, DUMP_RAW */
			          /* or DUMP_END) */
	} __attribute__((packed));
	struct _lkcd_dump_header dumpHeader;
	struct _lkcd_dump_header_asm dumpHeaderAsm;
private:
	int compressGZIP(const char *old, uint32_t old_size, char *n, 
			uint32_t new_size);
	Dump* referenceDump;
};
class LKCDDump32 : public LKCDDump
public:
	LKCDDump32(Dump* dump, const RegisterContent32& rc);
	virtual void copyRegsToPage(uint64_t off
namespace ObjexxFCL {
template< typename > class ChunkVector;
class byte;
class ubyte;
typedef  byte  sbyte;
typedef  ChunkVector< bool >                ChunkVector_bool;
typedef  ChunkVector< byte >                ChunkVector_byte;
typedef  ChunkVector< sbyte >               ChunkVector_sbyte;
typedef  ChunkVector< ubyte >               ChunkVector_ubyte;
typedef  ChunkVector< short int >           ChunkVector_short;
typedef  ChunkVector< int >                 ChunkVector_int;
typedef  ChunkVector< long int >            ChunkVector_long;
typedef  ChunkVector< unsigned short int >  ChunkVector_ushort;
typedef  ChunkVector< unsigned int >        ChunkVector_uint;
typedef  ChunkVector< unsigned long int >   ChunkVector_ulong;
typedef  ChunkVector< std::size_t >         ChunkVector_size;
typedef  ChunkVector< std::int8_t >         ChunkVector_int8;
typedef  ChunkVector< std::int16_t >        ChunkVector_int16;
typedef  ChunkVector< std::int32_t >        ChunkVector_int32;
typedef  ChunkVe
/*
 * $Id: WriterDataSampleList.inl 6393 2014-07-11 15:14:36Z oschwaldp $
 *
 *
 * Distributed under the OpenDDS License.
 */
namespace OpenDDS {
namespace DCPS {
ACE_INLINE
WriterDataSampleList::WriterDataSampleList()
  : head_(0),
    tail_(0),
    size_(0)
ACE_INLINE
void WriterDataSampleList::reset()
  head_ = tail_ = 0;
  size_ = 0;
ACE_INLINE
ssize_t
WriterDataSampleList::size() const
  return size_;
ACE_INLINE
DataSampleElement*
WriterDataSampleList::head() const
  return head_;
ACE_INLINE
DataSampleElement*
WriterDataSampleList::tail() const
  return tail_;
ACE_INLINE
void
WriterDataSampleList::enqueue_tail(const DataSampleElement* sample)
  DataSampleElement* mSample = const_cast<DataSampleElement*>(sample);
  ++size_ ;
  if (head_ == 0) {
    head_ = tail_ = mSample ;
  } else {
    tail_->next_writer_sample_ = mSample ;
    mSample->previous_writer_sample_ = tail_;
    tail_ = mSample;
  }
ACE_INLINE
bool
WriterDataSampleList::dequeue_head(DataSampleElement*& stale)
  stale 
CPPTEST_CONTEXT("core.message.test.cpptest.TA_Message_CppTest/core.message.test.cpptest/generic_common/ConnectionThread.cpp");
CPPTEST_TEST_SUITE_INCLUDED_TO("core.message.test.cpptest.TA_Message_CppTest/core.message.test.cpptest/generic_common/ConnectionThread.cpp");
class TestSuite_isChannelLocatorReachable_24de00e : public CppTest_TestSuite
    private:
        std::string m_corbaloc_url;
        TA_Base_Core::IChannelLocator_var m_channel_locator;
        std::string m_prev_agent_id;
    public:
        CPPTEST_TEST_SUITE(TestSuite_isChannelLocatorReachable_24de00e);
        CPPTEST_TEST(test_isChannelLocatorReachable_1_not_reachable);
        CPPTEST_TEST(test_isChannelLocatorReachable_2_throw_CORBA__Exception);
        CPPTEST_TEST(test_isChannelLocatorReachable_3_reachable);
        CPPTEST_TEST_SUITE_END();
        void setUp();
        void tearDown();
        void test_isChannelLocatorReachable_1_not_reachable();
        void test_isChannelLocatorReachable_2_throw_CORBA__Exce

        void test_isChannelLocatorReachable_3_reachable();
};
CPPTEST_TEST_SUITE_REGISTRATION(TestSuite_isChannelLocatorReachable_24de00e);
void TestSuite_isChannelLocatorReachable_24de00e::setUp()
    FUNCTION_ENTRY( "setUp" );
    m_corbaloc_url = "localhost";
    m_channel_locator = TA_Base_Core::IChannelLocator::_nil();
    m_prev_agent_id = "";
    unit_test::initialize_corba();
    FUNCTION_EXIT;
void TestSuite_isChannelLocatorReachable_24de00e::tearDown()
    FUNCTION_ENTRY( "tearDown" );
    unit_test::destroy_corba();
    FUNCTION_EXIT;
/* CPPTEST_TEST_CASE_BEGIN test_isChannelLocatorReachable_1_not_reachable */
/* CPPTEST_TEST_CASE_CONTEXT bool TA_Base_Core::ChannelLocatorConnection::isChannelLocatorReachable(const std::string &, TA_Base_Core::IChannelLocator_ptr, const std::string &) const */
void TestSuite_isChannelLocatorReachable_24de00e::test_isChannelLocatorReachable_1_not_reachable()
    FUNCTION_ENTRY( "test_isChannelLocatorReachable_1_not_reachable" );
    CPPTEST_A

    TA_Base_Core::ChannelLocatorConnection channel_locator_connection( TA_Base_Core::gMakeServiceAddr(unit_test::notify_host, unit_test::notify_port) );
    {
        m_channel_locator = unit_test::ChannelLocatorStub::get_instance()._this();
        m_prev_agent_id = "wrong_id";
        CPPTEST_ASSERT( false == channel_locator_connection.isChannelLocatorReachable( m_corbaloc_url, m_channel_locator, m_prev_agent_id ) );
    }
    channel_locator_connection.terminateAndWait();
    FUNCTION_EXIT;
/* CPPTEST_TEST_CASE_END test_isChannelLocatorReachable_1_not_reachable */
/* CPPTEST_TEST_CASE_BEGIN test_isChannelLocatorReachable_2_throw_CORBA__Exception */
/* CPPTEST_TEST_CASE_CONTEXT bool TA_Base_Core::ChannelLocatorConnection::isChannelLocatorReachable(const std::string &, TA_Base_Core::IChannelLocator_ptr, const std::string &) const */
void TestSuite_isChannelLocatorReachable_24de00e::test_isChannelLocatorReachable_2_throw_CORBA__Exception()
    FUNCTION_ENTRY( "test_isChannelLocatorRea

    CPPTEST_ASSERT( unit_test::ChannelLocatorStub::get_instance().start_service() );
    TA_Base_Core::ChannelLocatorConnection channel_locator_connection( TA_Base_Core::gMakeServiceAddr(unit_test::notify_host, unit_test::notify_port) );
    {
        unit_test_throw_exception_when_log_guard( "CORBA::Exception", TA_Base_Core::DebugUtil::DebugError, "ChannelLocatorConnection::isChannelLocatorReachable(): %s unable to contact IChannelLocator at %s: agentID has changed" );
        m_channel_locator = unit_test::ChannelLocatorStub::get_instance()._this();
        m_prev_agent_id = "wrong_id";
        CPPTEST_ASSERT( false == channel_locator_connection.isChannelLocatorReachable( m_corbaloc_url, m_channel_locator, m_prev_agent_id ) );
    }
    channel_locator_connection.terminateAndWait();
    FUNCTION_EXIT;
/* CPPTEST_TEST_CASE_END test_isChannelLocatorReachable_2_throw_CORBA__Exception */
/* CPPTEST_TEST_CASE_BEGIN test_isChannelLocatorReachable_3_reachable */
/* CPPTEST_TEST_CASE_CONTEX
/*
 * MacGitver
 * Copyright (C) 2012 Sascha Cunz <sascha@babbelbox.org>
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
RepoTreeView::RepoTreeView()
    : ContextView("RepoTreeView")
    setViewName( trUtf8( "Repositories" ) );
    setFlags( ProvidesContexts );
    setupActions( this );
    mRepos = new TreeViewCtxMenu;
    mRepos->setFrameShape( QFrame::NoFrame );
    mRepos->setAttribute( Qt::WA_MacShowFocusRect, false );
    mModel = new RepoInfoModel();
    QSortFilterProxyModel* sfpm = new QSortF

    sfpm->setSourceModel(mModel);
    sfpm->setSortRole(Qt::DisplayRole);
    sfpm->sort(0);
    mRepos->setModel(sfpm);
    mRepos->setIndentation( 12 );
    mRepos->expandAll();
    mRepos->setHeaderHidden( true );
    setWidget( mRepos );
    connect( mRepos,    SIGNAL(contextMenu(QModelIndex,QPoint)),
             this,      SLOT(contextMenu(QModelIndex,QPoint)) );
    connect( &MacGitver::repoMan(), SIGNAL(repositoryActivated(RM::Repo*)),
             this,                  SLOT(onRepoActivated(RM::Repo*)) );
    connect( &MacGitver::repoMan(), SIGNAL(repositoryDeactivated(RM::Repo*)),
             this,                  SLOT(onRepoDeactivated(RM::Repo*)) );
QModelIndex RepoTreeView::deeplyMapToSource( QModelIndex current ) const
    while( current.isValid() )
    {
        const QAbstractProxyModel* apm = qobject_cast< const QAbstractProxyModel* >( current.model() );
        if( !apm )
            return current;
        current = apm->mapToSource( current );
    }
    return QM

void RepoTreeView::contextMenu( const QModelIndex& index, const QPoint& globalPos )
    RM::Repo* info = mModel->index2Info(deeplyMapToSource(index));
    if (info) {
        Heaven::Menu* menu = info->isSubModule() ? menuCtxMenuSMRepo : menuCtxMenuRepo;
        menu->setActivationContext( info );
        actActivate->setEnabled( !info->isActive() );
        menu->showPopup( globalPos );
    }
void RepoTreeView::onCtxActivate()
    Heaven::Action* action = qobject_cast< Heaven::Action* >( sender() );
    if( action )
    {
        RM::Repo* info = qobject_cast< RM::Repo* >( action->activatedBy() );
        if( info )
        {
            MacGitver::repoMan().activate( info );
        }
    }
void RepoTreeView::onCtxClose()
    Heaven::Action* action = qobject_cast< Heaven::Action* >( sender() );
    if( action )
    {
        RM::Repo* info = qobject_cast< RM::Repo* >( action->activatedBy() );
        if( info )
        {
            info->close();
        }
    }
void RepoTreeView::
struct SVRD_Stream_s {
    char* name;
    SVRD_Client* client;
    SVRD_Source* source;
    SVR_Encoding* encoding;
    Dictionary* encoding_options;
    SVR_Encoder* encoder;
    SVR_FrameProperties* frame_properties;
    SVR_StreamState state;
    void* payload_buffer;
    size_t payload_buffer_size;
    int drop_rate;
    int drop_counter;
    short priority;
    IplImage* temp_frame[2];
    pthread_t worker;
    bool worker_started;
    SVR_LOCKABLE;
};
SVRD_Stream* SVRD_Stream_new(const char* name);
void SVRD_Stream_destroy(SVRD_Stream* stream);
void SVRD_Stream_setClient(SVRD_Stream* stream, SVRD_Client* client);
int SVRD_Stream_attachSource(SVRD_Stream* stream, SVRD_Source* source);
int SVRD_Stream_detachSource(SVRD_Stream* stream);
void SVRD_Stream_sourceClosing(SVRD_Stream* stream);
int SVRD_Stream_setEncoding(SVRD_Stream* stream, const char* encoding_descriptor);
int SVRD_Stream_setChannels(SVRD_Stream* stream, int channels);
int SVRD_Stream_setPriority(SVRD_Stream* stream, 
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil -*- */
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
namespace ndn {
class KeyLocator {
public:
  struct Error : public std::runtime_error { Error(const std::string &what) : std::runtime_error(what) {} };
  
  enum {
    KeyLocator_None = -1,
    KeyLocator_Name = 0,
    
    KeyLocator_Unknown = 255
  };
  inline
  KeyLocator()
    : type_(KeyLocator_None)
  {
  }
  inline
  KeyLocator(const Name &name);
  inline const Block& 
  wireEncode() const;
  inline void 
  wireDecode(const Block &value);
  
  inline bool
  empty() const
  {
    return type_ == KeyLocator_None;
  }
  
  uint32_t 
  getType() const { return type_; }
      
  
  inline const Name&
  getName() const;
  inline void
  setName(const Name &name);
  
private:
  uint32_t type_;
  Name name_;
  
  mutable Block wire_;
};
inline
Key

  setName(name);
inline const Block& 
KeyLocator::wireEncode() const
  if (wire_.hasWire())
    return wire_;
  switch (type_) {
  case KeyLocator_None:
    wire_ = dataBlock(Tlv::KeyLocator, reinterpret_cast<const uint8_t*>(0), 0);
    break;
  case KeyLocator_Name:
    wire_ = Block(Tlv::KeyLocator);
    wire_.push_back(name_.wireEncode());
    wire_.encode();
    break;
  default:
    throw Error("Unsupported KeyLocator type");
  }
  
  return wire_;
inline void 
KeyLocator::wireDecode(const Block &value)
  wire_ = value;
  wire_.parse();
  
  if (!wire_.getAll().empty() && wire_.getAll().front().type() == Tlv::Name)
    {
      type_ = KeyLocator_Name;
      name_.wireDecode(wire_.getAll().front());
    }
  else
    {
      type_ = KeyLocator_Unknown;
    }
inline const Name&
KeyLocator::getName() const
  if (type_ != KeyLocator_Name)
    throw Error("Requested Name, but KeyLocator is not of the Name type");
  return name_;
inline void
KeyLocator::setName(const Name &name)
  type_
/*
  ========================================================================
  FILE:           FontMapModel.h
  SERVICES:       
  PUBLIC CLASSES: IFontMapModel
  DESCRIPTION:    
  ========================================================================
  ========================================================================
    
               Copyright Â© 1999-2007 QUALCOMM Incorporated 
                     All Rights Reserved.
                   QUALCOMM Proprietary/GTDR
    
  ========================================================================
  ========================================================================
*/
typedef struct FontMapModel FontMapModel;
typedef struct IFMListModel {
   AEEBASE_INHERIT(IListModel, FontMapModel);
} IFMListModel;
struct FontMapModel {
   ModelBase            base;
   IFMListModel         listModel;
   AEEVTBL(IListModel)  vtListModel;
   Vector               styles;
};
int         FontMapModel_New(IFontMapModel **ppo, IModule *piModul
/*
Brian Curless
Computer Graphics Laboratory
Stanford University
---------------------------------------------------------------------
Copyright (1997) The Board of Trustees of the Leland Stanford Junior
University. Except for commercial resale, lease, license or other
commercial transactions, permission is hereby given to use, copy,
modify this software for academic purposes only.  No part of this
software or any derivatives thereof may be used in the production of
computer models for resale or for use in a commercial
product. STANFORD MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND
CONCERNING THIS SOFTWARE.  No support is implied or provided.
*/
ChunkAllocator::ChunkAllocator()
    this->chunkSize = 0;
    this->chunkList = NULL;
    this->currentChunk = NULL;
    this->currentAddr = NULL;
    this->countInChunk = 0;
ChunkAllocator::ChunkAllocator(int chunkSize)
    this->chunkSize = chunkSize;
    this->chunkList = new ChunkLink(chunkSize);
    this->currentChunk = this->chunkLi

    this->currentAddr = this->chunkList->chunk;
    this->countInChunk = 0;
uchar *
ChunkAllocator::alloc(int num)
    this->newChunkIfNeeded(num);
    uchar *addr = this->currentAddr;
    this->currentAddr += num;
    this->countInChunk += num;
    return addr;
void
ChunkAllocator::newChunkIfNeeded(int num)
    if (num+this->countInChunk > this->chunkSize) {
	if (this->currentChunk->next == NULL) {
	    this->currentChunk->next = new ChunkLink(chunkSize);
	}
	this->currentChunk = this->currentChunk->next;
	this->countInChunk = 0;
	this->currentAddr = this->currentChunk->chunk;
    }
void
ChunkAllocator::reset()
    this->currentChunk = this->chunkList;
    this->currentAddr = this->chunkList->chunk;
    this->countInChunk = 0;
ChunkAllocator::~ChunkAllocator()
    ChunkLink *chunk, *nextChunk;
    
    chunk = this->chunkList;
    while (chunk != NULL) {
	nextChunk = chunk->next;
	delete chunk;
	chunk = nextChunk;
    }
uchar *
ChunkAllocator::nextElem(int size)
    uchar *addr;
    
namespace StiPersist
	namespace Data
	{
		Chunk::Chunk()
		{
			data = 0;
			length = 0;
			clearData = false;
		}
		Chunk::Chunk(char *m_data, unsigned int m_length)
		{
			data = m_data;
			length = m_length;
			clearData = true;
		}
		void Chunk::setClearData(bool m_clearData)
		{
			clearData = m_clearData;
		}
		bool Chunk::getClearData(void)
		{
			return clearData;
		}
		unsigned int Chunk::getLength(void)
		{
			return length;
		}
		char* Chunk::getData(void)
		{
			return data;
		}
		void Chunk::setData(char *m_data, unsigned int m_length)
		{
			data = m_data;
			length = m_length;
		}
		std::string Chunk::toString(void)
		{
			std::string text = data;
			return text;
		}
		ChunkMarker* Chunk::getMarker(void)
		{
			ChunkMarker *marker = new ChunkMarker();
			marker->length = length;
			return marker;
		}
		Chunk::~Chunk()
		{
			if(clearData && data != 0)
			{
				delete data;
			}
		}
		Chunk* Chunk::FromFieldMarker(FieldMarker *marker)
		{
			unsigned int length = sizeof(F
namespace dmz {
   class DMZ_KERNEL_LINK_SYMBOL StreamFile : public Stream {
      public:
         StreamFile ();
         StreamFile (FILE *handle);
         virtual ~StreamFile ();
         FILE *get_file_handle ();
         Boolean operator! () const;
         DMZ_BOOLEAN_OPERATOR;
         virtual Stream &write_raw_data (const UInt8 *Data, const Int32 Size);
         virtual Stream &flush ();
         virtual Stream &newline ();
         virtual Stream &operator<< (const UInt16 Value);
         virtual Stream &operator<< (const UInt32 Value);
         virtual Stream &operator<< (const UInt64 Value);
         virtual Stream &operator<< (const Int16 Value);
         virtual Stream &operator<< (const Int32 Value);
         virtual Stream &operator<< (const Int64 Value);
         virtual Stream &operator<< (const Float32 Value);
         virtual Stream &operator<< (const Float64 Value);
         virtual Stream &operator<< (const String &Value);
         virtual Stream &operator<< (con
EntityModel::EntityModel(std::string name)
	this->name = name;
EntityModel::~EntityModel(void)
void EntityModel::Initialize(Renderer* renderer)
	this->model = ResourceManager::Instance()->GetModel(this->modelFileName, renderer->GetDevice());
void EntityModel::Cleanup()
void EntityModel::Update(Timer* timer)
void EntityModel::Render(Renderer* renderer)
Matrix EntityModel::GetPosition()
	return position;
void EntityModel::SetPosition(Matrix pos)
	position = pos;
float EntityModel::GetHRotation()
	return position.rotation_h;
void EntityModel::SetHRotation(float rotation)
	position.rotation_h = rotation;
float EntityModel::GetVRotation()
	return position.rotation_v;
void EntityModel::SetVRotation(float rotation)
	position.rotation_v = rotation;
ResourceModel* EntityModel::GetModel()
	return model;
void EntityModel::SetModel(ResourceModel* model)
	this->model = model;
void EntityModel::SetModel(std::string fileName)
	this->modelFileName = fileName;
ResourceTexture* EntityModel::GetTexture()
namespace XPG
    Event::Event()
    {
        _firstHandler = 0;
    }
    Event::~Event()
    {
        while (_firstHandler)
        {
            Handler* deadHandler = _firstHandler;
            _firstHandler = _firstHandler->nextHandler;
            delete deadHandler;
        }
    }
    void Event::AddListener(Listener listener, void* userData)
    {
        Handler* handler = new Handler;
        handler->listener = listener;
        handler->userData = userData;
        handler->nextHandler = _firstHandler;
        _firstHandler = handler;
    }
    void Event::RemoveListener(Listener listener, void* userData)
    {
        Handler* handler = _firstHandler;
        if (handler)
        {
            if (handler->listener == listener
                && handler->userData == userData)
            {
                _firstHandler = _firstHandler->nextHandler;
                delete handler;
            }
            else
            {
                Handler* next = handler->nextH
namespace Scene {
    ModelScene::ModelScene() :
        AbstractScene() {
    }
    ModelScene::~ModelScene() {
    }
    Viewport::ViewportArray * ModelScene::viewportArray() const {
        return _viewportArray;
    }
    Model::AbstractModel * ModelScene::selectedModel() const {
        return qobject_cast<Model::AbstractModel *>(_models.selectedObject());
    }
    void ModelScene::setViewportArray(Viewport::ViewportArray * viewportArray) {
        _viewportArray = viewportArray;
        emit viewportArrayChanged();
    }
    void ModelScene::updateScene() {
        while (!_blueprints.isEmpty()) {
            unpackBlueprint(_blueprints.dequeue());
        }
        for (Model::AbstractModel * model : _models.list()) {
            if (model->updateNeeded()) {
                model->update();
            }
        }
    }
    void ModelScene::renderScene(const QSize & surfaceSize) {
        viewportArray()->resize(surfaceSize);
        updateScene();
        render();
        /* 

        * for example depth buffer check affects values of points (z-coordinate)
        */
        if (postProcess()) {
            emit redraw();
        }
    }
    void ModelScene::render(const Model::AbstractModel::RenderState & state) {
        Viewport::ViewportRect boundingRect;
        for (const Viewport::Viewport * viewport : _viewportArray->array()) {
            boundingRect = viewport->boundingRect();
            glViewport(boundingRect.x(), boundingRect.y(), boundingRect.width(), boundingRect.height());
            for (Model::AbstractModel * model : _models.list()) {
                model->drawModel(viewport, state);
            }
        }
    }
    bool ModelScene::postProcess() {
        bool redraw = false;
        for (Model::AbstractModel * model : _models.list()) {
            for (const Viewport::Viewport * viewport : _viewportArray->array()) {
                redraw |= model->checkBuffers(viewport);
            }
            if (redraw) {
                model

            }
        }
        return redraw;
    }
    void ModelScene::cleanUp() {
        _models.clear();
        AbstractScene::cleanUp();
    }
    QVariant ModelScene::blueprint() const {
        return _blueprint;
    }
    void ModelScene::setBlueprint(const QVariant & blueprint) {
        _blueprints.enqueue(blueprint.value<Blueprint>());
        _blueprint = blueprint;
        emit blueprintChanged(blueprint);
    }
    void ModelScene::selectModel(Model::AbstractModel * model) {
        Model::AbstractModel * prevSelected = _models.selectedObject();
        if (prevSelected) {
            prevSelected->unselectModel();
        }
        _models.selectObject(model);
        uint selectedID = 0;
        for (const Model::AbstractModel * model : _models.list()) {
            selectedID = std::max(selectedID, model->numberedID());
        }
        model->selectModel(selectedID);
        Message::SettingsMessage message(
                    Message::Sender(_models.selectedObj

                    Message::Reciever("sidebar")
                    );
        message.data["action"] = "changeModelID";
        emit post(message);
    }
    Model::AbstractModel *  ModelScene::addModel(const ModelInfo::Model & model) {
        ModelInfo::Params params;
        Model::AbstractModel * modelI = Model::AbstractModel::createModel(model.first, this);
        params = model.second;
        modelI->init(params);
        QVariantList children = params["children"].toList();
        QVariantMap childsMap;
        for (const QVariant & child : children) {
            childsMap = child.toMap();
            modelI->addChild(addModel(ModelInfo::Model(
                                     childsMap["type"].value<ModelInfo::Type>(),
                                     childsMap["params"].value<ModelInfo::Params>()
                                    )
                                )
            );
        }
        QObject::connect(modelI, &Model::AbstractModel::post, this, &Mod

        return modelI;
    }
    void ModelScene::initScene() {
        unpackBlueprint(_blueprints.dequeue(), true);
    }
    void ModelScene::unpackBlueprint(const Blueprint & blueprint, const bool & resetScene) {
        if (resetScene) {
            cleanUp();
        }
        QVariantMap helper;
        for (const QVariant & lightSource : blueprint["lightSources"].toList()) {
            lightSources.append(new LightSource(lightSource.toMap()));
        }
        for (const QVariant & material : blueprint["materials"].toList()) {
            materials.append(new Material(material.toMap()));
        }
        for (const QVariant & texture : blueprint["textures"].toList()) {
            textures.append(new Texture(texture.toMap()));
        }
        Model::AbstractModel * newModel;
        for (const QVariant & model : blueprint["models"].toList()) {
            helper = model.toMap();
            newModel = addModel(ModelInfo::Model(
                                    helper["
namespace dy
    std::string& PsetPath()
    {
        static std::string sample_pset_path = "psets/dy_samples_cfg.py";
        return sample_pset_path;
    }
        
    std::vector<edm::ParameterSet>& PsetVector()
    {
        static std::vector<edm::ParameterSet> pset_vec;
        return pset_vec;
    }
    void ResetPsetVector()
    {
        const edm::ParameterSet& process = edm::readPSetsFrom(PsetPath())->getParameter<edm::ParameterSet>("process");
        PsetVector() = process.getParameter<std::vector<edm::ParameterSet> >("dy_samples");
    }
    Sample::Info CreateSampleInfo(const Sample::value_type sample, const std::vector<edm::ParameterSet>& pset_vec)
    {
        assert(pset_vec.size() == Sample::static_size);
        const auto& pset = pset_vec[sample];
        Sample::Info info
        {
            pset.getParameter<std::string>("name"),
            pset.getParameter<std::string>("title"),
            pset.getParameter<std::string>("latex"),
            pset.getPara

            static_cast<Color_t>(pset.getParameter<int>("color")),
            pset.getParameter<double>("eff"),
            sample
        };
        return info;
    }
    std::vector<Sample::Info> GetInitialSampleInfosFromPset()
    {
        ResetPsetVector();
        assert(PsetVector().size() == Sample::static_size);
        std::vector<Sample::Info> sample_infos;
        sample_infos.reserve(Sample::static_size);
        for (size_t i = 0; i < PsetVector().size(); ++i)
        {
            sample_infos.push_back(CreateSampleInfo(static_cast<Sample::value_type>(i), PsetVector()));
        }
        assert(sample_infos.size() == Sample::static_size);
        return sample_infos;
    }
    /*static*/ std::vector<Sample::Info>& SampleInfos()
    {
        static std::vector<Sample::Info> sample_infos = GetInitialSampleInfosFromPset();
        assert(sample_infos.size() == Sample::static_size);
        return sample_infos;
    }
    /*static*/ const std::vector<Sample::Info>& Sampl

    {
        return SampleInfos();
    }
    std::vector<Sample::Info> GetSampleInfosFromPset()
    {
        std::vector<Sample::Info> sample_infos;
        sample_infos.reserve(Sample::static_size);
        for (auto& sample_info : Sample::GetInfos())
        {
            sample_infos.push_back(CreateSampleInfo(sample_info.sample, PsetVector()));
        }
        assert(sample_infos.size() == Sample::static_size);
        return sample_infos;
    }
    /*static*/ void Sample::SetPsetPath(const std::string& pset_path)
    {
        PsetPath() = pset_path;
        ResetPsetVector();
        SampleInfos() = GetSampleInfosFromPset();
    }
    /*static*/ const std::string& Sample::GetPsetPath()
    {
        return PsetPath();
    }
    bool operator < (const Sample::Info& s1, const Sample::Info& s2)
    {
        return (s1.sample < s2.sample);
    }
    std::ostream& operator << (std::ostream& out, const Sample::Info& sample_info)
    {
        out << Form("Sample::Info = {\n\t%s, 

                    sample_info.name.c_str(),
                    sample_info.title.c_str(),
                    sample_info.latex.c_str(),
                    sample_info.ntuple_path.c_str(),
                    sample_info.color,
                    sample_info.filter_eff,
                    sample_info.sample);
        return out;               
    }
    void PrintSampleInfos(std::ostream& out)
    {
        for (const auto& sample_info : Sample::GetInfos())
        {
            out << sample_info << '\n';
        }
        out << '\n';
    }
    Sample::value_type GetSampleFromName(const std::string& sample_name)
    {
        for (const auto& sample_info : Sample::GetInfos())
        {
            if (sample_info.name == sample_name)
            {
                return sample_info.sample; 
            }
        }
        throw std::domain_error(Form("[dy::GetSampleInfo] Error: sample %s not found!", sample_name.c_str()));
    }
    Sample::value_type GetSampleFromNumber(const

    {
        if (sample_num < 0 or sample_num >= Sample::static_size)
        {
            throw std::domain_error("[dy::GetSampleInfo] Error: sample number out of bounds!");
        }
        return static_cast<Sample::value_type>(sample_num);
    }
    bool IsSample(const std::string& sample_name)
    {
        for (const auto& sample_info : Sample::GetInfos())
        {
            if (sample_info.name == sample_name)
            {
                return true; 
            }
        }
        return false;
    }
    Sample::Info GetSampleInfo(const Sample::value_type& sample)
    {
        return Sample::GetInfos()[sample]; 
    }
    Sample::Info GetSampleInfo(const std::string& sample_name)
    {
        Sample::value_type sample = GetSampleFromName(sample_name); 
        return GetSampleInfo(sample); 
    }
    Sample::Info GetSampleInfo(const int sample_num)
    {
        Sample::value_type sample = GetSampleFromNumber(sample_num); 
        return GetSampleInfo(sample); 
    
using boost::unit_test::test_suite;
using boost::unit_test::test_case;
using namespace std;
using namespace zypp;
using namespace zypp::filesystem;
using namespace zypp::repo;
BOOST_AUTO_TEST_CASE(refresh_addon_in_subdir)
    KeyRingTestReceiver keyring_callbacks;
    KeyRingTestSignalReceiver receiver;
    keyring_callbacks.answerAcceptKey(KeyRingReport::KEY_TRUST_TEMPORARILY);
    keyring_callbacks.answerAcceptVerFailed(true);
    keyring_callbacks.answerAcceptUnknownKey(true);
    TestSetup test( Arch_x86_64 );
    RepoInfo info;
    info.setBaseUrl( REPODATADIR.asDirUrl() );
    info.setPath("/updates");
    info.setType(RepoType::YAST2);
    info.setAlias("boooh");
    test.loadRepo(info);
    Repository r( test.satpool().reposFind( "boooh" ) );
    BOOST_REQUIRE( r );
    BOOST_CHECK_EQUAL( r.solvablesSize(), 2 );
    BOOST_CHECK_EQUAL( r.info().type(), repo::RepoType::YAST2 );
    BOOST_CHECK( r.info().hasLicense() );
BOOST_AUTO_TEST_CASE(pluginservices_test)
  TmpDir tmpCachePa

  RepoManagerOptions opts( RepoManagerOptions::makeTestSetup( tmpCachePath ) ) ;
  filesystem::assert_dir( opts.knownReposPath );
  filesystem::assert_dir( opts.pluginsPath / "services");
  opts.pluginsPath = DATADIR + "/plugin-service-lib-1";
  BOOST_CHECK(PathInfo(opts.pluginsPath / "services/service").isExist());
  {
    RepoManager manager(opts);
    BOOST_REQUIRE_EQUAL(1, manager.serviceSize());
    BOOST_CHECK(manager.repoEmpty());
    ServiceInfo service(*manager.serviceBegin());
    BOOST_CHECK_EQUAL("service", service.alias());
    BOOST_CHECK_EQUAL( (DATADIR / "/plugin-service-lib-1/services/service").asFileUrl(), service.url().asString());
    manager.refreshServices();
    BOOST_CHECK_EQUAL((unsigned) 2, manager.repoSize());
  }
  opts.pluginsPath = DATADIR + "/plugin-service-lib-2";
  {
    RepoManager manager(opts);
    BOOST_REQUIRE_EQUAL(1, manager.serviceSize());
    ServiceInfo service(*manager.serviceBegin());
    BOOST_CHECK_EQUAL("service", service.alias());
    B

    manager.refreshServices();
    BOOST_CHECK_EQUAL((unsigned) 1, manager.repoSize());
  }
BOOST_AUTO_TEST_CASE(service_file_link_bug)
  TmpDir tmpCachePath;
  RepoManagerOptions opts( RepoManagerOptions::makeTestSetup( tmpCachePath ) ) ;
  filesystem::mkdir( opts.knownReposPath );
  filesystem::mkdir( opts.knownServicesPath );
  RepoManager manager(opts);
  ServiceInfo service("test", DATADIR.asDirUrl() );
  service.setEnabled(true);
  manager.addService(service);
  manager.modifyService(service.alias(), service);
  manager.modifyService(service.alias(), service);
BOOST_AUTO_TEST_CASE(repomanager_test)
  TmpDir tmpCachePath;
  RepoManagerOptions opts( RepoManagerOptions::makeTestSetup( tmpCachePath ) ) ;
  filesystem::mkdir( opts.knownReposPath );
  filesystem::mkdir( opts.knownServicesPath );
  BOOST_CHECK_EQUAL( filesystem::copy_dir_content( DATADIR + "/repos.d", opts.knownReposPath ), 0 );
  RepoManager manager(opts);
  list<RepoInfo> repos;
  repos.insert(repos.end(), manager.re

  BOOST_CHECK_EQUAL(repos.size(), (unsigned) 4);
  manager.addRepositories( (DATADIR / "/proprietary.repo").asFileUrl() );
  BOOST_CHECK( PathInfo(opts.knownReposPath + "/proprietary.repo_1").isExist() );
  repos.clear();
  repos.insert(repos.end(), manager.repoBegin(), manager.repoEnd());
  BOOST_CHECK_EQUAL(repos.size(), (unsigned) 6);
  RepoInfo office_dup;
  office_dup.setAlias("office");
  BOOST_CHECK_THROW(manager.addRepository(office_dup), RepoAlreadyExistsException);
  RepoInfo office;
  office.setAlias("office");
  manager.removeRepository(office);
  repos.clear();
  repos.insert(repos.end(), manager.repoBegin(), manager.repoEnd());
  BOOST_CHECK_EQUAL(repos.size(), (unsigned) 5);
  BOOST_CHECK( PathInfo(opts.knownReposPath + "/proprietary.repo_1").isExist() );
  RepoInfo macromedia;
  macromedia.setAlias("macromedia");
  manager.removeRepository(macromedia);
  BOOST_CHECK_EQUAL(manager.repoSize(), (unsigned) 4);
  BOOST_CHECK( ! PathInfo(opts.knownReposPath + "/proprietary.r

  Url urlS( DATADIR.asDirUrl() );
  ServiceInfo service("test", urlS);
  service.setEnabled(true);
  manager.addService(service);
  manager.refreshServices();
  urlS = (DATADIR / "second").asDirUrl();
  service.setUrl(urlS);
  service.setEnabled(true);
  manager.modifyService(service.alias(), service);
  manager.refreshServices();
  std::list<RepoInfo> infos;
  manager.getRepositoriesInService("test",
    insert_iterator<std::list<RepoInfo> >(infos,infos.begin()));
  RepoInfo repo;
  repo.setAlias("foo");
  repo.setBaseUrl( (Pathname(TESTS_SRC_DIR) / "/repo/yum/data/10.2-updates-subset").asDirUrl() );
  KeyRingTestReceiver keyring_callbacks;
  KeyRingTestSignalReceiver receiver;
  keyring_callbacks.answerAcceptKey(KeyRingReport::KEY_TRUST_TEMPORARILY);
  keyring_callbacks.answerAcceptVerFailed(true);
  keyring_callbacks.answerAcceptUnknownKey(true);
  BOOST_CHECK_MESSAGE( !manager.isCached(repo), "Repo should not yet be cached" );
  manager.buildCache(repo);
  BOOST_CHECK_MESSAGE( man

  RepoManager::RefreshCheckStatus ref_stat = manager.checkIfToRefreshMetadata(repo, *repo.baseUrlsBegin());
  SEC << endl << ref_stat << endl;
  BOOST_CHECK_MESSAGE( ref_stat== RepoManager::REPO_UP_TO_DATE || ref_stat == RepoManager::REPO_CHECK_DELAYED, "Metadata should be up to date" );
  Pathname base = (opts.repoCachePath / "solv" / repo.alias());
  Pathname solvfile = base / "solv";
  Pathname cookiefile = base / "cookie";
  BOOST_CHECK_MESSAGE( PathInfo(solvfile).isExist(), "Solv file is created after caching: " + solvfile.asString());
  BOOST_CHECK_MESSAGE( PathInfo(cookiefile).isExist(), "Cookie file is created after caching: " + cookiefile.asString());
  MIL << "Repo already in cache, clean cache"<< endl;
  manager.cleanCache(repo);
  BOOST_CHECK_MESSAGE( !manager.isCached(repo),
                       "Repo cache was just deleted, should not be cached now" );
  manager.buildCache(repo);
  manager.loadFromCache(repo);
  if ( manager.isCached(repo ) )
  {
    MIL << "Repo alrea
/*
 * =====================================================================================
 *
 *       Filename:  testReadModel.cpp
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  2014/7/26 9:51:01
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
using namespace std;
struct Point
    int x;
    int y;
};
Point modelSize;
char **model;
void readModelFromFile( const char *filename )
    FILE *fp;
    fp  = fopen( filename, "r" );
    if( !fp )
    {
        printf( "%sæå¼åºéï¼\n", filename );
        return;
    }
    modelSize.y = 0;
    modelSize.x = 0;
    fscanf( fp, "%d %d", &modelSize.x, &modelSize.y );
    model = new char *[modelSize.y];
    char temp[10];
    fgets( temp, 10, fp );
    int i = 0;
    while( !feof( fp ) )
    {
        model[i] = new char[ modelSize.x ];
        fgets( model[i], 1024, fp );
namespace handystats { namespace json_dump {
namespace stats {
metrics::gauge dump_time;
void initialize() {
	dump_time = metrics::gauge();
void finalize() {
	dump_time = metrics::gauge();
std::mutex dump_mutex;
std::shared_ptr<const std::string> dump(new std::string());
const std::shared_ptr<const std::string>
get_dump() {
	std::lock_guard<std::mutex> lock(dump_mutex);
	return dump;
template<typename Allocator>
std::shared_ptr<const std::string> create_dump(Allocator&& allocator = Allocator()) {
	rapidjson::Value dump_value(rapidjson::kObjectType);
	const auto metrics_dump = metrics_dump::get_dump();
	for (const auto& metric_entry : *metrics_dump) {
		rapidjson::Value metric_value;
		switch (metric_entry.second.which()) {
			case metrics::metric_index::GAUGE:
				json::write_to_json_value(&boost::get<metrics::gauge>(metric_entry.second), &metric_value, allocator);
				break;
			case metrics::metric_index::COUNTER:
				json::write_to_json_value(&boost::get<metrics::counter>(metric_entr

				break;
			case metrics::metric_index::TIMER:
				json::write_to_json_value(&boost::get<metrics::timer>(metric_entry.second), &metric_value, allocator);
				break;
		}
		dump_value.AddMember(metric_entry.first.c_str(), allocator, metric_value, allocator);
	}
	{
		rapidjson::Value timestamp_value;
		json::write_to_json_value(metrics_dump::dump_timestamp, &timestamp_value);
		dump_value.AddMember("handystats.dump_timestamp", timestamp_value, allocator);
	}
	rapidjson::GenericStringBuffer<rapidjson::UTF8<>, Allocator> buffer(&allocator);
	rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<>, Allocator>> writer(buffer);
	dump_value.Accept(writer);
	auto dump_end_time = chrono::clock::now();
	return std::shared_ptr<const std::string>(new std::string(buffer.GetString(), buffer.GetSize()));
void update() {
	if (!config::metrics_dump.to_json) {
		return;
	}
	auto dump_start_time = chrono::clock::now();
	auto new_dump = create_dump<rapidjson::MemoryPoolAllocator<>>();
	a
/*
 * ResourceLocator.cpp
 *
 *  Created on: Aug 18, 2011
 *      Author: muhrin
 */
namespace sstbx {
namespace io {
namespace fs = ::boost::filesystem;
namespace algorithm = ::boost::algorithm;
ResourceLocator::ResourceLocator()
{}
ResourceLocator::ResourceLocator(const fs::path & path):
myPath(path)
{}
ResourceLocator::ResourceLocator(const fs::path & path, const ::std::string & resourceId):
myPath(path),
myResourceId(resourceId)
{}
bool ResourceLocator::set(const ::std::string & locatorString)
  typedef ::std::vector< ::std::string> SplitVector;
  if(locatorString.empty())
    return false;
  fs::path newPath;
  ::std::string newResourceId;
    
  SplitVector splitStrings;
  algorithm::split(splitStrings, locatorString, algorithm::is_any_of(ID_DELIMITER));
  if(splitStrings.size() > 2)
    return false;
  else if(splitStrings.size() == 2)
    newResourceId = splitStrings[1];
  newPath = fs::path(splitStrings[0]);
  
  setPath(newPath);
  if(!newResourceId.empty())
    setId(newReso

  return true;
::std::string ResourceLocator::string() const
  ::std::string str = myPath.string();
  if(!myResourceId.empty())
    str += ID_DELIMITER + myResourceId;
  return str;
const fs::path & ResourceLocator::path() const
  return myPath;
void ResourceLocator::setPath(const fs::path & path)
  myPath = path;
const ::std::string & ResourceLocator::id() const
  return myResourceId;
void ResourceLocator::setId(const ::std::string & resourceId)
  myResourceId = resourceId;
bool ResourceLocator::empty() const
  return myPath.empty() && myResourceId.empty();
ResourceLocator & ResourceLocator::operator =(const ResourceLocator & rhs)
  setPath(rhs.path());
  setId(rhs.id());
  return *this;
ResourceLocator &
ResourceLocator::makeRelative(const ::boost::filesystem::path & from)
  myPath = make_relative(from, myPath);
  return *this;
bool equivalent(const ResourceLocator & loc1, const ResourceLocator & loc2)
  return fs::equivalent(loc1.path(), loc2.path()) && loc1.id() == loc2.id();
Reso
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
namespace repo {
namespace core {
/*!
 */
class REPO_CORE_EXPORT RepoBinary : public RepoBSON
public:
    RepoBinary() : RepoBSON() {}
    RepoBinary(const mongo::BSONObj &obj) : RepoBSON(obj) {}
    RepoBinary(const unsigned char* bytes,
              unsigned int bytesLength,
              const string &mediaType);
    RepoBinary(const std::string
DECLARE_WXLUA_BINDFUNC(defs);
DECLARE_WXLUA_BINDFUNC(clntdata);
DECLARE_WXLUA_BINDFUNC(object);
DECLARE_WXLUA_BINDFUNC(gdiobj);
DECLARE_WXLUA_BINDFUNC(dc);
DECLARE_WXLUA_BINDFUNC(event);
DECLARE_WXLUA_BINDFUNC(window);
DECLARE_WXLUA_BINDFUNC(control);
DECLARE_WXLUA_BINDFUNC(ctrlsub);
DECLARE_WXLUA_BINDFUNC(toplevel);
DECLARE_WXLUA_BINDFUNC(treebase);
DECLARE_WXLUA_BINDFUNC(combobox);
DECLARE_WXLUA_BINDFUNC(combo);
DECLARE_WXLUA_BINDFUNC(odcombo);
DECLARE_WXLUA_BINDFUNC(aboutdlg);
DECLARE_WXLUA_BINDFUNC(accel);
DECLARE_WXLUA_BINDFUNC(anidecod);
DECLARE_WXLUA_BINDFUNC(animate);
DECLARE_WXLUA_BINDFUNC(animdecod);
DECLARE_WXLUA_BINDFUNC(artprov);
DECLARE_WXLUA_BINDFUNC(bitmap);
DECLARE_WXLUA_BINDFUNC(bookctrl);
DECLARE_WXLUA_BINDFUNC(brush);
DECLARE_WXLUA_BINDFUNC(busyinfo);
DECLARE_WXLUA_BINDFUNC(button);
DECLARE_WXLUA_BINDFUNC(calctrl);
DECLARE_WXLUA_BINDFUNC(caret);
DECLARE_WXLUA_BINDFUNC(checkbox);
DECLARE_WXLUA_BINDFUNC(checklst);
DECLARE_WXLUA_BINDFUNC(collpane);
DECLARE_WXLUA_BINDFU

DECLARE_WXLUA_BINDFUNC(cursor);
DECLARE_WXLUA_BINDFUNC(dialog);
DECLARE_WXLUA_BINDFUNC(dirctrl);
DECLARE_WXLUA_BINDFUNC(dirdlg);
DECLARE_WXLUA_BINDFUNC(dnd);
DECLARE_WXLUA_BINDFUNC(frame);
DECLARE_WXLUA_BINDFUNC(gdicmn);
DECLARE_WXLUA_BINDFUNC(image);
DECLARE_WXLUA_BINDFUNC(listbox);
DECLARE_WXLUA_BINDFUNC(menu);
DECLARE_WXLUA_BINDFUNC(msgdlg);
DECLARE_WXLUA_BINDFUNC(panel);
DECLARE_WXLUA_BINDFUNC(radiobox);
DECLARE_WXLUA_BINDFUNC(radiobut);
DECLARE_WXLUA_BINDFUNC(sizer);
DECLARE_WXLUA_BINDFUNC(spinctrl);
DECLARE_WXLUA_BINDFUNC(statbox);
DECLARE_WXLUA_BINDFUNC(stattext);
DECLARE_WXLUA_BINDFUNC(statusbar);
DECLARE_WXLUA_BINDFUNC(textctrl);
DECLARE_WXLUA_BINDFUNC(toolbar);
DECLARE_WXLUA_BINDFUNC(tooltip);
DECLARE_WXLUA_BINDFUNC(treectrl);
DECLARE_WXLUA_BINDFUNC(app);
DECLARE_WXLUA_BINDFUNC(wxstring);
DECLARE_WXLUA_BINDFUNC(version);
DECLARE_WXLUA_BINDFUNC(wxchar);
DECLARE_WXLUA_BINDFUNC(bmpcbox);
DECLARE_WXLUA_BINDFUNC(auibar);
DECLARE_WXLUA_BINDFUNC(auibook);
DECLARE_WXLUA_BINDFUNC(doc

DECLARE_WXLUA_BINDFUNC(floatpane);
DECLARE_WXLUA_BINDFUNC(framemanager);
DECLARE_WXLUA_BINDFUNC(tabmdi);
DECLARE_WXLUA_BINDFUNC(xmlres);
int luaopen_wx(lua_State* L)
    open(L);
    NEW_LUA_TABLE(wx);
        INVOKE_WXLUA_BINDFUNC(defs);
        INVOKE_WXLUA_BINDFUNC(clntdata);
        INVOKE_WXLUA_BINDFUNC(object);
        INVOKE_WXLUA_BINDFUNC(gdiobj);
        INVOKE_WXLUA_BINDFUNC(dc);
        INVOKE_WXLUA_BINDFUNC(event);
        INVOKE_WXLUA_BINDFUNC(window);
        INVOKE_WXLUA_BINDFUNC(control);
        INVOKE_WXLUA_BINDFUNC(ctrlsub);
        INVOKE_WXLUA_BINDFUNC(toplevel);
        INVOKE_WXLUA_BINDFUNC(treebase);
        INVOKE_WXLUA_BINDFUNC(combobox);
        INVOKE_WXLUA_BINDFUNC(combo);
        INVOKE_WXLUA_BINDFUNC(odcombo);
    }
    INVOKE_WXLUA_BINDFUNC(aboutdlg);
    INVOKE_WXLUA_BINDFUNC(accel);
    INVOKE_WXLUA_BINDFUNC(anidecod);
    INVOKE_WXLUA_BINDFUNC(animate);
    INVOKE_WXLUA_BINDFUNC(animdecod);
    INVOKE_WXLUA_BINDFUNC(artprov);
    INVOKE_WXLUA_BINDFUN

    INVOKE_WXLUA_BINDFUNC(bookctrl);
    INVOKE_WXLUA_BINDFUNC(brush);
    INVOKE_WXLUA_BINDFUNC(busyinfo);
    INVOKE_WXLUA_BINDFUNC(button);
    INVOKE_WXLUA_BINDFUNC(calctrl);
    INVOKE_WXLUA_BINDFUNC(caret);
    INVOKE_WXLUA_BINDFUNC(checkbox);
    INVOKE_WXLUA_BINDFUNC(listbox);
    INVOKE_WXLUA_BINDFUNC(checklst);
    INVOKE_WXLUA_BINDFUNC(collpane);
    INVOKE_WXLUA_BINDFUNC(colour);
    INVOKE_WXLUA_BINDFUNC(cursor);
    INVOKE_WXLUA_BINDFUNC(dialog);
    INVOKE_WXLUA_BINDFUNC(dirdlg);
    INVOKE_WXLUA_BINDFUNC(dnd);
    INVOKE_WXLUA_BINDFUNC(frame);
    INVOKE_WXLUA_BINDFUNC(gdicmn);
    INVOKE_WXLUA_BINDFUNC(image);
    INVOKE_WXLUA_BINDFUNC(menu);
    INVOKE_WXLUA_BINDFUNC(msgdlg);
    INVOKE_WXLUA_BINDFUNC(panel);
    INVOKE_WXLUA_BINDFUNC(sizer);
    INVOKE_WXLUA_BINDFUNC(spinctrl);
    INVOKE_WXLUA_BINDFUNC(statbox);
    INVOKE_WXLUA_BINDFUNC(radiobox);
    INVOKE_WXLUA_BINDFUNC(radiobut);
    INVOKE_WXLUA_BINDFUNC(stattext);
    INVOKE_WXLUA_BINDFUNC(statusbar);
    IN
ChunkProvider::ChunkProvider(std::string folderName)
	_folderName = folderName;
bool ChunkProvider::LoadChunk(Chunk* chunk)
	if(chunk->_fresh)
	{
		char saveFile[50];
		sprintf(saveFile,"%s/%i.%i.%i.ch",_folderName.c_str(),chunk->GetChunkX(),chunk->GetChunkY(),chunk->GetChunkZ());
		FILE *file = fopen(saveFile,"rb");
		if(file != NULL)
		{
			chunk->_initData();
			fread(chunk->_blocks,sizeof(unsigned char),chunk->_chunkWidth * chunk->_chunkHeight * chunk->_chunkWidth,file);
			fclose(file);
			chunk->_fresh = false;
			chunk->_dirty = true;
			return true;
		}
		return false;
	}
	return true;	
bool ChunkProvider::SaveChunk(Chunk* chunk)
	if(chunk->_blocks == 0)
		return false;
	char saveFile[50];
	sprintf(saveFile,"%s/%i.%i.%i.ch",_folderName.c_str(),chunk->GetChunkX(),chunk->GetChunkY(),chunk->GetChunkZ());
	FILE *file = fopen(saveFile,"wb");
	if(file != NULL)
	{
		fwrite(chunk->_blocks,sizeof(unsigned char),chunk->_chunkWidth * chunk->_chunkHeight * chunk->_chunkWidth,file);
		fclos
using namespace std;
void setupMix( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10 );
  model.add( X[4] >= -10 && X[4] <= 10 );
  model.add( X[5] >= -10 && X[5] <= 10 );
  VarArray S;
  S.add( X[0] );
  S.add( X[1] );
  S.add( X[2] );
  model.add( -X[3] + X[1] + Sum(S) == X[4] - X[5] );
  model.add( X[0] != X[1] );
  model.add( X[4] != X[5] );
  model.add( X[0] > X[4] + X[5] );
  model.add( X[3] <= X[0] + X[1] + X[2] );
  model.add( (X[0] == 3) == (X[1]+2 < 4) );
  model.add( X[X[X[4]]] > X[0] );
void setupSum1( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10 );
  model.add( X[4] >= -10 && X[4] <= 10 );
  model.add( X[5] >= -10 && X[5] <= 10 );
  
  model.add( X[1] == 1 );
  model.add( X[2] != -4 );
  mo

  model.add( X[5] == 5 );
  model.add( Sum( X ) == 25 );
void setupSum2( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10 );
  model.add( X[4] >= -10 && X[4] <= 10 );
  model.add( X[5] >= -10 && X[5] <= 10 );
  VarArray Y;
  Y.add(X[0]);
  Y.add(X[1]);
  VarArray Z;
  Z.add(X[2]);
  Z.add(X[3]);
  Z.add(X[4]);
  Z.add(X[5]);
  
  model.add( Sum( X ) == 30 );
  model.add( Sum( Y ) == Sum( Z ) );
void setupOFN( CSP& model, VarArray& X )
  model.add( X[0] >= -100 && X[0] <= 100 );
  model.add( X[1] >= -100 && X[1] <= 100 );
  model.add( X[2] >= -100 && X[2] <= 100 );
  model.add( X[3] >= -100 && X[3] <= 100 );
  model.add( X[4] >= -100 && X[4] <= 100 );
  model.add( X[5] >= -100 && X[5] <= 100 );
  model.add( X[0] == (X[1] + 3) );
  model.add( X[2] == (X[3] * 3) );
  model.add( X[3] == -X[4] );
  model.add( X[4] == -X[5] );
void setupAbs( CSP& mode

  model.add( X[0] >= -5 && X[0] <= 5 );
  model.add( X[1] >= -5 && X[1] <= 5 );
  model.add( X[2] >= -5 && X[2] <= 5 );
  model.add( X[3] >= -5 && X[3] <= 5 );
  model.add( X[4] >= -5 && X[4] <= 5 );
  model.add( X[5] >= -5 && X[5] <= 5 );
  model.add( Sum( X ) == 15 );
  model.add( Abs( (X[1] - X[0]) ) == Abs( (X[2] - X[3]) ) );
  model.add( Abs( (X[1] - X[0]) ) > Abs( (X[4] - X[5]) ) );
void setupLog( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10 );
  model.add( X[4] >= -10 && X[4] <= 10 );
  model.add( X[5] >= -10 && X[5] <= 10 );
  model.add( ( X[0] < X[1] ) || ( X[1] < X[0] ) );
  model.add( !(( X[2] == X[3] ) && ( X[4] == X[5] )) );
void setupBound( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10

  model.add( X[4] >= -10 && X[4] <= 10 );
  model.add( X[5] >= -10 && X[5] <= 10 );
  model.add( ( X[0] > 3 ) || ( X[1] >= 5 ) || ( X[2] > 7 ) );
  model.add( ( X[3] > 3 ) || ( X[4] >= 5 ) || ( X[5] > 7 ) );
  model.add( X[2] < 3 || X[5] < 3 );
void setupRanges( CSP& model, VarArray& X )
  model.add( Sum(X) == 1000 );
  model.add( X[0] == X[1] || X[0] == X[5] );
  model.add( X[2] == X[3] );
void setupOffset( CSP& model, VarArray& X )
  model.add( X[0] >= -3 && X[0] <= 3 );
  model.add( X[1] >= -3 && X[1] <= 3 );
  model.add( X[2] >= -3 && X[2] <= 3 );
  model.add( X[3] >= -3 && X[3] <= 3 );
  model.add( X[4] >= -3 && X[4] <= 3 );
  model.add( X[5] >= -3 && X[5] <= 3 );
  model.add( ( X[0] + 1 ) == Abs( X[1] - X[2] ) );
  model.add( AllDifferent( X ) );
void setupQueens( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10 );
  model.add( X[4] >= -10

  model.add( X[5] >= -10 && X[5] <= 10 );
  for(int i=1; i<X.size(); ++i)
    model.add( ( X[i-1] != X[i] ) && ( Abs( X[i-1] - X[i] ) != i ) );
  model.add( (X[5] + 0) == 1 );
void setupPreced( CSP& model, VarArray& X )
  model.add( X[0] >= -10 && X[0] <= 10 );
  model.add( X[1] >= -10 && X[1] <= 10 );
  model.add( X[2] >= -10 && X[2] <= 10 );
  model.add( X[3] >= -10 && X[3] <= 10 );
  model.add( X[4] >= -10 && X[4] <= 10 );
  model.add( X[5] >= -10 && X[5] <= 10 );
  model.add( X[0] < X[1] );
  model.add( X[1] < X[2] );
  model.add( X[2] == 3 );
  model.add( !(X[4] >= X[5]) );
  model.add( !(X[2] >= X[4]) );
void setupOFN2( CSP& model, VarArray& X )
  model.add( X[0] >= -100 && X[0] <= 100 );
  model.add( X[1] >= -100 && X[1] <= 100 );
  model.add( X[2] >= -100 && X[2] <= 100 );
  model.add( X[3] >= -100 && X[3] <= 100 );
  model.add( X[4] >= -100 && X[4] <= 100 );
  model.add( X[5] >= -100 && X[5] <= 100 );
  VarArray Y;
  Y.add(X[0]);
  Y.add(X[1]);
  VarArray Z;
  Z.add(X[2]);
  

  Z.add(X[4]);
  Z.add(X[5]);
  
  model.add( Sum( X ) == 30 );
  model.add( Sum( Y ) == Sum( Z ) );
  
  model.add( X[0] == (X[1] + 3) );
void setupSum3( CSP& model, VarArray& X )
  model.add( X[0] >= -100 && X[0] <= 100 );
  model.add( X[1] >= -100 && X[1] <= 100 );
  model.add( X[2] >= -100 && X[2] <= 100 );
  model.add( X[3] >= -100 && X[3] <= 100 );
  model.add( X[4] >= -100 && X[4] <= 100 );
  model.add( X[5] >= -100 && X[5] <= 100 );
  VarArray Y;
  Y.add(X[0]);
  Y.add(X[1]);
  VarArray Z;
  Z.add(X[2]);
  Z.add(X[3]);
  Z.add(X[4]);
  Z.add(X[5]);
  Z.add(X[5]);
  int wx[7] = {1, -2, 3, -4, 1, 3, 0};
  model.add( Sum( X, wx ) == 30 );
  int wz[6] = {3, -2, 0, -2, 2, 0};
  model.add( Sum( Y ) == Sum( Z, wz ) );
void model_and_solve( const int M ) 
  int n=6;
  CSP model;
  VarArray X(n, -1000, 1000);
  if( M < 0 ) 
    {
  
    }
  else
    {    
      switch(M) {
      case 0 :  setupMix( model, X );    break;
      case 1 :  setupSum1( model, X );   break;
      case 2 :  se
class Fragment_Type_Data_Chunk : public Chunk
public :
	Fragment_Type_Data_Chunk(Chunk_With_Children* parent,const char* name);
	Fragment_Type_Data_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
	~Fragment_Type_Data_Chunk();
	size_t size_chunk ();
	void fill_data_block (char * data_start);
	char* frag_type_name;
	int pad1,pad2,pad3;
};
class Fragment_Type_Shape_Chunk : public Chunk
public:	
	Fragment_Type_Shape_Chunk(Chunk_With_Children* parent,const char* _name,int number,ChunkVectorInt _location);
	Fragment_Type_Shape_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
	~Fragment_Type_Shape_Chunk();
	size_t size_chunk ();
	void fill_data_block (char * data_start);
	int num_fragments;
	ChunkVectorInt location;
	char* name;
	int pad1,pad2,pad3;	
};
class Fragment_Type_Sound_Chunk : public Chunk
public:	
	Fragment_Type_Sound_Chunk(Chunk_With_Children* parent);
	Fragment_Type_Sound_Chunk (Chunk_With_Children * const parent,const char *, size_t c
using namespace BasicEngine;
using namespace Managers;
using namespace Rendering;
Models_Manager::Models_Manager()
Models_Manager::~Models_Manager()
	for (auto model: gameModelList)
	{
		delete model.second;
	}
	gameModelList.clear();
	for (auto model : gameModelList_NDC)
	{
		delete model.second;
	}
	gameModelList_NDC.clear();
void Models_Manager::Update()
	for (auto model: gameModelList)
	{
		model.second->Update();
	}
	for (auto model : gameModelList_NDC)
	{
		model.second->Update();
	}
void Models_Manager::Draw()
	for (auto model : gameModelList_NDC)
	{
		model.second->Draw();
	}
void Models_Manager::Draw(const glm::mat4& projection_matrix, const glm::mat4& view_matrix)
	for (auto model : gameModelList)
	{
		model.second->Draw(projection_matrix, view_matrix);
	}
void Models_Manager::DeleteModel(const std::string& gameModelName)
	IGameObject* model = gameModelList[gameModelName];
	model->Destroy();
	gameModelList.erase(gameModelName);
void Models_Manager::DeleteModel_NDC(const std::
using namespace std;
namespace Model
    namespace TableModel
    {
        ModelForeignKey::ModelForeignKey(const ModelForeignKey& foreignKey):
            ModelForeignKey(foreignKey.mModel, foreignKey.mId)
        {
        }
        ModelForeignKey::ModelForeignKey():
            ModelForeignKey(NULL, -1)
        {
        }
        ModelForeignKey::ModelForeignKey(Model* model, int id):
            mModel(NULL),
            mId(0)
        {
            init(model, id);
        }
        ModelForeignKey::~ModelForeignKey(){
            deleteReference();
        }
        void ModelForeignKey::init(Model* model, int id){
            deleteReference();
            mModel=model;
            mId=id;
            addReference();
        }
        bool ModelForeignKey::setId(int id){
            if(mModel==NULL){
                return false;
            }
            deleteReference();
            mId=id;
            addReference();
            return true;
        }
        int ModelFor
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
namespace repo {
namespace core {
class REPO_CORE_EXPORT RepoGraphOptimizer
public:
    RepoGraphOptimizer(RepoGraphScene* scene);
    ~RepoGraphOptimizer() {}
    void collapseSingleMeshTransformations();
    void collapseSingleMeshTransformations(RepoNodeMesh* mesh);
    void collapseZeroMeshTransformations();
    RepoGraphScene* getScene() const 
/***********************************************************************
ChunkedArray - Data structure to store lists of elements in page-aligned
chunks of memory.
Copyright (c) 2005 Oliver Kreylos
This file is part of the Miscellaneous Support Library (Misc).
The Miscellaneous Support Library is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
The Miscellaneous Support Library is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along
with the Miscellaneous Support Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA
****

namespace Misc {
template <class ContentParam,size_t pageSizeParam =8192>
class ChunkedArray
	{
	/* Embedded classes: */
	public:
	private:
	struct Chunk;
		{
		/* Elements: */
		public:
		
		/* Constructors and destructors: */
		ChunkHeader(void)
			:succ(0),numElements(0)
			{
			}
		};
		{
		/* Elements: */
		public:
		char mem[pageSize-sizeof(ChunkHeader)];
		
		/* Methods: */
		const Content& operator[](size_t index) const
			{
			return reinterpret_cast<const Content*>(mem)[index];
			}
		Content& operator[](size_t index)
			{
			return reinterpret_cast<Content*>(mem)[index];
			}
		const Content* getAddress(size_t index) const
			{
			return reinterpret_cast<const Content*>(mem)+index;
			}
		Content* getAddress(size_t index)
			{
			return reinterpret_cast<Content*>(mem)+index;
			}
		};
	public:
	class const_iterator;
	class iterator
		{
		friend class ChunkedArray;
		friend class const_iterator;
		
		/* Elements: */
		private:
		
		/* Constructors and destructors: */
		publi

			:chunk(0),index(0)
			{
			}
		private:
			:chunk(sChunk),index(0)
			{
			}
		
		/* Methods: */
		public:
		bool operator==(const iterator& other) const
			{
			return chunk==other.chunk&&index==other.index;
			}
		bool operator!=(const iterator& other) const
			{
			return chunk!=other.chunk||index!=other.index;
			}
		Content& operator*(void) const
			{
			return (*chunk)[index];
			}
		Content* operator->(void) const
			{
			return chunk->getAddress(index);
			}
		iterator& operator++(void)
			{
			++index;
			if(index==chunk->header.numElements)
				{
				chunk=chunk->header.succ;
				index=0;
				}
			return *this;
			}
		iterator operator++(int)
			{
			iterator result(*this);
			++index;
			if(index==chunk->header.numElements)
				{
				chunk=chunk->header.succ;
				index=0;
				}
			return result;
			}
		};
	class const_iterator
		{
		friend class ChunkedArray;
		
		/* Elements: */
		private:
		
		/* Constructors and destructors: */
		public:
			:chunk(0),index(0)
			{
			

			:chunk(source.chunk),index(source.index)
			{
			}
		private:
			:chunk(sChunk),index(0)
			{
			}
		
		/* Methods: */
		public:
		bool operator==(const const_iterator& other) const
			{
			return chunk==other.chunk&&index==other.index;
			}
		bool operator==(const iterator& other) const
			{
			return chunk==other.chunk&&index==other.index;
			}
		bool operator!=(const const_iterator& other) const
			{
			return chunk!=other.chunk||index!=other.index;
			}
		bool operator!=(const iterator& other) const
			{
			return chunk!=other.chunk||index!=other.index;
			}
		const Content& operator*(void) const
			{
			return (*chunk)[index];
			}
		const Content* operator->(void) const
			{
			return chunk->getAddress(index);
			}
		const_iterator& operator++(void)
			{
			++index;
			if(index==chunk->header.numElements)
				{
				chunk=chunk->header.succ;
				index=0;
				}
			return *this;
			}
		const_iterator operator++(int)
			{
			const_iterator result(*this);
			++index;
			if(index==

				{
				chunk=chunk->header.succ;
				index=0;
				}
			return result;
			}
		};
	/* Elements: */
	private:
	/* Constructors and destructors: */
	public:
		:firstChunk(0),lastChunk(0)
		{
		}
	private:
	public:
		{
		clear();
		}
	/* Methods: */
		{
		return firstChunk==0;
		}
		{
		size_t result=0;
		for(const Chunk* chPtr=firstChunk;chPtr!=0;chPtr=chPtr->header.succ)
			result+=chPtr->header.numElements;
		return result;
		}
		{
		return (*lastChunk)[lastChunk->header.numElements-1];
		}
		{
		return (*lastChunk)[lastChunk->header.numElements-1];
		}
		{
		/* Check for empty array first: */
		if(lastChunk==0)
			{
			/* Create the first chunk: */
			firstChunk=new Chunk;
			lastChunk=firstChunk;
			}
		
		/* Check if there is room in the last chunk: */
		if(lastChunk->header.numElements==chunkSize)
			{
			/* Create a new chunk: */
			lastChunk->header.succ=new Chunk;
			lastChunk=lastChunk->header.succ;
			}
		
		/* Append the new element to the last chunk: */
		new(lastChunk->ge

		
		/* Increase the element count of the last chunk: */
		++lastChunk->header.numElements;
		}
		{
		/* Decrease the element count of the last chunk: */
		--lastChunk->header.numElements;
		
		/* Destroy the last element: */
		(*lastChunk)[lastChunk->header.numElements].~Content();
		
		/* Remove last chunk if it is empty: */
		if(lastChunk->header.numElements==0)
			{
			/* Find pointer to but-last chunk: */
			Chunk* chPtr1=0;
			for(Chunk* chPtr2=firstChunk;chPtr2!=lastChunk;chPtr1=chPtr2,chPtr2=chPtr2->header.succ)
				;
			
			/* Remove last chunk: */
			delete lastChunk;
			lastChunk=chPtr1;
			
			/* Check for empty array: */
			if(lastChunk==0)
				firstChunk=0;
			}
		}
		{
		while(firstChunk!=0)
			{
			Chunk* succ=firstChunk->header.succ;
			
			/* Destroy all elements in the chunk: */
			for(size_t i=0;i<firstChunk->header.numElements;++i)
				(*firstChunk)[i].~Content();
			
			/* Delete the chunk: */
			delete firstChunk;
			
			firstChunk=succ;
			}
		lastChunk=0;
		}


		return const_iterator(firstChunk);
		}
		{
		return iterator(firstChunk);
		}
		{
		return const_iterator();
		}
		{
		return iterator();
		}
	template <class FunctorParam>
		{
		/* Iterate through all chunks: */
		for(const Chunk* chunkPtr=firstChunk;chunkPtr!=0;chunkPtr=chunkPtr->header.succ)
			{
			/* Iterate through all elements in the chunk: */
			for(size_t i=0;i<chunkPtr->header.numElements;++i)
				{
				/* Apply the functor to the element: */
				functor((*chunkPtr)[i]);
				}
			}
		}
	template <class FunctorParam>
		{
		/* Iterate through all chunks: */
		for(Chunk* chunkPtr=firstChunk;chunkPtr!=0;chunkPtr=chunkPtr->header.succ)
			{
			/* Iterate through all elements in the chunk: */
			for(size_t i=0;i<chunkPtr->header.numElements;++i)
				{
				/* Apply the functor to the element: */
				functor((*chunkPtr)[i]);
				}
			}
		}
	template <class FunctorParam>
		{
		/* Iterate through all chunks: */
		for(const Chunk* chunkPtr=firstChunk;chunkPtr!=0;chunkPtr=chunkPtr->he
using namespace std;
namespace openflShareExtension {
	void log(const char *msg) {
		/*
		FILE *logFile = fopen("logs/log.txt", "a");
		fprintf(logFile, "%s\n", msg);
		fclose(logFile);
		*/
	}
	void doShare(const char *method, const char *text) {
		navigator_invoke_invocation_t *invoke = NULL;
		navigator_invoke_invocation_create(&invoke);
		navigator_invoke_invocation_set_action(invoke, "bb.action.SHARE");
		navigator_invoke_invocation_set_data(invoke, text, strlen(text));
		navigator_invoke_invocation_set_target(invoke, method);
		navigator_invoke_invocation_set_type(invoke, "text/plain");
		navigator_invoke_invocation_send(invoke);
		navigator_invoke_invocation_destroy(invoke);
	}
	vector<ShareQueryResult> query() {
		/*
		FILE *logFile = fopen("logs/log.txt", "w");
		fclose(logFile);
		char msg[64];
		*/
		/*
		snprintf(msg, 64, "pid %d\n", getpid());
		log(msg);
		*/
		vector<ShareQueryResult> results;
		navigator_invoke_query_t *query = NULL;
		navigator_invoke_query_create(&que

		navigator_invoke_query_set_id(query, "12345");
		navigator_invoke_query_set_action(query, "bb.action.SHARE");
		navigator_invoke_query_set_type(query, "text/plain");
		if (navigator_invoke_query_send(query)!=BPS_SUCCESS) {
			log("navigator_invoke_query_send Failed");
		}
		bps_event_t *event = NULL;
		do {
			bps_get_event(&event, -1);
			/*
			log(msg);
			*/
		} while (
			navigator_get_domain()!=bps_event_get_domain(event) ||
			bps_event_get_code(event)!=NAVIGATOR_INVOKE_QUERY_RESULT
		);
		int action_count =
			navigator_invoke_event_get_query_result_action_count(event);
		for (int i=0; i<action_count; i++) {
			const navigator_invoke_query_result_action_t *action =
				navigator_invoke_event_get_query_result_action(event, i);
			const char *name =
				navigator_invoke_query_result_action_get_name(action);
			const char *icon =
				navigator_invoke_query_result_action_get_icon(action);
			const char *label =
				navigator_invoke_query_result_action_get_label(action);
			int ta
/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   Steve Plimpton, sjplimp@sandia.gov
   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.
   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------
   Contributing author:  Axel Kohlmeyer (Temple U)
------------------------------------------------------------------------- */
using namespace LAMMPS_NS;
/* ---------------------------------------------------------------------- */
void WriteDump::command(int narg, char **arg)
  if (narg < 3) error->all(FLERR,"Illegal write_dump command");
  int modindex;
 
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
free_string_gen_class::generate_free_string(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (has_string_type)
    {
      stream << "if (";
      generate_string (structure, stream, indent + indent_str.length ());
      stream << "->";
      generate_string (opt_var, stream, indent + indent_str.length ());
      stream << "_arg)";
      stream << "\n";
      stream << indent_str;
      stream << "  {";
      stream << "\n";
      stream << indent_str;
      stream << "    free (";
      generate_string (structure, stream, indent + indent_str.length ());
      stream << "->";
      generate_string (opt_var, stream, indent + indent_str.length ());
      stream << "_arg); /* free ";
      generate_string (comment, stream, indent + indent_str.length ());
      stream << " */";
      stream << "\n";
      stream << indent_str;
      indent = 4;
      stream << "    ";

      generate_string (structure, stream, indent + indent_str.length ());
      stream << "->";
      generate_string (opt_var, stream, indent + indent_str.length ());
      stream << "_arg = 0;";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "  }";
      stream << "\n";
      stream << indent_str;
    }
  stream << "if (";
  generate_string (structure, stream, indent + indent_str.length ());
  stream << "->";
  generate_string (opt_var, stream, indent + indent_str.length ());
  stream << "_orig)";
  stream << "\n";
  stream << indent_str;
  stream << "  {";
  stream << "\n";
  stream << indent_str;
  stream << "    free (";
  generate_string (structure, stream, indent + indent_str.length ());
  stream << "->";
  generate_string (opt_var, stream, indent + indent_str.length ());
  stream << "_orig); /* free ";
  generate_string (comment, stream, indent + indent_str.length ());
  stream << " */";
  stream << "\n";
  stream << indent_str;
  indent = 
using namespace std;
int main(){
    BTree B;
    int key;
    string add;
    
    cout << "Enter int(key) string(data) pair to insert (Control-D to quit) " << endl;
/*    while( cin >> key >> add ) {
        B.insert(key, add);
    }*/
    B.dump();
     
    B.insert(1, "apple");
    cout << "----printing tree----\n";
    B.dump();
    
    
    B.insert(2, "baby");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(3, "carrot");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(4, "dog");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(5, "eat");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(6, "fly");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(7, "giggle");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(8, "hello");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(9, "island");
    cout << "----printing tree----\n";
    

    
    B.insert(10, "joy");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(11, "kind");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(12, "light");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(13, "merry");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(14, "nice");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(15, "orange");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(16, "puppy");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(17, "quite");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(18, "rose");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(19, "sandy");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(20, "tree");
    cout << "----printing tree----\n";
    B.dump();
    B.insert(21, "uncle");
    cout << "----printing tree----\n";
   
namespace {
  hsize_t g_chunkSize = 0;
namespace O2OTranslator {
hsize_t 
CvtOptions::chunkSize(const hdf5pp::Type& type) const
  return chunkSize(m_chunkSizeBytes, type, ::g_chunkSize);
void 
CvtOptions::setChunkSize(hsize_t chunkSize)
  ::g_chunkSize = chunkSize;
/**
 *  @brief Returns HDF5 chunk size counted in objects of given HDF5 type.
 *
 *  This method calculates chunk size like it is described above but
 *  instead of taking into account value set with the setChunkSize() method
 *  it uses additional parameter.
 */
hsize_t
CvtOptions::chunkSize(hsize_t chunkSizeBytes, const hdf5pp::Type& type, hsize_t chunkSize)
  size_t obj_size = type.size();
  hsize_t chunk = chunkSize > 0 ? chunkSize : chunkSizeBytes / obj_size;
  if (chunk > ::max_objects_per_chunk) {
    chunk = ::max_objects_per_chunk;
  } else if (chunk < ::min_objects_per_chunk) {
    chunk = ::min_objects_per_chunk;
  }
  if (chunk*obj_size > ::abs_max_chunk_size) {
    chunk = ::abs_max_chunk_size / obj_size;
    if
/*
 * This class's main job is to store all the models
 * and provide to the UnitBlock variables when needed.
 */
using namespace std;
enum eBlockType;
class ModelManager {
private:
	Model								*pModel1x1x1Upper;
	Model								*pModel1x1x1Lower;
	Model								*pModel1x2x1Upper;
	Model								*pModel1x2x1Lower;
	Model								*pModel2x1x1Upper;
	Model								*pModel2x1x1Lower;
	Model								*pModel2x2x1Upper;/*yakexi*/
	Model								*pModel2x2x1Lower;
	Model								*pModel3x1x1Upper;
	Model								*pModel3x1x1Lower;
	Model								*pModel3x1x2Upper;
	Model								*pModel3x1x2Lower;
	Model								*pModel4x1x1Upper;
	Model								*pModel4x1x1Lower;
	Model								*pModel4x1x2Upper;
	Model								*pModel4x1x2Lower;
	Model								*pModelSaberStand;
	Model								*pModelSaberLeft;
	Model								*pModelSaberRight;
	bool								PreloadModel(Model*& model, const char *filename);
	bool								UnloadModel(Model*& model);
	inline Model						*GetModel1x1x1Upper() const					{ return pModel1x1x1Upper;

	inline Model						*GetModel1x1x1Lower() const					{ return pModel1x1x1Lower; }
	inline Model						*GetModel1x2x1Upper() const					{ return pModel1x2x1Upper; }
	inline Model						*GetModel1x2x1Lower() const					{ return pModel1x2x1Lower; }
	inline Model						*GetModel2x1x1Upper() const					{ return pModel2x1x1Upper; }
	inline Model						*GetModel2x1x1Lower() const					{ return pModel2x1x1Lower; }
	inline Model						*GetModel2x2x1Upper() const					{ return pModel2x2x1Upper; }/*yakexi*/
	inline Model						*GetModel2x2x1Lower() const					{ return pModel2x2x1Lower; }
	inline Model						*GetModel3x1x1Upper() const					{ return pModel3x1x1Upper; }
	inline Model						*GetModel3x1x1Lower() const					{ return pModel3x1x1Lower; }
	inline Model						*GetModel3x1x2Upper() const					{ return pModel3x1x2Upper; }
	inline Model						*GetModel3x1x2Lower() const					{ return pModel3x1x2Lower; }
	inline Model						*GetModel4x1x1Upper() const					{ return pModel4x1x1Upper; }
	inline Model						*GetModel4
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
multiple_option_gen_class::generate_multiple_option(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (has_short_option)
    {
      stream << "case '";
      generate_string (short_option, stream, indent + indent_str.length ());
      stream << "':	/* ";
      generate_string (option_comment, stream, indent + indent_str.length ());
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "/* ";
      generate_string (option_comment, stream, indent + indent_str.length ());
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      generate_string (gen_else, stream, indent + indent_str.length ());
      stream << "if (strcmp (long_options[option_index].name, \"";
      generate_string (long_option, stream, indent + indent_str.length ());
      stream << "\") == 0)";
      stream << "\n";
    

      stream << "{";
      stream << "\n";
      stream << indent_str;
    }
  stream << "  local_args_info.";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given++;";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  if (option_has_type)
    {
      stream << "  multi_token = get_multiple_arg_token(optarg);";
      stream << "\n";
      stream << indent_str;
      stream << "  multi_next = get_multiple_arg_token_next (optarg);";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "  while (1)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      if (option_has_values)
        {
          stream << "      if ((found = check_possible_values((multi_token ? multi_token : ";
          if (( defaultval != "" ))
            {
              stream << "\"";
              ge

              stream << "\" ";
            }
          else
            {
              stream << "0 ";
            }
          stream << "), ";
          generate_string (option_values, stream, indent + indent_str.length ());
          stream << ")) < 0)";
          stream << "\n";
          stream << indent_str;
          stream << "        {";
          stream << "\n";
          stream << indent_str;
          stream << "          fprintf (stderr, \"%s: %s argument, \\\"%s\\\", for option `--";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << "'";
          if (has_short_option)
            {
              stream << " (`-";
              generate_string (short_option, stream, indent + indent_str.length ());
              stream << "')";
            }
          stream << "%s\\n\", ";
          generate_string (package_var_name, stream, indent + indent_str.length ());
          stream << ", (found == -2) ? \"ambiguous\" : \"invalid\"

          stream << "\n";
          stream << indent_str;
          stream << "          free (multi_token);";
          stream << "\n";
          stream << indent_str;
          stream << "          goto failure;";
          stream << "\n";
          stream << indent_str;
          stream << "        }";
          stream << "\n";
          stream << indent_str;
          stream << "\n";
          stream << indent_str;
        }
      stream << "      ";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_new = (struct ";
      generate_string (type, stream, indent + indent_str.length ());
      stream << "_list *) malloc (sizeof (struct ";
      generate_string (type, stream, indent + indent_str.length ());
      stream << "_list));";
      stream << "\n";
      stream << indent_str;
      indent = 6;
      stream << "      ";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_new->next = ";


      stream << "_list;";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      indent = 6;
      stream << "      ";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_list = ";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_new;";
      indent = 0;
      stream << "\n";
      stream << indent_str;
      indent = 6;
      stream << "      ";
      generate_string (update_arg, stream, indent + indent_str.length ());
      indent = 0;
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      stream << "      if (multi_next)";
      stream << "\n";
      stream << indent_str;
      stream << "        {";
      stream << "\n";
      stream << indent_str;
      stream << "          multi_token = get_multiple_arg_token(multi_next);";
      stream << "\n";
      stream << indent_str;
      stream << "          multi_next = get_

      stream << "\n";
      stream << indent_str;
      stream << "          local_args_info.";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_given++;";
      stream << "\n";
      stream << indent_str;
      stream << "        }";
      stream << "\n";
      stream << indent_str;
      stream << "      else";
      stream << "\n";
      stream << indent_str;
      stream << "        break;";
      stream << "\n";
      stream << indent_str;
      stream << "    }";
      stream << "\n";
      stream << indent_str;
    }
  if (option_has_group)
    {
      stream << "  if (!args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_group)";
      stream << "\n";
      stream << indent_str;
      stream << "    {";
      stream << "\n";
      stream << indent_str;
      stream << "      args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
   
using namespace QInstaller;
class tst_Repository : public QObject
    Q_OBJECT
private slots:
    void testRepository()
    {
        Repository repo;
        QCOMPARE(repo.isValid(), false);
        QCOMPARE(repo.isDefault(), false);
        QCOMPARE(repo.isEnabled(), false);
        QCOMPARE(repo.url(), QUrl());
        QCOMPARE(repo.username(), QString());
        QCOMPARE(repo.password(), QString());
        QCOMPARE(repo.isValid(), true);
        repo.setEnabled(true);
        QCOMPARE(repo.isEnabled(), true);
        repo.setUsername("tester");
        QCOMPARE(repo.username(), QString("tester"));
        repo.setPassword("test");
        QCOMPARE(repo.password(), QString("test"));
    }
    void testRepositoryFromUrl()
    {
        QCOMPARE(repo.isValid(), true);
        QCOMPARE(repo.isDefault(), true);
        QCOMPARE(repo.isEnabled(), true);
        QCOMPARE(repo.username(), QString());
        QCOMPARE(repo.password(), QString());
        repo.setUrl(QUrl());
        QCOMP

        repo.setEnabled(false);
        QCOMPARE(repo.isEnabled(), false);
        repo.setUsername("tester");
        QCOMPARE(repo.username(), QString("tester"));
        repo.setPassword("test");
        QCOMPARE(repo.password(), QString("test"));
    }
    void testRepositoryFromUserInput()
    {
        QCOMPARE(repo.isValid(), true);
        QCOMPARE(repo.isDefault(), false);
        QCOMPARE(repo.isEnabled(), true);
        QCOMPARE(repo.username(), QString("tester"));
        QCOMPARE(repo.password(), QString("test"));
        repo.setUrl(QUrl());
        QCOMPARE(repo.isValid(), false);
        repo.setEnabled(false);
        QCOMPARE(repo.isEnabled(), false);
        repo.setUsername("");
        QCOMPARE(repo.username(), QString());
        repo.setPassword("");
        QCOMPARE(repo.password(), QString());
    }
    void testRepositoryOperators()
    {
        Repository lhs, rhs;
        QVERIFY(lhs == rhs);
        QVERIFY(lhs != rhs);
        Repository clhs(rhs);
     
/* 
 * File:   RepoClient.h
 * Author: johadunf
 *
 * Created on May 20, 2014, 6:52 PM
 */
typedef std::vector<std::string> StringVector;
typedef std::pair<RepositoryInfo, std::string> RepoFile;
typedef std::map<int, RepoFile> FileCache;
class RepoCommand {
public:
    std::string cmd;
    StringVector args;
};
class RepoClient {
public:
    RepoClient() {
        globalFileIndex = 0;
    }
    /**
     * Process client input for handling remote rev files
     * 
     * @param command   Command to process
     * @return          Returns true if command was relevant, otherwise false
     */
    bool processCommand(std::vector<RepositoryInfo> repositories, std::string cmd) {
        boost::trim(cmd);
        if(cmd.size() == 0){
            return false;
        }
        
        RepoCommand rc;
        boost::split(rc.args, cmd, boost::is_any_of(" "));
        rc.cmd = pop_front(rc.args);
        if (rc.cmd == "repo_list") {
            globalFileIndex = 0;
            BOOST_FOREACH(Re

                if (browser) {
                    HttpResponse httpResponse = browser->getIndex();
                    httpResponse.data = pushIndex(repo, httpResponse.data);
                    repoObserver->notifyGetIndexComplete(httpResponse, repo);
                }
            }
            return true;
        } else if (rc.cmd == "repo_get") {
            if (fileCache.size() <= 0) {
                repoObserver->notifyError("Cache not set, initializing now... Try download again when complete!");
                processCommand(repositories, "repo_list");
                return true;
            }
            std::string error = "Valid syntax to download a file is:\n 1) repo-get <file index>\n 2) repo-get <repository>.<filename>";
            if (rc.args.size() != 1) {
                repoObserver->notifyError(error);
                return true;
            }
            int index;
            try {
                index = boost::lexical_cast<int>(rc.args.at(0));
            }

                repoObserver->notifyError(error);
                return true;
            }
            if (!fileCache.count(index)) {
                repoObserver->notifyError("The provided file index does not exist.");
                return true;
            }
            RepositoryInfo repo = fileCache[index].first;
            if (browser) {
                repoObserver->notifyGetFileComplete(browser->getFile(fileCache[index].second), repo);
                return true;
            }
            repoObserver->notifyError("Error, something went wrong requesting file at '" + repo.GetName() + "'.");
            return true;
        }
        return false;
    }
    static StringVector getHelp() {
        StringVector v;
        return v;
    }
    void setObserver(IRepoObserver *repoObserver) {
        this->repoObserver = repoObserver;
    }
private:
    IRepoObserver *repoObserver;
    int globalFileIndex;
    FileCache fileCache;
    StringVector pushIndex(RepositoryInfo repo, S
namespace MCServer {
namespace {
BlockAccess<1>::BlockAccess(Chunk &chunk)
:chunk(chunk) {
BlockAccess<2> BlockAccess<1>::operator[](int x) {
    return BlockAccess<2>(chunk, x);
ConstBlockAccess<2> BlockAccess<1>::operator[](int x) const {
    return BlockAccess<2>(chunk, x);
BlockAccess<1>::operator ConstBlockAccess<1>() const {
    return ConstBlockAccess<1>(chunk);
BlockAccess<2>::BlockAccess(Chunk &chunk, int x)
:chunk(chunk), x(x) {
BlockAccess<3> BlockAccess<2>::operator[](int z) {
    return BlockAccess<3>(chunk, x, z);
ConstBlockAccess<3> BlockAccess<2>::operator[](int z) const {
    return ConstBlockAccess<3>(chunk, x, z);
BlockAccess<2>::operator ConstBlockAccess<2>() const {
    return ConstBlockAccess<2>(chunk, x);
BlockAccess<3>::BlockAccess(Chunk &chunk, int x, int z)
:chunk(chunk), x(x), z(z) {
Block BlockAccess<3>::operator[](int y) {
    return Block(chunk, x, y, z);
const Block BlockAccess<3>::operator[](int y) const {
    return Block(chunk, x, y, z);
BlockAccess<3>
static void sampleListAppend(QQmlListProperty<SampleData> *prop, SampleData *val)
    SampleListModelPrivate *d = static_cast<SampleListModelPrivate*>(prop->data);
    d->sampleListData.append(val);
static SampleData *sampleListAt(QQmlListProperty<SampleData> *prop, int index)
    return (static_cast<SampleListModelPrivate*>(prop->data))->sampleListData.at(index);
    }
static int sampleListCount(QQmlListProperty<SampleData> *prop)
    return static_cast<SampleListModelPrivate*>(prop->data)->sampleListData.size();
static void sampleListClear(QQmlListProperty<SampleData> *prop)
    static_cast<SampleListModelPrivate*>(prop->data)->sampleListData.clear();
SampleListModel::SampleListModel(QObject *parent) :
    QObject(parent),
    d(new SampleListModelPrivate)
    d->isPopulated = false;
    d->sampleList
            = new QQmlListProperty<SampleData>(this, d,
                                               sampleListAppend,
                                               sampleListCount,

GameLoadingScene* GameLoadingScene::nodeWithChapter(int chapter, int level) {
  GameLoadingScene* scene = new GameLoadingScene(chapter, level);
  scene->autorelease();
  scene->init();
  return scene;
GameLoadingScene::GameLoadingScene(int chapter, int level) : chapter_(chapter), level_(level) {
  
void GameLoadingScene::setupTasks() {  
  loadTasks_.push(new SpriteSheetLoadTask("fonts.plist"));
  loadTasks_.push(new SpriteSheetLoadTask("game_assets.plist"));
  loadTasks_.push(new SpriteSheetLoadTask("game.plist"));
  loadTasks_.push(new SpriteSheetLoadTask("transition.plist"));
  
  switch (chapter_) {
    case 0:
      loadTasks_.push(new SpriteSheetLoadTask("country_backgrounds.plist"));
      break;
      
    case 1:
      loadTasks_.push(new SpriteSheetLoadTask("city_backgrounds.plist"));
      break;
      
    case 2:
      loadTasks_.push(new SpriteSheetLoadTask("jungle_backgrounds.plist"));
      break;
      
    default:
      break;
  }
  loadTasks_.push(new MusicLoadTask(

  
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_01.mp3"));
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_07.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_medium_08.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_05.mp3")); 
  loadTasks_.push(new So

  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_07.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_low_08.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_07.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_high_08.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_2nd_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_2nd_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_2nd_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask(

  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_2nd_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_launch_2nd_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_idle_pose_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_idle_pose_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_idle_pose_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_idle_pose_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_idle_pose_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_

  loadTasks_.push(new SoundEffectLoadTask("kh_voc_full_power_08.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_falling_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_falling_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_falling_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_falling_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_falling_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_falling_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_voc_cat_collect_

  
  int levelCount = ChapterData::forChapter(chapter_).levels();
  for (int i = 0; i < levelCount; i++) {
    String filePath = String::withFormat("%d_%02d.level", chapter_ + 1, i + 1);
    loadTasks_.push(new ChapterDataLoadTask(filePath));    
  }
  
  
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_rocket_power_up_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_rocket_launch_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_rocket_full_power_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_pickup_good_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_pickup_cat_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_parachute_open_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_parachute_open_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_03.

  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_05.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_06.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_fail_horn_07.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_crashland_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_crashland_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_crashland_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_crashland_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_collide_close_up_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_collide_close_up_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_collide_close_up_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_collide_close_up_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_cat_sad_01.mp3")); 
  loadTasks_.push(new SoundEffectLoad

  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_grapple_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_points_blip_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_grapple_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_grapple_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_music_ident_04.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_menu_click_01.mp3"));
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_cat_meow_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_cat_meow_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_collect_key_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_award_pop_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_award_pop_02.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_award_pop_03.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_teleport_01.mp3")); 
  loadTasks_.push(new SoundEffectLoadTask("kh_sfx_points_blip_end_01.m
/**
 * Implementation of the factory used to create event locators in this plugin
 */
/**
 * Constructor
 */
EventLocatorFactory::EventLocatorFactory() :
   Factory           (Gmat::EVENT_LOCATOR)
   if (creatables.empty())
   {
      creatables.push_back("EclipseLocator");
      creatables.push_back("ContactLocator");
   }
/**
 * Destructor
 */
EventLocatorFactory::~EventLocatorFactory()
/**
 * Copy constructor
 *
 * @param elf The factory copied here
 */
EventLocatorFactory::EventLocatorFactory(const EventLocatorFactory& elf) :
   Factory           (elf)
   if (creatables.empty())
   {
      creatables.push_back("EclipseLocator");
      creatables.push_back("ContactLocator");
   }
/**
 * Assignment operator
 *
 * @param elf The factory copied to this one
 *
 * @return this instance, set to match elf
 */
EventLocatorFactory& EventLocatorFactory::operator=(
      const EventLocatorFactory& elf)
   if (this != &elf)
   {
      Factory::operator=(elf);
      if (creatables.empty())
     
/*
 * BaseLocator.cpp - Methods for BaseLocator class.
 * 
 * Author: Patrick O'Leary
 * Created: June 3, 2010
 * Copyright 2010. All rights reserved.
 */
/*
 * BaseLocator
 * 
 * parameter _locatorTool - Vrui::LocatorTool*
 * parameter _rocket - Rocket*
 */
BaseLocator::BaseLocator(Vrui::LocatorTool* _locatorTool, Rocket* _rocket) :
	Vrui::LocatorToolAdapter(_locatorTool) {
	rocket = _rocket;
/*
 * ~BaseLocator - Destructor
 */
BaseLocator::~BaseLocator(void) {
	rocket = 0;
/*
 * highlightLocator - Render actual locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::highlightLocator(GLContextData& glContextData) const {
/*
 * glRenderAction - Render opaque elements of locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::glRenderAction(GLContextData& glContextData) const {
/*
 * glRenderActionTransparent - Render transparent elements of locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::glRenderActionTransparent
void doDalitzKKK(Int_t seed = 9){
   gSystem->Load("libPhysics.so");
   gSystem->Load("libRooFit.so");
  gROOT->LoadMacro("twoDStyle.C");
  gROOT->LoadMacro("histoUtils.C");
  twoDStyle();
  gROOT->LoadMacro("AbsComplexBrackets.C+");
  gROOT->LoadMacro("AbsComplex.C+");
  gROOT->LoadMacro("AbsComplexPdf.C+");
  gROOT->LoadMacro("dataThrowerAway.C+");
  gROOT->LoadMacro("ComplexProxy.C+");
  gROOT->LoadMacro("ComplexBW.C+");
  gROOT->LoadMacro("DcyAmplitude.C+");
  gROOT->LoadMacro("DcyCoupledAmplitude.C+");
  gROOT->LoadMacro("DcyGSAmplitude.C+");
  gROOT->LoadMacro("DcyNonRes.C+");
  gROOT->LoadMacro("DbleAmplitude.C+");
  gROOT->LoadMacro("Resonance.C+");
  gROOT->LoadMacro("ComplexSum.C+");
  gROOT->LoadMacro("ComplexProd.C+");
  gROOT->LoadMacro("RooAbsPhaseSpace.C+");
  gROOT->LoadMacro("Roo3BodyPhaseSpace.C+");
  gROOT->LoadMacro("Calculate4BodyProps.h+");
  gROOT->LoadMacro("SpinFactorThreeBody.C+");
  gROOT->LoadMacro("SpinFactor.C+");
  gROOT->LoadMacro("SpinFactors.C+");
  gR
namespace cuke {
namespace internal {
StepInfo::StepInfo(const std::string &stepMatcher, const std::string source) :
    regex(stepMatcher),
    source(source) {
    static step_id_type currentId = 0;
    id = ++currentId;
SingleStepMatch StepInfo::matches(const std::string &stepDescription) {
    SingleStepMatch stepMatch;
    shared_ptr<RegexMatch> regexMatch(regex.find(stepDescription));
    if (regexMatch->matches()) {
        stepMatch.stepInfo = this;
        stepMatch.submatches = regexMatch->getSubmatches();
    }
    return stepMatch;
SingleStepMatch::SingleStepMatch() :
    stepInfo(0) {
SingleStepMatch::SingleStepMatch(const SingleStepMatch &match) :
    stepInfo(match.stepInfo),
    submatches(match.submatches) {
SingleStepMatch & SingleStepMatch::operator =(const SingleStepMatch &match) {
    stepInfo = match.stepInfo;
    submatches = match.submatches;
    return *this;
SingleStepMatch::operator void *() {
    return (void *) stepInfo;
MatchResult::operator void *() {
   

MatchResult::operator bool() {
    return !resultSet.empty();
const MatchResult::match_results_type MatchResult::getResultSet() {
    return resultSet;
void MatchResult::addMatch(SingleStepMatch match) {
    resultSet.push_back(match);
void InvokeArgs::addArg(const std::string arg) {
    args.push_back(arg);
const Table & InvokeArgs::getTableArg() const {
    return tableArg;
Table & InvokeArgs::getVariableTableArg() {
    return tableArg;
InvokeResult::InvokeResult(const InvokeResultType type, const char *description) :
    type(type) {
    if (description) { this->description = description; };
InvokeResult::InvokeResult() :
    type(FAILURE) {
InvokeResult::InvokeResult(const InvokeResult &ir) :
    type(ir.type),
    description(ir.description) {
InvokeResult& InvokeResult::operator= (const InvokeResult &rhs) {
    this->type = rhs.type;
    this->description = rhs.description;
    return *this;
InvokeResult InvokeResult::success() {
    return InvokeResult(SUCCESS, 0);
InvokeResul

    return InvokeResult::failure(0);
InvokeResult InvokeResult::failure(const char *description) {
    return InvokeResult(FAILURE, description);
InvokeResult InvokeResult::failure(const std::string &description) {
    return InvokeResult(FAILURE, description.c_str());
InvokeResult InvokeResult::pending(const char *description) {
    return InvokeResult(PENDING, description);
bool InvokeResult::isSuccess() const {
    return (type == SUCCESS);
bool InvokeResult::isPending() const {
    return (type == PENDING);
InvokeResultType InvokeResult::getType() const {
    return type;
const std::string &InvokeResult::getDescription() const {
    return description;
StepManager::~StepManager() {
void StepManager::addStep(StepInfo *stepInfo) {
    steps().insert(std::make_pair(stepInfo->id, stepInfo));
MatchResult StepManager::stepMatches(const std::string &stepDescription) const {
    MatchResult matchResult;
    for (steps_type::iterator iter = steps().begin(); iter != steps().end(); ++iter) {

        StepInfo *stepInfo = iter->second;
        SingleStepMatch currentMatch = stepInfo->matches(stepDescription);
        if (currentMatch) {
            matchResult.addMatch(currentMatch);
        }
    }
    return matchResult;
StepInfo *StepManager::getStep(step_id_type id) {
    return steps()[id];
/**
 * Needed to fix the "static initialization order fiasco"
 */
StepManager::steps_type& StepManager::steps() const {
    static steps_type *steps = new steps_type();
    return *steps;
InvokeResult BasicStep::invoke(const InvokeArgs *pArgs) {
    this->pArgs = pArgs;
    currentArgIndex = 0;
    currentResult = InvokeResult::success();
    try {
        InvokeResult returnedResult = invokeStepBody();
        if (currentResult.isPending()) {
            return currentResult;
        } else {
            return returnedResult;
        }
    } catch (...) {
        return InvokeResult::failure();
    }
void BasicStep::pending() {
    pending(0);
void BasicStep::pending(const char *d
ChunkProviderClient(World ChunkProviderClient::world) 
        chunkMapping = new HashMap();
        field_889_c = new ArrayList();
        blankChunk = new EmptyChunk(world, new byte[32768], 0, 0);
        worldObj = world;
boolean ChunkProviderClient::chunkExists(int i, int j) 
        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
        return chunkMapping.containsKey(chunkcoordintpair);
void ChunkProviderClient::func_539_c(int i, int j) 
        Chunk chunk = provideChunk(i, j);
        if(!chunk.func_21167_h())
        {
            chunk.onChunkUnload();
        }
        chunkMapping.remove(new ChunkCoordIntPair(i, j));
        field_889_c.remove(chunk);
Chunk ChunkProviderClient::func_538_d(int i, int j) 
        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
        BYTE abyte0[] = new byte[32768];
        Chunk chunk = new Chunk(worldObj, abyte0, i, j);
        Arrays.fill(chunk.skylightMap.data, (byte)-1);
        chunkMapping.put(ch
namespace urchin
	SoundBoxReaderWriter::SoundBoxReaderWriter()
	{
	}
	SoundBoxReaderWriter::~SoundBoxReaderWriter()
	{
	}
	SoundShape *SoundBoxReaderWriter::loadFrom(std::shared_ptr<XmlChunk> shapeChunk, const XmlParser &xmlParser) const
	{
		std::shared_ptr<XmlChunk> halfSizesChunk = xmlParser.getUniqueChunk(true, HALF_SIZES_TAG, XmlAttribute(), shapeChunk);
		Vector3<float> halfSizes = halfSizesChunk->getVector3Value();
		std::shared_ptr<XmlChunk> positionChunk = xmlParser.getUniqueChunk(true, POSITION_TAG, XmlAttribute(), shapeChunk);
		Point3<float> position = positionChunk->getPoint3Value();
		std::shared_ptr<XmlChunk> orientationChunk = xmlParser.getUniqueChunk(true, ORIENTATION_TAG, XmlAttribute(), shapeChunk);
		std::shared_ptr<XmlChunk> orientationAxisChunk = xmlParser.getUniqueChunk(true, AXIS_TAG, XmlAttribute(), orientationChunk);
		std::shared_ptr<XmlChunk> orientationAngleChunk = xmlParser.getUniqueChunk(true, ANGLE_TAG, XmlAttribute(), orientationChunk);
		Quaternion<flo

		std::shared_ptr<XmlChunk> marginChunk = xmlParser.getUniqueChunk(true, MARGIN_TAG, XmlAttribute(), shapeChunk);
		float margin = marginChunk->getFloatValue();
		return new SoundBox(halfSizes, position, orientation, margin);
	}
	void SoundBoxReaderWriter::writeOn(std::shared_ptr<XmlChunk> shapeChunk, const SoundShape *soundShape, XmlWriter &xmlWriter) const
	{
		shapeChunk->setAttribute(XmlAttribute(TYPE_ATTR, BOX_VALUE));
		const SoundBox *boxshape = static_cast<const SoundBox *>(soundShape);
		std::shared_ptr<XmlChunk> halfSizesChunk = xmlWriter.createChunk(HALF_SIZES_TAG, XmlAttribute(), shapeChunk);
		halfSizesChunk->setVector3Value(boxshape->getHalfSizes());
		std::shared_ptr<XmlChunk> positionChunk = xmlWriter.createChunk(POSITION_TAG, XmlAttribute(), shapeChunk);
		positionChunk->setPoint3Value(boxshape->getCenterPosition());
		std::shared_ptr<XmlChunk> orientationChunk = xmlWriter.createChunk(ORIENTATION_TAG, XmlAttribute(), shapeChunk);
		std::shared_ptr<XmlChunk> orientatio
using std::endl;
namespace script
    DumpOpcode::DumpOpcode(OpcodeModule &OM, std::string &file)
        : file_(file, std::ios::out), module(OM)
    {
    }
    void DumpOpcode::dump()
    {
		for (auto i : module.functions_) {
			dumpFunction(i.second);
		}
        dumpStringPool();
    }
	void DumpOpcode::dumpInstruction(Opcode & opcode, size_t & ip)
	{
	}
	void DumpOpcode::dumpFunction(OpcodeFunction & func)
	{
		const auto &opcode = func.codes;
		file_ << "[Function]: " << module.getString(func.name) 
			<< "\nbegin : " << endl;
		size_t ip = 0;
		while (true)
		{
			if (ip >= opcode.size())
				break;
			file_ << "  0x" << std::setfill('0') 
				<< std::setw(8) << ip << ":\t";
			switch (opcode[ip++])
			{
			case OK_Add:
			case OK_Sub:
			case OK_Div:
			case OK_Mul:
			case OK_Great:
			case OK_GreatThan:
			case OK_Less:
			case OK_LessThan:
			case OK_NotEqual:
			case OK_Equal:
				dumpBinary(opcode, ip);
				break;
			case OK_Not:
				dumpNotOP(opcode, ip);
				break;
			

				dumpCall(opcode, ip);
				break;
			case OK_TailCall:
				dumpTailCall(opcode, ip);
				break;
			case OK_Goto:
				dumpGoto(opcode, ip);
				break;
			case OK_If:
				dumpIf(opcode, ip);
				break;
			case OK_Return:
				dumpReturn(opcode, ip);
				break;
			case OK_Load:
				dumpLoad(opcode, ip);
				break;
			case OK_Store:
				dumpStore(opcode, ip);
				break;
			case OK_Move:
				dumpMove(opcode, ip);
				break;
			case OK_MoveF:
				dumpMoveF(opcode, ip);
				break;
			case OK_MoveI:
				dumpMoveI(opcode, ip);
				break;
			case OK_MoveS:
				dumpMoveS(opcode, ip);
				break;
			case OK_MoveN:
				dumpMoveN(opcode, ip);
				break;
			case OK_Halt:
				dumpHalt(opcode, ip);
				break;
			case OK_Param:
				dumpParam(opcode, ip);
				break;
			case OK_NewClosure:
				dumpNewClosure(opcode, ip);
				break;
			case OK_UserClosure:
				dumpUserClosure(opcode, ip);
				break;
			case OK_NewHash:
				dumpNewHash(opcode, ip);
				break;
			case OK_Index:
				dumpIndex(opcode, ip);
	

			case OK_SetIndex:
				dumpSetIndex(opcode, ip);
				break;
			}
		}
		file_ << "\n\n";
	}
	void DumpOpcode::dumpBinary(const Opcode &opcode, size_t & ip)
    {
        dumpRegister(opcode[ip++]); file_ << " = ";
        dumpRegister(opcode[ip++]); 
        switch (opcode[ip - 3])
        {
        case OK_Add: file_ << " + "; break;
        case OK_Sub: file_ << " - "; break;
        case OK_Div: file_ << " / "; break;
        case OK_Mul: file_ << " * "; break;
        case OK_Great: file_ << " > "; break;
        case OK_GreatThan: file_ << " >= "; break;
        case OK_Less: file_ << " < "; break;
        case OK_LessThan: file_ << " <= "; break;
        case OK_NotEqual: file_ << " != "; break;
        case OK_Equal: file_ << " == "; break;
        }
        dumpRegister(opcode[ip++]);
        file_ << endl;
    }
    void DumpOpcode::dumpNotOP(const Opcode &opcode, size_t & ip)
    {
        dumpRegister(opcode[ip++]); 
		file_ << " = !";
        dumpRegister(opcode[ip++]);
 

    }
    void DumpOpcode::dumpCall(const Opcode &opcode, size_t & ip)
    {
        dumpRegister(opcode[ip++]);
        file_ << " = call "; 
		dumpRegister(opcode[ip++]);
        file_ << " <params>:";
        file_ << getInteger(opcode, ip) << endl;
    }
    void DumpOpcode::dumpTailCall(const Opcode &opcode, size_t & ip)
    {
		dumpRegister(opcode[ip++]);
		file_ << " = tail_call ";
		dumpRegister(opcode[ip++]);
		file_ << " <params>:";
		file_ << getInteger(opcode, ip) << endl;
    }
    void DumpOpcode::dumpGoto(const Opcode &opcode, size_t & ip)
    {
        file_ << "goto "; 
        file_ << "@0x" << std::setfill('0')
			<< std::setw(8) 
			<< getInteger(opcode, ip) << endl;
    }
    void DumpOpcode::dumpIf(const Opcode &opcode, size_t & ip)
    {
        file_ << "if ";
        dumpRegister(opcode[ip++]);
		file_ << " to @0x" << std::setfill('0')
			<< std::setw(8)
			<< getInteger(opcode, ip) << endl;
    }
    void DumpOpcode::dumpReturn(const Opcode &opcode, size_t & 

    {
        file_ << "return ";
        dumpRegister(opcode[ip++]);
        file_ << endl;
    }
    void DumpOpcode::dumpLoad(const Opcode &opcode, size_t & ip)
    {
        file_ << "load ";
        dumpRegister(opcode[ip++]);
        file_ << " at " << getInteger(opcode, ip) << endl;
    }
    void DumpOpcode::dumpStore(const Opcode &opcode, size_t & ip)
    {
        file_ << "store ";
        dumpRegister(opcode[ip++]);
        file_ << " into " << getInteger(opcode, ip) << endl;
    }
	void DumpOpcode::dumpIndex(const Opcode & opcode, size_t & ip)
	{
		dumpRegister(opcode[ip++]);
		file_ << " = ";
		dumpRegister(opcode[ip++]);
		file_ << "[";
		dumpRegister(opcode[ip++]);
		file_ << "]" << endl;
	}
	void DumpOpcode::dumpSetIndex(const Opcode & opcode, size_t & ip)
	{
		dumpRegister(opcode[ip++]);
		file_ << "[";
		dumpRegister(opcode[ip++]);
		file_ << "] = ";
		dumpRegister(opcode[ip++]);
		file_ << endl;
	}
    void DumpOpcode::dumpMove(const Opcode &opcode, size_t & ip)
  

        dumpRegister(opcode[ip++]);
        file_ << " = ";
        dumpRegister(opcode[ip++]);
        file_ << endl;
    }
    void DumpOpcode::dumpMoveF(const Opcode &opcode, size_t & ip)
    {
        dumpRegister(opcode[ip++]);
        file_ << " = " << getFloat(opcode, ip) << endl;
    }
    void DumpOpcode::dumpMoveI(const Opcode &opcode, size_t & ip)
    {
        dumpRegister(opcode[ip++]);
        file_ << " = " << getInteger(opcode, ip) << endl;
    }
    void DumpOpcode::dumpMoveS(const Opcode &opcode, size_t & ip)
    {
        dumpRegister(opcode[ip++]);
        file_ << " = ";
        file_ << "<string offset>:" << getInteger(opcode, ip);
        file_ << endl;
    }
	void DumpOpcode::dumpMoveN(const Opcode & opcode, size_t & ip)
	{
		dumpRegister(opcode[ip++]);
		file_ << " = null";
		file_ << endl;
	}
    void DumpOpcode::dumpHalt(const Opcode &opcode, size_t & ip)
    {
        file_ << "halt" << endl;
    }
    void DumpOpcode::dumpParam(const Opcode &opcode, size_t

    {
        file_ << "param ";
        dumpRegister(opcode[ip++]);
        file_ << endl;
    }
    void DumpOpcode::dumpNewClosure(const Opcode &opcode, size_t & ip)
    {
		dumpRegister(opcode[ip++]);
		int32_t offset = getInteger(opcode, ip);
		const std::string &name = module.getString(offset);
		file_ << " = new closure : " << name;
		file_ << " <params>:";
		file_ << getInteger(opcode, ip) << endl;
    }
	void DumpOpcode::dumpUserClosure(const Opcode & opcode, size_t & ip)
	{
		dumpRegister(opcode[ip++]);
		int32_t offset = getInteger(opcode, ip);
		const std::string &name = module.getString(offset);
		file_ << " = new user closure : " << name << endl;
	}
    void DumpOpcode::dumpNewHash(const Opcode &opcode, size_t &ip)
    {
        dumpRegister(opcode[ip++]);
        file_ << " = new hash " << endl;
    }
    
    void DumpOpcode::dumpRegister(unsigned reg)
    {
		file_ << "$" << reg;
    }
    void DumpOpcode::dumpStringPool()
    {
        file_ << "\n\n[String pool]: \n
HttpConnectionHandlerPool::HttpConnectionHandlerPool(QSettings* settings, HttpRequestHandler* requestHandler)
    : QObject()
    Q_ASSERT(settings!=0);
    this->settings=settings;
    this->requestHandler=requestHandler;
    cleanupTimer.start(settings->value("cleanupInterval",1000).toInt());
    connect(&cleanupTimer, SIGNAL(timeout()), SLOT(cleanup()));
HttpConnectionHandlerPool::~HttpConnectionHandlerPool() {    
    foreach(HttpConnectionHandler* handler, pool) {
        connect(handler,SIGNAL(finished()),handler,SLOT(deleteLater()));
        handler->quit();
    }
HttpConnectionHandler* HttpConnectionHandlerPool::getConnectionHandler() {   
    HttpConnectionHandler* freeHandler=0;
    mutex.lock();
    foreach(HttpConnectionHandler* handler, pool) {
        if (!handler->isBusy()) {
            freeHandler=handler;
            freeHandler->setBusy();
            break;
        }
    }
    if (!freeHandler) {
        int maxConnectionHandlers=settings->value("maxThreads",100).to
/**
* @file ClrSampleReader.cpp
* @brief Clr Sample Reader
* @author OKADA, H.
* @date 2012/07/18
* Copyright (C) 2014 Shimadzu Corporation All rights reserved.
* <è£è¶³èª¬æ>
*/
using kome::clr::ClrSampleReader;
ClrSampleReader::ClrSampleReader(){
ClrSampleReader::~ClrSampleReader(){
void ClrSampleReader::setBaseSampleReader( kome::clr::ClrSampleReaderBase^ baseSampleReader ){
	m_baseSampleReader = baseSampleReader;
kome::clr::ClrSampleReaderBase^ ClrSampleReader::getBaseSampleReader(){
	return m_baseSampleReader;
std::string ClrSampleReader::onSelectKeys( void ){
	ClrSampleReaderBase^ baseSampleReader = m_baseSampleReader;
	if( dynamic_cast<ClrSampleReaderBase^>(baseSampleReader) == nullptr )
	{
		return "";
	}
	return ClrObjectTool::convertString( baseSampleReader->onSelectKeys() );
};
kome::objects::Sample* ClrSampleReader::onOpenData( std::string strKey ){
	ClrSampleReaderBase^ baseSampleReader = m_baseSampleReader;
	SampleWrapper^ sample = baseSampleReader->onOpenData( ClrObjectTool::c
namespace DVLib
	namespace UnitTests 
	{
		class ConfigFileUnitTests : public dotNetInstallerLibUnitTestFixture
		{
			CPPUNIT_TEST_SUITE( ConfigFileUnitTests );
			CPPUNIT_TEST( testLoadPackagedSetup );
			CPPUNIT_TEST( testLoadInstallCheckOperators );
			CPPUNIT_TEST( testLoadStandaloneSetup );
			CPPUNIT_TEST( testLoadDownloadSetup );
			CPPUNIT_TEST( testLoadReferenceSetup );
			CPPUNIT_TEST( testLoadInstallCheckProductSetup );
			CPPUNIT_TEST( testLoadOsFiltersSetup );
			CPPUNIT_TEST( testLoadResource );
			CPPUNIT_TEST( testLoadMultilingualSetup );
			CPPUNIT_TEST( testLoadLicenseAgreement );
			CPPUNIT_TEST( testGetSupportedConfigurations );
			CPPUNIT_TEST( testLoadCustomInputSetup );
			CPPUNIT_TEST( testLoadMultipleSetup );
			CPPUNIT_TEST( testLoadPatchSetup );
			CPPUNIT_TEST( testLoadExeSetup );
			CPPUNIT_TEST_SUITE_END();
		public:
			void testLoadPackagedSetup();
			void testLoadInstallCheckOperators();
			void testLoadInstallCheckProductSetup();
			void testLoadStanda
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
namespace RM
    using namespace Internal;
    /**
     * @class       RepoMan
     * @brief       Manages the open / active repositories
     */
    /**
     * @brief       Constructor
     *
     * Initializes the repository subsystem. Invoked from MacGitver boot up code.
     *
     */
    RepoMan::Rep

        : Base(*new RepoManPrivate(this))
    {
        Events::addReceiver(this);
        connect(BlueSky::Application::instance(),
                SIGNAL(activeModeChanged(BlueSky::Mode*)),
                this,
                SLOT(reactivateWorkaround()));
    }
    /**
     * @brief       Destructor
     *
     * Close all repositories.
     *
     */
    RepoMan::~RepoMan()
    {
        closeAll();
        Events::delReceiver(this);
    }
    /**
     * @brief       Open a repository (By it's path)
     *
     * Opens a Git::Repository at the @a path and if this is valid, call open() to setup a RepoMan
     * repository for it.
     *
     * @param[in]   path    The path where to look for the repository to open.
     *
     * @return      A pointer to a Repo object that represents the repositorty. An existing one will
     *              be returned if such a Repo object can be found.
     *              `NULL` will be returned, if the repository cannot be opened.
     *
     *

    Repo* RepoMan::open(const QString& path)
    {
        Git::Result result;
        Git::Repository repo = Git::Repository::open( result, path );
        if( !result || !repo.isValid() )
        {
            return NULL;
        }
        return open( repo );
    }
    /**
     * @brief       Setup a Repo object for a Git::Repository
     *
     * If there is no Repo object for the git repository at that place in the file system, a new one
     * will be created and registered with the repo-manager and the core.
     *
     * @param[in]   gitRepo The Git::Repository object
     *
     * @return      Returns either an existing Repo object or a newly created one.
     *
     */
    Repo* RepoMan::open(const Git::Repository& gitRepo)
    {
        RM_D(RepoMan);
        Repo* repo = repoByPath(gitRepo.workTreePath(), false);
        if(!repo) {
            repo = new Repo(gitRepo, this);
            d->repos.append(repo);
            Events::self()->repositoryOpened(repo);
          

                emit firstRepositoryOpened();
            }
        }
        activate( repo );
        return repo;
    }
    Repo* RepoMan::repoByPath( const QString& basePath, bool searchSubmodules )
    {
        RM_D(RepoMan);
        foreach (Repo* repo, d->repos) {
            if (repo->path() == basePath) {
                return repo;
            }
            if (searchSubmodules) {
                if (RepoPrivate* subPriv = Private::dataOf<Repo>(repo)) {
                    if (Repo* subSubRepo = subPriv->repoByPath(basePath, true)) {
                        return subSubRepo;
                    }
                }
            }
        }
        return NULL;
    }
    /**
     * @brief       Close all currently open repositories
     *
     */
    void RepoMan::closeAll()
    {
        RM_D(RepoMan);
        foreach(Repo* repo, d->repos) {
            repo->close();
        }
    }
    void RepoMan::reactivateWorkaround()
    {
        RM_D(RepoMan);
        if (d->active

            Events::self()->repositoryDeactivated(d->activeRepo);
            Events::self()->repositoryActivated(d->activeRepo);
        }
    }
    void RepoMan::activate(Repo* repository)
    {
        RM_D(RepoMan);
        if(repository != d->activeRepo) {
            Repo* old = d->activeRepo;
            if (d->activeRepo) {
                d->activeRepo->deactivated();
                Events::self()->repositoryDeactivated(d->activeRepo);
            }
            d->activeRepo = repository;
            if (repository) {
                repository->activated();
                Events::self()->repositoryActivated(d->activeRepo);
            }
            if ((d->activeRepo != NULL) != (old != NULL)) {
                emit hasActiveRepositoryChanged(d->activeRepo != NULL);
            }
        }
    }
    void RepoMan::internalClosedRepo(Repo* repository)
    {
        RM_D(RepoMan);
        int i = d->repos.indexOf(repository);
        if (i != -1) {
            d->repos.remove

            emit repositoryClosed();
            if (d->repos.count() == 0) {
                emit lastRepositoryClosed();
            }
        }
    }
    Repo* RepoMan::activeRepository()
    {
        RM_D(RepoMan);
        return d->activeRepo;
    }
    Repo::List RepoMan::repositories() const
    {
        RM_CD(RepoMan);
        return d->repos;
    }
    RepoManPrivate::RepoManPrivate(RepoMan* _pub)
        : BasePrivate(_pub)
        , activeRepo(NULL)
        , refresher(NULL)
    {
        setupActions(_pub);
        if (MacGitver::self().isRunningGui()) {
            refresher = new AutoRefresher(_pub);
        }
    }
    bool RepoManPrivate::refreshSelf()
    {
        return true;
    }
    ObjTypes RepoManPrivate::objType() const
    {
        return RepoManagerObject;
    }
    void RepoManPrivate::dumpSelf(Internal::Dumper& dumper) const
    {
        dumper.addLine(QStringLiteral("Repository-Manager"));
    }
    void RepoManPrivate::preTerminate()
    {
    }
    

    {
        return QStringLiteral("RepoMan");
    }
    QString RepoManPrivate::objectTypeName() const
    {
        return QStringLiteral("RepoMan");
    }
    Heaven::Menu* RepoManPrivate::contextMenuFor(Base* object)
    {
        switch (object->objType()) {
        case BranchObject:      return menuCtxBranch;
        case TagObject:         return menuCtxTag;
        case RepoObject:        return menuCtxRepo;
        case SubmoduleObject:   return menuCtxSubmodule;
        case NamespaceObject:   return menuCtxNamespace;
        case RefLogObject:      return menuCtxRefLog;
        case RemoteObject:      return menuCtxRemote;
        case CollectionNodeObject:
            switch (static_cast<CollectionNode*>(object)->collectionType()) {
            case ctBranches:    return menuCtxBranches;
            case ctTags:        return menuCtxTags;
            case ctNotes:       return menuCtxNotes;
            case ctNamespaces:  return menuCtxNamespaces;
            default:   
BOOST_STATIC_ASSERT(sizeof(frozenbyte::filesystem::uint16_t) * CHAR_BIT == 16);
BOOST_STATIC_ASSERT(CHAR_BIT == 8);
namespace frozenbyte {
namespace filesystem {
namespace {
	template<class Type>
	void readFromStream(IInputStreamBuffer &buffer, Type &value)
	{
		ConvertTo<Type> converter;
		for(int i = 0; i < converter.getSize(); ++i)
			converter.setByte(i, buffer.popByte());
		value = converter.getValue();
	}
InputStream::InputStream()
InputStream::~InputStream()
void InputStream::setBuffer(boost::shared_ptr<IInputStreamBuffer> streamBuffer_)
	assert(streamBuffer_);
	streamBuffer = streamBuffer_;
bool InputStream::isEof() const
	assert(streamBuffer);
	return streamBuffer->isEof();
int InputStream::getSize() const
	assert(streamBuffer);
	return streamBuffer->getSize();
InputStream &InputStream::read(std::string &value)
	assert(streamBuffer);
	uint16_t stringSize = 0;
	this->read(stringSize);
	value.resize(stringSize);
	for(int i = 0; i < stringSize; ++i)
		value[i] = streamBuffer->pop

	return *this;
InputStream &InputStream::read(bool &value)
	assert(streamBuffer);
	value = streamBuffer->popByte() != 0;
	return *this;
InputStream &InputStream::read(unsigned char &value)
	assert(streamBuffer);
	value = streamBuffer->popByte();
	return *this;
InputStream &InputStream::read(char &value)
	assert(streamBuffer);
	value = streamBuffer->popByte();
	return *this;
InputStream &InputStream::read(signed char &value)
	assert(streamBuffer);
	value = streamBuffer->popByte();
	return *this;
InputStream &InputStream::read(unsigned short &value)
	assert(streamBuffer);
	readFromStream(*streamBuffer, value);
	return *this;
InputStream &InputStream::read(signed short &value)
	assert(streamBuffer);
	readFromStream(*streamBuffer, value);
	return *this;
InputStream &InputStream::read(unsigned int &value)
	assert(streamBuffer);
	readFromStream(*streamBuffer, value);
	return *this;
InputStream &InputStream::read(signed int &value)
	assert(streamBuffer);
	readFromStream(*streamBuffer, value)
Model::Model()
Model::~Model()
int Model::Choose_Model_Type(Model_Para *model_para,LogFile* logFile){
    if (model_para->model_status == MODEL_STATUS_UNKNOWN) {
        cout<<"Please specify the task you would like to perform (est/inf)!\n";
        return 1;
    }
    if (model_para->model_type == MODEL_NAME_UNKNOWN) {
        cout<<"Please specify the model you would like to perform (LDA / JST / USTM_FT_W / SENLDA / ASUM)!\n";
        return 1;
    }
    if (model_para->model_type == MODEL_NAME_LDA){
        LDA_process(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_JST & model_para->model_status == MODEL_STATUS_EST){
        JST_Train(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_JST & model_para->model_status == MODEL_STATUS_INF){
        JST_Test(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_USTM_FW_W){
        USTM_FT_W_process(model_pa

        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_D_PLDA){
        D_PLDA_process(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_SENLDA & model_para->model_status == MODEL_STATUS_EST){
        SENLDA_Train(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_SENLDA & model_para->model_status == MODEL_STATUS_INF){
        SENLDA_Test(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_ASUM & model_para->model_status == MODEL_STATUS_EST){
        ASUM_Train(model_para,logFile);
        return 0;
    }
    else if (model_para->model_type == MODEL_NAME_ASUM & model_para->model_status == MODEL_STATUS_INF){
        ASUM_Test(model_para,logFile);
        return 0;
    }
int Model::LDA_process(Model_Para *model_para,LogFile* logFile){
    LDA lda;
    lda.set_log_file(logFile);
    lda.excute_model(model_para);
int Model::JST_Train(Model_

    JST_model jst_est;
    jst_est.set_log_file(logFile);
    jst_est.excute_model(model_para);
int Model::JST_Test(Model_Para *model_para,LogFile* logFile){
    JST_inference jst_inf;
    jst_inf.set_log_file(logFile);
    jst_inf.excute_model(model_para);
int Model::USTM_FT_W_process(Model_Para *model_para,LogFile* logFile){
    USTM_FT_W ustm_ft_w;
    ustm_ft_w.set_log_file(logFile);
    ustm_ft_w.excute_model(model_para);
int Model::D_PLDA_process(Model_Para *model_para,LogFile* logFile){
    D_PLDA d_plda;
    d_plda.set_log_file(logFile);
    d_plda.excute_model(model_para);
int Model::SENLDA_Train(Model_Para *model_para,LogFile* logFile){
    SenLDA_model senLda_est;
    senLda_est.set_log_file(logFile);
    senLda_est.excute_model(model_para);
int Model::SENLDA_Test(Model_Para *model_para,LogFile* logFile){
int Model::ASUM_Train(Model_Para *model_para,LogFile* logFile){
    ASUM_model asum_est;
    asum_est.set_log_file(logFile);
    asum_est.excute_model(model_para);
int Mod
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
	namespace worker {
		/*!
		* Worker class to that fetches individual databases from given Mongo client.
		*/
		class OptimizeWorker : public RepoAbstractWorker {
			Q_OBJECT
		public:
			OptimizeWorker(
				repo::RepoController *controller, 
				const repo::RepoController::RepoToken *token,
				repo::core::model::RepoScene *scene);
			~OptimizeWorker(
/*
 *  EGRenderApi.cc
 *
 *  Copyright (c) 2008 - 2013, Michael Clark <michael@earthbuzz.com>, EarthBuzz Software
 */
/* EGRenderApi */
static const char class_name[] = "EGRenderApi";
EGRenderApi* EGRenderApi::currentApi = &EGRenderApiES2::apiImpl();
EGint EGRenderApi::nextApiId = 1;
EGRenderApi::EGRenderApi(const char* apiName, EGRenderApiVersion apiVersion) : apiId(nextApiId++), apiName(apiName), apiVersion(apiVersion) {}
EGRenderApi::~EGRenderApi() {}
const char* EGRenderApi::getName() const
    return apiName;
EGint EGRenderApi::getId() const
    return apiId;
EGRenderApiVersion EGRenderApi::getVersion() const
    return apiVersion;
EGbool EGRenderApi::isVersion(EGRenderApiVersion version) const
    return version == apiVersion;
EGRenderApi& EGRenderApi::currentApiImpl()
    return *currentApi;
EGbool EGRenderApi::init(EGRenderApi &api)
    EGDebug("%s:%s initializing %s\n", class_name, __func__, api.getName());
    return (currentApi = &api)->init();
EGbool EGRenderApi::initRender
namespace grace {
	class FormattedStream;
	class String;
	struct StringRef;
	class FormattedStream : public IOutputStream {
	public:
		FormattedStream(IOutputStream& stream) : stream_(stream) {}
		
		bool is_writable() const final { return stream_.is_writable(); }
		bool is_write_nonblocking() const final { return stream_.is_write_nonblocking(); }
		Either<size_t, IOEvent> write(const byte* buffer, size_t max) final { return stream_.write(buffer, max); }
		size_t tell_write() const final { return stream_.tell_write(); }
		bool seek_write(size_t position) final { return stream_.seek_write(position); }
		void flush() final { return stream_.flush(); }
		template <typename... Args>
		FormattedStream& printf(StringRef format, Args&&... args);
	protected:
		IOutputStream& stream_;
	};
	FormattedStream& operator<<(FormattedStream& stream, const char* cstr);
	FormattedStream& operator<<(FormattedStream& stream, const String&);
	FormattedStream& operator<<(FormattedStream& stream, const StringR

	FormattedStream& operator<<(FormattedStream& stream, bool b);
	FormattedStream& operator<<(FormattedStream& stream, uint8);
	FormattedStream& operator<<(FormattedStream& stream, uint16);
	FormattedStream& operator<<(FormattedStream& stream, uint32);
	FormattedStream& operator<<(FormattedStream& stream, uint64);
	FormattedStream& operator<<(FormattedStream& stream, char);
	FormattedStream& operator<<(FormattedStream& stream, int8);
	FormattedStream& operator<<(FormattedStream& stream, int16);
	FormattedStream& operator<<(FormattedStream& stream, int32);
	FormattedStream& operator<<(FormattedStream& stream, int64);
	FormattedStream& operator<<(FormattedStream& stream, float32);
	FormattedStream& operator<<(FormattedStream& stream, float64);
	inline FormattedStream& operator<<(FormattedStream& stream, unsigned long n) { return stream << (uint64)n; }
	inline FormattedStream& operator<<(FormattedStream& stream, long n) { return stream << (int64)n; }
	inline FormattedStream& operator<<(For
/* This file defines which functions should be loaded from desktop OpenGL.
 * LOAD() is a macro defined before including. */
LOAD(glActiveTexture)
LOAD(glAlphaFunc)
LOAD(glBegin)
LOAD(glBindTexture)
LOAD(glBlendFunc)
LOAD(glClear)
LOAD(glClearColor)
LOAD(glClearDepth)
LOAD(glClearStencil)
LOAD(glClientActiveTexture)
LOAD(glClipPlane)
LOAD(glColor4d)
LOAD(glColor4f)
LOAD(glColor4fv)
LOAD(glColor4ub)
LOAD(glColorMask)
LOAD(glColorPointer)
LOAD(glCopyTexImage2D)
LOAD(glCopyTexSubImage2D)
LOAD(glCullFace)
LOAD(glDeleteTextures)
LOAD(glDepthFunc)
LOAD(glDepthMask)
LOAD(glDepthRange)
LOAD(glDisable)
LOAD(glDisableClientState)
LOAD(glDrawElements)
LOAD(glEnable)
LOAD(glEnableClientState)
LOAD(glEnd)
LOAD(glFinish)
LOAD(glFlush)
LOAD(glFogi)
LOAD(glFogf)
LOAD(glFogfv)
LOAD(glFrontFace)
LOAD(glFrustum)
LOAD(glGenTextures)
LOAD(glGetBooleanv)
LOAD(glGetClipPlane)
LOAD(glGetDoublev)
LOAD(glGetError)
LOAD(glGetFloatv)
LOAD(glGetIntegerv)
LOAD(glGetLightfv)
LOAD(glGetMaterialfv)
LOAD(glGetString)
L

LOAD(glGetTexEnviv)
LOAD(glGetTexParameterfv)
LOAD(glGetTexParameteriv)
LOAD(glHint)
LOAD(glIsEnabled)
LOAD(glIsTexture)
LOAD(glLightf)
LOAD(glLightfv)
LOAD(glLightModelf)
LOAD(glLightModelfv)
LOAD(glLineWidth)
LOAD(glLoadIdentity)
LOAD(glLoadMatrixd)
LOAD(glLoadMatrixf)
LOAD(glLogicOp)
LOAD(glMaterialf)
LOAD(glMaterialfv)
LOAD(glMatrixMode)
LOAD(glMultiTexCoord4d)
LOAD(glMultiTexCoord4f)
LOAD(glMultMatrixd)
LOAD(glMultMatrixf)
LOAD(glNormal3d)
LOAD(glNormal3f)
LOAD(glNormal3fv)
LOAD(glNormalPointer)
LOAD(glOrtho)
LOAD(glPixelStorei)
LOADO(glPointParameterf)
LOADO(glPointParameterfv)
LOAD(glPointSize)
LOAD(glPolygonOffset)
LOAD(glPopMatrix)
LOAD(glPushMatrix)
LOAD(glReadPixels)
LOAD(glRotated)
LOAD(glRotatef)
LOAD(glSampleCoverage)
LOAD(glScaled)
LOAD(glScalef)
LOAD(glScissor)
LOAD(glShadeModel)
LOAD(glStencilFunc)
LOAD(glStencilMask)
LOAD(glStencilOp)
LOAD(glTexCoordPointer)
LOAD(glTexEnvf)
LOAD(glTexEnvfv)
LOAD(glTexEnvi)
LOAD(glTexEnviv)
LOAD(glTexImage2D)
LOAD(glTexParameterf)
LOA
/**
 *  @file    LocatorImpl.h
 *
 *  $Id: LocatorImpl.h 80826 2008-03-04 14:51:23Z wotte $
 *
 *  @author Nanbor Wang <nanbor@cs.wustl.edu>
 *  @author Krishnakumar Balasubramanian <kitty@cs.wustl.edu>
 */
/**
 * @class ACEXML_LocatorImpl LocatorImpl.h "ACEXML/common/LocatorImpl.h"
 *
 * @brief ACEXML_LocatorImpl is an implementation of ACEXML_Locator.
 *
 * This class is available mainly for application writers, who can
 * use it to make a persistent snapshot of a locator at any point
 * during a document parse:
 *
 * @code
 *   ACEXML_Locator locator;
 *   ACEXML_Locator startloc;
 *
 *   public void setLocator (ACEXML_Locator locator)
 *   {
 *      this.locator = locator;
 *   }
 *
 *   public void startDocument ()
 *   {
 *      ACEXML_Locator startloc = new ACEXML_LocatorImpl(locator);
 *   }
 * @endcode
 *
 * Normally, parser writers will not use this class, since it is more
 * efficient to provide location information only when requested,
 * rather than constantly updating a L

 *
 * @todo ACEXML parser doesn't support the use of Locator yet.
 *
 * @sa ACEXML_Locator
 */
class ACEXML_Export ACEXML_LocatorImpl : public ACEXML_Locator
public:
  /*
   * Default constructor.
   */
  ACEXML_LocatorImpl (void);
  /**
   * Construct a locator with systemId and publicId
   *
   */
  ACEXML_LocatorImpl (const ACEXML_Char* systemId,
                      const ACEXML_Char* publicId);
  /**
   * Copy constructor.  Create a persistent copy of the current state
   * of a locator. When the original locator changes, this copy will
   * still keep the original values (and it can be used outside the
   * scope of DocumentHandler methods).
   */
  ACEXML_LocatorImpl (const ACEXML_Locator& locator);
  /*
   * Destructor.
   */
  virtual ~ACEXML_LocatorImpl (void);
  /*
   * Return the column number where the current document event ends.
   */
  virtual int getColumnNumber (void) const;
  /*
   * Return the line number where the current document event ends.
   */
  virtual int 

  /*
   * Return the public identifier for the current document event.
   */
  virtual const ACEXML_Char *getPublicId (void) const;
  /*
   * Return the system identifier for the current document event.
   */
  virtual const ACEXML_Char *getSystemId (void) const;
  /*
   * Set the column number of this locator.
   */
  void setColumnNumber (int cn);
  /*
   * Set the line number of this locator.
   */
  void setLineNumber (int ln);
  /*
   * Set the public identifier of this locator.
   */
  void setPublicId (const ACEXML_Char *id);
  /*
   * Set the system identifier of this locator.
   */
  void setSystemId (const ACEXML_Char *id);
  /*
   * Increment the line number.
   */
  void incrLineNumber ();
  /*
   * Increment the column number.
   */
  void incrColumnNumber ();
  /*
   * Reset the Locator information. This is necessary because one might
   * want to use the same parser to parse multiple files. In that case,
   * tying the life of the Locator with the parser is not appropri
/*
 * ModelAndView.cpp
 *
 *  Created on: 01.07.2010
 *      Author: fkrauthan
 */
ModelAndView::ModelAndView() {
	mView = NULL;
ModelAndView::ModelAndView(View* view) {
	mView = view;
ModelAndView::ModelAndView(View* view, const std::string& modelName, const boost::any& modelObject) {
	mView = view;
	mModel[modelName] = modelObject;
ModelAndView::ModelAndView(View* view, const std::map<std::string, boost::any>& model) {
	mView = view;
	mModel = model;
ModelAndView::~ModelAndView() {
	delete mView;
View* ModelAndView::getView() {
	return mView;
const std::map<std::string, boost::any>& ModelAndView::getModel() const {
	return mModel;
void ModelAndView::addModel(const std::string& name, const boost::any& object) {
	mModel[name] = object;
const boost::any& ModelAndView::getModel(const std::string& name) const {
	std::map<std::string, boost::any>::const_iterator iter = mModel.find(name);
	if(iter!=mModel.end()) {
		return iter->second;
	}
	throw ModelNotFoundException("The model \""+name+"
AutoPtr<SurfaceLocatorBase> SurfaceLocatorBase::build (const SurfaceLocatorType t, const MeshBase& mesh, unsigned int subdomain)
  switch (t)
  {
      case SurfaceLocator_SPHERE:
      {
        AutoPtr<SurfaceLocatorBase> ap(new SurfaceLocatorSphere(mesh, subdomain));
        return ap;
      }
      case SurfaceLocator_LIST:
      {
        AutoPtr<SurfaceLocatorBase> ap(new SurfaceLocatorList(mesh, subdomain));
        return ap;
      }
      default:
      {
        std::cerr << "ERROR: Bad SurfaceLocatorType = " << t << std::endl;
        genius_error();
      }
  }
  genius_error();
  AutoPtr<SurfaceLocatorBase> ap(NULL);
  return ap;
AutoPtr<SurfaceLocatorBase> SurfaceLocatorBase::build (const SurfaceLocatorType t, const MeshBase& mesh, short int boundary)
  switch (t)
  {
    case SurfaceLocator_SPHERE:
    {
      AutoPtr<SurfaceLocatorBase> ap(new SurfaceLocatorSphere(mesh, boundary));
      return ap;
    }
    case SurfaceLocator_LIST:
    {
      AutoPtr<SurfaceLocatorBa
/*
    _____               __  ___          __            ____        _      __
   / ___/__ ___ _  ___ /  |/  /__  ___  / /_____ __ __/ __/_______(_)__  / /_
                                               /___/             /_/
                                             
  See Copyright Notice in gmMachine.h
*/
gmMemChain::gmMemChain(unsigned int a_elementSize, unsigned int a_numElementsInChunk)
  m_chunkSize = a_numElementsInChunk * a_elementSize;
  m_elementSize = a_elementSize;
  m_rootChunk = NULL;
  m_currentChunk = NULL;
gmMemChain::~gmMemChain()
  FreeChunks();
void gmMemChain::FreeChunks()
  if(m_rootChunk)
  {
    MemChunk *curChunk;
    curChunk = m_rootChunk;
    while(curChunk)
    {
      MemChunk *chunkToFree;
      
      chunkToFree = curChunk;
      curChunk = curChunk->m_nextChunk;
      
      delete [] (char*)chunkToFree;
    }
  }
void gmMemChain::ResetAndFreeMemory()
  FreeChunks();
  m_rootChunk = NULL;
  m_currentChunk = NULL;
void gmMemChain::Presize(int a_kby

  int numChunks = ((a_kbytes + 1) * 1024) / m_chunkSize;
  MemChunk *curChunk;
  curChunk = m_rootChunk;
  while(curChunk)
  {
    --numChunks;
    curChunk = curChunk->m_nextChunk;
  }
  MemChunk * currentChunk = m_currentChunk;
  while(numChunks > 0)
  {
    NewChunk();
    --numChunks;
  }
  if(currentChunk)
  {
    m_currentChunk = currentChunk;
  }
gmMemChain::MemChunk* gmMemChain::NewChunk()
  MemChunk* newChunk;
  if(m_currentChunk && m_currentChunk->m_nextChunk)
  {
    newChunk = m_currentChunk->m_nextChunk;
    newChunk->m_curAddress = newChunk->m_minAddress;    
    m_currentChunk = newChunk;
  }
  {
    char * mem = (char *) GM_NEW( char[sizeof(MemChunk) + m_chunkSize] );
    newChunk = (MemChunk *) mem;
  
    newChunk->m_minAddress = mem + sizeof(MemChunk);
    newChunk->m_lastAddress = (void*)((gmuptr)newChunk->m_minAddress + m_chunkSize);
    newChunk->m_curAddress = newChunk->m_minAddress;
    newChunk->m_lastChunk = m_currentChunk;
    newChunk->m_nextChunk = NULL;
 

    {
      m_currentChunk->m_nextChunk = newChunk;
    }
    m_currentChunk = newChunk;
    if(!m_rootChunk)
    {
      m_rootChunk = m_currentChunk;
    }
  }
  return newChunk;
void* gmMemChain::Alloc()
  void *retPtr;
  
  if(!m_rootChunk)
  {
    NewChunk();
  }
  if(((gmuptr)m_currentChunk->m_curAddress + m_elementSize) > (gmuptr)m_currentChunk->m_lastAddress)
  {
    NewChunk();    
  }
  retPtr = m_currentChunk->m_curAddress;
  m_currentChunk->m_curAddress = (void*)((gmuptr)m_currentChunk->m_curAddress + m_elementSize);
  return retPtr;
void* gmMemChain::AllocBytes(unsigned int a_numBytes, unsigned int a_alignNumBytes)
  void *retPtr;
  
  if(!m_rootChunk)
  {
    NewChunk();
  }
  retPtr = _gmAlignMem(m_currentChunk->m_curAddress, a_alignNumBytes);
  if(((gmuptr)retPtr + a_numBytes) > (gmuptr)m_currentChunk->m_lastAddress)
  {
    NewChunk();    
    
    retPtr = _gmAlignMem(m_currentChunk->m_curAddress, a_alignNumBytes);
  }
  
  m_currentChunk->m_curAddress = (void*)((gmu
/*
 * Copyright (c) 2014-2015 Dave French <contact/dot/dave/dot/french3/at/googlemail/dot/com>
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program (see COPYING); if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301 USA.
 *
 */
class Demo2ModuleControls : public ModuleControls
	Q_OBJECT
public:
	explicit Demo2ModuleControls( QObject *parent = 0 );
	~Demo2ModuleControls();
	enum MixMo
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoNodeAbstract::RepoNodeAbstract(const mongo::BSONObj &obj)
	uniqueID = RepoTranscoderBSON::retrieve(obj.getField(REPO_NODE_LABEL_ID));
	if (obj.hasField(REPO_NODE_LABEL_SHARED_ID))
		sharedID = RepoTranscoderBSON::retrieve(
			obj.getField(REPO_NODE_LABEL_SHARED_ID));
	if (obj.hasField(REPO_NODE_LABEL_TYPE))
		type = obj.getField(REPO

	else
	if (obj.hasField(REPO_NODE_LABEL_API))
		api = obj.getField(REPO_NODE_LABEL_API).numberInt();
	else
	if (obj.hasField(REPO_NODE_LABEL_NAME))
		name = obj.getField(REPO_NODE_LABEL_NAME).String();
	if (obj.hasField(REPO_NODE_LABEL_PARENTS))
	{
		std::vector<boost::uuids::uuid> parentIDs =
			RepoTranscoderBSON::retrieveUUIDs(
				obj.getField(REPO_NODE_LABEL_PARENTS));
        std::vector<boost::uuids::uuid>::iterator it;
        for (it = parentIDs.begin(); it != parentIDs.end(); ++it)
        {
            boost::uuids::uuid id = *it;
			parentSharedIDs.insert(id);
        }
	}
bool repo::core::RepoNodeAbstract::operator==(const RepoNodeAbstract &other) const
    return (this->getType() == other.getType()) &&
           (this->getName() == other.getName()) &&
           (this->getApi() == other.getApi()) &&
           (this->getSharedID() == other.getSharedID());
bool repo::core::RepoNodeAbstract::operator<(const RepoNodeAbstract& other) const
    return this->getType() != othe

            ? this->getType() < other.getType()
            : this->getName() != other.getName()
            ? this->getName() < other.getName()
            : this->getApi() != other.getApi()
            ? this->getApi() < other.getApi()
            : this->getSharedID() < other.getSharedID();
std::vector<std::vector<boost::uuids::uuid>>
	repo::core::RepoNodeAbstract::getPaths(const RepoNodeAbstract * node)
	std::vector<std::vector<boost::uuids::uuid>> ret;
	if (node->isRoot())
	{	
		std::vector<boost::uuids::uuid> vec;
		vec.push_back(node->sharedID);
		ret.push_back(vec);
	}
	else 
	{	
        std::set<const RepoNodeAbstract *>::iterator it;
        for (it = node->parents.begin(); it != node->parents.end(); ++it)
        {
            const RepoNodeAbstract *parent = *it;
            std::vector<std::vector<boost::uuids::uuid> > paths =
				getPaths(parent);			
			
            std::vector<std::vector<boost::uuids::uuid> >::iterator itt;
            for (itt = paths.begin(); itt != 

            {
                std::vector<boost::uuids::uuid> vec = *itt;
                vec.push_back(node->sharedID);
				ret.push_back(vec);
			}
		}		
	}
	return ret;
void repo::core::RepoNodeAbstract::getSubNodes(
        std::set<const RepoNodeAbstract *> &components) const
	components.insert(this);
    std::set<const RepoNodeAbstract *>::iterator it;
    for (it = children.begin(); it != children.end(); ++it)
    {
        const RepoNodeAbstract *child = *it;
		child->getSubNodes(components);
    }
std::set<boost::uuids::uuid> repo::core::RepoNodeAbstract::
	getParentSharedIDs() 
	if (parents.size() > parentSharedIDs.size())
	{
		parentSharedIDs.clear();
        std::set<const RepoNodeAbstract *>::iterator it;
        for (it = parents.begin(); it != parents.end(); ++it)
        {
			parentSharedIDs.insert((*it)->sharedID);
        }
	}
	return parentSharedIDs;
void repo::core::RepoNodeAbstract::appendDefaultFields(
	mongo::BSONObjBuilder &builder) const
{	
	RepoTranscoderBSON
ChunkManager::ChunkManager()
  chunks.resize(CMX * CMY * CMZ);
inline bool ChunkManager::outOfBounds(int x, int y, int z)
  return (0 > x || x >= CMX * Chunk::CHUNK_SIZE || 0 > y ||
          y >= CMY * Chunk::CHUNK_SIZE || 0 > z ||
          z >= CMZ * Chunk::CHUNK_SIZE);
BlockType ChunkManager::get(int x, int y, int z)
  if (outOfBounds(x, y, z))
  {
    return BlockType::Inactive;
  }
  auto cmx = x / Chunk::CHUNK_SIZE;
  auto cmy = y / Chunk::CHUNK_SIZE;
  auto cmz = z / Chunk::CHUNK_SIZE;
  x %= CMX;
  y %= CMY;
  z %= CMZ;
  if (chunks[index(cmx, cmy, cmz)] == nullptr)
  {
    return BlockType::Inactive;
  }
  return chunks[index(cmx, cmy, cmz)]->get(x, y, z);
void ChunkManager::set(glm::vec3 pos, BlockType type)
  set(int(pos.x), int(pos.y), int(pos.z), type);
void ChunkManager::set(int x, int y, int z, BlockType type)
  if (outOfBounds(x, y, z))
  {
    return;
  }
  auto cmx = x / Chunk::CHUNK_SIZE;
  auto cmy = y / Chunk::CHUNK_SIZE;
  auto cmz = z / Chunk::CHUNK_SIZE;
  x %=

  y %= CMY;
  z %= CMZ;
  if (chunks[index(cmx, cmy, cmz)] == nullptr)
  {
    chunks[index(cmx, cmy, cmz)] =
      std::make_shared<Chunk>(cmx * Chunk::CHUNK_SIZE, cmy * Chunk::CHUNK_SIZE,
                              cmz * Chunk::CHUNK_SIZE);
  }
  auto chunk = chunks[index(cmx, cmy, cmz)];
  chunk->set(x % CMX, y % CMY, z % CMZ, type);
  chunksToUpdate.insert(chunk);
int ChunkManager::index(int x, int y, int z)
  return x * CMY * CMZ + y * CMZ + z;
std::shared_ptr<Chunk> ChunkManager::getChunkAtIndex(int x, int y, int z)
  std::shared_ptr<Chunk> chunk;
  return (outOfBounds(x, y, z)
            ? chunk
            : chunks[index(x / Chunk::CHUNK_SIZE, y / Chunk::CHUNK_SIZE,
                           z / Chunk::CHUNK_SIZE)]);
void ChunkManager::update()
  for (auto& c : chunksToUpdate)
  {
    auto down = getChunkAtIndex(c->X, c->Y - Chunk::CHUNK_SIZE, c->Z);
    auto up = getChunkAtIndex(c->X, c->Y + Chunk::CHUNK_SIZE, c->Z);
    auto left = getChunkAtIndex(c->X - Chunk::CHUNK_SI
namespace clover {
namespace game {
WorldChunkMgr::ChunkSet WorldChunkMgr::getChunksInRadius(util::Vec2d p, real64 r){
	ChunkSet c;
	p -= util::Vec2d(game::WorldChunk::width*0.5);
	r += game::WorldChunk::width*0.8;
	for (auto it=chunks.begin(); it!= chunks.end(); ++it){
		game::WorldChunk& chunk= it->second;
		util::Vec2d chunkpos{(real64)chunk.getPosition().x, (real64)chunk.getPosition().y};
		chunkpos = chunkpos*game::WorldChunk::width;
		if ( util::Vec2d(chunkpos - p).lengthSqr() <= r*r){
			c.insert(&chunk);
		}
	}
	return c;
WorldChunkMgr::ChunkSet WorldChunkMgr::getChunksOutRadius(util::Vec2d p, real64 r){
	ChunkSet c;
	p -= util::Vec2d(game::WorldChunk::width*0.5);
	r += game::WorldChunk::width*0.8;
	for (auto it=chunks.begin(); it!= chunks.end(); ++it){
		game::WorldChunk& chunk= it->second;
		util::Vec2d chunkpos{	(real64)chunk.getPosition().x,
						(real64)chunk.getPosition().y };
		chunkpos = chunkpos*game::WorldChunk::width;
		if ( util::Vec2d(chunkpos - p).lengthSqr() > r

			c.insert(&chunk);
		}
	}
	return c;
WorldChunkMgr::ChunkSet WorldChunkMgr::inhabitChunksInRadius(util::Vec2d p, real64 r){
	ChunkSet vec;
	r += game::WorldChunk::width*0.8;
	util::Vec2i search_pos= game::WorldGrid::worldToChunkVec(p - util::Vec2d(r));
	util::Vec2i start_pos= search_pos;
	util::Vec2i last_pos= game::WorldGrid::worldToChunkVec(p + util::Vec2d(r));
	while (search_pos.y <= last_pos.y){
		if (p.distanceSqr(util::Vec2d{(real64)search_pos.x, (real64)search_pos.y}*game::WorldChunk::width) <= r*r){
			game::GridPoint p;
			p.setChunkVec(search_pos);
			if (!getChunk(p)){
				vec.insert(&createChunk(p));
			}
		}
		++search_pos.x;
		if (search_pos.x > last_pos.x){
			search_pos.x=start_pos.x;
			++search_pos.y;
		}
	}
	return vec;
util::Set<RegionVec> WorldChunkMgr::getInhabitedRegionPositions() const {
	util::Set<RegionVec> regions;
	for (const auto& pair : chunks){
		regions.insert(game::GridPoint::Chunk(pair.first).getRegionVec());
	}
	return regions;
game::WorldChunk* Wo

	auto it= chunks.find(p.getChunkVec());
	if (it == chunks.end()) return nullptr;
	return &it->second;
game::WorldChunk& WorldChunkMgr::createChunk(game::GridPoint pos){
	util::Vec2i p= pos.getChunkVec();
	game::WorldChunk *sides[4]={0,0,0,0};
	if (chunks.count(p)){
		throw global::Exception("WorldChunkManifold::createChunk(..): there's already chunk in position %i, %i", p.x, p.y);
	}
	for (auto it=chunks.begin(); it!=chunks.end(); ++it){
		game::WorldChunk &chunk= it->second;
		if (p.x + 1 == chunk.getPosition().x && p.y == chunk.getPosition().y) sides[game::WorldChunk::Right]= &chunk;
		if (p.x - 1 == chunk.getPosition().x && p.y == chunk.getPosition().y) sides[game::WorldChunk::Left]= &chunk;
		if (p.x == chunk.getPosition().x && p.y + 1 == chunk.getPosition().y) sides[game::WorldChunk::Up]= &chunk;
		if (p.x == chunk.getPosition().x && p.y - 1 == chunk.getPosition().y) sides[game::WorldChunk::Down]= &chunk;
	}
	game::WorldChunk& chunk= chunks[p];
	chunk.setPosition(p);
	for (int32 

		if (sides[i]){
			chunk.setSide(*sides[i]);
		}
	}
	return chunk;
WorldChunkMgr::ChunkSet WorldChunkMgr::getChunks(){
	util::Set<game::WorldChunk*> vec;
	for (auto it= chunks.begin(); it != chunks.end(); ++it)
		vec.insert(&it->second);
	return vec;
WorldChunkMgr::ClusterSet WorldChunkMgr::getCommonClusters(ChunkSet chs) const {
	ClusterSet clusters;
	for (const auto& chunk : chs){
		clusters.insert(chunk->getCluster());
	}
	for (auto it= clusters.begin(); it != clusters.end();){
		if (!util::fullyContains(chs, *it))
			it= clusters.erase(it);
		else
			++it;
	}
	return clusters;
WorldChunkMgr::ClusterSet WorldChunkMgr::getClusters() const {
	ClusterSet clusters;
	for (const auto& pair : chunks){
		clusters.insert(pair.second.getCluster());
	}
	return clusters;
void WorldChunkMgr::updateChunkDependencies(){
	for (auto it=chunks.begin(); it!=chunks.end(); ++it){
		if (it->second.getState() == game::WorldChunk::State::Active)
			it->second.clearDependencies();
	}
	for (auto it= Strict

		StrictHandleConnection *con= *it;
		if (con == 0)
			continue;
		game::WeHandle& h= con->getHandle();
		game::WorldEntity *we1= h.get();
		game::WorldEntity *we2= &con->getOwner();
		if (!we1 || !we2)
			continue;
		game::WorldChunk *chunk1= we1->getInChunk();
		game::WorldChunk *chunk2= we2->getInChunk();
		if (!chunk1 || !chunk2 || chunk1 == chunk2)
			continue;
		if (chunk1->getState() != game::WorldChunk::State::Active || chunk2->getState() != game::WorldChunk::State::Active)
			continue;
		chunk1->addDependency(*chunk2);
		chunk2->addDependency(*chunk1);
	}
void WorldChunkMgr::startDestroyingChunk(game::WorldChunk& c){
	c.setState(game::WorldChunk::State::Destroying);
void WorldChunkMgr::startDestroyingChunks(const ChunkSet& c){
	for (auto& m : c){
		m->setState(game::WorldChunk::State::Destroying);
	}
void WorldChunkMgr::updateDestroying(){
	const SizeType remove_count= 10;
	SizeType removed= 0;
	for (auto& chunk_pair : chunks){
		game::WorldChunk& chunk= chunk_pair.second;
		
/**************************************
* Block vertex format:
* 	property		bits
* 	position.x		8
* 	position.y		8
* 	position.z		8
* 	normalID		3
* 	texcoordID		2
*	unused			3
* 					--
* 					32
* 	texID			6
* 	occlusion		2
* 	unused			8
* 	unused			8
* 	unused			8
*					--
*					32
/**************************************/
namespace Blocks
enum BIOME
	BIOME_PLAINS,
	BIOME_MOUNTAINS,
	BIOME_COUNT
};
struct BlockPosition
	int chunkX;
	int chunkZ;
	int x, y, z;
};
struct BlockVertex
	uint8 data1[4];
	uint8 data2[4];
};
struct Chunk
	int pos[2];
	bool terrainGenerated;
	BIOME biomeMap[CHUNK_WIDTH][CHUNK_WIDTH];
	BLOCK_TYPE blocks[CHUNK_WIDTH][CHUNK_HEIGHT][CHUNK_WIDTH];
};
struct ChunkMesh
	int chunkPos[2];
	int numVertices;
	bool dirty;
	BlockVertex* vertices;
};
struct ChunkContext
	ChunkContext( Chunk * chunkNegZNegX, Chunk * chunkNegZSamX, Chunk * chunkNegZPosX,
				  Chunk * chunkSamZNegX, Chunk * chunkSamZSamX, Chunk * chunkSamZPosX,
				  Chunk * chunkPosZNegX, Chunk * chunkPosZSa

	BLOCK_TYPE GetBlockAt( int x, int y, int z ) const;
	void SetBlockAt( int x, int y, int z, BLOCK_TYPE block );
	Chunk * chunks_[ 9 ];
};
void InitWorldGen();
void InitChunkCache( Chunk * cache, uint cacheDim );
void GenerateChunk( Chunk *chunk, int x, int z );
void GenerateChunkStructures( Chunk * chunk, ChunkContext chunkContext );
void ClearChunk( Chunk * chunk );
void MergeChunks( Chunk * target, Chunk * source );
int GenerateChunkMesh( ChunkMesh *chunkMesh, Chunk* chunkNegXPosZ, Chunk* chunkPosZ, Chunk* chunkPosXPosZ,
											 Chunk* chunkNegX, Chunk* chunk, Chunk* chunkPosX,
											 Chunk* chunkNegXNegZ, Chunk* chunkNegZ, Chunk* chunkPosXNegZ );
int GenerateChunkMesh( ChunkMesh *chunkMesh, ChunkContext chunks );
DirectX::XMINT3 GetPlayerChunkPos( DirectX::XMFLOAT3 playerPos );
DirectX::XMINT3 GetPlayerBlockPos( DirectX::XMFLOAT3 playerPos );
BLOCK_TYPE GetBlockType( const Chunk &chunk, DirectX::XMINT3 blockPos );
BLOCK_TYPE SetBlockType( Chunk *chunk, DirectX::XMINT3 bloc
/*
 * CVmDispatcherDump.cpp
 *
 * Copyright (C) 1999-2014 Parallels IP Holdings GmbH
 *
 * This file is part of Parallels SDK. Parallels SDK is free
 * software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License,
 * or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * 51 Franklin Street, Fifth Floor Boston, MA 02110, USA.
 *
 * Our contact details: Parallels IP Holdings GmbH, Vordergasse 59, 8200
 */
/*****************************************************************************
 * CVmDispatcherDu

 *****************************************************************************/
CVmDispatcherDump::CVmDispatcherDump () :
    mutex( QMutex::Recursive )
{}
CVmDispatcherDump::CVmDispatcherDump ( const QString& dumpFileName ) :
    mutex( QMutex::Recursive )
{ setDumpFile( dumpFileName ); }
CVmDispatcherDump::~CVmDispatcherDump ()
{ dumpFile.remove(); }
bool CVmDispatcherDump::setDumpFile ( const QString& dumpFileName )
    if ( dumpFile.isOpen() )
        dumpFile.close();
    dumpFile.setFileName( dumpFileName );
    if ( !dumpFile.open( QIODevice::ReadWrite ) )
        return false;
    parseDumpFile();
    return true;
bool CVmDispatcherDump::isOpen () const
{ return dumpFile.isOpen(); }
CVmDispatcherDump::DumpHash CVmDispatcherDump::getDump () const
    QMutexLocker locker( &mutex );
    return dumpHash;
bool CVmDispatcherDump::contains ( const QString& uuid ) const
    if ( !dumpElements.contains( uuid ) )
        return false;
    QDomElement dumpSet = dumpElements[uuid];
    QS

    bool ok = false;
    int pid = pidStr.toInt( &ok );
    if ( !ok ) {
        LOG_MESSAGE( DBG_FATAL, ">>> Dump: can't parse pid for uuid: %s",  qPrintable(uuid) );
        return false;
    }
    if ( (qint64)getpid() == pid )
        return false;
    return true;
QString CVmDispatcherDump::toString () const
    QMutexLocker locker( &mutex );
    return dumpDoc.toString(1);
void CVmDispatcherDump::dumpSet ( const QString& uuid,
                                  const CVmDispatcherDump::DumpSet& dumpSet )
    QMutexLocker locker( &mutex );
    dumpHash[uuid] = dumpSet;
    QDomElement dumpSetElement;
    QString timestamp = QDateTime::currentDateTime().
                             toString( "dd.MM.yyyyThh:mm:ss.zzz" );
    if ( dumpElements.contains( uuid ) ) {
        dumpSetElement = dumpElements[uuid];
    }
    else {
        dumpSetElement = dumpDoc.createElement( XML_VM_DISPATCHER_DUMP_SET );
        dumpDoc.documentElement().appendChild( dumpSetElement );
        dumpEleme

        dumpSetElement.setAttribute( XML_VM_DISPATCHER_DUMP_STARTED,
                                     timestamp );
    }
    dumpSetElement.setAttribute( XML_VM_DISPATCHER_DUMP_VM_UUID, uuid );
    dumpSetElement.setAttribute( XML_VM_DISPATCHER_DUMP_OBJ_UUID,
                                 dumpSet.objUuid );
    dumpSetElement.setAttribute( XML_VM_DISPATCHER_DUMP_VM_PID,
                                 dumpSet.vmPid );
    dumpSetElement.setAttribute( XML_VM_DISPATCHER_DUMP_DISP_PID,
                                 getpid() );
    dumpSetElement.setAttribute( XML_VM_DISPATCHER_DUMP_CHANGED, timestamp );
    flush();
bool CVmDispatcherDump::removeDumpSet ( const QString& vmUuid )
    if ( ! dumpHash.contains( vmUuid ) )
        return false;
    QMutexLocker locker( &mutex );
    dumpHash.remove( vmUuid );
    if ( dumpElements.contains( vmUuid ) ) {
        dumpDoc.documentElement().removeChild( dumpElements[vmUuid] );
        dumpElements.remove( vmUuid );
    }
    flush();


void CVmDispatcherDump::cleanOldDumpSets ()
    QMutexLocker locker( &mutex );
    DumpHash tmpDumpHash = dumpHash;
    DumpHash::Iterator i = tmpDumpHash.begin();
    for ( ; i != tmpDumpHash.end(); ++i ) {
        QString vmUuid = i.key();
        QDomElement dumpSet = dumpElements[vmUuid];
        QString pidStr  = dumpSet.attribute( XML_VM_DISPATCHER_DUMP_DISP_PID );
        bool ok = false;
        int pid = pidStr.toInt( &ok );
        if ( !ok ) {
            LOG_MESSAGE( DBG_FATAL, ">>> Dump: can't parse pid for uuid: %s",
                      qPrintable(vmUuid) );
            continue;
        }
        if ( pid == getpid() )
            continue;
        removeDumpSet( vmUuid );
    }
void CVmDispatcherDump::parseDumpFile ()
    if ( ! isOpen() )
        return;
    QDomElement rootElement;
    if ( !dumpDoc.setContent( &dumpFile ) ) {
        dumpDoc.clear();
        QDomNode xmlInstr = dumpDoc.createProcessingInstruction(
                        "xml", QString("version=\"

        dumpDoc.insertBefore( xmlInstr, QDomNode() );
        rootElement = dumpDoc.createElement( XML_VM_DISPATCHER_DUMP_ROOT );
        dumpDoc.appendChild(rootElement);
    } else {
        rootElement = dumpDoc.documentElement();
    }
    QDomNode n = rootElement.firstChild();
    for ( ; !n.isNull(); n = n.nextSibling()) {
        QDomElement dumpSet = n.toElement();
        if ( dumpSet.isNull() ||
             dumpSet.tagName() != XML_VM_DISPATCHER_DUMP_SET )
            continue;
        QString vmUuid  = dumpSet.attribute( XML_VM_DISPATCHER_DUMP_VM_UUID );
        QString objUuid = dumpSet.attribute( XML_VM_DISPATCHER_DUMP_OBJ_UUID );
        QString pidStr  = dumpSet.attribute( XML_VM_DISPATCHER_DUMP_VM_PID );
        bool ok = false;
        int pid = pidStr.toInt( &ok );
        if ( !ok ) {
            LOG_MESSAGE( DBG_FATAL, ">>> Dump: can't parse pid for uuid: %s",
                      qPrintable(vmUuid) );
            continue;
        }
        dumpHash[vmUuid] = CV
/***************************************************************************
 *   Copyright 2007 Robert Gruber <rgruber@users.sourceforge.net>          *
 *   Copyright 2010 Milian Wolff <mail@milianw.de>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
EditRepository::EditRepository(SnippetRepository* repository, QWidget* parent)
    : KDialog(parent), Ui::EditRepositoryBase(), m_repo(repository)
    setButtons(/*Reset | */Apply | Cancel | Ok);
    setupUi(mainWidget());
    co

    connect(this, SIGNAL(applyClicked()), this, SLOT(save()));
    connect(repoNameEdit, SIGNAL(textEdited(QString)), this, SLOT(validate()));
    KTextEditor::Document *document = KTextEditor::EditorChooser::editor()->createDocument(0);
    repoFileTypesList->addItems(document->highlightingModes());
    repoFileTypesList->sortItems();
    repoFileTypesList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    connect(repoFileTypesList->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
            this, SLOT(updateFileTypesEdit()));
    delete document;
    repoLicenseEdit->addItems(QStringList() << "Artistic" << "BSD" << "LGPL v2+" << "LGPL v3+");
    repoLicenseEdit->setEditable(true);
    if ( m_repo ) {
        repoNameEdit->setText(m_repo->text());
        repoAuthorsEdit->setText(m_repo->authors());
        repoNamespaceEdit->setText(m_repo->completionNamespace());
        if ( !m_repo->license().isEmpty() ) {
            int index = repoLicenseEd

            if ( index == -1 ) {
                repoLicenseEdit->addItem(m_repo->license());
                repoLicenseEdit->model()->sort(0);
                index = repoLicenseEdit->findText(m_repo->license());
            }
            repoLicenseEdit->setCurrentIndex(index);
        }
        foreach ( const QString& type, m_repo->fileTypes() ) {
            foreach( QListWidgetItem* item, repoFileTypesList->findItems(type, Qt::MatchExactly) ) {
                item->setSelected(true);
            }
        }
        setWindowTitle(i18n("Edit Snippet Repository %1", m_repo->text()));
    } else {
        setWindowTitle(i18n("Create New Snippet Repository"));
        KUser user;
        repoAuthorsEdit->setText(user.property(KUser::FullName).toString());
    }
    validate();
    updateFileTypesEdit();
    repoNameEdit->setFocus();
EditRepository::~EditRepository()
void EditRepository::validate()
    bool valid = !repoNameEdit->text().isEmpty() && !repoNameEdit->text().contains('
/*
 * File:   ChunkTest.h
 * Author: daniele
 *
 * Created on Oct 11, 2010, 2:16:04 PM
 */
namespace {
    class ChunkTest : public ::testing::Test {
    protected:
        ChunkTest() {}
        virtual ~ChunkTest() {}
        virtual void SetUp()
        {
            _offset = 31337;
            _testString = "test123";
            _chunk = new Chunk( _testString.c_str(), BufferDescriptor( _offset, _testString.size() ) );
            _emptyChunk = new Chunk();
        }
        
        virtual void TearDown()
        {
            delete _chunk;
            delete _emptyChunk;
        }
        
        std::size_t _offset;
        std::string _testString;
        Chunk* _chunk;
        Chunk* _emptyChunk;
    };
    
    TEST_F(ChunkTest, descriptor)
    {
        EXPECT_TRUE( _chunk->descriptor() == BufferDescriptor(_offset, _testString.size()) );
    }
    TEST_F(ChunkTest, empty_descriptor_is_zero)
    {
        EXPECT_TRUE( _emptyChunk->descriptor() == BufferDescriptor(0, 0) )
using std::map;
namespace base {
typedef HistogramBase::Count Count;
typedef HistogramBase::Sample Sample;
SampleMap::SampleMap() {}
SampleMap::~SampleMap() {}
void SampleMap::Accumulate(Sample value, Count count) {
  sample_counts_[value] += count;
  IncreaseSum(count * value);
  IncreaseRedundantCount(count);
Count SampleMap::GetCount(Sample value) const {
  map<Sample, Count>::const_iterator it = sample_counts_.find(value);
  if (it == sample_counts_.end())
    return 0;
  return it->second;
Count SampleMap::TotalCount() const {
  Count count = 0;
  for (map<Sample, Count>::const_iterator it = sample_counts_.begin();
       it != sample_counts_.end();
       ++it) {
    count += it->second;
  }
  return count;
scoped_ptr<SampleCountIterator> SampleMap::Iterator() const {
  return scoped_ptr<SampleCountIterator>(new SampleMapIterator(sample_counts_));
bool SampleMap::AddSubtractImpl(SampleCountIterator* iter,
                                HistogramSamples::Operator op) {
  Sample m
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
namespace mozilla {
class LoadInfoUpdateRunner;
class LoadInfoCollectRunner;
class LoadNotificationCallback
public:
    virtual void LoadChanged(float aSystemLoad, float aProcessLoad) = 0;
};
class LoadMonitor MOZ_FINAL : public nsIObserver
public:
    NS_DECL_THREADSAFE_ISUPPORTS
    NS_DECL_NSIOBSERVER
    LoadMonitor(int aLoadUpdateInterval);
    ~LoadMonitor();
    nsresult Init(nsRefPtr<LoadMonitor> &self);
    void SetLoadChangeCallback(LoadNotificationCallback* aCallback);
    void Shutdown();
    float GetSystemLoad();
    float GetProcessLoad();
    friend class LoadInfoCollectRunner;
private:
    void SetProcessLoad(float load);
    void SetSystemLoad(float load);
    void FireCallbacks();
    int                  mLoadUpdateInterval;
    mozilla::Mutex    
using namespace Ilwis;
SampleSet::SampleSet()
    _sampleHistogram.reset(new SampleHistogram());
    _sampleSum.reset(new SampleSum());
    _sampleSumXY.reset(new SampleSumXY());
    _sampleStats.reset(new SampleStatistics());
SampleSet::SampleSet(const Resource &res)
SampleSet::SampleSet(const SampleSet &sampleset) : Identity(name(),id(), code(), description())
    _sampleMap = sampleset._sampleMap;
    _sampleMaps = sampleset._sampleMaps;
    _sampleDomain = sampleset._sampleDomain;
    _sampleStats.reset(sampleset._sampleStats->copy<SampleStatistics>());
    _sampleHistogram.reset( sampleset._sampleHistogram->copy<SampleHistogram>());
    _sampleSum.reset(sampleset._sampleSum->copy<SampleSum>());
    _sampleSumXY.reset(sampleset._sampleSumXY->copy<SampleSumXY>());
SampleSet::SampleSet(const IRasterCoverage &samplemaps, const IThematicDomain &dom, const IRasterCoverage &samplemap) :
    _sampleMap(samplemap),
    _sampleMaps(samplemaps),
    _sampleDomain(dom)
    _sampleHistogram.re

    _sampleSum.reset(new SampleSum());
    _sampleSumXY.reset(new SampleSumXY());
    _sampleStats.reset(new SampleStatistics());
SampleSet::~SampleSet()
void SampleSet::sampleRasterSet(const IRasterCoverage &raster)
    if ( !hasType(raster->datadef().domain<>()->valueType(), itNUMBER)){
        ERROR2(ERR_INVALID_PROPERTY_FOR_2, TR("Sample list domain"), raster->name());
        return;
    }
    if ( raster->size().zsize() > 1){
        if ( _sampleMap.isValid()){
            if (! _sampleMap->georeference()->isCompatible(raster->georeference())){
                ERROR2(ERR_NOT_COMPATIBLE2,raster->name(), _sampleMap->name());
                return ;
            }
        }
        _sampleMaps = raster;
    }
    else
        ERROR2(ERR_INVALID_PROPERTY_FOR_2, TR("Sample list size"), raster->name());
void SampleSet::sampleRaster(const IRasterCoverage& raster) {
    if ( _sampleMaps.isValid()){
        if (! _sampleMaps->georeference()->isCompatible(raster->georeference())){
       

            return ;
        }
    }
    _sampleMap = raster;
void SampleSet::thematicDomain(const IThematicDomain &dom)
    _sampleDomain = dom;
bool SampleSet::prepare()
    if (!isValid())
        return false;
    if ( !_sampleMap.isValid()){
        OperationHelperRaster::initialize(_sampleMaps, _sampleMap, itDOMAIN | itGEOREF | itCOORDSYSTEM | itENVELOPE);
        return true;
    }
    Identity::prepare();
    BoundingBox box = _sampleMaps->size();
    PixelIterator iterSampleMap(_sampleMap);
    PixelIterator iterBands(_sampleMaps);
    iterBands.setFlow(PixelIterator::fZXY);
    PixelIterator iterBandsEnd = iterBands.end();
    int nrOfBands = _sampleMaps->size().zsize();
    _sampleHistogram->prepare(_sampleDomain, _sampleMaps);
    _sampleSumXY->prepare(_sampleDomain, nrOfBands);
    _sampleSum->prepare(_sampleDomain, nrOfBands);
    _sampleStats->prepare(_sampleDomain, nrOfBands);
    while(iterBands != iterBandsEnd) {
        Raw raw = *iterSampleMap;
        if ( raw != 

            std::vector<double> zcolumn(nrOfBands, rUNDEF);
            for(double& v : zcolumn){
                v = *iterBands;
                ++iterBands;
            }
            for( int band = 0 ; band < nrOfBands; ++band){
                _sampleHistogram->at(raw ,band, zcolumn[band])++;
                _sampleSum->at(raw, band) += zcolumn[band];
                    _sampleSumXY->at(raw, band, otherBand) += (zcolumn[band] * zcolumn[otherBand]);
                }
            }
            _sampleSum->at(raw, box.zlength())++;
        }else
            iterBands += nrOfBands;
        ++iterSampleMap;
    }
    double sum, mean, num, std;
    for(int band = 0; band < nrOfBands; ++band){
        for(auto item : _sampleDomain) {
            num = _sampleSum->at(item->raw(), nrOfBands);
            if ( num == 0) {
                mean = std = 0;
            }else {
                sum = _sampleSum->at(item->raw(),band);
                mean = sum / num;
                if ( num < 

                    std = 0;
                } else {
                    double v = _sampleSumXY->at(item->raw(), band, band) - num * mean * mean;
                    std = v * v / ( num - 1);
                }
            }
            _sampleStats->at(item->raw(), band, SampleCell::mMEAN)= mean;
            _sampleStats->at(item->raw(), band, SampleCell::mSTANDARDDEV) = std;
        }
    }
    return true;
SampleSet &SampleSet::operator=(const SampleSet &sampleset)
    name(sampleset.name());
    code(sampleset.code());
    setId(sampleset.id());
    setDescription(sampleset.description());
    _sampleMap = sampleset._sampleMap;
    _sampleMaps = sampleset._sampleMaps;
    _sampleDomain = sampleset._sampleDomain;
    _sampleStats.reset(sampleset._sampleStats->copy<SampleStatistics>());
    _sampleHistogram.reset( sampleset._sampleHistogram->copy<SampleHistogram>());
    _sampleSum.reset(sampleset._sampleSum->copy<SampleSum>());
    _sampleSumXY.reset(sampleset._sampleSumXY->copy<S

    return *this;
Raw SampleSet::addClass(const QString& className){
    auto item = _sampleDomain->item(className);
    Raw raw = item->raw();
    if ( !_sampleHistogram->exists(raw)){
        ++_nrOfClasses;
        _sampleHistogram->addClass(raw);
        _sampleStats->addClass(raw);
        _sampleSum->addClass(raw);
        _sampleSumXY->addClass(raw);
    }
    return raw;
void SampleSet::deleteClass(Raw raw){
    if ( !_sampleHistogram->exists(raw))
        return;
    _sampleHistogram->delClass(raw);
    _sampleStats->delClass(raw);
    _sampleSum->delClass(raw);
    _sampleSumXY->delClass(raw);
    for(auto& v : _sampleMap)
        if ( v == raw)
            v = iUNDEF;
    for(auto& featureSpace : _featureSpaces)
        featureSpace.second->compute();
Raw SampleSet::mergeClass(Raw raw1, Raw raw2){
    if ( raw1 == raw2)
        return raw1;
    _sampleHistogram->mergeClass(raw1, raw2);
    _sampleSum->mergeClass(raw1, raw2);
    _sampleSumXY->mergeClass(raw1, raw2);
    _sa

    for(auto& v : _sampleMap)
        if ( v == raw2)
            v = raw1;
    for(auto& featureSpace : _featureSpaces)
        featureSpace.second->compute();
    return raw1;
void SampleSet::changeSums(const Pixel& pixel, Raw targetClass, int change){
    quint32 nrOfBands = _sampleMaps->size().zsize();
    _sampleSum->at(targetClass,nrOfBands)+=change;
    for(int band = 0 ; band < nrOfBands; ++band){
        Raw raw = _sampleMaps->pix2value(Pixel(pixel.x, pixel.y, pixel.z));
        _sampleHistogram->at(targetClass, band, raw)+=change;
        _sampleSum->at(targetClass, band) += raw;
        for(quint32 band2 = band; band2 < nrOfBands; ++band2){
            if ( band2 == band)
                _sampleSumXY->at(targetClass,band, band) += change * raw * raw;
            else
                _sampleSumXY->at(targetClass, band, band2) += change * raw * _sampleMaps->pix2value(Pixel(pixel.x, pixel.y, band2));
        }
    }
void SampleSet::decrementSums(const Pixel& pixel, Raw targetC

    changeSums(pixel, targetClass, -1);
void SampleSet::incrementSums(const Pixel& pixel, Raw targetClass){
    changeSums(pixel, targetClass, 1);
void SampleSet::incrementSampels(Raw newClass){
    quint32 nrOfBands = _sampleMaps->size().zsize();
    double mean = 0, std = 0, sum = 0;
    for(int band = 0 ; band < nrOfBands; ++band){
        quint32 num = _sampleSum->at(newClass, nrOfBands);
        mean = sum / num;
        if ( num == 0)
            mean = std = 0;
        else{
            sum =  _sampleSum->at(newClass, band);
        }
        std = num == 1 ? 0 : std::sqrt(_sampleSumXY->at(newClass, band, band) - num * mean * mean) / (num - 1);
        _sampleStats->at(newClass, band, SampleCell::mMEAN) = mean;
        _sampleStats->at(newClass, band, SampleCell::mSTANDARDDEV) = std;
    }
void SampleSet::registerFeatureSpace(FeatureSpace *fs)
    if(!fs)
        return;
    auto iter = _featureSpaces.find(fs->id());
    if ( iter !=  end(_featureSpaces)){
        _featureSpace
/* a StreamPage is a part of continuous memory
this page is get from the buffer manager
one page is divided into chunks
all chunks are connected by pointers 
pointer is saved at the chunk header inside each chunk
each chunk contains two parts: 
(1)the first is "chunk header", save the position of the next chunk
(2)the second is the remaining part of the chunk, save any information
*/
class StreamPage
private:
	char* buffer;
public:
	StreamPage(void)
	{
		this->buffer = MemoryManager::getInstance()->getOnePage();
	}
	~StreamPage(void){}
	inline void setPointerOfNextChunk(CHUNK_INDEX_TYPE chunk, MemoryPosition& memoryPosition)
	{
		char* buffer = this->buffer;
		int p = 0;
		*(PAGE_INDEX_TYPE*)(buffer + chunk* CHUNK_SIZE + p) = memoryPosition.pageIndex;
		p += sizeof(memoryPosition.pageIndex);
		*(PAGE_INDEX_TYPE*)(buffer + chunk* CHUNK_SIZE + p) = memoryPosition.chunkIndex;
	}
	inline void getPointerOfNextChunk(CHUNK_INDEX_TYPE chunk, MemoryPosition& memoryPosition)
	{
		char* buffer = 

		int p = 0;
		memoryPosition.pageIndex = *(PAGE_INDEX_TYPE*)(buffer + chunk* CHUNK_SIZE + p);
		p += sizeof(PAGE_INDEX_TYPE);
		memoryPosition.chunkIndex = *(CHUNK_INDEX_TYPE*)(buffer + chunk* CHUNK_SIZE + p);
	}
	inline void setValue( CHUNK_INDEX_TYPE chunkIndex,Element& element)
	{
		assert(element.getSize()<=CHUNK_SIZE);
		assert(chunkIndex<=CHUNK_NUMBER_ONE_PAGE);
		char* chunkPostion = this->buffer + chunkIndex*CHUNK_SIZE;
		int p= sizeof(CHUNK_INDEX_TYPE)+sizeof(PAGE_INDEX_TYPE);
		*(Timestamp*)(chunkPostion + p) = element.timestamp;
		p += TIMESTAMP_SIZE;
		*(DocumentId*)(chunkPostion + p) = element.id;
		p += DOCUMENT_IDENTIFIER_SIZE;
		*(Mark*)(chunkPostion + p) = element.mark;
		p += MARK_SIZE;
		*(MasterTag*)(chunkPostion + p) = element.masterTag;
		p += MASTER_TAG_SIZE;
		memcpy(chunkPostion + p, element.document.objdata(),element.document.objsize());
	}
	inline void getValue( CHUNK_INDEX_TYPE chunkIndex,Element& element )
	{
		assert(chunkIndex<=CHUNK_NUMBER_ONE_PAGE);
	
namespace handystats { namespace metrics_dump {
namespace stats {
metrics::gauge dump_time;
void initialize() {
	dump_time = metrics::gauge();
void finalize() {
	dump_time = metrics::gauge();
chrono::clock::time_point dump_timestamp;
std::mutex dump_mutex;
std::shared_ptr<const std::map<std::string, metrics::metric_variant>> dump(new std::map<std::string, metrics::metric_variant>());
const std::shared_ptr<const std::map<std::string, metrics::metric_variant>>
get_dump()
	std::lock_guard<std::mutex> lock(dump_mutex);
	return dump;
std::shared_ptr<const std::map<std::string, metrics::metric_variant>>
create_dump()
	auto dump_start_time = chrono::clock::now();
	std::shared_ptr<std::map<std::string, metrics::metric_variant>> new_dump(new std::map<std::string, metrics::metric_variant>());
	for (const auto& metric_entry : internal::metrics_map) {
		switch (metric_entry.second.which()) {
			case metrics::metric_index::GAUGE:
				new_dump->insert(
						std::pair<std::string, metrics::metric_va

							metric_entry.first,
							*boost::get<metrics::gauge*>(metric_entry.second)
						)
					);
				break;
			case metrics::metric_index::COUNTER:
				new_dump->insert(
						std::pair<std::string, metrics::metric_variant>(
							metric_entry.first,
							*boost::get<metrics::counter*>(metric_entry.second)
						)
					);
				break;
			case metrics::metric_index::TIMER:
				new_dump->insert(
						std::pair<std::string, metrics::metric_variant>(
							metric_entry.first,
							*boost::get<metrics::timer*>(metric_entry.second)
						)
					);
				break;
		}
	}
	{
		{
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handystats.internal.size",
						internal::stats::size
						)
					);
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handystats.internal.process_time",
						internal::stats::process_time
						)
					);
		}
		{
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handys

						message_queue::stats::size
						)
					);
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handystats.message_queue.message_wait_time",
						message_queue::stats::message_wait_time
						)
					);
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handystats.message_queue.pop_count",
						message_queue::stats::pop_count
						)
					);
		}
		{
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handystats.metrics_dump.dump_time",
						stats::dump_time
						)
					);
			new_dump->insert(
					std::pair<std::string, metrics::metric_variant>(
						"handystats.json_dump.dump_time",
						json_dump::stats::dump_time
						)
					);
		}
	}
	dump_timestamp = chrono::clock::now();
	stats::dump_time.set(chrono::duration_cast<chrono::time_duration>(dump_timestamp - dump_start_time).count(), dump_timestamp);
	return std::const_pointer_cast<const std::map<std::string, metrics::metric_variant>

void update() {
	if (config::metrics_dump.interval.count() == 0) {
		return;
	}
	if (chrono::duration_cast<std::chrono::nanoseconds>(chrono::clock::now() - dump_timestamp) > config::metrics_dump.interval) {
		auto new_dump = create_dump();
		{
			std::lock_guard<std::mutex> lock(dump_mutex);
			dump = new_dump;
		}
		if (config::metrics_dump.to_json) {
			json_dump::update();
		}
	}
void initialize() {
	stats::initialize();
	{
		std::lock_guard<std::mutex> lock(dump_mutex);
		dump_timestamp = chrono::clock::time_point();
		dump = std::shared_ptr<const std::map<std::string, metrics::metric_variant>>(new std::map<std::string, metrics::metric_variant>());
	}
	json_dump::initialize();
void finalize() {
	stats::finalize();
	{
		std::lock_guard<std::mutex> lock(dump_mutex);
		dump_timestamp = chrono::clock::time_point();
		dump = std::shared_ptr<const std::map<std::string, metrics::metric_variant>>(new std::map<std::string, metrics::metric_variant>());
	}
	json_dump::finalize();
const std::
/* Copyright (C) 2013 BMW Group
 * Author: Manfred Bathelt (manfred.bathelt@bmw.de)
 * Author: Juergen Gehring (juergen.gehring@bmw.de)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
namespace CommonAPI {
InputStream& operator>>(InputStream& inputStream, bool& boolValue) {
    return inputStream.readValue(boolValue);
InputStream& operator>>(InputStream& inputStream, int8_t& int8Value) {
    return inputStream.readValue(int8Value);
InputStream& operator>>(InputStream& inputStream, int16_t& int16Value) {
    return inputStream.readValue(int16Value);
InputStream& operator>>(InputStream& inputStream, int32_t& int32Value) {
    return inputStream.readValue(int32Value);
InputStream& operator>>(InputStream& inputStream, int64_t& int64Value) {
    return inputStream.readValue(int64Value);
InputStream& operator>>(InputStream& inputStream, uint8_t& uint8Value) {
    return inputStream.readValue(uint8Va

InputStream& operator>>(InputStream& inputStream, uint16_t& uint16Value) {
    return inputStream.readValue(uint16Value);
InputStream& operator>>(InputStream& inputStream, uint32_t& uint32Value) {
    return inputStream.readValue(uint32Value);
InputStream& operator>>(InputStream& inputStream, uint64_t& uint64Value) {
    return inputStream.readValue(uint64Value);
InputStream& operator>>(InputStream& inputStream, float& floatValue) {
    return inputStream.readValue(floatValue);
InputStream& operator>>(InputStream& inputStream, double& doubleValue) {
    return inputStream.readValue(doubleValue);
InputStream& operator>>(InputStream& inputStream, std::string& stringValue) {
    return inputStream.readValue(stringValue);
InputStream& operator>>(InputStream& inputStream, Version& versionValue) {
    return inputStream.readVersionValue(versionValue);
InputStream& operator>>(InputStream& inputStream, SerializableStruct& serializableStruct) {
    inputStream.beginReadSerializableStruct(seria
/*
 * $Id: TextLocatorBase.cpp,v 1.1 2009/02/02 05:14:35 stuart_hc Exp $
 *
 *
 *
 * Copyright (C) 2008  Philip de Nier <philipn@users.sourceforge.net>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
using namespace std;
using namespace mxfpp;
const mxfKey TextLocatorBase::setKey = MXF_SET_K(TextLoc
TAO::DCPS::RepoIdSet::~RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","~RepoIdSet",5);
void
TAO::DCPS::RepoIdSet::serialize(Serializer & serializer)
  DBG_ENTRY_LVL("RepoIdSet","serialize",5);
  CORBA::ULong sz = this->size ();
  serializer << sz;
  MapType::ENTRY* entry;
  for (MapType::ITERATOR itr(this->map_);
    itr.next(entry);
    itr.advance())
  {
    serializer << entry->ext_id_;
  }
bool
TAO::DCPS::RepoIdSet::is_subset (RepoIdSet& map)
  DBG_ENTRY_LVL("RepoIdSet","is_subset",5);
  if (this->size () <= map.size () && this->size () > 0)
  {
    MapType::ENTRY* entry;
    for (MapType::ITERATOR itr(this->map_);
      itr.next(entry);
      itr.advance())
    {
      MapType::ENTRY* ientry;
      if (map.map_.find (entry->ext_id_, ientry) != 0)
        return false;
    }
    return true;
  }
  return false;
bool
TAO::DCPS::RepoIdSet::exist (const RepoId& local_id,
                             bool& last)
  DBG_ENTRY_LVL("RepoIdSet","exist",5);
  last = true;
  RepoId remote;
  if (thi
namespace blink {
DEFINE_TRACE(MemoryCacheDumpClient) {}
MemoryCacheDumpProvider* MemoryCacheDumpProvider::instance() {
  DEFINE_STATIC_LOCAL(MemoryCacheDumpProvider, instance, ());
  return &instance;
bool MemoryCacheDumpProvider::OnMemoryDump(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* memoryDump) {
  DCHECK(isMainThread());
  if (!m_client)
    return false;
  WebMemoryDumpLevelOfDetail level;
  switch (args.level_of_detail) {
    case base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND:
      level = blink::WebMemoryDumpLevelOfDetail::Background;
      break;
    case base::trace_event::MemoryDumpLevelOfDetail::LIGHT:
      level = blink::WebMemoryDumpLevelOfDetail::Light;
      break;
    case base::trace_event::MemoryDumpLevelOfDetail::DETAILED:
      level = blink::WebMemoryDumpLevelOfDetail::Detailed;
      break;
    default:
      NOTREACHED();
      return false;
  }
  WebProcessMemoryDump dump(args.level_of_detail, memory
World::World(Player* player)
    
    this->player = player;
World::~World()
    std::map<std::array<int, 3>, Chunk*>::iterator it = chunks.begin();
    while(it != chunks.end())
    {
        delete it->second;
        chunks.erase(it++);
    }
void World::update()
    
    Chunk* oldChunk = getChunk(player->getOldX(), player->getOldY(), player->getOldZ());
    Chunk* currentChunk = getChunk(player->getX(), player->getY(), player->getZ());
        
    std::map<std::array<int, 3>, Chunk*>::iterator it = chunks.begin();
    
    if(currentChunk->getX() != oldChunk->getX() || currentChunk->getY() != oldChunk->getY() || currentChunk->getZ() != oldChunk->getZ())
    {
            
        while(it != chunks.end())
        {
                
            if(isInViewFrustum(*it->second))
            {
                
                if(!it->second->getGenerated())
                {
                    
                    generate(*it->second);
                    it->second->setGenerated(t

                        
                }
                
                it->second->update();
                it++;
                
            }
            else
            {
            
                delete it->second;
                chunks.erase(it++);
                
            }
            
        }
        
        for(int i = currentChunk->getX() - 4; i <= currentChunk->getX() + 4; i++)
        {
            
            for(int j = currentChunk->getY() - 4; j <= currentChunk->getY() + 4; j++)
            {
                
                for(int k = currentChunk->getZ() - 4; k < currentChunk->getZ() + 4; k++)
                {
                
                    setChunk(i, j, k);
                    
                }
                
            }
            
        }
        
    }
    else
    {
        
        while(it != chunks.end())
        {
                
            if(isInViewFrustum(*it->second))
            {
                
                

                {
                    
                    generate(*it->second);
                    it->second->setGenerated(true);
                        
                }
                
                it->second->update();
                
            }
            
            it++;
            
        }
        
    }
void World::render()
    for(std::map<std::array<int, 3>, Chunk*>::iterator it = chunks.begin(); it != chunks.end(); it++)
    {
        
        it->second->render();
    }
Chunk* World::getChunk(int x, int y, int z)
    
    float modifiedX = (float)x / (float)CHUNK_WIDTH;
    float modifiedY = (float)y / (float)CHUNK_WIDTH;
    float modifiedZ = (float)z / (float)CHUNK_WIDTH;
    int chunkX = (modifiedX < 0.0f) ? ceil(modifiedX - 0.5f) : floor(modifiedX + 0.5f);
    int chunkY = (modifiedY < 0.0f) ? ceil(modifiedY - 0.5f) : floor(modifiedY + 0.5f);
    int chunkZ = (modifiedZ < 0.0f) ? ceil(modifiedZ - 0.5f) : floor(modifiedZ + 0.5f);
    
    std::array<i

    
    if(chunks.find(chunkName) == chunks.end())
    {
        chunks[chunkName] = new Chunk(chunkX, chunkY, chunkZ);
    }
    return chunks[chunkName];
void World::setChunk(int x, int y, int z)
    std::array<int, 3> chunkName = {x, y, z};
    chunks[chunkName] = new Chunk(x, y, z);
    
Block* World::getBlock(int x, int y, int z)
    return getChunk(x, y, z)->getBlock(x, y, z);
void World::setBlock(int x, int y, int z, bool air)
    getChunk(x, y, z)->setBlock(x, y, z, air);
void World::generate(Chunk& chunk)
    
    if(chunk.getY() < 0)
    {
        
        for(int i = chunk.getX() * CHUNK_WIDTH - CHUNK_WIDTH / 2; i < chunk.getX() * CHUNK_WIDTH + CHUNK_WIDTH / 2; i++)
        {
            
            for(int j = chunk.getY() * CHUNK_WIDTH - CHUNK_WIDTH / 2; j < chunk.getY() * CHUNK_WIDTH + CHUNK_WIDTH / 2; j++)
            {
                
                for(int k = chunk.getZ() * CHUNK_WIDTH - CHUNK_WIDTH / 2; k < chunk.getZ() * CHUNK_WIDTH + CHUNK_WIDTH / 2; k++)
    
    /*
    Copyright (C) 2000 Stefan Westerfeld
                       stefan@space.twc.de
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.
  
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
   
    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
    */
using namespace Arts;
class KWidgetRepoShutdown : public StartupClass {
public:
	void startup() {};
	void shutdown()
	{
	
/**
* 
* @file
* @brief  Volume lookup table
* @author vitamin.caig@gmail.com
**/
namespace Devices
namespace AYM
  class MultiVolumeTable
  {
  public:
    MultiVolumeTable()
      : Table(0)
      , Layout(0)
    {
    }
    void SetParameters(ChipType type, LayoutType layout, const MixerType& mixer)
    {
      static const MultiSample IN_A = {{Sound::Sample::MAX, Sound::Sample::MID, Sound::Sample::MID}};
      static const MultiSample IN_B = {{Sound::Sample::MID, Sound::Sample::MAX, Sound::Sample::MID}};
      static const MultiSample IN_C = {{Sound::Sample::MID, Sound::Sample::MID, Sound::Sample::MAX}};
      const Sound::Sample::Type* const newTable = GetVolumeTable(type);
      const LayoutData* const newLayout = GetLayout(layout);
      if (Table != newTable
       || Layout != newLayout
       || !(Lookup[HIGH_LEVEL_A] == Mix(IN_A, mixer))
       || !(Lookup[HIGH_LEVEL_B] == Mix(IN_B, mixer))
       || !(Lookup[HIGH_LEVEL_C] == Mix(IN_C, mixer)))
      {
        Table = newTab

        Layout = newLayout;
        FillLookupTable(mixer);
      }
    }
    Sound::Sample Get(uint_t in) const
    {
      return Lookup[in];
    }
  private:
    static const Sound::Sample::Type* GetVolumeTable(ChipType type)
    {
      static const Sound::Sample::Type AYVolumeTab[32] =
      {
        ToSample(0x0000), ToSample(0x0000), ToSample(0x0340), ToSample(0x0340), ToSample(0x04C0), ToSample(0x04C0), ToSample(0x06F2), ToSample(0x06F2),
        ToSample(0x0A44), ToSample(0x0A44), ToSample(0x0F13), ToSample(0x0F13), ToSample(0x1510), ToSample(0x1510), ToSample(0x227E), ToSample(0x227E),
        ToSample(0x289F), ToSample(0x289F), ToSample(0x414E), ToSample(0x414E), ToSample(0x5B21), ToSample(0x5B21), ToSample(0x7258), ToSample(0x7258),
        ToSample(0x905E), ToSample(0x905E), ToSample(0xB550), ToSample(0xB550), ToSample(0xD7A0), ToSample(0xD7A0), ToSample(0xFFFF), ToSample(0xFFFF)
      };
      static const Sound::Sample::Type YMVolumeTab[32] =
      {
        ToSample(0

        ToSample(0x0611), ToSample(0x0782), ToSample(0x0912), ToSample(0x0A36), ToSample(0x0C31), ToSample(0x0EB6), ToSample(0x1130), ToSample(0x13A0),
        ToSample(0x1751), ToSample(0x1BF5), ToSample(0x20E2), ToSample(0x2594), ToSample(0x2CA1), ToSample(0x357F), ToSample(0x3E45), ToSample(0x475E),
        ToSample(0x5502), ToSample(0x6620), ToSample(0x7730), ToSample(0x8844), ToSample(0xA1D2), ToSample(0xC102), ToSample(0xE0A2), ToSample(0xFFFF)
      };
      switch (type)
      {
      case TYPE_YM2149F:
        return YMVolumeTab;
      default:
        return AYVolumeTab;
      }
    }
    static Sound::Sample::Type ToSample(uint_t val)
    {
      return Sound::Sample::MID + val * (Sound::Sample::MAX - Sound::Sample::MID) / (Sound::Sample::MAX - Sound::Sample::MIN);
    }
    typedef boost::array<uint_t, SOUND_CHANNELS> LayoutData;
    static const LayoutData* GetLayout(LayoutType type)
    {
      static const LayoutData LAYOUTS[] =
      {
      };
      return type == LAY

        ? 0
        : LAYOUTS + type;
    }
    typedef MixerType::InDataType MultiSample;
    void FillLookupTable(const MixerType& mixer)
    {
      for (uint_t idx = 0; idx != Lookup.size(); ++idx)
      {
        const MultiSample res =
        {{
          Table[idx & HIGH_LEVEL_A],
          Table[(idx >> BITS_PER_LEVEL) & HIGH_LEVEL_A],
          Table[idx >> 2 * BITS_PER_LEVEL]
        }};
        Lookup[idx] = Mix(res, mixer);
      }
    }
    Sound::Sample Mix(const MultiSample& in, const MixerType& mixer) const
    {
      if (Layout)
      {
        const MultiSample out =
        {{
          in[Layout->at(0)],
          in[Layout->at(1)],
          in[Layout->at(2)]
        }};
        return mixer.ApplyData(out);
      }
      {
        const Sound::Sample::Type avg = (int_t(in[0]) + in[1] + in[2]) / SOUND_CHANNELS;
        const MultiSample out = {{avg, avg, avg}};
        return mixer.ApplyData(out);
      }
    }
  private:
    const Sound::Sample::Type* Table;
   
typedef enum {
    SVR_PAUSED,
    SVR_UNPAUSED
} SVR_StreamState;
struct SVR_Stream_s {
    char* stream_name;
    char* source_name;
    IplImage* current_frame;
    SVR_StreamState state;
    SVR_FrameProperties* frame_properties;
    SVR_Encoding* encoding;
    SVR_Decoder* decoder;
    bool orphaned;
    pthread_cond_t new_frame;
    SVR_LOCKABLE;
};
void SVR_Stream_init(void);
SVR_Stream* SVR_Stream_new(const char* source);
void SVR_Stream_destroy(SVR_Stream* stream);
int SVR_Stream_setEncoding(SVR_Stream* stream, const char* encoding);
int SVR_Stream_resize(SVR_Stream* stream, int width, int height);
int SVR_Stream_setGrayscale(SVR_Stream* stream, bool grayscale);
int SVR_Stream_setPriority(SVR_Stream* stream, short priority);
int SVR_Stream_setDropRate(SVR_Stream* stream, int drop_rate);
int SVR_Stream_unpause(SVR_Stream* stream);
int SVR_Stream_pause(SVR_Stream* stream);
SVR_FrameProperties* SVR_Stream_getFrameProperties(SVR_Stream* stream);
IplImage* SVR_Stream_getFrame(SVR_S
FORCE_CHUNK_INCLUDE_IMPLEMENT(sndchunk)
RIF_IMPLEMENT_DYNCREATE("SOUNDOB2",Sound_Object_Chunk)
Sound_Object_Chunk::Sound_Object_Chunk (Chunk_With_Children * parent, 
	ChunkVectorInt & pos,
	const char * _name
	)
: Chunk (parent, "SOUNDOB2"), position (pos), 
	inner_range (0), outer_range (0), max_volume (0), pitch (0),
	flags (0), probability (0), pad3 (0),
	snd_name (0), wav_name (0)
	if (_name) 
	{
		snd_name = new char [strlen(_name)+1];
		strcpy (snd_name, _name);	
	}
	else
	{
		snd_name = new char [1];
		snd_name [0] = 0;
	}
Sound_Object_Chunk::~Sound_Object_Chunk()
	if (snd_name)
		delete [] snd_name;
	if (wav_name)
		delete [] wav_name;
Sound_Object_Chunk::Sound_Object_Chunk (Chunk_With_Children * parent, const char * data, size_t /*ssize*/)
: Chunk (parent, "SOUNDOB2"), snd_name (0), wav_name (0)
	position = *((ChunkVectorInt *) data);
	data += sizeof(ChunkVectorInt);
	inner_range = *((int *)data);
	data += 4;
	outer_range = *((int *)data);
	data += 4;
	max_volume = *((int *)da

	data += 4;
	pitch = *((int *)data);
	data += 4;
	flags = *((int *)data);
	data += 4;
	probability = *((int *)data);
	data += 4;
	pad3 = *((int *)data);
	data += 4;
	snd_name = new char [strlen (data) + 1];
	strcpy (snd_name, data);
	data += strlen (data) + 1;
	if (strlen(data))
	{
		wav_name = new char [strlen (data) + 1];
		strcpy (wav_name, data);
	}
void Sound_Object_Chunk::fill_data_block ( char * data_start)
	strncpy (data_start, identifier, 8);
	data_start += 8;
	*((int *) data_start) = chunk_size;
	data_start += 4;
	*((ChunkVectorInt *) data_start) = position;
	data_start += sizeof(ChunkVectorInt);
	*((int *)data_start) = inner_range;
	data_start += 4;
	*((int *)data_start) = outer_range;
	data_start += 4;
	*((int *)data_start) = max_volume;
	data_start += 4;
	*((int *)data_start) = pitch;
	data_start += 4;
	*((int *)data_start) = flags;
	data_start += 4;
	*((int *)data_start) = probability;
	data_start += 4;
	*((int *)data_start) = pad3;
	data_start += 4;
	sprintf (data_start

	data_start += strlen (snd_name) + 1;
	if (wav_name)
	{
		sprintf (data_start, "%s", wav_name);	
	}
	else
	{
		*data_start = 0;
	}
ObjectID Sound_Object_Chunk::CalculateID()
	ObjectID retval={0,0};
	char buffer[16];
	md5_buffer(snd_name,strlen(snd_name),&buffer[0]);
	buffer[7]=0;
	retval = *(ObjectID*)&buffer[0];
	return retval;
Sound_Object_Extra_Data_Chunk* Sound_Object_Chunk::get_extra_data_chunk()
	List<Chunk*> chlist;
	parent->lookup_child("SOUNDEXD",chlist);
	if(!chlist.size())return 0;
	for(LIF<Chunk*> chlif(&chlist);!chlif.done();chlif.next())
	{
		Sound_Object_Extra_Data_Chunk* soedc=(Sound_Object_Extra_Data_Chunk*)chlif();
		Sound_Object_Extra_Name_Chunk* sname=(Sound_Object_Extra_Name_Chunk*) soedc->lookup_single_child("SOUNDNAM");
		
		if(sname)
		{
			if(!strcmp(snd_name,sname->name))
			{
				return soedc;
			}
		}
	}
	return 0;
Sound_Object_Extra_Data_Chunk* Sound_Object_Chunk::create_extra_data_chunk()
	Sound_Object_Extra_Data_Chunk* soedc=get_extra_data_chunk();
	if(s

	return new Sound_Object_Extra_Data_Chunk(parent,this);
Object_Alternate_Locations_Chunk* Sound_Object_Chunk::get_alternate_locations_chunk()
	Sound_Object_Extra_Data_Chunk* soedc=get_extra_data_chunk();
	if(!soedc) return 0;
	return (Object_Alternate_Locations_Chunk*)soedc->lookup_single_child("ALTLOCAT");
Object_Alternate_Locations_Chunk* Sound_Object_Chunk::create_alternate_locations_chunk()
	Sound_Object_Extra_Data_Chunk* soedc=create_extra_data_chunk();
	Object_Alternate_Locations_Chunk* loc_chunk=(Object_Alternate_Locations_Chunk*)soedc->lookup_single_child("ALTLOCAT");
	if(loc_chunk) return loc_chunk;
	return new Object_Alternate_Locations_Chunk(soedc);
RIF_IMPLEMENT_DYNCREATE("SOUNDEXD",Sound_Object_Extra_Data_Chunk)
CHUNK_WITH_CHILDREN_LOADER("SOUNDEXD",Sound_Object_Extra_Data_Chunk)
/*
Children for Sound_Object_Extra_Data_Chunk :
"SOUNDNAM"		Sound_Object_Extra_Name_Chunk
"ALTLOCAT"		Object_Alternate_Locations_Chunk
*/
Sound_Object_Extra_Data_Chunk::Sound_Object_Extra_Data_Ch

:Chunk_With_Children(parent,"SOUNDEXD")
	new Sound_Object_Extra_Name_Chunk(this,soc->snd_name);	
Sound_Object_Chunk* Sound_Object_Extra_Data_Chunk::get_sound_chunk()
	List<Chunk*> chlist;
	lookup_child("SOUNDNAM",chlist);
	if(!chlist.size()) return 0;
	const char* name=((Sound_Object_Extra_Name_Chunk*)chlist.first_entry())->name;
	parent->lookup_child("SOUNDEXD",chlist);
	for(LIF<Chunk*> chlif(&chlist);!chlif.done();chlif.next())
	{
		Sound_Object_Chunk* soc=(Sound_Object_Chunk*)chlif();
		if(!strcmp(soc->snd_name,name))
		{
			return soc;
		}
	}
	return 0;
RIF_IMPLEMENT_DYNCREATE("SOUNDNAM",Sound_Object_Extra_Name_Chunk)
Sound_Object_Extra_Name_Chunk::Sound_Object_Extra_Name_Chunk(Chunk_With_Children * parent, const char * data, size_t /*size*/)
:Chunk(parent,"SOUNDNAM")
	int length=strlen(data);
	name=new char[length+1];
	strcpy(name,data);
Sound_Object_Extra_Name_Chunk::Sound_Object_Extra_Name_Chunk(Chunk_With_Children * parent, const char * _name)
:Chunk(parent,"SOUNDNAM")
	name=n

	strcpy(name,_name);
Sound_Object_Extra_Name_Chunk::~Sound_Object_Extra_Name_Chunk()
	delete name;
void Sound_Object_Extra_Name_Chunk::fill_data_block(char* data_start)
	strncpy (data_start, identifier, 8);
	data_start += 8;
	*((int *) data_start) = chunk_size;
	data_start += 4;
	strcpy(data_start,name);
size_t Sound_Object_Extra_Name_Chunk::size_chunk()
	chunk_size=12;
	chunk_size+=(strlen(name)+4)&~3;
	return chunk_size;
RIF_IMPLEMENT_DYNCREATE("INDSOUND",Indexed_Sound_Chunk)
Indexed_Sound_Chunk::Indexed_Sound_Chunk(Chunk_With_Children* parent,const char* data,const size_t)
:Chunk(parent,"INDSOUND")
	CHUNK_EXTRACT(index,int)
	CHUNK_EXTRACT_STRING(wav_name)
	CHUNK_EXTRACT(inner_range,int)
	CHUNK_EXTRACT(outer_range,int)
	CHUNK_EXTRACT(max_volume,int)
	CHUNK_EXTRACT(pitch,int)
	CHUNK_EXTRACT(flags,int)
	CHUNK_EXTRACT_ARRAY(num_extra_data,extra_data,int)
Indexed_Sound_Chunk::Indexed_Sound_Chunk(Chunk_With_Children* parent)
:Chunk(parent,"INDSOUND")
	index=0;
	wav_name=0;
	num_extra_dat

	extra_data=0;
Indexed_Sound_Chunk::~Indexed_Sound_Chunk()
	if(extra_data) delete [] extra_data;
	if(wav_name) delete [] wav_name;
void Indexed_Sound_Chunk::fill_data_block(char * data)
	CHUNK_FILL_START
	CHUNK_FILL(index,int)
	CHUNK_FILL_STRING(wav_name)
	CHUNK_FILL(inner_range,int)
	CHUNK_FILL(outer_range,int)
	CHUNK_FILL(max_volume,int)
	CHUNK_FILL(pitch,int)
	CHUNK_FILL(flags,int)
	CHUNK_FILL_ARRAY(num_extra_data,extra_data,int)
size_t Indexed_Sound_Chunk::size_chunk()
	chunk_size=12+24;
	chunk_size+=4+4*num_extra_data;
	if(wav_name)
		chunk_size+=(strlen(wav_name)+4)&~3;
	else
		chunk_size+=4;
	return chunk_size;
/*
Sound_Collection_Chunk::Sound_Collection_Chunk(Chunk_With_Children* parent,const char* data,const size_t)
:Chunk(parent,"SOUNDCOL")
	CHUNK_EXTRACT(index,int)
	CHUNK_EXTRACT_ARRAY(num_sounds,sounds,ChunkSoundWeighting)
	CHUNK_EXTRACT(spare,int)
Sound_Collection_Chunk::Sound_Collection_Chunk(Chunk_With_Children* parent)
:Chunk(parent,"SOUNDCOL")
	index=-1;
	num_sounds=0
namespace mlib
    template <typename T, std::size_t size_T = sizeof(T)>
    class List
    {
        private:
            template <typename TT>
            class Chunk
            {
                private:
                    std::size_t size;
                    Chunk<TT> * next;
                    Chunk<TT> * back;
                    unsigned char * data;
                public:
                    Chunk<TT>(std::size_t s)
                    {
                        size = s;
                        data = new_memory<unsigned char>(size * sizeof(TT), sizeof(TT));
                        next = 0;
                        back = 0;
                    }
                    Chunk<TT> * AddChunk()
                    {
                        Chunk<TT> * chunk = new Chunk<TT>(size);
                        Chunk<TT> * tmp = this;
                        while (tmp->next != 0) tmp = tmp->next;
                        tmp->next = chunk;
                        chunk->back = tmp;
   

                    }
                    void* Get(std::size_t num)
                    {
                        return reinterpret_cast<void*>(data + num * sizeof(TT));
                }
                    Chunk<TT>* GetNext()
                    {
                        return next;
                }
                    Chunk<TT>* GetBack()
                    {
                        return back;
                }
                    ~Chunk<TT>()
                    {
                        Chunk<TT> * tmp = this;
                        while (tmp->next != 0)
                        {
                                del_memory(static_cast<void*>(data));
                                tmp->next->back = tmp;
                                tmp = tmp->next;
                                tmp->back->~Chunk();
                        }
                    }
            };
            Chunk<T> * chunks;
            std::size_t chunk_size;
            std::size_t chunk_count;
   

            Chunk<T> * last;
            Chunk<T> * current;
            std::size_t current_n;
        public:
            List(std::size_t size_chunk = 1)
            {
                chunks = new Chunk<T>(size_chunk);
                chunk_size = size_chunk;
                chunk_count = 1;
                lenght = 0;
                first = chunks;
                current = first;
                last = first;
                current_n = 0;
            }
            ~List()
            {
                delete chunks;
            }
            void Add(T & item)
            {
                if (lenght >= chunk_size)
                {
                    last = chunks->AddChunk();
                    chunk_count++;
                    lenght = 0;
                }
                new(last->Get(lenght)) T(item);
                lenght++;
            }
            T Get(std::size_t index)
            {
                std::size_t num_chunk   = index / chunk_size;
                st
/********************************************************************
 ********************************************************************/
/* YGtkTreeModel, C++ wrapper for gtk+ */
                                         YGTK_TYPE_WRAP_MODEL, YGtkWrapModel))
                                         YGTK_TYPE_WRAP_MODEL, YGtkWrapModelClass))
                                         YGTK_TYPE_WRAP_MODEL, YGtkWrapModelClass))
struct YGtkWrapModel
	GObject parent;
	YGtkTreeModel *model;
	struct Notify;
	Notify *notify;
};
struct YGtkWrapModelClass
	GObjectClass parent_class;
};
static void ygtk_wrap_model_entry_changed (YGtkWrapModel *model, int row);
static void ygtk_wrap_model_entry_inserted (YGtkWrapModel *model, int row);
static void ygtk_wrap_model_entry_deleted (YGtkWrapModel *model, int row);
struct YGtkWrapModel::Notify : public YGtkTreeModel::Listener {
YGtkWrapModel *model;
	Notify (YGtkWrapModel *model) : model (model) {}
	virtual void rowChanged (int row)
	{ ygtk_wrap_model_

	virtual void rowInserted (int row)
	{ ygtk_wrap_model_entry_inserted (model, row); }
	virtual void rowDeleted (int row)
	{ ygtk_wrap_model_entry_deleted (model, row); }
};
static void ygtk_wrap_model_tree_model_init (GtkTreeModelIface *iface);
G_DEFINE_TYPE_WITH_CODE (YGtkWrapModel, ygtk_wrap_model, G_TYPE_OBJECT,
	G_IMPLEMENT_INTERFACE (GTK_TYPE_TREE_MODEL, ygtk_wrap_model_tree_model_init))
static void ygtk_wrap_model_init (YGtkWrapModel *zmodel)
{}
static void ygtk_wrap_model_finalize (GObject *object)
	YGtkWrapModel *ymodel = YGTK_WRAP_MODEL (object);
	delete ymodel->model;
	ymodel->model = NULL;
	delete ymodel->notify;
	ymodel->notify = NULL;
	G_OBJECT_CLASS (ygtk_wrap_model_parent_class)->finalize (object);
static GtkTreeModelFlags ygtk_wrap_model_get_flags (GtkTreeModel *model)
{ return (GtkTreeModelFlags) (GTK_TREE_MODEL_ITERS_PERSIST|GTK_TREE_MODEL_LIST_ONLY); }
static gboolean ygtk_wrap_model_get_iter (GtkTreeModel *model, GtkTreeIter *iter,
                                 

	YGtkWrapModel *ymodel = YGTK_WRAP_MODEL (model);
	gint index = gtk_tree_path_get_indices (path)[0];
	iter->user_data = GINT_TO_POINTER (index);
	int rowsNb = ymodel->model->rowsNb();
	if (!rowsNb && index == 0 && ymodel->model->showEmptyEntry())
		return TRUE;
	return index < rowsNb;
static GtkTreePath *ygtk_wrap_model_get_path (GtkTreeModel *model, GtkTreeIter *iter)
	int index = GPOINTER_TO_INT (iter->user_data);
	GtkTreePath *path = gtk_tree_path_new();
	gtk_tree_path_append_index (path, index);
	return path;
static gboolean ygtk_wrap_model_iter_next (GtkTreeModel *model, GtkTreeIter *iter)
	YGtkWrapModel *ymodel = YGTK_WRAP_MODEL (model);
	int index = GPOINTER_TO_INT (iter->user_data) + 1;
	iter->user_data = GINT_TO_POINTER (index);
	int rowsNb = ymodel->model->rowsNb();
	return index < rowsNb;
static gboolean ygtk_wrap_model_iter_parent (GtkTreeModel *, GtkTreeIter *, GtkTreeIter *)
{ return FALSE; }
static gboolean ygtk_wrap_model_iter_has_child (GtkTreeModel *, GtkTreeIter *)


static gint ygtk_wrap_model_iter_n_children (GtkTreeModel *model, GtkTreeIter *iter)
{ return 0; }
static gboolean ygtk_wrap_model_iter_nth_child (GtkTreeModel *model, GtkTreeIter *iter,
                                                GtkTreeIter  *parent, gint index)
	if (parent) return FALSE;
	YGtkWrapModel *ymodel = YGTK_WRAP_MODEL (model);
	iter->user_data = GINT_TO_POINTER (index);
	int rowsNb = ymodel->model->rowsNb();
	if (!rowsNb && index == 0 && ymodel->model->showEmptyEntry())
		return TRUE;
	return index < rowsNb;
static gboolean ygtk_wrap_model_iter_children (
	GtkTreeModel *model, GtkTreeIter *iter, GtkTreeIter  *parent)
{ return ygtk_wrap_model_iter_nth_child (model, iter, parent, 0); }
void ygtk_wrap_model_entry_changed (YGtkWrapModel *model, int row)
	GtkTreeIter iter;
	iter.user_data = GINT_TO_POINTER (row);
	GtkTreePath *path = ygtk_wrap_model_get_path (GTK_TREE_MODEL (model), &iter);
	gtk_tree_model_row_changed (GTK_TREE_MODEL (model), path, &iter);
	gtk_tree_path_f

void ygtk_wrap_model_entry_inserted (YGtkWrapModel *ymodel, int row)
	GtkTreeModel *model = GTK_TREE_MODEL (ymodel);
	GtkTreeIter iter;
	iter.user_data = GINT_TO_POINTER (row);
	GtkTreePath *path = ygtk_wrap_model_get_path (model, &iter);
	if (row == 0 && ymodel->model->rowsNb() == 1 && ymodel->model->showEmptyEntry())
		gtk_tree_model_row_changed (model, path, &iter);
	else
		gtk_tree_model_row_inserted (model, path, &iter);
	gtk_tree_path_free (path);
void ygtk_wrap_model_entry_deleted (YGtkWrapModel *ymodel, int row)
	GtkTreeModel *model = GTK_TREE_MODEL (ymodel);
	GtkTreeIter iter;
	iter.user_data = GINT_TO_POINTER (row);
	GtkTreePath *path = ygtk_wrap_model_get_path (model, &iter);
	if (row == 0 && ymodel->model->rowsNb() == 1 && ymodel->model->showEmptyEntry())
		gtk_tree_model_row_changed (model, path, &iter);
	else
		gtk_tree_model_row_deleted (model, path);
	gtk_tree_path_free (path);
static gint ygtk_wrap_model_get_n_columns (GtkTreeModel *model)
	YGtkWrapModel *ymodel = YGT

	return ymodel->model->columnsNb();
static GType ygtk_wrap_model_get_column_type (GtkTreeModel *model, gint column)
	YGtkWrapModel *ymodel = YGTK_WRAP_MODEL (model);
	return ymodel->model->columnType (column);
static void ygtk_wrap_model_get_value (GtkTreeModel *model, GtkTreeIter *iter,
                                       gint column, GValue *value)
	int row = GPOINTER_TO_INT (iter->user_data);
	YGtkWrapModel *ymodel = YGTK_WRAP_MODEL (model);
	g_value_init (value, ymodel->model->columnType (column));
	if (row == 0 && ymodel->model->rowsNb() == 0)
		row = -1;
	ymodel->model->getValue (row, column, value);
GtkTreeModel *ygtk_tree_model_new (YGtkTreeModel *model)
	YGtkWrapModel *ymodel = (YGtkWrapModel *) g_object_new (YGTK_TYPE_WRAP_MODEL, NULL);
	ymodel->model = model;
	ymodel->notify = new YGtkWrapModel::Notify (ymodel);
	model->listener = ymodel->notify;
	return GTK_TREE_MODEL (ymodel);
YGtkTreeModel *ygtk_tree_model_get_model (GtkTreeModel *model)
	YGtkWrapModel *ymodel = YGTK_
typedef INT32 stream_sample_t;
typedef struct _sound_stream sound_stream;
typedef void (*stream_callback)(void *param, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
int streams_init(void);
void streams_set_tag(void *streamtag);
void streams_frame_update(void);
/* core stream configuration and operation */
sound_stream *stream_create(int inputs, int outputs, int sample_rate, void *param, stream_callback callback);
void stream_set_input(sound_stream *stream, int index, sound_stream *input_stream, int output_index, float gain);
void stream_update(sound_stream *stream, int min_interval);	/* min_interval is in usec */
stream_sample_t *stream_consume_output(sound_stream *stream, int output, int samples);
/* utilities for accessing a particular stream */
sound_stream *stream_find_by_tag(void *streamtag, int streamindex);
int stream_get_inputs(sound_stream *stream);
int stream_get_outputs(sound_stream *stream);
void stream_set_input_gain(sound_stream *stream, int input, fl
namespace falcon {
template<std::size_t NumArg>
struct invoke_partial_param_loop_tag {};
template<std::size_t NumArg>
struct invoke_partial_recursive_param_loop_tag {};
/**
 * \brief Functor for used \link call-arguments \p invoke(), \p invoke_partial_param_loop() and \p invoke_partial_recursive_param_loop() \endlink
 *
 * Tag is \p invoke_partial_param_loop_tag for used \p invoke_partial_param_loop(), \p invoke_partial_recursive_param_loop_tag for used \p invoke_partial_recursive_param_loop(), each tag of \link indexes-tag indexes-tag \endlink or \p parameter_index
 * @{
 */
template <class Tag = full_parameter_index_tag>
struct invoke_adapter
  constexpr invoke_adapter() noexcept {}
  template<
    class Func, class... Args
  , class BuildIndexes = typename keep_parameter_index<
      typename parameter_index_or_tag_to_tag<Tag>::type, sizeof...(Args)
    >::type
  >
  constexpr CPP1X_DELEGATE_FUNCTION_NOEXCEPT(
    operator()(Func && f, Args&&... args) const
  , invoke(BuildIndexes()

};
template <std::size_t NumArg>
struct invoke_adapter<invoke_partial_param_loop_tag<NumArg>>
  template<class Func, class... Args>
  constexpr CPP1X_DELEGATE_FUNCTION_NOEXCEPT(
    operator()(Func && f, Args&&... args) const
  , invoke_partial_param_loop<NumArg>(
    std::forward<Func>(f), std::forward<Args>(args)...
  ))
};
template <std::size_t NumArg>
struct invoke_adapter<invoke_partial_recursive_param_loop_tag<NumArg>>
  template<class Func, class... Args>
  constexpr CPP1X_DELEGATE_FUNCTION_NOEXCEPT(
    operator()(Func && f, Args&&... args) const
  , invoke_partial_recursive_param_loop<NumArg>(
    std::forward<Func>(f), std::forward<Args>(args)...
  ))
};
template <class Tag>
invoke_adapter<Tag> make_invoke_adapter(Tag)
{ return {};  }
template<std::size_t Keep = 1>
using invoke_first_param_fn = invoke_adapter<first_parameter_index_tag<Keep>>;
template<std::size_t Keep = 1, class Function, class... Args>
constexpr CPP1X_DELEGATE_FUNCTION_NOEXCEPT(
  invoke_first_param(Functio

, invoke_first_param_fn<Keep>()(
    std::forward<Function>(func), std::forward<Args>(args)...
))
template<std::size_t Keep = 1>
using invoke_last_param_fn = invoke_adapter<last_parameter_index_tag<Keep>>;
template<std::size_t Keep = 1, class Function, class... Args>
constexpr CPP1X_DELEGATE_FUNCTION_NOEXCEPT(
  invoke_last_param(Function && func, Args&&... args)
, invoke_last_param_fn<Keep>()(
    std::forward<Function>(func), std::forward<Args>(args)...
))
template<std::size_t Start, std::size_t Len>
using invoke_range_param_fn
  = invoke_adapter<range_parameter_index_tag<Start, Len>>;
template<std::size_t Start, std::size_t Len, class Function, class... Args>
constexpr CPP1X_DELEGATE_FUNCTION_NOEXCEPT(
  invoke_range_param(Function && func, Args&&... args)
, invoke_range_param_fn<Start, Len>()(
    std::forward<Function>(func), std::forward<Args>(args)...
))
template<std::size_t Pos, std::size_t Ignore = 1>
using invoke_ignore_param_fn
  = invoke_adapter<ignore_parameter_index_tag<
void dump_file( const char *file, const char *str )
	FILE *fp = fopen( file, "a" );
	fprintf( fp, "%s\n\n", str );
	fclose( fp );
	{ \
		char str[256]; \
		dump_file( CALLER_FILE, str ); \
		dump_file( CALLER_FILE, TO_STR( CREATE_LUA_CALLER( i ) ) ); \
	}
	{ \
		char str[256]; \
		dump_file( BINDER_FILE, str ); \
		dump_file( BINDER_FILE, TO_STR( CREATE_LUA_BINDER( i ) ) ); \
	}
	{ \
		char str[256]; \
		dump_file( BIND_CALLER_FILE, str ); \
		dump_file( BIND_CALLER_FILE, TO_STR( PRIVATE_CREATE_CALLER( i ) ) ); \
	}
int main()
	DUMP_CALLER( 1 );
	DUMP_CALLER( 2 );
	DUMP_CALLER( 3 );
	DUMP_CALLER( 4 );
	DUMP_CALLER( 5 );
	DUMP_CALLER( 6 );
	DUMP_CALLER( 7 );
	DUMP_CALLER( 8 );
	DUMP_CALLER( 9 );
	DUMP_CALLER( 10 );
	DUMP_CALLER( 11 );
	DUMP_CALLER( 12 );
	DUMP_CALLER( 13 );
	DUMP_CALLER( 14 );
	DUMP_CALLER( 15 );
	DUMP_BINDER( 1 );
	DUMP_BINDER( 2 );
	DUMP_BINDER( 3 );
	DUMP_BINDER( 4 );
	DUMP_BINDER( 5 );
	DUMP_BINDER( 6 );
	DUMP_BINDER( 7 );
	DUMP_BINDER( 8 );
	DUMP_BINDER( 9 );
	DUMP
InstructionHandler::AInstructionHandler::AInstructionHandler(const std::string & IName)
  :InstructionName(IName)
InstructionHandler::AInstructionHandler::~AInstructionHandler()
const std::string & InstructionHandler::AInstructionHandler::getInstructionName() const
  return (this->InstructionName);
Instruction::IInstruction * InstructionHandler::AInstructionHandler::create() const
  Instruction::IInstruction  *instruct = createInstruction();
  return (instruct);
InstructionHandler::AddHandler::AddHandler()
  : AInstructionHandler("add")
InstructionHandler::AddHandler::~AddHandler()
Instruction::IInstruction * InstructionHandler::AddHandler::createInstruction() const
  return (new Instruction::Add());
InstructionHandler::SubHandler::SubHandler()
  : AInstructionHandler("sub")
InstructionHandler::SubHandler::~SubHandler()
Instruction::IInstruction * InstructionHandler::SubHandler::createInstruction() const
  return (new Instruction::Sub());
InstructionHandler::MulHandler::MulHandler()
  

InstructionHandler::MulHandler::~MulHandler()
Instruction::IInstruction * InstructionHandler::MulHandler::createInstruction() const
  return (new Instruction::Mul());
InstructionHandler::DivHandler::DivHandler()
  : AInstructionHandler("div")
InstructionHandler::DivHandler::~DivHandler()
Instruction::IInstruction * InstructionHandler::DivHandler::createInstruction() const
  return (new Instruction::Div());
InstructionHandler::ModHandler::ModHandler()
  : AInstructionHandler("mod")
InstructionHandler::ModHandler::~ModHandler()
Instruction::IInstruction * InstructionHandler::ModHandler::createInstruction() const
  return (new Instruction::Mod());
InstructionHandler::DumpHandler::DumpHandler()
  : AInstructionHandler("dump")
InstructionHandler::DumpHandler::~DumpHandler()
Instruction::IInstruction * InstructionHandler::DumpHandler::createInstruction() const
  return (new Instruction::Dump());
InstructionHandler::PopHandler::PopHandler()
  : AInstructionHandler("pop")
InstructionHandler::

Instruction::IInstruction * InstructionHandler::PopHandler::createInstruction() const
  return (new Instruction::Pop());
InstructionHandler::PrintHandler::PrintHandler()
  : AInstructionHandler("print")
InstructionHandler::PrintHandler::~PrintHandler()
Instruction::IInstruction * InstructionHandler::PrintHandler::createInstruction() const
  return (new Instruction::Print());
InstructionHandler::ExitHandler::ExitHandler()
  : AInstructionHandler("exit")
InstructionHandler::ExitHandler::~ExitHandler()
Instruction::IInstruction * InstructionHandler::ExitHandler::createInstruction() const
  return (new Instruction::Exit());
InstructionHandler::PushHandler::PushHandler()
  : AInstructionHandler("push")
InstructionHandler::PushHandler::~PushHandler()
Instruction::IInstruction * InstructionHandler::PushHandler::createInstruction() const
  return (new Instruction::Push());
InstructionHandler::AssertHandler::AssertHandler()
  : AInstructionHandler("assert")
InstructionHandler::AssertHandler::~
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla browser.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications, Inc.
 * Portions created by the Initial Developer are Copyright (C) 1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Travis Bogard <travis@netscape.com>
 *
 * Alternatively, the contents of this file may

 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g

 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LO

    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOA

    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline PRBool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    case LOAD_HIST
/*++
Copyright (c) 2011 Microsoft Corporation
Module Name:
    filter_model_converter.cpp
Abstract:
    Filter decls from a model
Author:
    Leonardo (leonardo) 2011-05-06
Notes:
--*/
filter_model_converter::~filter_model_converter() {
void filter_model_converter::operator()(model_ref & old_model, unsigned goal_idx) {
    TRACE("filter_mc", tout << "before filter_model_converter\n"; model_v2_pp(tout, *old_model); display(tout););
    ast_fast_mark1 fs;
    unsigned num = m_decls.size();
    for (unsigned i = 0; i < num; i++) 
        fs.mark(m_decls.get(i));
    model * new_model = alloc(model, m());
    num = old_model->get_num_constants();
    for (unsigned i = 0; i < num; i++) {
        func_decl * f = old_model->get_constant(i);
        if (fs.is_marked(f))
            continue;
        expr * fi     = old_model->get_const_interp(f);
        new_model->register_decl(f, fi);
    }
    num = old_model->get_num_functions();
    for (unsigned i = 0; i < num; i++) {
        func_decl *
namespace media {
int SampleFormatToBytesPerChannel(SampleFormat sample_format) {
  switch (sample_format) {
    case kUnknownSampleFormat:
      return 0;
    case kSampleFormatU8:
      return 1;
    case kSampleFormatS16:
    case kSampleFormatPlanarS16:
      return 2;
    case kSampleFormatS32:
    case kSampleFormatF32:
    case kSampleFormatPlanarF32:
    case kSampleFormatPlanarS32:
      return 4;
  }
  NOTREACHED() << "Invalid sample format provided: " << sample_format;
  return 0;
const char* SampleFormatToString(SampleFormat sample_format) {
  switch(sample_format) {
    case kUnknownSampleFormat:
      return "Unknown sample format";
    case kSampleFormatU8:
      return "Unsigned 8-bit with bias of 128";
    case kSampleFormatS16:
      return "Signed 16-bit";
    case kSampleFormatS32:
      return "Signed 32-bit";
    case kSampleFormatF32:
      return "Float 32-bit";
    case kSampleFormatPlanarS16:
      return "Signed 16-bit planar";
    case kSampleFormatPlanarF32
/********************************************************************
	Rhapsody	: 7.5 
	Login		: KBE
	Component	: TargetComponent 
	Configuration 	: Target
	Model Element	: SampleSet
	File Path	: C:/Ubuntu_share/sapien190/source/Sandbox/sapine_v1/rpy/SampleSet.cpp
*********************************************************************/
SampleSet::SampleSet() : num(2) {
SampleSet::~SampleSet() {
Sample* SampleSet::GetSample(int idx) {
    if (idx < num)
    	return &itsSample[idx];
    else
    	return 0;
int SampleSet::getItsSample() const {
    int iter = 0;
    return iter;
void SampleSet::SetSample(int idx, const Sample& sample) {
    if (idx < num)
    	itsSample[idx] = sample;
int SampleSet::getNum() const {
    return num;
void SampleSet::setNum(int p_num) {
    num = p_num;
WFDB_Annotation SampleSet::GetAnnotation(int idx) {
    
     if (idx < num)
    	return itsSample[idx].getAnnotation();
     else 
     	return Sample::FactoryAnnotation(NOTQRS);
     
void SampleSet::SetSampl
/** @file StreamInterface.cpp
 *  @ingroup Utils
 *
 *  @author Luk2010
 *  @version 0.1A
 *
 *  @date 04/01/2013 - 23/03/2014
 *
 *  Implements the Streams class.
 *
**/
namespace APro
    CursorStream::CursorStream()
    {
    }
    CursorStream::~CursorStream()
    {
    }
    bool CursorStream::operator bool() const
    {
        return !isEOS();
    }
    size_t CursorStream::size()
    {
        size_t _p, _ret;
        _p = tell();
        seek(0, CP_END);
        _ret = tell();
        seek(_p, CP_BEGIN);
        return ret;
    }
    InputStream::InputStream()
     : CursorStream()
    {
    }
    InputStream::~CursorStream()
    {
    }
    InputStream& InputStream::operator >> (String& str)
    {
        readWord(str);
        return *this;
    }
    InputStream& InputStream::operator >> (Real& r)
    {
        readReal(r);
        return *this;
    }
    InputStream& InputStream::operator >> (int& i)
    {
        readInt(i);
        return *this;
    }
    OutputStream::Ou
namespace frozenbyte {
    namespace filesystem {
        class IOutputStreamBuffer {
        public:
            virtual ~IOutputStreamBuffer() { }
            virtual void putByte(unsigned char byte) = 0;
        };
        class OutputStream {
            boost::shared_ptr<IOutputStreamBuffer> streamBuffer;
            bool textStrings;
        public:
            OutputStream();
            ~OutputStream();
            void setBuffer(boost::shared_ptr<IOutputStreamBuffer> streamBuffer);
        private:
            OutputStream&write(const std::string &value);
            OutputStream&write(bool value);
            OutputStream&write(unsigned char value);
            OutputStream&write(signed char value);
            OutputStream&write(unsigned short value);
            OutputStream&write(signed short value);
            OutputStream&write(unsigned int value);
            OutputStream&write(signed int value);
            OutputStream&write(float value);
            OutputStream&wri

            friend OutputStream &operator <<(OutputStream &, const std::string &);
            friend OutputStream &operator <<(OutputStream &, bool);
            friend OutputStream &operator <<(OutputStream &, unsigned char);
            friend OutputStream &operator <<(OutputStream &, signed char);
            friend OutputStream &operator <<(OutputStream &, unsigned short);
            friend OutputStream &operator <<(OutputStream &, signed short);
            friend OutputStream &operator <<(OutputStream &, unsigned int);
            friend OutputStream &operator <<(OutputStream &, signed int);
            friend OutputStream &operator <<(OutputStream &, float);
            friend OutputStream &operator <<(OutputStream &, double);
        };
        inline OutputStream &operator << (OutputStream &stream, const std::string &value) { return stream.write(value); }
        inline OutputStream &operator << (OutputStream &stream, bool value) { return stream.write(value);  }
        inl
inline
Rice::detail::Exception_Handler::
Exception_Handler(
    Data_Object<Exception_Handler> next_exception_handler)
  : next_exception_handler_(next_exception_handler)
  , next_exception_handler_guard_(&next_exception_handler_)
inline
Rice::detail::Exception_Handler::
~Exception_Handler()
inline
VALUE
Rice::detail::Exception_Handler::
call_next_exception_handler() const
  return next_exception_handler_->handle_exception();
inline Rice::detail::Default_Exception_Handler::
Default_Exception_Handler()
  : Exception_Handler(
      Data_Object<Exception_Handler>(0, rb_cObject))
inline
VALUE
Rice::detail::Default_Exception_Handler::
handle_exception() const
  throw;
template <typename Exception_T, typename Functor_T>
inline
Rice::detail::Functor_Exception_Handler<Exception_T, Functor_T>::
Functor_Exception_Handler(
    Functor_T handler,
    Data_Object<Exception_Handler> next_exception_handler)
  : Exception_Handler(next_exception_handler)
  , handler_(handler)
template <typename Excepti
class Object_Chunk;
class Object_Hierarchy_Data_Chunk;
class Object_Hierarchy_Name_Chunk;
class Shape_Chunk;
	class INode;
class Object_Hierarchy_Chunk : public Chunk_With_Children
public:
	Object_Hierarchy_Chunk(Chunk_With_Children * parent)
	: Chunk_With_Children (parent, "OBJCHIER")
	{}
	Object_Hierarchy_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
	List <Object_Hierarchy_Chunk *> list_h_children();
	Object_Hierarchy_Data_Chunk * get_data ();
	Object_Hierarchy_Name_Chunk * get_name ();
	INode* node;
};
class Object_Hierarchy_Data_Chunk : public Chunk
public:
	Object_Hierarchy_Data_Chunk (Object_Hierarchy_Chunk * parent, const char * obname);
	Object_Hierarchy_Data_Chunk (Chunk_With_Children * parent, const char * sdata, size_t /*ssize*/);
	~Object_Hierarchy_Data_Chunk ();
	int num_extra_data;
	int* extra_data;
	Object_Chunk * const object;
	virtual size_t size_chunk ();
	virtual void fill_data_block (char * data_start);
	virtual void post_input_processing()

	char * ob_name;
private:
	friend class Object_Hierarchy_Chunk;
};
class Object_Hierarchy_Name_Chunk : public Chunk 
public:
	Object_Hierarchy_Name_Chunk (Object_Hierarchy_Chunk * parent, const char * hname);
	Object_Hierarchy_Name_Chunk (Chunk_With_Children * parent, const char * sdata, size_t /*ssize*/);
	~Object_Hierarchy_Name_Chunk();
	char * hierarchy_name;
	virtual size_t size_chunk ()
	{
		return(chunk_size = 12 + strlen (hierarchy_name) + 4 - strlen (hierarchy_name)%4);
	}
	virtual void fill_data_block (char * data_start);
private:
	friend class Object_Hierarchy_Chunk;
};
struct Replaced_Shape_Details
	~Replaced_Shape_Details()
	{
		if(old_object_name) delete old_object_name;
		if(new_object_name) delete new_object_name;
	}
	char* old_object_name;
	char* new_object_name;
};
class Object_Hierarchy_Alternate_Shape_Set_Chunk : public Chunk
public :
	Object_Hierarchy_Alternate_Shape_Set_Chunk(Chunk_With_Children* parent,int num,const char* name);
	Object_Hierarchy_Alternate_Shape_

	Object_Hierarchy_Alternate_Shape_Set_Chunk (Chunk_With_Children * parent, const char * data, size_t /*ssize*/);
	~Object_Hierarchy_Alternate_Shape_Set_Chunk();
	virtual size_t size_chunk();
	virtual void fill_data_block (char * data_start);
	char* Shape_Set_Name;
	int Shape_Set_Num;
	List<Replaced_Shape_Details*> Replaced_Shape_List; 
	int flags;
	int spare[3];
private:
};
class Hierarchy_Shape_Set_Collection_Chunk : public Chunk
public :
	Hierarchy_Shape_Set_Collection_Chunk(Chunk_With_Children* parent,int num,const char* name);
	Hierarchy_Shape_Set_Collection_Chunk (Chunk_With_Children * parent, const char * data, size_t /*ssize*/);
	~Hierarchy_Shape_Set_Collection_Chunk();
	virtual size_t size_chunk();
	virtual void fill_data_block (char * data_start);
	char* Set_Collection_Name;
	int Set_Collection_Num;
	List<int> Index_List; 
	int TypeIndex;
	int flags;
};
class Hierarchy_Degradation_Distance_Chunk : public Chunk
public :
	Hierarchy_Degradation_Distance_Chunk(Chunk_With_Children
using namespace nspace;
ModelNode * ModelBuilderBase::createNode(){return new ModelNode;};
Connection * ModelBuilderBase::createConnection(){return new Connection;}
Connector * ModelBuilderBase::createConnector(){return new Connector;}
const Set<Model*> ModelBuilderBase::models()const{
  return _models;
ModelBuilderBase::ModelBuilderBase(){
  reset();
void ModelBuilderBase::reset(){
  _currentModel=0;
  _currentElement=0;
Model * ModelBuilderBase::currentModel(){
  return _currentModel;
Model * ModelBuilderBase::beginModel(){
  _currentModel = new Model();
  addElement(_currentModel);
  _models.add(_currentModel);
  return _currentModel;
Model * ModelBuilderBase::endModel(){
  buildModel(*_currentModel);
  Model * model = _currentModel;
  _currentModel =0;
  return model;
ModelNode * ModelBuilderBase::addNode(){
  ModelNode * node = createNode();
  _currentModel->nodes().add(node);
  return node;
Connector * ModelBuilderBase::addConnector(const std::string & nodeName){
  return 0;
Conn
grid_list::grid_list() {}
grid_list::~grid_list()
   {clear();}
void grid_list::clear()
   {
   unsigned int i;
   for (i=0; i<m_layer.getsize(); i++) delete m_layer[i];
   m_layer.setsize(0);
   }
void grid_list::append(grid_layer *layer)
   {grid_layers::append(layer);}
grid_layer *grid_list::load(ministring repo,ministring path)
   {
   grid_layer_db *layer_db;
   grid_layer_pnm *layer_pnm;
   grid_layer_gdal *layer_gdal;
   if (path.startswith("/") ||
       path.startswith("\\")) repo="";
   layer_db=new grid_layer_db();
   if (layer_db==NULL) MEMERROR();
   layer_db->set_repo(repo);
   if (layer_db->load(path))
      {
      grid_layers::append(layer_db);
      return(layer_db);
      }
   else delete layer_db;
   layer_pnm=new grid_layer_pnm();
   if (layer_pnm==NULL) MEMERROR();
   layer_pnm->set_repo(repo);
   if (layer_pnm->load(path))
      {
      grid_layers::append(layer_pnm);
      return(layer_pnm);
      }
   else delete layer_pnm;
   layer_gdal=new grid_layer_gdal();


   layer_gdal->set_repo(repo);
   if (layer_gdal->load(path))
      {
      grid_layers::append(layer_gdal);
      return(layer_gdal);
      }
   else delete layer_gdal;
   return(NULL);
   }
BOOLINT grid_list::tryload(ministring repo,ministring path)
   {
   grid_layer *layer=load(repo,path);
   if (layer==NULL) return(FALSE);
   remove(layer);
   return(TRUE);
   }
BOOLINT grid_list::exists(ministring repo,ministring path)
   {
   if (!repo.empty())
      if (repo.last()!='/' && repo.last()!='\\') repo.append("/");
   return(checkfile((repo+path).c_str())!=0);
   }
grid_layer *grid_list::multiload(ministring repo,ministring path,
                                 int &layers)
   {
   const char *file;
   ministring fname;
   unsigned int idx;
   grid_layer *layer;
   layers=0;
   layer=NULL;
   if (path.find("*",idx))
      {
      if (!repo.empty())
         if (repo.last()!='/' && repo.last()!='\\') repo.append("/");
      filesearch((repo+path).c_str());
      while ((file=findfil

         {
         fname=ministring(file);
         fname.substitute(repo,"");
         if (load(repo,fname)!=NULL) layers++;
         }
      }
   else
      {
      layer=load(repo,path);
      if (layer!=NULL) layers++;
      }
   return(layer);
   }
BOOLINT grid_list::save(ministring repo,ministring path,grid_layer *layer,
                        double compression)
   {
   BOOLINT success;
   grid_layer_gdal *layer_gdal;
   layer_gdal=new grid_layer_gdal(*layer);
   layer_gdal->set_repo(repo);
   success=layer_gdal->save(path,compression);
   delete layer_gdal;
   return(success);
   }
BOOLINT grid_list::save_db(ministring repo,ministring path,grid_layer *layer,
                           BOOLINT autocompress,BOOLINT zcompress)
   {
   BOOLINT success;
   ministring tmp;
   tmp=layer->get_repo();
   layer->set_repo(repo);
   success=layer->save_db(path,autocompress,zcompress);
   layer->set_repo(tmp);
   return(success);
   }
void grid_list::set_repo(ministring repo)
   {
   uns

   ministring path;
   for (i=0; i<m_layer.getsize(); i++)
      {
      path=m_layer[i]->get_repo()+m_layer[i]->get_path();
      if (path.startswith(repo))
         {
         m_layer[i]->set_repo(repo);
         m_layer[i]->set_path(path.suffix(repo));
         }
      else
         {
         m_layer[i]->set_repo("");
         m_layer[i]->set_path(path);
         }
      }
   }
grid_list *grid_list::clone()
   {
   unsigned int i;
   grid_list *list;
   grid_layer *layer;
   list=new grid_list();
   for (i=0; i<m_layer.getsize(); i++)
      {
      layer=new grid_layer(*m_layer[i]);
      if (layer==NULL) MEMERROR();
      list->append(layer);
      }
   return(list);
   }
void grid_list::clone(const grid_layers *layers)
   {
   unsigned int i;
   grid_layer *layer;
   clear();
   for (i=0; i<layers->get_num(); i++)
      {
      layer=new grid_layer(*layers->get(i));
      if (layer==NULL) MEMERROR();
      append(layer);
      }
   }
void grid_list::remove(unsigned int n)
   {
 
/**
 *  @file LB_LoadMinimum.h
 *
 *  $Id$
 *
 *  @author Jaiganesh Balasubramanian <jai@dre.vanderbilt.edu>
 *          Ossama Othman <ossama@uci.edu>
 */
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO_LB
  /**
   * @name Default LoadMinimum strategy parameters.
   *
   * Defaults defined by the Load Balancing specification.
   */
  const CORBA::Float LM_DEFAULT_TOLERANCE = 1;
  const CORBA::Float LM_DEFAULT_DAMPENING = 0;
  const CORBA::Float LM_DEFAULT_PER_BALANCE_LOAD = 0;
  /**
   * @name TAO-specific LoadMinimum strategy parameters.
   *
   * Parameters internal to TAO's LoadMinimum strategy
   * implementation.
   */
  /**
   * If the percent difference between two loads, i.e.:
   *   (Old Load - New Load) / New Load
   * is less than or equal to this value, the two loads will be
   * considered equivalent.  In such a case, an object group member
   * residing at the location corresponding to one of the two loads
   * will be selected at random.
   */
/**
 * @class TAO_LB_Load

 *
 * @brief "Least loaded" load balancing strategy
 *
 * This load balancing strategy is designed to select an object group
 * member residing at a location with the smallest load.
 */
class TAO_LB_LoadMinimum
  : public virtual POA_CosLoadBalancing::Strategy
public:
  TAO_LB_LoadMinimum (PortableServer::POA_ptr poa);
  /**
   * @name CosLoadBalancing::Strategy methods
   *
   * Methods required by the CosLoadBalancing::Strategy interface.
   */
  virtual char * name (void);
  virtual CosLoadBalancing::Properties * get_properties ();
  virtual void push_loads (
      const PortableGroup::Location & the_location,
      const CosLoadBalancing::LoadList & loads);
  virtual CosLoadBalancing::LoadList * get_loads (
      CosLoadBalancing::LoadManager_ptr load_manager,
      const PortableGroup::Location & the_location);
  virtual CORBA::Object_ptr next_member (
      PortableGroup::ObjectGroup_ptr object_group,
      CosLoadBalancing::LoadManager_ptr load_manager);
  virtual void analyze_

      PortableGroup::ObjectGroup_ptr object_group,
      CosLoadBalancing::LoadManager_ptr load_manager);
  virtual PortableServer::POA_ptr _default_POA (
    );
  void init (const PortableGroup::Properties & props);
protected:
  ~TAO_LB_LoadMinimum (void);
  CORBA::Boolean get_location (CosLoadBalancing::LoadManager_ptr load_manager,
                               const PortableGroup::Locations & locations,
                               PortableGroup::Location & location);
  CORBA::Float effective_load (CORBA::Float previous_load,
                               CORBA::Float new_load);
  void push_loads (
      const PortableGroup::Location & the_location,
      const CosLoadBalancing::LoadList & loads,
      CosLoadBalancing::Load & effective_load);
  void extract_float_property (const PortableGroup::Property & property,
                               CORBA::Float & value);
private:
  PortableServer::POA_var poa_;
  TAO_LB_LoadMap * load_map_;
  TAO_SYNCH_MUTEX * lock_;
  CosLoadBal
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
using std::string;
using std::ostream;
class c_header_gen_class
 protected:
  string author;
  string externfunctions;
  string fields;
  string funbody;
  string genconv;
  string genname;
  string genparameters;
  string genstring;
  string othercomments;
  string package;
  string structname;
  string version;
 public:
  c_header_gen_class()
  {
  }
  
  {
  }
  virtual ~c_header_gen_class()
  {
  }
  static void
  generate_string(const string &s, ostream &stream, unsigned int indent)
  {
    if (!indent || s.find('\n') == string::npos)
      {
        stream << s;
        return;
      }
    string::size_type pos;
    string::size_type start = 0;
    string ind (indent, ' ');
    while ( (pos=s.find('\n', start)) != string::npos)
      {
        stream << s.substr (start, (pos+1)-start);
        start = pos+1;
        if (start+1 <= s.size ())
          stream << ind;
      }
    if (start+1 <= s.size ())
 

  }
  void set_author(const string &_author)
  {
    author = _author;
  }
  virtual void generate_externfunctions(ostream &stream, unsigned int indent) = 0;
  void set_externfunctions(const string &_externfunctions)
  {
    externfunctions = _externfunctions;
  }
  virtual void generate_fields(ostream &stream, unsigned int indent) = 0;
  void set_fields(const string &_fields)
  {
    fields = _fields;
  }
  virtual void generate_funbody(ostream &stream, unsigned int indent) = 0;
  void set_funbody(const string &_funbody)
  {
    funbody = _funbody;
  }
  virtual void generate_genconv(ostream &stream, unsigned int indent) = 0;
  void set_genconv(const string &_genconv)
  {
    genconv = _genconv;
  }
  void set_genname(const string &_genname)
  {
    genname = _genname;
  }
  virtual void generate_genparameters(ostream &stream, unsigned int indent) = 0;
  void set_genparameters(const string &_genparameters)
  {
    genparameters = _genparameters;
  }
  virtual void generate_genstring(

  void set_genstring(const string &_genstring)
  {
    genstring = _genstring;
  }
  {
  }
  void set_othercomments(const string &_othercomments)
  {
    othercomments = _othercomments;
  }
  void set_package(const string &_package)
  {
    package = _package;
  }
  void set_structname(const string &_structname)
  {
    structname = _structname;
  }
  void set_version(const string &_version)
  {
    version = _version;
  }
  void generate_c_header(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * File automatically generated by";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    generate_string (package, stream, indent + indent_str.length ());
    stream << " ";
    generate_string (version, stream, indent + indent_str.length ());
    stream << " ";
    generate_string (author, stream, indent + indent_str.length ());
    stream <<

    stream << indent_str;
    stream << " * ";
    generate_string (othercomments, stream, indent + indent_str.length ());
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "extern \"C\" {";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "struct ";
    generate_string (structname, stream, indent + indent_str.length ());
    stream << "\n";
    stream << indent_str;
    stream << "{";
    stream << "\

    stream << indent_str;
    indent = 2;
    if (fields.size () > 0)
      generate_string (fields, stream, indent + indent_str.length ());
    else
      generate_fields (stream, indent + indent_str.length ());
    indent = 0;
    stream << indent_str;
    stream << "};";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    if (externfunctions.size () > 0)
      generate_string (externfunctions, stream, indent + indent_str.length ());
    else
      generate_externfunctions (stream, indent + indent_str.length ());
    stream << indent_str;
    stream << "void";
    stream << "\n";
    stream << indent_str;
    stream << "generate_";
    generate_string (genname, stream, indent + indent_str.length ());
    stream << "(FILE *stream, struct ";
    generate_string (structname, stream, indent + indent_str.length ());
    stream << " *record, unsigned int indent);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << i

    stream << "void";
    stream << "\n";
    stream << indent_str;
    stream << "generatep_";
    generate_string (genname, stream, indent + indent_str.length ());
    stream << "(FILE *stream, unsigned int indent";
    if (genparameters.size () > 0)
      generate_string (genparameters, stream, indent + indent_str.length ());
    else
      generate_genparameters (stream, indent + indent_str.length ());
    stream << ");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "char *";
    stream << "\n";
    stream << indent_str;
    stream << "genstring_";
    generate_string (genname, stream, indent + indent_str.length ());
    stream << "(struct ";
    generate_string (structname, stream, indent + indent_str.length ());
    stream << " *record, unsigned int indent);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "char *";
    stream << "\n";
    stream << indent_str;

    stream << "genstringp_";
    generate_string (genname, stream, indent + indent_str.length ());
    stream << "(unsigned int indent";
    if (genparameters.size () > 0)
      generate_string (genparameters, stream, indent + indent_str.length ());
    else
      generate_genparameters (stream, indent + indent_str.length ());
    stream << ");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "int";
    stream << "\n";
    stream << indent_str;
    stream << "strcnt_";
    generate_string (genname, stream, indent + indent_str.length ());
    stream << "(struct ";
    generate_string (structname, stream, indent + indent_str.length ());
    stream << " *record, unsigned int indent);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "void";
    stream << "\n";
    stream << indent_str;
    stream << "init_";
    generate_string (structname, stream, indent + indent_str.leng

    stream << "(struct ";
    generate_string (structname, stream, indent + indent_str.length ());
    stream << " *record);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    if (genstring.size () > 0)
      generate_string (genstring, stream, indent + indent_str.length ());
    else
      generate_genstring (stream, indent + indent_str.length ());
    stream << indent_str;
    if (genconv.size () > 0)
      generate_string (genconv, stream, indent + indent_str.length ());
    else
      generate_genconv (stream, indent + indent_str.length ());
    stream << indent_str;
    if (funbody.size () > 0)
      generate_string (funbody, stream, indent + indent_str.length ());
    else
      generate_funbody (stream, indent + indent_str.length ());
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n
enum Process { OTHER, TEST, DATA, WW, WZ, ZZ, VV, We, Wm, Wt, DYee, DYmm, DYtt,
	       ttbar, ttMadgraph, tW, singleTop_tChannel, singleTop_sChannel, 
	       LM0, LM1, LM2, LM2mhfeq360, LM3, LM4, LM5, LM6, LM7, LM8, LM9, LM9p, LM9t175, LM10, LM11, LM12, LM13,
	       InclusiveMuPt15, InclusiveMuPt15dilep,
	       QCDBCtoEPt20to30, QCDBCtoEPt30to80, QCDBCtoEPt80to170, QCDBCtoEPt20to170,
	       QCDEMenrichedPt20to30, QCDEMenrichedPt30to80, QCDEMenrichedPt80to170, QCDEMenrichedPt20to170,
	       QCDpt15, QCDpt30, QCDpt80, QCDpt170, QCDpt1400,
	       photonJetPt20to30, photonJetPt30to50, photonJetPt50to80, photonJetPt80to120, photonJetPt120to170, photonJetPt170to300, photonJetPt20to300,
	       singleElectron, singleGamma};
class TChain;
class Sample {
public:
     TChain 		*chain;
     enum Process 	process;
     int		histo_color;
     double		kFactor;
     std::string	name;
     bool               sm;
     double             upper_pthat;
};
Sample operator + (const Sample &, const Sa

TChain *makeChain (const char *sample_glob, const char *name = "Events");
Sample fFreeForm (const char *sample_glob, enum Process = OTHER, int histo_color = kBlack, 
		  double kFactor = 1, std::string = "other", bool = 1, double = -1);
Sample fTest ();
Sample fdata		   ();
Sample fWW	           ();
Sample fWZ	           ();
Sample fZZ	           ();
Sample fVV		   ();
Sample fWe                 ();
Sample fWmu                ();
Sample fWtau               ();
Sample fWeJets	           ();
Sample fWmJets	           ();
Sample fWtJets	           ();
Sample fZee 	           ();
Sample fZmm 	           ();
Sample fZtt 	           ();
Sample fZeejets            ();
Sample fZmmjets            ();
Sample fZttjets            ();
Sample fttbar	           ();
Sample fttMadgraph         ();
Sample ftW	           ();
Sample fSingleTop_tChannel ();
Sample fSingleTop_sChannel ();
Sample fLM0                ();
Sample fLM1                ();
Sample fLM2                ();
Sample fLM2mhfeq360       

Sample fLM3                ();
Sample fLM4                ();
Sample fLM5                ();
Sample fLM6                ();
Sample fLM7                ();
Sample fLM8                ();
Sample fLM9                ();
Sample fLM9p               ();
Sample fLM9t175            ();
Sample fLM10               ();
Sample fLM11               ();
Sample fLM12               ();
Sample fLM13               ();
  
Sample fInclusiveMuPt15	        ();
Sample fInclusiveMuPt15dilep    ();
Sample fQCDBCtoEPt20to30	();
Sample fQCDBCtoEPt30to80	();
Sample fQCDBCtoEPt80to170	();
Sample fQCDBCtoEPt20to170       ();
Sample fQCDEMenrichedPt20to30	();
Sample fQCDEMenrichedPt30to80	();
Sample fQCDEMenrichedPt80to170  ();
Sample fQCDEMenrichedPt20to170  ();
Sample fQCDpt15                 ();
Sample fQCDpt30                 ();
Sample fQCDpt80                 ();
Sample fQCDpt170                ();
Sample fQCDpt1400               ();
Sample fphotonJetPt20to30       ();
Sample fphotonJetPt30to50       ();
Sampl
int main(int argc, char * argv[]){
    MemoryChunk* chunk;
    chunk = new MemoryChunk();
    int i = 12;
    chunk->set_content(0, &i, sizeof(int));
    int * p = (int *)chunk->begin();
    assert(chunk->size() == sizeof(int));
    printf("%d\n", *p);
    printf("%ld\n", chunk->capacity());
    p = & i;
    chunk->set_chunk(p, sizeof(int), NULL);
    short t = 5;
    chunk->set_content(sizeof(int), &t, sizeof(short));
    assert( sizeof(int) + sizeof(short) == chunk->size());
    printf("%ld\n", chunk->capacity());
    p = (int *)chunk->begin();
    short * p2 =(short *)(((char *) (chunk->begin())) + sizeof(int));
    printf("%d\t%d\n", *p, *p2);
    chunk->set_content(sizeof(int) + sizeof(short), &t, sizeof(short));
  
    assert( sizeof(int) + (sizeof(short) << 1) == chunk->size());
    printf("%ld\n", chunk->capacity());
    p = (int *)chunk->begin();
    p2 =(short *)(((char *) (chunk->begin())) + sizeof(int));
    printf("%d\t%d\t%d\n", *p, *p2, *(p2 + 1));
    chunk->set_size(si

    p = (int *)chunk->begin();
    p2 =(short *)(((char *) (chunk->begin())) + sizeof(int));
    chunk->set_content(0, &i, sizeof(int));
    *(p2+2) = 3;
    printf("%d\t%d\t%d\t%d\n", *p, *p2, *(p2 + 1), *(p2+2));
    int m = 10;
    chunk->set_chunk(&m, sizeof(int), NULL);
    int n = 12;
    chunk->insert_content(sizeof(int), &n, sizeof(int));
    n = 11;
    chunk->insert_content(sizeof(int), &n, sizeof(int));
    int * p3 = (int *)chunk->begin();
    printf("%d\t%d\t%d\n", *p3, *(p3+1), *(p3+2));
    chunk->remove_content(sizeof(int), sizeof(int));
    printf("%d\t%d\n", *p3, *(p3+1));
    int tmp;
    assert(chunk->get_content(sizeof(int), &tmp, sizeof(int)));
    printf("%d\n", tmp);
    delete chunk;
    const char * filename =  "/tmp/version";
    const char * version = "0.2.0";
    chunk =  new MemoryChunk;
    bool retval = chunk->load(filename);
    if ( !retval ){
        fprintf(stderr, "can't find chunk\n");
    }else if ( memcmp(version, chunk->begin(), strlen(version)
static const int RESOLUTION_FAILURE_DELAY_MS = 1;
static const int RESOLUTION_SUCCESS_DELAY_MS = 2;
ChannelLocatorConnection::ChannelLocatorConnection( const std::string& channel_locator_address )
    : omni_thread( NULL, omni_thread::PRIORITY_NORMAL ),
      m_running( true ),
      m_condition( &m_mutex ),
      m_connection_status( DISCONNECTED ),
      m_channel_locator_address( channel_locator_address )
    m_channel_locator_ior = "corbaloc::" + m_channel_locator_address + "/ChannelLocator";
    start_undetached();
    BOOST_LOG(m_log) << __FUNCTION__ << " - " << m_channel_locator_ior;
ChannelLocatorConnection::~ChannelLocatorConnection()
    BOOST_LOG(m_log) << __FUNCTION__ << " - " << m_channel_locator_ior << ", observer-size = " << m_observers.size();
void* ChannelLocatorConnection::run_undetached( void* )
    unsigned long abs_sec = 0;
    unsigned long abs_nsec = 0;
    while ( m_running )
    {
        while ( m_observers.empty() && m_running )
        {
            m_condit

        }
        if ( ! m_running )
        {
            break;
        }
        if ( CORBA::is_nil(m_channel_locator) )
        {
            m_channel_locator = Corba::string_to_object<TA_Base_Core::IChannelLocator>( m_channel_locator_ior );
            if ( CORBA::is_nil( m_channel_locator ) )
            {
                if ( m_connection_status != DISCONNECTED )
                {
                    m_connection_status = DISCONNECTED;
                    notify_observer( DISCONNECTED );
                }
            }
            else
            {
                try
                {
                    CORBA::String_var id = m_channel_locator->getID();
                    m_channel_mapping = m_channel_locator->getChannels();
                    m_connection_status = CONNECTED;
                    Notify::initialize( m_channel_mapping[0].channel );
                    if ( m_channel_locator_id.empty() )
                    {
                        m_channel_locator_id = id

                        notify_observer( CONNECTED );
                    }
                    else if ( m_channel_locator_id != id.in() )
                    {
                        m_channel_locator_id = id.in();
                        notify_observer( RESTARTED );
                    }
                    else
                    {
                        notify_observer( CONNECTED );
                    }
                }
                catch ( CORBA::Exception& e )
                {
                    BOOST_LOG(m_log) << __FUNCTION__ << ":" << __LINE__ << " - " << Corba::exception_to_string(e);
                    m_channel_locator = TA_Base_Core::IChannelLocator::_nil();
                }
            }
        }
        else
        {
            try
            {
                CORBA::String_var id = m_channel_locator->getID();
                if ( m_channel_locator_id != id.in() )
                {
                    m_channel_locator_id = id.in();
                   

                    Notify::initialize( m_channel_mapping[0].channel );
                    notify_observer( RESTARTED );
                }
            }
            catch ( CORBA::Exception& e )
            {
                BOOST_LOG(m_log) << __FUNCTION__ << ":" << __LINE__ << " - " << Corba::exception_to_string(e);
                m_channel_locator = TA_Base_Core::IChannelLocator::_nil();
                m_connection_status = DISCONNECTED;
                notify_observer( DISCONNECTED );
            }
        }
        omni_thread::get_time( &abs_sec, &abs_nsec, ( m_connection_status == CONNECTED ? RESOLUTION_SUCCESS_DELAY_MS : RESOLUTION_FAILURE_DELAY_MS ), 0 );
        m_condition.timedwait( abs_sec, abs_nsec );
    }
    return NULL;
void ChannelLocatorConnection::terminate()
    m_running = false;
    m_observers.clear();
    m_condition.signal();
std::string ChannelLocatorConnection::get_channel_locator_ior()
    return m_channel_locator_ior;
TA_Base_Core::IChannelLocator_var

    return m_channel_locator;
CosNA::EventChannel_var ChannelLocatorConnection::get_channel( const std::string& name )
    for ( size_t i = 0; i < m_channel_mapping->length(); ++i )
    {
        if ( name == m_channel_mapping[i].channelName.in() )
        {
            return m_channel_mapping[i].channel;
        }
    }
    return CosNA::EventChannel::_nil();
void ChannelLocatorConnection::notify_observer( EConnectionStatus status )
    const char* s[] = { "CONNECTED", "DISCONNECTED", "RESTARTED" };
    BOOST_LOG(m_log) << __FUNCTION__ << " - " << s[status] << " (" << m_channel_locator_address << "), observers-size=" << m_observers.size();
    for ( std::set<IChannelLocatorObserver*>::iterator it = m_observers.begin(); it != m_observers.end(); ++it )
    {
        if ( status == CONNECTED )
        {
            (*it)->connection_connected();
        }
        else if ( status == DISCONNECTED )
        {
            (*it)->connection_disconnected();
        }
        else
        {

namespace cheaproute {
static void TestCharacterByCharacter(size_t max_read_size, size_t buffer_size) {
  BufferedInputStream stream(shared_ptr<InputStream>(
    new FakeInputStream(max_read_size, "Hello World!")), buffer_size);
  
  ASSERT_EQ('H', stream.Peek());
  ASSERT_EQ('H', stream.Read());
  ASSERT_EQ('e', stream.Read());
  ASSERT_EQ('l', stream.Read());
  ASSERT_EQ('l', stream.Read());
  ASSERT_EQ('o', stream.Read());
  ASSERT_EQ(' ', stream.Read());
  ASSERT_EQ('W', stream.Peek());
  ASSERT_EQ('W', stream.Peek());
  ASSERT_EQ('W', stream.Read());
  ASSERT_EQ('o', stream.Read());
  ASSERT_EQ('r', stream.Read());
  ASSERT_EQ('l', stream.Read());
  ASSERT_EQ('d', stream.Read());
  ASSERT_EQ('!', stream.Read());
  ASSERT_EQ(-1, stream.Read());
  ASSERT_EQ(-1, stream.Read());
  ASSERT_EQ(-1, stream.Read());
  ASSERT_EQ(-1, stream.Peek());
TEST(BufferedInputStreamTest, CharacterByCharacterReading) {
  TestCharacterByCharacter(100, 4);
  TestCharacterByCharacter(6, 4);
  TestCharacte

  TestCharacterByCharacter(2, 4);
  TestCharacterByCharacter(1, 4);
  TestCharacterByCharacter(2, 100);
  TestCharacterByCharacter(100, 100);
static string ReadString(InputStream* stream, size_t size) {
  vector<char> buffer;
  buffer.resize(size);
  size_t bytes_read = stream->Read(&buffer[0], size);
  assert(bytes_read >= 0);
  assert(bytes_read <= size);
  return string(&buffer[0], bytes_read);
TEST(BufferedInputStreamTest, NormalReading) {
  BufferedInputStream stream(shared_ptr<InputStream>(
    new FakeInputStream(6, "Hello World!")), 4);
  
  ASSERT_EQ("Hello ", ReadString(&stream, 6));
  ASSERT_EQ("W", ReadString(&stream, 1));
  ASSERT_EQ("orl", ReadString(&stream, 10));
  ASSERT_EQ("d!", ReadString(&stream, 10));
  ASSERT_EQ("", ReadString(&stream, 10));
TEST(BufferedOutputStreamTest, CharacterByCharacterWriting) {
  MemoryOutputStream* memOutStream = new MemoryOutputStream();
  BufferedOutputStream stream(shared_ptr<OutputStream>(memOutStream), 5);
  stream.Write('a');
  str
enum {
    REPO_ITEM_TYPE,
    REPO_CATEGORY_TYPE
};
/**
 * Represent a repo
 */
class RepoItem : public QStandardItem {
public:
    RepoItem(const ServerRepo& repo);
    void setRepo(const ServerRepo& repo);
    void setLocalRepo(const LocalRepo& repo);
    virtual int type() const { return REPO_ITEM_TYPE; }
    const ServerRepo& repo() const { return repo_; }
    const LocalRepo& localRepo() const { return local_repo_; }
    /**
     * Every time the item is painted, we record the metrics of each part of
     * the item on the screen. So later we the mouse click/hover the item, we
     * can decide which part is hovered, and to do corresponding actions.
     */
    struct Metrics {
        QRect icon_rect;
        QRect name_rect;
        QRect subtitle_rect;
        QRect status_icon_rect;
    };
    void setMetrics(const Metrics& metrics) const { metrics_ = metrics; }
    const Metrics& metrics() const { return metrics_; }
    void setCloneTask(const CloneTask& task=CloneTask()) { 
extern FileManager* pFileManager;
Mix_Chunk* concat2Chunks(Mix_Chunk* sound1, Mix_Chunk* sound2)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = sound1->volume;
	returnChunk->alen = sound1->alen + sound2->alen;
	if((returnChunk->abuf = (Uint8 *)malloc(returnChunk->alen)) == NULL) {
		free(returnChunk);
		return NULL;
	}
	memcpy(returnChunk->abuf, sound1->abuf, sound1->alen);
	memcpy(returnChunk->abuf + sound1->alen, sound2->abuf, sound2->alen);
	return returnChunk;
Mix_Chunk* concat3Chunks(Mix_Chunk* sound1, Mix_Chunk* sound2, Mix_Chunk* sound3)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = sound1->volume;
	returnChunk->alen = sound1->alen + sound2->alen + sound3->alen;
	if((returnChunk->abuf = (Uint8 *)malloc(returnChunk->alen)) == NULL) {
		free(return

		return NULL;
	}
	memcpy(returnChunk->abuf, sound1->abuf, sound1->alen);
	memcpy(returnChunk->abuf + sound1->alen, sound2->abuf, sound2->alen);
	memcpy(returnChunk->abuf + sound1->alen + sound2->alen, sound3->abuf, sound3->alen);
	return returnChunk;
Mix_Chunk* concat4Chunks(Mix_Chunk* sound1, Mix_Chunk* sound2, Mix_Chunk* sound3, Mix_Chunk* sound4)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = sound1->volume;
	returnChunk->alen = sound1->alen + sound2->alen + sound3->alen + sound4->alen;
	if((returnChunk->abuf = (Uint8 *)malloc(returnChunk->alen)) == NULL) {
		free(returnChunk);
		return NULL;
	}
	memcpy(returnChunk->abuf, sound1->abuf, sound1->alen);
	memcpy(returnChunk->abuf + sound1->alen, sound2->abuf, sound2->alen);
	memcpy(returnChunk->abuf + sound1->alen + sound2->alen, sound3->abuf, sound3->alen);
	memcpy(returnChunk->abuf + sound1->alen + sound2->alen + sou

	return returnChunk;
Mix_Chunk* createEmptyChunk()
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = 0;
	returnChunk->alen = 0;
	returnChunk->abuf = NULL;
	return returnChunk;
Mix_Chunk* createSilenceChunk(int length)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = MIX_MAX_VOLUME;
	returnChunk->alen = length;
	if((returnChunk->abuf = (Uint8 *)calloc(returnChunk->alen,1)) == NULL) {
		free(returnChunk);
		return NULL;
	}
	return returnChunk;
Mix_Chunk* getChunkFromFile(std::string filename) {
	Mix_Chunk* returnChunk;
	SDL_RWops* rwop;
	if((rwop = pFileManager->openFile(filename)) == NULL) {
		fprintf(stderr,"getChunkFromFile(): Cannot open %s!\n",filename.c_str());
		exit(EXIT_FAILURE);
	}
	if((returnChunk = LoadVOC_RW(rwop, 1)) == NULL) {
		fprintf(stderr,"
typedef struct _model {
        kvec_t(Literal) model_stack; /* Keeps track of the state of the model */ 
        int last2propagated, last3propagated, lastNpropagated;
        kvec_t(char) assignment; /*truth value of each literal*/
        unsigned int decision_lvl;
        kvec_t(VarInfo) vinfo; /*keeps track of each variable*/
        Literal dlMarker;
        unsigned int n_vars;
        unsigned int n_lits;
} Model;
void model_set_true_decision(Model *model, Literal l);
void model_set_true_w_reason(Literal l, Reason r, Model *model);
void push(Literal lit, Model *model);
void set_true_in_assignment(Literal lit, Model *model);
void set_undef_in_assignment(Literal lit, Model *model);
void init_in_assignment(Var var, Model *model);
void model_init(unsigned int num_vars, Model *model);
bool model_lit_is_of_current_dl(Literal lit, Model *model);
unsigned int model_get_lit_dl(Literal lit, Model *model);
unsigned int model_get_lit_height(Literal lit, Model *model);
Literal  model_pop_an
namespace VideoCapture {
RotateBy180DegreesSampleConverter::RotateBy180DegreesSampleConverter() {
RGBVideoFormat RotateBy180DegreesSampleConverter::convertedSampleFormat(
    RGBVideoFormat inputSampleFormat) const {
  if (!inputSampleFormat) {
    return inputSampleFormat;
  }
  boost::int32_t angleRotationDegrees(inputSampleFormat.angleRotationDegrees());
  angleRotationDegrees = (angleRotationDegrees + kAngleHalfRotationDegrees);
  angleRotationDegrees = (angleRotationDegrees % kAngleFullRotationDegrees);
  RGBVideoFormat outputSampleFormat(
      inputSampleFormat.uuid(),
      inputSampleFormat.sizePixels(),
      angleRotationDegrees,
      inputSampleFormat.rgbFormat());
  return outputSampleFormat;
void RotateBy180DegreesSampleConverter::convertSample(
      RGBVideoSampleRef inputSample,
      RGBVideoSampleRef outputSample) const {
  typedef RGBVideoFrame::ImageViewType ImageViewType;
  typedef RGBVideoSample::SampleDataSharedPtr SampleDataSharedPtr;
  if (!inputSample) {
   
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
namespace repo {
namespace core {
/*!
 * Repo severity levels according to RFC 5424, the SysLog protocol.
 */
class REPO_CORE_EXPORT RepoSeverity
public :
typedef enum
    REPO_PANIC_NUM      = 7,
    REPO_ALERT_NUM      = 6,
    REPO_CRITICAL_NUM   = 5,
    REPO_ERROR_NUM      = 4,
    REPO_WARNING_NUM    = 3,
    REPO_NOTICE_NUM     = 2,
    REPO_

    REPO_DEBUG_NUM      = 0
} Level;
private:
    RepoSeverity(const std::string &color, const std::string &level, int);
public :
    RepoSeverity();
    inline bool operator==(const RepoSeverity &s) const
    {   return
                this->color == s.color &&
                this->level == s.level &&
                this->value == s.value;  }
    inline bool operator<(const RepoSeverity &s) const
    {   return this->value < s.value; }
    friend std::ostream& operator<<(std::ostream& os, const RepoSeverity &s)
    {   os << s.toString(); return os;  }
    std::string toString() const { return level; }
    std::string getColor() const { return color;}
    int getValue() const { return value; }
    /*!
     * Returns an integer representation of the severity level to use with
     * swtich statements. \sa Level
     */
    operator int() const { return value; }
    static const RepoSeverity REPO_PANIC;
    static const RepoSeverity REPO_ALERT;
    static const RepoSeverity REPO_CRIT
namespace mU {
namespace Function {
FUNCTION_API var Factorial(uint);
FUNCTION_API var Binomial(Var,uint);
FUNCTION_API var Binomial(Var,uint);
FUNCTION_API var Fibonacci(uint);
FUNCTION_API var Lucas(uint);
FUNCTION_API var Euler();
FUNCTION_API var Catalan();
FUNCTION_API var Log(Var);
FUNCTION_API var Log2(Var);
FUNCTION_API var Log10(Var);
FUNCTION_API var Exp(Var);
FUNCTION_API var Exp2(Var);
FUNCTION_API var Exp10(Var);
FUNCTION_API var Cos(Var);
FUNCTION_API var Sin(Var);
FUNCTION_API var Tan(Var);
FUNCTION_API var Sec(Var);
FUNCTION_API var Csc(Var);
FUNCTION_API var Cot(Var);
FUNCTION_API var Acos(Var);
FUNCTION_API var Asin(Var);
FUNCTION_API var Atan(Var);
FUNCTION_API var Cosh(Var);
FUNCTION_API var Sinh(Var);
FUNCTION_API var Tanh(Var);
FUNCTION_API var Sech(Var);
FUNCTION_API var Csch(Var);
FUNCTION_API var Coth(Var);
FUNCTION_API var Acosh(Var);
FUNCTION_API var Asinh(Var);
FUNCTION_API var Atanh(Var);
FUNCTION_API var Gamma(Var);
FUNCTION_API var Lngamma(Var);
FUNCTION_
class MsvServerMessage : public QObject
	Q_OBJECT
public:
	MsvServerMessage(QObject *parent = 0);
	bool isAuthentication() const;
	bool isServerInfo() const;
	bool isJoinTable() const;
	bool isPlayerJoinChair() const;
	bool isGameAction() const;
	bool isYourTurn() const;
	bool isAuthFailed() const;
	AuthInfoModel* getAuthInfoModel() const;
	ServerInfoModel* getServerInfoModel() const;
	JoinTableInfoModel* getJoinTableInfoModel() const;
	PlayerJoinChairModel* getPlayerJoinChairModel() const;
	PokerRoomModel* getPokerRoomModel() const;
	void setAuthInfoModel(AuthInfoModel* model);
	void setServerInfoModel(ServerInfoModel* model);
	void setJoinTableInfoModel(JoinTableInfoModel* model);
	void setPlayerJoinChairModel(PlayerJoinChairModel* model);
	void setPokerRoomModel(PokerRoomModel* model);
	void setType(QString* type);
	QString* getType() const;
private:
	QString* type;
	AuthInfoModel* authModel;
	ServerInfoModel* serverInfoModel;
	JoinTableInfoModel* joinTableInfoModel;
	PlayerJoinChai
/******************************************************************************
* function : show Canny sample
******************************************************************************/
HI_VOID SAMPLE_IVE_Canny(HI_CHAR chComplete);
/******************************************************************************
* function : show BgModel sample
******************************************************************************/
HI_VOID SAMPLE_IVE_BgModel(HI_CHAR chEncode, HI_CHAR chVo);
/******************************************************************************
* function : show Gmm sample
******************************************************************************/
HI_VOID SAMPLE_IVE_Gmm(HI_CHAR chEncode, HI_CHAR chVo);
/******************************************************************************
* function : show Occlusion detected sample
******************************************************************************/
HI_VOID SAMPLE_IVE_Od(HI_VOID);
/****************************

* function : show Test Memory sample
******************************************************************************/
HI_VOID SAMPLE_IVE_TestMemory(HI_VOID);
/******************************************************************************
* function : show Sobel sample
******************************************************************************/
HI_VOID SAMPLE_IVE_Sobel(HI_VOID);
/******************************************************************************
* function : show Ann sample
******************************************************************************/
HI_VOID SAMPLE_IVE_Ann(HI_VOID);
/******************************************************************************
* function : show St Lk sample
******************************************************************************/
HI_VOID SAMPLE_IVE_St_Lk(HI_VOID);
/******************************************************************************
* function : show Svm sample
***********************************************************
namespace psddl_hdf2psana {
DefaultChunkPolicy::DefaultChunkPolicy(hsize_t chunkSizeTargetBytes,
    int chunkSizeTarget,
    hsize_t maxChunkSizeBytes,
    int minObjectsPerChunk,
    int maxObjectsPerChunk,
    hsize_t minChunkCacheSize,
    hsize_t maxChunkCacheSize)
  : m_chunkSizeTargetBytes(chunkSizeTargetBytes)
  , m_maxChunkSizeBytes(maxChunkSizeBytes)
  , m_chunkSizeTarget(chunkSizeTarget)
  , m_minObjectsPerChunk(minObjectsPerChunk)
  , m_maxObjectsPerChunk(maxObjectsPerChunk)
  , m_minChunkCacheSize(minChunkCacheSize)
  , m_maxChunkCacheSize(maxChunkCacheSize)
DefaultChunkPolicy::~DefaultChunkPolicy ()
int
DefaultChunkPolicy::chunkSize(const hdf5pp::Type& dsType) const
  const size_t obj_size = dsType.size();
  int chunk = m_chunkSizeTarget > 0 ? m_chunkSizeTarget : m_chunkSizeTargetBytes / obj_size;
  if (chunk > m_maxObjectsPerChunk) {
    chunk = m_maxObjectsPerChunk;
  } else if (chunk < m_minObjectsPerChunk) {
    chunk = m_minObjectsPerChunk;
  }
  if (chunk*obj_size >
TEST(TrickTest, OneColour)
	model::Trick t(model::Denomination::HEARTS);
	t.addCard(model::Card(model::Suit::DIAMONDS, model::Rank::TEN));
	ASSERT_FALSE(t.hasEnded());
	t.addCard(model::Card(model::Suit::DIAMONDS, model::Rank::TWO));
	t.addCard(model::Card(model::Suit::DIAMONDS, model::Rank::KING));
	t.addCard(model::Card(model::Suit::DIAMONDS, model::Rank::QUEEN));
	ASSERT_TRUE(t.hasEnded());
	ASSERT_EQ(2, t.getWinner());
TEST(TrickTest, TrumpBeat)
	model::Trick t(model::Denomination::SPADES);
	ASSERT_FALSE(t.hasEnded());
	t.addCard(model::Card(model::Suit::CLUBS, model::Rank::ACE));
	t.addCard(model::Card(model::Suit::CLUBS, model::Rank::KING));
	t.addCard(model::Card(model::Suit::CLUBS, model::Rank::QUEEN));
	t.addCard(model::Card(model::Suit::SPADES, model::Rank::TWO));
	ASSERT_EQ(3, t.getWinner());
	ASSERT_TRUE(t.hasEnded());
TEST(TrickTest, TwoTrumps)
	model::Trick t(model::Denomination::DIAMONDS);
	t.addCard(model::Card(model::Suit::SPADES, model::Rank::ACE));
	t.addCard(model::

	t.addCard(model::Card(model::Suit::SPADES, model::Rank::TWO));
	ASSERT_FALSE(t.hasEnded());
	t.addCard(model::Card(model::Suit::DIAMONDS, model::Rank::JACK));
	ASSERT_EQ(3, t.getWinner());
	ASSERT_TRUE(t.hasEnded());
TEST(TrickTest, WrongColour)
	model::Trick t(model::Denomination::CLUBS);
	t.addCard(model::Card(model::Suit::SPADES, model::Rank::TWO));
	t.addCard(model::Card(model::Suit::HEARTS, model::Rank::SEVEN));
	ASSERT_FALSE(t.hasEnded());
	t.addCard(model::Card(model::Suit::DIAMONDS, model::Rank::NINE));
	t.addCard(model::Card(model::Suit::HEARTS, model::Rank::THREE));
	ASSERT_EQ(0, t.getWinner());
	ASSERT_TRUE(t.hasEnded());
TEST(TrickTest, NoTrump)
	model::Trick t(model::Denomination::NO_TRUMP);
	t.addCard(model::Card(model::Suit::HEARTS, model::Rank::KING));
	t.addCard(model::Card(model::Suit::CLUBS, model::Rank::ACE));
	t.addCard(model::Card(model::Suit::HEARTS, model::Rank::TWO));
	t.addCard(model::Card(model::Suit::HEARTS, model::Rank::ACE));
	ASSERT_EQ(3, t.getWinner())
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoCollStats::~RepoCollStats() {}
long long repo::core::RepoCollStats::getActualSizeOnDisk() const
    return getSize() + 16 * getCount() + getTotalIndexSize();
std::string repo::core::RepoCollStats::getDatabase() const
    return getDatabase(getNs());
std::string repo::core::RepoCollStats::getDatabase(const std::string& ns)
    std::st

    const char *str = ns.c_str();
    const char *p;
    if (ns.find('.') != std::string::npos && (p = strchr(str, '.')))
        database = std::string(str, p - str);
    return database;
long long repo::core::RepoCollStats::getCount() const
    return getSize("count");
std::string repo::core::RepoCollStats::getCollection() const
    return getCollection(getNs());
std::string repo::core::RepoCollStats::getCollection(const std::string& ns)
    std::string collection = ns;
    const char *p;
    if (ns.find('.') != std::string::npos && (p = strchr(ns.c_str(), '.')))
        collection = p + 1;
    return collection;
std::string repo::core::RepoCollStats::getNs() const
    std::string ns;
    if(isOk())
        ns = getField("ns").String();
    return ns;
long long repo::core::RepoCollStats::getSize(const std::string& name) const
    long long size = 0;
    if (isOk())
        size = getField(name).safeNumberLong();
    return size;
long long repo::core::RepoCollStats::getSize() const
 
/*
 * $Id$
 *
 * Copyright 2010 Object Computing, Inc.
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSet::RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","RepoIdSet",6);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::insert_id(RepoId key, RepoId value)
  DBG_ENTRY_LVL("RepoIdSet","insert_id",6);
  return OpenDDS::DCPS::bind(map_, key, value);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::remove_id(RepoId id)
  DBG_ENTRY_LVL("RepoIdSet","remove_id",6);
  int result = unbind(map_, id);
  if (result != 0) {
    VDBG((LM_DEBUG, "(%P|%t) RepoId (%d) not found in map_.\n",id));
  }
  return result;
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSet::size() const
  DBG_ENTRY_LVL("RepoIdSet","size",6);
  return map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map()
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->map_;
ACE_INLINE const OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map() const
  DBG_ENTRY_LVL("RepoIdSet","map",6);
 
template<class T>
BinaryStream &operator <<(BinaryStream &stream, std::list<T> &list)
	unsigned int size = list.size();
	stream << size;
	for(T &t : list)
	{
		stream << t;
	}
	return stream;
template<class T>
BinaryStream &operator >>(BinaryStream &stream, std::list<T> &list)
	unsigned int size = 0;
	stream >> size;
	for(unsigned int i = 0; i < size; i++)
	{
		T t;
		stream >> t;
		list.push_back(t);
	}
	return stream;
template<class T>
BinaryStream &operator >>(BinaryStream &stream, std::vector<T> &vector)
	unsigned int size = 0;
	stream >> size;
	for(unsigned int i = 0; i < size; i++)
	{
		T t;
		stream >> t;
		vector.push_back(t);
	}
	return stream;
template<class TKey, class TValue>
BinaryStream &operator >>(BinaryStream &stream, std::map<TKey, TValue> &map)
	unsigned int size = 0;
	stream >> size;
	for(unsigned int i = 0; i < size; i++)
	{
		TKey key;
		TValue value;
		stream >> key;
		stream >> value;
		map[key] = value;
	}
	return stream;
template<class TFirst, class TSecond>
B
/*
 * mirco_mempage_heap.c
 *  Created on: 2012-12-21
 *      Author: qianqians
 * mirco_mempage_heap 
 */
size_t chunk_size = 1024*64;
bool flag(mirco_mempage_heap * _heap){
	return _heap->_flag.test_and_set();
void clear(mirco_mempage_heap * _heap){
	_heap->_flag.clear();
void * _mirco_mempage_heap_alloc_big(struct mirco_mempage_heap * _heap, size_t size){
	void * ret = _malloc(_heap->chunk, size);
	if (ret == 0){	
		size_t _chunksize = ((size+sizeof(struct chunk)+sizeof(struct chunk*)+sizeof(size_t))*2+chunk_size-1)/chunk_size*chunk_size;
		size_t _old_chunksize = _heap->chunk->size;
		if (_chunksize <= _old_chunksize){
			do{
				if (_heap->chunk->count.load() == 0){
					_heap->chunk->slide = sizeof(struct chunk);
					break;
				}else{
					_heap->chunk->rec_flag.store(1);
					char flag = 1;
					if (_heap->chunk->count.load() == 0){
						if (_heap->chunk->rec_flag.compare_exchange_weak(flag, 0)){
							_heap->chunk->slide = sizeof(struct chunk);
							break;
						}
					}
	

				_heap->chunk = _chunk(_heap->_father_heap, _old_chunksize);
			}while(0);
		}else{
			if (_heap->chunk->count.load() == 0){
				_recover_chunk(_heap->_father_heap, _heap->chunk);
			}else{
				_heap->chunk->rec_flag.store(1);
				char flag = 1;
				if (_heap->chunk->count.load() == 0){
					if (_heap->chunk->rec_flag.compare_exchange_weak(flag, 2)){
						_recover_chunk(_heap->_father_heap, _heap->chunk);
					}
				}
			}
			_heap->chunk = _chunk(_heap->_father_heap, _chunksize);
		}
		ret = _malloc(_heap->chunk, size);
	}
	return ret;
void * _mirco_mempage_heap_alloc_small(struct mirco_mempage_heap * _heap, size_t size){
	void * ret = _malloc(_heap->chunk_small, size);
	if (ret == 0){	
		do{
			if (_heap->chunk_small->count.load() != 0){
				_heap->chunk_small->rec_flag.store(1);
				if (_heap->chunk_small->count.load() == 0){
					char flag = 1;
					if (!_heap->chunk_small->rec_flag.compare_exchange_weak(flag, 0)){
						_heap->chunk_small = _chunk(_heap->_father_heap, chunk_s
ModelsSingleton* ModelsSingleton::_instance = NULL;
ModelsSingleton::ModelsSingleton(void)
{	
	_modelsCount = 0;
	_models.clear();
	_modelCube.InitModel( ".\\Resources\\cube.obj" , ".\\Resources\\diamond_ore.png" );
	_modelTorus.InitModel( ".\\Resources\\torus.obj" , ".\\Resources\\stonebrick_mossy.png" );
	_modelThing.InitModel( ".\\Resources\\untitled.obj" , ".\\Resources\\redstone_block.png" );
	_modelBook.InitModel( ".\\Resources\\LivreFerme.obj" , ".\\Resources\\LivreFermeRouge.png" );
	_modelCaterpie.InitModel( ".\\Resources\\chenipan.obj" , ".\\Resources\\chenipan.png" );
	_modelPokeball.InitModel( ".\\Resources\\pokeball.obj" , ".\\Resources\\pokeball.png" );
	_modelGround.InitModel( ".\\Resources\\ground.obj" , ".\\Resources\\ground.png" );
	_modelFond.InitModel( ".\\Resources\\fond.obj" , ".\\Resources\\ground.png" );
	_modelRock.InitModel( ".\\Resources\\rock.obj" , ".\\Resources\\stonebrick_mossy.png" );
	_modelFish.InitModel( ".\\Resources\\Magicarpe.obj" , ".\\Resources\\

ModelsSingleton::~ModelsSingleton(void)
	std::list<Model*>::iterator it = _models.begin();
	while (it != _models.end())
	{
		delete (*it);
		it = _models.erase(it);
	}
	std::map<Model*, float>::iterator it2 = _modelsToRemove.begin();
	while (it2 != _modelsToRemove.end())
	{
		it2 = _modelsToRemove.erase(it2);
	}
ModelsSingleton* ModelsSingleton::Instance()
	if( _instance == NULL )
		_instance = new ModelsSingleton();
	return _instance;
void ModelsSingleton::ReleaseInstance()
	delete _instance;
	_instance = NULL;
Model* ModelsSingleton::Instanciate(ModelName modelName)
	Model* model;
	switch(modelName)
	{
	case Torus:
		model = new Model(_modelTorus);
		break;
	case Book:
		model = new Model(_modelBook);
		break;
	case Thing:
		model = new Model(_modelThing);
		break;
	case Ground :
		model = new Model(_modelGround);
		break;
	case Caterpie :
		model = new Model(_modelCaterpie);
		break;
	case Pokeball :
		model = new Model(_modelPokeball);
		break;
	case Fond :
		model = new Model(_mo

		break;
	case Rock :
		model = new Model(_modelRock);
		break;
	case Tree :
		model = new Model(_modelTree);
		break;
	case Fish :
		model = new Model(_modelFish);
		break;
	case Cube:
	default:
		model = new Model(_modelCube);
		break;
	}
	if( model == NULL )
		return NULL;
	model->_modelNum = _modelsCount;
	_models.push_back(model);
	_modelsCount++;
	return model;
Model* ModelsSingleton::Instanciate(ModelName modelName, Point3 position, Point3 rotation)
	Model* model = Instanciate(modelName);
	if( model == NULL )
		return NULL;
	model->SetLocation(position);
	model->SetRotation(rotation);
	return model;
void ModelsSingleton::Destroy(Model* model)
	_modelsToRemove[model] = 0.0f;
void ModelsSingleton::Destroy(Model* model, float timer)
	_modelsToRemove[model] = timer;
void ModelsSingleton::CleanListOfModels(UpdateArgs args)
	std::map<Model*, float>::iterator it = _modelsToRemove.begin();
	for( it; it != _modelsToRemove.end(); )
	{
		(*it).second -= args.GetDeltaTime();
		if( (*it).se
HELIUM_DEFINE_ENUM( Helium::Editor::LocatorShape );
HELIUM_DEFINE_CLASS( Helium::Editor::Locator );
using namespace Helium;
using namespace Helium::Editor;
void Locator::PopulateMetaType( Reflect::MetaStruct& comp )
	Reflect::Field* field = comp.AddField( &Locator::m_Shape, TXT( "m_Shape" ) );
	field->SetProperty( TXT( "HelpText" ), TXT( "Determines the shape of the locator node." ) );
Locator::Locator()
	: m_Shape (LocatorShape::Cross)
Locator::~Locator()
LocatorShape Locator::GetShape() const
	return m_Shape;
void Locator::SetShape( LocatorShape shape )
	m_Shape = shape;
	Dirty();
void Locator::Evaluate(GraphDirection direction)
	Base::Evaluate(direction);
	switch (direction)
	{
	case GraphDirections::Downstream:
		{
			m_ObjectBounds.Reset();
			const Primitive* prim = NULL;
			if (prim)
			{
				m_ObjectBounds.Merge(prim->GetBounds());
			}
			break;
		}
	case GraphDirections::Upstream:
		break;
	}
void Locator::Render( RenderVisitor* render )
	{
		RenderEntry* entry = render->Allo
int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void *lpReserved) {
    return 1;
float *GetFloatList(void *arr, INVOKE_CALL _Invoke) {
    INTEGER type      = 0;
    NUMBER  nr        = 0;
    void    *newpData = 0;
    float   *ret      = 0;
    int count = _Invoke(INVOKE_GET_ARRAY_COUNT, arr);
    ret        = new float[count + 1];
    ret[count] = 0;
    for (int i = 0; i < count; i++) {
        _Invoke(INVOKE_ARRAY_VARIABLE, arr, i, &newpData);
        if (newpData) {
            char    *szData;
            INTEGER type;
            NUMBER  nData;
            _Invoke(INVOKE_GET_VARIABLE, newpData, &type, &szData, &nData);
            if (type == VARIABLE_STRING) {
                ret[i] = 0;
            } else
                ret[i] = nData;
        }
    }
    return ret;
char **GetCharList(void *arr, INVOKE_CALL _Invoke) {
    INTEGER type      = 0;
    NUMBER  nr        = 0;
    void    *newpData = 0;
    char    **ret     = 0;
    int count = _Invoke(INVOKE_GE

    ret        = new char * [count + 1];
    ret[count] = 0;
    for (int i = 0; i < count; i++) {
        _Invoke(INVOKE_ARRAY_VARIABLE, arr, i, &newpData);
        if (newpData) {
            char    *szData;
            INTEGER type;
            NUMBER  nData;
            _Invoke(INVOKE_GET_VARIABLE, newpData, &type, &szData, &nData);
            if (type == VARIABLE_STRING) {
                ret[i] = szData;
            } else
                ret[i] = 0;
        }
    }
    return ret;
int *GetIntList(void *arr, INVOKE_CALL _Invoke) {
    INTEGER type      = 0;
    NUMBER  nr        = 0;
    void    *newpData = 0;
    int     *ret      = 0;
    int count = _Invoke(INVOKE_GET_ARRAY_COUNT, arr);
    ret        = new int[count + 1];
    ret[count] = 0;
    for (int i = 0; i < count; i++) {
        _Invoke(INVOKE_ARRAY_VARIABLE, arr, i, &newpData);
        if (newpData) {
            char    *szData;
            INTEGER type;
            NUMBER  nData;
            _Invoke(INVOKE_GET_V

            if (type == VARIABLE_STRING) {
                ret[i] = 0;
            } else
                ret[i] = (int)nData;
        }
    }
    return ret;
double *GetDoubleList(void *arr, INVOKE_CALL _Invoke) {
    INTEGER type      = 0;
    NUMBER  nr        = 0;
    void    *newpData = 0;
    double  *ret      = 0;
    int count = _Invoke(INVOKE_GET_ARRAY_COUNT, arr);
    ret        = new double[count + 1];
    ret[count] = 0;
    for (int i = 0; i < count; i++) {
        _Invoke(INVOKE_ARRAY_VARIABLE, arr, i, &newpData);
        if (newpData) {
            char    *szData;
            INTEGER type;
            NUMBER  nData;
            _Invoke(INVOKE_GET_VARIABLE, newpData, &type, &szData, &nData);
            if (type == VARIABLE_STRING) {
                ret[i] = 0;
            } else
                ret[i] = nData;
        }
    }
    return ret;
bool *GetBoolList(void *arr, INVOKE_CALL _Invoke) {
    INTEGER type      = 0;
    NUMBER  nr        = 0;
    void    *newpData =
using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace Common;
namespace Fast_kNCN_Test
{	
	SampleSet* testSampleSet;
	SampleSetFactory* ssf;
	TEST_CLASS(SampleSetTest)	{
	private:
		TEST_CLASS_INITIALIZE(SampleSetTestSetUp) {	
			testSampleSet = new SampleSet();
			ssf = new SampleSetFactory();
			*testSampleSet = ssf->createSampleSet("../../Datasets/ftrain01.txt");
			Assert::IsNotNull(&testSampleSet);
			Assert::AreEqual(8, testSampleSet->nrClasses);
			Assert::AreEqual(30, testSampleSet->nrDims);
			Assert::AreEqual(1400, testSampleSet->nrSamples);
		}
		TEST_CLASS_CLEANUP(SampleSetTestTearDown) {
			delete testSampleSet;
			delete ssf;
		}
	public:
		TEST_METHOD(ConstructorSampleSet) {
			SampleSet testSampleSet2(8, 30, 1400);
			Assert::IsNotNull(&testSampleSet2);
			testSampleSet2 = ssf->createSampleSet("../../Datasets/ftrain01.txt");
			Assert::AreEqual(*testSampleSet, testSampleSet2);
		}
		TEST_METHOD(CopyConstructorSampleSet) {
			SampleSet copySample

			Assert::AreEqual(*testSampleSet, copySampleSet);
			Assert::AreNotSame(testSampleSet, &copySampleSet);
			SampleSet copySampleSet2 = *testSampleSet;
			Assert::AreEqual(*testSampleSet, copySampleSet2);
		}
		TEST_METHOD(AssignmentOperatorSampleSet) {
			SampleSet testSampleSet2;
			Assert::IsNotNull(&testSampleSet2);
			testSampleSet2 = *testSampleSet;
			Assert::AreEqual(*testSampleSet, testSampleSet2);
			SampleSet testSampleSet3(8, 30, 1400);
			Assert::IsNotNull(&testSampleSet3);
			testSampleSet3 = *testSampleSet;
			Assert::AreEqual(*testSampleSet, testSampleSet3);
		}
		TEST_METHOD(ExplicitEqualityOperatorSampleSet) {
			SampleSet testSampleSet7 = *testSampleSet;
			Assert::IsNotNull(&testSampleSet7);
			Assert::IsTrue(testSampleSet7 == *testSampleSet);
		}
		TEST_METHOD(UnequalSampleSet) {
			SampleSet otherSampleSet;
			Assert::IsNotNull(&otherSampleSet);
			otherSampleSet = ssf->createSampleSet("../Fast_k-NCN/Datasets/ftrain02.txt");
			Assert::IsNotNull(&otherSampleSet);
DbService::DbService()
    scientistRepo = ScientistRepository();
    computerRepo = ComputerRepository();
    connectRepo = ConnectRepository();
void DbService::addS(Scientist s)
    scientistRepo.add(s);
void DbService::addC(Computer c)
    computerRepo.add(c);
void DbService::addID(int scientist_id, int computer_id)
    connectRepo.add(scientist_id, computer_id);
list <Scientist> DbService::get_allScientists()
    return scientistRepo.get_allscientists();
list<Computer> DbService::get_allComputers()
    return computerRepo.get_allcomputers();
list<Connect> DbService::get_allconnections()
    return connectRepo.get_allconnections();
list <Scientist> DbService::sort_scientists(int col, int mod)
    return scientistRepo.sort_function(col, mod);
list<Computer> DbService::sort_computers(int col, int mod)
    return computerRepo.sort_function(col,mod);
list <Scientist> DbService::search_scientists(string s)
    return scientistRepo.search_function(s);
list<Computer> DbService::search_comp
ModelPool::ModelPool()
  pvpModels = new vector<ModelAbstraction*>();
ModelAbstraction * ModelPool::GetModel(string name)
  if(pvpModels == NULL)
    return NULL;
  for(auto i : *pvpModels)
  {
    if(i->Name == name)
    {
      return i;
    }
  }
  return NULL;
bool ModelPool::AddModel(ModelAbstraction * model)
  if(model == NULL)
    return false;
  ModelAbstraction * existing = this->GetModel(model->Name);
  if(existing != NULL)
    return false;
  this->pvpModels->push_back(model);
  return true;
bool ModelPool::RemoveModel(ModelAbstraction * model)
  if(model == NULL)
    return false;
  return this->RemoveModel(model->Name);
bool ModelPool::RemoveModel(string name)
  ModelAbstraction * existing = this->GetModel(name);
  if(existing != NULL)
  {
    delete existing;
    existing = NULL;
    return true;
  }
  return false;
void ModelPool::SetModelPool(vector<ModelAbstraction*> * source)
  this->pvpModels = source;
vector<ModelAbstraction*> * ModelPool::GetModelPool()
  return th
/*
 * $Id$
 *
 * Copyright 2009 Object Computing, Inc.
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSet::RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","RepoIdSet",6);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::insert_id(RepoId key, RepoId value)
  DBG_ENTRY_LVL("RepoIdSet","insert_id",6);
  return bind(map_, key, value);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::remove_id(RepoId id)
  DBG_ENTRY_LVL("RepoIdSet","remove_id",6);
  int result = unbind(map_, id);
  if (result != 0) {
    VDBG((LM_DEBUG, "(%P|%t) RepoId (%d) not found in map_.\n",id));
  }
  return result;
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSet::size() const
  DBG_ENTRY_LVL("RepoIdSet","size",6);
  return map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map()
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->map_;
ACE_INLINE const OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map() const
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->m
/**
 *  @file    cceByteStream.cpp
 *  @brief   This file is a part of cocos2dx-extra
 *
 *  @author  Master.G, mg@whatstool.com
 *
 *  @internal
 *  Created:  2014/08/12
 *  Company:  whatstool
 *  (C) Copyright 2014 whatstool All rights reserved.
 *
 * The copyright to the contents herein is the property of whatstool
 * The contents may be used and/or copied only with the written permission of
 * whatstool or in accordance with the terms and conditions stipulated in
 * the agreement/contract under which the contents have been supplied.
 * =====================================================================================
 */
CCE_NS_BEGIN
void ByteStream_Open(bytestream_t *stream, void *buffer, size_t length)
    stream->stream = (uint8_t *)buffer;
    stream->length = length;
    stream->pos = 0;
    stream->mode = BS_DEFAULT;
void ByteStream_OpenIncoming(bytestream_t *stream, void *buffer, size_t length)
    ByteStream_Open(stream, buffer, length);
    stream->mode = BS_INCOMING;


    ByteStream_Open(stream, buffer, length);
    stream->mode = BS_OUTGOING;
/* ************************************************************
 * read / write
 * ************************************************************/
void ByteStream_Skip(bytestream_t *stream, size_t size)
    if (stream->pos + size > stream->length)
        stream->pos = stream->length;
    else
        stream->pos += size;
void ByteStream_SetPosition(bytestream_t *stream, size_t pos)
    if (pos > stream->length)
        return;
    else
        stream->pos = pos;
size_t ByteStream_ReadRaw(bytestream_t *stream, void *dst, size_t size)
    if (stream->pos + size > stream->length)
        return 0;
    
    memcpy(dst, &stream->stream[stream->pos], size);
    stream->pos += size;
    
    return size;
size_t ByteStream_WriteRaw(bytestream_t *stream, const void *src, size_t size)
    if (stream->pos + size > stream->length)
        return 0;
    
    memcpy(&stream->stream[stream->pos], src, size);
    stream->pos 

    
    return size;
unsigned char ByteStream_ReadByte(bytestream_t *stream, int *result)
    unsigned char ret = 0;
    if (stream->pos + 1 > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(unsigned char *)&stream->stream[stream->pos];
    stream->pos++;
    
    return ret;
int ByteStream_WriteByte(bytestream_t *stream, const unsigned char data)
    if (stream->pos + 1 > stream->length)
    {
        return 0;
    }
    
    *(unsigned char *)&stream->stream[stream->pos] = data;
    
    return 1;
char ByteStream_ReadChar(bytestream_t *stream, int *result)
    char ret = 0;
    if (stream->pos + 1 > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(char *)&stream->stream[stream->pos];
    stream->pos++;
    
    return ret;
int ByteStream_WriteChar(bytestream_t *stream, const char data)
    if (stream->pos + 1 > stream->length)


        return 0;
    }
    
    *(char *)&stream->stream[stream->pos] = data;
    
    return 1;
int16_t ByteStream_ReadInt16(bytestream_t *stream, int *result)
    int16_t ret = 0;
    int sizetoread = sizeof(int16_t);
    if (stream->pos + sizetoread > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(int16_t *)&stream->stream[stream->pos];
    stream->pos += sizetoread;
    
    if (stream->mode == BS_INCOMING)
        ret = BWSwapInt16BigToHost(ret);
    
    return ret;
int ByteStream_WriteInt16(bytestream_t *stream, const int16_t data)
    int16_t actualData = data;
    int sizetowrite = sizeof(int16_t);
    if (stream->pos + sizetowrite > stream->length)
    {
        return 0;
    }
    
    if (stream->mode == BS_OUTGOING)
        actualData = BWSwapInt16HostToBig(data);
    
    *(int16_t *)&stream->stream[stream->pos] = actualData;
    stream->pos += sizetowrite;
    
    return sizetowrite;
uint1

    uint16_t ret = 0;
    int sizetoread = sizeof(uint16_t);
    if (stream->pos + sizetoread > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(uint16_t *)&stream->stream[stream->pos];
    stream->pos += sizetoread;
    
    if (stream->mode == BS_INCOMING)
        ret = BWSwapInt16BigToHost(ret);
    
    return ret;
int ByteStream_WriteUInt16(bytestream_t *stream, const uint16_t data)
    uint16_t actualData = data;
    int sizetowrite = sizeof(uint16_t);
    if (stream->pos + sizetowrite > stream->length)
    {
        return 0;
    }
    
    if (stream->mode == BS_OUTGOING)
        actualData = BWSwapInt16HostToBig(data);
    
    *(uint16_t *)&stream->stream[stream->pos] = actualData;
    stream->pos += sizetowrite;
    
    return sizetowrite;
int32_t ByteStream_ReadInt32(bytestream_t *stream, int *result)
    int32_t ret = 0;
    int sizetoread = sizeof(int32_t);
    if (stream->pos + sizetoread > s

    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(int32_t *)&stream->stream[stream->pos];
    stream->pos += sizetoread;
    
    if (stream->mode == BS_INCOMING)
        ret = BWSwapInt32BigToHost(ret);
    
    return ret;
int ByteStream_WriteInt32(bytestream_t *stream, const int32_t data)
    int32_t actualData = data;
    int sizetowrite = sizeof(int32_t);
    if (stream->pos + sizetowrite > stream->length)
    {
        return 0;
    }
    
    if (stream->mode == BS_OUTGOING)
        actualData = BWSwapInt32HostToBig(data);
    
    *(int32_t *)&stream->stream[stream->pos] = actualData;
    stream->pos += sizetowrite;
    
    return sizetowrite;
uint32_t ByteStream_ReadUInt32(bytestream_t *stream, int *result)
    uint32_t ret = 0;
    int sizetoread = sizeof(uint32_t);
    if (stream->pos + sizetoread > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    


    stream->pos += sizetoread;
    
    if (stream->mode == BS_INCOMING)
        ret = BWSwapInt32BigToHost(ret);
    
    return ret;
int ByteStream_WriteUInt32(bytestream_t *stream, const uint32_t data)
    uint32_t actualData = data;
    int sizetowrite = sizeof(uint32_t);
    if (stream->pos + sizetowrite > stream->length)
    {
        return 0;
    }
    
    if (stream->mode == BS_OUTGOING)
        actualData = BWSwapInt32HostToBig(data);
    
    *(uint32_t *)&stream->stream[stream->pos] = actualData;
    stream->pos += sizetowrite;
    
    return sizetowrite;
int64_t ByteStream_ReadInt64(bytestream_t *stream, int *result)
    int64_t ret = 0;
    int sizetoread = sizeof(int64_t);
    if (stream->pos + sizetoread > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(int64_t *)&stream->stream[stream->pos];
    stream->pos += sizetoread;
    
    if (stream->mode == BS_INCOMING)
        ret = BWSwapInt64

    
    return ret;
int ByteStream_WriteInt64(bytestream_t *stream, const int64_t data)
    int64_t actualData = data;
    int sizetowrite = sizeof(int64_t);
    if (stream->pos + sizetowrite > stream->length)
    {
        return 0;
    }
    
    if (stream->mode == BS_OUTGOING)
        actualData = BWSwapInt64HostToBig(data);
    
    *(int64_t *)&stream->stream[stream->pos] = actualData;
    stream->pos += sizetowrite;
    
    return sizetowrite;
uint64_t ByteStream_ReadUInt64(bytestream_t *stream, int *result)
    uint64_t ret = 0;
    int sizetoread = sizeof(uint64_t);
    if (stream->pos + sizetoread > stream->length)
    {
        if (result != NULL)
            *result = 0;
        
        return ret;
    }
    
    ret = *(uint64_t *)&stream->stream[stream->pos];
    stream->pos += sizetoread;
    
    if (stream->mode == BS_INCOMING)
        ret = BWSwapInt64BigToHost(ret);
    
    return ret;
int ByteStream_WriteUInt64(bytestream_t *stream, const uint64_t data)
    uin
/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
namespace qpid {
namespace amqp_0_10 {
template <class F>
struct ApplyVisitor<ControlVisitor, F>:
    public ApplyVisitorBase<ControlVisitor, F>
    virtual void visit(connection::Start& x) { this->invoke(x); }
    virtual void visit(

    virtual void visit(connection::Secure& x) { this->invoke(x); }
    virtual void visit(connection::SecureOk& x) { this->invoke(x); }
    virtual void visit(connection::Tune& x) { this->invoke(x); }
    virtual void visit(connection::TuneOk& x) { this->invoke(x); }
    virtual void visit(connection::Open& x) { this->invoke(x); }
    virtual void visit(connection::OpenOk& x) { this->invoke(x); }
    virtual void visit(connection::Redirect& x) { this->invoke(x); }
    virtual void visit(connection::Heartbeat& x) { this->invoke(x); }
    virtual void visit(connection::Close& x) { this->invoke(x); }
    virtual void visit(connection::CloseOk& x) { this->invoke(x); }
    virtual void visit(session::Attach& x) { this->invoke(x); }
    virtual void visit(session::Attached& x) { this->invoke(x); }
    virtual void visit(session::Detach& x) { this->invoke(x); }
    virtual void visit(session::Detached& x) { this->invoke(x); }
    virtual void visit(session::RequestTimeout& x) { this->invoke(

    virtual void visit(session::Timeout& x) { this->invoke(x); }
    virtual void visit(session::CommandPoint& x) { this->invoke(x); }
    virtual void visit(session::Expected& x) { this->invoke(x); }
    virtual void visit(session::Confirmed& x) { this->invoke(x); }
    virtual void visit(session::Completed& x) { this->invoke(x); }
    virtual void visit(session::KnownCompleted& x) { this->invoke(x); }
    virtual void visit(session::Flush& x) { this->invoke(x); }
    virtual void visit(session::Gap& x) { this->invoke(x); }
    virtual void visit(cluster::UpdateRequest& x) { this->invoke(x); }
    virtual void visit(cluster::UpdateOffer& x) { this->invoke(x); }
    virtual void visit(cluster::RetractOffer& x) { this->invoke(x); }
    virtual void visit(cluster::Ready& x) { this->invoke(x); }
    virtual void visit(cluster::ConfigChange& x) { this->invoke(x); }
    virtual void visit(cluster::MessageExpired& x) { this->invoke(x); }
    virtual void visit(cluster::ErrorCheck& x) { this

    virtual void visit(cluster::Shutdown& x) { this->invoke(x); }
    virtual void visit(cluster-connection::Announce& x) { this->invoke(x); }
    virtual void visit(cluster-connection::DeliverClose& x) { this->invoke(x); }
    virtual void visit(cluster-connection::DeliverDoOutput& x) { this->invoke(x); }
    virtual void visit(cluster-connection::Abort& x) { this->invoke(x); }
    virtual void visit(cluster-connection::ConsumerState& x) { this->invoke(x); }
    virtual void visit(cluster-connection::DeliveryRecord& x) { this->invoke(x); }
    virtual void visit(cluster-connection::TxStart& x) { this->invoke(x); }
    virtual void visit(cluster-connection::TxAccept& x) { this->invoke(x); }
    virtual void visit(cluster-connection::TxDequeue& x) { this->invoke(x); }
    virtual void visit(cluster-connection::TxEnqueue& x) { this->invoke(x); }
    virtual void visit(cluster-connection::TxPublish& x) { this->invoke(x); }
    virtual void visit(cluster-connection::TxEnd& x) { this->invo

    virtual void visit(cluster-connection::AccumulatedAck& x) { this->invoke(x); }
    virtual void visit(cluster-connection::SessionState& x) { this->invoke(x); }
    virtual void visit(cluster-connection::ShadowReady& x) { this->invoke(x); }
    virtual void visit(cluster-connection::Membership& x) { this->invoke(x); }
    virtual void visit(cluster-connection::RetractOffer& x) { this->invoke(x); }
    virtual void visit(cluster-connection::QueuePosition& x) { this->invoke(x); }
    virtual void visit(cluster-connection::Exchange& x) { this->invoke(x); }
    virtual void visit(cluster-connection::Queue& x) { this->invoke(x); }
    virtual void visit(cluster-connection::ExpiryId& x) { this->invoke(x); }
    virtual void visit(cluster-connection::AddQueueListener& x) { this->invoke(x); }
};
template <class F>
struct ApplyVisitor<ConstControlVisitor, F>:
    public ApplyVisitorBase<ConstControlVisitor, F>
    virtual void visit(const connection::Start& x) { this->invoke(x); }
    virtu

    virtual void visit(const connection::Secure& x) { this->invoke(x); }
    virtual void visit(const connection::SecureOk& x) { this->invoke(x); }
    virtual void visit(const connection::Tune& x) { this->invoke(x); }
    virtual void visit(const connection::TuneOk& x) { this->invoke(x); }
    virtual void visit(const connection::Open& x) { this->invoke(x); }
    virtual void visit(const connection::OpenOk& x) { this->invoke(x); }
    virtual void visit(const connection::Redirect& x) { this->invoke(x); }
    virtual void visit(const connection::Heartbeat& x) { this->invoke(x); }
    virtual void visit(const connection::Close& x) { this->invoke(x); }
    virtual void visit(const connection::CloseOk& x) { this->invoke(x); }
    virtual void visit(const session::Attach& x) { this->invoke(x); }
    virtual void visit(const session::Attached& x) { this->invoke(x); }
    virtual void visit(const session::Detach& x) { this->invoke(x); }
    virtual void visit(const session::Detached& x) { t

    virtual void visit(const session::RequestTimeout& x) { this->invoke(x); }
    virtual void visit(const session::Timeout& x) { this->invoke(x); }
    virtual void visit(const session::CommandPoint& x) { this->invoke(x); }
    virtual void visit(const session::Expected& x) { this->invoke(x); }
    virtual void visit(const session::Confirmed& x) { this->invoke(x); }
    virtual void visit(const session::Completed& x) { this->invoke(x); }
    virtual void visit(const session::KnownCompleted& x) { this->invoke(x); }
    virtual void visit(const session::Flush& x) { this->invoke(x); }
    virtual void visit(const session::Gap& x) { this->invoke(x); }
    virtual void visit(const cluster::UpdateRequest& x) { this->invoke(x); }
    virtual void visit(const cluster::UpdateOffer& x) { this->invoke(x); }
    virtual void visit(const cluster::RetractOffer& x) { this->invoke(x); }
    virtual void visit(const cluster::Ready& x) { this->invoke(x); }
    virtual void visit(const cluster::ConfigC

    virtual void visit(const cluster::MessageExpired& x) { this->invoke(x); }
    virtual void visit(const cluster::ErrorCheck& x) { this->invoke(x); }
    virtual void visit(const cluster::Shutdown& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::Announce& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::DeliverClose& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::DeliverDoOutput& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::Abort& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::ConsumerState& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::DeliveryRecord& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::TxStart& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::TxAccept& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::TxDequeue& x) { this->invoke(x); }
    virtu

    virtual void visit(const cluster-connection::TxPublish& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::TxEnd& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::AccumulatedAck& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::SessionState& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::ShadowReady& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::Membership& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::RetractOffer& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::QueuePosition& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::Exchange& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::Queue& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::ExpiryId& x) { this->invoke(x); }
    virtual void visit(const cluster-connection::AddQueueListener& 
struct InterfaceActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct InterfaceFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct InterfaceActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cp

		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R, typename T1>
struct InterfaceFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct InterfaceActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct InterfaceFuncInvoker2
	typedef R (*

	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3>
struct InterfaceActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct InterfaceFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void

	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct InterfaceActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct InterfaceFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData

		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	

		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct InterfaceActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct InterfaceActionInvoker7
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline void Invoke (Il2CppM

	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct InterfaceFuncInvoker8
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, T8, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_interface_invoke_data (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct InterfaceFuncInvoker9
	typedef 
template <typename T>
class Chunker : Noncopyable {
public:
    typedef T EntryType;
    Chunker(const std::string& chnkDir, size_t countInChnk,
        std::function<void(const char*)> chnkFilled = std::function<void(const char*)>()) :
            chunkDir(chnkDir),
            countInChunk(countInChnk),
            chunkDataCounter(0),
            chunkCounter(0),
            chunkFilled(chnkFilled) {
        std::string chunkFileName = getChunkFileName();
        chunkFileNames.push_back(chunkFileName);
        fileArchive.reset(new FileOutArchive(chunkFileName));
    }
    void add(const EntryType& entry) {
        if (chunkDataCounter == countInChunk) {
            ++chunkCounter;
            std::string prevChunkFileName = chunkFileNames.back();
            std::string chunkFileName = getChunkFileName();
            chunkFileNames.push_back(chunkFileName);
            fileArchive.reset(new FileOutArchive(chunkFileName));
            chunkDataCounter = 0;
            if (chunkFill
namespace Client
    EmbeddedTilemap::EmbeddedTilemap()
    {
        for(std::size_t i = 0; i < layerCount; ++i)
        {
            m_layers[i] = std::map<int, std::map<int, std::unique_ptr<EmbeddedChunk> > >();
        }
    }
    EmbeddedTilemap::~EmbeddedTilemap()
    {
    }
    void EmbeddedTilemap::clear()
    {
        for(auto &layer : m_layers)
        {
            for(auto &chunks : layer)
            {
                for(auto &chunk : chunks.second)
                {
                    chunk.second->reset();
                }
            }
        }
    }
    void EmbeddedTilemap::setTile(int x, int y, int z, uint8_t tile)
    {
        int chunkX = x / EmbeddedChunk::width, chunkY = y / EmbeddedChunk::width;
        int tileX = x % EmbeddedChunk::width, tileY = y % EmbeddedChunk::width;
        if(!chunkExists(chunkX, chunkY, z))
        {
            createChunk(chunkX, chunkY, z);
        }
        m_layers[z][chunkX][chunkY]->setTile(tileX, tileY, tile);
    }
   

    {
        int chunkX = x / EmbeddedChunk::width, chunkY = y / EmbeddedChunk::width;
        if(chunkExists(chunkX, chunkY, z))
        {
            int tileX = x % EmbeddedChunk::width, tileY = y % EmbeddedChunk::width;
            return m_layers[z][chunkX][chunkY]->getTile(tileX, tileY);
        }
        return 0;
    }
    void EmbeddedTilemap::setTileUserdata(int x, int y, int z, uint8_t tile)
    {
        int chunkX = x / EmbeddedChunk::width, chunkY = y / EmbeddedChunk::width;
        int tileX = x % EmbeddedChunk::width, tileY = y % EmbeddedChunk::width;
        if(!chunkExists(chunkX, chunkY, z))
        {
            createChunk(chunkX, chunkY, z);
        }
        m_layers[z][chunkX][chunkY]->setTileUserdata(tileX, tileY, tile);
    }
    uint8_t EmbeddedTilemap::getTileUserdata(int x, int y, int z)
    {
        int chunkX = x / EmbeddedChunk::width, chunkY = y / EmbeddedChunk::width;
        if(chunkExists(chunkX, chunkY, z))
        {
            int tileX = x % E

            return m_layers[z][chunkX][chunkY]->getTileUserdata(tileX, tileY);
        }
        return 0;
    }
    void EmbeddedTilemap::render(Window *window, const glm::ivec2 &offset)
    {
        for(std::size_t z = 0; z < layerCount - 1; ++z)
        {
            for(auto &chunks : m_layers[z])
            {
                for(auto &chunk : chunks.second)
                {
                    chunk.second->render(window, chunks.first * EmbeddedChunk::width * EmbeddedChunk::tileWidth + offset.x,
                                         chunk.first * EmbeddedChunk::width * EmbeddedChunk::tileWidth + offset.y);
                }
            }
        }
    }
    EmbeddedTilemap::CollisionTypes EmbeddedTilemap::getCollisionOf(int x, int y)
    {
        return static_cast<CollisionTypes>((unsigned int) getTile(x, y, layerCount - 1));
    }
    void EmbeddedTilemap::setCollisionOf(int x, int y, CollisionTypes collisionType)
    {
        setTile(x, y, layerCount - 1, static_cast<u

    }
    void EmbeddedTilemap::setTextureForLayer(std::shared_ptr<Texture> texture, int z)
    {
        if(z >= 0 && z < layerCount - 1)
        {
            m_textures[z] = texture;
            for(auto &chunks : m_layers[z])
            {
                for(auto &chunk : chunks.second)
                {
                    chunk.second->setTexture(texture);
                }
            }
        }
    }
    bool EmbeddedTilemap::chunkExists(int chunkX, int chunkY, int z)
    {
        if(z >= 0 && z < m_layers.size())
        {
            if(m_layers[z].count(chunkX) > 0)
            {
                if(m_layers[z][chunkX].count(chunkY) > 0)
                {
                    return true;
                }
            }
        }
        return false;
    }
    void EmbeddedTilemap::createChunk(int chunkX, int chunkY, int z)
    {
        if(m_layers[z].count(chunkX) == 0)
        {
            m_layers[z][chunkX] = std::map<int, std::unique_ptr<EmbeddedChunk> >();
       
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    
LibCSymTable& LibCSymTable::instance(){
    static LibCSymTable tbl;
    return tbl;
LibCSymTable::LibCSymTable()
    void* handle=getHandle();
    LOAD_SYM(gethostbyname);
    LOAD_SYM(calloc);
    LOAD_SYM(realloc);
    LOAD_SYM(free);


    LOAD_SYM(srandom);
    LOAD_SYM(printf);
    LOAD_SYM(socket);
    LOAD_SYM(close);
    LOAD_SYM(getsockopt);
    LOAD_SYM(setsockopt);
    LOAD_SYM(fcntl);
    LOAD_SYM(connect);
    LOAD_SYM(send);
    LOAD_SYM(recv);
    LOAD_SYM(select);
    LOAD_SYM(poll);
    LOAD_SYM(gettimeofday);
    LOAD_SYM(pthread_create);
    LOAD_SYM(pthread_detach);
    LOAD_SYM(pthread_cond_broadcast);
    LOAD_SYM(pthread_cond_destroy);
    LOAD_SYM(pthread_cond_init);
    LOAD_SYM(pthread_cond_signal);
    LOAD_SYM(pthread_cond_timedwait);
    LOAD_SYM(pthread_cond_wait);
    LOAD_SYM(pthread_join);
    LOAD_SYM(pthread_mutex_destroy);
    LOAD_SYM(pthread_mutex_init);
    LOAD_SYM(pthread_mutex_lock);
    LOAD_SYM(pthread_mutex_trylock);
    LOAD_SYM(pthread_mutex_unlock);
void* LibCSymTable::getHandle(){
    static void* handle=0;
    if(!handle){
        handle=dlopen("cygwin1.dll",RTLD_LAZY);
        assert("Unable to dlopen global sym table"&&handle);
        handle=RTLD_NEXT;
    }
    retu
ACE_INLINE
TAO::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",5);
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find",5);
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      return 0;
    }
  return value._retn();
ACE_INLINE size_t
TAO::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",5);
  return this->map_.current_size();
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",5);
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      value = new RepoIdSet();
      if (this->map_.bind(key, value) != 0)
        {
           ACE_ERROR((LM_ERROR,
                      "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                      "the RepoIdSetMap.\n"));
           return 0;
        }
    }
  return value._retn();
ACE_INLINE TAO::DCPS::Repo
/*
    Copyright (c) 2007-2009 FastMQ Inc.
    This file is part of 0MQ.
    0MQ is free software; you can redistribute it and/or modify it under
    the terms of the Lesser GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
    0MQ is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    Lesser GNU General Public License for more details.
    You should have received a copy of the Lesser GNU General Public License
*/
zmq::locator_t::locator_t (const char *hostname_)
    if (hostname_) {
        if (!strchr (hostname_, ':')) {
            char buf [256];
            zmq_snprintf (buf, 256, "%s:%d", hostname_,
                (int) default_locator_port);
            hostname_ = buf;
        }
        global_locator = new tcp_socket_t (hostname_, true);
     

    }
    else
        global_locator = NULL;
zmq::locator_t::~locator_t ()
    if (global_locator)
        delete global_locator;
void zmq::locator_t::register_endpoint (const char *name_, attr_list_t &attrs_)
    assert (global_locator);
    assert (strlen (name_) <= 255);
    unsigned char cmd = create_id;
    global_locator->write (&cmd, 1);
    unsigned char size = (unsigned char) strlen (name_);
    global_locator->write (&size, 1);
    global_locator->write (name_, size);
    for (attr_list_t::iterator it = attrs_.begin ();
            it != attrs_.end (); it ++) {
        const std::string &key = (*it).first;
        const std::string &value = (*it).second;
        assert (key.size () < 256);
        size = key.size ();
        global_locator->write (&size, 1);
        global_locator->write (key.c_str (), size);
        assert (value.size () < 256);
        size = value.size ();
        global_locator->write (&size, 1);
        global_locator->write (value.c_str (), size);
   
/*
 * Copyright (c) 2012, The Linux Foundation. All rights reserved.
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all copies.
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
extern "C" {
    SW_API_DEF(SW_API_PT_DUPLEX_GET, athena_port_duplex_get), \
    SW_API_DEF(SW_API_PT_DUPLEX_SET, athena_port_duplex_set), \
    SW_API_DEF(SW_API_PT_SPEED_GET, athena_port_speed_get), 

    SW_API_DEF(SW_API_PT_SPEED_SET, athena_port_speed_set), \
    SW_API_DEF(SW_API_PT_AN_GET, athena_port_autoneg_status_get), \
    SW_API_DEF(SW_API_PT_AN_ENABLE, athena_port_autoneg_enable), \
    SW_API_DEF(SW_API_PT_AN_RESTART, athena_port_autoneg_restart), \
    SW_API_DEF(SW_API_PT_AN_ADV_GET, athena_port_autoneg_adv_get), \
    SW_API_DEF(SW_API_PT_AN_ADV_SET, athena_port_autoneg_adv_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_SET, athena_port_igmps_status_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_GET, athena_port_igmps_status_get), \
    SW_API_DEF(SW_API_PT_POWERSAVE_SET, athena_port_powersave_set), \
    SW_API_DEF(SW_API_PT_POWERSAVE_GET, athena_port_powersave_get), \
    SW_API_DEF(SW_API_PT_HIBERNATE_SET, athena_port_hibernate_set), \
    SW_API_DEF(SW_API_PT_HIBERNATE_GET, athena_port_hibernate_get),
    SW_API_DESC(SW_API_PT_DUPLEX_GET)  \
    SW_API_DESC(SW_API_PT_DUPLEX_SET)  \
    SW_API_DESC(SW_API_PT_SPEED_GET)  \
    SW_API_DESC(SW_API_PT_SPEED_SET)  \
    SW_

    SW_API_DESC(SW_API_PT_AN_ENABLE)  \
    SW_API_DESC(SW_API_PT_AN_RESTART) \
    SW_API_DESC(SW_API_PT_AN_ADV_GET) \
    SW_API_DESC(SW_API_PT_AN_ADV_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_GET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_SET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_GET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_SET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_GET)
    SW_API_DEF(SW_API_VLAN_ADD, athena_vlan_create), \
    SW_API_DEF(SW_API_VLAN_DEL, athena_vlan_delete), \
    SW_API_DEF(SW_API_VLAN_MEM_UPDATE, athena_vlan_member_update), \
    SW_API_DEF(SW_API_VLAN_FIND, athena_vlan_find), \
    SW_API_DEF(SW_API_VLAN_NEXT, athena_vlan_next), \
    SW_API_DEF(SW_API_VLAN_APPEND, athena_vlan_entry_append),
    SW_API_DESC(SW_API_VLAN_ADD)  \
    SW_API_DESC(SW_API_VLAN_DEL)  \
    SW_API_DESC(SW_API_VLAN_MEM_UPDATE) \
    SW_API_DESC(SW_API_VLAN_FIND) \
    SW_API_DESC(SW_API_VLAN_NEXT) \
    SW_API_DESC(SW_API_VLAN_APPEND)
    SW_API

    SW_API_DEF(SW_API_PT_ING_MODE_SET, athena_port_1qmode_set), \
    SW_API_DEF(SW_API_PT_EG_MODE_GET, athena_port_egvlanmode_get), \
    SW_API_DEF(SW_API_PT_EG_MODE_SET, athena_port_egvlanmode_set), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_ADD, athena_portvlan_member_add), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_DEL, athena_portvlan_member_del), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_UPDATE, athena_portvlan_member_update), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_GET, athena_portvlan_member_get), \
    SW_API_DESC(SW_API_PT_ING_MODE_GET)  \
    SW_API_DESC(SW_API_PT_ING_MODE_SET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_GET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_SET)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_ADD) \
    SW_API_DESC(SW_API_PT_VLAN_MEM_DEL) \
    SW_API_DESC(SW_API_PT_VLAN_MEM_UPDATE)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_GET)
    SW_API_DEF(SW_API_FDB_ADD, athena_fdb_add), \
    SW_API_DEF(SW_API_FDB_DELALL, athena_fdb_del_all), \
    SW_API_DEF(SW_API_FDB_DELPORT,athena_fdb_del_by_port), \
 

    SW_API_DEF(SW_API_FDB_FIRST,  athena_fdb_first), \
    SW_API_DEF(SW_API_FDB_NEXT,   athena_fdb_next),
    SW_API_DESC(SW_API_FDB_ADD)  \
    SW_API_DESC(SW_API_FDB_DELALL)  \
    SW_API_DESC(SW_API_FDB_DELPORT) \
    SW_API_DESC(SW_API_FDB_DELMAC)  \
    SW_API_DESC(SW_API_FDB_FIRST)   \
    SW_API_DESC(SW_API_FDB_NEXT)
    SW_API_DEF(SW_API_PT_MIB_GET, athena_get_mib_info),
    SW_API_DESC(SW_API_PT_MIB_GET)
    SW_API_DEF(SW_API_PHY_GET, athena_phy_get), \
    SW_API_DEF(SW_API_PHY_SET, athena_phy_set), \
    SW_API_DEF(SW_API_REG_GET, athena_reg_get), \
    SW_API_DEF(SW_API_REG_SET, athena_reg_set), \
    SW_API_DEF(SW_API_REG_FIELD_GET, athena_reg_field_get), \
    SW_API_DEF(SW_API_REG_FIELD_SET, athena_reg_field_set),
    SW_API_DESC(SW_API_PHY_GET)  \
    SW_API_DESC(SW_API_PHY_SET)  \
    SW_API_DESC(SW_API_REG_GET)  \
    SW_API_DESC(SW_API_REG_SET)  \
    SW_API_DESC(SW_API_REG_FIELD_GET) \
    SW_API_DESC(SW_API_REG_FIELD_SET)
    SW_API_DEF(SW_API_SWITCH_RESET, athen
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
TempRepo::TempRepo(Fixture* fixture, const char* name)
    mTempRepoDir = fixture->prepareRepo(name);
TempRepo::~TempRepo()
    QDir(mTempRepoDir).rmpath(QStringLiteral("."));
TempRepoOpener::TempRepoOpener(Fixture* fixture, const char* name)
    : mTempRepo(fixture, name)
    mRepo = MacGitver::repoMan(
long mod(long a, long b)
	return (a%b + b) % b;
BaseLayer::BaseLayer()
float BaseLayer::get(long x, long y)
	int chunk_x = (int)floor((float)x/ chunkSize);
	int chunk_y = (int)floor((float)y/ chunkSize);
	float value;
	std::pair<int, int> chunk_coordinates = std::make_pair(chunk_x, chunk_y);
	long in_chunk_coordinates = (mod(x, chunkSize)) * chunkSize + mod(y, chunkSize);
	{
	}
	else
	{
	  std::shared_ptr<ChunkData> chunk_ptr = preGenerateChunk(chunk_x, chunk_y);
	  chunk_map.insert({chunk_coordinates, chunk_ptr});
	  value = chunk_map[chunk_coordinates]->data[in_chunk_coordinates];
	}
	return value;
void BaseLayer::listchunks()
	std::cout << "Currently loaded chunks:" << std::endl;
	for(auto it=chunk_map.begin(); it!=chunk_map.end(); ++it)
	{
		std::pair<int, int> coordinates = it->first;
		std::cout << " - " << coordinates.first << ";" << coordinates.second << std::endl;
	}
unsigned long BaseLayer::nbChunks()
	return (unsigned long)chunk_map.size();
std::shared_ptr<ChunkData> BaseLay
void setupStaticModels(ModelGeneral            *& modelGeneral,
                       ModelAVOStatic          *& modelAVOstatic,
                       ModelSettings            * modelSettings,
                       InputFiles               * inputFiles,
                       SeismicParametersHolder  & seismicParameters,
                       CommonData               * commonData,
                       int                        i_interval)
  modelGeneral    = new ModelGeneral(modelSettings,
                                     inputFiles,
                                     seismicParameters,
                                     commonData,
                                     i_interval);
  modelAVOstatic  = new ModelAVOStatic(modelSettings,
                                       inputFiles,
                                       commonData,
                                       modelGeneral->GetSimbox(),
                                       i_interval);
bool doTimeLapseAVOI

                             ModelGeneral            * modelGeneral,
                             ModelAVOStatic          * modelAVOstatic,
                             CommonData              * commonData,
                             SeismicParametersHolder & seismicParameters,
                             int                       vintage,
                             int                       i_interval)
  ModelAVODynamic * modelAVOdynamic = NULL;
  modelAVOdynamic = new ModelAVODynamic(modelSettings,
                                        modelGeneral,
                                        commonData,
                                        seismicParameters,
                                        modelGeneral->GetSimbox(),
                                        vintage,
                                        i_interval);
  bool failedLoadingModel = modelAVOdynamic == NULL || modelAVOdynamic->GetFailed();
  if(failedLoadingModel == false) {
    AVOInversion * avoinversion =

    delete avoinversion;
  }
  delete modelAVOdynamic;
  if(modelSettings->getDo4DInversion() == true) {
    if(modelSettings->getDebugLevel()>0)
      modelGeneral->DumpSeismicParameters(const_cast<ModelSettings*>(modelSettings),"_AfterAVO",vintage ,  seismicParameters);
    modelGeneral->updateState4D(seismicParameters);
    if(modelSettings->getDebugLevel()>0)
      modelGeneral->Dump4Dparameters(const_cast<ModelSettings*>(modelSettings),"_AfterAVO",vintage ,  true);
  }
  return(failedLoadingModel);
bool
doTimeLapseTravelTimeInversion(const ModelSettings     * modelSettings,
                               ModelGeneral            * modelGeneral,
                               ModelTravelTimeStatic   * modelTravelTimeStatic,
                               const InputFiles        * inputFiles,
                               const int               & vintage,
                               SeismicParametersHolder & seismicParameters)
  ModelTravelTimeDynamic * modelTravelTimeDynamic =

  modelTravelTimeDynamic = new ModelTravelTimeDynamic(modelSettings,
                                                      inputFiles,
                                                      modelTravelTimeStatic,
                                                      modelGeneral->GetSimbox(),
                                                      vintage);
  bool failedLoadingModel = modelTravelTimeDynamic == NULL || modelTravelTimeDynamic->getFailed();
  if(failedLoadingModel == false) {
    delete travel_time_inversion;
  }
  delete modelTravelTimeDynamic;
  return(failedLoadingModel);
bool
doTimeLapseGravimetricInversion(ModelSettings           * modelSettings,
                                ModelGeneral            * modelGeneral,
                                ModelGravityStatic      * modelGravityStatic,
                                InputFiles              * inputFiles,
                                int                     & vintage,
                                SeismicPa
class Expression;
class Expression_list;
class Named_object;
class Statement;
class Gogo;
class Ast_dump_context : public String_dump
 public:
  Ast_dump_context(std::ostream* out = NULL, bool dump_subblocks = true);
  void
  dump(Gogo*, const char* basename);
  void
  print_indent();
  void
  indent()
  { ++this->indent_;}
  void
  unindent()
  { --this->indent_;}
  bool
  dump_subblocks()
  { return this->dump_subblocks_; }
  std::ostream&
  ostream()
  { return *this->ostream_;}
  void
  dump_block(Block*);
  void
  dump_type(const Type*);
  void
  dump_expression(const Expression*);
  void
  dump_expression_list(const Expression_list*, bool as_pairs = false);
  void
  dump_typed_identifier(const  Typed_identifier*);
  void
  dump_typed_identifier_list(const Typed_identifier_list*);
  void
  dump_temp_variable_name(const Statement*);
  void
  dump_label_name(const Unnamed_label*);
  void
  dump_operator(Operator);
  void
  write_c_string(const char*);
  void
  write_string(const std
class Expression;
class Expression_list;
class Named_object;
class Statement;
class Gogo;
class Ast_dump_context : public String_dump
 public:
  Ast_dump_context(std::ostream* out = NULL, bool dump_subblocks = true);
  void
  dump(Gogo*, const char* basename);
  void
  print_indent();
  void
  indent()
  { ++this->indent_;}
  void
  unindent()
  { --this->indent_;}
  bool
  dump_subblocks()
  { return this->dump_subblocks_; }
  std::ostream&
  ostream()
  { return *this->ostream_;}
  void
  dump_block(Block*);
  void
  dump_type(const Type*);
  void
  dump_expression(const Expression*);
  void
  dump_expression_list(const Expression_list*, bool as_pairs = false);
  void
  dump_typed_identifier(const  Typed_identifier*);
  void
  dump_typed_identifier_list(const Typed_identifier_list*);
  void
  dump_temp_variable_name(const Statement*);
  void
  dump_label_name(const Unnamed_label*);
  void
  dump_operator(Operator);
  void
  write_c_string(const char*);
  void
  write_string(const std
class CBitTreeDecoder3
  CBitDecoder m_Models[1 << 3];
public:
  void Init()
  {
    for(int i = 1; i < (1 << 3); i++)
      m_Models[i].Init();
  }
  int Decode(CRangeDecoder *rangeDecoder)
  {
    int modelIndex = 1;
    RC_INIT_VAR
    for(int bitIndex = 3; bitIndex > 0; bitIndex--)
    {
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
    }
    RC_FLUSH_VAR
    return modelIndex - (1 << 3);
  };
};
class CBitTreeDecoder6
  CBitDecoder m_Models[1 << 6];
public:
  void Init()
  {
    for(int i = 1; i < (1 << 6); i++)
      m_Models[i].Init();
  }
  int Decode(CRangeDecoder *rangeDeco

  {
    int modelIndex = 1;
    RC_INIT_VAR
    for(int bitIndex = 6; bitIndex > 0; bitIndex--)
    {
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(

    }
    RC_FLUSH_VAR
    return modelIndex - (1 << 6);
  };
};
class CBitTreeDecoder8
  CBitDecoder m_Models[1 << 8];
public:
  void Init()
  {
    for(int i = 1; i < (1 << 8); i++)
      m_Models[i].Init();
  }
  int Decode(CRangeDecoder *rangeDecoder)
  {
    int modelIndex = 1;
    RC_INIT_VAR
    for(int bitIndex = 8; bitIndex > 0; bitIndex--)
    {
      RC_GETBIT(m_Models[modelIndex].Probability, modelIndex)
      modelIndex = (modelIndex + modelIndex) + m_Models[modelIndex].Decode(rangeDecoder);
    }
    RC_FLUSH_VAR
    return modelIndex - (1 << 8);
  };
};
class CReverseBitTreeDecoder4
  CBitDecoder m_Models[1 << 4];
public:
  void Init()
  {
    for(int i = 1; i < (1 << 4); i++)
      m_Models[i].Init();
  }
  int Decode(CRangeDecoder *rangeDecoder)
  {
    int modelIndex = 1;
    int symbol = 0;
    RC_INIT_VAR
    for(int bitIndex = 0; bitIndex < 4; bitIndex++)
    {
      RC_GETBIT2(m_Models[modelIndex].Probability, modelIndex, ; , symbol |= (1 << bitIndex))
      RC_G

      RC_GETBIT2(m_Models[modelIndex].Probability, modelIndex, ; , symbol |= (1 << 1))
      RC_GETBIT2(m_Models[modelIndex].Probability, modelIndex, ; , symbol |= (1 << 2))
      RC_GETBIT2(m_Models[modelIndex].Probability, modelIndex, ; , symbol |= (1 << 3))
      int bit = m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = modelIndex + modelIndex + bit;
      symbol |= (bit << bitIndex);
      int bit = m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = modelIndex + modelIndex + bit;
      symbol |= (bit << 0);
      bit = m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = modelIndex + modelIndex + bit;
      symbol |= (bit << 1);      
      bit = m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = modelIndex + modelIndex + bit;
      symbol |= (bit << 2);      
      bit = m_Models[modelIndex].Decode(rangeDecoder);
      modelIndex = modelIndex + modelIndex + bit;
      symbol |= (bit << 3);      
    }
    RC_FLUSH_VAR
    return symbol
namespace gin {
V8IsolateMemoryDumpProvider::V8IsolateMemoryDumpProvider(
    IsolateHolder* isolate_holder)
    : isolate_holder_(isolate_holder) {
  base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(
      this, "V8Isolate", base::ThreadTaskRunnerHandle::Get());
V8IsolateMemoryDumpProvider::~V8IsolateMemoryDumpProvider() {
  base::trace_event::MemoryDumpManager::GetInstance()->UnregisterDumpProvider(
      this);
bool V8IsolateMemoryDumpProvider::OnMemoryDump(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* process_memory_dump) {
  if (isolate_holder_->access_mode() == IsolateHolder::kUseLocker) {
    v8::Locker locked(isolate_holder_->isolate());
    DumpHeapStatistics(args, process_memory_dump);
  } else {
    DumpHeapStatistics(args, process_memory_dump);
  }
  return true;
void V8IsolateMemoryDumpProvider::DumpHeapStatistics(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemory

  std::string dump_base_name =
      base::StringPrintf("v8/isolate_%p", isolate_holder_->isolate());
  std::string space_name_prefix = dump_base_name + "/heap_spaces";
  v8::HeapStatistics heap_statistics;
  isolate_holder_->isolate()->GetHeapStatistics(&heap_statistics);
  size_t known_spaces_used_size = 0;
  size_t known_spaces_size = 0;
  size_t known_spaces_physical_size = 0;
  size_t number_of_spaces = isolate_holder_->isolate()->NumberOfHeapSpaces();
  for (size_t space = 0; space < number_of_spaces; space++) {
    v8::HeapSpaceStatistics space_statistics;
    isolate_holder_->isolate()->GetHeapSpaceStatistics(&space_statistics,
                                                       space);
    const size_t space_size = space_statistics.space_size();
    const size_t space_used_size = space_statistics.space_used_size();
    const size_t space_physical_size = space_statistics.physical_space_size();
    known_spaces_size += space_size;
    known_spaces_used_size += space_used_siz

    known_spaces_physical_size += space_physical_size;
    std::string space_dump_name =
        space_name_prefix + "/" + space_statistics.space_name();
    auto space_dump = process_memory_dump->CreateAllocatorDump(space_dump_name);
    space_dump->AddScalar(base::trace_event::MemoryAllocatorDump::kNameSize,
                          base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                          space_physical_size);
    space_dump->AddScalar("virtual_size",
                          base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                          space_size);
    space_dump->AddScalar("allocated_objects_size",
                          base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                          space_used_size);
  }
  std::string other_spaces_name = space_name_prefix + "/other_spaces";
  auto other_dump = process_memory_dump->CreateAllocatorDump(other_spaces_name);
  other_dump->AddScalar(
      base::trace_event::MemoryAllocatorDump

      base::trace_event::MemoryAllocatorDump::kUnitsBytes,
      heap_statistics.total_physical_size() - known_spaces_physical_size);
  other_dump->AddScalar(
      "allocated_objects_size",
      base::trace_event::MemoryAllocatorDump::kUnitsBytes,
      heap_statistics.used_heap_size() - known_spaces_used_size);
  other_dump->AddScalar("virtual_size",
                        base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                        heap_statistics.total_heap_size() - known_spaces_size);
  if (heap_statistics.does_zap_garbage()) {
    auto zap_dump = process_memory_dump->CreateAllocatorDump(
        dump_base_name + "/zapped_for_debug");
    zap_dump->AddScalar(base::trace_event::MemoryAllocatorDump::kNameSize,
                        base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                        heap_statistics.total_heap_size() -
                            heap_statistics.total_physical_size());
  }
  if (args.level_of_detail == base::trace_event::

    return;
  std::string object_name_prefix = dump_base_name + "/heap_objects_at_last_gc";
  bool did_dump_object_stats = false;
  const size_t object_types =
      isolate_holder_->isolate()->NumberOfTrackedHeapObjectTypes();
  for (size_t type_index = 0; type_index < object_types; type_index++) {
    v8::HeapObjectStatistics object_statistics;
    if (!isolate_holder_->isolate()->GetHeapObjectStatisticsAtLastGC(
            &object_statistics, type_index))
      continue;
    std::string dump_name =
        object_name_prefix + "/" + object_statistics.object_type();
    if (object_statistics.object_sub_type()[0] != '\0')
      dump_name += std::string("/") + object_statistics.object_sub_type();
    auto object_dump = process_memory_dump->CreateAllocatorDump(dump_name);
    object_dump->AddScalar(
        base::trace_event::MemoryAllocatorDump::kNameObjectCount,
        base::trace_event::MemoryAllocatorDump::kUnitsObjects,
        object_statistics.object_count());
    object_dump-
namespace omaha {
class DataDumperGoopdate : public DataDumper {
 public:
  DataDumperGoopdate();
  virtual ~DataDumperGoopdate();
  virtual HRESULT Process(const DumpLog& dump_log,
                          const GoopdumpCmdLineArgs& args);
 private:
  void DumpGoogleUpdateIniFile(const DumpLog& dump_log);
  void DumpHostsFile(const DumpLog& dump_log);
  void DumpUpdateDevKeys(const DumpLog& dump_log);
  void DumpLogFile(const DumpLog& dump_log);
  void DumpEventLog(const DumpLog& dump_log);
  void DumpGoogleUpdateProcessInfo(const DumpLog& dump_log);
  void DumpDirContents(const DumpLog& dump_log, bool is_machine);
  void DumpServiceInfo(const DumpLog& dump_log);
  void DumpRunKeys(const DumpLog& dump_log);
  void DumpScheduledTaskInfo(const DumpLog& dump_log, bool is_machine);
  HRESULT GetRegisteredVersion(bool is_machine, CString* version);
  HRESULT GetDllDir(bool is_machine, CString* dll_path);
  void DumpFileContents(const DumpLog& dump_log,
                        const CStrin
/******************************************************************************
 *
 * TODO: Project Title
 *
 * Copyright (C) 2013 Lars Simon Zehnder. All Rights Reserved.
 * Web: -
 *
 * Author: Lars Simon Zehnder <simon.zehnder@gmail.com>
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 ******************************************************************************/
arma::imat simulateEKOP_cc (const unsigned int nobs, const double alpha, 
        const double epsilon, const double delta, const double mu,
        const double T)
    arma::imat sample(nobs, 5);
    Rcpp::RNGScope scope;
    for (unsigned int i = 0; i < nobs; ++i) {
        if (R::runif(0, 1) < alpha) {
            if (R::runif(0, 1) > delta) {
                sample.at(i, 2) = R::rpois((epsilon + mu) * T);
                sample.at(i, 3) = R::rpois(epsilon * T);
                sample.at(i, 4) = sample.at(i, 2) 

            } else {
                sample.at(i, 2) = R::rpois(epsilon * T);
                sample.at(i, 3) = R::rpois((epsilon + mu) * T);
                sample.at(i, 4) = sample.at(i, 2) + sample.at(i, 3);
            }
        } else {
            sample.at(i, 2) = R::rpois(epsilon * T);
            sample.at(i, 3) = R::rpois(epsilon * T);
            sample.at(i, 4) = sample.at(i, 2) + sample.at(i, 3);
        }
    }    
    return sample;
arma::imat simulateEKOPMis_cc(const unsigned int nobs, const double alpha,
        const double epsilon, const double delta, const double mu,
        const double mis, const double T)
    arma::imat sample(nobs, 5);
    Rcpp::RNGScope scope;
    arma::ivec x(2);
    x.at(0) = 0;
    x.at(1) = 1;
    arma::vec prob(2);
    prob.at(0) = 1.0 - mis;
    prob.at(1) = mis;
    for (unsigned int i = 0; i < nobs; ++i) {
        if (R::runif(0, 1) < alpha) {
            if (R::runif(0, 1) > delta) {
                sample.at(i, 2) = R::rpois((epsilon

                sample.at(i, 3) = R::rpois(epsilon * T);
                sample.at(i, 4) = sample.at(i, 2) + sample.at(i, 3);        
            } else {
                sample.at(i, 2) = R::rpois(epsilon * T);
                sample.at(i, 3) = R::rpois((epsilon + mu) * T);
                sample.at(i, 4) = sample.at(i, 2) + sample.at(i, 3);
            }
        } else {
            sample.at(i, 2) = R::rpois(epsilon * T);
            sample.at(i, 3) = R::rpois(epsilon * T);
            sample.at(i, 4) = sample.at(i, 2) + sample.at(i, 3);
        }
        arma::ivec mis_b(sample.at(i, 2));
        arma::ivec mis_s(sample.at(i, 3));
        mis_b = sample_arma<arma::ivec, Rcpp::IntegerVector>(x, 
                sample.at(i, 2), true, prob);
        mis_s = sample_arma<arma::ivec, Rcpp::IntegerVector>(x, 
                sample.at(i, 3), true, prob);
        sample.at(i, 2) = sample.at(i, 2) - arma::sum(mis_b)
            + arma::sum(mis_s);
        sample.at(i, 3) = sample.at(i, 3)
class Stat {
public:
  Stat () {
    reset ();
  }
  
  void reset (float prior_sample_count = 1.0) {
	}
  void update (float sample) {
    sample_count       += 1.0;
    sample_sum         += sample;
    square_sample_sum  += sample * sample;
  }
  float update_count () {
    return sample_count;
  }
  float mean () { 
    return sample_sum / sample_count; 
  }
  float variance () {
    float m = mean ();
    return square_sample_sum / sample_count - m * m;
  }
  float std_dev () { 
    return sqrt (variance ());
  }
  float std_err () {
    return sqrt (variance () / sample_count);
  } 
  float ucb (Player pl, float explore_coeff) {
    return 
      (pl == Player::black () ? mean() : -mean()) +
      sqrt (explore_coeff / update_count());
  }
  string to_string (float minimal_update_count = 0.0) {
    if (sample_count < minimal_update_count) return "           ";
    ostringstream out;
    char buf [100];
    sprintf (buf, "%+3.3f(%5.0f)", mean(), update_count());
    out << buf;
  
inline size_t roundUp(size_t size, size_t alignment)
    assert(alignment != 0);
    assert((alignment & (alignment - 1)) == 0);
    return (size + (alignment - 1)) & ~(alignment - 1);
GcInfoArrayListBase::GcInfoArrayListBase(IAllocator* allocator)
    : m_allocator(allocator),
      m_firstChunk(nullptr),
      m_lastChunk(nullptr),
      m_lastChunkCount(0),
      m_lastChunkCapacity(0),
      m_itemCount(0)
    assert(m_allocator != nullptr);
GcInfoArrayListBase::~GcInfoArrayListBase()
    for (ChunkBase* list = m_firstChunk, *chunk; list != nullptr; list = chunk)
    {
        chunk = list->m_next;
        m_allocator->Free(list);
    }
void GcInfoArrayListBase::AppendNewChunk(size_t firstChunkCapacity, size_t elementSize, size_t chunkAlignment)
    size_t chunkCapacity = (m_firstChunk == nullptr) ? firstChunkCapacity : (m_lastChunkCapacity * GrowthFactor);
    S_SIZE_T chunkSize = S_SIZE_T(roundUp(sizeof(ChunkBase), chunkAlignment)) + (S_SIZE_T(elementSize) * S_SIZE_T(chunkCapacit

    assert(!chunkSize.IsOverflow());
    ChunkBase* chunk = reinterpret_cast<ChunkBase*>(m_allocator->Alloc(chunkSize.Value()));
    chunk->m_next = nullptr;
    if (m_lastChunk != nullptr)
    {
        assert(m_firstChunk != nullptr);
        m_lastChunk->m_next = chunk;
    }
    else
    {
        assert(m_lastChunk == nullptr);
        m_firstChunk = chunk;
    }
    m_lastChunk = chunk;
    m_lastChunkCount = 0;
    m_lastChunkCapacity = chunkCapacity;
GcInfoArrayListBase::IteratorBase::IteratorBase(GcInfoArrayListBase* list, size_t firstChunkCapacity)
    : m_list(list)
    assert(m_list != nullptr);
    m_currentChunk = m_list->m_firstChunk;
    m_currentChunkCount = (m_currentChunk == m_list->m_lastChunk) ? m_list->m_lastChunkCount : firstChunkCapacity;
GcInfoArrayListBase::ChunkBase* GcInfoArrayListBase::IteratorBase::GetNextChunk(size_t& elementCount)
    if (m_currentChunk == nullptr)
    {
        elementCount = 0;
        return nullptr;
    }
    ChunkBase* chunk = m_cu
static bool checkLocatorCallbacks( const osgVolume::Locator& locator )
    return locator.getLocatorCallbacks().size()>0;
static bool readLocatorCallbacks( osgDB::InputStream& is, osgVolume::Locator& locator )
    unsigned int size = is.readSize(); is >> osgDB::BEGIN_BRACKET;
    for ( unsigned int i=0; i<size; ++i )
    {
        osgVolume::Locator::LocatorCallback* cb =
            dynamic_cast<osgVolume::Locator::LocatorCallback*>( is.readObject() );
        if ( cb ) locator.addCallback( cb );
    }
    is >> osgDB::END_BRACKET;
    return true;
static bool writeLocatorCallbacks( osgDB::OutputStream& os, const osgVolume::Locator& locator )
    const osgVolume::Locator::LocatorCallbacks& callbacks = locator.getLocatorCallbacks();
    os.writeSize( callbacks.size() ); os << osgDB::BEGIN_BRACKET << std::endl;
    for ( osgVolume::Locator::LocatorCallbacks::const_iterator itr=callbacks.begin();
          itr!=callbacks.end(); ++itr )
    {
        os << itr->get();
    }
    os << osgD
QDataStream& operator<<(QDataStream& stream, const film::rgb& pixel);
QDataStream& operator>>(QDataStream& stream, film::rgb& pixel);
QDataStream& operator<<(QDataStream& stream, const film::hitable_t& type);
QDataStream& operator>>(QDataStream& stream, film::hitable_t& type);
QDataStream& operator<<(QDataStream& stream, const film::Hitable* hitable);
QDataStream& operator>>(QDataStream& stream, film::Hitable* hitable);
QDataStream& operator<<(QDataStream& stream, const film::Sphere* sphere);
QDataStream& operator>>(QDataStream& stream, film::Sphere* sphere);
QDataStream& operator<<(QDataStream& stream, const film::Scene* scene);
QDataStream& operator>>(QDataStream& stream, film::Scene* scene);
QDataStream& operator<<(QDataStream& stream, const film::Camera* camera);
QDataStream& operator>>(QDataStream& stream, film::Camera* camera);
QDataStream& operator<<(QDataStream& stream, const film::point3& p);
QDataStream& operator>>(QDataStream& stream, film::point3& p);
QDataStream& operator<
int main(int argc, char *argv[])
	std::string gitVersion = GitInterface::GetGitVersion();
	if (gitVersion.empty())
	{
		std::cerr << "Failed to find git.  Make sure it is installed and on your path." << std::endl;
		return 1;
	}
	std::cout << gitVersion << std::endl;
	if (argc < 2)
	{
		std::cerr << "" << std::endl;
		return 1;
	}
	std::string searchPath(argv[1]);
	if (searchPath.back() != '/')
		searchPath.append("/");
	GitInterface gitIface;
	std::string repoPath;
	std::vector<GitInterface::RepositoryInfo> repoInfo;
	std::vector<std::string> directories(
		FileSystemNavigator::GetAllSubdirectories(searchPath));
	unsigned int i, repoCount(0), ignoreCount(0), nonRepoCount(0);
	const std::string ignoreFileName(".ignore");
	bool needsSpace(false);
	for (i = 0; i < directories.size(); i++)
	{
		repoPath = searchPath + directories[i] + "/";
		std::ifstream ignoreFile((repoPath + ignoreFileName).c_str());
		if (ignoreFile.is_open())
		{
			ignoreCount++;
			continue;
		}
		repoInfo.push_bac

		if (repoInfo.back().isGitRepository)
		{
			repoCount++;
			if (repoInfo.back().uncommittedChanges ||
				repoInfo.back().unstagedChanges ||
				repoInfo.back().untrackedFiles)
			{
				if (needsSpace)
					std::cout << "\n";
				std::cout << repoInfo.back().name << "\n";
				if (repoInfo.back().uncommittedChanges)
					std::cout << "  -> Uncommitted changes\n";
				if (repoInfo.back().unstagedChanges)
					std::cout << "  -> Unstaged changes\n";
				if (repoInfo.back().untrackedFiles)
					std::cout << "  -> Untracked files\n";
				std::cout << std::endl;
				needsSpace = false;
			}
			else if (repoInfo.back().remotes.size() == 0)
			{
				std::cout << "No remotes for " << repoInfo.back().name << std::endl;
				needsSpace = true;
			}
			else
			{
				std::string errorList;
				if (gitIface.FetchAll(repoPath, errorList))
				{
					bool printedName(false);
					unsigned int j, k;
					for (j = 0; j < repoInfo.back().remotes.size(); j++)
					{
						for (k = 0; k < repoInfo.back()

						{
							GitInterface::RepositoryStatus status =
								GitInterface::CompareHeads(repoPath,
								repoInfo.back(), repoInfo.back().remotes[j].name,
								repoInfo.back().branches[k].name);
							if (status != GitInterface::StatusUpToDate)
							{
								if (!printedName)
								{
									if (needsSpace)
										std::cout << "\n";
									std::cout << repoInfo.back().name;
									printedName = true;
								}
									
								std::cout << "\n ==> "
									<< repoInfo.back().remotes[j].name
									<< ":" << repoInfo.back().branches[k].name;
								if (status == GitInterface::StatusLocalAhead ||
									status == GitInterface::StatusRemoteMissingBranch)
								{
									if (gitIface.PushToRemote(repoPath,
										repoInfo.back().remotes[j].name,
										repoInfo.back().branches[k].name))
										std::cout << " is now up-to-date";
									else
										std::cout << " push failed";
								}
								else if (status == GitInterface::StatusRemoteAhead)


									std::cout << " has diverged from remote and requires user action";
								}
								else if (status == GitInterface::StatusLocalMissingBranch)
								{
									std::cout << " branch does not exist locally";
								}
								
							}
						}
					}
					if (printedName)
					{
						std::cout << "\n" << std::endl;
						needsSpace = false;
					}
				}
				else
				{
					if (needsSpace)
						std::cout << "\n";
					std::cout << repoInfo.back().name << "\n";
					std::cout << errorList << std::endl;
					needsSpace = false;
				}
			}
		}
		else
		{
			nonRepoCount++;
			/*std::cout << repoInfo.back().name << " is not a git repository" << std::endl;
			needsSpace = true;*/
		}
	}
	if (repoCount == 0)
	{
		std::cout << "Failed to find any git repositories under '" << searchPath << "'" << std::endl;
		return 0;
	}
	std::cout << "\nChecked " << repoCount << " git repositories" << std::endl;
	std::cout << "Skipped " << nonRepoCount << " directories which did not contain repo
class QAction;
class QContextMenuEvent;
class QEvent;
class QShowEvent;
class QHideEvent;
class QModelIndex;
class QStandardItem;
class RepoItem;
class RepoCategoryItem;
class CloudView;
class CloneTasksDialog;
class RepoTreeView : public QTreeView {
    Q_OBJECT
public:
    RepoTreeView(CloudView *view, QWidget *parent=0);
    std::vector<QAction*> getToolBarActions();
protected:
    void contextMenuEvent(QContextMenuEvent *event);
    bool viewportEvent(QEvent *event);
    void showEvent(QShowEvent *event);
    void hideEvent(QHideEvent *event);
    void selectionChanged(const QItemSelection &selected,
                          const QItemSelection &deselected);
private slots:
    void downloadRepo();
    void showRepoDetail();
    void openLocalFolder();
    void viewRepoOnWeb();
    void onItemClicked(const QModelIndex& index);
    void onItemDoubleClicked(const QModelIndex& index);
    void toggleRepoAutoSync();
    void unsyncRepo();
    void syncRepoImmediately();
    void cance
namespace ZGen {
namespace BestFirst {
void wp(const ctx_t& ctx, std::vector<bs_t>& results) {
  results.clear();
  results.push_back( bs_t(ctx.word, ctx.tag) );
void w0w1(const ctx_t& ctx, std::vector<bs_t>& results) {
  results.clear();
  for (int i = 1; i < ctx.words.size(); ++ i) {
    const word_t& w0 = ctx.words[i- 1];
    const word_t& w1 = ctx.words[i];
    results.push_back( bs_t(w0, w1) );
  }
void p0p1(const ctx_t& ctx, std::vector<bs_t>& results) {
  results.clear();
  for (int i = 1; i < ctx.words.size(); ++ i) {
    const postag_t& p0 = ctx.postags[i- 1];
    const postag_t& p1 = ctx.postags[i];
    results.push_back( bs_t(p0, p1) );
  }
void hm(const ctx_t& ctx, std::vector<bs_t>& results) {
  results.clear();
  for (int i = 0; i < ctx.relations.size(); ++ i) {
    const int& hid = ctx.relations[i].first;
    const int& mid = ctx.relations[i].second;
    const word_t& hw = ctx.ref->forms[hid];
    const word_t& mw = ctx.ref->forms[mid];
    const postag_t& hp = ctx.ref->

    const postag_t& mp = ctx.ref->postags[mid];
    results.push_back( bs_t(hw, mw) );
    results.push_back( bs_t(hw, mp) );
    results.push_back( bs_t(hp, mw) );
    results.push_back( bs_t(hp, mp) );
  }
void hm3(const ctx_t& ctx, std::vector<ts_t>& results) {
  results.clear();
  for (int i = 0; i < ctx.relations.size(); ++ i) {
    const int& hid = ctx.relations[i].first;
    const int& mid = ctx.relations[i].second;
    const word_t& hw = ctx.ref->forms[hid];
    const word_t& mw = ctx.ref->forms[mid];
    const postag_t& hp = ctx.ref->postags[hid];
    const postag_t& mp = ctx.ref->postags[mid];
    results.push_back( ts_t(hw, hp, mw) );
    results.push_back( ts_t(hw, hp, mp) );
    results.push_back( ts_t(hw, mw, mw) );
    results.push_back( ts_t(hp, mw, mp) );
  }
Model::Model() {
  uscore_repo.reserve(64);
  bscore_repo.reserve(80);
  tscore_repo.reserve(80);
  uscore_repo.clear();
  bscore_repo.clear();
  tscore_repo.clear();
  bscore_repo.push_back( ScoreMap<bs_t>( wp )

  bscore_repo.push_back( ScoreMap<bs_t>( w0w1 ) );
  bscore_repo.push_back( ScoreMap<bs_t>( p0p1 ) );
  bscore_repo.push_back( ScoreMap<bs_t>( hm ) );
  tscore_repo.push_back( ScoreMap<ts_t>( hm3 ) );
floatval_t
Model::score(const Span& span, bool avg) const {
  ScoreContext ctx(span);
  return score(ctx, avg);
floatval_t
Model::score(const ScoreContext& ctx, bool avg) const {
  floatval_t ret = 0;
  for (int i = 0; i < uscore_repo.size(); ++ i) {
    ret += uscore_repo[i].score(ctx, avg, 0.);
  }
  for (int i = 0; i < bscore_repo.size(); ++ i) {
    ret += bscore_repo[i].score(ctx, avg, 0.);
  }
  for (int i = 0; i < tscore_repo.size(); ++ i) {
    ret += tscore_repo[i].score(ctx, avg, 0.);
  }
  return ret;
void
Model::update(const Span& span, int timestamp, floatval_t scale) {
  ScoreContext ctx(span);
  update(ctx, timestamp, scale);
void
Model::update(const ScoreContext& ctx, int timestamp, floatval_t scale) {
  for (int i = 0; i < uscore_repo.size(); ++ i) {
    uscore_repo[i].u

  }
  for (int i = 0; i < bscore_repo.size(); ++ i) {
    bscore_repo[i].update(ctx, timestamp, scale);
  }
  for (int i = 0; i < tscore_repo.size(); ++ i) {
    tscore_repo[i].update(ctx, timestamp, scale);
  }
void
Model::flush(int timestamp) {
  for (int i = 0; i < uscore_repo.size(); ++ i) {
    uscore_repo[i].flush(timestamp);
  }
  for (int i = 0; i < bscore_repo.size(); ++ i) {
    bscore_repo[i].flush(timestamp);
  }
  for (int i = 0; i < tscore_repo.size(); ++ i) {
    tscore_repo[i].flush(timestamp);
  }
bool
Model::save(std::ostream& os) {
  boost::archive::text_oarchive oa(os);
  for (int i = 0; i < uscore_repo.size(); ++ i) {
    uscore_repo[i].save(oa);
  }
  for (int i = 0; i < bscore_repo.size(); ++ i) {
    bscore_repo[i].save(oa);
  }
  for (int i = 0; i < tscore_repo.size(); ++ i) {
    tscore_repo[i].save(oa);
  }
  return true;
bool
Model::load(std::istream& is) {
  boost::archive::text_iarchive ia(is);
  for (int i = 0; i < uscore_repo.size(); ++ i) {
    uscore_
namespace lldb {
class LLDB_API SBAddress;
class LLDB_API SBBlock;
class LLDB_API SBBreakpoint;
class LLDB_API SBBreakpointLocation;
class LLDB_API SBBroadcaster;
class LLDB_API SBCommand;
class LLDB_API SBCommandInterpreter;
class LLDB_API SBCommandPluginInterface;
class LLDB_API SBCommandReturnObject;
class LLDB_API SBCommunication;
class LLDB_API SBCompileUnit;
class LLDB_API SBData;
class LLDB_API SBDebugger;
class LLDB_API SBDeclaration;
class LLDB_API SBError;
class LLDB_API SBEvent;
class LLDB_API SBEventList;
class LLDB_API SBExpressionOptions;
class LLDB_API SBFileSpec;
class LLDB_API SBFileSpecList;
class LLDB_API SBFrame;
class LLDB_API SBFunction;
class LLDB_API SBHostOS;
class LLDB_API SBInstruction;
class LLDB_API SBInstructionList;
class LLDB_API SBLineEntry;
class LLDB_API SBListener;
class LLDB_API SBModule;
class LLDB_API SBModuleSpec;
class LLDB_API SBModuleSpecList;
class LLDB_API SBProcess;
class LLDB_API SBSourceManager;
class LLDB_API SBStream;
class LLDB_API SBS
using namespace Boxes;
using namespace std;
SampleTableBox::SampleTableBox (uint32_t size, uint64_t type) :
		BaseBox (size, type),
		SampleDescription (NULL),
		TimeToSample (NULL),
		SampleToChunk (NULL),
		SampleSize (NULL),
		ChunkOffset (NULL)
		{}
SampleTableBox::~SampleTableBox () {
	if (this->SampleDescription) 	delete this->SampleDescription;
	if (this->TimeToSample) 		delete this->TimeToSample;
	if (this->SampleToChunk) 		delete this->SampleToChunk;
	if (this->SampleSize) 			delete this->SampleSize;
	if (this->ChunkOffset) 			delete this->ChunkOffset;
void SampleTableBox::SetSampleDescriptionBox (SampleDescriptionBox *stsdBox) {
	if (!this->SampleDescription) this->SampleDescription = stsdBox;
void SampleTableBox::SetTimeToSampleBox (TimeToSampleBox *sttsBox) {
	if (!this->TimeToSample) this->TimeToSample = sttsBox;
void SampleTableBox::SetSampleToChunkBox (SampleToChunkBox *stscBox) {
	if (!this->SampleToChunk) this->SampleToChunk = stscBox;
void SampleTableBox::SetSampleSiz

	if (!this->SampleSize) this->SampleSize = stszBox;
void SampleTableBox::SetChunkOffsetBox (ChunkOffsetBox *stcoBox) {
	if (!this->ChunkOffset) this->ChunkOffset = stcoBox;
SampleDescriptionBox* SampleTableBox::GetSampleDescriptionBox () {
	return this->SampleDescription;
TimeToSampleBox* SampleTableBox::GetTimeToSampleBox () {
	return this->TimeToSample;
SampleToChunkBox* SampleTableBox::GetSampleToChunkBox () {
	return this->SampleToChunk;
SampleSizeBox* SampleTableBox::GetSampleSizeBoc () {
	return this->SampleSize;
ChunkOffsetBox* SampleTableBox::GetChunkOffsetBox () {
	return this->ChunkOffset;
void SampleTableBox::Print (uint32_t level) {
	stringstream ss;
	for (uint32_t i = 0; i < level; i++)
		ss << "  ";
	cout << endl;
	cout << ss.str() << "Sample Table Box :" << endl;
	cout << ss.str() << "  Size = " << this->GetSize() << endl;
	cout << ss.str() << "  Type = " << this->GetType() << " (";
	for (int i = 3; i >= 0; i--) cout << (uint8_t)(this->GetType() >> i*8);
	cout << ")" <<
/* 
 * File:   FormatChunk.cpp
 * Author: rd
 * 
 * Created on 3 ÐÑÐ½Ñ 2010 Ð³., 12:49
 */
FormatChunk::FormatChunk() {
FormatChunk::FormatChunk(const FormatChunk& orig) {
    throw "ÐÐµ Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑÑÐ¾Ñ ÐºÐ»Ð°ÑÑ ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑÑÑ!";
FormatChunk::~FormatChunk() {
void FormatChunk::loadData(std::ifstream& in){
    if(getSize()!=sizeof(WaveFormat))
        throw "ÐÐ¾Ð²ÑÐµÐ¶Ð´ÐµÐ½Ð½ÑÐ¹ format-chunk";
    in.read((char*)(&format),sizeof(WaveFormat));
void FormatChunk::saveData(std::ofstream& out)const{
    out.write((const char*)&format,sizeof(WaveFormat));
unsigned short FormatChunk::getFormatTag() const{
    return format.formatTag;
    
unsigned short FormatChunk::getChannels()const{
    return format.channels;
unsigned int FormatChunk::getSamplesPerSec()const{
    return format.samplesPerSec;
unsigned int FormatChunk::getAvgBytesPerSec()const{
    return format.avgBytesPerSec;
unsigned short FormatChunk::getBlockAlign()const{
    return format.blockAlign;
unsigned short  FormatChunk::bitsPerSample()const{
    
/*
** $Id: ldump.c,v 2.17 2012/01/23 23:02:10 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size*sizeof(char),D);
 }
static void DumpFunction(const Proto* f, DumpState* D);
static void DumpConstants(const Proto* f, DumpSta

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttypenv(o),D);
  switch (ttypenv(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
    default: lua_assert(0);
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],D);
static void DumpUpvalues(const Proto* f, DumpState* D)
 int i,n=f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpChar(f->upvalues[i].instack,D);
  DumpChar(f->upvalues[i].idx,D);
 }
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 DumpString((D->strip) ? NULL : f->source,D);
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].
/*-----------------------------------------------------------------------
 * File: BioAPI_API.H
 *
 *-----------------------------------------------------------------------
 */
/* API Functions */
extern "C" {
/*************************************************************************/
/*** BioAPI Core Functions ***********************************************/
/*************************************************************************/
BioAPI_RETURN BioAPI BioAPI_Init(
						const BioAPI_VERSION *Version,
						uint32 Reserved1,
						const void *Reserved2,
						uint32 Reserved3,
						const void *Reserved4 );
BioAPI_RETURN BioAPI BioAPI_Terminate(
						void );
BioAPI_RETURN BioAPI BioAPI_ModuleLoad(
						const BioAPI_UUID *ModuleGuid,
						uint32 Reserved,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
BioAPI_RETURN BioAPI BioAPI_ModuleUnload(
						const BioAPI_UUID *ModuleGuid,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *A

BioAPI_RETURN BioAPI BioAPI_ModuleAttach(
						const BioAPI_UUID *ModuleGuid,
						const BioAPI_VERSION *Version,
						const BioAPI_MEMORY_FUNCS *MemoryFuncs,
						uint32 DeviceID,
						uint32 Reserved1,
						uint32 Reserved2,
						uint32 Reserved3,
						BioAPI_FUNC_NAME_ADDR *FunctionTable,
						uint32 NumFunctionTable,
						const void *Reserved4,
						BioAPI_HANDLE_PTR NewModuleHandle );
BioAPI_RETURN BioAPI BioAPI_ModuleDetach(
						BioAPI_HANDLE ModuleHandle );
BioAPI_RETURN BioAPI BioAPI_QueryDevice(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_SERVICE_UID_PTR ServiceUID );
/*************************************************************************/
/*** BioAPI Service Functions ********************************************/
/*************************************************************************/
BioAPI_RETURN BioAPI BioAPI_FreeBIRHandle(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle );
BioAPI_RETURN BioAPI BioAPI_GetBIRFromHandle(
						BioAP

						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_PTR *BIR );
BioAPI_RETURN BioAPI BioAPI_GetHeaderFromHandle(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_HEADER_PTR Header );
BioAPI_RETURN BioAPI BioAPI_EnableEvents(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_MODULE_EVENT_MASK *Events );
BioAPI_RETURN BioAPI BioAPI_SetGUICallbacks(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_GUI_STREAMING_CALLBACK GuiStreamingCallback,
						void *GuiStreamingCallbackCtx,
						BioAPI_GUI_STATE_CALLBACK GuiStateCallback,
						void *GuiStateCallbackCtx );
BioAPI_RETURN BioAPI BioAPI_SetStreamCallback(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_STREAM_CALLBACK StreamCallback,
						void *StreamCallbackCtx );
BioAPI_RETURN BioAPI BioAPI_StreamInputOutput(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DATA_PTR InMessage,
						BioAPI_DATA_PTR OutMessage );
BioAPI_RETURN BioAPI BioAPI_Capture(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPO

						BioAPI_BIR_HANDLE_PTR CapturedBIR,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_CreateTemplate(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload );
BioAPI_RETURN BioAPI BioAPI_Process(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						BioAPI_BIR_HANDLE_PTR ProcessedBIR );
BioAPI_RETURN BioAPI BioAPI_VerifyMatch(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE *AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload );
BioAPI_RETURN BioAPI BioAPI_IdentifyMatc

						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout );
BioAPI_RETURN BioAPI BioAPI_Enroll(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpose,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_Verify(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR AdaptedBIR,
						BioAPI_BOOL *R

						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_Identify(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_Import(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_DATA *InputData,
						BioAPI_BIR_BIOMETRIC_DATA_FORMAT InputFormat,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR ConstructedBIR );
BioAPI_RETURN BioAPI BioAPI_SetPowerMode(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_POWER_MODE PowerMode );
BioAPI_RETURN BioAPI BioAPI_DbOpen(
			

						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
BioAPI_RETURN BioAPI BioAPI_DbClose(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle );
BioAPI_RETURN BioAPI BioAPI_DbCreate(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle );
BioAPI_RETURN BioAPI BioAPI_DbDelete(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName );
BioAPI_RETURN BioAPI BioAPI_DbSetCursor(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_DB_CURSOR_PTR Cursor );
BioAPI_RETURN BioAPI BioAPI_DbFreeCursor(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
BioAPI_RETURN BioAPI BioAPI_DbStoreBIR(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *BIRToStore,
						BioAPI_DB_HANDLE DbHandle,
						BioAPI_UUID_PTR Uui
FUNCTION_POINTER(RTL_Init);
FUNCTION_POINTER(RTL_Copy);
FUNCTION_POINTER(RTL_BytesToUnit);
FUNCTION_POINTER(RTL_ByteOffsetToUnitOffset);
FUNCTION_POINTER(RTL_BytesToSectors);
FUNCTION_POINTER(RTL_BytesToPages);
FUNCTION_POINTER(RTL_ByteOffsetToLBA);
FUNCTION_POINTER(STRING_Compare);
FUNCTION_POINTER(STRING_Append);
FUNCTION_POINTER(STRING_Copy);
FUNCTION_POINTER(HEAP_Alloc);
FUNCTION_POINTER(HEAP_Free);
FUNCTION_POINTER(LIST_Init);
FUNCTION_POINTER(LIST_IsEmpty);
FUNCTION_POINTER(LIST_InsertHead);
FUNCTION_POINTER(LIST_InsertTail);
FUNCTION_POINTER(LIST_Remove);
FUNCTION_POINTER(LIST_First);
FUNCTION_POINTER(LIST_Next);
FUNCTION_POINTER(CONSOLE_Init);
FUNCTION_POINTER(CONSOLE_SetCursor);
FUNCTION_POINTER(CONSOLE_GetX);
FUNCTION_POINTER(CONSOLE_GetY);
FUNCTION_POINTER(CONSOLE_Clear);
FUNCTION_POINTER(CONSOLE_Write);
FUNCTION_POINTER(CONSOLE_NewLine);
FUNCTION_POINTER(CONSOLE_WriteLn);
FUNCTION_POINTER(CONSOLE_WriteNumber);
					if(!X) return false
PUBLIC bool LoadRTL(VIRTUAL _load_addre

	string RTL_module = STRING("COMMONS\\RTL.x");
	if(XKY_LDR_LoadUserModule(&RTL_module, XKY_ADDRESS_SPACE_GetCurrent(), _load_address))
	{
		LoadExportedFunction(_load_address, RTL_Init);
		LoadExportedFunction(_load_address, RTL_Copy);
		LoadExportedFunction(_load_address, RTL_BytesToUnit);
		LoadExportedFunction(_load_address, RTL_ByteOffsetToUnitOffset);
		LoadExportedFunction(_load_address, RTL_BytesToSectors);
		LoadExportedFunction(_load_address, RTL_BytesToPages);
		LoadExportedFunction(_load_address, RTL_ByteOffsetToLBA);
		LoadExportedFunction(_load_address, STRING_Compare);
		LoadExportedFunction(_load_address, STRING_Append);
		LoadExportedFunction(_load_address, STRING_Copy);
		LoadExportedFunction(_load_address, HEAP_Alloc);
		LoadExportedFunction(_load_address, HEAP_Free);
		LoadExportedFunction(_load_address, LIST_Init);
		LoadExportedFunction(_load_address, LIST_IsEmpty);
		LoadExportedFunction(_load_address, LIST_InsertHead);
		LoadExportedFunction(_load_address, LIST_
const ChunkID rootChunkID((uint8 *)"ROOT");
const uint32 ChunkID::length = 4;
ChunkID::ChunkID()
ChunkID::ChunkID(const uint8 *_id)
	Decode(_id);
bool ChunkID::operator==(const ChunkID &other) const
	return(id == other.id);
bool ChunkID::operator==(const uint8 *other) const
	return(*((uint32 *)other) == id);
void ChunkID::Encode(uint8 *_id)
	*((uint32 *)_id) = id;
void ChunkID::Decode(const uint8 *_id)
	id = *((uint32 *)_id);
Chunk::Chunk(Chunk *_parent, Chunk *_rootChunk, const ChunkID &_id)
	id = _id;
	parent = _parent;
	rootChunk = _rootChunk;
Chunk::~Chunk()
	Clear();
uint32 Chunk::GetLength()
	uint32 length = 0;
	for(std::list<Chunk *>::iterator i = subChunks.begin(); i != subChunks.end(); ++i)
	{
		length += (*i)->GetLength();
	}
	return(length + ChunkID::length + 4);
void Chunk::Clear()
	for(std::list<Chunk *>::iterator i = subChunks.begin(); i != subChunks.end(); ++i)
	{
		delete *i;
	}
	subChunks.clear();
bool Chunk::FindSubChunk(ChunkID &id, std::list<Chunk *>::iterator *resu

	std::list<Chunk *>::iterator newStartingPos, newEndingPos;
	if(startingPos != NULL)
	{
		newStartingPos = *startingPos;
	}
	else
	{
		newStartingPos = subChunks.begin();
	}
	if(endingPos != NULL)
	{
		newEndingPos = *endingPos;
		++newEndingPos;
	}
	else
	{
		newEndingPos = subChunks.end();
	}
	for(std::list<Chunk *>::iterator i = 0; i != newEndingPos; ++i)
	{
		if((*i)->id == id)
		{
			*result = i;
			return(true);
		}
	}
	return(false);
void Chunk::ChildrenHandler(const uint8 *data, const uint32 maxLength)
	uint32 currentPos = 0;
	uint32 maxChunkSize;
	Chunk *newChunk;
	while(currentPos < maxLength)
	{
		if(currentPos < (ChunkID::length + 4))
		{
			throw CFE_OutOfData("Ran out of data while searching for subChunks");
		}
		uint32 chunkLength;
		chunkLength = *(uint32 *)(data + currentPos + ChunkID::length + 4);
		maxChunkSize = maxLength - currentPos;
		newChunk = ChildFactory(ChunkID(data), maxLength - currentPos);
		if(newChunk != NULL)
		{
			newChunk->Decode(data, maxLength -
namespace ll {
obstack *obstack::_new(size_t initsize, page_allocator *pa) 
    if (!pa) {
        pa = page_allocator::global();
    }
    page *chunk; 
    initsize += ll_align_default(sizeof(obstack));
    chunk = pa->alloc(initsize);
    chunk->next = nullptr;
    obstack *ob = (obstack*)chunk->firstp;
    chunk->firstp += ll_align_default(sizeof(obstack));
    ob->_pa = pa;
    ob->_chunk = chunk;
    ob->_next_free = ob->_object_base = chunk->firstp;
    ob->_chunk_limit = chunk->endp;
    ob->_maybe_empty_object = false;
    return ob;
void obstack::_delete(obstack *ob)
    page_allocator *pa = ob->_pa;
    page *chunk = ob->_chunk;
    page *tmp;
    while (chunk) {
        tmp = chunk->next;
        pa->free(chunk);
        chunk = tmp;
    }
void obstack::clear()
    page *chunk = _chunk;
    page *tmp;
    while (1) {
        tmp = chunk->next;
        if (!tmp) {
            break;
        }
        _pa->free(chunk);
        chunk = tmp;
    }
    _chunk = chunk;
    _next_

    _chunk_limit = chunk->endp;
    _maybe_empty_object = false;
void obstack::newchunk(size_t length)
    register page *old_chunk = _chunk;
    register page *new_chunk;
    register size_t new_size;
    register size_t obj_size = _next_free - _object_base;
    char *object_base;
    new_size = obj_size + length + 128;
    new_chunk = _pa->alloc(new_size);
    _chunk = new_chunk;
    new_chunk->next = old_chunk;
    _chunk_limit = new_chunk->endp;
    /* Compute an aligned object_base in the new chunk */
    object_base = new_chunk->firstp;
    memcpy(object_base, _object_base, obj_size);
    if (!_maybe_empty_object && (_object_base == old_chunk->firstp) && old_chunk->next) {
        new_chunk->next = old_chunk->next;
        _pa->free(old_chunk);
    }
    _object_base = object_base;
    _next_free = _object_base + obj_size;
    _maybe_empty_object = false;
void obstack::free(page *chunk, char *obj)
    page *tmp;
    while ((tmp = chunk->next) && (chunk->firstp >= obj || chunk->e

        _pa->free(chunk);
        chunk = tmp;
        /* If we switch chunks, we can't tell whether the new current
           chunk contains an empty object, so assume that it may.  */
        _maybe_empty_object = true;
    }
    if (!tmp && (chunk->firstp > obj || chunk->endp < obj)) {
        crit_error("obstack free failed, obj is not in any of the chunks!");
    }
    _object_base = _next_free = obj;
    _chunk_limit = chunk->endp;
    _chunk = chunk;
int obstack::vprint(const char *fmt, va_list ap)
    struct obstack_vbuff : public printf_formatter::buff {
        obstack *_owner;
        int flush() {
            _owner->_next_free = curpos;
            if (_owner->_next_free >= _owner->_chunk_limit) {
                _owner->make_rome(128);
                curpos = _owner->_next_free;
                endpos = _owner->_chunk_limit;
            }
            return 0;
        }
    };
    obstack_vbuff buff;
    buff._owner = this;
    buff.curpos = _next_free;
    buff.endpos
RepoItem::RepoItem(const ServerRepo& repo)
    : repo_(repo)
    setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
    LocalRepo local_repo;
    seafApplet->rpcClient()->getLocalRepo(repo.id, &local_repo);
    setLocalRepo(local_repo);
    sync_now_clicked_ = false;
void RepoItem::setRepo(const ServerRepo& repo)
    repo_ = repo;
void RepoItem::setLocalRepo(const LocalRepo& repo)
    local_repo_ = repo;
bool RepoItem::repoDownloadable() const
    if (local_repo_.isValid()) {
        return false;
    }
    if (!clone_task_.isValid()) {
        return true;
    }
    QString state = clone_task_.state;
    if (state == "canceled" || state == "error" || state == "done") {
        return true;
    }
    return false;
RepoCategoryItem::RepoCategoryItem(const QString& name)
    : name_(name),
      group_id_(-1)
    setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
RepoCategoryItem::RepoCategoryItem(const QString& name, int group_id)
    : name_(name),
      group_id_(group_id)
    setFl
AVInfo::AVInfo
    (
    double aFps /* = 0.0 */,
    double aUsecs /* = 0.0 */,
    unsigned aAudioChannel /* = 0.0 */,
    AVSampleFormat aSampleFormat /* = AV_SAMPLE_FMT_NONE */,
    unsigned aAudioSampleRate /* = 0.0 */,
    unsigned aAudioBitsPerSample /* = 0.0 */
    )
    mFps = aFps;
    mUsecs = aUsecs;
    mAudioChannel = aAudioChannel;
    mAudioSampleFormat = turnLibavSampleFormat( aSampleFormat );
    mAudioSampleRate = aAudioSampleRate;
    mAudioBitsPerSample = aAudioBitsPerSample;
    dump();
AudioPlayer::SampleFormat AVInfo::turnLibavSampleFormat( AVSampleFormat aFormat )
    DEBUG() << "get a audio sample format: " << av_get_sample_fmt_name(aFormat);
    /*
        not support libav sample format:
        AV_SAMPLE_FMT_U8P,
        AV_SAMPLE_FMT_S16P,
        AV_SAMPLE_FMT_S32P,
        AV_SAMPLE_FMT_FLTP,
        AV_SAMPLE_FMT_DBLP,
        AV_SAMPLE_FMT_DBL,
        AV_SAMPLE_FMT_NONE,
        AV_SAMPLE_FMT_NB
        enum AVSampleFormat {
            AV_SAMPLE_FMT_

        };
    */
    switch ( aFormat )
    {
        case AV_SAMPLE_FMT_U8:
        case AV_SAMPLE_FMT_U8P: return AudioPlayer::UInt8;
        case AV_SAMPLE_FMT_S16:
        case AV_SAMPLE_FMT_S16P:return AudioPlayer::Int16;
        case AV_SAMPLE_FMT_S32:
        case AV_SAMPLE_FMT_S32P:return AudioPlayer::Int32;
        case AV_SAMPLE_FMT_FLT:
        case AV_SAMPLE_FMT_FLTP:return AudioPlayer::Float32;
        default:                return AudioPlayer::Error;
    }
double AVInfo::getFps() const
    return mFps;
double AVInfo::getUsecs() const
    return mUsecs;
unsigned AVInfo::getAudioChannel() const
    return mAudioChannel;
AudioPlayer::SampleFormat AVInfo::getAudioSampleFormat() const
    return mAudioSampleFormat;
unsigned AVInfo::getAudioSampleRate() const
    return mAudioSampleRate;
unsigned AVInfo::getAudioBitsPerSample() const
    return mAudioBitsPerSample;
void AVInfo::dump() const
    DEBUG() << "fps:" << mFps;
    DEBUG() << "audio channel:" << mAudioChannel;
    
namespace fly
static int positive_mod(int a, int b)
    return (a % b + b) % b;
Terrain::Terrain(int radius, int detail) :
            m_radius(radius),
            m_detail(detail),
            m_center(0.f, 0.f),
            m_centerChunk{0, 0},
            m_renderer(radius, detail)
{}
void Terrain::generateChunk(int coord_x, int coord_y, std::vector<float>& heights, std::vector<float>& color)
    heights.resize(sq(m_detail + 1 + 2));
    color.resize(sq(m_detail + 1));
    for (int i = -1, c = 0; i <= m_detail + 1; ++i)
    {
        for (int j = -1; j <= m_detail + 1; ++j, ++c)
        {
            float x = coord_x + 1.0f * i / m_detail - 0.5f,
                  y = coord_y + 1.0f * j / m_detail - 0.5f;
            float height = 1.5f * std::pow(
                scaled_octave_noise_3d(4.f, 0.15f, 1.f / 6.f, 4.f, 0.f, 1.f, x, y, m_seed), 3.f);
            heights[c] = height;
            if (i >= 0 && i <= m_detail && j >= 0 && j <= m_detail)
                color[i * (m_detail +

                scaled_octave_noise_3d(4.f, 0.5f, 1.f / 10.f, 2.f, 0.f, 1.f, x, y, m_seed + 42);
        }
    }
void Terrain::updateChunk(int chunk_x, int chunk_y, int coord_x, int coord_y,
                          const std::vector<float>& heights, const std::vector<float>& color)
    m_chunkMap[chunk_x + m_radius - 1][chunk_y + m_radius - 1] = {coord_x, coord_y};
    m_renderer.updateChunk(chunk_x, chunk_y, coord_x, coord_y, heights, color);
void Terrain::generate(float seed)
    m_seed = seed;
    m_renderer.reset(m_radius, m_detail);
    LOG(Info) << "Generating terrain with seed: " << seed << std::endl;
    m_chunkMap.resize(2 * m_radius - 1, std::vector<Pair>(2 * m_radius - 1, {0, 0}));
    std::vector<float> heights, colormap;
    for (int x = -m_radius + 1; x < m_radius; ++x)
    {
        for (int y = -m_radius + 1; y < m_radius; ++y)
        {
            generateChunk(x, y, heights, colormap);
            updateChunk(x, y, x, y, heights, colormap);
        }
    }
    LOG

void Terrain::moveCenter(const glm::vec2& displacement)
    m_center += displacement;
    int dx_chunk = static_cast<int>(m_center.x) - m_centerChunk.x;
    int dy_chunk = static_cast<int>(m_center.y) - m_centerChunk.y;
    if (dx_chunk != 0)
    {
        assert(std::abs(dx_chunk) == 1);
        std::vector<float> heights, colormap;
        int chunk_x = positive_mod(m_centerChunk.x + (m_radius - 1) - (m_radius - 1) * dx_chunk,
                              2 * m_radius - 1) - (m_radius  - 1);
        for (int chunk_y = -m_radius + 1; chunk_y < m_radius; ++chunk_y)
        {
            int y = m_chunkMap[chunk_x + m_radius - 1][chunk_y + m_radius - 1].y;
            generateChunk(m_centerChunk.x + m_radius * dx_chunk, y, heights, colormap);
            updateChunk(chunk_x, chunk_y, m_centerChunk.x + m_radius * dx_chunk, y, heights, colormap);
        }
        m_centerChunk.x +=  dx_chunk;
    }
    if (dy_chunk != 0)
    {
        assert(std::abs(dy_chunk) == 1);
        std::vecto
extern bool SortObjectsPredicate(const Object* o1, const Object* o2);
extern Engine* engine;
Object::Object() {
	gridSize=engine->editorGridSize;
	grabbed=false;
	visible=true;
	depth=0;
	chunk.x=0;
	chunk.y=0;
	objectIndex=0;
};
Object::~Object() {
};
bool Object::SetBBox(int left, int top, int width, int height) {
	bBox.left=left;
	bBox.top=top;
	bBox.width=width;
	bBox.height=height;
	return true;
};
sf::Rect<sf::Int16> Object::GetBBox() {
	return bBox;
};
void Object::SetPosition(float xx, float yy) {
	x=xx;
	y=yy;
	xPrev=x;
	yPrev=y;
};
void Object::MoveToChunk() {
	int chunkX = floor(x/engine->objectsManager->chunkSize.x);
	int chunkY = floor(y/engine->objectsManager->chunkSize.y);
	chunkX = std::max(0,chunkX);
	chunkY = std::max(0,chunkY);
	chunkX = std::min(chunkX,engine->objectsManager->chunksNumber.x);
	chunkY = std::min(chunkY,engine->objectsManager->chunksNumber.y);
	sf::Vector2i temp(chunkX,chunkY);
	if (chunk.x!=temp.x || chunk.y!=temp.y) {
		int size=engine->objectsManag
/*
 * File automatically generated by
 * gengen 1.3 by Lorenzo Bettini 
 */
void
option_arg_gen_class::generate_option_arg(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (long_long_arg)
    {
      stream << "\n";
      stream << indent_str;
      generate_string (type, stream, indent + indent_str.length ());
      stream << " ";
      generate_string (name, stream, indent + indent_str.length ());
      stream << "_arg;	/**< ";
      stream << "@";
      stream << "brief ";
      generate_string (desc, stream, indent + indent_str.length ());
      if (has_default)
        {
          stream << " (default=";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ")";
        }
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      generate_string (longtype, stream, indent + indent_str.length ());
      stream << " ";
    

      stream << "_arg;	/**< ";
      stream << "@";
      stream << "brief ";
      generate_string (desc, stream, indent + indent_str.length ());
      if (has_default)
        {
          stream << " (default=";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ")";
        }
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
      generate_string (origtype, stream, indent + indent_str.length ());
      stream << " ";
      generate_string (name, stream, indent + indent_str.length ());
      stream << "_orig;	/**< ";
      stream << "@";
      stream << "brief ";
      generate_string (desc, stream, indent + indent_str.length ());
      stream << " original value given at command line.  */";
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      if (flag_arg)
        {
          generate_string (type, stream, indent + indent_str.length ())

          stream << " ";
          generate_string (name, stream, indent + indent_str.length ());
          stream << "_flag;	/**< ";
          stream << "@";
          stream << "brief ";
          generate_string (desc, stream, indent + indent_str.length ());
          stream << " (default=";
          if (default_on)
            {
              stream << "on";
            }
          else
            {
              stream << "off";
            }
          stream << ").  */";
          stream << "\n";
          stream << indent_str;
        }
      else
        {
          if (has_arg)
            {
              if (has_enum)
                {
                  stream << "enum enum_";
                  generate_string (name, stream, indent + indent_str.length ());
                  stream << " ";
                  if (multiple)
                    {
                      stream << "*";
                    }
                  generate_string (name, stream, indent + indent_str.lengt

                  stream << "_arg;	/**< ";
                  stream << "@";
                  stream << "brief ";
                  generate_string (desc, stream, indent + indent_str.length ());
                  if (has_default)
                    {
                      stream << " (default='";
                      generate_string (default_value, stream, indent + indent_str.length ());
                      stream << "')";
                    }
                  stream << ".  */";
                  stream << "\n";
                  stream << indent_str;
                }
              else
                {
                  generate_string (type, stream, indent + indent_str.length ());
                  stream << " ";
                  generate_string (name, stream, indent + indent_str.length ());
                  stream << "_arg;	/**< ";
                  stream << "@";
                  stream << "brief ";
                  generate_string (desc, stream, indent + indent_str.le

                  if (has_default)
                    {
                      stream << " (default='";
                      generate_string (default_value, stream, indent + indent_str.length ());
                      stream << "')";
                    }
                  stream << ".  */";
                  stream << "\n";
                  stream << indent_str;
                }
              generate_string (origtype, stream, indent + indent_str.length ());
              stream << " ";
              generate_string (name, stream, indent + indent_str.length ());
              stream << "_orig;	/**< ";
              stream << "@";
              stream << "brief ";
              generate_string (desc, stream, indent + indent_str.length ());
              stream << " original value given at command line.  */";
              stream << "\n";
              stream << indent_str;
            }
        }
    }
  if (multiple)
    {
      stream << "unsigned int ";
      generate_string (n
namespace three {
  Frustum::Frustum()
  {
  }
  Frustum::Frustum(Matrix4 const& modelViewProjection)
  {
    setFromMatrix(modelViewProjection);
  }
  void Frustum::setFromMatrix(Matrix4 const& modelViewProjection)
  {
    planes[0].x = modelViewProjection[3]  + modelViewProjection[0];
    planes[0].y = modelViewProjection[7]  + modelViewProjection[4];
    planes[0].z = modelViewProjection[11] + modelViewProjection[8];
    planes[0].w = modelViewProjection[15] + modelViewProjection[12];
    planes[1].x = modelViewProjection[3]  - modelViewProjection[0];
    planes[1].y = modelViewProjection[7]  - modelViewProjection[4];
    planes[1].z = modelViewProjection[11] - modelViewProjection[8];
    planes[1].w = modelViewProjection[15] - modelViewProjection[12];
    planes[2].x = modelViewProjection[3]  + modelViewProjection[1];
    planes[2].y = modelViewProjection[7]  + modelViewProjection[5];
    planes[2].z = modelViewProjection[11] + modelViewProjection[9];
    planes[2].w = modelViewPro

    planes[3].x = modelViewProjection[3]  - modelViewProjection[1];
    planes[3].y = modelViewProjection[7]  - modelViewProjection[5];
    planes[3].z = modelViewProjection[11] - modelViewProjection[9];
    planes[3].w = modelViewProjection[15] - modelViewProjection[13];
    planes[4].x = modelViewProjection[3]  + modelViewProjection[2];
    planes[4].y = modelViewProjection[7]  + modelViewProjection[6];
    planes[4].z = modelViewProjection[11] + modelViewProjection[10];
    planes[4].w = modelViewProjection[15] + modelViewProjection[14];
    planes[5].x = modelViewProjection[3]  - modelViewProjection[2];
    planes[5].y = modelViewProjection[7]  - modelViewProjection[6];
    planes[5].z = modelViewProjection[11] - modelViewProjection[10];
    planes[5].w = modelViewProjection[15] - modelViewProjection[14];
    for (uint32_t i = 0; i < 6; ++i)
    {
      const float length = 1.0f / sqrtf(planes[i].x * planes[i].x + planes[i].y * planes[i].y + planes[i].z * planes[i].z);
      plane
struct VirtActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct VirtFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct VirtActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R, typename

struct VirtFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct VirtActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct VirtFuncInvoker2
	typedef R (*Func)(void*, T1, T2, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((F

	}
};
template <typename T1, typename T2, typename T3>
struct VirtActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct VirtFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct VirtActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke (Il2Cp

	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct VirtFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)i

	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct VirtActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, 

struct VirtFuncInvoker6
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct VirtActionInvoker7
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6

struct VirtFuncInvoker7
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct VirtActionInvoker8
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, T8, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typenam

struct VirtFuncInvoker8
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, T8, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct VirtActionInvoker9
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, T8, T9, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, p9, invokeData.method);
	}
};
template <ty

struct VirtActionInvoker10
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct VirtActionInvoker13
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtu
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
Listener::Listener(Log::Channel channel)
    : repoManChannel(channel)
    RM::Events::addReceiver(this);
Listener::~Listener()
    RM::Events::delReceiver(this);
void Listener::repositoryOpened(RM::Repo* repo)
    Log::Event e = Log::Event::create(TMPL_REPO_ACTIVITY);
    Q_ASSERT(e);
    e.setParam(QStr

    e.setParam(QStringLiteral("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::repositoryAboutToClose(RM::Repo* repo)
    Log::Event e = Log::Event::create(TMPL_REPO_ACTIVITY);
    Q_ASSERT(e);
    e.setParam(QStringLiteral("Action"),     tr("closed"));
    e.setParam(QStringLiteral("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::repositoryActivated(RM::Repo* repo)
    Log::Event e = Log::Event::create(TMPL_REPO_ACTIVITY);
    Q_ASSERT(e);
    e.setParam(QStringLiteral("Action"),     tr("activated"));
    e.setParam(QStringLiteral("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::repositoryDeactivated(RM::Repo* repo)
void Listener::objectCreated(RM::Repo* repo, RM::Base* object)
void Listener::objectAboutToBeDeleted(RM::Repo* repo, RM::Base* object)
void Listener::refTreeNodeCreated(RM::Repo* repo, RM::RefTreeNode* node)
void Listener::refTreeNodeAboutToBeDeleted(RM::Repo* repo,

void Listener::refCreated(RM::Repo* repo, RM::Ref* ref)
void Listener::refAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref)
void Listener::refMoved(RM::Repo* repo, RM::Ref* ref)
void Listener::refHeadDetached(RM::Repo* repo, RM::Ref* ref)
void Listener::tagCreated(RM::Repo* repo, RM::Tag* tag)
    Log::Event e = Log::Event::create(TMPL_FOUND_NEW_REF);
    Q_ASSERT(e);
    e.setParam(QStringLiteral("Type"),       tr("tag"));
    e.setParam(QStringLiteral("ObjName"),    tag->displayName());
    e.setParam(QStringLiteral("SHA"),        tag->displaySha1());
    e.setParam(QStringLiteral("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::tagAboutToBeDeleted(RM::Repo* repo, RM::Tag* tag)
void Listener::branchCreated(RM::Repo* repo, RM::Branch* branch)
void Listener::branchAboutToBeDeleted(RM::Repo* repo, RM::Branch* branch)
void Listener::branchMoved(RM::Repo* repo, RM::Branch* branch)
    Log::Event e = Log::Event::create(TMPL_BRANCH_MOVED);
    Q_ASSERT(e);


    e.setParam(QStringLiteral("SHA"),        branch->displaySha1());
    e.setParam(QStringLiteral("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::branchUpstreamChanged(RM::Repo* repo, RM::Branch* branch)
void Listener::namespaceCreated(RM::Repo* repo, RM::Namespace* nameSpace)
void Listener::namespaceAboutToBeDeleted(RM::Repo* repo, RM::Namespace* nameSpace)
void Listener::refLogChanged(RM::Repo* repo, RM::RefLog* reflog)
void Listener::refLogNewEntry(RM::Repo* repo, RM::RefLog* reflog)
void Listener::stageCreated(RM::Repo* repo, RM::Ref* ref)
void Listener::stageAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref)
void Listener::remoteCreated(RM::Repo* repo, RM::Remote* remote)
void Listener::remoteAboutToBeDeleted(RM::Repo* repo, RM::Remote* remote)
void Listener::remoteModified(RM::Repo* repo, RM::Remote* remote)
void Listener::submoduleCreated(RM::Repo* repo, RM::Submodule* submodule)
    Log::Event e = Log::Event::create(TMPL_FOUND_NEW_SM);
    Q_A
namespace skia {
SkiaMemoryDumpProvider* SkiaMemoryDumpProvider::GetInstance() {
  return base::Singleton<
      SkiaMemoryDumpProvider,
      base::LeakySingletonTraits<SkiaMemoryDumpProvider>>::get();
SkiaMemoryDumpProvider::SkiaMemoryDumpProvider() {}
SkiaMemoryDumpProvider::~SkiaMemoryDumpProvider() {}
bool SkiaMemoryDumpProvider::OnMemoryDump(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* process_memory_dump) {
  if (args.level_of_detail ==
      base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND) {
    auto* glyph_cache_dump =
        process_memory_dump->CreateAllocatorDump("skia/sk_glyph_cache");
    glyph_cache_dump->AddScalar(
        base::trace_event::MemoryAllocatorDump::kNameSize,
        base::trace_event::MemoryAllocatorDump::kUnitsBytes,
        SkGraphics::GetFontCacheUsed());
    auto* resource_cache_dump =
        process_memory_dump->CreateAllocatorDump("skia/sk_resource_cache");
    resource_cache_dump->AddScalar(
/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 */
using std::string;
using std::ostream;
class genstringfun_lua_gen_class
 protected:
 public:
  genstringfun_lua_gen_class()
  {
  }
  
  void generate_genstringfun_lua(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "\n";
    stream << indent_str;
    stream << "function strchr_tab(tab, char)";
    stream << "\n";
    stream << indent_str;
    stream << "  local store";
    stream << "\n";
    stream << indent_str;
    stream << "  local ret_str = \"\"";
    stream << "\n";
    stream << indent_str;
    stream << "  for w, k in ipairs(tab) do";
    stream << "\n";
    stream << indent_str;
    stream << "    if(k == char) then";
    stream << "\n";
    stream << indent_str;
    stream << "      store = w";
    stream << "\n";
    stream << indent_str;
    stream << "      break";
    stream << "\n";
    stream << indent_str;
    stream << "

    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  if(store == nil) then";
    stream << "\n";
    stream << indent_str;
    stream << "    return nil";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    ret_str = ret_str .. tab[i]";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  return store, ret_str";
    stream << "\n";
    stream << indent_str;
    stream << "end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "function str_to_tab(str)";
    stream << "\n";
    stream << indent_str;
    stream << "  tab = {}";
    stream << "\n";
    stream << indent_str;
    stream << "  for i in string.gmatch(str, \".\") do";
    stream << "\n";
 

    stream << "    table.insert(tab, i)";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  return tab";
    stream << "\n";
    stream << indent_str;
    stream << "end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "function generate_string(s, stream, indent)";
    stream << "\n";
    stream << indent_str;
    stream << "  local subs = s";
    stream << "\n";
    stream << indent_str;
    stream << "  local indent_str = \"\"";
    stream << "\n";
    stream << indent_str;
    stream << "  local id = {}";
    stream << "\n";
    stream << indent_str;
    stream << "  local pos = 0";
    stream << "\n";
    stream << indent_str;
    stream << "  local my_tab = str_to_tab(s)";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  -- save context";
    stream << "\n";
    stream << indent_str

    stream << "  local ctx = io.output()";
    stream << "\n";
    stream << indent_str;
    stream << "  io.output(stream)";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  if((indent == 0) or (strchr_tab(my_tab, \"\\n\") == nil)) then";
    stream << "\n";
    stream << indent_str;
    stream << "    io.write(s)";
    stream << "\n";
    stream << indent_str;
    stream << "    return";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  for i = 1, indent do";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  indent_str = table.concat(id)";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  while(true) do";
    strea

    stream << indent_str;
    stream << "    pos, subs = strchr_tab(str_to_tab(s), '\\n')";
    stream << "\n";
    stream << indent_str;
    stream << "    if(subs == nil) then break end";
    stream << "\n";
    stream << indent_str;
    stream << "    io.write(table.concat(my_tab, \"\", 1, pos))";
    stream << "\n";
    stream << indent_str;
    stream << "    s = subs:sub(2)";
    stream << "\n";
    stream << indent_str;
    stream << "    my_tab = str_to_tab(s)";
    stream << "\n";
    stream << indent_str;
    stream << "    if(s ~= \"\") then";
    stream << "\n";
    stream << indent_str;
    stream << "      io.write(indent_str);";
    stream << "\n";
    stream << indent_str;
    stream << "    end";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  if(s) then";
    stream << "\n";
    stream << indent_str;
    stream << "    io.write(s)";
    stream << "\n";
    stream << indent_str;
    st
namespace mU {
namespace Function {
FUNCTION_API var Factorial(uint);
FUNCTION_API var Binomial(Var,uint);
FUNCTION_API var Binomial(Var,uint);
FUNCTION_API var Fibonacci(uint);
FUNCTION_API var Lucas(uint);
FUNCTION_API var Euler();
FUNCTION_API var Catalan();
FUNCTION_API var Log(Var);
FUNCTION_API var Log2(Var);
FUNCTION_API var Log10(Var);
FUNCTION_API var Exp(Var);
FUNCTION_API var Exp2(Var);
FUNCTION_API var Exp10(Var);
FUNCTION_API var Cos(Var);
FUNCTION_API var Sin(Var);
FUNCTION_API var Tan(Var);
FUNCTION_API var Sec(Var);
FUNCTION_API var Csc(Var);
FUNCTION_API var Cot(Var);
FUNCTION_API var Acos(Var);
FUNCTION_API var Asin(Var);
FUNCTION_API var Atan(Var);
FUNCTION_API var Cosh(Var);
FUNCTION_API var Sinh(Var);
FUNCTION_API var Tanh(Var);
FUNCTION_API var Sech(Var);
FUNCTION_API var Csch(Var);
FUNCTION_API var Coth(Var);
FUNCTION_API var Acosh(Var);
FUNCTION_API var Asinh(Var);
FUNCTION_API var Atanh(Var);
FUNCTION_API var Gamma(Var);
FUNCTION_API var Lngamma(Var);
FUNCTION_
namespace Network
    /**
      * Constructeur sans paramÃ¨tres
      */
    ChunkDataMessage::ChunkDataMessage() :
    AbstractMessage(Network::CHUNKDATA)
    {
    }
    /**
      * Constructeur
      */
    ChunkDataMessage::ChunkDataMessage(const Chunk::Chunk &chunk) :
    AbstractMessage(CHUNKDATA),
    _chunk(chunk)
    {
    }
    /**
      * Renvoie le chunk
      */
    Chunk::Chunk& ChunkDataMessage::getChunk()
    {
        return _chunk;
    }
    /**
      * Renvoie le chunk, surchargÃ© constant
      */
    const Chunk::Chunk& ChunkDataMessage::getChunk() const
    {
        return _chunk;
    }
    /**
      * Envoie le message dans un QDataStream
      */
    QDataStream& operator<<(QDataStream &out, const ChunkDataMessage &m)
    {
        out << m.MAGICNUMBER_CHUNKDATA;
        out << m._chunk;
        return out;
    }
    /**
      * RecupÃ¨re le message d'un QDataStream
      */
    QDataStream& operator>>(QDataStream &in, ChunkDataMessage &m)
    {
        qint32 mag
/* This file is part of the FaCT++ DL reasoner
Copyright (C) 2003-2011 by Dmitry Tsarkov
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
void TBox :: dump ( dumpInterface* dump ) const
	dump->prologue();
	dumpAllRoles(dump);
	for ( c_const_iterator pc = c_begin(); pc != c_end(); ++pc )
		if ( isRelevant(*pc) )
			dumpConcept( dump, *pc );
	f

		if ( isRelevant(*pi) )
			dumpConcept( dump, *pi );
	if ( getTG() != bpTOP )
	{
		dump->startAx (diImpliesC);
		dump->dumpTop();
		dump->contAx (diImpliesC);
		dumpExpression ( dump, getTG() );
		dump->finishAx (diImpliesC);
	}
	dump->epilogue();
void TBox :: dumpConcept ( dumpInterface* dump, const TConcept* p ) const
	dump->startAx (diDefineC);
	dump->dumpConcept(p);
	dump->finishAx (diDefineC);
	if ( p->pBody != bpTOP )
	{
		diAx Ax = p->isNonPrimitive() ? diEqualsC : diImpliesC;
		dump->startAx (Ax);
		dump->dumpConcept(p);
		dump->contAx (Ax);
		dumpExpression ( dump, p->pBody );
		dump->finishAx (Ax);
	}
void TBox :: dumpRole ( dumpInterface* dump, const TRole* p ) const
	if ( p->getId() > 0 || !isRelevant(p->inverse()) )
	{
		const TRole* q = ( p->getId()>0 ? p : p->inverse() );
		dump->startAx (diDefineR);
		dump->dumpRole(q);
		dump->finishAx (diDefineR);
		for ( ClassifiableEntry::const_iterator i = q->told_begin(); i != q->told_end(); ++i )
		{
			dump->startAx (diImplies

			dump->dumpRole(q);
			dump->contAx (diImpliesR);
			dump->dumpRole(static_cast<const TRole*>(*i));
			dump->finishAx (diImpliesR);
		}
	}
	if ( p->isTransitive() )
	{
		dump->startAx (diTransitiveR);
		dump->dumpRole(p);
		dump->finishAx (diTransitiveR);
	}
	if ( p->isTopFunc() )
	{
		dump->startAx (diFunctionalR);
		dump->dumpRole(p);
		dump->finishAx (diFunctionalR);
	}
	if ( p->getBPDomain() != bpTOP )
	{
		dump->startAx (diDomainR);
		dump->dumpRole(p);
		dump->contAx (diDomainR);
		dumpExpression ( dump, p->getBPDomain() );
		dump->finishAx (diDomainR);
	}
	if ( p->getBPRange() != bpTOP )
	{
		dump->startAx (diRangeR);
		dump->dumpRole(p);
		dump->contAx (diRangeR);
		dumpExpression ( dump, p->getBPRange() );
		dump->finishAx (diRangeR);
	}
void TBox :: dumpExpression ( dumpInterface* dump, BipolarPointer p ) const
	fpp_assert ( isValid(p) );
	if ( p == bpTOP )
		return dump->dumpTop();
	if ( p == bpBOTTOM )
		return dump->dumpBottom();
	if ( isNegative(p) )
	{
		dump->startOp

		dumpExpression ( dump, inverse(p) );
		return dump->finishOp (diNot);
	}
	const DLVertex& v = DLHeap [getValue(p)];
	switch ( v.Type() )
	{
	case dtTop:
		return dump->dumpTop();
	case dtName:
		return dump->dumpConcept(static_cast<const TConcept*>(v.getConcept()));
	case dtAnd:
		dump->startOp (diAnd);
		for ( DLVertex::const_iterator q = v.begin(); q != v.end(); ++q )
		{
			if ( q != v.begin() )
				dump->contOp (diAnd);
			dumpExpression ( dump, *q );
		}
		dump->finishOp (diAnd);
		return;
	case dtForall:
		dump->startOp (diForall);
		dump->dumpRole (v.getRole());
		dump->contOp(diForall);
		dumpExpression ( dump, v.getC() );
		dump->finishOp (diForall);
		return;
	case dtLE:
		dump->startOp ( diLE, v.getNumberLE() );
		dump->dumpRole (v.getRole());
		dump->contOp(diLE);
		dumpExpression ( dump, v.getC() );
		dump->finishOp (diLE);
		return;
	default:
		std::cerr << "Error dumping vertex of type " << v.getTagName() << "(" << v.Type () << ")";
		fpp_unreachable();
	}
void TBox :

	RoleMaster::const_iterator p;
	for ( p = ORM.begin(); p != ORM.end(); ++p )
		if ( isRelevant(*p) )
		{
			fpp_assert ( !(*p)->isSynonym() );
			dumpRole ( dump, *p );
		}
	for ( p = DRM.begin(); p != DRM.end(); ++p )
		if ( isRelevant(*p) )
		{
			fpp_assert ( !(*p)->isSynonym() );
			dumpRole ( dump, *p );
		}
void dumpCExpression ( dumpInterface* dump, const DLTree* C )
	if ( C == NULL )
		return;
	Token t = C->Element().getToken();
	diOp tag;
	switch (t)
	{
	case TOP:
		return dump->dumpTop();
	case BOTTOM:
		return dump->dumpBottom();
	case CNAME:
	case INAME:
		return dump->dumpConcept(static_cast<TConcept*>(C->Element().getNE()));
	case NOT:
		dump->startOp(diNot);
		dumpCExpression ( dump, C->Left() );
		return dump->finishOp(diNot);
	case AND:
	case OR:
		tag = t == AND ? diAnd : diOr;
		dump->startOp(tag);
		dumpCExpression ( dump, C->Left() );
		dump->contOp(tag);
		dumpCExpression ( dump, C->Right() );
		return dump->finishOp(tag);
	case EXISTS:
	case FORALL:
	case LE:
	c
class qMRMLListWidgetPrivate: public qCTKPrivate<qMRMLListWidget>
public:
  QCTK_DECLARE_PUBLIC(qMRMLListWidget);
  void init();
};
void qMRMLListWidgetPrivate::init()
  QCTK_P(qMRMLListWidget);
  
  qMRMLSceneModel* sceneModel = new qMRMLSceneModel(p);
  qMRMLTransformProxyModel* transformModel = new qMRMLTransformProxyModel(p);
  transformModel->setSourceModel(sceneModel);
  QSortFilterProxyModel* sortModel = new QSortFilterProxyModel(p);
  sortModel->setSourceModel(transformModel);
  sortModel->setDynamicSortFilter(true);
  p->QListView::setModel(sortModel);
  p->setWrapping(true);
  p->setResizeMode(QListView::Adjust);
  p->setFlow(QListView::TopToBottom);
  new qCTKModelTester(transformModel,p);
qMRMLListWidget::qMRMLListWidget(QWidget *_parent)
  :QListView(_parent)
  QCTK_INIT_PRIVATE(qMRMLListWidget);
  qctk_d()->init();
qMRMLListWidget::~qMRMLListWidget()
void qMRMLListWidget::setMRMLScene(vtkMRMLScene* scene)
  QSortFilterProxyModel* sortModel = qobject_cast<QSortFilterProxyM
static ELEMDESC s_mElemDesc[] = 
	{{{NULL}, VT_VARIANT}, {NULL, 0x11}},
	{{{NULL}, VT_VARIANT}, {NULL, 0x1}},
	{0}
};
static CBTypeInfo::METHOD_ENTRY s_mData[] =
	{L"Item", {0x00000000, NULL, &s_mElemDesc[0], FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 1, 1, 28, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"HasKeys", {0x60020001, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 32, 0, {{{NULL}, VT_BOOL}}, 0}},
	{L"_NewEnum", {0xFFFFFFFC, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 36, 0, {{{NULL}, VT_UNKNOWN}}, 1}},
	{L"Count", {0x60020003, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 40, 0, {{{NULL}, VT_I4}}, 0}},
	{L"Key", {0x60020004, NULL, &s_mElemDesc[1], FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 1, 0, 44, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"Items", {0x60020005, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 48, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"Keys", {0x60020006, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTY

};
static HRESULT _Invoke(PVOID pvInstance, MEMBERID memid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult)
	IReadCookie* pObject = (IReadCookie*)pvInstance;
	HRESULT hr;
	UINT cArgs = pDispParams->cArgs;
	UINT cArgs1 = cArgs - pDispParams->cNamedArgs;
	hr;cArgs;cArgs1;
	{
		if(cArgs1 > 1)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_OPT(VT_VARIANT, 0)
		INVOKE_PARAM_RET(VT_VARIANT, 1)
		hr = pObject->get_Item(v0, v1);
		INVOKE_DISP_PUT(1);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_RET(VT_BOOL, 0)
		hr = pObject->get_HasKeys(v0);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_RET(VT_UNKNOWN, 0)
		hr = pObject->get__NewEnum(v0);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_RET(VT_I4, 0)
		hr = pObject->get_Count(v0);
		return hr;
	}
	{
		if(cArgs1 > 1)
			return DISP_E_BADPARAMCOUNT;
		if(cArgs1 < 1)
			return DISP_E_PARAMNOTOPTIONAL;
		INVOKE_PARAM(VT_VARIANT
/* 
 * File:   Light.cpp
 * Author: brady
 * 
 * Created on February 8, 2011, 11:19 AM
 */
Light::Light() {
    Color = Vector3D(1.0, 1.0, 1.0);
    Origin = Vector3D(0.0, 0.0, 0.0);
    Size = 1.0;
Light::Light(Vector3D origin, Vector3D color)
    Color = Vector3D(color);
    Origin = Vector3D(origin);
    Size = 1.0;
Light::~Light() {
Vector3D Light::GetRandomPoint(Ray& sampleRay, int spp)
    Vector3D Gaze, U, V, W;
    Gaze = sampleRay.GetOrigin() - Origin;
    Gaze.normalize();
    Vector3D up = Vector3D(0.0, 1.0, 0.0);
    W = Gaze * -1.0;
    U = up.cross(W);
    U.normalize();
    V = W.cross(U);
    V.normalize();
    double left, right, top, bottom;
    left = -Size/2;
    right = Size/2;
    top = -Size/2;
    bottom = Size/2;
    double xOff, yOff;
    double sampleXOffset, sampleYOffset;
    int sampleNum = sampleRay.sNum;
    int sampleColumn;
    int sampleRow;
    int sampleRows = sqrt(spp);
    int sampleCols = sampleRows;
    double theta;
    double radius;
    if(sa

    {
        radius = ((double)random()/(double)RAND_MAX)*Size*(.25);
        radius += Size*.75;
       
        xOff = cos(theta)*radius;
        yOff = sin(theta)*radius;
    }
    else
    {
        theta = ((2.0*M_PI)/spp) * sampleNum;
        radius = ((double)random()/(double)RAND_MAX)*Size*.75;
        radius += Size*.25;
        xOff = cos(theta)*radius;
        yOff = sin(theta)*radius;
    }
    /*
    if(sampleNum < 0)
    {
        
        sampleXOffset = (sampleNum % 2 == 0)? 0.0 : 1.0;
        sampleYOffset = (sampleNum <= -3)? 0.0 : 1.0;
        sampleColumn = sampleXOffset*(sampleCols -1);
        sampleRow = sampleYOffset*(sampleRows -1);
        if(sampleNum == -5)
        {
            sampleXOffset = 0.5;
            sampleYOffset = 0.5;
            sampleRow = sampleRows/2 - 1;
            sampleColumn = sampleCols/2 -1;
        }
        
        xOff = left + Size*((sampleColumn + sampleXOffset)/sampleCols);
        yOff = top + Size*((sampleRow + sampleYOffs
namespace factor
struct profiling_sample_count
	fixnum sample_count;
	fixnum gc_sample_count;
	fixnum jit_sample_count;
	fixnum foreign_sample_count;
	fixnum foreign_thread_sample_count;
	profiling_sample_count() :
		sample_count(0),
		gc_sample_count(0),
		jit_sample_count(0),
		foreign_sample_count(0),
		foreign_thread_sample_count(0) {}
	profiling_sample_count(fixnum sample_count,
		fixnum gc_sample_count,
		fixnum jit_sample_count,
		fixnum foreign_sample_count,
		fixnum foreign_thread_sample_count) :
		sample_count(sample_count),
		gc_sample_count(gc_sample_count),
		jit_sample_count(jit_sample_count),
		foreign_sample_count(foreign_sample_count),
		foreign_thread_sample_count(foreign_thread_sample_count) {}
	bool empty() const
	{
		return sample_count
			+ gc_sample_count
			+ jit_sample_count
			+ foreign_sample_count
			+ foreign_thread_sample_count == 0;
	}
	profiling_sample_count record_counts() volatile;
	void clear() volatile;
};
struct profiling_sample
	profiling_sample_co
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
namespace RM
    class Base;
    class Namespace;
    class Repo;
    class Ref;
    class Remote;
    class Submodule;
    class RefTreeNode;
    class RefLog;
    class Branch;
    class Tag;
    class MGV_CORE_API EventsInterface
    {
    public:
        virtual ~EventsInterface() {}
    public:
     

        virtual void repositoryAboutToClose(Repo* repo) = 0;
        virtual void repositoryActivated(Repo* repo) = 0;
        virtual void repositoryDeactivated(Repo* repo) = 0;
        virtual void objectCreated(Repo* repo, Base* object) = 0;
        virtual void objectAboutToBeDeleted(Repo* repo, Base* object) = 0;
        virtual void refTreeNodeCreated(Repo* repo, RefTreeNode* node) = 0;
        virtual void refTreeNodeAboutToBeDeleted(Repo* repo, RefTreeNode* node) = 0;
        virtual void refCreated(Repo* repo, Ref* ref) = 0;
        virtual void refAboutToBeDeleted(Repo* repo, Ref* ref) = 0;
        virtual void refMoved(Repo* repo, Ref* ref) = 0;
        virtual void refHeadDetached(Repo* repo, Ref* ref) = 0;
        virtual void tagCreated(Repo* repo, Tag* tag) = 0;
        virtual void tagAboutToBeDeleted(Repo* repo, Tag* tag) = 0;
        virtual void branchCreated(Repo* repo, Branch* branch) = 0;
        virtual void branchAboutToBeDeleted(Repo* repo, Branch* branch) = 0

        virtual void branchMoved(Repo* repo, Branch* branch) = 0;
        virtual void branchUpstreamChanged(Repo* repo, Branch* branch) = 0;
        virtual void namespaceCreated(Repo* repo, Namespace* nameSpace) = 0;
        virtual void namespaceAboutToBeDeleted(Repo* repo, Namespace* nameSpace) = 0;
        virtual void refLogChanged(Repo* repo, RefLog* reflog) = 0;
        virtual void refLogNewEntry(Repo* repo, RefLog* reflog) = 0;
        virtual void stageCreated(Repo* repo, Ref* ref) = 0;
        virtual void stageAboutToBeDeleted(Repo* repo, Ref* ref) = 0;
        virtual void remoteCreated(Repo* repo, Remote* remote) = 0;
        virtual void remoteAboutToBeDeleted(Repo* repo, Remote* remote) = 0;
        virtual void remoteModified(Repo* repo, Remote* remote) = 0;
        virtual void submoduleCreated(Repo* repo, Submodule* submodule) = 0;
        virtual void submoduleAboutToBeDeleted(Repo* repo, Submodule* submodule) = 0;
        virtual void submoduleMoved(Repo* repo, S

        virtual void repositoryStateChanged(Repo* repo) = 0;
        virtual void indexUpdated(Repo* repo) = 0;
        virtual void workTreeUpdated(Repo* repo) = 0;
    };
    {
    private:
        Events();
    public:
        static Events* self();
        static void addReceiver(EventsInterface* ev);
        static void delReceiver(EventsInterface* ev);
    private:
        QSet< EventsInterface* > mEvents;
        static Events* sSelf;
    public:
        void repositoryOpened(Repo* repo);
        void repositoryAboutToClose(Repo* repo);
        void repositoryActivated(Repo* repo);
        void repositoryDeactivated(Repo* repo);
        void objectCreated(Repo* repo, Base* object);
        void objectAboutToBeDeleted(Repo* repo, Base* object);
        void refTreeNodeCreated(Repo* repo, RefTreeNode* node);
        void refTreeNodeAboutToBeDeleted(Repo* repo, RefTreeNode* node);
        void refCreated(Repo* repo, Ref* ref);
        void refAboutToBeDeleted(Repo* repo, Ref* ref)

        void refMoved(Repo* repo, Ref* ref);
        void refHeadDetached(Repo* repo, Ref* ref);
        void tagCreated(Repo* repo, Tag* tag);
        void tagAboutToBeDeleted(Repo* repo, Tag* tag);
        void branchCreated(Repo* repo, Branch* branch);
        void branchAboutToBeDeleted(Repo* repo, Branch* branch);
        void branchMoved(Repo* repo, Branch* branch);
        void branchUpstreamChanged(Repo* repo, Branch* branch);
        void namespaceCreated(Repo* repo, Namespace* nameSpace);
        void namespaceAboutToBeDeleted(Repo* repo, Namespace* nameSpace);
        void refLogChanged(Repo* repo, RefLog* reflog);
        void refLogNewEntry(Repo* repo, RefLog* reflog);
        void stageCreated(Repo* repo, Ref* ref);
        void stageAboutToBeDeleted(Repo* repo, Ref* ref);
        void remoteCreated(Repo* repo, Remote* remote);
        void remoteAboutToBeDeleted(Repo* repo, Remote* remote);
        void remoteModified(Repo* repo, Remote* remote);
        void submoduleC
class RepoMonitor : public Thread
public:
    RepoMonitor() : Thread() {
    }
    /*
     * Update repository information and return thre repoId, otherwise empty 
     * string.
     */
    void updateRepo(const string &path) {
        RepoControl repo = RepoControl(path);
        RepoInfo info;
        try {
            repo.open();
        } catch (SystemException &e) {
            WARNING("Failed to open repository %s: %s", path.c_str(), e.what());
            return;
        }
        RWKey::sp key = infoLock.writeLock();
        if (myInfo.hasRepo(repo.getUUID())) {
            info = myInfo.getRepo(repo.getUUID());
        } else {
            info = RepoInfo(repo.getUUID(), repo.getPath());
        }
        info.updateHead(repo.getHead());
        myInfo.updateRepo(repo.getUUID(), info);
        LOG("Checked %s: %s %s", path.c_str(), repo.getHead().c_str(), repo.getUUID().c_str());
        
        repo.close();
        return;
    }
    void run() {
        list<string> repos
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
using namespace repo::worker;
RepoMultithreader::~RepoMultithreader()
    cancelAllThreads();
bool RepoMultithreader::cancelAllThreads()
    mutex.emitCancelSignal();
void RepoMultithreader::connectWorker(
        const RepoAbstractWorker *worker,
        QProgressBar *progressBar)
    if (worker)
    {
        QObject::connect(
                    &mutex, &RepoMutex::

                    worker, &repo::worker::RepoAbstractWorker::cancel,
                    Qt::DirectConnection);
        QObject::connect(
                    worker, &RepoAbstractWorker::finished,
                    &mutex, &RepoMutex::unlockSlot);
        if (progressBar)
        {
            QObject::connect(
                        worker, &repo::worker::RepoAbstractWorker::progressRangeChanged,
                        progressBar, &QProgressBar::setRange);
            QObject::connect(
                        worker, &repo::worker::RepoAbstractWorker::progressValueChanged,
                        progressBar, &QProgressBar::setValue);
            QObject::connect(
                        worker, &repo::worker::RepoAbstractWorker::finished,
                        progressBar, &QProgressBar::hide);
            progressBar->show();
        }
    }
void RepoMultithreader::connectAndStartWorker(
        RepoAbstractWorker *worker,
        QProgressBar *progressBar)
    connectWork
using namespace std;
using namespace sf;
using namespace tgui;
namespace kg
	std::string Chunk::getChunkSavename( const ChunkPosition& chunkPosition )
	{
	}
	bool Chunk::operator==( const Chunk& rhs ) const
	{
		return m_position == rhs.m_position;
	}
	Chunk::Chunk( const ChunkPosition& position )
		:m_position( position )
	{ }
	const ChunkPosition& Chunk::getPosition() const
	{
		return m_position;
	}
	void Chunk::addEntity( Entity* entity )
	{
		if( calculateChunkPositionForPosition2d( entity->getComponent<Transformation>()->getPosition() ) != m_position )
			throw exception();
		if( m_position == Position2d( 0, 0, 0 ) )
			int a = 0;
		auto transformationComponent = entity->getComponent<Transformation>();
		transformationComponent->setChunkPostion( m_position );
		m_entities.push_back( entity );
	}
	void Chunk::removeEntity( Entity* entity )
	{
		auto transformationComponent = entity->getComponent<Transformation>();
		m_entities.erase( std::remove( m_entities.begin(), m_entities.end
std::vector<Chunk*> Chunk::chunks;
unsigned int Chunk::next_chunk = CHUNK_ALLOC_SIZE;
unsigned int Chunk::allocated = 0;
Chunk::Chunk(World *world, signed int x, signed int y)
    : x(x)
    , y(y)
    world->initialize_chunk(this);
Chunk *Chunk::neighbor(World *world, Direction i)
    if (neighbors[i]) {return neighbors[i];}
    signed int tcx = x;
    signed int tcy = y;
    switch (i)
    {
    case up:
        tcy -= CHUNK_SIZE; break;
    case down:
        tcy += CHUNK_SIZE; break;
    case left:
        tcx -= CHUNK_SIZE; break;
    case right:
        tcx += CHUNK_SIZE; break;
    }
    Chunk *chunk = find_chunk(tcx, tcy);
    if (chunk)
    {
        chunk->neighbors[i ^ 1] = this;
    }
    else
    {
        chunk = new Chunk(world, tcx, tcy);
        chunk->neighbors[i ^ 0] = 0;
        chunk->neighbors[i ^ 1] = this;
        chunk->neighbors[i ^ 2] = 0;
        chunk->neighbors[i ^ 3] = 0;
    }
    neighbors[i] = chunk;
    return chunk;
Chunk *Chunk::find_chunk(signed in
namespace tiki
	struct Chunk;
	typedef uint8 ChunkTypeId;
	enum
	{
		InvalidChunkTypeId = 0xffu
	};
	struct ChunkState
	{
		ChunkTypeId		typeId;
		ChunkState*		pPrevStateOfSameType;
		ChunkState*		pNextStateOfSameType;
	};
	struct ChunkStorageParameters
	{
		ChunkStorageParameters()
		{
			chunkSize		= 4096u;
			chunkAlignment	= TIKI_DEFAULT_ALIGNMENT;
			chunkCount		= 32u;
			typeCount		= 32u;
		}
		uint chunkSize;
		uint chunkAlignment;
		uint chunkCount;
		uint typeCount;
	};
	class ChunkStorage
	{
		TIKI_NONCOPYABLE_CLASS( ChunkStorage );
	public:
								ChunkStorage();
								~ChunkStorage();
		bool					create( const ChunkStorageParameters& parameters );
		void					dispose();
		ChunkTypeId				registerType( uint stateSize );
		void					unregisterType( ChunkTypeId typeId );
		ChunkState*				allocateState( ChunkTypeId typeId );
		void					freeState( ChunkState* pState );
	private:
		
		Array< uint >			m_typeRegister;
		uint					m_chunkSize;
		Array< uint8 >			m_memory;
		Array< Chu
namespace Earlgrey
	namespace Test
	{	
		void Dump(LPEXCEPTION_POINTERS exceptionPtr)
		{
			const xwstring baseDir = Environment::BaseDirectoryW();
			const xwstring dumpFilePath( Path::Combine(baseDir, L"MiniDumpTest.dmp") );
			if( File::Exists(dumpFilePath.c_str()) )
			{
				ASSERT_TRUE2(File::Delete(dumpFilePath));
			}
			const MINIDUMP_TYPE dumpType = MiniDumpNormal;
			MiniDump miniDump(dumpFilePath.c_str(), dumpType);
			miniDump.AddExtendedMessage(
				static_cast<MINIDUMP_STREAM_TYPE>(LastReservedStream + 1)
				, L"ì¬ì©ì ì ë³´ 1"
				);
			miniDump.HandleException(exceptionPtr);	
			ASSERT_TRUE2( File::Exists(dumpFilePath) );
		}
		void WriteSummary(LPEXCEPTION_POINTERS exceptionPtr)
		{
			const xwstring baseDir = Environment::BaseDirectoryW();
			const xwstring dumpFilePath( Path::Combine(baseDir, L"MiniDumpTest.txt") );
			if( File::Exists(dumpFilePath.c_str()) )
			{
				File::Delete( dumpFilePath );
			}
			StackWriter sw(dumpFilePath.c_str(), StackWalker::OptionsAll);
			
extern bool SortObjectsPredicate(const Object* o1, const Object* o2);
extern Engine* engine;
Object::Object() {
	locked=false;
	visible=true;
	solid=false;
	depth=0;
	chunk.x=0;
	chunk.y=0;
	objectIndex=0;
	canMove=true;
	isMoving=false;
	isControlled=false;
	isBlocked=false;
	active=true;
	objectName="none";
};
Object::~Object() {
};
bool Object::SetBBox(int left, int top, int width, int height) {
	bBox.left=left;
	bBox.top=top;
	bBox.width=width;
	bBox.height=height;
	return true;
};
sf::Rect<sf::Int16> Object::GetBBox() {
	return bBox;
};
void Object::Lock() {
	locked=true;
};
void Object::Unlock() {
	locked=false;
};
void Object::SetPosition(float xx, float yy) {
	x=xx;
	y=yy;
	xPrev=x;
	yPrev=y;
};
void Object::MoveToChunk() {
	int chunkX = floor(x/engine->objectsManager->chunkSize.x);
	int chunkY = floor(y/engine->objectsManager->chunkSize.y);
	chunkX = std::max(0,chunkX);
	chunkY = std::max(0,chunkY);
	chunkX = std::min(chunkX,engine->objectsManager->chunksNumber.x);
	chunkY = s
using std::stringstream;
namespace tut
/**
 * Testing reporter.
 */
struct reporter_test
    test_result tr1;
    test_result tr2;
    test_result tr3;
    test_result tr4;
    test_result tr5;
    test_result tr6;
    test_result tr7;
    test_result tr8;
    reporter_test()
        : tr1("foo", 1, "", test_result::ok),
          tr2("foo", 2, "", test_result::fail),
          tr3("foo", 3, "", test_result::ex),
          tr4("foo", 4, "", test_result::warn),
          tr5("foo", 5, "", test_result::term),
          tr6("foo", 6, "", test_result::skipped),
          tr7("foo", 7, "", test_result::ex_ctor),
          tr8("foo", 8, "", test_result::rethrown)
    {
    }
    virtual ~reporter_test()
    {
    }
};
typedef test_group<reporter_test> tg;
typedef tg::object object;
tg reporter_test("default reporter");
template<>
template<>
void object::test<1>()
    stringstream ss;
    ss << tr1 << tr2 << tr3 << tr4 << tr5 << tr6 << tr7 << tr8;
    ensure_equals("operator << formatter", ss

    ensure_THROW( ss << test_result("foo", 9, "", test_result::dummy), tut_error );
template<>
template<>
void object::test<2>()
    stringstream ss;
    console_reporter repo(ss);
    ensure_equals("ok count", repo.ok_count, 0);
    ensure_equals("fail count", repo.failures_count, 0);
    ensure_equals("ex count", repo.exceptions_count, 0);
    ensure_equals("warn count", repo.warnings_count, 0);
    ensure_equals("term count", repo.terminations_count, 0);
    ensure_equals("skip count", repo.skipped_count, 0);
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.test_completed(tr2);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    rep

    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.run_completed();
    ensure_equals("ok count", repo.ok_count, 1);
    ensure_equals("fail count", repo.failures_count, 2);
    ensure_equals("ex count", repo.exceptions_count, 3);
    ensure_equals("warn count", repo.warnings_count, 4);
    ensure_equals("term count", repo.terminations_count, 5);
    ensure_equals("skip count", repo.skipped_count, 6);
    ensure(!repo.all_ok());
template<>
template<>
void object::test<3>()
    std::stringstream ss;
    tut::console_reporter repo(ss);
    repo.run_started();
    repo.test_completed(tr1);
    repo.run_completed();
    ensure_equals("ok count",repo.ok_count,1);
    ensure(repo.all_ok());
    repo.run_started();
    ensure_equals("ok count",repo.ok_count,0);
template<>
template<>
void object::test<4>()
    stringstream ss;
    console_reporter repo(ss);
    repo.run_started();
    r

    repo.run_completed();
    ensure(repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr3);
    repo.test_completed(tr1);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr4);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr5);
    repo.test_completed(tr1);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr6);
    repo.run_completed();
    ensure(repo.all_ok());
template<>
template<>
void object::test<5>()
    stringstream ss;
    console_reporter repo(ss);
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr3);
    repo.test_completed(tr6);
    repo.run_completed();
    std::string outp

    std::string format = "\nfoo: .[3=X][6=S]\n\n---> group: foo, test: test<3>\n     problem: unexpected exception\n\n"
                         "tests summary: exceptions:1 ok:1 skipped:1\n";
    ensure_equals("output formatting mismatch", output.begin(), output.end(), format.begin(), format.end());
template<>
template<>
void object::test<6>()
    stringstream ss;
    console_reporter repo(ss);
    test_result trex("foo", 9, "", test_result::ex);
    trex.exception_typeid = "foobar";
    test_result trmsg("foo", 10, "", test_result::warn);
    trmsg.message = "barqux";
    test_result trfail("bar", 11, "", test_result::fail);
    trfail.message = "bazquz";
    repo.run_started();
    repo.test_completed(tr8);
    repo.test_completed(trex);
    repo.test_completed(trmsg);
    repo.test_completed(trfail);
    repo.run_completed();
    std::string output = ss.str();
    std::string format =
        "\n"
        "foo: [8=P][9=X][10=W]\n"
        "bar: [11=F]\n\n"
        "---> group: foo
void GeoTif_Scale(float* OriginDepth , int OriginW , int OriginH , float* NewDepth , int imageWidth , int imageHeight)
    float xfactor = ((float) (OriginW  - 1)) / 1025.0f;
    float yfactor = ((float) (OriginH - 1)) / 1025.0f;
    uint32 px , py;
    uint32 sample_x[2];
    uint32 sample_y[2];
    for ( int y = 0 ; y < imageHeight ; ++y )
    {
        for ( int x = 0 ; x < imageWidth ; ++x )
        {
            float fx = x * xfactor;
            float fy = y * yfactor;
            px = fx;     py = fy;
            if(px > fx) { sample_x[0] = px - 1 ; sample_x[1] = px    ; } 
            else        { sample_x[0] = px     ; sample_x[1] = px + 1; }
            if(py > fy) { sample_y[0] = py - 1 ; sample_y[1] = py    ; } 
            else        { sample_y[0] = py     ; sample_y[1] = py + 1; }
           
            float factor_x = sample_x[1] - fx ;
        
            float v1 = OriginDepth[ sample_y[0]*OriginW + sample_x[0] ]  *  factor_x +
                       OriginDepth[
namespace rubinius {
  CodeManager::Chunk::Chunk(int size)
    : next(0)
  {
    resources = new CodeResource*[size];
    memset(resources, 0, sizeof(CodeResource*) * size);
  }
  CodeManager::Chunk::~Chunk() {
    delete[] resources;
  }
  CodeManager::CodeManager(SharedState* shared, int chunk_size)
    : shared_(shared)
    , chunk_size_(chunk_size)
    , first_chunk_(0)
    , last_chunk_(0)
    , current_chunk_(0)
    , current_index_(0)
    , freed_resources_(0)
    , total_allocated_(0)
    , total_freed_(0)
    , gc_triggered_(0)
    , bytes_used_(0)
  {
    first_chunk_ = new Chunk(chunk_size_);
    last_chunk_ = first_chunk_;
    current_chunk_ = first_chunk_;
  }
  CodeManager::~CodeManager() {
    Chunk* chunk = first_chunk_;
    while(chunk) {
      for(int i = 0; i < chunk_size_; i++) {
        if(CodeResource* cr = chunk->resources[i]) {
          delete cr;
          chunk->resources[i] = 0;
        }
      }
      Chunk* next = chunk->next;
      delete chunk;
      chu

    }
  }
  void CodeManager::add_chunk() {
    Chunk* c = new Chunk(chunk_size_);
    current_index_ = 0;
    last_chunk_->next = c;
    last_chunk_ = c;
    current_chunk_ = c;
  }
  void CodeManager::add_resource(CodeResource* cr, bool* collect_now) {
    utilities::thread::Mutex::LockGuard guard(mutex_);
    total_allocated_ += cr->size();
    bytes_used_ += cr->size();
    if(total_allocated_ - gc_triggered_ > cGCTriggerThreshold) {
      gc_triggered_ = total_allocated_;
      *collect_now = true;
    }
    for(;;) {
      while(current_index_ < chunk_size_) {
        if(current_chunk_->resources[current_index_] == 0) {
          current_chunk_->resources[current_index_] = cr;
          return;
        }
        current_index_++;
      }
      current_index_ = 0;
      current_chunk_ = current_chunk_->next;
      if(!current_chunk_) add_chunk();
    }
  }
  void CodeManager::sweep() {
    Chunk* chunk = first_chunk_;
    Chunk* prev  = NULL;
    freed_resources_ = 0;
    State s

    while(chunk) {
      bool chunk_used = false;
      for(int i = 0; i < chunk_size_; i++) {
        if(CodeResource* cr = chunk->resources[i]) {
          if(!cr->marked()) {
            total_freed_ += cr->size();
            bytes_used_ -= cr->size();
            freed_resources_++;
            cr->cleanup(&state, this);
            delete cr;
            chunk->resources[i] = 0;
          } else {
            chunk_used = true;
            cr->clear_mark();
          }
        }
      }
      if(!chunk_used && prev) {
        prev->next = chunk->next;
        if(last_chunk_ == chunk) {
          last_chunk_ = prev;
        }
        if(current_chunk_ == chunk) {
          current_chunk_ = prev;
        }
        delete chunk;
        chunk = prev->next;
      } else {
        prev = chunk;
        chunk = chunk->next;
      }
    }
  }
  void CodeManager::clear_marks() {
    Chunk* chunk = first_chunk_;
    while(chunk) {
      for(int i = 0; i < chunk_size_; i++) {
        if(C
namespace dart {
class ProfileSampleBufferTestHelper {
 public:
  static intptr_t IterateCount(const Isolate* isolate,
                               const SampleBuffer& sample_buffer) {
    intptr_t c = 0;
    for (intptr_t i = 0; i < sample_buffer.capacity(); i++) {
      Sample* sample = sample_buffer.GetSample(i);
      if (sample->isolate != isolate) {
        continue;
      }
      c++;
    }
    return c;
  }
  static intptr_t IterateSumPC(const Isolate* isolate,
                               const SampleBuffer& sample_buffer) {
    intptr_t c = 0;
    for (intptr_t i = 0; i < sample_buffer.capacity(); i++) {
      Sample* sample = sample_buffer.GetSample(i);
      if (sample->isolate != isolate) {
        continue;
      }
      c += sample->pcs[0];
    }
    return c;
  }
};
TEST_CASE(ProfilerSampleBufferWrapTest) {
  SampleBuffer* sample_buffer = new SampleBuffer(3);
  Isolate* i = reinterpret_cast<Isolate*>(0x1);
  EXPECT_EQ(0, ProfileSampleBufferTestHelper::IterateSumPC(i

  Sample* s;
  s = sample_buffer->ReserveSample();
  s->isolate = i;
  s->pcs[0] = 2;
  EXPECT_EQ(2, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  s = sample_buffer->ReserveSample();
  s->isolate = i;
  s->pcs[0] = 4;
  EXPECT_EQ(6, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  s = sample_buffer->ReserveSample();
  s->isolate = i;
  s->pcs[0] = 6;
  EXPECT_EQ(12, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  s = sample_buffer->ReserveSample();
  s->isolate = i;
  s->pcs[0] = 8;
  EXPECT_EQ(18, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  delete sample_buffer;
TEST_CASE(ProfilerSampleBufferIterateTest) {
  SampleBuffer* sample_buffer = new SampleBuffer(3);
  Isolate* i = reinterpret_cast<Isolate*>(0x1);
  EXPECT_EQ(0, ProfileSampleBufferTestHelper::IterateCount(i, *sample_buffer));
  Sample* s;
  s = sample_buffer->ReserveSample();
  s->isolate = i;
  EXPECT_EQ(1, ProfileSampleBufferTestHelper::Iterate
namespace blink {
WebProcessMemoryDump::WebProcessMemoryDump()
    : owned_process_memory_dump_(new base::trace_event::ProcessMemoryDump(
          nullptr,
          {base::trace_event::MemoryDumpLevelOfDetail::DETAILED})),
      process_memory_dump_(owned_process_memory_dump_.get()),
      level_of_detail_(base::trace_event::MemoryDumpLevelOfDetail::DETAILED) {}
WebProcessMemoryDump::WebProcessMemoryDump(
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : process_memory_dump_(process_memory_dump),
      level_of_detail_(level_of_detail) {}
WebProcessMemoryDump::~WebProcessMemoryDump() {}
blink::WebMemoryAllocatorDump* WebProcessMemoryDump::createMemoryAllocatorDump(
    const String& absolute_name) {
  StringUTF8Adaptor adapter(absolute_name);
  std::string name(adapter.data(), adapter.length());
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocato

  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump* WebProcessMemoryDump::createMemoryAllocatorDump(
    const String& absolute_name,
    blink::WebMemoryAllocatorDumpGuid guid) {
  StringUTF8Adaptor adapter(absolute_name);
  std::string name(adapter.data(), adapter.length());
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocatorDump(
          name, base::trace_event::MemoryAllocatorDumpGuid(guid));
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
WebProcessMemoryDump::createWebMemoryAllocatorDump(
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump) {
  if (!memory_allocator_dump)
    return nullptr;
  WebMemoryAllocatorDump* web_memory_allocator_dump =
      new WebMemoryAllocatorDump(memory_allocator_dump);
  memory_allocator_dumps_.set(memory_allocator_dump,
                              wrapUnique(web_memory_allocator_dump));


blink::WebMemoryAllocatorDump* WebProcessMemoryDump::getMemoryAllocatorDump(
    const String& absolute_name) const {
  StringUTF8Adaptor adapter(absolute_name);
  std::string name(adapter.data(), adapter.length());
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->GetAllocatorDump(name);
  if (!memory_allocator_dump)
    return nullptr;
  blink::WebMemoryAllocatorDump* web_memory_allocator_dump =
      memory_allocator_dumps_.get(memory_allocator_dump);
  DCHECK(web_memory_allocator_dump);
  return web_memory_allocator_dump;
void WebProcessMemoryDump::clear() {
  memory_allocator_dumps_.clear();
  process_memory_dump_->Clear();
void WebProcessMemoryDump::takeAllDumpsFrom(
    blink::WebProcessMemoryDump* other) {
  process_memory_dump_->TakeAllDumpsFrom(other->process_memory_dump_);
  const size_t expected_final_size =
      memory_allocator_dumps_.size() + other->memory_allocator_dumps_.size();
  while (!other->memory_allocator_dumps_.isEm

    auto first_entry = other->memory_allocator_dumps_.begin();
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
        first_entry->key;
    memory_allocator_dumps_.set(
        memory_allocator_dump,
        other->memory_allocator_dumps_.take(memory_allocator_dump));
  }
  DCHECK_EQ(expected_final_size, memory_allocator_dumps_.size());
  DCHECK(other->memory_allocator_dumps_.isEmpty());
void WebProcessMemoryDump::addOwnershipEdge(
    blink::WebMemoryAllocatorDumpGuid source,
    blink::WebMemoryAllocatorDumpGuid target,
    int importance) {
  process_memory_dump_->AddOwnershipEdge(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      base::trace_event::MemoryAllocatorDumpGuid(target), importance);
void WebProcessMemoryDump::addOwnershipEdge(
    blink::WebMemoryAllocatorDumpGuid source,
    blink::WebMemoryAllocatorDumpGuid target) {
  process_memory_dump_->AddOwnershipEdge(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      base::trace_

void WebProcessMemoryDump::addSuballocation(
    blink::WebMemoryAllocatorDumpGuid source,
    const String& target_node_name) {
  StringUTF8Adaptor adapter(target_node_name);
  std::string target_node(adapter.data(), adapter.length());
  process_memory_dump_->AddSuballocation(
      base::trace_event::MemoryAllocatorDumpGuid(source), target_node);
SkTraceMemoryDump* WebProcessMemoryDump::createDumpAdapterForSkia(
    const String& dump_name_prefix) {
  StringUTF8Adaptor adapter(dump_name_prefix);
  std::string prefix(adapter.data(), adapter.length());
  sk_trace_dump_list_.push_back(
      base::WrapUnique(new skia::SkiaTraceMemoryDumpImpl(
          prefix, level_of_detail_, process_memory_dump_)));
  return sk_trace_dump_list_.back().get();
blink::WebMemoryAllocatorDump*
WebProcessMemoryDump::createDiscardableMemoryAllocatorDump(
    const std::string& name,
    base::DiscardableMemory* discardable) {
  base::trace_event::MemoryAllocatorDump* dump =
      discardable->CreateMemoryA
/*
** $Id: ldump.c,v 2.17.1.1 2013/04/12 18:48:47 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size*sizeof(char),D);
 }
static void DumpFunction(const Proto* f, DumpState* D);
static void DumpConstants(const Proto* f, Dum

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttypenv(o),D);
  switch (ttypenv(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
    default: lua_assert(0);
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],D);
static void DumpUpvalues(const Proto* f, DumpState* D)
 int i,n=f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpChar(f->upvalues[i].instack,D);
  DumpChar(f->upvalues[i].idx,D);
 }
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 DumpString((D->strip) ? NULL : f->source,D);
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].
/*
    This file is part of Soupe Au Caillou.
    @author Soupe au Caillou - Jordane Pelloux-Prayer
    @author Soupe au Caillou - Gautier Pelloux-Prayer
    @author Soupe au Caillou - Pierre-Eric Pelloux-Prayer
    Soupe Au Caillou is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3.
    Soupe Au Caillou is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
*/
class AdAPI;
class AssetAPI;
class CommunicationAPI;
class ExitAPI;
class GameCenterAPI;
class InAppPurchaseAPI;
class JoystickAPI;
class KeyboardInputHandlerAPI;
class LocalizeAPI;
class MusicAPI;
class NetworkAPI;
class OpenURLAPI;
class SoundAPI;
class StorageAPI

class StringInputAPI;
class VibrateAPI;
class WWWAPI;
namespace ContextAPI {
    enum Enum {
        Ad,
        Asset,
        Communication,
        Exit,
        GameCenter,
        InAppPurchase,
        Joystick,
        KeyboardInputHandler,
        Localize,
        Music,
        Network,
        OpenURL,
        Sound,
        Storage,
        StringInput,
        Vibrate,
        WWW,
    };
struct GameContext {
    GameContext()
        : adAPI(0), assetAPI(0), communicationAPI(0), exitAPI(0),
          gameCenterAPI(0), inAppPurchaseAPI(0), joystickAPI(0),
          keyboardInputHandlerAPI(0), localizeAPI(0), musicAPI(0),
          networkAPI(0), openURLAPI(0), soundAPI(0), storageAPI(0),
          stringInputAPI(0), vibrateAPI(0), wwwAPI(0) {}
    AdAPI* adAPI;
    AssetAPI* assetAPI;
    CommunicationAPI* communicationAPI;
    ExitAPI* exitAPI;
    GameCenterAPI* gameCenterAPI;
    InAppPurchaseAPI* inAppPurchaseAPI;
    JoystickAPI* joystickAPI;
    KeyboardInputHandler
/*******************************************************************************
* çæææ(C) pyhcx 2009
* æä»¶åç§°	: DumpFile.cpp
* å½åçæ¬	: 1.0.0.1
* ä½    è	: å½­å (pyhcx@foxmail.com)
* è®¾è®¡æ¥æ	: 2009å¹´3æ31æ¥
* åå®¹æè¦	: 
* ä¿®æ¹è®°å½	: 
* æ¥    æ		ç    æ¬		ä¿®æ¹äºº		ä¿®æ¹æè¦
********************************************************************************/
/**************************** æ¡ä»¶ç¼è¯éé¡¹åå¤´æä»¶ ****************************/
/********************************** å®ãå¸¸é **********************************/
/********************************** æ°æ®ç±»å **********************************/
/************************************ åé ************************************/
/********************************** å½æ°å®ç° **********************************/
/*********************************** ç±»å®ç° ***********************************/
CDumpFile::CDumpFile(LPCTSTR ptszFile)
	m_hDumpFile = ::CreateFile(ptszFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
CDumpFile::~CDumpFile(void)
	Close();
BOOL CDumpFile::DumpInfo(PEXCEPTION_PO
namespace Service
	struct WorkerSort 
	{
		bool operator() (IWorker* p_pLeft, IWorker* p_pRight) 
		{ 
			return (p_pLeft->GetPriority() > p_pRight->GetPriority());
		}
	} WorkerSorter;
	CWorkerLocator* CWorkerLocator::m_pInstance = nullptr;
	CWorkerLocator::CWorkerLocator()
	{
	}
	CWorkerLocator::~CWorkerLocator()
	{
		
	}
	CWorkerLocator* CWorkerLocator::GetInstance()
	{
		if(!m_pInstance)
			m_pInstance = new CWorkerLocator();
		return m_pInstance;
	}
	IWorker* CWorkerLocator::GetWorker()
	{
		return GetInstance()->Get();	
	}
	void CWorkerLocator::ProvideWorker(IWorker* p_pWorker)
	{
		GetInstance()->Provide(p_pWorker);
	}
	bool CWorkerLocator::IsWorkDone()
	{
		return GetInstance()->IsDone();
	}
	void CWorkerLocator::Provide(IWorker* p_pService)
	{
		m_vWorkers.push_back(p_pService);
	}
	IWorker* CWorkerLocator::Get()
	{
		std::sort(m_vWorkers.begin(), m_vWorkers.end(), WorkerSorter);
		for(IWorker* pWorker : m_vWorkers)
		{
			if(!pWorker->IsBusy())
				return pWorker;
		}
		retur
namespace base {
namespace trace_event {
const char* MemoryDumpTypeToString(const MemoryDumpType& dump_type) {
  switch (dump_type) {
    case MemoryDumpType::PERIODIC_INTERVAL:
      return "periodic_interval";
    case MemoryDumpType::EXPLICITLY_TRIGGERED:
      return "explicitly_triggered";
    case MemoryDumpType::PEAK_MEMORY_USAGE:
      return "peak_memory_usage";
    case MemoryDumpType::SUMMARY_ONLY:
      return "summary_only";
  }
  NOTREACHED();
  return "unknown";
MemoryDumpType StringToMemoryDumpType(const std::string& str) {
  if (str == "periodic_interval")
    return MemoryDumpType::PERIODIC_INTERVAL;
  if (str == "explicitly_triggered")
    return MemoryDumpType::EXPLICITLY_TRIGGERED;
  if (str == "peak_memory_usage")
    return MemoryDumpType::PEAK_MEMORY_USAGE;
  if (str == "summary_only")
    return MemoryDumpType::SUMMARY_ONLY;
  NOTREACHED();
  return MemoryDumpType::LAST;
const char* MemoryDumpLevelOfDetailToString(
    const MemoryDumpLevelOfDetail& level_of_de
using content::BrowserThread;
BookmarkModelTask::BookmarkModelTask(BookmarkModel* model)
    : model_(model) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(model_);
  model_->BlockTillLoaded();
BookmarkModel* BookmarkModelTask::model() const {
  return model_;
BookmarkModelObserverTask::BookmarkModelObserverTask(
    BookmarkModel* bookmark_model)
    : BookmarkModelTask(bookmark_model) {
  model()->AddObserver(this);
BookmarkModelObserverTask::~BookmarkModelObserverTask() {
  model()->RemoveObserver(this);
void BookmarkModelObserverTask::Loaded(BookmarkModel* model,
                                       bool ids_reassigned) {
void BookmarkModelObserverTask::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
void BookmarkModelObserverTask::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
   
namespace dart {
class ProfileSampleBufferTestHelper {
 public:
  static intptr_t IterateCount(const Isolate* isolate,
                               const SampleBuffer& sample_buffer) {
    intptr_t c = 0;
    for (intptr_t i = 0; i < sample_buffer.capacity(); i++) {
      Sample* sample = sample_buffer.At(i);
      if (sample->isolate() != isolate) {
        continue;
      }
      c++;
    }
    return c;
  }
  static intptr_t IterateSumPC(const Isolate* isolate,
                               const SampleBuffer& sample_buffer) {
    intptr_t c = 0;
    for (intptr_t i = 0; i < sample_buffer.capacity(); i++) {
      Sample* sample = sample_buffer.At(i);
      if (sample->isolate() != isolate) {
        continue;
      }
      c += sample->At(0);
    }
    return c;
  }
};
TEST_CASE(ProfilerSampleBufferWrapTest) {
  SampleBuffer* sample_buffer = new SampleBuffer(3);
  Isolate* i = reinterpret_cast<Isolate*>(0x1);
  EXPECT_EQ(0, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_b

  Sample* s;
  s = sample_buffer->ReserveSample();
  s->Init(i, 0, 0);
  s->SetAt(0, 2);
  EXPECT_EQ(2, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  s = sample_buffer->ReserveSample();
  s->Init(i, 0, 0);
  s->SetAt(0, 4);
  EXPECT_EQ(6, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  s = sample_buffer->ReserveSample();
  s->Init(i, 0, 0);
  s->SetAt(0, 6);
  EXPECT_EQ(12, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  s = sample_buffer->ReserveSample();
  s->Init(i, 0, 0);
  s->SetAt(0, 8);
  EXPECT_EQ(18, ProfileSampleBufferTestHelper::IterateSumPC(i, *sample_buffer));
  delete sample_buffer;
TEST_CASE(ProfilerSampleBufferIterateTest) {
  SampleBuffer* sample_buffer = new SampleBuffer(3);
  Isolate* i = reinterpret_cast<Isolate*>(0x1);
  EXPECT_EQ(0, ProfileSampleBufferTestHelper::IterateCount(i, *sample_buffer));
  Sample* s;
  s = sample_buffer->ReserveSample();
  s->Init(i, 0, 0);
  EXPECT_EQ(1, ProfileSampleBufferTestH
IDataProviderSvc* CkvG4SvcLocator::RichG4detSvc()
{ 
  static IDataProviderSvc* a_detSvc = 0 ;
  if( 0 == a_detSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("RichG4Svclocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service(CkvG4SvcLocator::a_RichG4DataSvcName , a_detSvc, true );
      if( sc.isFailure() ) 
        { throw GaudiException("CkvG4SvcLocator::Could not locate IDataProviderSvc='" 
                               + CkvG4SvcLocator::a_RichG4DataSvcName + "'",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE); }
      if( 0 == a_detSvc ) 
        { throw GaudiException("CkvG4SvcLocator::IDataProviderSvc*(" 
                               +  CkvG4SvcLocator::a_RichG4DataSvcName + 
                               "')

                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      a_detSvc->addRef();
    }
  return a_detSvc ;
IMessageSvc* CkvG4SvcLocator::RichG4MsgSvc ()
  static IMessageSvc* a_msgSvc = 0 ;
  if( 0 == a_msgSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("CkvG4SvcLocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service( CkvG4SvcLocator::a_RichG4MessageSvcName , a_msgSvc, true );
      if( sc.isFailure() ) 
        { throw GaudiException("CkvG4SvcLocator::Could not locate IMessageSvc='" 
                               + CkvG4SvcLocator::a_RichG4MessageSvcName  + "'",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE); }
      if( 0 == a_msgSvc ) 
        { throw GaudiExc

                               +CkvG4SvcLocator::a_RichG4MessageSvcName + 
                               "') points to NULL!" ,
                               "*DetDescException*" , 
                               StatusCode::FAILURE  ); }
      a_msgSvc->addRef();
    }
  return a_msgSvc ;
IHistogramSvc*   CkvG4SvcLocator::RichG4HistoSvc()
  static IHistogramSvc* a_HistoSvc = 0 ;
  if( 0 == a_HistoSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("CkvG4SvcLocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service( CkvG4SvcLocator::a_RichG4HistoSvcName , a_HistoSvc,true  );
      if( sc.isFailure() ) 
        { throw GaudiException("CkvG4SvcLocator::Could not locate IHistogramSvc='" 
                               + CkvG4SvcLocator::a_RichG4HistoSvcName  + "'",
                   

                               StatusCode::FAILURE); }
      if( 0 == a_HistoSvc ) 
        { throw GaudiException("CkvG4SvcLocator::IHistogramSvc*(" 
                               +CkvG4SvcLocator::a_RichG4HistoSvcName + 
                               "') points to NULL!" ,
                               "*DetDescException*" , 
                               StatusCode::FAILURE  ); }
      a_HistoSvc->addRef();
    }
  return a_HistoSvc ;
INTupleSvc*   CkvG4SvcLocator::RichG4NtupleSvc()
  static INTupleSvc* a_NtupleSvc = 0 ;
  if( 0 == a_NtupleSvc ) 
    {
      ISvcLocator* svcLoc = Gaudi::svcLocator();
      if( 0 == svcLoc ) 
        { throw GaudiException("CkvG4SvcLocator::ISvcLocator* points to NULL!",
                               "*RichG4Exception*" , 
                               StatusCode::FAILURE  ); }
      StatusCode sc = 
        svcLoc->service( CkvG4SvcLocator::a_RichG4NtupSvcName , a_NtupleSvc,true  );
      if( sc.isFailure() ) 
        { throw GaudiException("
namespace Filters
void Ridge::
        subchunk( Tfr::ChunkAndInverse& chunkai )
    Tfr::Chunk& chunk = *chunkai.chunk;
    Tfr::ChunkElement* p     = chunk.transform_data->getCpuMemory();
    std::vector<Tfr::ChunkElement> q[] = {
        std::vector<Tfr::ChunkElement>(chunk.nSamples()),
        std::vector<Tfr::ChunkElement>(chunk.nSamples())
    };
    unsigned bytes_per_row = sizeof(Tfr::ChunkElement)*chunk.nSamples();
    Tfr::ChunkElement
            *prev_row = &q[0][0],
            *this_row = &q[1][0];
    for (unsigned y=1; y<chunk.nScales()-1; y++)
    {
        Tfr::ChunkElement* t = prev_row;
        prev_row = this_row;
        this_row = t;
        for (unsigned x=0; x<chunk.nSamples(); x++)
        {
            Tfr::ChunkElement a = p[(y-1)*chunk.nSamples() + x];
            Tfr::ChunkElement b = p[(y+0)*chunk.nSamples() + x];
            Tfr::ChunkElement c = p[(y+1)*chunk.nSamples() + x];
            float A = norm(a);
            float B = norm(b);
            floa
QDataStream& operator>>( QDataStream& Stream, DBQueryValue& Value )
  Stream >> Value.vint64;
  return Stream;
QDataStream& operator<<( QDataStream& Stream, const DBQueryValue& Value )
  Stream << Value.vint64;
  return Stream;
QDataStream& operator>>( QDataStream& Stream, DBPhotos::QueryKey& Value )
  quint8 key;
  Stream >> key;
  Value = static_cast<DBPhotos::QueryKey>(key);
  return Stream;
QDataStream& operator<<( QDataStream& Stream, const DBPhotos::QueryKey& Value )
  Stream << quint8(Value);
  return Stream;
QDataStream& operator>>( QDataStream& Stream, DBFaces::QueryKey& Value )
  quint8 key;
  Stream >> key;
  Value = static_cast<DBFaces::QueryKey>(key);
  return Stream;
QDataStream& operator<<( QDataStream& Stream, const DBFaces::QueryKey& Value )
  Stream << quint8(Value);
  return Stream;
QDataStream& operator>>( QDataStream& Stream, DBPersons::QueryKey& Value )
  quint8 key;
  Stream >> key;
  Value = static_cast<DBPersons::QueryKey>(key);
  return Stream;
QDataStream& op
void testaddBook() {
	BookstoreRepository repo;
	Book book = Book(1, "titlu", "author", "subiect", 2001);
	repo.addBook(book);
	assert(repo.getAll().size() == 1);
void testdeleteBook() {
	BookstoreRepository repo;
	Book book = Book(1, "titlu", "author", "subiect", 2001);
	repo.addBook(book);
	book = Book(2, "titlu2", "author31", "subiect", 2001);
	repo.addBook(book);
	repo.deleteBook(book);
	assert(repo.getAll().size() == 1);
void testupdateBook() {
	BookstoreRepository repo;
	Book book = Book(1, "titlu", "author", "subiect", 2001);
	repo.addBook(book);
	book = Book(1, "dadada", "dsdsa", "subiect", 2001);
	repo.updateBook(book);
	std::vector<Book> v = repo.getAll();
	assert(v.front().getTitle() == "dadada");
	assert(v.front().getAuthor() != "author");
	assert(v.front().getYear() == 2001);
void testeexistId() {
	BookstoreRepository repo;
	Book book = Book(1, "titlu", "author", "subiect", 2001);
	repo.addBook(book);
	book = Book(2, "titlu2", "author31", "subiect", 2001);
	repo.addBook(bo

	book = Book(3, "titlu2", "author31", "subiect", 2001);
	repo.addBook(book);
	assert(repo.existId(2) == true);
	assert(repo.existId(21) == false);
void testgetLastId() {
	BookstoreRepository repo;
	Book book1 = Book(1, "titlu", "author", "subject", 2011);
	repo.addBook(book1);
	book1 = Book(2, "titlu", "author", "subject", 2011);
	repo.addBook(book1);
	assert(repo.getLastId() == 3);
void testexistTitle() {
	BookstoreRepository repo;
	Book book1 = Book(1, "titlu", "author", "subject", 2011);
	repo.addBook(book1);
	assert(repo.existTitle("titlu").getId() == 1);
	assert(repo.existTitle("ada").getId() == -1);
void testgetById() {
	BookstoreRepository repo;
	Book book1 = Book(1, "titlu2", "author", "subject", 2011);
	repo.addBook(book1);
	book1 = Book(2, "titlu", "author", "subject", 2011);
	repo.addBook(book1);
	assert(repo.getById(2) == book1);
	assert((repo.getById(21) == book1) == false);
void testsortBy() {
	BookstoreRepository repo;
	Book b = Book(1, "Ion", "L. Rebreanu", "Roman", 19

	repo.addBook(b);
	b = Book(2, "Enigma Otiliei", "G. Calinescu", "Roman", 1900);
	repo.addBook(b);
	b = Book(3, "Moara cu Noroc", "I. Slavici", "Nuvela", 2011);
	repo.addBook(b);
	b = Book(4, "Mara	", "I. Slavici", "Nuvela", 1965);
	repo.addBook(b);
	b = Book(5, "Marile sperante", "C. Dickens", "Nuvela", 1800);
	repo.addBook(b);
	b = Book(6, "Mendebilul", "M. Cartarescu", "Roman", 2005);
	repo.addBook(b);
	b = Book(7, "Dama cu camelii", "A. Dumas", "Roman", 1800);
	repo.addBook(b);
	b = Book(8, "Decameronul", "G. Boccaccio", "Nuvela", 1200);
	repo.addBook(b);
	vector<Book> books = repo.sortBy(1);
	assert(books.size() == 8);
	b = Book(8, "Decameronul", "G. Boccaccio", "Nuvela", 1200);
	assert(books[1] == b);
	b = Book(6, "Mendebilul", "M. Cartarescu", "Roman", 2005);
	assert(books[6] == b);
	books = repo.sortBy(3);
	b = Book(5, "Marile sperante", "C. Dickens", "Nuvela", 1800);
	assert(books[1] == b);
	b = Book(7, "Dama cu camelii", "A. Dumas", "Roman", 1800);
	assert(books[2] == b);
vo
namespace ctornado {
void Buffer::merge(Buffer *buffer)
    while (buffer->size() > 0) {
        push(buffer->pop());
    }
void Buffer::merge_prefix(size_t size)
    Str chunk;
    str_buffer_t *prefix_buf;
    char *pos;
    size_t remaining;
    log_vverb("merge prefix %zu bytes (at most) of buffer", size);
    if (chunk_dq_.size() == 1 && chunk_dq_[0].len() <= size)
        return;
    if (chunk_dq_.size() > 0 && size > 0) {
        if (chunk_dq_[0].len() == size)
            return;
        if (chunk_dq_[0].len() > size) {
            chunk = chunk_dq_[0];
            chunk_dq_.pop_front();
            chunk_dq_.push_front(chunk.substr(size, -1));
            chunk_dq_.push_front(chunk.substr(0, size));
            return;
        }
        size = min(size, size_);
        prefix_buf = Str::alloc(size);
        pos = prefix_buf->data;
        remaining = size;
        while (remaining > 0 /* && chunk_dq_.size() > 0 */) {
            chunk = chunk_dq_[0];
            chunk_dq_.pop_

            if (chunk.len() > remaining) {
                chunk_dq_.push_front(chunk.substr(remaining, -1));
                memcpy(pos, chunk.data(), remaining);
                pos += remaining;
                remaining = 0;
            }
            else {
                memcpy(pos, chunk.data(), chunk.len());
                pos += chunk.len();
                remaining -= chunk.len();
            }
        }
        chunk_dq_.push_front(Str(prefix_buf, size));
    }
    if (chunk_dq_.size() == 0)
        chunk_dq_.push_front("");
void Buffer::double_prefix()
    size_t n;
    if (chunk_dq_.size() < 2)
        return;
    n = max(chunk_dq_[0].len() * 2, chunk_dq_[0].len() + chunk_dq_[1].len());
    merge_prefix(n);
void Buffer::remove_prefix(size_t size)
    Str chunk;
    size_t remaining;
    log_vverb("remove prefix %zu bytes (at most) from buffer", size);
    remaining = size;
    while (chunk_dq_.size() > 0 && remaining > 0) {
        chunk = chunk_dq_[0];
        chunk_dq

        if (chunk.len() > remaining) {
            chunk_dq_.push_front(chunk.substr(remaining, -1));
            size_ -= remaining;
            remaining = 0;
        }
        else {
            size_ -= chunk.len();
            remaining -= chunk.len();
        }
    }
void Buffer::push(const Str& chunk)
    log_vverb("push %zu bytes to buffer", chunk.len());
    size_ += chunk.len();
    chunk_dq_.push_back(chunk);
Str Buffer::pop()
    Str chunk;
    ASSERT(chunk_dq_.size() > 0);
    chunk = chunk_dq_[0];
    chunk_dq_.pop_front();
    size_ -= chunk.len();
    log_vverb("pop %zu bytes from buffer", chunk.len());
    return chunk;
Str Buffer::top()
    ASSERT(chunk_dq_.size() > 0);
    return chunk_dq_[0];
size_t Buffer::size()
    return size_;
void Buffer::clear()
    chunk_dq_.clear();
    size_ = 0;
Buffer *BufferIO::get_buffer()
    return &buffer_;
Str BufferIO::get_value()
    buffer_.merge_prefix(buffer_.size());
    return buffer_.top();
void BufferIO::clear()
    buffe
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocSh

    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_

    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_F

    LOAD_REPLACE_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(uint32_t aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    case LOAD_HISTORY:
    case LOAD_RELOAD_NORMAL:
    case LOAD_RELOAD_BYPASS_CACHE:
    case LOAD_RELOAD_BYPASS_PROXY:
    case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    case LOAD_LINK:
    case LOAD_REFRESH:
    case LOAD_RELOAD_CHARSET_CHANGE:
    cas
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
boost::uuids::uuid repo::core::RepoNodeRevision::REPO_NODE_UUID_BRANCH_MASTER =
	{ 0x00 ,0x00, 0x00, 0x00
    , 0x00, 0x00
    , 0x00, 0x00
    , 0x00, 0x00
    , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
repo::core::RepoNodeRevision::RepoNodeRevision(const mongo::BSONObj & obj)
	: RepoNodeAbstract(obj) 
	if (obj.hasField(REPO_NODE_LABEL_AUTHOR))
		autho

	if (obj.hasField(REPO_NODE_LABEL_MESSAGE))
		message = obj.getField(REPO_NODE_LABEL_MESSAGE).str();
	if (obj.hasField(REPO_NODE_LABEL_TAG))
		tag = obj.getField(REPO_NODE_LABEL_TAG).str();
	if (obj.hasField(REPO_NODE_LABEL_TIMESTAMP))
		timestamp = obj.getField(REPO_NODE_LABEL_TIMESTAMP).Date();
	if (obj.hasField(REPO_NODE_LABEL_CURRENT_UNIQUE_IDS))
		currentUniqueIDs = RepoTranscoderBSON::retrieveUUIDsSet(
			obj.getField(REPO_NODE_LABEL_CURRENT_UNIQUE_IDS));
	if (obj.hasField(REPO_NODE_LABEL_ADDED_SHARED_IDS))
		addedSharedIDs = RepoTranscoderBSON::retrieveUUIDsSet(
			obj.getField(REPO_NODE_LABEL_ADDED_SHARED_IDS));
	if (obj.hasField(REPO_NODE_LABEL_DELETED_SHARED_IDS))
		deletedSharedIDs = RepoTranscoderBSON::retrieveUUIDsSet(
			obj.getField(REPO_NODE_LABEL_DELETED_SHARED_IDS));
	if (obj.hasField(REPO_NODE_LABEL_MODIFIED_SHARED_IDS))
		modifiedSharedIDs = RepoTranscoderBSON::retrieveUUIDsSet(
			obj.getField(REPO_NODE_LABEL_MODIFIED_SHARED_IDS));
	if (obj.hasField(REPO_NODE_LABE

		unmodifiedSharedIDs = RepoTranscoderBSON::retrieveUUIDsSet(
			obj.getField(REPO_NODE_LABEL_UNMODIFIED_SHARED_IDS));
repo::core::RepoNodeRevision::~RepoNodeRevision() {}
bool repo::core::RepoNodeRevision::operator==(const RepoNodeAbstract& other) const
    const RepoNodeRevision *otherRevision = dynamic_cast<const RepoNodeRevision*>(&other);
    return otherRevision &&
            RepoNodeAbstract::operator==(other) &&
            this->getAuthor() == otherRevision->getAuthor() &&
            this->getMessage() == otherRevision->getMessage() &&
            this->getTag() == otherRevision->getTag() &&
            this->getTimestamp() == otherRevision->getTimestamp() &&
            (std::equal(this->getCurrentUniqueIDs().begin(),
                        this->getCurrentUniqueIDs().end(),
                        otherRevision->getCurrentUniqueIDs().end())) &&
            (std::equal(this->getAddedSharedIDs().begin(),
                        this->getAddedSharedIDs().end(),
            

            (std::equal(this->getDeletedSharedIDs().begin(),
                        this->getDeletedSharedIDs().end(),
                        otherRevision->getDeletedSharedIDs().end())) &&
            (std::equal(this->getModifiedSharedIDs().begin(),
                        this->getModifiedSharedIDs().end(),
                        otherRevision->getModifiedSharedIDs().end())) &&
            (std::equal(this->getUnmodifiedSharedIDs().begin(),
                        this->getUnmodifiedSharedIDs().end(),
                        otherRevision->getUnmodifiedSharedIDs().end()));
mongo::BSONObj repo::core::RepoNodeRevision::toBSONObj() const
	mongo::BSONObjBuilder builder;
	appendDefaultFields(builder);
	if (!author.empty()) 
		builder << REPO_NODE_LABEL_AUTHOR << author;
	if (!message.empty()) 
		builder << REPO_NODE_LABEL_MESSAGE << message;
	if (!tag.empty()) 
		builder << REPO_NODE_LABEL_TAG << tag;
	builder << REPO_NODE_LABEL_TIMESTAMP << timestamp;
	if (currentUniqueIDs.size() > 

        RepoTranscoderBSON::append(REPO_NODE_LABEL_CURRENT_UNIQUE_IDS,
                                   currentUniqueIDs, builder);
	if (addedSharedIDs.size() > 0)
        RepoTranscoderBSON::append(REPO_NODE_LABEL_ADDED_SHARED_IDS,
                                   addedSharedIDs, builder);
	if (deletedSharedIDs.size() > 0)
        RepoTranscoderBSON::append(REPO_NODE_LABEL_DELETED_SHARED_IDS,
                                   deletedSharedIDs, builder);
	if (modifiedSharedIDs.size() > 0)
        RepoTranscoderBSON::append(REPO_NODE_LABEL_MODIFIED_SHARED_IDS,
                                   modifiedSharedIDs, builder);
	if (unmodifiedSharedIDs.size() > 0)
        RepoTranscoderBSON::append(REPO_NODE_LABEL_UNMODIFIED_SHARED_IDS,
                                   unmodifiedSharedIDs, builder);
	return builder.obj();
void repo::core::RepoNodeRevision::setCurrentUniqueIDs(const RepoNodeAbstractSet &nodes)
    currentUniqueIDs.clear();
    for (RepoNodeAbstract *node : nodes)
    
CPPTEST_CONTEXT("core.message.test.cpptest.TA_Message_CppTest/core.message.test.cpptest/generic_common/ConnectionThread.cpp");
CPPTEST_TEST_SUITE_INCLUDED_TO("core.message.test.cpptest.TA_Message_CppTest/core.message.test.cpptest/generic_common/ConnectionThread.cpp");
class TestSuite_resolveChannelLocator_34ae5f07 : public CppTest_TestSuite
    public:
        CPPTEST_TEST_SUITE(TestSuite_resolveChannelLocator_34ae5f07);
        CPPTEST_TEST(test_resolveChannelLocator_1);
        CPPTEST_TEST_SUITE_END();
        void setUp();
        void tearDown();
        void test_resolveChannelLocator_1();
};
CPPTEST_TEST_SUITE_REGISTRATION(TestSuite_resolveChannelLocator_34ae5f07);
void TestSuite_resolveChannelLocator_34ae5f07::setUp()
    FUNCTION_ENTRY( "setUp" );
    FUNCTION_EXIT;
void TestSuite_resolveChannelLocator_34ae5f07::tearDown()
    FUNCTION_ENTRY( "tearDown" );
    FUNCTION_EXIT;
/* CPPTEST_TEST_CASE_BEGIN test_resolveChannelLocator_1 */
/* CPPTEST_TEST_CASE_CONTEXT bool TA_Base_Co
/* GStreamer
 * Copyright (C) 1999,2000 Erik Walthinsen <omega@cse.ogi.edu>
 *                    2000 Wim Taymans <wtay@chello.be>
 *
 * gstsample.h: Header for GstSample object
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
G_BEGIN_DECLS
GST_EXPORT GType _gst_sample_type;
/**
 * GstSample:
 *
 * 

 * exchange buffers with an application.
 */
typedef struct _GstSample GstSample;
GST_EXPORT
GType                gst_sample_get_type      (void);
/* allocation */
GST_EXPORT
GstSample *          gst_sample_new           (GstBuffer          *buffer,
                                               GstCaps            *caps,
                                               const GstSegment   *segment,
                                               GstStructure       *info);
GST_EXPORT
GstBuffer *          gst_sample_get_buffer    (GstSample *sample);
GST_EXPORT
GstCaps *            gst_sample_get_caps      (GstSample *sample);
GST_EXPORT
GstSegment *         gst_sample_get_segment   (GstSample *sample);
GST_EXPORT
const GstStructure * gst_sample_get_info      (GstSample *sample);
GST_EXPORT
GstBufferList *      gst_sample_get_buffer_list (GstSample *sample);
GST_EXPORT
void                 gst_sample_set_buffer_list (GstSample *sample, GstBufferList *buffer_list);
/* refcounting */
/**
 * g

 *
 * Increases the refcount of the given sample by one.
 *
 * Returns: (transfer full): @sample
 */
static inline GstSample *
gst_sample_ref (GstSample * sample)
  return GST_SAMPLE_CAST (gst_mini_object_ref (GST_MINI_OBJECT_CAST (
      sample)));
/**
 * gst_sample_unref:
 *
 * Decreases the refcount of the sample. If the refcount reaches 0, the
 * sample will be freed.
 */
static inline void
gst_sample_unref (GstSample * sample)
  gst_mini_object_unref (GST_MINI_OBJECT_CAST (sample));
/* copy sample */
/**
 * gst_sample_copy:
 *
 * Create a copy of the given sample. This will also make a newly allocated
 * copy of the data the source sample contains.
 *
 * Returns: (transfer full): a new copy of @buf.
 *
 * Since: 1.2
 */
static inline GstSample *
gst_sample_copy (const GstSample * buf)
  return GST_SAMPLE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (buf)));
/**
 * gst_value_set_sample:
 *
 * Sets @b as the value of @v.  Caller retains reference to sample.
 */
/**
 * gst
/* GStreamer
 * Copyright (C) 1999,2000 Erik Walthinsen <omega@cse.ogi.edu>
 *                    2000 Wim Taymans <wtay@chello.be>
 *
 * gstsample.h: Header for GstSample object
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
G_BEGIN_DECLS
GST_EXPORT GType _gst_sample_type;
/**
 * GstSample:
 *
 * 

 * exchange buffers with an application.
 */
typedef struct _GstSample GstSample;
GType gst_sample_get_type            (void);
/* allocation */
GstSample *          gst_sample_new           (GstBuffer          *buffer,
                                               GstCaps            *caps,
                                               const GstSegment   *segment,
                                               GstStructure       *info);
GstBuffer *          gst_sample_get_buffer    (GstSample *sample);
GstCaps *            gst_sample_get_caps      (GstSample *sample);
GstSegment *         gst_sample_get_segment   (GstSample *sample);
const GstStructure * gst_sample_get_info      (GstSample *sample);
GstBufferList *      gst_sample_get_buffer_list (GstSample *sample);
void                 gst_sample_set_buffer_list (GstSample *sample, GstBufferList *buffer_list);
/* refcounting */
/**
 * gst_sample_ref:
 *
 * Increases the refcount of the given sample by one.
 *
 * Returns: (transfer 

 */
static inline GstSample *
gst_sample_ref (GstSample * sample)
  return GST_SAMPLE_CAST (gst_mini_object_ref (GST_MINI_OBJECT_CAST (
      sample)));
/**
 * gst_sample_unref:
 *
 * Decreases the refcount of the sample. If the refcount reaches 0, the
 * sample will be freed.
 */
static inline void
gst_sample_unref (GstSample * sample)
  gst_mini_object_unref (GST_MINI_OBJECT_CAST (sample));
/* copy sample */
/**
 * gst_sample_copy:
 *
 * Create a copy of the given sample. This will also make a newly allocated
 * copy of the data the source sample contains.
 *
 * Returns: (transfer full): a new copy of @buf.
 *
 * Since: 1.2
 */
static inline GstSample *
gst_sample_copy (const GstSample * buf)
  return GST_SAMPLE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (buf)));
/**
 * gst_value_set_sample:
 *
 * Sets @b as the value of @v.  Caller retains reference to sample.
 */
/**
 * gst_value_take_sample:
 *
 * Sets @b as the value of @v.  Caller gives away reference to sample.
 */
int
main( int argc, char* argv[] )
    InitializeOgreBase( "Xenogears Model Exporter" );
    {
    }
    {
/*
        MeshData data;
        data.name = "robo1";
        data.tex_width = 4096;
        data.tex_height = 256;
        ModelInfo model_info;
        model_info.data = data;
        model_info.model_file = "2203.model";
        model_info.animation_file = "2202.animation";
        model_info.animations.push_back( "Idle" );
        model_info.animations.push_back( "ToIdle" );
        model_info.animations.push_back( "ToFire" );
*/
        MeshData data;
        data.name = "weltall";
        data.tex_width = 4096;
        data.tex_height = 256;
        ModelInfo model_info;
        model_info.data = data;
        model_info.model_file = "2145.model";
        model_info.animation_file = "2144.animation";
        model_info.animations.push_back( "Idle" );
        model_info.animations.push_back( "1" );
        model_info.animations.push_back( "2" );
        model_info.animations

        model_info.animations.push_back( "4" );
        model_info.animations.push_back( "5" );
        model_info.animations.push_back( "6" );
        model_info.animations.push_back( "7" );
        model_info.animations.push_back( "8" );
        model_info.animations.push_back( "9" );
        model_info.animations.push_back( "10" );
        model_info.animations.push_back( "11" );
        model_info.animations.push_back( "12" );
        model_info.animations.push_back( "14" );
        model_info.animations.push_back( "15" );
        model_info.animations.push_back( "16" );
        model_info.animations.push_back( "17" );
        model_info.animations.push_back( "18" );
        model_info.animations.push_back( "19" );
        model_info.animations.push_back( "20" );
        model_info.animations.push_back( "21" );
        model_info.animations.push_back( "22" );
        model_info.animations.push_back( "23" );
        model_info.animations.push_back( "24" );
        model_info.animat
/*
 * chunk.h
 *
 *  Created on: Jan 19, 2015
 *      Author: scho
 */
template<class Value, typename offset_t>
class ChunkIter {
private:
	std::iterator<std::input_iterator_tag, Value> delta_iterator_;
public:
	ChunkIter(offset_t offset);
	Value Next();
	bool HasNext();
};
template<class Value, typename offset_t>
class Chunk {
private:
	offset_t offset_;
	uint32_t size_;
	uint32_t first_;
	std::list<Value> main_set_;
	std::list<Value> delta_set_;
	Chunk* next_;
	std::list<Value> MaterializeDelta();
public:
	Chunk(offset_t offset);
	Chunk(offset_t offset, offset_t next_offset, std::list<Value> set);
	/**
	 * Returns the number of elements in the chunk.
	 * @return the number of elements in the chunk.
	 */
	uint32_t Size();
	/**
	 * Returns the chunk iterator. The iterator should be lazy iterator.
	 * @return the chunk iterator.
	 */
	ChunkIter<Value, offset_t> Iterator();
	bool Encode();
	bool Add(Value value);
};
template<class Value, typename offset_t>
Chunk<Value, offset_t>::Chunk(o
namespace overload {
namespace detail {
template <typename... Types> struct TypeList {};
template <typename Sig> struct SigTraits;
template <typename R, typename... Args> struct SigTraits<R(Args...)> {
  typedef R ReturnType;
  typedef TypeList<Args...> ArgsType;
  typedef R (*InvokeFnType)(void*, Args&&...);
};
template <typename... Sigs> class InvokeFnTable;
template <> class InvokeFnTable<> {
 public:
  typedef void (*Deleter)(void*);
  constexpr InvokeFnTable(Deleter d) : deleter_(d) {}
  Deleter deleter() const {
    return deleter_;
  }
 private:
  const Deleter deleter_;
};
template <typename Sig, typename... Sigs>
class InvokeFnTable<Sig, Sigs...> : public InvokeFnTable<Sigs...> {
 public:
  typedef void (*Deleter)(void*);
  typedef typename SigTraits<Sig>::InvokeFnType InvokeFnType;
  constexpr InvokeFnTable(Deleter d, InvokeFnType fn,
                          typename SigTraits<Sigs>::InvokeFnType... fns)
      : InvokeFnTable<Sigs...>(d, fns...), invoke_fn_(fn) {}
  InvokeF

  InvokeFnTable(InvokeFnType&&) = delete;
  InvokeFnType& operator=(const InvokeFnType&) = delete;
  InvokeFnType& operator=(InvokeFnType&&) = delete;
  template <typename S>
  typename std::enable_if<std::is_same<S, Sig>::value, InvokeFnType>::type
  Get() const {
    return invoke_fn_;
  }
  template <typename S>
  typename std::enable_if<!std::is_same<S, Sig>::value,
                          typename SigTraits<S>::InvokeFnType>::type
  Get() const {
    return InvokeFnTable<Sigs...>::template Get<S>();
  }
  operator InvokeFnType() const {
    return invoke_fn_;
  }
 private:
  const InvokeFnType invoke_fn_;
};
template <typename T, typename Sig> struct Invoker;
template <typename T, typename R>
struct Invoker<T, R()> {
  static R Invoke(void* obj) {
    constexpr R (T::*fn)() = &T::operator();
    return (static_cast<T*>(obj)->*fn)();
  }
};
template <typename T, typename R, typename... Args>
struct Invoker<T, R(Args...)> {
  static R Invoke(void* obj, Args&&... args) {
    const

    return (static_cast<T*>(obj)->*fn)(std::forward<Args>(args)...);
  }
};
template <typename T>
void Delete(void* obj) {
  delete static_cast<T*>(obj);
template <typename T, typename... Sigs>
constexpr InvokeFnTable<Sigs...> InitInvokeFnTable() {
  return InvokeFnTable<Sigs...>(&Delete<T>, &Invoker<T, Sigs>::Invoke...);
template <typename T, typename... Sigs>
struct InvokeFnTableHolder {
  constexpr InvokeFnTableHolder() : table(InitInvokeFnTable<T, Sigs...>()) {}
  const InvokeFnTable<Sigs...> table;
  static const InvokeFnTableHolder singleton;
};
template <typename T, typename... Sigs>
const InvokeFnTableHolder<T, Sigs...> InvokeFnTableHolder<T, Sigs...>::singleton;
template <typename T, typename... Sigs>
constexpr const InvokeFnTable<Sigs...>* GetTable() {
  return &InvokeFnTableHolder<T, Sigs...>::singleton.table;
template <typename ArgsType, typename... Sigs> struct DispatchReturnType;
template <typename ArgsType>
struct DispatchReturnType<ArgsType> {
  struct Type;
};
templat

struct DispatchReturnType<ArgsType, Sig, Sigs...> {
  typedef typename std::conditional<
    std::is_same<ArgsType, typename SigTraits<Sig>::ArgsType>::value,
    typename SigTraits<Sig>::ReturnType,
    typename DispatchReturnType<ArgsType, Sigs...>::Type
  >::type Type;
};
template <typename... Sigs>
class Overload {
 public:
  template <typename T>
  Overload(const T& obj)
      : obj_(new T(obj)), invoke_fn_table_(detail::GetTable<T, Sigs...>()) {}
  Overload(const Overload&) = delete;
  Overload& operator=(const Overload&) = delete;
  Overload(Overload&& o) : obj_(o.obj_), invoke_fn_table_(o.invoke_fn_table_) {
    o.obj_ = nullptr;
  }
  Overload& operator=(Overload&& o) {
    obj_ = o.obj_;
    o.obj_ = nullptr;
    invoke_fn_table_ = o.invoke_fn_table_;
  }
  ~Overload() {
    auto del = invoke_fn_table_->deleter();
    (*del)(obj_);
  }
  template <typename... Args>
  typename detail::DispatchReturnType<detail::TypeList<Args...>, Sigs...>::Type
  operator()(Args&&... args) {

using namespace UnitTest;
using namespace std;
namespace {
TEST(DefaultIsEmptyString)
    MemoryOutStream const stream;
    CHECK(stream.GetText() != 0);
    CHECK_EQUAL("", stream.GetText());
TEST(StreamingTextCopiesCharacters)
    MemoryOutStream stream;
    stream << "Lalala";
    CHECK_EQUAL("Lalala", stream.GetText());
TEST(StreamingMultipleTimesConcatenatesResult)
    MemoryOutStream stream;
    stream << "Bork" << "Foo" << "Bar";
    CHECK_EQUAL("BorkFooBar", stream.GetText());
TEST(StreamingIntWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << (int)123;
    CHECK_EQUAL("123", stream.GetText());
TEST(StreamingUnsignedIntWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << (unsigned int)123;
    CHECK_EQUAL("123", stream.GetText());
TEST(StreamingLongWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << (long)(-123);
    CHECK_EQUAL("-123", stream.GetText());
TEST(StreamingUnsignedLongWritesCorrectCharacters)
    MemoryOutStream stream;


    CHECK_EQUAL("123", stream.GetText());
TEST(StreamingFloatWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << 3.1415f;
    CHECK(strstr(stream.GetText(), "3.1415"));
TEST(StreamingDoubleWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << 3.1415;
    CHECK(strstr(stream.GetText(), "3.1415"));
TEST(StreamingPointerWritesCorrectCharacters)
    MemoryOutStream stream;
    int* p = (int*)0x1234;
    stream << p;
    CHECK(strstr(stream.GetText(), "1234"));
TEST(StreamingSizeTWritesCorrectCharacters)
    MemoryOutStream stream;
    size_t const s = 53124;
    stream << s;
    CHECK_EQUAL("53124", stream.GetText());
TEST(StreamInitialCapacityIsCorrect)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    CHECK_EQUAL((int)MemoryOutStream::GROW_CHUNK_SIZE, stream.GetCapacity());
TEST(StreamInitialCapacityIsMultipleOfGrowChunkSize)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE + 1);
    CHECK_EQUAL((int)MemoryOutStream::GROW_CHUNK_SIZE

TEST(ExceedingCapacityGrowsBuffer)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    stream << "012345678901234567890123456789";
    char const* const oldBuffer = stream.GetText();
    stream << "0123456789";
    CHECK(oldBuffer != stream.GetText());
TEST(ExceedingCapacityGrowsBufferByGrowChunk)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    stream << "0123456789012345678901234567890123456789";
    CHECK_EQUAL(MemoryOutStream::GROW_CHUNK_SIZE * 2, stream.GetCapacity());
TEST(WritingStringLongerThanCapacityFitsInNewBuffer)
    MemoryOutStream stream(8);
    stream << "0123456789ABCDEF";
    CHECK_EQUAL("0123456789ABCDEF", stream.GetText());
TEST(WritingIntLongerThanCapacityFitsInNewBuffer)
    MemoryOutStream stream(8);
    stream << "aaaa" << 123456;;
    CHECK_EQUAL("aaaa123456", stream.GetText());
TEST(WritingFloatLongerThanCapacityFitsInNewBuffer)
    MemoryOutStream stream(8);
    stream << "aaaa" << 123456.0f;;
    CHECK_EQUAL("aaaa123456.000000
namespace cir { namespace common { namespace concurrency {
std::map<boost::thread::id, cv::gpu::Stream*> StreamHandler::_threadToStreamMap;
StreamHandler::StreamHandler() {
StreamHandler::~StreamHandler() {
cv::gpu::Stream* StreamHandler::currentStream() {
	boost::thread::id threadId = boost::this_thread::get_id();
	std::map<boost::thread::id, cv::gpu::Stream*>::iterator it = _threadToStreamMap.find(threadId);
	if(it == _threadToStreamMap.end()) {
		cv::gpu::Stream* stream = new cv::gpu::Stream;
		_threadToStreamMap[threadId] = stream;
		return stream;
	} else {
		return (*it).second;
	}
cudaStream_t StreamHandler::nativeStream() {
	cv::gpu::Stream* currentStream = StreamHandler::currentStream();
	return cv::gpu::StreamAccessor::getStream(*currentStream);
void StreamHandler::waitForCompletion() {
	for(std::map<boost::thread::id, cv::gpu::Stream*>::iterator it = _threadToStreamMap.begin();
			it != _threadToStreamMap.end(); it++) {
		cv::gpu::Stream* stream = (*it).second;
		stream->wai
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
typedef Fixture RepositoryFixture;
TEST_F(RepositoryFixture, CanOpen)
    Git::Result r;
    TempRepoOpener tempRepo(this, "SimpleRepo1", r);
    CHECK_GIT_RESULT(r);
    Git::Repository repo(tempRepo);
    ASSERT_TRUE(repo.isValid());
    ASSERT_FALSE(repo.isBare());
    ASSERT_FALSE(repo.isHeadDetached
namespace base {
namespace trace_event {
JavaHeapDumpProvider* JavaHeapDumpProvider::GetInstance() {
  return Singleton<JavaHeapDumpProvider,
                   LeakySingletonTraits<JavaHeapDumpProvider>>::get();
JavaHeapDumpProvider::JavaHeapDumpProvider() {
JavaHeapDumpProvider::~JavaHeapDumpProvider() {
bool JavaHeapDumpProvider::OnMemoryDump(const MemoryDumpArgs& args,
                                        ProcessMemoryDump* pmd) {
  long total_heap_size = 0;
  long free_heap_size = 0;
  android::JavaRuntime::GetMemoryUsage(&total_heap_size, &free_heap_size);
  MemoryAllocatorDump* outer_dump = pmd->CreateAllocatorDump("java_heap");
  outer_dump->AddScalar(MemoryAllocatorDump::kNameSize,
                        MemoryAllocatorDump::kUnitsBytes, total_heap_size);
  MemoryAllocatorDump* inner_dump =
      pmd->CreateAllocatorDump("java_heap/allocated_objects");
  inner_dump->AddScalar(MemoryAllocatorDump::kNameSize,
                        MemoryAllocatorDump::kUnitsBytes,
        
/*  YTP King - Easy to use sentence mixer
 *  Copyright (C) 2013  Alex "rainChu" Haddad et al.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
*/
	namespace ytpking
	{
	namespace smp
	{
SampleManager::SampleManager( void ) :
	m_selectedSample( NULL )
SampleManager::~SampleManager( void )
	for ( SampleMap::const_iterator it = m_samples.begin(); it != m_samples.end(); ++it )
		delete it->second;
void
SampleManager::loadAll( void )
	for ( SampleUserSet::const_

		(*it)->onLoadAllSamples();
void
SampleManager::registerSampleUser( SampleUser *sampleUser )
	m_sampleUsers.insert( sampleUser );
void
SampleManager::unregisterSampleUser( SampleUser *sampleUser )
	m_sampleUsers.erase( sampleUser );
/** Get the currently active sample. */
smp::Sample
*SampleManager::getSelectedSample( void ) const
	return m_selectedSample;
/** Set the currently active sample. */
void
SampleManager::selectSample( smp::Sample *sample )
	m_selectedSample = sample;
	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onSelectSample( sample );
smp::Sample
*SampleManager::addSample( const char *filename, const char *name, const char *speakerName,
                           const Guid &guid,
                           SamplesDataFile::NodeReference *nodeReferencePtr )
	smp::Sample *sample = new smp::Sample( name, filename, guid );
	if ( nodeReferencePtr != NULL )
		sample->m_nodeReference = *nodeReferencePtr;
	m_samples

	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onAddSample( name, speakerName, sample );
	return sample;
void
SampleManager::deleteSample( smp::Sample *sample )
	if ( sample == NULL )
		sample = m_selectedSample;
	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onDeleteSample( sample );
	SampleMap::const_iterator it = m_samples.find( sample->getGuid() );
	assert( it != m_samples.end() );
	m_samples.erase( it );
	delete sample;
void
SampleManager::renameSample( smp::Sample *sample, const char *name )
	SampleMap::iterator it = m_samples.find( sample->getGuid() );
	assert ( it != m_samples.end() );
	it->second->m_name = name;
	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onRenameSample( name, sample );
void
SampleManager::changeSpeaker( smp::Sample *sample, const char *speakerName )
	SampleMap::const_iterator

	assert( it != m_samples.end() );
	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onChangeSampleSpeaker( speakerName, sample );
void
SampleManager::setSampleRange( Sample *sample, unsigned int start, unsigned int end )
	SampleMap::const_iterator it = m_samples.find( sample->getGuid() );
	assert( it != m_samples.end() );
	assert( end > start );
	sample->m_start = start;
	sample->m_duration = end - start;
	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onChangeSampleRange( sample );
void
SampleManager::setSampleStart( Sample *sample, unsigned int start )
	SampleMap::const_iterator it = m_samples.find( sample->getGuid() );
	assert( it != m_samples.end() );
	int oldEnd = sample->getEnd();
	sample->m_start = start;
	for ( SampleUserSet::const_iterator it = m_sampleUsers.begin(); it != m_sampleUsers.end(); ++it )
		(*it)->onChangeSampleRange( sample );
void
SampleManager::
static ELEMDESC s_mElemDesc[] = 
	{{{NULL}, VT_I2}, {NULL, 0x1}},
	{{{NULL}, VT_VARIANT}, {NULL, 0x1}},
	{{{NULL}, VT_VARIANT}, {NULL, 0x1}},
	{{{NULL}, VT_VARIANT}, {NULL, 0x1}},
	{{{NULL}, VT_VARIANT}, {NULL, 0x1}},
	{{{NULL}, VT_VARIANT}, {NULL, 0x11}},
	{0}
};
static CBTypeInfo::METHOD_ENTRY s_mData[] =
	{L"Padding", {0x00000004, NULL, &s_mElemDesc[0], FUNC_DISPATCH, INVOKE_PROPERTYPUT, CC_STDCALL, 1, 0, 44, 0, {{{NULL}, VT_EMPTY}}, 0}},
	{L"PrivateKey", {0x00000005, NULL, &s_mElemDesc[1], FUNC_DISPATCH, INVOKE_PROPERTYPUT, CC_STDCALL, 1, 0, 52, 0, {{{NULL}, VT_EMPTY}}, 0}},
	{L"PublicKey", {0x00000006, NULL, &s_mElemDesc[2], FUNC_DISPATCH, INVOKE_PROPERTYPUT, CC_STDCALL, 1, 0, 60, 0, {{{NULL}, VT_EMPTY}}, 0}},
	{L"IsPrivateKey", {0x00000001, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 28, 0, {{{NULL}, VT_BOOL}}, 0}},
	{L"Key", {0x00000002, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 32, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"KeySize", {0x0000

	{L"Padding", {0x00000004, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 40, 0, {{{NULL}, VT_I2}}, 0}},
	{L"PrivateKey", {0x00000005, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 48, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"PublicKey", {0x00000006, NULL, NULL, FUNC_DISPATCH, INVOKE_PROPERTYGET, CC_STDCALL, 0, 0, 56, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"Decrypt", {0x00000007, NULL, &s_mElemDesc[3], FUNC_DISPATCH, INVOKE_FUNC, CC_STDCALL, 1, 0, 64, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"Encrypt", {0x00000008, NULL, &s_mElemDesc[4], FUNC_DISPATCH, INVOKE_FUNC, CC_STDCALL, 1, 0, 68, 0, {{{NULL}, VT_VARIANT}}, 0}},
	{L"GenerateKey", {0x00000009, NULL, &s_mElemDesc[5], FUNC_DISPATCH, INVOKE_FUNC, CC_STDCALL, 1, 1, 72, 0, {{{NULL}, VT_EMPTY}}, 0}}
};
static HRESULT _Invoke(PVOID pvInstance, MEMBERID memid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult)
	IRSA* pObject = (IRSA*)pvInstance;
	HRESULT hr;
	UINT cArgs = pDispParams->cArgs;
	UINT cArgs1 = c

	hr;cArgs;cArgs1;
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_NAMED_VALUE(VT_I2, 0)
		hr = pObject->put_Padding(v0);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_NAMED_VALUE(VT_VARIANT, 0)
		hr = pObject->put_PrivateKey(v0);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_NAMED_VALUE(VT_VARIANT, 0)
		hr = pObject->put_PublicKey(v0);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_RET(VT_BOOL, 0)
		hr = pObject->get_IsPrivateKey(v0);
		return hr;
	}
	{
		INVOKE_PARAM_RET(VT_VARIANT, 0)
		hr = pObject->get_Key(v0);
		INVOKE_DISP;
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_RET(VT_I2, 0)
		hr = pObject->get_KeySize(v0);
		return hr;
	}
	{
		if(cArgs1 > 0)
			return DISP_E_BADPARAMCOUNT;
		INVOKE_PARAM_RET(VT_I2, 0)
		hr = pObject->get_Padding(v0);
		return hr;
	}
	{
		INVOKE_PARAM_RET(VT_VARIANT, 0)
		hr = pObject->get_P
using content::BrowserThread;
BookmarkModelTask::BookmarkModelTask(BookmarkModel* model)
    : model_(model) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(model_);
  model_->BlockTillLoaded();
BookmarkModel* BookmarkModelTask::model() const {
  return model_;
BookmarkModelObserverTask::BookmarkModelObserverTask(
    BookmarkModel* bookmark_model)
    : BookmarkModelTask(bookmark_model) {
  model()->AddObserver(this);
BookmarkModelObserverTask::~BookmarkModelObserverTask() {
  model()->RemoveObserver(this);
void BookmarkModelObserverTask::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BookmarkModelObserverTask::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
void BookmarkModelObserverTask::BookmarkNodeAdded(BookmarkModel* model,
                                                  cons
/* Dependencies */
namespace CheapTune {
Mixer::Mixer(Amplitude_t globalAmplitude) :
		_channels(), /*_filter(),*/ _globalAmplitude(globalAmplitude) {
void Mixer::setGlobalAmplitude(Amplitude_t globalAmplitude) {
	_globalAmplitude = globalAmplitude;
Sample_t Mixer::mixTwoSamples(Sample_t _A, Sample_t _B) {
	int32_t Z, A = _A, B = _B;
	if (A < 0 && B < 0)
		Z = (A + B) - ((A * B) / SAMPLE_VMIN);
	else if ((A > 0) & (B > 0))
		Z = (A + B) - ((A * B) / SAMPLE_VMAX);
	else
		Z = A + B;
	return Z;
Sample_t Mixer::getSample() {
	/* Get the first channel sample */
	Sample_t sample = _channels[0].getSample();
	/* Get all other channels samples */
	for (unsigned char i = 1; i < CHANNELS_COUNT; ++i) {
		/* Get channel sample and mix them with the previous sample */
		sample = mixTwoSamples(sample, _channels[i].getSample());
	}
	/* Pass the resulting sample into the filter */
	/* Amplitude modulate the sample */
	sample = AmplitudeModulator::compute(sample, _globalAmplitude);
	/* Return the final
/*================================================================================
  code generated by: java2cpp
  class: org.xml.sax.Locator
================================================================================*/
namespace j2cpp { namespace java { namespace lang { class Object; } } }
namespace j2cpp { namespace java { namespace lang { class String; } } }
namespace j2cpp {
namespace org { namespace xml { namespace sax {
	class Locator;
	class Locator
		: public object<Locator>
	{
	public:
		J2CPP_DECLARE_CLASS
		J2CPP_DECLARE_METHOD(0)
		J2CPP_DECLARE_METHOD(1)
		J2CPP_DECLARE_METHOD(2)
		J2CPP_DECLARE_METHOD(3)
		explicit Locator(jobject jobj)
		: object<Locator>(jobj)
		{
		}
		operator local_ref<java::lang::Object>() const;
		local_ref< java::lang::String > getPublicId();
		local_ref< java::lang::String > getSystemId();
		jint getLineNumber();
		jint getColumnNumber();
namespace j2cpp {
org::xml::sax::Locator::operator local_ref<java::lang::Object>() const
	return local_r

local_ref< java::lang::String > org::xml::sax::Locator::getPublicId()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(0),
		org::xml::sax::Locator::J2CPP_METHOD_SIGNATURE(0), 
		local_ref< java::lang::String >
	>(get_jobject());
local_ref< java::lang::String > org::xml::sax::Locator::getSystemId()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(1),
		org::xml::sax::Locator::J2CPP_METHOD_SIGNATURE(1), 
		local_ref< java::lang::String >
	>(get_jobject());
jint org::xml::sax::Locator::getLineNumber()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(2),
		org::xml::sax::Locator::J2CPP_METHOD_SIGNATURE(2), 
		jint
	>(get_jobject());
jint org::xml::sax::Locator::getColumnNumber()
	return call_method<
		org::xml::sax::Locator::J2CPP_CLASS_NAME,
		org::xml::sax::Locator::J2CPP_METHOD_NAME(3),
		org::xml::sax::Loca
/**
 * @file ServantLocator.h
 *
 * $Id$
 *
 * Implementation header for the PortableServer::ServantLocator for
 * the PortableInterceptor / ServantLocator test.
 *
 * @author Ossama Othman <ossama@dre.vanderbilt.edu>
 */
/**
 * @class ServantLocator
 *
 * @brief Test PortableServer::ServantLocator.
 *
 * PortableServer::ServantLocator used for this test.
 */
class ServantLocator
  : public virtual PortableServer::ServantLocator,
    public virtual ::CORBA::LocalObject
public:
  ServantLocator (CORBA::ORB_ptr orb);
  virtual PortableServer::Servant preinvoke (
      const PortableServer::ObjectId & oid,
      PortableServer::POA_ptr adapter,
      const char * operation,
      PortableServer::ServantLocator::Cookie & the_cookie);
  virtual void postinvoke (
      const PortableServer::ObjectId & oid,
      PortableServer::POA_ptr adapter,
      const char * operation,
      PortableServer::ServantLocator::Cookie the_cookie,
      PortableServer::Servant the_servant);
  bool error_statu
/*!
 *	COPYRIGHT NOTICE
 *	Copyright (c) 2011, Combinz
 *	All rights reserved.
 *
 *	CoGit Library is a Object-Oriented Qt wrap of Git
 *	CoGit Library is released under the GPLv2 License
 *
 *	\file coref.cpp
 *	\brief CoRefç±»çå®ç°é¨å
 *
 *	\author ä¸å½¦ dingyan@freestorm.org
 *	\author ä»äºæ fuyaxing@freestorm.org
 *	\date 2011/03/01
 */
CoRef::CoRef()
	m_repo = NULL;
	m_name = "";
	m_commit = NULL;
	m_type = CoRef::Invalid;
CoRef::CoRef(CoRepo* repo, QString name, CoCommit* commit, CoRefType type)
	m_repo = repo;
	m_name = name;
	m_commit = commit;
	m_type = type;
CoRef::CoRef(CoRepo* repo, QString name, QString commit, CoRefType type)
	m_repo = repo;
	m_name = name;
	m_commit = new CoCommit(repo, commit);
	m_type = type;
CoRef::CoRef(CoRepo* repo,QString name, CoRefType type)
	m_repo = repo;
	m_name = name;
	m_type = type;
	CoKwargs opts;
	opts.insert("hash","");
	QStringList cmd;
	QString out, error;
	switch(type)
	{
		case Head:
			{
				cmd << "show-ref" << "refs/heads/"+name;
				break;
/*
 *  btree.h
 *  C Library
 *
 *  Created by hailong zhang on 10-10-5.
 *  Copyright 2010 hailongz. All rights reserved.
 *
 */
extern "C" {
    typedef struct _map_t{
        hint32 count;
    } * hmap_t;
    
	typedef huintptr (*hash_code_t)(hany key,InvokeTickDeclare);
	typedef hbool (*equal_t)(hany  key1,hany key2,InvokeTickDeclare);
	typedef void (*map_each_t)(hmap_t map, hany key,hany value,hany arg0,hany arg1,InvokeTickDeclare);
	huintptr hash_code_str(hany ,InvokeTickDeclare);
	huintptr hash_code_any(hany ,InvokeTickDeclare);
	hbool equal_str(hany ,hany,InvokeTickDeclare);
	hbool equal_any(hany ,hany ,InvokeTickDeclare);
	hmap_t map_alloc(hint32 capacity,hash_code_t hash_code ,equal_t equal,InvokeTickDeclare);
	void map_dealloc(hmap_t map,InvokeTickDeclare);
	hany map_put(hmap_t map,hany key,hany value,InvokeTickDeclare);
	hany map_get(hmap_t map,hany key,InvokeTickDeclare);
	hany map_remove(hmap_t map,hany key,InvokeTickDeclare);
	hany map_get_and_exist(hmap_t map,hany key,h
/*
** $Id: ldump.c,v 1.19 2011/11/23 17:48:18 lhf Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size*sizeof(char),D);
 }
static void DumpFunction(const Proto* f, DumpState* D);
static void DumpConstants(const Proto* f, DumpState* 

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],D);
static void DumpUpvalues(const Proto* f, DumpState* D)
 int i,n=f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpChar(f->upvalues[i].instack,D);
  DumpChar(f->upvalues[i].idx,D);
 }
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 DumpString((D->strip) ? NULL : f->source,D);
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 
void invoke_adapter_test() {
  using namespace falcon;
	CHECK_EQUAL_VALUE(12, invoke_last_param<2>(plus<>(), 0, 1, 2, 4, 8));
	CHECK_EQUAL_VALUE(3, invoke_first_param<2>(plus<>(), 1, 2, 4, 8));
	CHECK_EQUAL_VALUE(9, invoke_ignore_param<1, 2>(plus<>(), 1, 2, 4, 8));
	CHECK_EQUAL_VALUE(12, invoke_partial_param_loop<2>(plus<>(), 1, 2, 4, 8));
	CHECK_EQUAL_VALUE(15, invoke_partial_recursive_param_loop<2>(plus<>(), 1, 2, 4, 8));
	CHECK_EQUAL_VALUE(25, invoke_partial_recursive_param_loop<2>(plus<>(), 1, 2, 4, 8, 10));
	CHECK_EQUAL_VALUE(5, invoke_partial_recursive_param_loop<2>(plus<>(), 1, 4));
	CHECK_EQUAL_VALUE(6, invoke_range_param<1, 2>(plus<>(), 1, 2, 4, 8));
	CHECK_EQUAL_VALUE(-2, invoke_reverse_param<0, 2>(minus<>(), 4, 2));
  typedef invoke_adapter<range_parameter_index_tag<1, 2>> adapter_type;
  adapter_type adapter;
  CHECK_EQUAL_VALUE(6, adapter(plus<>(), 1, 2, 4, 8));
  CHECK_EQUAL_VALUE(11, adapter(plus<>(), 1, 7, 4, 8));
  CHECK_EQUAL_VALUE(12, adapter(plus<>(), 1, 7, 5, 8));

/*
 * $Id$
 *
 * Copyright 2010 Object Computing, Inc.
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSet::RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","RepoIdSet",6);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::insert_id(RepoId key, RepoId value)
  DBG_ENTRY_LVL("RepoIdSet","insert_id",6);
  return bind(map_, key, value);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::remove_id(RepoId id)
  DBG_ENTRY_LVL("RepoIdSet","remove_id",6);
  int result = unbind(map_, id);
  if (result != 0) {
    VDBG((LM_DEBUG, "(%P|%t) RepoId (%d) not found in map_.\n",id));
  }
  return result;
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSet::size() const
  DBG_ENTRY_LVL("RepoIdSet","size",6);
  return map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map()
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->map_;
ACE_INLINE const OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map() const
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->m
namespace Rd3 
using namespace System;
/**
 * ResourceLoader
 */
class ResourceLoader
public:
	ResourceLoader();
	~ResourceLoader();
	/**
	 *
	 */
	void LoadFromXML( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
	/**
	 *
	 */
	void LoadFromFile( const sString& path, ResLoadParams& loadParams ) throws_error;
	/**
	 *
	 */
	void FreeResources();
private:
	sVector<ResourceObject*>	_loadedResources;
private:
	void LoadTexture( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
	void LoadEffect( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
	void LoadMesh( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
	void LoadVBuffer( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
	void LoadIBuffer( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
	void LoadAfterEffect( const Xml::BaseDomNode& element, ResLoadParams& loadParams ) throws_error;
using namespace std;
using namespace zypp;
class ZypperUtils
private:
  /******************************* Member Declarations *******************************/
  static scoped_ptr<RepoManager> s_repoManager;
  static RepoInfo s_repoInfo;
  static KeyRingReceive s_keyReceiveReport;
public:
  /**
   * Initialize Repositories 
   */
  static void initRepository( const string & repoName, const string & repoUrl );
  
  /**
   * Refresh RepoManager to query meta data of a package
   */
  static void refreshRepoManager();
  
  /**
   * Initialize RepoInfo. Needed to refresh RepoManager
   * RepoInfo contains all the information there is about a repository
   */
  static void initRepoInfo( const string & repoUrl, const string & packageName );
  
  /**
   * Add repository
   */
  static void addRepository( const string & repoUrl, const string & repoAlias = "temp" );
  
   /**
   * Return true if repository exists
   */
  static bool exists( const string & repoUrl );
  /**
   * Returns KeyRing rep
void Chunk_Loader::Open(const char* FileName) {
	Data = fopen(FileName, "rb");
	if (Data) {
		fseek(Data,0,2); fileSize = ftell(Data); fseek(Data,0,0);
		strncpy(fileName,FileName,255);
		fileName[255] = 0;
		/* Wrapper for fread which logs an error if the expected amount
		 * of bytes couldn't be read
		 */
		{								\
			size_t const bytes_expected = (size) * (times);		\
			size_t const bytes_read = fread(			\
				(dest), (size), (times), (src));		\
										\
			if (bytes_expected != bytes_read) {			\
				logWrite("Expected to read %d (%d * %d) bytes from %s into %s but could only read %d bytes in %s:%d (%s)",								\
					bytes_expected, (size), (times),	\
					bytes_read,				\
					__FILE__, __LINE__, __func__		\
				);						\
			}							\
		}								\
		FREAD(fileFormat, 1, 4, Data);
		FREAD(&chunkSize, 4, 1, Data);
		FREAD(&fileVersion, 4, 1, Data);
		chunkPos = 4;
		chunkSize = 4;
		chunkHeader[0] = 0;
	} else {
		chunkSize = 0;
		chunkPos = 0;
	}
void Chunk_Loader::Close() 

	if (Data) fclose(Data);
bool Chunk_Loader::IsFileFormat(const char FormatID[4], uint FormatVersion) {
	if ((Data) && ((strncmp(fileFormat,FormatID,4) == 0) && (fileVersion == FormatVersion))) {
		return true;
	} else return false;
bool Chunk_Loader::IsChunk(const char ChunkID[4]) {
	if ((Data) && (strncmp(chunkHeader,ChunkID,4) == 0)) {
		return true;
	} else return false;
bool Chunk_Loader::ReadChunk() {
	if (Data) {
		if (!fread(chunkHeader,1,4,Data)) return false;
		if (!fread(&chunkSize,4,1,Data)) return false;
		chunkPos = 0;
		if (chunkSize > fileSize-ftell(Data)) {
			logError("Corrupted chunk %c%c%c%c (size %d bytes, only %d bytes left in file",
				chunkHeader[0],chunkHeader[1],chunkHeader[2],chunkHeader[3],
				chunkSize,fileSize-ftell(Data));
		}
		if ((chunkHeader[0] < 0x20) || (chunkHeader[0] > 0x7F) ||
			(chunkHeader[1] < 0x20) || (chunkHeader[1] > 0x7F) ||
			(chunkHeader[2] < 0x20) || (chunkHeader[2] > 0x7F) ||
			(chunkHeader[3] < 0x20) || (chunkHeader[3] > 0x7F)) {

			logError("Corrupted chunk header: %c%c%c%c (size %d bytes)",
				chunkHeader[0],chunkHeader[1],chunkHeader[2],chunkHeader[3],
				chunkSize);
		}
		logWritem("\treading chunk %c%c%c%c (%d bytes)",
			chunkHeader[0],chunkHeader[1],chunkHeader[2],chunkHeader[3],
			chunkSize);
		return true;
	} else return false;
int Chunk_Loader::Read(void* buf, int sz) {
	if ((Data) && (chunkSize > 0)) {
		int i = 0;
		if (chunkPos + sz > chunkSize) {
			logError("Error while reading %s (chunk %c%c%c%c): exceeded chunk bounds (%d req , %d left)",
				fileName,chunkHeader[0],chunkHeader[1],chunkHeader[2],chunkHeader[3],
				sz, chunkSize - chunkPos);
			return 0;
		}
		if (buf) i = sz*fread(buf,sz,1,Data);
		chunkPos += i;
		return i;
	} else return 0;
int Chunk_Loader::ReadString(char buf[256]) {
	unsigned char stringLen;
	int sz = Read(&stringLen,1);
	if (sz) {
		if (stringLen) sz += Read(buf,stringLen);
		buf[stringLen] = '\0';
	return sz;
bool Chunk_Loader::IsEndOfChunk() {
	if (chunkPos >= chun
/* -*- C++ -*- */
/*
  This heap manages memory in units of Chunks.
  malloc returns a slot within a chunk,
  while free returns slots back to a chunk.
  
  Once a chunk is COMPLETELY empty, it is returned to the superheap.
*/
template <int chunkSize, int slotSize, class Super>
class LazySlotHeap : public Super {
public:
  LazySlotHeap (void)
    : myChunk (new (Super::malloc (sz)) Chunk<chunkSize, slotSize>())
  {}
  ~LazySlotHeap (void)
  {
    Super::free (myChunk);
  }
  inline void * malloc (size_t sz) {
    assert (sz == chunkSize);
    void * ptr = myChunk->getSlot();
    if (ptr == NULL) {
      myChunk = new (Super::malloc (sz)) Chunk<chunkSize, slotSize>();
      ptr = myChunk->getSlot();
      assert (ptr != NULL);
    }
    return ;
  }
  inline void free (void * ptr) {
    Chunk<chunkSize, slotSize> * ch = Chunk<chunkSize, slotSize>::getChunk (ptr);
    ch->putSlot (ptr);
    if (ch->getNumSlotsAvailable() == ch->getNumSlots()) {
      if (ch == myChunk) {
	myChunk = new (
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
namespace mozilla {
class LoadInfoUpdateRunner;
class LoadInfoCollectRunner;
class LoadNotificationCallback
public:
    virtual void LoadChanged(float aSystemLoad, float aProcessLoad) = 0;
};
class LoadMonitor MOZ_FINAL : public nsIObserver
public:
    NS_DECL_THREADSAFE_ISUPPORTS
    NS_DECL_NSIOBSERVER
    explicit LoadMonitor(int aLoadUpdateInterval);
    nsresult Init(nsRefPtr<LoadMonitor> &self);
    void SetLoadChangeCallback(LoadNotificationCallback* aCallback);
    void Shutdown();
    float GetSystemLoad();
    float GetProcessLoad();
    friend class LoadInfoCollectRunner;
private:
    ~LoadMonitor();
    void SetProcessLoad(float load);
    void SetSystemLoad(float load);
    void FireCallbacks();
    int                  mLoadUpdateInterval;
    mozilla::
                                                                                                                                                                                                                                
                                                                                                                                                                                                                                
                                                                                                                                                                                                                                struct Dump : std::ofstream
                                                                                                                                                                                                                                {
                                                                        

                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                        (*f) << text;
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                    Dump(Dump&& rhs) : f(std::move(rhs.f)) {}
                       

                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                Dump files[] = { Dump("main.cpp", R"delim(
int main()
    std::cout << sum(3, 4) << std::endl;
}    
                                                                                                                                                                                                                                                )delim"), Dump("a.h", R"delim(
int sum(int, int);
                                                                                                                                             

                                                                                
int sum(int a, int b) { return a + b; }
                                                                                                                                                                                                                                                )delim") };
                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                
                                                                                                                                                
/*
Copyright (C) 1997-2001 Id Software, Inc.
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
typedef struct
	menuFramework_s	menu;
	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuPicButton_s	save;
	menuPicButton_s	load;
	menuPicButton_s	done;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];
} uiSaveLoad_t;
static uiSaveLoad_t	uiSaveLoad;
/*
==========

UI_SaveLoad_Callback
=================
*/
static void UI_SaveLoad_Callback( void *self, int event )
	menuCommon_s	*item = (menuCommon_s *)self;
	if( event != QM_ACTIVATED )
		return;
	switch( item->id )
	{
	case ID_LOAD:
		UI_LoadGame_Menu();
		break;
	case ID_SAVE:
		UI_SaveGame_Menu();
		break;
	case ID_DONE:
		UI_PopMenu();
		break;
	}
/*
=================
UI_SaveLoad_Init
=================
*/
static void UI_SaveLoad_Init( void )
	memset( &uiSaveLoad, 0, sizeof( uiSaveLoad_t ));
	uiSaveLoad.menu.vidInitFunc = UI_SaveLoad_Init;
	strcat( uiSaveLoad.hintText, "During play, you can quickly save your game by pressing " );
	strcat( uiSaveLoad.hintText, KEY_KeynumToString( KEY_GetKey( "save quick" )));
	strcat( uiSaveLoad.hintText, ".\nLoad this game again by pressing " );
	strcat( uiSaveLoad.hintText, KEY_KeynumToString( KEY_GetKey( "load quick" )));
	strcat( uiSaveLoad.hintText, ".\n" );
	uiSaveLoad.background.generic.id = ID_BACKGROUND;
	uiSaveLoad.background.generic.type = QMTYPE_BITM

	uiSaveLoad.background.generic.flags = QMF_INACTIVE;
	uiSaveLoad.background.generic.x = 0;
	uiSaveLoad.background.generic.y = 0;
	uiSaveLoad.background.generic.width = 1024;
	uiSaveLoad.background.generic.height = 768;
	uiSaveLoad.background.pic = ART_BACKGROUND;
	uiSaveLoad.banner.generic.id = ID_BANNER;
	uiSaveLoad.banner.generic.type = QMTYPE_BITMAP;
	uiSaveLoad.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiSaveLoad.banner.generic.x = UI_BANNER_POSX;
	uiSaveLoad.banner.generic.y = UI_BANNER_POSY;
	uiSaveLoad.banner.generic.width = UI_BANNER_WIDTH;
	uiSaveLoad.banner.generic.height = UI_BANNER_HEIGHT;
	uiSaveLoad.banner.pic = ART_BANNER;
	uiSaveLoad.load.generic.id = ID_LOAD;
	uiSaveLoad.load.generic.type = QMTYPE_BM_BUTTON;
	uiSaveLoad.load.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiSaveLoad.load.generic.name = "Load game";
	uiSaveLoad.load.generic.statusText = "Load a previously saved game";
	uiSaveLoad.load.generic.x = 72;
	uiSaveLoad.load.gene

	uiSaveLoad.load.generic.callback = UI_SaveLoad_Callback;
	UI_UtilSetupPicButton( &uiSaveLoad.load, PC_LOAD_GAME );
	uiSaveLoad.save.generic.id = ID_SAVE;
	uiSaveLoad.save.generic.type = QMTYPE_BM_BUTTON;
	uiSaveLoad.save.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiSaveLoad.save.generic.name = "Save game";
	uiSaveLoad.save.generic.statusText = "Save current game";
	uiSaveLoad.save.generic.x = 72;
	uiSaveLoad.save.generic.y = 280;
	uiSaveLoad.save.generic.callback = UI_SaveLoad_Callback;
	UI_UtilSetupPicButton( &uiSaveLoad.save, PC_SAVE_GAME );
	uiSaveLoad.done.generic.id = ID_DONE;
	uiSaveLoad.done.generic.type = QMTYPE_BM_BUTTON;
	uiSaveLoad.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiSaveLoad.done.generic.name = "Done";
	uiSaveLoad.done.generic.statusText = "Go back to the Main Menu";
	uiSaveLoad.done.generic.x = 72;
	uiSaveLoad.done.generic.y = 330;
	uiSaveLoad.done.generic.callback = UI_SaveLoad_Callback;
	UI_UtilSetupPicButton( &

	uiSaveLoad.hintMessage.generic.id = ID_MSGHINT;
	uiSaveLoad.hintMessage.generic.type = QMTYPE_ACTION;
	uiSaveLoad.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiSaveLoad.hintMessage.generic.color = uiColorHelp;
	uiSaveLoad.hintMessage.generic.name = uiSaveLoad.hintText;
	uiSaveLoad.hintMessage.generic.x = 360;
	uiSaveLoad.hintMessage.generic.y = 480;
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.background );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.banner );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.load );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.save );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.done );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.hintMessage );
/*
=================
UI_SaveLoad_Precache
=================
*/
void UI_SaveLoad_Precache( void )
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
/*
=================
UI_SaveLoad_Menu
=================
*/
void UI_SaveLoad_Menu( void )
	if( gMenu.m_gameinfo.ga
namespace thelonious {
namespace dsp {
namespace delays {
class Reverb : public Processor<1, 1> {
public:
    Reverb(Sample time=0.7, Sample mix=0.2) : time(time), mix(mix) {}
    void tick(Block<1> &inputBlock, Block<1> &outputBlock) {
        Chock timeChock = time.get();
        Chock mixChock = mix.get();
        for (uint32_t i=0; i<constants::BLOCK_SIZE; i++) {
            Sample inputSample = inputBlock[0][i];
            Sample time = timeChock[i];
            Sample mix = mixChock[i];
            Sample bufferSample = inputAp1[inputApIndex1];
            Sample delaySample = inputBlock[0][i] + 0.625 * bufferSample;
            inputAp1[inputApIndex1] = delaySample;
            Sample outputSample = bufferSample - 0.625 * delaySample;
            bufferSample = inputAp2[inputApIndex2];
            delaySample = outputSample + 0.625 * bufferSample;
            inputAp2[inputApIndex2] = delaySample;
            outputSample = bufferSample - 0.625 * delaySample;
            buffer

            delaySample = outputSample + 0.625 * bufferSample;
            inputAp3[inputApIndex3] = delaySample;
            outputSample = bufferSample - 0.625 * delaySample;
            bufferSample = inputAp4[inputApIndex4];
            delaySample = outputSample + 0.625 * bufferSample;
            inputAp4[inputApIndex4] = delaySample;
            outputSample = bufferSample - 0.625 * delaySample;
            Sample sampleA = loopDelay1[loopDelayIndex1] * time;
            Sample sampleB = loopDelay2[loopDelayIndex2] * time;
            bufferSample = loopAp1[loopApIndex1];
            delaySample = sampleA + 0.625 * bufferSample;
            inputAp2[inputApIndex2] = delaySample;
            sampleA = bufferSample - 0.625 * delaySample;
            bufferSample = loopAp2[loopApIndex2];
            delaySample = sampleB + 0.625 * bufferSample;
            inputAp2[inputApIndex2] = delaySample;
            sampleB = bufferSample - 0.625 * delaySample;
            loopDelay1[loopDe

            loopDelay2[loopDelayIndex2] = sampleA;
            outputBlock[0][i] = inputSample * (1.f - mix ) +
                                (sampleA + sampleB) * mix;
            inputApIndex1++;
            inputApIndex1 %= inputAp1.size();
            inputApIndex2++;
            inputApIndex2 %= inputAp2.size();
            inputApIndex3++;
            inputApIndex3 %= inputAp3.size();
            inputApIndex4++;
            inputApIndex4 %= inputAp4.size();
            loopDelayIndex1++;
            loopDelayIndex1 %= loopDelay1.size();
            loopDelayIndex2++;
            loopDelayIndex2 %= loopDelay2.size();
            loopApIndex1++;
            loopApIndex1 %= loopAp1.size();
            loopApIndex2++;
            loopApIndex2 %= loopAp2.size();
        }
    }
    Parameter time;
    Parameter mix;
private:
    Channel<122> inputAp1;
    Channel<303> inputAp2;
    Channel<553> inputAp3;
    Channel<922> inputAp4;
    uint32_t inputApIndex1;
    uint32_t inputApIn
using base::StringPiece;
namespace net {
namespace test {
void QuicStreamPeer::SetWriteSideClosed(bool value, QuicStream* stream) {
  stream->write_side_closed_ = value;
void QuicStreamPeer::SetStreamBytesWritten(
    QuicStreamOffset stream_bytes_written,
    QuicStream* stream) {
  stream->stream_bytes_written_ = stream_bytes_written;
bool QuicStreamPeer::read_side_closed(QuicStream* stream) {
  return stream->read_side_closed();
void QuicStreamPeer::CloseReadSide(QuicStream* stream) {
  stream->CloseReadSide();
bool QuicStreamPeer::FinSent(QuicStream* stream) {
  return stream->fin_sent_;
bool QuicStreamPeer::FinReceived(QuicStream* stream) {
  return stream->fin_received_;
bool QuicStreamPeer::RstSent(QuicStream* stream) {
  return stream->rst_sent_;
bool QuicStreamPeer::RstReceived(QuicStream* stream) {
  return stream->rst_received_;
bool QuicStreamPeer::ReadSideClosed(QuicStream* stream) {
  return stream->read_side_closed_;
bool QuicStreamPeer::WriteSideClosed(QuicStream* strea
template< typename sample_t>
class analyze_mutator
public:
	typedef sample_t sample_type;
	typedef typename sampletraits<sample_type>::channel_type channel_type;
	struct typed_information
	{
		typed_information()
			:
				sum( sampletraits<sample_type>::expand_to_channels( 0.0)),
				sum_abs( sampletraits<sample_type>::expand_to_channels( 0.0)),
				max( sampletraits<sample_type>::get_min()),
				min( sampletraits<sample_type>::get_max()),
				count( 0)
		{
		}
		operator sound_analysis() const
		{
			sound_analysis result;
			result.avg = normalize_sample( channel_type(average_of_channels( sum)/count));
			result.norm= normalize_sample( channel_type(average_of_channels( sum_abs)/count));
			result.max = normalize_sample( max_of_channels( max));
			result.min = normalize_sample( min_of_channels( min));
			return result;
		}
		void reset()
		{
			*this = typed_information();
		}
		typename sampletraits<sample_type>::template foreach_channel_type<double>::type sum;
		typename sampletrait

		sample_type max;
		sample_type min;
		sampleno count;
		inline double get_average() { return sum/count;}
	};
	typedef typed_information result_information_type;
	void MutateHeader( const stream_header &)
	{
	}
	void Mutate( const sample_t *sample)
	{
		state.max = max_sample( state.max, *sample);
		state.min = min_sample( state.min, *sample);
		state.sum += *sample;
		state.sum_abs += abs( typename sampletraits<sample_t>::template foreach_channel_type<double>::type( *sample));
		++state.count;
	}
	void Reset()
	{
		state.reset();
	}
	typed_information GetResult()
	{
		return  state;
	}
private:
	template <typename sampletype>
		inline static double average_of_channels( const sampletype &sample)
	{
		return sample;
	}
	template <typename sampletype>
		inline static double average_of_channels( const StereoSample< sampletype> &sample)
	{
		typedef typename sampletraits<sampletype>::accumulator_type accu_type;
		return (double( average_of_channels( sample.m_left)) +
				double( average_

	}
	template <typename sampletype>
	inline static sampletype max_of_channels( const sampletype &sample)
	{
		return sample;
	}
	template <typename sampletype>
		inline static sampletype max_of_channels( const StereoSample< sampletype> &sample)
	{
		return max_sample( sample.m_left, sample.m_right);
	}
	template <typename sampletype>
	inline static sampletype min_of_channels( const sampletype &sample)
	{
		return sample;
	}
	template <typename sampletype>
		inline static sampletype min_of_channels( const StereoSample< sampletype> &sample)
	{
		return min_sample( sample.m_left, sample.m_right);
	}
	typed_information state;
};
template< typename sample_type>
struct typed_analyzer : public uniform_block_mutator< analyze_mutator< sample_type>, sample_analyzer >
	typedef uniform_block_mutator< analyze_mutator< sample_type>, sample_analyzer > parent_type;
	virtual sound_analysis GetResult()
	{
		return parent_type::m_sample_mutator.GetResult();
	}
	virtual void Reset()
	{
		parent_type::m_sa
/* Copyright (C) 2003 MySQL AB
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
HandleDbc::FuncTab
HandleDbc::m_funcTab[] = {
    {   SQL_API_SQLALLOCCONNECT       , 1  },
    {   SQL_API_SQLALLOCENV           , 1  },
    {   SQL_API_SQLALLOCHANDLE        , 1  },
    {   SQL_API_SQLALLOCHANDLESTD     , 0  },
    {   SQL_API_SQLALLOCSTMT 

    {   SQL_API_SQLBINDCOL            , 1  },
    {   SQL_API_SQLBINDPARAM          , 1  },
    {   SQL_API_SQLBINDPARAMETER      , 1  },
    {   SQL_API_SQLBROWSECONNECT      , 0  },
    {   SQL_API_SQLBULKOPERATIONS     , 0  },
    {   SQL_API_SQLCANCEL             , 1  },
    {   SQL_API_SQLCLOSECURSOR        , 1  },
    {   SQL_API_SQLCOLATTRIBUTE       , 1  },
    {   SQL_API_SQLCOLATTRIBUTES      , 1  },
    {   SQL_API_SQLCOLUMNPRIVILEGES   , 0  },
    {   SQL_API_SQLCOLUMNS            , 1  },
    {   SQL_API_SQLCONNECT            , 1  },
    {   SQL_API_SQLCOPYDESC           , 0  },
    {   SQL_API_SQLDATASOURCES        , 0  },
    {   SQL_API_SQLDESCRIBECOL        , 1  },
    {   SQL_API_SQLDESCRIBEPARAM      , 0  },
    {   SQL_API_SQLDISCONNECT         , 1  },
    {   SQL_API_SQLDRIVERCONNECT      , 1  },
    {   SQL_API_SQLDRIVERS            , 0  },
    {   SQL_API_SQLENDTRAN            , 1  },
    {   SQL_API_SQLERROR              , 1  },
    {   SQL_API_SQLEXECDIRECT    

    {   SQL_API_SQLEXECUTE            , 1  },
    {   SQL_API_SQLEXTENDEDFETCH      , 0  },
    {   SQL_API_SQLFETCH              , 1  },
    {   SQL_API_SQLFETCHSCROLL        , 0  },
    {   SQL_API_SQLFOREIGNKEYS        , 0  },
    {   SQL_API_SQLFREECONNECT        , 1  },
    {   SQL_API_SQLFREEENV            , 1  },
    {   SQL_API_SQLFREEHANDLE         , 1  },
    {   SQL_API_SQLFREESTMT           , 1  },
    {   SQL_API_SQLGETCONNECTATTR     , 1  },
    {   SQL_API_SQLGETCONNECTOPTION   , 1  },
    {   SQL_API_SQLGETCURSORNAME      , 1  },
    {   SQL_API_SQLGETDATA            , 1  },
    {   SQL_API_SQLGETDESCFIELD       , 1  },
    {   SQL_API_SQLGETDESCREC         , 1  },
    {   SQL_API_SQLGETDIAGFIELD       , 1  },
    {   SQL_API_SQLGETDIAGREC         , 1  },
    {   SQL_API_SQLGETENVATTR         , 1  },
    {   SQL_API_SQLGETFUNCTIONS       , 1  },
    {   SQL_API_SQLGETINFO            , 1  },
    {   SQL_API_SQLGETSTMTATTR        , 1  },
    {   SQL_API_SQLGETSTMTOPTION 

    {   SQL_API_SQLGETTYPEINFO        , 1  },
    {   SQL_API_SQLMORERESULTS        , 1  },
    {   SQL_API_SQLNATIVESQL          , 0  },
    {   SQL_API_SQLNUMPARAMS          , 1  },
    {   SQL_API_SQLNUMRESULTCOLS      , 1  },
    {   SQL_API_SQLPARAMDATA          , 1  },
    {   SQL_API_SQLPARAMOPTIONS       , 0  },
    {   SQL_API_SQLPREPARE            , 1  },
    {   SQL_API_SQLPRIMARYKEYS        , 1  },
    {   SQL_API_SQLPROCEDURECOLUMNS   , 0  },
    {   SQL_API_SQLPROCEDURES         , 0  },
    {   SQL_API_SQLPUTDATA            , 1  },
    {   SQL_API_SQLROWCOUNT           , 1  },
    {   SQL_API_SQLSETCONNECTATTR     , 1  },
    {   SQL_API_SQLSETCONNECTOPTION   , 1  },
    {   SQL_API_SQLSETCURSORNAME      , 1  },
    {   SQL_API_SQLSETDESCFIELD       , 1  },
    {   SQL_API_SQLSETDESCREC         , 1  },
    {   SQL_API_SQLSETENVATTR         , 1  },
    {   SQL_API_SQLSETPARAM           , 1  },
    {   SQL_API_SQLSETPOS             , 0  },
    {   SQL_API_SQLSETSCROLLOPTIO
/*================================================================================
  code generated by: java2cpp
  class: org.xml.sax.helpers.LocatorImpl
================================================================================*/
namespace j2cpp { namespace org { namespace xml { namespace sax { class Locator; } } } }
namespace j2cpp { namespace java { namespace lang { class String; } } }
namespace j2cpp { namespace java { namespace lang { class Object; } } }
namespace j2cpp {
namespace org { namespace xml { namespace sax { namespace helpers {
	class LocatorImpl;
	class LocatorImpl
		: public object<LocatorImpl>
	{
	public:
		J2CPP_DECLARE_CLASS
		J2CPP_DECLARE_METHOD(0)
		J2CPP_DECLARE_METHOD(1)
		J2CPP_DECLARE_METHOD(2)
		J2CPP_DECLARE_METHOD(3)
		J2CPP_DECLARE_METHOD(4)
		J2CPP_DECLARE_METHOD(5)
		J2CPP_DECLARE_METHOD(6)
		J2CPP_DECLARE_METHOD(7)
		J2CPP_DECLARE_METHOD(8)
		J2CPP_DECLARE_METHOD(9)
		explicit LocatorImpl(jobject jobj)
		: object<LocatorImpl>(jobj)
		{
		}
		ope

		operator local_ref<java::lang::Object>() const;
		LocatorImpl();
		LocatorImpl(local_ref< org::xml::sax::Locator > const&);
		local_ref< java::lang::String > getPublicId();
		local_ref< java::lang::String > getSystemId();
		jint getLineNumber();
		jint getColumnNumber();
		void setPublicId(local_ref< java::lang::String >  const&);
		void setSystemId(local_ref< java::lang::String >  const&);
		void setLineNumber(jint);
		void setColumnNumber(jint);
namespace j2cpp {
org::xml::sax::helpers::LocatorImpl::operator local_ref<org::xml::sax::Locator>() const
	return local_ref<org::xml::sax::Locator>(get_jobject());
org::xml::sax::helpers::LocatorImpl::operator local_ref<java::lang::Object>() const
	return local_ref<java::lang::Object>(get_jobject());
org::xml::sax::helpers::LocatorImpl::LocatorImpl()
: object<org::xml::sax::helpers::LocatorImpl>(
	call_new_object<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(0),
		org::xm

	>()
org::xml::sax::helpers::LocatorImpl::LocatorImpl(local_ref< org::xml::sax::Locator > const &a0)
: object<org::xml::sax::helpers::LocatorImpl>(
	call_new_object<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(1),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(1)
	>(a0)
local_ref< java::lang::String > org::xml::sax::helpers::LocatorImpl::getPublicId()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(2),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(2), 
		local_ref< java::lang::String >
	>(get_jobject());
local_ref< java::lang::String > org::xml::sax::helpers::LocatorImpl::getSystemId()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(3),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(3), 
		local_ref<

	>(get_jobject());
jint org::xml::sax::helpers::LocatorImpl::getLineNumber()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(4),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(4), 
		jint
	>(get_jobject());
jint org::xml::sax::helpers::LocatorImpl::getColumnNumber()
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(5),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(5), 
		jint
	>(get_jobject());
void org::xml::sax::helpers::LocatorImpl::setPublicId(local_ref< java::lang::String > const &a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(6),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(6), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setSystemId(local_ref< 

	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(7),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(7), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setLineNumber(jint a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(8),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(8), 
		void
	>(get_jobject(), a0);
void org::xml::sax::helpers::LocatorImpl::setColumnNumber(jint a0)
	return call_method<
		org::xml::sax::helpers::LocatorImpl::J2CPP_CLASS_NAME,
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_NAME(9),
		org::xml::sax::helpers::LocatorImpl::J2CPP_METHOD_SIGNATURE(9), 
		void
	>(get_jobject(), a0);
J2CPP_DEFINE_CLASS(org::xml::sax::helpers::LocatorImpl,"org/xml/sax/helpers/LocatorImpl")
J2CPP_DEFINE_METHOD(org::xml::sax::helpers::LocatorImpl,0,"<init>","(
/*
 * streams_functions.h
 *
 * \brief wrapper functions with pointer checks for stream interface
 * 
 * Created: 07/06/2012 21:07:26
 *  Author: sfx
 */
static uint8_t inline bytestream_get(byte_stream_t *stream) {
	RUN_IF((stream->get!=NULL),STREAM_ERROR, WARNING, "stream get: null pointer\n")  {
		return stream->get(stream->data);
	}
	return 0;
static int8_t inline bytestream_put(byte_stream_t *stream, uint8_t element) {
	RUN_IF((stream->put!=NULL),STREAM_ERROR, WARNING, "stream put: null pointer\n")  {
		stream->put(stream->data, element);
		return 1;
	}
	return -1;
static void inline bytestream_flush(byte_stream_t *stream) {
	RUN_IF((stream->flush!=NULL),STREAM_ERROR, WARNING, "stream flush: null pointer\n")  {
		stream->flush(stream->data);
	}
static void inline bytestream_start_transmission(byte_stream_t *stream) {
	RUN_IF((stream->start_transmission!=NULL),STREAM_ERROR, WARNING, "stream start transmission: null pointer\n")  {
		stream->start_transmission(stream->data);
	}
stati

	RUN_IF((stream->clear_stream!=NULL),STREAM_ERROR, WARNING, "stream clear: null pointer\n")  {
		stream->clear_stream(stream->data);
	}
static bool inline bytestream_buffer_empty(byte_stream_t *stream) {
	RUN_IF((stream->buffer_empty!=NULL),STREAM_ERROR, WARNING, "stream buffer_empty: null pointer\n")  {
		return stream->buffer_empty(stream->data);
	}
	return false;
static int inline bytestream_bytes_available(byte_stream_t *stream) {
	RUN_IF((stream->bytes_available!=NULL),STREAM_ERROR, WARNING, "stream bytes_available: null pointer\n")  {
		return stream->bytes_available(stream->data);
	}
	return -1;
typedef struct packet_t {
	char *data;
	int size;
} packet_t;
typedef struct packet_stream_t {
	int		(*put)(stream_data_t *data, packet_t *packet);
	int     (*buffer_empty)(stream_data_t *data);
	int     (*packets_available)(stream_data_t *data);
	volatile stream_data_t data;
} packet_stream_t;
static packet_t inline packet_get(packet_stream_t *stream) {
	RUN_IF((stream->put!=NULL),STRE
/*
 *     SocialLedge.com - Copyright (C) 2013
 *
 *     This file is part of free software framework for embedded processors.
 *     You can use it and/or distribute it as long as this copyright header
 *     remains unmodified.  The code is free for personal use and requires
 *     permission to use in a commercial product.
 *
 *      THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 *      OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 *      MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 *      I SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
 *      CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 *     You can reach the author of this software at :
 *          p r e e t . w i k i @ g m a i l . c o m
 */
/**
 * @file
 * @brief Contains the terminal handler function declarations.
 *
 * 12082013 : Added I2C handler
 */
CMD_HANDLER_FUNC(taskListHandler);
CMD_HANDLER_FUNC(memInf
namespace ld3d
	namespace voxel
	{
		class ChunkLoader
		{
		public:
			typedef std::function<void(const ChunkKey&)>			ChunkLoadedHandler;
			ChunkLoader(void);
			virtual ~ChunkLoader(void);
			bool													Initialize(ChunkManagerPtr pChunkManager, OctreeManagerPtr pOctreeManager, MeshizerPtr pMeshizer, WorldGenPtr pWorldGen);
			void													Release();
			void													Update();
			uint32													GetPendingCount() const;
			bool													RequestChunk(const Coord& center, uint32 radius, uint32 height, const std::function<bool(const ChunkKey&)>& pre_load);
			bool													RequestChunk(const ChunkKey& key, const ChunkLoadedHandler& on_loaded);
			bool													RequestUnloadChunk(const ChunkKey& key);
			bool													RequestUnloadChunk(ChunkPtr pChunk);
			bool													RequestMesh(ChunkPtr pChunk);
			
		private:
			void													_on_mesh_gen_complete(const ChunkKey& key, ChunkMesh* mesh);
			void													_on_chunk_gen_complete(const ChunkKey& key,
using namespace std;
using namespace ntse;
/**
 * å¯¹æ ·æ¬è¿è¡éæ ·åæ
 *
 * @param session  ä¼è¯
 * @param object  å¯æ«æçæ¨¡åæä¾çæ«æå¯¹è±¡
 * @param maxSample  æå¤§éæ ·æ°ç®ï¼è¿ä¸ªåå«å°æ ·æ¬åºåå¤§æ ·æ¬åºä¹å
 * @param smallScanPct  å°æ ·æ¬åºéæ ·çæ¯ä¾
 * @param scanBig  æ¯å¦éæ ·å¤§æ ·æ¬åº
 * @param difference  å¤æ¬¡éæ ·æ¶ï¼ç¸éä¸¤æ¬¡éæ ·çå·®å¼åº¦ï¼è¿ä¸ªå¼è¶å°ï¼å¯¹äºå¤æ¬¡å¹³è¡éæ ·çç»æç¸ä¼¼åº¦è¦æ±è¶é«
 * @param bScanTimes  å¤§éæ ·åºéæ ·åæ¹è¿è¡çæ¬¡æ°
 * @return  éæ ·åæç»æ
 */
SampleResult * SampleAnalyse::sampleAnalyse(Session *session, Analysable *object, int maxSample, int smallScanPct,
											bool scanBig, double difference, int bScanTimes) {
	assert(maxSample > 0);
	if (!smallScanPct && !scanBig)
	u64 mcsavept = session->getMemoryContext()->setSavepoint();
	assert(smallScanPct >= 0 && smallScanPct <= 100);
	uint smallSampleCnt = 0, bigSampleCnt = 0;
	Sample **sScanSamples = NULL, **bScanSamples = NULL;
	SampleID *bSIDs = NULL;
	SampleResult *smallSampleResult = NULL, *bigSampleResult = NULL;
	SampleHandle *handle;
	Sample *sample;
	if (smallScanPct) {
		/* éè¦è¿è¡å°æ ·æ¬åºæ«æ */
		int count = maxSample * smallScanPct /

		if (count > 0) {
			handle = object->beginSample(session, count, true);
			while (count-- && (sample = object->sampleNext(handle)) != NULL) {
				sScanSamples[smallSampleCnt++] = sample;
			}
			object->endSample(handle);
		}
		if (smallSampleCnt) {
			smallSampleResult = analyse(sScanSamples, smallSampleCnt);
		} else {
			smallScanPct = 0;
		}
	}
	if (scanBig && !(smallScanPct == 100)) {
		/* å¤§æ ·æ¬åæ¹éæ · */
		/* ç¬¬ä¸æ¬¡éæ ·ï¼åå°æ ·æ¬åºç»æè¿è¡æ¯è¾ */
		Hash<SampleID, Sample *> sidHT(bSampleTotal);
		if (0 == count) count = 1;
		handle = object->beginSample(session, count, false);
		while (count-- && (sample = object->sampleNext(handle)) != NULL) {
				sidHT.remove(sample->m_ID);
			}
			sidHT.put(sample->m_ID, sample);
		}
		object->endSample(handle);
		sidHT.elements(bSIDs, bScanSamples);
		bigSampleCnt = (uint)sidHT.getSize();
		bigSampleResult = analyse(bScanSamples, bigSampleCnt);
		/* æ¯è¾bigç»æåsmallç»æ */
		if (!smallScanPct || !compareResult(smallSampleResult, bigSampleResult, difference)) {
			if 

			SampleResult *tmpResutl;
				handle = object->beginSample(session, count, false);
				int samCnt = 0;
				while (samCnt < count && (sample = object->sampleNext(handle)) != NULL) {
					tmpSample[samCnt++] = sample;
				}
				object->endSample(handle);
				tmpResutl = analyse(tmpSample, samCnt);
				bool isSimilar = compareResult(tmpResutl, bigSampleResult, difference);
				for (int i = 0; i < samCnt; ++i) {
						sidHT.remove(tmpSample[i]->m_ID);
					}
					sidHT.put(tmpSample[i]->m_ID, tmpSample[i]);
				}
				delete tmpResutl;
				delete bigSampleResult;
				sidHT.elements(bSIDs, bScanSamples);
				bigSampleCnt = (uint)sidHT.getSize();
				bigSampleResult = analyse(bScanSamples, bigSampleCnt);
				if (isSimilar) break;
			}
		}
	}
	/* æ¸çsample */
	/* ä½¿ç¨MemoryContextä¸éè¦æå¨éæ¾åå­
	if (smallSampleCnt) {
		for (uint i = 0; i < smallSampleCnt; ++i) {
			delete sScanSamples[i];
		}
	}
	*/
	/*
	if (smallScanPct) {
		delete [] sScanSamples;
	}*/
	/* ä½¿ç¨MemoryContextä¸éè¦æå¨éæ¾åå­
	if (bigSampleC

		for (uint i = 0; i < bigSampleCnt; ++i) {
			delete bScanSamples[i];
		}
		delete [] bScanSamples;
		delete [] bSIDs;
	}*/
	session->getMemoryContext()->resetToSavepoint(mcsavept);
	/* è¿åç»æ */
	if (bigSampleCnt) {
		assert(bigSampleResult != NULL);
		if (smallSampleResult)
			delete smallSampleResult;
		return bigSampleResult;
	} else {
		assert(bigSampleResult == NULL);
		return smallSampleResult;
	}
/**
 * åææ ·æ¬ï¼è¿åç»æ
 * 
 * @param samples  Sampleæéæ°ç»
 * @param numSample  æ°ç»ä¸­çSampleæéä¸ªæ°
 */
SampleResult * SampleAnalyse::analyse(Sample **samples, int numSample) {
	long *fieldSum;		/** ååçå */
	double *delta2Sum;	/** ååçåå¼å·®æ¹å */
	assert(numSample > 0 && samples);
	int numFields = samples[0]->getFieldNum();
	fieldSum = new long[numFields];
	delta2Sum = new double[numFields];
	SampleResult *result = new SampleResult(numFields);
	/* è®¡ç®ååå */
	for (int fi = 0; fi < numFields; ++fi) {
		fieldSum[fi] = 0;
		for (int si = 0; si < numSample; ++si) {
			fieldSum[fi] += (*samples[si])[fi];
		}


		result->m_fieldCalc[fi].m_average = (double)fieldSum[fi] / (double)numSample;
	}
	/* è®¡ç®ååæ¹å·®å */
	for (int fi = 0; fi < numFields; ++fi) {
		delta2Sum[fi] = .0;
		for (int si = 0; si < numSample; ++si) {
			double avgDiff = result->m_fieldCalc[fi].m_average - (*samples[si])[fi];
			delta2Sum[fi] += avgDiff * avgDiff;
		}
		/* è®°å½æ¹å·®åå¼ */
		result->m_fieldCalc[fi].m_delta = sqrt(delta2Sum[fi] / (double)numSample);
	}
	delete [] fieldSum;
	delete [] delta2Sum;
	result->m_numSamples = numSample;
	return result;
/**
 * æ£æ¥ä¸¤ä¸ªSampleAnalyseæ¯å¦ç¬¦å¨ç»å®çå·®å¼åº¦èå´ä¹åã
 *
 * @param first, second  ä¸¤ä¸ªéæ ·ç»æ
 * @param difference  ç¸ä¼¼åº¦å®¹è®¸å·®å¼èå´ï¼å°±æ¯ä¸¤ä¸ªéæ ·ç»æåå¼å·®ååèªæ¹å·®çæ¯ä¾ã
 * @return  å¨å®¹è®¸èå´åä¸ºtrueï¼å¦åè¿åfalse
 */
bool SampleAnalyse::compareResult(SampleResult *first, SampleResult *second, double difference) {
	assert(first->m_numFields == second->m_numFields);
	bool isSimilar = true;
	for (int fi = 0; fi < first->m_numFields; ++fi) {
		double diff = first->m_fieldCalc[fi].m_average - second->m_fieldCalc[fi].m_average;
		if (dif
window::window(repository *repo) {
    this->repo = repo;
    this->setFixedSize(550,350);
    QVBoxLayout *mainlayout = new QVBoxLayout(this);
    QVBoxLayout *inputtable = new QVBoxLayout;
    repo->aktie.setFixedWidth(111);
    repo->timerange.setFixedWidth(25);
    QLabel *aktietext = new QLabel;
    aktietext->setText("Aktie:");
    QLabel *texttimerange = new QLabel;         
    texttimerange->setText("Zeitspanne:");  
    repo->timerangeunit.addItem(tr("Tage"));
    repo->timerangeunit.addItem(tr("Monate"));
    repo->timerangeunit.addItem(tr("Jahre"));
    repo->timerangeunit.setFixedWidth(80);
    repo->aktie.setText("^GDAXI");
    repo->timerange.setText("5");
    QPushButton *GoButton = new QPushButton("GO");
    GoButton->setMaximumWidth(112);
    
    this->renew(); 
    
    connect(GoButton,SIGNAL(clicked()),this,SLOT(renew()));
    QHBoxLayout *firstinputline = new QHBoxLayout;
    QHBoxLayout *secondinputline = new QHBoxLayout;
    QHBoxLayout *thirdinputline = new QH

    inputtable->addLayout(firstinputline, 0);
    firstinputline->addStretch(1);
    firstinputline->addWidget(aktietext, 0);
    firstinputline->addWidget(&repo->aktie, 1);
    
    
    inputtable->addLayout(secondinputline, 1);
    secondinputline->addStretch(1);
    secondinputline->addWidget(texttimerange, 0);
    secondinputline->addWidget(&repo->timerange, 1);
    secondinputline->addWidget(&repo->timerangeunit,2);
   
    inputtable->addLayout(thirdinputline, 2);
    thirdinputline->addStretch(2);
    thirdinputline->addWidget(GoButton, 2);
    mainlayout->addLayout(inputtable, 0);
    mainlayout->addStretch(0);
};
char window::timerangeletter(){
    
    if(repo->timerangeunit.currentText()=="Monate")return 'm';
    else if(repo->timerangeunit.currentText()=="Jahre")return 'y';
    else if(repo->timerangeunit.currentText()=="Tage")return 'd';
    return 'd';
};
QString window::url(){
};
void window::renew(){
    
    repo->htmlcode="<img src=\""+url()+"\" width=520>";
    
  
enum Process { OTHER, TEST, WW, WZ, ZZ, Wjets, We, Wm, Wt, DYee, DYmm, DYtt, DY, Wgamma, Zgamma, ttbar, tW, 
	       LM0, LM1, LM2, LM3, LM4, LM5, LM6, LM7, LM8, LM9, LM9p, LM10, LM11,
	       InclusiveMu5Pt50, InclusiveMuPt15, 
	       QCDBCtoEPt20to30, QCDBCtoEPt30to80, QCDBCtoEPt80to170, 
	       QCDEMenrichedPt20to30, QCDEMenrichedPt30to80, QCDEMenrichedPt80to170, QCDpt30, QCDpt80,
	       QCDpt30to80,QCDpt80to170,QCDpt170to300,QCDpt300to470,QCDpt470to800,QCDpt800toInf,
	       PhotonJet, QCDEMenrichedPt20to170, QCDBCtoEPt20to170, QCDEMenrichedPt30to170, QCDBCtoEPt30to170};
class TChain;
class Sample {
public:
     TChain 		*chain;
     enum Process 	process;
     int		histo_color;
     double		kFactor;
     std::string	name;
     bool               sm;
     double             upper_pthat;
};
Sample operator + (const Sample &, const Sample &);
Sample fTest ();
TChain *makeChain (const char *sample_glob, const char *name = "Events");
Sample fFreeForm (const char *sample_glob, enum P

		  double kFactor = 1, std::string = "other", bool = 1, double = -1);
Sample fWW	();
Sample fWZ	();
Sample fWZ_incl	();
Sample fZZ	();
Sample fWjets	();
Sample fWjetsAlpgenSingle();
Sample fWejetsAlpgenSingle();
Sample fWmjetsAlpgenSingle();
Sample fWtjetsAlpgenSingle();
Sample fWjetsSingle ();
Sample fZeejetsAlpgenSingle();
Sample fZmmjetsAlpgenSingle();
Sample fZttjetsAlpgenSingle();
Sample fInclusiveMuPt15Single();
Sample fWe      ();
Sample fWm      ();
Sample fWt      ();
Sample fWc	();
Sample fDYee 	();
Sample fDYmm 	();
Sample fDYtt 	();
Sample fVlqq	();
Sample fAstar	();
Sample fDY20tt	();
Sample fDY20mm	();
Sample fDY20ee  ();
Sample fWgamma	();
Sample fZgamma	();
Sample fttbar	();
Sample fttbarSingle ();
Sample fttbar_taula	();
Sample ftW	();
Sample fSingleTop_tChannel	();
Sample fSingleTop_sChannel	();
Sample fLM0     ();
Sample fLM1     ();
Sample fLM2     ();
Sample fLM3     ();
Sample fLM4     ();
Sample fLM5     ();
Sample fLM6     ();
Sample fLM7     ();
Sample fLM8  
/** Returns an instance of the requested internal measurement model
    (using <code>new</code>). Returns NULL if there was no match.
**/
Internal_Measurement_Model* HRP_Internal_Measurement_Model_Creator::
create_model(const std::string& type, Motion_Model *motion_model)
  std::cout << "Creating a " << type << " internal measurement model"
            << std::endl;
  Internal_Measurement_Model* pModel;
  pModel = new
    Camera_Height_Internal_Measurement_Model(motion_model);
  if(pModel->internal_type == type)
    return pModel;
  else
    delete pModel;
  pModel = new
    ThreeD_Gyro_Internal_Measurement_Model(motion_model);
  if(pModel->internal_type == type)
    return pModel;
  else
    delete pModel;
  pModel = new
    Waist_Velocity_Internal_Measurement_Model(motion_model);
  if(pModel->internal_type == type)
    return pModel;
  else
    delete pModel;
  pModel = new Orientation_Internal_Measurement_Model(motion_model);
  if(pModel->internal_type == type)
    return pModel;
  
/*
 * gameController.cpp
 *
 *  Created on: Nov 29, 2013
 *      Author: robin
 */
namespace game {
GameController::GameController(std::shared_ptr<ModelPtr> model) : model_(model), time_(0){
GameController::~GameController() {
void GameController::startCycle() {
	time_ = model_->model->getTime();
void GameController::pause() {
	model_->model->pauseTime_+= model_->model->getTime();
	model_->model->paused_ = true;
void GameController::go() {
	model_->model->clock_.restart();
	model_->model->paused_ = false;
void GameController::fireGun() {
	if (time_ - model_->model->gunLastFired_ >= model_->model->gunFireSpeed_) {
		model_->model->bullets_.push_back(model_->model->gun_->fire());
		model_->model->gunLastFired_ = time_;
	}
void GameController::moveAndFire() {
	for (auto a : model_->model->aliens_) {
		bool fire = true;
		for (auto b : model_->model->aliens_) {
			if ((b->getPosition().first == a->getPosition().first) && (b->getPosition().second > a->getPosition().second)) {
				fire = fal

				}
			}
		if (fire) {
			std::shared_ptr<objects::Bullet> temp(a->fire(time_));
			if (temp != nullptr) {
				model_->model->bullets_.push_back(temp);
			}
		}
	}
	for (auto b : model_->model->bullets_) {
		b->move(time_, model_->model->bulletUpdateDelay_);
	}
	for (auto c : model_->model->aliens_) {
		c->move(time_);
	}
void GameController::moveGun(objects::MoveDirection dir) {
	std::cout << "moving gun" << std::endl;
	if (dir != objects::right && dir != objects::left) {
		throw(Exception("A GUN CAN ONLY MOVE LEFT OR RIGHT"));
	}
	else {
		model_->model->gun_->setMove(dir);
		model_->model->gun_->move();
	}
void GameController::check() {
	checkBoundaries();
	checkCollision();
	if (model_->model->aliens_.size() == 0) {
		std::cout << "level " << model_->model->level_ << std::endl;
		if (model_->model->level_ == model_->model->nrLevels_ ){
			model_->model->win_ = true;
		}
		else {
			unsigned int score = model_->model->score_;
			model_->model = GameFactory::createGameModel("../in

			model_->model->score_ = score;
		}
	}
void GameController::restart() {
	model_->model = GameFactory::createGameModel("../informationFiles/level1");
void GameController::checkCollision() {
	for (unsigned int i = 0; i< model_->model->bullets_.size(); i++) {
		for (unsigned int j = 0; j < model_->model->bunkers_.size(); j++) {
			bool hit = utility::intersects(model_->model->bullets_.at(i), model_->model->bunkers_.at(j));
			if (hit) {
				model_->model->bullets_.erase(model_->model->bullets_.begin()+i);
				i--;
				model_->model->bunkers_.at(j)->hit();
					model_->model->bunkers_.erase(model_->model->bunkers_.begin()+j);
					j--;
				}
				break;
			}
		}
	}
	for (unsigned int i = 0; i< model_->model->bullets_.size(); i++) {
		for (unsigned int j = 0; j < model_->model->aliens_.size(); j++) {
			if (model_->model->bullets_.at(i)->getDirection() == objects::down) {
				break;
			}
			bool hit = utility::intersects(model_->model->bullets_.at(i), model_->model->aliens_.at(j));
			if 

				model_->model->score_ += model_->model->aliens_.at(j)->getScore();
				std::cout << "Score = " << model_->model->score_ << std::endl;
				model_->model->bullets_.erase(model_->model->bullets_.begin()+i);
				i--;
				model_->model->aliens_.erase(model_->model->aliens_.begin()+j);
				j--;
				break;
			}
		}
	}
	for (unsigned int i = 0; i< model_->model->bullets_.size(); i++) {
		if (model_->model->bullets_.at(i)->getDirection() == objects::up) {
			continue;
		}
		bool hit = utility::intersects(model_->model->bullets_.at(i), model_->model->gun_);
		if (hit) {
			std::cout << "gun hit" << std::endl;
			model_->model->gun_->liveDecr();
			model_->model->bullets_.erase(model_->model->bullets_.begin()+i);
			i--;
			model_->model->dead_ = true;
			if (model_->model->gun_->getLives() <= 0) {
				model_->model->lose_ = true;
			}
		}
	}
	for (unsigned int i = 0; i< model_->model->aliens_.size(); i++) {
		bool hit = utility::intersects(model_->model->aliens_.at(i), model_->model->gun_);

		if (hit) {
			std::cout << "alien hit gun" << std::endl;
			std::cout << " ALien position : " << model_->model->aliens_.at(i)->getPosition().first << " , " << model_->model->aliens_.at(i)->getPosition().second << std::endl;;
			std::cout << " gun position : " << model_->model->gun_->getPosition().first << " , " << model_->model->gun_->getPosition().second << std::endl;;
			model_->model->lose_ = true;
			model_->model->aliens_.erase(model_->model->aliens_.begin()+i);
			break;
		}
	}
	for (unsigned int i = 0; i< model_->model->aliens_.size(); i++) {
		for (unsigned int j = 0; j < model_->model->bunkers_.size(); j++) {
			bool hit = utility::intersects(model_->model->aliens_.at(i), model_->model->bunkers_.at(j));
			if (hit) {
				model_->model->aliens_.erase(model_->model->aliens_.begin()+i);
				i--;
				model_->model->bunkers_.erase(model_->model->bunkers_.begin()+j);
				j--;
				break;
			}
		}
	}
void GameController::checkBoundaries () {
	if ((model_->model->gun_->getPosition()

		model_->model->gun_->setPosition(objects::Position(model_->model->gun_->getSpeed(),model_->model->gun_->getPosition().second));
	}
	else if (model_->model->gun_->getPosition().first > model_->model->width_ - model_->model->gun_->getSizeX()) {
		model_->model->gun_->setPosition(objects::Position(model_->model->width_ - model_->model->gun_->getSizeX(), model_->model->gun_->getPosition().second));
	}
	for (unsigned int i = 0; i < model_->model->bullets_.size(); i++)
	{
		if ((model_->model->bullets_.at(i)->getPosition().first < 0) || (model_->model->bullets_.at(i)->getPosition().first > model_->model->width_)) {
			model_->model->bullets_.erase(model_->model->bullets_.begin()+i);
			i--;
		}
		else if ((model_->model->bullets_.at(i)->getPosition().second < 0) || (model_->model->bullets_.at(i)->getPosition().second > model_->model->height_)) {
			model_->model->bullets_.erase(model_->model->bullets_.begin()+i);
			i--;
		}
		else {
			continue;
		}
	}
	for (unsigned int i = 0; i < model
USING_L4L7_APP_NS;
BandwidthLoadManager::BandwidthLoadManager()
    : mProtoName("-"),
      mBllHnd(0),
      mEnableDynamicLoad(false),
      mEnableBwCtrl(false),
      mDynamicLoadTotal(0),
      mDynamicLoadPerConnBps(0),
      mPrevLoadPerConnBps(0),
      mDynamicLoadInput(0),
      mDynamicLoadOutput(0)
    InitBwTimeStorage();
BandwidthLoadManager::~BandwidthLoadManager()
void BandwidthLoadManager::RegisterDynamicLoadDelegates(StreamSocketHandler *ssh)
    ssh->RegisterDynamicLoadDelegates(
        boost::bind(&BandwidthLoadManager::GetDynamicLoad, this, _1),
        boost::bind(&BandwidthLoadManager::ProduceDynamicLoad, this, _1, _2),
        boost::bind(&BandwidthLoadManager::ConsumeDynamicLoad, this, _1, _2)
    );
void BandwidthLoadManager::UnregisterDynamicLoadDelegates(StreamSocketHandler *ssh)
    ssh->UnregisterDynamicLoadDelegates();
size_t BandwidthLoadManager::GetDynamicLoad(bool isInput)
    if (isInput)
        return mDynamicLoadInput;
    else
        return mDy

    return 0;
size_t BandwidthLoadManager::ProduceDynamicLoad(bool isInput, const ACE_Time_Value& currTime)
    ACE_Time_Value elapsed;
    time_t secElapsed;
    size_t maxSizeT = (size_t)-1;
    if (isInput)
    {
        elapsed = currTime - mLastInput;
        secElapsed = elapsed.sec();
        bytesProduced *= secElapsed;
        if (bytesProduced > 0)
            mLastInput = currTime;
            mDynamicLoadInput = maxSizeT;
        else
            mDynamicLoadInput += bytesProduced;
        return mDynamicLoadInput;
    }
    else
    {
        elapsed = currTime - mLastOutput;
        secElapsed = elapsed.sec();
        bytesProduced *= secElapsed;
        if (bytesProduced > 0)
            mLastOutput = currTime;
            mDynamicLoadOutput = maxSizeT;
        else
            mDynamicLoadOutput += bytesProduced;
        return mDynamicLoadOutput;
    }
    return 0;
size_t BandwidthLoadManager::ConsumeDynamicLoad(bool isInput, size_t consumed)
    if (isInput)
    {
 
void doDalitzKKKFit(Int_t seed = 9){
   gSystem->Load("libPhysics.so");
   gSystem->Load("libRooFit.so");
  gROOT->LoadMacro("twoDStyle.C");
  gROOT->LoadMacro("histoUtils.C");
  twoDStyle();
  gROOT->LoadMacro("AbsComplexBrackets.C+");
  gROOT->LoadMacro("AbsComplex.C+");
  gROOT->LoadMacro("AbsComplexPdf.C+");
  gROOT->LoadMacro("dataThrowerAway.C+");
  gROOT->LoadMacro("ComplexProxy.C+");
  gROOT->LoadMacro("ComplexBW.C+");
  gROOT->LoadMacro("DcyAmplitude.C+");
  gROOT->LoadMacro("DcyCoupledAmplitude.C+");
  gROOT->LoadMacro("DcyGSAmplitude.C+");
  gROOT->LoadMacro("DcyNonRes.C+");
  gROOT->LoadMacro("DbleAmplitude.C+");
  gROOT->LoadMacro("Resonance.C+");
  gROOT->LoadMacro("ComplexSum.C+");
  gROOT->LoadMacro("ComplexProd.C+");
  gROOT->LoadMacro("RooAbsPhaseSpace.C+");
  gROOT->LoadMacro("Roo3BodyPhaseSpace.C+");
  gROOT->LoadMacro("Calculate4BodyProps.h+");
  gROOT->LoadMacro("SpinFactorThreeBody.C+");
  gROOT->LoadMacro("SpinFactor.C+");
  gROOT->LoadMacro("SpinFactors.C+");
 
/*
Chay Davis
CS 202
Group B
May 3, 2013
*/
void Sound::attackSetup1()
	currentSound_=audio::load( loadResource( SWORD_CUT_1 ) );
void Sound::attackSetup2()
	{
	currentSound_=audio::load( loadResource( SWORD_CUT_2 ) );
void Sound::attackSetup3()
	{
	currentSound_=audio::load( loadResource( SWORD_CUT_3 ) );
void Sound::attackSetup4()
	{
	currentSound_=audio::load( loadResource( SWORD_CUT_4 ) );
void Sound::magicAttackSetup()
	{
	currentSound_=audio::load( loadResource( MAGIC_ATTACK ) );
void Sound::screechSetup()
	currentSound_=audio::load( loadResource( SWALLOW ) );
void Sound::monsterScreechSetup()
	currentSound_=audio::load( loadResource( MONSTER_SCREECH ) );
void Sound::swallowSetup()
	currentSound_=audio::load( loadResource( SWALLOW ) );
void Sound::snarlSetup()
	currentSound_=audio::load( loadResource( SNARL ) );
void Sound::superSnarlSetup()
	currentSound_=audio::load( loadResource( SUPER_SNARL ) );
void Sound::doorNoiseSetup()
	currentSound_=audio::load( loadResource( DOOR_OPEN 
void LoadModel(char *FileName, TModel* model)
  FILE* f=fopen(FileName,"r");
  int texturetype;
  fscanf(f,"%d",&model->type);
  fscanf(f,"%d",&texturetype);
  fscanf(f,"%d",&model->VCount);
  model->vertex=new float[3*model->VCount];
  model->normal=new float[3*model->VCount];
  model->texcoord=new float[2*model->VCount];
  for(int i=0; i<model->VCount; i++)
  {
    fscanf(f,"%f",&model->vertex[i*3]);
    fscanf(f,"%f",&model->vertex[i*3+1]);
    fscanf(f,"%f",&model->vertex[i*3+2]);
    
    if(texturetype==1)
    {
      model->texcoord[i*2]=model->vertex[i*3];
      model->texcoord[i*2+1]=model->vertex[i*3+1];
    }
    else if(texturetype==2)
    {  
      model->texcoord[i*2]=model->vertex[i*3+0];
      model->texcoord[i*2+1]=model->vertex[i*3+2]+0.423*model->vertex[i*3+1];
    }
    float r=sqrt(model->vertex[i*3]*model->vertex[i*3]+
                 model->vertex[i*3+1]*model->vertex[i*3+1]+
                 model->vertex[i*3+2]*model->vertex[i*3+2]);
    model->normal[i*3]=-mo
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g. LOAD_FLAGS_BYPASS_CLASSIFIER), since MAKE_LOAD_TYPE would
 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocSh

    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_NORMAL_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_

    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE),
    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_F

    LOAD_REPLACE_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY | nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline bool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_CACHE:
    case LOAD_NORMAL_BYPASS_PROXY:
    case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    case LOAD_HISTORY:
    case LOAD_RELOAD_NORMAL:
    case LOAD_RELOAD_BYPASS_CACHE:
    case LOAD_RELOAD_BYPASS_PROXY:
    case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    case LOAD_LINK:
    case LOAD_REFRESH:
    case LOAD_RELOAD_CHARSET_CHANGE:
    cas
ChunkManager::ChunkManager () {
	maxFltlinesSupported = 5;
	fltInUse = 0;
ChunkManager::~ChunkManager () {
	for (NV_INT32 i = 0; i < fltInUse; i++) {
		free (chunks[i].maxRecord);
		free (chunks[i].minRecord);
	}
void ChunkManager::SetMaxFltLinesSupported (NV_INT32 toSupport) {
	maxFltlinesSupported = toSupport;
Chunk * ChunkManager::RegisterFlightline (QString name) {
	NV_INT32 foundIndex = FindFlightLineIndex (name);
	if (foundIndex >= 0) return &(chunks[foundIndex]);
	else {		
		
		Chunk * newChunk = FillChunk (name);		
		if (newChunk != NULL) {
			
			AddFlightlineChunk (newChunk);			
			if (fltInUse != maxFltlinesSupported) fltInUse++;
			delete newChunk;
			
			return &(chunks[0]);
		}	
		
		return NULL;
	}
void ChunkManager::AddFlightlineChunk (Chunk * chunk) {
	for (NV_INT32 i = (fltInUse - 1); i >= 0; i--) {
		if (i == (maxFltlinesSupported - 1)) continue;
		else chunks[i + 1] = chunks[i];
	}
	chunks[0] = *chunk;
NV_INT32 ChunkManager::FindFlightLineIndex (QString name) {
	for

		if (chunks[i].name == name) return i;
	return -1;
Chunk * ChunkManager::FillChunk (QString name) {
	QFileInfo fileInfo (name);
	QDir dir = fileInfo.dir();
	QString filePrefix = fileInfo.completeBaseName();
	QString nameFilter = filePrefix + "*.wav";
	QStringList filters;
	filters << nameFilter;
	dir.setNameFilters (filters);
	dir.setSorting (QDir::Name);
	dir.setFilter (QDir::Files);
	QStringList matchingFiles = dir.entryList (filters);
	Chunk * newChunk = new Chunk;
	if (newChunk == NULL) {
		fprintf (stderr, "error[FillChunk]:  chunk could not be allocated\n");
		fflush (stderr);
		return NULL;
	}
	newChunk->name = name;
	newChunk->numChunks = matchingFiles.size ();
	newChunk->maxRecord = (NV_INT64 *) malloc (sizeof (NV_INT64) * newChunk->numChunks);
	newChunk->minRecord = (NV_INT64 *) malloc (sizeof (NV_INT64) * newChunk->numChunks);
	if (newChunk->maxRecord == NULL || newChunk->minRecord == NULL) {
		fprintf (stderr, "error[FillChunk]: max or min record of Waveform chunk memory 

		fflush (stderr);
		delete newChunk;
		return NULL;
	}	
	for (NV_INT32 i = 0; i < matchingFiles.size (); i++) {
		
		QString fileName = dir.absolutePath() + "/" + matchingFiles.at(i);		
		NV_BOOL success = ProcessWFFile (fileName, newChunk);
		if (!success) {
			fprintf (stderr, "error[FillChunk]:  problem opening waveform file\n");
			fflush (stderr);
			delete newChunk;
			return NULL;
		}
	}	
	return newChunk;
NV_BOOL ChunkManager::ProcessWFFile (QString fileName, Chunk * chunk) {
	for (NV_INT32 i = 0; i < chunk->numChunks; i++) { 
		FILE * fp;
		  
   	    fp = fopen (fileName.toAscii(), "rb");
		if (fp == NULL) {
		  fprintf (stderr, " could not open chunky file %s\n", qPrintable (fileName));
		  fflush (stderr);
		  return false;
		}
		fseek (fp, 0, SEEK_END);
		NV_INT64 eof = ftell (fp);
		NV_INT64 numRecords = eof / 1000;
		if (i == 0) {
		  chunk->minRecord[i] = 0;
		  chunk->maxRecord[i] = numRecords - 1;
		}
		else {
		  chunk->minRecord[i] = chunk->maxRecord[i - 1] + 1;
	
/*----------- defined in video/fromanc2.c -----------*/
VIDEO_UPDATE( fromanc2 );
VIDEO_START( fromanc2 );
VIDEO_START( fromancr );
VIDEO_START( fromanc4 );
READ16_HANDLER( fromanc2_paletteram_0_r );
READ16_HANDLER( fromanc2_paletteram_1_r );
WRITE16_HANDLER( fromanc2_paletteram_0_w );
WRITE16_HANDLER( fromanc2_paletteram_1_w );
READ16_HANDLER( fromancr_paletteram_0_r );
READ16_HANDLER( fromancr_paletteram_1_r );
WRITE16_HANDLER( fromancr_paletteram_0_w );
WRITE16_HANDLER( fromancr_paletteram_1_w );
READ16_HANDLER( fromanc4_paletteram_0_r );
READ16_HANDLER( fromanc4_paletteram_1_r );
WRITE16_HANDLER( fromanc4_paletteram_0_w );
WRITE16_HANDLER( fromanc4_paletteram_1_w );
WRITE16_HANDLER( fromanc2_videoram_0_w );
WRITE16_HANDLER( fromanc2_videoram_1_w );
WRITE16_HANDLER( fromanc2_videoram_2_w );
WRITE16_HANDLER( fromanc2_videoram_3_w );
WRITE16_HANDLER( fromancr_videoram_0_w );
WRITE16_HANDLER( fromancr_videoram_1_w );
WRITE16_HANDLER( fromancr_videoram_2_w );
WRITE16_HANDLER( fromanc4_v
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
    synthPosition=1;
    ui->setupUi(this);
MainWindow::~MainWindow()
    delete ui;
void MainWindow::changeEvent(QEvent *e)
    QMainWindow::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
void MainWindow::on_actionOpen_synthesiser_triggered()
    synthPosition++;
    openSynth=synthPosition;
    sy.show();
void MainWindow::on_actionOpen_sampler_triggered()
    samplePosition++;
    openSample=samplePosition;
    s.show();
void MainWindow::onSamplerSave(){
    sampleBlocks[openSample].sampleLocation1.setFileName(s.s.sampleLocation1.fileName());
    sampleBlocks[openSample].sampleLocation2.setFileName(s.s.sampleLocation2.fileName());
    sampleBlocks[openSample].sampleLocation3.setFileName(s.s.sampleLocation3.fileName());
    sampleBlocks[openSample].sampleLocation4.setFileName(s.s.sampl

    sampleBlocks[openSample].sampleLocation5.setFileName(s.s.sampleLocation5.fileName());
    sampleBlocks[openSample].sampleLocation6.setFileName(s.s.sampleLocation6.fileName());
    sampleBlocks[openSample].sampleLocation7.setFileName(s.s.sampleLocation7.fileName());
    sampleBlocks[openSample].sampleLocation8.setFileName(s.s.sampleLocation8.fileName());
    sampleBlocks[openSample].sampleLocation9.setFileName(s.s.sampleLocation9.fileName());
    sampleBlocks[openSample].sampleLocation10.setFileName(s.s.sampleLocation10.fileName());
    sampleBlocks[openSample].sampleLocation11.setFileName(s.s.sampleLocation11.fileName());
    sampleBlocks[openSample].sampleLocation12.setFileName(s.s.sampleLocation12.fileName());
    sampleBlocks[openSample].sampleLocation13.setFileName(s.s.sampleLocation13.fileName());
    sampleBlocks[openSample].sampleLocation14.setFileName(s.s.sampleLocation14.fileName());
    sampleBlocks[openSample].sampleLocation15.setFileName(s.s.sampleLocation15.fileName()
/**
 * @author William R. Otte <wotte@dre.vanderbilt.edu>
 * @author Johnny Willemsen (jwillemsen@remedy.nl)
 *
 * $Id$
 *
 * Wrapper facade for NDDS.
 */
inline void
operator<<= (::DDS::SampleInfo& sample_info, const ::DDS_SampleInfo& dds_sample_info)
  sample_info.sample_state = dds_sample_info.sample_state;
  sample_info.view_state = dds_sample_info.view_state;
  sample_info.instance_state = dds_sample_info.instance_state;
  sample_info.source_timestamp <<= dds_sample_info.source_timestamp;
  sample_info.instance_handle <<= dds_sample_info.instance_handle;
  sample_info.publication_handle <<= dds_sample_info.publication_handle;
  sample_info.disposed_generation_count = dds_sample_info.disposed_generation_count;
  sample_info.no_writers_generation_count = dds_sample_info.no_writers_generation_count;
  sample_info.sample_rank = dds_sample_info.sample_rank;
  sample_info.generation_rank = dds_sample_info.generation_rank;
  sample_info.absolute_generation_rank = dds_sample_info.absolute
namespace sf {
namespace repository {
  class GitRepoVersion;
  /*!
   * An instance of this class can be backed by a bare git
   * repository or a working directory.
   * 
   * A custom alias to resolve the <latest> version can be
   * specified, the default is master.
   */
  class GitRepo : public Repository {
    friend class GitRepoVersion;
   protected:
    std::string latest_alias;
    std::string path;
    git_repository* repo;
    void ensure_repo_is_open();
    git_commit* resolveCommit(std::string revision);
   public:
    GitRepo(std::string path, std::string latest="refs/heads/master");
    ~GitRepo();
    virtual RepositoryVersionRef latest();
    virtual RepositoryVersionRef version(std::string revision);
    virtual std::string resolveVersion(
        sf::state::Context context, const std::string version
    );
    virtual void verifyVersion(
        sf::state::Context context, const std::string version
    );
  };
  class GitRepoVersion : public RepositoryVersion {
  p
/******************************************************************************
 *
 * stream.hpp
 *
 * @author Copyright (C) 2015 Kotone Itaya
 * @version 2.1.0
 * @created  2015/10/15 Kotone Itaya -- Created!
 * @modified 2015/11/02 Kotone Itaya -- Added operators.
 * @@
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limit

 * under the License.
 *
 *****************************************************************************/
namespace spira {
  enum class SAMPLED_BY {FIRST, SECOND, BOTH};
  template<typename T>
  class stream {
  public:
    template<typename U>
    friend class stream;
    stream();
    stream(const stream<T>& other);
    stream(stream<T>&& other) noexcept;
    stream<T>& operator =(const stream<T>& other);
    stream<T>& operator =(stream<T>&& other) noexcept;
    template<typename U>
    friend void swap(stream<U>& a, stream<U>& b);
    stream<T> unique();
    stream<T> mirror();
    stream<T> merge(stream<T> other);
    stream<T> filter(std::function<bool(T)> filter);
    stream<T> whilst(stream<bool> whilst);
    stream<T> scan(T seed, const std::function<T(T,T)> scan);
    template<typename U>
    stream<U> map(std::function<U(T)> map);
    template<typename U>
    stream<std::pair<T, U> > combine(stream<U> other, SAMPLED_BY flag);
    void bind(const std::function<void(T)> funct

  private:
    void glue(const std::function<void(T)> function);
    void hook(const std::function<void(T)> function);
  protected:
    void push(T value) const;
    void listcall(const std::list<std::function<void(T)> > list) const;
    void call() const;
  private:
    struct impl; std::shared_ptr<impl> pimpl;
  };
  template<typename T>
  stream<T> operate(stream<T> a, stream<T> b, std::function<T(T, T)> operation);
  template<typename T>
  stream<T> operate(stream<T> a, T b, std::function<T(T, T)> operation);
  template<typename T>
  stream<T> operate(T a, stream<T> b, std::function<T(T, T)> operation);
  template<typename T> stream<T> operator ==(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator !=(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator < (stream<T> a, stream<T> b);
  template<typename T> stream<T> operator > (stream<T> a, stream<T> b);
  template<typename T> stream<T> operator <=(stream<T> a, stream<T> b);
  template<typename T> s

  template<typename T> stream<T> operator ==(stream<T> a, T b);
  template<typename T> stream<T> operator !=(stream<T> a, T b);
  template<typename T> stream<T> operator < (stream<T> a, T b);
  template<typename T> stream<T> operator > (stream<T> a, T b);
  template<typename T> stream<T> operator <=(stream<T> a, T b);
  template<typename T> stream<T> operator >=(stream<T> a, T b);
  template<typename T> stream<T> operator ==(T a, stream<T> b);
  template<typename T> stream<T> operator !=(T a, stream<T> b);
  template<typename T> stream<T> operator < (T a, stream<T> b);
  template<typename T> stream<T> operator > (T a, stream<T> b);
  template<typename T> stream<T> operator <=(T a, stream<T> b);
  template<typename T> stream<T> operator >=(T a, stream<T> b);
  template<typename T> stream<T> operator +(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator -(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator *(stream<T> a, stream<T> b);
  template<typenam

  template<typename T> stream<T> operator %(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator +(stream<T> a, T b);
  template<typename T> stream<T> operator -(stream<T> a, T b);
  template<typename T> stream<T> operator *(stream<T> a, T b);
  template<typename T> stream<T> operator /(stream<T> a, T b);
  template<typename T> stream<T> operator %(stream<T> a, T b);
  template<typename T> stream<T> operator +(T a, stream<T> b);
  template<typename T> stream<T> operator -(T a, stream<T> b);
  template<typename T> stream<T> operator *(T a, stream<T> b);
  template<typename T> stream<T> operator /(T a, stream<T> b);
  template<typename T> stream<T> operator %(T a, stream<T> b);
  template<typename T> stream<T> operator ~ (stream<T> a);
  template<typename T> stream<T> operator & (stream<T> a, stream<T> b);
  template<typename T> stream<T> operator ^ (stream<T> a, stream<T> b);
  template<typename T> stream<T> operator | (stream<T> a, stream<T> b);
  template<typename T> 

  template<typename T> stream<T> operator >>(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator & (stream<T> a, T b);
  template<typename T> stream<T> operator ^ (stream<T> a, T b);
  template<typename T> stream<T> operator | (stream<T> a, T b);
  template<typename T> stream<T> operator <<(stream<T> a, T b);
  template<typename T> stream<T> operator >>(stream<T> a, T b);
  template<typename T> stream<T> operator & (T a, stream<T> b);
  template<typename T> stream<T> operator ^ (T a, stream<T> b);
  template<typename T> stream<T> operator | (T a, stream<T> b);
  template<typename T> stream<T> operator <<(T a, stream<T> b);
  template<typename T> stream<T> operator >>(T a, stream<T> b);
  template<typename T> stream<T> operator !(stream<T> a);
  template<typename T> stream<T> operator &&(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator ||(stream<T> a, stream<T> b);
  template<typename T> stream<T> operator &&(stream<T> a, T b);
  template<typename T
extern FILE *output;
void dump_table_assembly     (MonoImage *m);
void dump_table_assemblyref  (MonoImage *m);
void dump_table_class_layout (MonoImage *m);
void dump_table_constant     (MonoImage *m);
void dump_table_customattr   (MonoImage *m);
void dump_table_declsec      (MonoImage *m);
void dump_table_property     (MonoImage *m);
void dump_table_property_map (MonoImage *m);
void dump_table_event        (MonoImage *m);
void dump_table_file         (MonoImage *m);
void dump_table_moduleref    (MonoImage *m);
void dump_table_module       (MonoImage *m);
void dump_table_method       (MonoImage *m);
void dump_table_methodimpl   (MonoImage *m);
void dump_table_methodsem    (MonoImage *m);
void dump_table_field        (MonoImage *m);
void dump_table_manifest     (MonoImage *m);
void dump_table_memberref    (MonoImage *m);
void dump_table_param        (MonoImage *m);
void dump_table_typedef      (MonoImage *m);
void dump_table_typeref      (MonoImage *m);
void dump_table_typespec     (Mono
ThreadHandlerMananger* ThreadHandlerMananger::getInstance()
	static ThreadHandlerMananger instance;
	return &instance;
void ThreadHandlerMananger::pushHandler( ThreadHandler& handler ,void* instance)
	handler.instance = (int)instance;
	m_HandlerList.push_back(handler);
void ThreadHandlerMananger::pushHandlerAudio( ThreadHandler& handler )
	m_HandlerAudioList.push_back(handler);
void ThreadHandlerMananger::pushHandlerRelease( ThreadHandler& handler )
	m_handleReleaseList.push_back(handler);
void ThreadHandlerMananger::deleteHandler( int instance )
	list<ThreadHandler>::iterator it = m_HandlerList.begin();
	for(;it!=m_HandlerList.end();it++)
	{
		if (it->instance == instance)
		{
			m_HandlerList.erase(it);
			return;
		}
	}
void ThreadHandlerMananger::update( float delay )
	int handlerSize = m_HandlerList.size();
	if (handlerSize>0)
	{
		for (int i=0;i<handlerSize;i++)
		{
			ThreadHandler& handler =  m_HandlerList.front();
			handler.method(handler.ptr1,handler.ptr2);
			m_HandlerList.
namespace TAO
  namespace DCPS
  {
    class RepoIdSetMap;
    class TAO_DdsDcps_Export RepoIdSetMap
    {
      public:
        typedef ACE_Hash_Map_Manager_Ex<RepoId,
                                        RepoIdSet_rch,
                                        ACE_Hash<RepoId>,
                                        ACE_Equal_To<RepoId>,
                                        ACE_Null_Mutex>        MapType;
        RepoIdSetMap();
        virtual ~RepoIdSetMap();
        int        insert(RepoId key, RepoId value);
        RepoIdSet* find(RepoId key);
        int        remove(RepoId key, RepoId value);
        RepoIdSet* remove_set(RepoId key);
        int release_publisher(RepoId subscriber_id, RepoId publisher_id);
        size_t size() const;
        MapType& map();
        const MapType& map() const;
        size_t marshaled_size ();
        
        ACE_Message_Block* marshal (bool byte_order);
        bool equal (RepoIdSetMap& map, RepoId id);
        
        int demarshal
using namespace LibQGit2;
class TestInit : public TestBase
    Q_OBJECT
public:
    TestInit();
    ~TestInit();
private slots:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void initBare();
private:
    QPointer<Repository> repo;
    const QString repoPath;
};
TestInit::TestInit() :
    repo(0),
    repoPath(QString(VALUE_TO_STR(TEST_DIR)) + "/repo")
void TestInit::initTestCase()
    TestBase::initTestCase();
    QVERIFY(!repo);
    repo = new LibQGit2::Repository();
    QVERIFY(repo);
void TestInit::cleanupTestCase()
    QVERIFY(repo);
    delete repo;
    QVERIFY(!repo);
    TestBase::cleanupTestCase();
void TestInit::init()
    QVERIFY(removeDir(repoPath));
    QVERIFY(!QDir(repoPath).exists());
    QDir().mkdir(repoPath);
    QVERIFY(QDir(repoPath).exists());
    try {
        repo->init(repoPath, false);
    } catch (const LibQGit2::Exception& ex) {
        QFAIL(ex.what());
    }
    QVERIFY(QDir(repoPath).exists());
    QVERIFY(QFile(repoPath + "/.gi
extern FileManager* pFileManager;
Mix_Chunk* Concat2Chunks(Mix_Chunk* sound1, Mix_Chunk* sound2)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = sound1->volume;
	returnChunk->alen = sound1->alen + sound2->alen;
	if((returnChunk->abuf = (Uint8 *)malloc(returnChunk->alen)) == NULL) {
		free(returnChunk);
		return NULL;
	}
	memcpy(returnChunk->abuf, sound1->abuf, sound1->alen);
	memcpy(returnChunk->abuf + sound1->alen, sound2->abuf, sound2->alen);
	return returnChunk;
Mix_Chunk* Concat3Chunks(Mix_Chunk* sound1, Mix_Chunk* sound2, Mix_Chunk* sound3)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = sound1->volume;
	returnChunk->alen = sound1->alen + sound2->alen + sound3->alen;
	if((returnChunk->abuf = (Uint8 *)malloc(returnChunk->alen)) == NULL) {
		free(return

		return NULL;
	}
	memcpy(returnChunk->abuf, sound1->abuf, sound1->alen);
	memcpy(returnChunk->abuf + sound1->alen, sound2->abuf, sound2->alen);
	memcpy(returnChunk->abuf + sound1->alen + sound2->alen, sound3->abuf, sound3->alen);
	return returnChunk;
Mix_Chunk* Concat4Chunks(Mix_Chunk* sound1, Mix_Chunk* sound2, Mix_Chunk* sound3, Mix_Chunk* sound4)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = sound1->volume;
	returnChunk->alen = sound1->alen + sound2->alen + sound3->alen + sound4->alen;
	if((returnChunk->abuf = (Uint8 *)malloc(returnChunk->alen)) == NULL) {
		free(returnChunk);
		return NULL;
	}
	memcpy(returnChunk->abuf, sound1->abuf, sound1->alen);
	memcpy(returnChunk->abuf + sound1->alen, sound2->abuf, sound2->alen);
	memcpy(returnChunk->abuf + sound1->alen + sound2->alen, sound3->abuf, sound3->alen);
	memcpy(returnChunk->abuf + sound1->alen + sound2->alen + sou

	return returnChunk;
Mix_Chunk* CreateEmptyChunk()
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = 0;
	returnChunk->alen = 0;
	returnChunk->abuf = NULL;
	return returnChunk;
Mix_Chunk* CreateSilenceChunk(int length)
	Mix_Chunk* returnChunk;
	if((returnChunk = (Mix_Chunk*) malloc(sizeof(Mix_Chunk))) == NULL) {
		return NULL;
	}
	returnChunk->allocated = 1;
	returnChunk->volume = MIX_MAX_VOLUME;
	returnChunk->alen = length;
	if((returnChunk->abuf = (Uint8 *)calloc(returnChunk->alen,1)) == NULL) {
		free(returnChunk);
		return NULL;
	}
	return returnChunk;
Mix_Chunk* GetChunkFromFile(std::string Filename) {
	Mix_Chunk* returnChunk;
	SDL_RWops* rwop;
	if((rwop = pFileManager->OpenFile(Filename)) == NULL) {
		fprintf(stderr,"GetChunkFromFile(): Cannot open %s!\n",Filename.c_str());
		exit(EXIT_FAILURE);
	}
	if((returnChunk = LoadVOC_RW(rwop, 1)) == NULL) {
		fprintf(stderr,"
/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2016 Pelican Mapping
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 */
namespace osgEarth { namespace Util
    using namespace osgEarth;
    /**
     * @deprecated - slated for removal after Version 2.7
     * ObjectLocator - a revisioned object that generates a positional matrix for a node.
     */
    class OSGEARTHUTIL_EXPORT ObjectLocator : public osg::R

    {
    public:
        /** Flags that represent separable location components. */
        enum Components {
            COMP_NONE           = 0x00,
            COMP_POSITION       = 0x01,
            COMP_HEADING        = 0x02,
            COMP_PITCH          = 0x04,
            COMP_ROLL           = 0x08,
            COMP_ORIENTATION    = COMP_HEADING | COMP_PITCH | COMP_ROLL,
            COMP_ALL            = COMP_POSITION | COMP_ORIENTATION
        };
        /** The order in which rotation are calculated */
        enum RotationOrder {
            HPR,
            RPH
        };
    public:
        /**
         * Constructs a new locator that will generate positional matricies based on
         * the specified SRS and rotation order.
         */
        ObjectLocator( const osgEarth::Map* map );
        /**
         * Constucts a new relative locator that inherits the mask of specified
         * components from a parent locator.
         */
        ObjectLocator(ObjectLocator*

        /** dtor */
        virtual ~ObjectLocator() { }
        /**
         * Sets the absolute OR relative positioning of this locator (depending on whether
         * this locator has a parent). Units conform to this Locator's SRS.
         */
        void setPosition( const osg::Vec3d& pos );
        const osg::Vec3d& getPosition() const { return _pos; }
        /**
         * Sets the absolute OR relative orientation of this locator (depending on whether
         * this locator has a parent). Units are Euler angle degrees.
         */
        void setOrientation( const osg::Vec3d& hpr_deg );
        const osg::Vec3d& getOrientation() const { return _hpr; }
        /**
         * The timestamp associated with this locator's position information.
         * (Note: setting the time does not "dirty" the locator)
         */
        void setTime( double t ) { _timestamp = t; }
        double getTime() const { return _timestamp; }
        /**
         * The order in which to calculate

         */
        void setRotationOrder( RotationOrder value ) { _rotOrder = value; }
        RotationOrder getRotationOrder() const { return _rotOrder; }
        /**
         * The optional parent locator. If a Locator has a parent, it inherits position and
         * orientation from that parent as prescribed by the Components flags. Otherwise,
         * the Locator is absolute.
         */
        void setParentLocator( ObjectLocator* parent, unsigned int componentsToInherit =COMP_ALL );
        ObjectLocator* getParentLocator() { return _parentLoc.get(); }
        const ObjectLocator* getParentLocator() const { return _parentLoc.get(); }
        /** Policy for inheriting parent locator's components */
        void setComponentsToInherit( unsigned int compMask );
        unsigned int getComponentsToInherit() const { return _componentsToInherit; }
        /** Gets the map associated with this locator. */
        const Map* getMap() const { return _map.get(); }
        /** Whether

        bool isEmpty() const;
        /** Whether this location contains valid data */
        bool isValid() const { return !_isEmpty && _map.valid(); }
    public:
        /**
         * Gets the aggregate position represented by this locator,
         * returning true upon success.
         */
        bool getLocatorPosition( osg::Vec3d& output ) const;
        /**
         * Gets the aggregate positioning matrix for this locator,
         * returning true upon success.
         */
        bool getPositionMatrix( osg::Matrixd& output ) const;
        /**
         * Gets the aggregate orientation (HPR degrees) represented by this locator,
         * returning true upon success.
         */
        bool getLocatorOrientation( osg::Vec3d& output ) const;
        /**
         * Gets the aggregate orientation matrix for this locator,
         * returning true upon success.
         */
        bool getOrientationMatrix( osg::Matrixd& output, unsigned inherit =COMP_ALL ) const;
        /*

         * Gets a matrix that can be used to position and orient an object corresponding
         * to this locator, returning true upon success.
         */
        bool getLocatorMatrix( osg::Matrixd& output, unsigned components =COMP_ALL ) const;
    public:
        /** Override Revisioned::inSync to track with the parent locator's revision. */
        virtual bool inSyncWith( int exRev ) const;
    private:
        osg::observer_ptr<const osgEarth::Map> _map;
        osg::ref_ptr<ObjectLocator> _parentLoc;
        RotationOrder _rotOrder;
        osg::Vec3d _pos;
        osg::Vec3d _hpr;
        double _timestamp;
        bool _isEmpty;
    };
    /**
     * A transform node that tracks the position/orientation information in an ObjectLocator.
     */
    class OSGEARTHUTIL_EXPORT ObjectLocatorNode : public osg::MatrixTransform
    {
    public:
        ObjectLocatorNode();
        ObjectLocatorNode( ObjectLocator* locator );
        ObjectLocatorNode( const Map* map );
        Ob
namespace libj {
namespace node {
class GTestAdd : LIBJ_JS_FUNCTION(GTestAdd)
 public:
    Value operator()(JsArray::Ptr args) {
        if (!args) {
            return Error::create(Error::ILLEGAL_ARGUMENT);
        }
        Int sum = 0;
        for (Size i = 0; i < args->length(); i++) {
            int x;
            if (to<Int>(args->get(i), &x)) {
                sum += x;
            } else {
                return Error::create(Error::ILLEGAL_ARGUMENT);
            }
        }
        return sum;
    }
    static GTestAdd::Ptr create() {
        return Ptr(new GTestAdd());
    }
};
TEST(GTestInvoke, TestInvoke) {
    GTestAdd::Ptr add = GTestAdd::create();
    ASSERT_TRUE(invoke(add).instanceof(Type<Error>::id()));
    ASSERT_TRUE(invoke(add, 1).equals(1));
    ASSERT_TRUE(invoke(add, 1, 2).equals(3));
    ASSERT_TRUE(invoke(add, 1, 2, 3).equals(6));
    ASSERT_TRUE(invoke(add, 1, 2, 3, 4).equals(10));
    ASSERT_TRUE(invoke(add, 1, 2, 3, 4, 5).equals(15));
    ASSERT_TRUE(invo
/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 */
void
reset_group_gen_class::generate_reset_group(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  stream << "static void";
  stream << "\n";
  stream << indent_str;
  stream << "reset_group_";
  generate_string (name, stream, indent + indent_str.length ());
  stream << "(struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  stream << "  if (! args_info->";
  generate_string (name, stream, indent + indent_str.length ());
  stream << "_group_counter)";
  stream << "\n";
  stream << indent_str;
  stream << "    return;";
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  indent = 0;
  stream << "\n";
  stream << indent_str;
  indent = 2;
  stream << "  ";
  generate_string (body, stream, inde
/*
 * ChunkManager.cpp
 *
 *  Created on: Mar 17, 2013
 *      Author: Tyler
 */
ChunkManager::ChunkManager() {
	mainPlayer = NULL;
ChunkManager::ChunkManager(Player * mainPlayer) {
	this->mainPlayer = mainPlayer;
ChunkManager::~ChunkManager() {
void ChunkManager::addChunk(int x, int y, int z, float r, float g, float b) {
	Chunk *chunk = new Chunk;
	chunk->init(x, y, z);
	chunk->setTestColor(r, g, b);
	chunks.push_back(chunk);
void ChunkManager::deleteChunk(int index) {
	delete chunks[index];
	chunks[index] = NULL;
void ChunkManager::update(time_t dt) {
	loadChunks();
	unloadChunks();
	std::vector<Chunk *>::iterator iterator;
		Chunk *chunk = *iterator;
		chunk->update(dt);
	}
void ChunkManager::draw(glm::mat4 *viewMat) {
	std::vector<Chunk *>::iterator iterator;
		Chunk *chunk = *iterator;
		chunk->draw(mainPlayer);
	}
Chunk * ChunkManager::getChunkWithCoordinate(int x, int y, int z) {
	Chunk * returnChunk = NULL;
	std::vector<Chunk *>::iterator iterator;
		Chunk *chunk = *iterator;
	

		bool inChunk = (x >= chunkPos.x && x < (chunkPos.x + Chunk::CHUNK_SIZE)) && (y >= chunkPos.y && y < (chunkPos.y + Chunk::CHUNK_SIZE))
				&& (z >= chunkPos.z && z < (chunkPos.z + Chunk::CHUNK_SIZE));
		if (inChunk) {
			returnChunk = chunk;
			break;
		}
	}
	return returnChunk;
		for (int y = floorf(mainPlayer->getPosition().y - (1 * Chunk::CHUNK_SIZE)); y < floorf(mainPlayer->getPosition().y + (0 * Chunk::CHUNK_SIZE)); y += Chunk::CHUNK_SIZE) {
			for (int z = floorf(mainPlayer->getPosition().z - (2 * Chunk::CHUNK_SIZE)); z < floorf(mainPlayer->getPosition().z + (2 * Chunk::CHUNK_SIZE)); z += Chunk::CHUNK_SIZE) {
				Chunk * currentChunk = getChunkWithCoordinate(x - (x % Chunk::CHUNK_SIZE), y - (y % Chunk::CHUNK_SIZE), z - (z % Chunk::CHUNK_SIZE));
				if ((currentChunk != NULL && !(currentChunk->isLoaded())) || !currentChunk) {
					addChunk(x - (x % Chunk::CHUNK_SIZE), y - (y % Chunk::CHUNK_SIZE), z - (z % Chunk::CHUNK_SIZE), 1, 1, 1);
					return;
				}
			}
		}
	}
void ChunkMan
class LimitedV2_kNCN: public Classifier {
public:
	static LoggerPtr logger;
	Distance** distances;
	Distance** nndists;
	SampleSet centroids;
	float percentMaxRobustRank;
	LimitedV2_kNCN(const int k, const int nrTrainSamples, const int nrTestSamples, 
		const int nrClasses, const int nrDims, const float percentMRobust);
	~LimitedV2_kNCN();
	void preprocess(const SampleSet& trainSet, const SampleSet& testSet);
	void classify(const SampleSet& trainSet, const SampleSet& testSet);
	int classifySample(const SampleSet& trainSet, const Sample& testSample,
		Distance* testSampleDists, Distance* testSampleNNdists, const int k);
	int classifySample(const SampleSet& trainSet, const Sample& testSample);
private:
	LimitedV2_kNCN();
	const Distance find1NNLimited(const SampleSet& trainSet, const Sample& testSample,
		const Distance* testSampleDists, const int maximalRobustRankx);
	void findkNCNLearn(const SampleSet& trainSet, const Sample& testSample,
		Distance* testSampleDists, Distance* testSampl
/*
Brian Curless
Computer Graphics Laboratory
Stanford University
---------------------------------------------------------------------
Copyright (1997) The Board of Trustees of the Leland Stanford Junior
University. Except for commercial resale, lease, license or other
commercial transactions, permission is hereby given to use, copy,
modify this software for academic purposes only.  No part of this
software or any derivatives thereof may be used in the production of
computer models for resale or for use in a commercial
product. STANFORD MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND
CONCERNING THIS SOFTWARE.  No support is implied or provided.
*/
ChunkAllocator::ChunkAllocator()
    this->chunkSize = 0;
    this->chunkList = NULL;
    this->currentChunk = NULL;
    this->currentAddr = NULL;
    this->countInChunk = 0;
ChunkAllocator::ChunkAllocator(int chunkSize)
    this->chunkSize = chunkSize;
    this->chunkList = new ChunkLink(chunkSize);
    this->currentChunk = this->chunkLi
class X : public IDEEventHandler\
{\
public:\
	X(sPtr p) { exp = p; };\
	virtual void notify(Event *e);\
};\
namespace carin {
	namespace IDEHandler {
		class IDEEventHandler 
			: public EventHandler
		{
		public:
			void swapSelected(sPtr a, sPtr b);
		};
		IDE_HANDLER_DECLARATION(IDECreateNextSiblingHandler);
		IDE_HANDLER_DECLARATION(IDECreatePreviousSiblingHandler);
		IDE_HANDLER_DECLARATION(IDEMoveNextSiblingHandler);
		IDE_HANDLER_DECLARATION(IDEMovePreviousSiblingHandler);
		IDE_HANDLER_DECLARATION(IDEDisbandHandler);
		IDE_HANDLER_DECLARATION(IDEMoveOutHandler);
		IDE_HANDLER_DECLARATION(IDEEnlistHandler);
		IDE_HANDLER_DECLARATION(IDEMoveInHandler);
		IDE_HANDLER_DECLARATION(IDEEvalHandler);
		IDE_HANDLER_DECLARATION(IDEPivotHandler);
		IDE_HANDLER_DECLARATION(IDEDeleteNodeHandler);
		IDE_HANDLER_DECLARATION(IDEKeyTypedHandler);
		IDE_HANDLER_DECLARATION(IDERuboutHandler);
	}
/*
class X : public IDEEventHandler \
{\
public:\
	virtual bool test(Event *e);\
	virtual sPtr handle

	X(EventHandler *e) { next = e; }; \
};
namespace carin {
	namespace IDEHandler {
		class IDEEventHandler : public EventHandler
		{
		public:
			IDEEventHandler(void);
			~IDEEventHandler(void);
			virtual bool test(Event *e) = 0;
			virtual sPtr handle(Event *e) = 0;
			sPtr findSelectedChild(sPtr p);
			void swapSelected(sPtr a, sPtr b);
			static IDEEventHandler* initializeHandlerList(sPtr exp);
		};
		IDE_HANDLER_DECLARATION(IDECreateNextSiblingHandler);
		IDE_HANDLER_DECLARATION(IDECreatePreviousSiblingHandler);
		IDE_HANDLER_DECLARATION(IDEMoveNextSiblingHandler);
		IDE_HANDLER_DECLARATION(IDEMovePreviousSiblingHandler);
		IDE_HANDLER_DECLARATION(IDEDisbandHandler);
		IDE_HANDLER_DECLARATION(IDEMoveOutHandler);
		IDE_HANDLER_DECLARATION(IDEEnlistHandler);
		IDE_HANDLER_DECLARATION(IDEMoveInHandler);
		IDE_HANDLER_DECLARATION(IDEEvalHandler);
		IDE_HANDLER_DECLARATION(IDEPivotHandler);
		IDE_HANDLER_DECLARATION(IDEDeleteNodeHandler);
		IDE_HANDLER_DECLARATION(IDEKeyTypedHandler);
/** ModelTest.h:
 * Unit tests for the Model class.
 */
class ModelTest : public CxxTest::TestSuite {
public:
	/** test_model_constructor:
	 * Tests that Model objects are created correctly.
	 * Tests that initial energy and power are 0.
     */
	void test_model_constructor() {
		Model model;
		TS_ASSERT_EQUALS(model.getEnergy(), 0);
		TS_ASSERT_EQUALS(model.getPower(), 0);
		TS_ASSERT_EQUALS(model.getStateChanged(), model.stateChanged_);
	}
	/** test_model_name:
	 * Tests that the getName() and setName() methods work.
     */
	void test_model_name() {
		Model model;
		std::string name = "someModel";
		model.setName(name);
		TS_ASSERT_EQUALS(model.getName(), name);
	}
	/** test_model_tick:
	 * Tests that the tick() method works.
     */
	void test_model_tick() {
		Scheduler sched;
		Model model;
		model.tick();
		model.activate("");
	}
	/** test_model_setScheduler:
	 * Tests that the Scheduler for Models is set correctly.
     */
	void test_model_setScheduler() {
		Scheduler sched;
		M
/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2011 Nokia Corporation and/or its subsidiary(-ies).
**
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** No Commercial Usage
**
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Lesser General Public License Usage
**
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
**
** If you have ques

** Nokia at qt-info@nokia.com.
**
**************************************************************************/
namespace Debugger {
namespace Internal {
QDataStream &operator<<(QDataStream &stream, const ThreadData &d)
    stream << (qint64)d.id;
    stream << d.address;
    stream << d.function;
    stream << d.fileName;
    stream << d.state;
    stream << d.lineNumber;
    stream << d.name;
    return stream;
QDataStream &operator>>(QDataStream &stream, ThreadData &d)
    qint64 id;
    stream >> id;
    d.id = id;
    stream >> d.address;
    stream >> d.function;
    stream >> d.fileName;
    stream >> d.state;
    stream >> d.lineNumber;
    stream >> d.name;
    return stream;
QDataStream &operator<<(QDataStream &stream, const Threads &threads)
    stream << (quint64)threads.count();
    for (int i = 0; i < threads.count(); i++)
    {
        const ThreadData &d = threads.at(i);
        stream << d;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, Threads &t

    quint64 count;
    stream >> count;
    threads.clear();
    for (quint64 i = 0; i < count; i++)
    {
        ThreadData d;
        stream >> d;
        threads.append(d);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrame &s)
    stream << (quint64)s.level;
    stream << s.function;
    stream << s.file;
    stream << s.from;
    stream << s.to;
    stream << s.line;
    stream << s.address;
    stream << s.usable;
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrame &s)
    quint64 level;
    stream >> level;
    s.level = level;
    stream >> s.function;
    stream >> s.file;
    stream >> s.from;
    stream >> s.to;
    stream >> s.line;
    stream >> s.address;
    stream >> s.usable;
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrames &frames)
    stream << (quint64)frames.count();
    for (int i = 0; i < frames.count(); i++)
    {
        const StackFrame &s = frames.at(i);
        stre

    }
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrames &frames)
    quint64 count;
    stream >> count;
    frames.clear();
    for (quint64 i = 0; i < count; i++)
    {
        StackFrame s;
        stream >> s;
        frames.append(s);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointResponse &s)
    stream << s.number;
    stream << s.condition;
    stream << s.ignoreCount;
    stream << s.fileName;
    stream << s.fullName;
    stream << s.lineNumber;
    stream << s.threadSpec;
    stream << s.functionName;
    stream << s.address;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointResponse &s)
    stream >> s.number;
    stream >> s.condition;
    stream >> s.ignoreCount;
    stream >> s.fileName;
    stream >> s.fullName;
    stream >> s.lineNumber;
    stream >> s.threadSpec;
    stream >> s.functionName;
    stream >> s.address;
    return stream;
QDataStream &operator<<(QDataStream &strea

    stream << s.fileName;
    stream << s.condition;
    stream << quint64(s.ignoreCount);
    stream << quint64(s.lineNumber);
    stream << quint64(s.address);
    stream << s.functionName;
    stream << int(s.pathUsage);
    stream << s.tracepoint;
    stream << s.module;
    stream << s.command;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointParameters &s)
    quint64 t;
    QString str;
    QByteArray ba;
    bool b;
    stream >> str; s.fileName = str;
    stream >> ba; s.condition = ba;
    stream >> t; s.ignoreCount = t;
    stream >> t; s.lineNumber = t;
    stream >> t; s.address = t;
    stream >> str; s.functionName = str;
    stream >> t; s.pathUsage = static_cast<BreakpointPathUsage>(t);
    stream >> b; s.tracepoint = b;
    stream >> str ; s.module = str;
    stream >> str ; s.command = str;
    return stream;
QDataStream &operator<<(QDataStream &stream, const WatchData &wd)
    stream << wd.id;
    stream << wd.iname;
    stream << wd.exp;
 

    stream << wd.value;
    stream << wd.editvalue;
    stream << wd.editformat;
    stream << wd.valuetooltip;
    stream << wd.typeFormats;
    stream << wd.type;
    stream << wd.displayedType;
    stream << wd.variable;
    stream << wd.address;
    stream << wd.hasChildren;
    stream << wd.generation;
    stream << wd.valueEnabled;
    stream << wd.valueEditable;
    stream << wd.error;
    stream << wd.state;
    stream << wd.changed;
    return stream;
QDataStream &operator>>(QDataStream &stream, WatchData &wd)
    stream >> wd.id;
    stream >> wd.iname;
    stream >> wd.exp;
    stream >> wd.name;
    stream >> wd.value;
    stream >> wd.editvalue;
    stream >> wd.editformat;
    stream >> wd.valuetooltip;
    stream >> wd.typeFormats;
    stream >> wd.type;
    stream >> wd.displayedType;
    stream >> wd.variable;
    stream >> wd.address;
    stream >> wd.hasChildren;
    stream >> wd.generation;
    stream >> wd.valueEnabled;
    stream >> wd.valueEditable;
    stream >
Locator::Locator(QObject *parent)
    : QObject(parent)
    , m_locations(QList<qreal>())
    , m_start(0)
    , m_end(1)
    , m_pixelSize(1)
    , m_multiples(QList<qreal>())
    m_multiples << 1 << 2 << 5;
    connect(this, &Locator::pixelSizeChanged, this, &Locator::updateLocator);
/*! \internal
 * \property Locator::locations
 * The current locations of the locator.
 */
QList<qreal> Locator::locations() const
    return m_locations;
void Locator::setLocations(QList<qreal> arg)
    if (m_locations == arg) return;
    m_locations = arg;
    emit locationsChanged(arg);
/*! \internal
 * \property Locator::start
 * The minimum value of the locator. By default this is the attached axis' min
 * value.
 */
qreal Locator::start() const
    return m_start;
void Locator::setStart(qreal arg)
    if (m_start == arg) return;
    m_start = arg;
    emit startChanged(arg);
    updateLocator();
/*! \internal
 * \property Locator::end
 * The maximum value of the locator. By default this is the atta

 * value.
 */
qreal Locator::end() const
    return m_end;
void Locator::setEnd(qreal arg)
    if (m_end == arg) return;
    m_end = arg;
    emit endChanged(arg);
    updateLocator();
void Locator::setLimits(qreal start, qreal end)
    if (start == -Inf || end == Inf) return;
    bool updateStart = m_start != start;
    bool updateEnd = m_end != end;
    if (!updateStart && !updateEnd) return;
    m_start = start;
    m_end = end;
    if (updateStart)
        emit startChanged(start);
    if (updateEnd)
        emit endChanged(end);
    updateLocator();
/*! \internal
 * \property Locator::pixelSize
 * The number of pixels covered by this locator. By default this is the
 * attached axis' length.
 */
qreal Locator::pixelSize() const
    return m_pixelSize;
void Locator::setPixelSize(qreal arg)
    if (m_pixelSize == arg) return;
    m_pixelSize = arg;
    emit pixelSizeChanged(arg);
/*! \internal
 * \property Locator::multiples
 * The multiples by which the Locator increases.
 */
QList

    return m_multiples;
void Locator::setMultiples(QList<qreal> arg)
    if (m_multiples == arg) return;
    m_multiples = arg;
    emit multiplesChanged(arg);
QStringList Locator::locationLabels() const
    if (m_locationLabels.length() != m_locations.length())
        return QStringList();
    else
        return m_locationLabels;
void Locator::setLocationLabels(QStringList arg)
    if (m_locationLabels == arg) return;
    m_locationLabels = arg;
    emit locationLabelsChanged(arg);
void Locator::setLocationsAndLabels(QList<qreal> locs, QStringList labels) {
    bool newLocs = locs != m_locations;
    bool newLabels = labels != m_locationLabels;
    m_locations = locs;
    m_locationLabels = labels;
    if (newLocs) emit locationsChanged(locs);
    if (newLabels) emit locationLabelsChanged(labels);
AutoLocator::AutoLocator(QObject *parent)
    : Locator(parent)
    , m_density(50)
AutoLocator::AutoLocator(qreal density, QObject *parent)
    : Locator(parent)
    , m_density(density)

    updateLocator();
/*!
 * \property AutoLocator::density
 * The preferred density of the locator in pixels/tick. Default: 50
 */
qreal AutoLocator::density() const
    return m_density;
void AutoLocator::setDensity(qreal arg)
    if (m_density == arg) return;
    m_density = arg;
    updateLocator();
    emit densityChanged(arg);
void AutoLocator::updateLocator()
    /* We want to find the multiple (n), and the magnitude (m) of the multiples that
     * get a tick density closest to the preferred density. The error can be
     * expressed in 2 ways:
     * density = scale*n*10^m + e   (1), OR
     * density = scale*n*10^(m+a)   (2)
     * Solving gives:
     * e = density*(1 - 10^(-a))
     * We want to minimise `e`
     */
    QTime timer; timer.start();
    qreal scale = pixelSize()/(end() - start());
    if (scale <= 0) setLocations(QList<qreal>());
    qreal bestA = m_density, bestMult = 0;
    foreach (qreal n, multiples()) {
        qreal m_a = log10(m_density/(scale*n));
    

        if (a < bestA) {
            bestA = a;
            bestMult = n*qPow(10, m);
        }
    }
    QList<qreal> newLocs;
    newLocs << ceil(start()/bestMult)*bestMult;
    while (newLocs.last() + bestMult <= end()) {
        qreal newVal = newLocs.last() + bestMult;
        if (qAbs(newVal)*scale < 0.1)
            newVal = 0;
        newLocs << newVal;
    }
    if (newLocs.length() < 2) {
        qreal dStart = qAbs(newLocs[0] - start()), dEnd = qAbs(newLocs[0] - end());
        if (dStart > dEnd && dStart*scale > m_density/2)
            newLocs.prepend(start());
        else if (dEnd >= dStart && dEnd*scale > m_density/2)
            newLocs.append(end());
        else
            newLocs.clear();
    }
    if (newLocs.length() == 0)
        newLocs << start() << end();
    setLocations(newLocs);
qreal AutoLocator::roundAt(qreal n, qreal f)
    qreal nInt = qFloor(n);
    qreal nFrac = n - nInt < f ? 0 : 1;
    return nInt + nFrac;
HardLocator::HardLocator(QObject *parent)

    : Locator(parent)
    , m_hardLocations(QList<qreal>())
HardLocator::HardLocator(QList<qreal> hardLocs, QObject *parent)
    : Locator(parent)
    , m_hardLocations(hardLocs)
    updateLocator();
void HardLocator::setHardLocations(QList<qreal> arg)
    if (m_hardLocations == arg) return;
    m_hardLocations = arg;
    updateLocator();
    emit hardLocationsChanged(arg);
void HardLocator::updateLocator()
    QList<qreal> newLocs;
    foreach (qreal val, m_hardLocations) {
        if (val >= start() && val <= end())
            newLocs << val;
    }
    setLocations(newLocs);
/*!
 * \property HardLocator::hardLocations
 * The exact locations at which to show ticks. This is not dynamic at all.
 */
QList<qreal> HardLocator::hardLocations() const
    return m_hardLocations;
SpacedLocator::SpacedLocator(QObject *parent)
    : Locator(parent)
    , m_spacing(1)
SpacedLocator::SpacedLocator(qreal spc, QObject *parent)
    : Locator(parent)
    , m_spacing(spc)
    updateLocator();
void Sp

    if (m_spacing == arg) return;
    m_spacing = arg;
    emit spacingChanged(arg);
void SpacedLocator::updateLocator()
    QList<qreal> newLocs;
    newLocs << qCeil(start()/m_spacing)*m_spacing;
    while (newLocs.last() <= end())
        newLocs << newLocs.last() + m_spacing;
    newLocs.removeLast();
    setLocations(newLocs);
/*!
 * \property SpacedLocator::spacing
 * Manually specify the spacing for ticks. This is anchored to zero.
 */
qreal SpacedLocator::spacing() const
    return m_spacing;
LabelLocator::LabelLocator(QObject *parent)
    : HardLocator(parent)
    , m_labels(QStringList())
LabelLocator::LabelLocator(QStringList labels, QList<qreal> hardLocs, QObject *parent)
    : HardLocator(hardLocs, parent)
    , m_labels(labels)
    updateLocator();
QStringList LabelLocator::labels() const
    return m_labels;
void LabelLocator::setLabels(QStringList arg)
    if (m_labels == arg) return;
    m_labels = arg;
    updateLocator();
    emit labelsChanged(arg);
void LabelLocat
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
struct repo_op_t{
	std::string  command;
	char** args;
	uint32_t nArgcs;
};
/*
* =========== HOW TO ADD A NEW COMMAND ===========
* 1. write the command under command functions
* 2. modify performOperations to recognise your command
* 3. modify helpInfo/knownValid
*/
/**
* Get info on commands (for --help menu)
* @return returns a string of command and it's info
*/
std

/**
* Check if the command is a special one (that can be used without database info)
* @return returns true if it is a special command
*/
bool isSpecialCommand(const std::string &cmd);
/**
* Check if the command is recognised
*          -1 if command not recognised
*/
int32_t knownValid(const std::string &cmd);
/**
* Perform the command given in in the struct repo_op_t
* @param controller the controller to the bouncer library
* @param token      token provided by the controller after authentication
* @param command    command and it's arguments to perform
* @return returns true upon success
*/
int32_t performOperation(
	repo::RepoController *controller,
	const repo::RepoController::RepoToken      *token,
	const repo_op_t            &command
	);
/*
* ======================== Command functions ===================
*/
/**
* Check all revisions within a project for status information,
* If the revision is deemed corrupted, attempt to repair, otherwise delete.
* @param controller the contro

* @param token      token provided by the controller after authentication
* @param command    command and it's arguments to perform
* @return returns true upon success
*/
static int32_t cleanUpProject(
	repo::RepoController       *controller,
	const repo::RepoController::RepoToken      *token,
	const repo_op_t            &command
	);
/**
* Generate and commit a federation
* @param controller the controller to the bouncer library
* @param token      token provided by the controller after authentication
* @param command    command and it's arguments to perform
* @return returns true upon success
*/
int32_t generateFederation(
	repo::RepoController       *controller,
	const repo::RepoController::RepoToken      *token,
	const repo_op_t            &command
	);
/**
* Generate a particular type of stash (src/gltf/repo) for a given project
* @param controller the controller to the bouncer library
* @param token      token provided by the controller after authentication
* @param command    com

* @return returns true upon success
*/
static int32_t generateStash(
	repo::RepoController       *controller,
	const repo::RepoController::RepoToken      *token,
	const repo_op_t            &command
	);
/**
* Retrieve the original file for the head of the project
* @param controller the controller to the bouncer library
* @param token      token provided by the controller after authentication
* @param command    command and it's arguments to perform
* @return returns true upon success
*/
static int32_t getFileFromProject(
	repo::RepoController       *controller,
	const repo::RepoController::RepoToken      *token,
	const repo_op_t            &command
	);
/**
* Import model from file and commit it to the database
* @param controller the controller to the bouncer library
* @param token      token provided by the controller after authentication
* @param command    command and it's arguments to perform
* @return returns true upon success
*/
static int32_t importFileAndCommit(
	repo::RepoCo
Tester::Tester()
void Tester::Test1(GraphManager manager)
	RawSample sample;
	sample.EventId = 0;
	sample.Label = 1;
	manager.AddSample(sample);
	sample.EventId = 1;
	manager.AddSample(sample);
	sample.EventId = 2;
	manager.AddSample(sample);
	sample.EventId = 3;
	manager.AddSample(sample);
	sample.EventId = 4;
	manager.AddSample(sample);
	sample.EventId = 5;
	sample.Label = 0;
	manager.AddSample(sample);
	EdgeElement edge;
	edge.First = 0;
	edge.Second = 5;
	manager.AddEdge(edge);
	edge.First = 1;
	edge.Second = 5;
	manager.AddEdge(edge);
	edge.First = 2;
	edge.Second = 5;
	manager.AddEdge(edge);
	edge.First = 3;
	edge.Second = 5;
	manager.AddEdge(edge);
	edge.First = 4;
	edge.Second = 5;
	manager.AddEdge(edge);
	manager.FixLastEdge();
	manager.VertexCover();
	std::vector<RawSample> final;
	manager.Extract(final);
	int signals = 0;
	for (auto sample : final)
	{
		if (sample.Label == 1)
			signals++;
	}
	if (signals == 4)
		std::cout << "Test passed\n";
	else
		std::cout << "Test faile
/*
*	Author: Chaitanya Agrawal (krypten)
*	Description:
*/
TEXT Model::getKey() const
  return key;
Model::ModelValueType Model::getValueType() const
  return valueType;
void Model::getValue(ModelArray& mArray, bool& error) const
  if (!error && getValueType() == ModelValueType::ModelValueArray) {
    mArray = *(value.modelArray);
  } else {
    error = true;
  }
void Model::getValue(TEXT& mString, bool& error) const
  if (!error && getValueType() == ModelValueType::ModelValueString) {
    mString = *(value.modelString);
  } else {
    error = true;
  }
void Model::getValue(double& mDouble, bool& error) const
  if (!error && getValueType() == ModelValueType::ModelValueDouble) {
    mDouble = value.modelDouble;
  } else {
    error = true;
  }
void Model::getValue(int& mInt, bool& error) const
  if (!error && getValueType() == ModelValueType::ModelValueInt) {
    mInt = value.modelInt;
  } else {
    error = true;
  }
void Model::setKey(TEXT mkey)
  key = mkey;
void Model::setValueType(
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree. An additional intellectual property rights grant can be found
 *  in the file PATENTS.  All contributing project authors may
 *  be found in the AUTHORS file in the root of the source tree.
 */
RTC_PUSH_IGNORING_WUNDEF()
RTC_POP_IGNORING_WUNDEF()
namespace webrtc {
namespace {
using audio_network_adaptor::debug_dump::Event;
using audio_network_adaptor::debug_dump::NetworkMetrics;
using audio_network_adaptor::debug_dump::EncoderRuntimeConfig;
void DumpEventToFile(const Event& event, FileWrapper* dump_file) {
  RTC_CHECK(dump_file->is_open());
  std::string dump_data;
  event.SerializeToString(&dump_data);
  int32_t size = event.ByteSize();
  dump_file->Write(&size, sizeof(size));
  dump_file->Write(dump_data.data(), dump_data.length());
class DebugDumpWriterImpl final : p

 public:
  explicit DebugDumpWriterImpl(FILE* file_handle);
  ~DebugDumpWriterImpl() override = default;
  void DumpEncoderRuntimeConfig(
      const AudioNetworkAdaptor::EncoderRuntimeConfig& config,
      int64_t timestamp) override;
  void DumpNetworkMetrics(const Controller::NetworkMetrics& metrics,
                          int64_t timestamp) override;
 private:
  std::unique_ptr<FileWrapper> dump_file_;
};
DebugDumpWriterImpl::DebugDumpWriterImpl(FILE* file_handle)
    : dump_file_(FileWrapper::Create()) {
  RTC_NOTREACHED();
  dump_file_->OpenFromFileHandle(file_handle);
  RTC_CHECK(dump_file_->is_open());
void DebugDumpWriterImpl::DumpNetworkMetrics(
    const Controller::NetworkMetrics& metrics,
    int64_t timestamp) {
  Event event;
  event.set_timestamp(timestamp);
  event.set_type(Event::NETWORK_METRICS);
  auto dump_metrics = event.mutable_network_metrics();
  if (metrics.uplink_bandwidth_bps)
    dump_metrics->set_uplink_bandwidth_bps(*metrics.uplink_bandwidth_bps);
  i

    dump_metrics->set_uplink_packet_loss_fraction(
        *metrics.uplink_packet_loss_fraction);
  }
  if (metrics.target_audio_bitrate_bps) {
    dump_metrics->set_target_audio_bitrate_bps(
        *metrics.target_audio_bitrate_bps);
  }
  if (metrics.rtt_ms)
    dump_metrics->set_rtt_ms(*metrics.rtt_ms);
  DumpEventToFile(event, dump_file_.get());
void DebugDumpWriterImpl::DumpEncoderRuntimeConfig(
    const AudioNetworkAdaptor::EncoderRuntimeConfig& config,
    int64_t timestamp) {
  Event event;
  event.set_timestamp(timestamp);
  event.set_type(Event::ENCODER_RUNTIME_CONFIG);
  auto dump_config = event.mutable_encoder_runtime_config();
  if (config.bitrate_bps)
    dump_config->set_bitrate_bps(*config.bitrate_bps);
  if (config.frame_length_ms)
    dump_config->set_frame_length_ms(*config.frame_length_ms);
  if (config.uplink_packet_loss_fraction) {
    dump_config->set_uplink_packet_loss_fraction(
        *config.uplink_packet_loss_fraction);
  }
  if (config.enable_fec)
    du
/****************************************************************************
 * Copyright (c) 2015, ARM Limited, All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ****************************************************************************
 */
using namespace utest::v1;
Case::Case(const char *description,
           const case_setup_handler_t setup_handler,
           const case_handler_t handler,
           const case_teardown_handler_t teardown_handler,
           const case

    description(description),
    handler(handler),
    control_handler(ignore_handler),
    repeat_count_handler(ignore_handler),
    setup_handler(setup_handler),
    teardown_handler(teardown_handler),
    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_handler_t handler,
           const case_teardown_handler_t teardown_handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(handler),
    control_handler(ignore_handler),
    repeat_count_handler(ignore_handler),
    setup_handler(default_handler),
    teardown_handler(teardown_handler),
    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_handler_t handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(handler),
    control_handler(ignore_handler),
    repeat_count_handler(ignore_handler),
    setup_handler(default_handler),
    teard

    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_setup_handler_t setup_handler,
           const case_control_handler_t handler,
           const case_teardown_handler_t teardown_handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(ignore_handler),
    control_handler(handler),
    repeat_count_handler(ignore_handler),
    setup_handler(setup_handler),
    teardown_handler(teardown_handler),
    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_control_handler_t handler,
           const case_teardown_handler_t teardown_handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(ignore_handler),
    control_handler(handler),
    repeat_count_handler(ignore_handler),
    setup_handler(default_handler),
    teardown_handler(teardown_handler),
    failure_handler(failure_handler)
{}
Case::Ca

           const case_control_handler_t handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(ignore_handler),
    control_handler(handler),
    repeat_count_handler(ignore_handler),
    setup_handler(default_handler),
    teardown_handler(default_handler),
    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_setup_handler_t setup_handler,
           const case_call_count_handler_t case_repeat_count_handler,
           const case_teardown_handler_t teardown_handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(ignore_handler),
    control_handler(ignore_handler),
    repeat_count_handler(case_repeat_count_handler),
    setup_handler(setup_handler),
    teardown_handler(teardown_handler),
    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_call_count_handler_t case_repeat_count_handler,

           const case_failure_handler_t failure_handler) :
    description(description),
    handler(ignore_handler),
    control_handler(ignore_handler),
    repeat_count_handler(case_repeat_count_handler),
    setup_handler(default_handler),
    teardown_handler(default_handler),
    failure_handler(failure_handler)
{}
Case::Case(const char *description,
           const case_call_count_handler_t case_repeat_count_handler,
           const case_teardown_handler_t teardown_handler,
           const case_failure_handler_t failure_handler) :
    description(description),
    handler(ignore_handler),
    control_handler(ignore_handler),
    repeat_count_handler(case_repeat_count_handler),
    setup_handler(default_handler),
    teardown_handler(teardown_handler),
    failure_handler(failure_handler)
{}
const char*
Case::get_description() const {
    return description;
bool
Case::is_empty() const {
    return !(handler || control_handler || repeat_count_handler || setup_handler || teard
CModelLoader::CModelLoader()
}	
CModelLoader::~CModelLoader()
CModel* CModelLoader::CreateShape(eModelShape aShape)
	CModel* newModel = new CModel();
	ID3D11VertexShader* vertexShader		= SHADERMGR->LoadVertexShader(L"Shaders/vertex_shader.fx", blueprint);
	ID3D11PixelShader* pixelShader			= SHADERMGR->LoadPixelShader(L"Shaders/pixel_shader.fx", blueprint);
	ID3D11InputLayout* inputLayout			= SHADERMGR->LoadInputLayout(L"Shaders/vertex_shader.fx", blueprint);
	D3D_PRIMITIVE_TOPOLOGY topology			= D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	CEffect* effect = new CEffect(vertexShader, pixelShader, geometryShader, inputLayout, topology);
	newModel->Initialize(effect, nullptr);
	switch (aShape)
	{
	case eModelShape::eTriangle:
		CreateTriangle(newModel);
		break;
	case eModelShape::eQuad:
		CreateQuad(newModel);
		break;
	case eModelShape::eCube:
		CreateCube(newModel);
		break;
	}
	return newModel;
	CFBXLoader loader;
	CLoaderModel* loadedModel = loader.LoadModel(aPath);
	assert(loadedModel != 

	int shaderType = loadedModel->myMeshes[0]->myShaderType;
	std::string modelPath = aPath;
	std::wstring directory = std::wstring(modelPath.begin(), modelPath.end());
	directory = directory.substr(0, directory.find_last_of('/') + 1);
	CU::GrowingArray<const wchar_t*> texturePaths;
	texturePaths.Init(8);
	std::wstring diffuse = std::wstring(loadedModel->myTextures[0].begin(), loadedModel->myTextures[0].end());
	diffuse = directory + diffuse;
	const wchar_t* diffusePath = diffuse.c_str();
	std::wstring roughness = std::wstring(loadedModel->myTextures[1].begin(), loadedModel->myTextures[1].end());
	roughness = directory + roughness;
	const wchar_t* roughnessPath = roughness.c_str();
	std::wstring ambientOclution = std::wstring(loadedModel->myTextures[2].begin(), loadedModel->myTextures[2].end());
	ambientOclution = directory + ambientOclution;
	const wchar_t* AOPath = ambientOclution.c_str();
	std::wstring emissive = std::wstring(loadedModel->myTextures[3].begin(), loadedModel->myTextures

	emissive = directory + emissive;
	const wchar_t* emissivePath = emissive.c_str();
	std::wstring normal = std::wstring(loadedModel->myTextures[5].begin(), loadedModel->myTextures[5].end());
	normal = directory + normal;
	const wchar_t* normalPath = normal.c_str();
	std::wstring metalness = std::wstring(loadedModel->myTextures[10].begin(), loadedModel->myTextures[10].end());
	metalness = directory + metalness;
	const wchar_t* metalnessPath = metalness.c_str();
	if (loadedModel->myTextures[0] == "")
		diffusePath = L"";
	texturePaths.Add(diffusePath);
	if (loadedModel->myTextures[1] == "")
		roughnessPath = L"";
	texturePaths.Add(roughnessPath);
	if (loadedModel->myTextures[2] == "")
		AOPath = L"";
	texturePaths.Add(AOPath);
	if (loadedModel->myTextures[3] == "")
		emissivePath = L"";
	texturePaths.Add(emissivePath);
	if (loadedModel->myTextures[5] == "")
		normalPath = L"";
	texturePaths.Add(normalPath);
	if (loadedModel->myTextures[10] == "")
		metalnessPath = L"";
	texturePaths.Add(

	ID3D11VertexShader* vertexShader		= SHADERMGR->LoadVertexShader(L"Shaders/vertex_shader.fx", shaderType);
	ID3D11PixelShader* pixelShader			= SHADERMGR->LoadPixelShader(L"Shaders/pixel_shader.fx", shaderType);
	ID3D11InputLayout* inputLayout			= SHADERMGR->LoadInputLayout(L"Shaders/vertex_shader.fx", shaderType);
	D3D_PRIMITIVE_TOPOLOGY topology			= D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	CEffect* effect = new CEffect(vertexShader, pixelShader, geometryShader, inputLayout, topology);
	CSurface* surface = new CSurface(texturePaths);
	aNewModel->Initialize(effect, surface, loadedModel);
	delete loadedModel;
	loadedModel = nullptr;
void CModelLoader::CreateTriangle(CModel* aModel)
void CModelLoader::CreateQuad(CModel* aModel)
	/*CU::GrowingArray<SVertexData>& modelVertices = aModel->GetVertices();
	CU::GrowingArray<unsigned int>& modelIndices = aModel->GetIndices();
	CU::Vector4f topLeft = {-0.5f, -0.5f, 0.5f, 1.0f};
	CU::Vector4f topRight = { 0.5f, -0.5f, 0.5f, 1.0f };
	CU::Vector4f bo

	CU::Vector4f botRight = { 0.5f, 0.5f, 0.5f, 1.0f };
	modelVertices.Add(SVertexData());
	modelVertices[0].position = topLeft;
	modelVertices.Add(SVertexData());
	modelVertices[1].position = botLeft;
	modelVertices.Add(SVertexData());
	modelVertices[2].position = botRight;
	modelVertices.Add(SVertexData());
	modelVertices[3].position = topRight;
	modelIndices.Add(0);
	modelIndices.Add(1);
	modelIndices.Add(3);
	modelIndices.Add(3);
	modelIndices.Add(1);
	modelIndices.Add(2);*/
void CModelLoader::CreateCube(CModel* aModel)
	modelVertices.Init(8);
	modelIndices.Init(36);
	modelVertices.Add(SVertexDataCube());
	modelVertices[0].position.x = -0.5f;
	modelVertices[0].position.y = 0.5f;
	modelVertices[0].position.z = -0.5f;
	modelVertices[0].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVertices[1].position.x = -0.5f;
	modelVertices[1].position.y = 0.5f;
	modelVertices[1].position.z = 0.5f;
	modelVertices[1].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVe

	modelVertices[2].position.y = 0.5f;
	modelVertices[2].position.z = 0.5f;
	modelVertices[2].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVertices[3].position.x = 0.5f;
	modelVertices[3].position.y = 0.5f;
	modelVertices[3].position.z = -0.5f;
	modelVertices[3].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVertices[4].position.x = -0.5f;
	modelVertices[4].position.y = -0.5f;
	modelVertices[4].position.z = -0.5f;
	modelVertices[4].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVertices[5].position.x = -0.5f;
	modelVertices[5].position.y = -0.5f;
	modelVertices[5].position.z = 0.5f;
	modelVertices[5].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVertices[6].position.x = 0.5f;
	modelVertices[6].position.y = -0.5f;
	modelVertices[6].position.z = 0.5f;
	modelVertices[6].position.w = 1.0f;
	modelVertices.Add(SVertexDataCube());
	modelVertices[7].position.x = 0.5f;
	modelVertices[7].position.y = -0.5f;
	modelVertices[7].p
/* ****************************************************************** **
**    OpenSees - Open System for Earthquake Engineering Simulation    **
**          Pacific Earthquake Engineering Research Center            **
**                                                                    **
**                                                                    **
** (C) Copyright 1999, The Regents of the University of California    **
** All Rights Reserved.                                               **
**                                                                    **
** Commercial use of this program without express permission of the   **
** University of California, Berkeley, is strictly prohibited.  See   **
** file 'COPYRIGHT'  in main directory for information on usage and   **
** redistribution,  and for a DISCLAIMER OF ALL WARRANTIES.           **
**                                                                    **
** Developed by:                                   

**   Frank McKenna (fmckenna@ce.berkeley.edu)                         **
**   Gregory L. Fenves (fenves@ce.berkeley.edu)                       **
**   Filip C. Filippou (filippou@ce.berkeley.edu)                     **
**                                                                    **
** ****************************************************************** */
                                                                        
                                                                        
                                                                        
Vector NodalLoad::gradientVector(1);
NodalLoad::NodalLoad(int theClasTag)
:Load(0,theClasTag), 
 myNode(0), myNodePtr(0), load(0), konstant(false)
  parameterID = 0;
NodalLoad::NodalLoad(int tag, int node, int theClassTag)
:Load(tag,theClassTag), 
 myNode(node), myNodePtr(0), load(0), konstant(false)
  parameterID = 0;
NodalLoad::NodalLoad(int tag, int node, const Vector &theLoad, bool isLoadConstant)
:Load(tag,

 myNode(node), myNodePtr(0), load(0), konstant(isLoadConstant)
    load = new Vector(theLoad);    
    if (load == 0) {
	opserr << "FATAL NodalLoad::NodalLoad(int node, const Vector &theLoad) -";
	opserr << " ran out of memory for load on Node " << node << endln;
	exit(-1);
    }
    parameterID = 0;
NodalLoad::~NodalLoad()
    if (load != 0)
	delete load;
void 
NodalLoad::setDomain(Domain *newDomain)
  if (newDomain == 0)
    return;
  this->DomainComponent::setDomain(newDomain);    
  /*
  if (newDomain != 0) {
    myNodePtr = newDomain->getNode(myNode);
    if (myNodePtr == 0) {
      opserr << *newDomain;
      opserr << "WARNING NodalLoad::setDomain() - No associated Node node " ;
      opserr << " for NodalLoad " << *this;
      return;
    }
  }
  */
int 
NodalLoad::getNodeTag(void) const
    return myNode;
void
NodalLoad::applyLoad(double loadFactor)
    if (myNodePtr == 0) {
      Domain *theDomain=this->getDomain();
      if ((theDomain == 0) || 
	  (myNodePtr = theDomain->g

	opserr << "WARNING NodalLoad::applyLoad() - No associated Node node " ;
	opserr << " for NodalLoad " << *this;
	return;
      }
    }
    if (konstant == false)
	myNodePtr->addUnbalancedLoad(*load,loadFactor);
    else
	myNodePtr->addUnbalancedLoad(*load,1.0);	
    
void
NodalLoad::applyLoadSensitivity(double loadFactor)
    if (myNodePtr == 0) {
	Domain *theDomain=this->getDomain();
	if ((theDomain == 0) || 
	    (myNodePtr = theDomain->getNode(myNode)) == 0) {
	    opserr << "WARNING NodalLoad::applyLoadSensitivity() - No associated Node node " ;
	    opserr << " for NodalLoad " << *this;
	    return;
	}
    }
    Vector loadsens(load->Size());
    if(parameterID == 0) return;
    if(parameterID > loadsens.Size()) return;
    loadsens(parameterID-1) = 1;
    if (konstant == false)
	myNodePtr->addUnbalancedLoad(loadsens,loadFactor);
    else
	myNodePtr->addUnbalancedLoad(loadsens,1.0);	
    
} 
int 
NodalLoad::sendSelf(int cTag, Channel &theChannel)
    int dataTag = this->getDbTag(

    ID data(5);
    data(0) = this->getTag();    
    data(1) = myNode;
    if (load != 0)
	data(2) = load->Size();
    else
	data(2) = 0;
    data(3) = konstant;
    data(4) = this->getLoadPatternTag();
    
    int result = theChannel.sendID(dataTag, cTag, data);
    if (result < 0) {
	opserr << "NodalLoad::sendSelf - failed to send data\n";
	return result;
    }
    if (load != 0){
	int result = theChannel.sendVector(dataTag, cTag, *load);
	if (result < 0) {
	    opserr << "NodalLoad::sendSelf - failed to Load data\n";
	    return result;
	}
    }    
    return 0;
int 
NodalLoad::recvSelf(int cTag, Channel &theChannel, 
		    FEM_ObjectBroker &theBroker)
{	
    int result;
    int dataTag = this->getDbTag();
    ID data(5);
    result = theChannel.recvID(dataTag, cTag, data);
    if (result < 0) {
      opserr << "NodalLoad::recvSelf() - failed to recv data\n";
      return result;
    }    
    this->setTag(data(0));
    myNode = data(1);
    int loadSize = data(2);
    konstant 

    this->setLoadPatternTag(data(4));
    if (loadSize != 0) {
	load = new Vector(data(2));
	result = theChannel.recvVector(dataTag, cTag, *load);
	if (result < 0) {
	  opserr << "NodalLoad::recvSelf() - failed to recv load\n";
	  return result;
	}    
    }
    return 0;
void
NodalLoad::Print(OPS_Stream &s, int flag)
     s << "Nodal Load: " << myNode;
     if (load != 0)
	 s << " load : " << *load;
int
NodalLoad::setParameter(const char **argv, int argc, Parameter &param)
  if (argc < 1)
    return -1;
  if (strcmp(argv[0],"1") == 0) {
    param.setValue((*load)(0));
    return param.addObject(1, this);
  }
  if (strcmp(argv[0],"2") == 0) {
    param.setValue((*load)(1));
    return param.addObject(2, this);
  }
  if (strcmp(argv[0],"3") == 0) {
    param.setValue((*load)(2));
    return param.addObject(3, this);
  }
  if (strcmp(argv[0],"4") == 0) {
    param.setValue((*load)(3));
    return param.addObject(4, this);
  }
  if (strcmp(argv[0],"5") == 0) {
    param.setValue((*load)(
namespace Defs
namespace Util
	typedef Game::Util::STG::ArrowLocator GameArrowLocator;
	class ArrowLocator
		: public GameArrowLocator
	{
	public:
		ArrowLocator( int initArrowPos, int top, int bottom )
			: GameArrowLocator( Input::Input::getController().GetPtr(), initArrowPos, top, bottom )
		{}
		ArrowLocator( int initArrowPos, int top, int bottom, 
				bool loop )
				: GameArrowLocator( Input::Input::getController().GetPtr(), initArrowPos, top, bottom, loop )
		{}
		ArrowLocator( int initArrowPos, int top, int bottom, 
				bool loop, bool horizontal )
				: GameArrowLocator( Input::Input::getController().GetPtr(), initArrowPos, top, bottom, loop, horizontal )
		{}
		int GetTop() const
		{
			return GameArrowLocator::GetInterval().upper();
		}
		void SetTop( int top )
		{
			GameArrowLocator::SetInterval( top, GetBottom() );
		}
		int GetBottom() const
		{
			return GameArrowLocator::GetInterval().lower();
		}
		void SetBottom( int bottom )
		{
			GameArrowLocator::SetInterval( Get
int samplesAdded = 0;
int patchSamplesAdded = 0;
static unsigned short g_PatchIterationKey = 0;
bool SampleData_CompareFunc( SampleData_t const &src1, SampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int SampleData_KeyFunc( SampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<SampleData_t> g_SampleHashTable( SAMPLEHASH_NUM_BUCKETS, 
										  SAMPLEHASH_GROW_SIZE, 
										  SAMPLEHASH_INIT_SIZE, 
										  SampleData_CompareFunc, SampleData_KeyFunc );
UtlHashHandle_t SampleData_Find( sample_t *pSample )
	SampleData_t sampleData;	
	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	return g_SampleHashTable.Find( sampleData );
UtlHashHandle_t SampleData_InsertIntoHashTable( sample_t *pSample, SampleHandle_t sampleHandle )
	Samp

	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	UtlHashHandle_t handle = g_SampleHashTable.AllocEntryFromKey( sampleData );
	SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
	pSampleData->x = sampleData.x;
	pSampleData->y = sampleData.y;
	pSampleData->z = sampleData.z;
	pSampleData->m_Samples.AddToTail( sampleHandle );
	samplesAdded++;
	return handle;
UtlHashHandle_t SampleData_AddSample( sample_t *pSample, SampleHandle_t sampleHandle )
	UtlHashHandle_t handle = SampleData_Find( pSample );
	if( handle == g_SampleHashTable.InvalidHandle() )
	{
		handle = SampleData_InsertIntoHashTable( pSample, sampleHandle );
	}
	else
	{
		SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
		pSampleData->m_Samples.AddToTail( sampleHandle );
		samplesAdded++;
	}
	return handle;
void SampleData_Log( void )
	if

	{
		g_SampleHashTable.Log( "samplehash.txt" );
	}
bool PatchSampleData_CompareFunc( PatchSampleData_t const &src1, PatchSampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int PatchSampleData_KeyFunc( PatchSampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<PatchSampleData_t>	g_PatchSampleHashTable( SAMPLEHASH_NUM_BUCKETS,
												    SAMPLEHASH_GROW_SIZE,
													SAMPLEHASH_INIT_SIZE,
													PatchSampleData_CompareFunc, PatchSampleData_KeyFunc );
void GetPatchSampleHashXYZ( const Vector &vOrigin, int &x, int &y, int &z )
	x = ( int )( vOrigin.x / SAMPLEHASH_VOXEL_SIZE );
	y = ( int )( vOrigin.y / SAMPLEHASH_VOXEL_SIZE );
	z = ( int )( vOrigin.z / SAMPLEHASH_VOXEL_SIZE );
unsigned short IncrementPatchIterationKey()
	if ( g_PatchIterationKey == 0xFFFF )
	{
		g_PatchIterationKey = 1;
		for ( int i=0; i < g_Patches.Count(); i++ )
			g_Patches[i].m_IterationKey = 0;
	}
	else
	{
	

	}
	return g_PatchIterationKey;
void PatchSampleData_AddSample( CPatch *pPatch, int ndxPatch )
	int patchSampleMins[3], patchSampleMaxs[3];
	GetPatchSampleHashXYZ( pPatch->mins, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	GetPatchSampleHashXYZ( pPatch->maxs, patchSampleMaxs[0], patchSampleMaxs[1], patchSampleMaxs[2] );
	GetPatchSampleHashXYZ( pPatch->origin, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	memcpy( patchSampleMaxs, patchSampleMins, sizeof( patchSampleMaxs ) );
	Assert( patchSampleMins[0] <= patchSampleMaxs[0] && patchSampleMins[1] <= patchSampleMaxs[1] && patchSampleMins[2] <= patchSampleMaxs[2] );
	patchSampleMins[0] = min( patchSampleMins[0], patchSampleMaxs[0] );
	patchSampleMins[1] = min( patchSampleMins[1], patchSampleMaxs[1] );
	patchSampleMins[2] = min( patchSampleMins[2], patchSampleMaxs[2] );
	int iterateCoords[3];
	for ( iterateCoords[0]=patchSampleMins[0]; iterateCoords[0] <= patchSampleMaxs[0]; iterateCoords[0]++ )
	{
		for 
using namespace std;
ResourceAsyncLoadTask* ResourceAsyncLoadTask::create() {
    ResourceAsyncLoadTask* task = new ResourceAsyncLoadTask;
    task->autorelease();
    return task;
ResourceAsyncLoadTask::ResourceAsyncLoadTask() :
_target(NULL),
_selector(NULL),
_cache(NULL),
_hasFinished(true),
_hasLoadVideoStarted(false),
_hasLoadImageStarted(false),
_hasLoadPlistStarted(false),
_hasLoadAudioStarted(false),
_resKey(NULL) {
    CC_SAFE_RELEASE_NULL(_resKey);
void ResourceAsyncLoadTask::loadResAsync(const ResourceConfigCache *cache, cocos2d::CCObject *target, SEL_CallFuncO selector, ResourceKey* resKey) {
    _cache = cache;
    _target = target;
    _selector = selector;
    _hasFinished = false;
    _resKey = resKey;
    CC_SAFE_RETAIN(_resKey);
void ResourceAsyncLoadTask::initLoadImages() {
    const map<ImageId, RImageConfig>& imagesConfig = _cache->getImagesConfig();
    _imagesToLoad.clear();
    for (auto iter = imagesConfig.begin(); iter != imagesConfig.end(); iter++) {
        

        _imagesToLoad.push_back(config);
    }
void ResourceAsyncLoadTask::initLoadVideos() {
    const map<VideoId, RVideoConfig>& videosConfig = _cache->getVideosConfig();
    _videosToLoad.clear();
    for (auto iter = videosConfig.begin(); iter != videosConfig.end(); iter++) {
        const RVideoConfig* config = &iter->second;
        _videosToLoad.push_back(config);
    }
void ResourceAsyncLoadTask::initLoadPlists() {
    const map<PlistId, RPlistConfig>& plistsConfig = _cache->getPlistsConfig();
    _plistsToLoad.clear();
    for (auto iter = plistsConfig.begin(); iter != plistsConfig.end(); iter++) {
        const RPlistConfig* config = &iter->second;
        _plistsToLoad.push_back(config);
    }
void ResourceAsyncLoadTask::initLoadAudios() {
    const map<AudioId, RAudioConfig>& audiosConfig = _cache->getAudiosConfig();
    _audiosToLoad.clear();
    for (auto iter = audiosConfig.begin(); iter != audiosConfig.end(); iter++) {
        const RAudioConfig* config = &iter->secon

        _audiosToLoad.push_back(config);
    }
void ResourceAsyncLoadTask::loadImage() {
    if (_imagesToLoad.empty()) {
        return;
    }
    
    const RImageConfig* config = _imagesToLoad.back();
    _imagesToLoad.pop_back();
    ResourceManager::getInstance()->bindKeyToResource(config->getImageId(), _resKey, ResourceManager::IMAGE_CONFIG);
void ResourceAsyncLoadTask::loadVideo() {
    if (_videosToLoad.empty()) {
        return;
    }
    
    const RVideoConfig* config = _videosToLoad.back();
    _videosToLoad.pop_back();
    ResourceManager::getInstance()->bindKeyToResource(config->getVideoId(), _resKey, ResourceManager::VIDEO_CONFIG);
void ResourceAsyncLoadTask::loadAudio() {
    if (_audiosToLoad.empty()) {
        return;
    }
    
    const RAudioConfig* config = _audiosToLoad.back();
    _audiosToLoad.pop_back();
    ResourceManager::getInstance()->bindKeyToResource(config->getAudioId(), _resKey, ResourceManager::AUDIO_CONFIG);
void ResourceAsyncLoadTask::loadPlist() 

    if (_plistsToLoad.empty()) {
        return;
    }
    
    const RPlistConfig* config = _plistsToLoad.back();
    _plistsToLoad.pop_back();
    ResourceManager::getInstance()->loadPlistResource(config->getPlistId(), _resKey);
bool ResourceAsyncLoadTask::hasTaskFinished() const {
    return _hasFinished;
void ResourceAsyncLoadTask::update() {
    if (_hasFinished) {
        return;
    }
    
    if (!_hasLoadImageStarted) {
        initLoadImages();
        _hasLoadImageStarted = true;
    }
    
    loadImage();
    
    if (_imagesToLoad.size() > 0) {
        return;
    }
    
    if (!_hasLoadVideoStarted) {
        initLoadVideos();
        _hasLoadVideoStarted = true;
    }
    
    loadVideo();
    
    if (_videosToLoad.size() > 0) {
        return;
    }
    
    if (!_hasLoadPlistStarted) {
        initLoadPlists();
        _hasLoadPlistStarted = true;
    }
    
    loadPlist();
    
    if (_plistsToLoad.size() > 0) {
        return;
    }
    
    if (!_hasLoadAudioS
namespace stl2 = __stl2;
constexpr struct {
	constexpr auto&& operator()(auto&& arg) const noexcept {
		return (decltype(arg)&&)arg;
	}
} h;
struct A {
	int i = 13;
	constexpr int f() const noexcept { return 42; }
	constexpr int g(int i) { return 2 * i; }
};
constexpr int f() noexcept { return 13; }
constexpr int g(int i) { return 2 * i + 1; }
int main() {
	CHECK(stl2::invoke(f) == 13);
	CHECK(noexcept(stl2::invoke(f) == 13));
	CHECK(stl2::invoke(g, 2) == 5);
	CHECK(stl2::invoke(h, 42) == 42);
	CHECK(noexcept(stl2::invoke(h, 42) == 42));
	{
		int i = 13;
		CHECK(&stl2::invoke(h, i) == &i);
		CHECK(noexcept(&stl2::invoke(h, i) == &i));
	}
	CHECK(stl2::invoke(&A::f, A{}) == 42);
	CHECK(noexcept(stl2::invoke(&A::f, A{}) == 42));
	CHECK(stl2::invoke(&A::g, A{}, 2) == 4);
	{
		A a;
		const auto& ca = a;
		CHECK(stl2::invoke(&A::f, a) == 42);
		CHECK(noexcept(stl2::invoke(&A::f, a) == 42));
		CHECK(stl2::invoke(&A::f, ca) == 42);
		CHECK(noexcept(stl2::invoke(&A::f, ca) == 42));
		CHECK(stl2

	}
	{
		A a;
		const auto& ca = a;
		CHECK(stl2::invoke(&A::f, &a) == 42);
		CHECK(noexcept(stl2::invoke(&A::f, &a) == 42));
		CHECK(stl2::invoke(&A::f, &ca) == 42);
		CHECK(noexcept(stl2::invoke(&A::f, &ca) == 42));
		CHECK(stl2::invoke(&A::g, &a, 2) == 4);
	}
	{
		auto up = std::make_unique<A>();
		CHECK(stl2::invoke(&A::f, up) == 42);
		CHECK(stl2::invoke(&A::g, up, 2) == 4);
	}
	{
		auto sp = std::make_shared<A>();
		CHECK(stl2::invoke(&A::f, sp) == 42);
		CHECK(noexcept(stl2::invoke(&A::f, sp) == 42));
		CHECK(stl2::invoke(&A::g, sp, 2) == 4);
	}
	CHECK(stl2::invoke(&A::i, A{}) == 13);
	CHECK(noexcept(stl2::invoke(&A::i, A{}) == 13));
	{ int&& tmp = stl2::invoke(&A::i, A{}); (void)tmp; }
	{
		A a;
		const auto& ca = a;
		CHECK(stl2::invoke(&A::i, a) == 13);
		CHECK(noexcept(stl2::invoke(&A::i, a) == 13));
		CHECK(stl2::invoke(&A::i, ca) == 13);
		CHECK(noexcept(stl2::invoke(&A::i, ca) == 13));
		CHECK(stl2::invoke(&A::i, &a) == 13);
		CHECK(noexcept(stl2::invoke(&A::i, &a) == 13)

		CHECK(stl2::invoke(&A::i, &ca) == 13);
		CHECK(noexcept(stl2::invoke(&A::i, &ca) == 13));
		stl2::invoke(&A::i, a) = 0;
		CHECK(a.i == 0);
		stl2::invoke(&A::i, &a) = 1;
		CHECK(a.i == 1);
		static_assert(stl2::models::Same<decltype(stl2::invoke(&A::i, ca)), const int&>);
		static_assert(stl2::models::Same<decltype(stl2::invoke(&A::i, &ca)), const int&>);
	}
	{
		auto up = std::make_unique<A>();
		CHECK(stl2::invoke(&A::i, up) == 13);
		stl2::invoke(&A::i, up) = 0;
		CHECK(up->i == 0);
	}
	{
		auto sp = std::make_shared<A>();
		CHECK(stl2::invoke(&A::i, sp) == 13);
		stl2::invoke(&A::i, sp) = 0;
		CHECK(sp->i == 0);
	}
	{
		struct B { int i = 42; constexpr int f() const { return i; } };
		constexpr B b;
		static_assert(b.i == 42);
		static_assert(b.f() == 42);
		static_assert(stl2::__invoke::impl(&B::i, b) == 42);
		static_assert(stl2::__invoke::impl(&B::i, &b) == 42);
		static_assert(stl2::__invoke::impl(&B::i, B{}) == 42);
		static_assert(stl2::__invoke::impl(&B::f, b) == 42);
		s
namespace aw {
namespace core {
namespace base {
boost::mutex ServiceLocator::m_mutex;
boost::weak_ptr<ServiceLocator> ServiceLocator::m_weakInstance;
ServiceLocator::ServiceLocator()
: m_services() {
ServiceLocator::~ServiceLocator() {
ServiceLocatorPtr ServiceLocator::Instance() {
    boost::lock_guard<boost::mutex> guard(m_mutex);
    ServiceLocatorPtr serviceLocator = m_weakInstance.lock();
    if(serviceLocator) {
        return serviceLocator;
    }
    serviceLocator = ServiceLocatorPtr(new ServiceLocator());
    m_weakInstance = serviceLocator;
    return serviceLocator;
void ServiceLocator::RegisterService(IServicePtr service) {
    if(!service) {
        throw std::invalid_argument("Invalid service to register.");
    }
    boost::lock_guard<boost::mutex> guard(m_mutex);
    if(!m_services.insert(std::make_pair(service->GetServiceID(), service)).second) {
        throw std::exception(boost::str(boost::format("Service (%1%) already registered.")
            % boost::uuids::to_
/**
 * Class constructor.
 *
 * @param process		gameserver id that should receive the loaded objects
 */
RequestChunkMessage::RequestChunkMessage  (std::vector<Chunk> chunks, const std::string &sceneId) :
	GameNetworkMessage("RequestChunkMessage"),
	m_chunks(),
	m_sceneId(sceneId)
	m_chunks.set(chunks);
	addVariable(m_chunks);
	addVariable(m_sceneId);
}	
RequestChunkMessage::RequestChunkMessage(Archive::ReadIterator & source) :
		GameNetworkMessage("RequestChunkMessage"),
		m_chunks(),
		m_sceneId()
	addVariable(m_chunks);
	addVariable(m_sceneId);
	unpack(source);
RequestChunkMessage::~RequestChunkMessage()
}	
std::vector<RequestChunkMessage::Chunk> const & RequestChunkMessage::getChunks() const
	return m_chunks.get();
RequestChunkMessage::Chunk::Chunk() :
		m_process(),
		m_nodeX(),
		m_nodeZ()
RequestChunkMessage::Chunk::Chunk(uint32 process, int nodeX, int nodeZ) :
		m_process(process),
		m_nodeX(nodeX),
		m_nodeZ(nodeZ)
namespace Archive
	void get(ReadIterator & source, RequestChun
/******************************************************************************/
/*  Copyright (C), 2007-2013, Hisilicon Technologies Co., Ltd. */
/******************************************************************************/
/* File name     : hi_m3boot_vector.h */
/* Version       : 2.0 */
/* Created       : 2013-05-10*/
/* Last Modified : */
/* Description   : */
/* Function List : */
/* History       : */
/* 1 Date        : */
/* Modification  : Create file */
/******************************************************************************/
    .word     STACK_ENTRY        ;  \
    .word     _start             ;  \
    .word     NmiSR              ;  \
    .word     FaultISR           ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     0                  ;  \
    .word     0                  ;  \
    .word     0                  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandle

    .word     0                  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word  

    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word  

    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word  

    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word     IntDefaultHandler  ;  \
    .word  
namespace mx3 {
    
    class RepoListVmHandle;
    
    class RepoListVm final : public mx3_gen::RepoListVm {
    public:
        RepoListVm(const vector<sqlite::Row> &rows, const std::weak_ptr<RepoListVmHandle> &handle/*, const string repo_url*/);
        virtual int32_t count() override;
        virtual optional<mx3_gen::RepoListVmCell> get(int32_t index) override;
    private:
        const vector<sqlite::Row> m_rows;
        const std::weak_ptr<RepoListVmHandle> m_handle;
        const string m_repo_url;
    };
    
    class RepoListVmHandle final : public mx3_gen::RepoListVmHandle, public std::enable_shared_from_this<RepoListVmHandle> {
    public:
        RepoListVmHandle(
                         shared_ptr<sqlite::Db> db,
                         const mx3::Http &http,
                         string repo_url,
                         int64_t owner_id,
                         const shared_ptr<SingleThreadTaskRunner> &ui_thread,
                         const shared_ptr<Sing
namespace pammo
class PerformanceMonitor
public:
    PerformanceMonitor(char const* name, uint32_t reportFrequency)
    {
        mName = name;
        mReportFrequency = reportFrequency;
        reset();
    }
    virtual ~PerformanceMonitor(){}
    void reset()
    {
        mSampleCount = 0;
        mSampleMin = 0xFFFFFFFF;
        mSampleMax = 0;
        mSampleAve = 0;
    }
    void addSample(float n)
    {
        ++mSampleCount;
        if(n < mSampleMin)
            mSampleMin = n;
        if(n > mSampleMax)
            mSampleMax = n;
        float beta = 0.1;
        mSampleAve = mSampleAve * (1.0 - beta) + (n* beta);
        if(!(mSampleCount%mReportFrequency))
        {
            report();
            reset();
        }
    }
    void report()
    {
        dprintf("%s\nmin\tmax\tave\n%.2f\t%.2f\t%.2f\n", 
            mName.c_str(), mSampleMin, mSampleMax, mSampleAve);
    }
protected:
private:
    std::string mName;
    uint32_t mReportFrequency;
    
    float mSampleA
  Author: Niels A.D
{%MainUnit lpinterpreter.pas}
ocIncCall_Var: DoIncCall_Var();
ocIncCall_PVar: DoIncCall_PVar();
ocIncCall_Ptr: DoIncCall_Ptr();
ocInvokeImported_Var: DoInvokeImported_Var();
ocInvokeImported_PVar: DoInvokeImported_PVar();
ocInvokeImported_Ptr: DoInvokeImported_Ptr();
ocInvokeImported_Var_Stk: DoInvokeImported_Var_Stk();
ocInvokeImported_Var_PStk: DoInvokeImported_Var_PStk();
ocInvokeImported_Var_Var: DoInvokeImported_Var_Var();
ocInvokeImported_Var_PVar: DoInvokeImported_Var_PVar();
ocInvokeImported_Var_Ptr: DoInvokeImported_Var_Ptr();
ocInvokeImported_PVar_Stk: DoInvokeImported_PVar_Stk();
ocInvokeImported_PVar_PStk: DoInvokeImported_PVar_PStk();
ocInvokeImported_PVar_Var: DoInvokeImported_PVar_Var();
ocInvokeImported_PVar_PVar: DoInvokeImported_PVar_PVar();
ocInvokeImported_PVar_Ptr: DoInvokeImported_PVar_Ptr();
ocInvokeImported_Ptr_Stk: DoInvokeImported_Ptr_Stk();
ocInvokeImported_Ptr_PStk: DoInvokeImported_Ptr_PStk();
ocInvokeImported_Ptr_Var: DoInvokeImported_P
void test_getAll(Repository<int> *repo) {
  repo->save(1);
  repo->save(2);
  repo->save(3);
  repo->save(4);
  static const int arr[] = {1, 2, 3, 4};
  vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
  assert(repo->getAll() == vec);
void test_save(Repository<int> *repo) {
  repo->save(5);
  static const int arr[] = {1, 2, 3, 4, 5};
  vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
  assert(repo->getAll() == vec);
void test_insertAtPosition(Repository<int> *repo) {
  repo->insertAtPosition(2, 6);
  static const int arr[] = {1, 2, 6, 3, 4, 5};
  vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
  assert(repo->getAll() == vec);
void test_update(Repository<int> *repo) {
  repo->update(2, 7);
  static const int arr[] = {1, 2, 7, 3, 4, 5};
  vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
  assert(repo->getAll() == vec);
void test_remove(Repository<int> *repo) {
  repo->remove(2);
  static const int arr[] = {1, 2, 3, 4, 5};
  vector<int> vec (ar
/*
 * OGLConsumer.cpp
 *
 *  Created on: Oct 1, 2012
 *      Author: Andrew Zhabura
 */
OGL_Consumer::OGL_Consumer()
:	m_Sample(new Sample * [Sample_QTY])
,	m_SampleNum(0)
	int i = -1;
	m_Sample[++i] = new Sample_8_1;
	m_Sample[++i] = new Sample_8_2;
	m_Sample[++i] = new Sample_8_4;
	m_Sample[++i] = new Sample_8_5;
	m_Sample[++i] = new Sample_8_6;
	m_Sample[++i] = new Sample_8_7;
	m_Sample[++i] = new Sample_8_8;
	m_Sample[++i] = new Sample_8_9;
	m_Sample[++i] = new Sample_8_10;
	m_Sample[++i] = new Sample_9_1;
	m_Sample[++i] = new Sample_9_3;
	m_Sample[++i] = new Sample_9_4;
	m_Sample[++i] = new Sample_9_5;
	m_Sample[++i] = new Sample_9_7;
	m_Sample[++i] = new Sample_9_8;
	m_Sample[++i] = new Sample_10_1;
	m_Sample[++i] = new Sample_10_3;
	m_Sample[++i] = new Sample_10_4;
	m_Sample[++i] = new Sample_10_5;
	m_Sample[++i] = new Sample_10_6;
	m_Sample[++i] = new Sample_11_3;
	m_Sample[++i] = new Sample_11_4;
	m_Sample[++i] = new Sample_12_1;
	m_Sample[++i] = new Sample_12_2;
	m_Sample[++i

	m_Sample[++i] = new Sample_12_4;
	m_Sample[++i] = new Sample_12_5;
	m_Sample[++i] = new Sample_12_7;
	m_Sample[++i] = new Sample_12_8;
	m_Sample[++i] = new Sample_13_2;
	m_Sample[++i] = new Sample_13_3;
	m_Sample[++i] = new Sample_13_6;
	m_Sample[++i] = new Sample_13_7;
	m_Sample[++i] = new Sample_14;
	if ( ++i != Sample_QTY )
		throw this;
OGL_Consumer::~OGL_Consumer()
	for (int i = 0; i < Sample_QTY; ++i)
	{
		if (m_Sample[i])
			delete m_Sample[i];
	}
void OGL_Consumer::setSample(unsigned int SampleNum)
	if (SampleNum >= Sample_QTY)
		return;
	m_SampleNum = SampleNum;
bool OGL_Consumer::sendMessage(unsigned int SampleNum, int message, int mode, int x, int y)
	return m_Sample[m_SampleNum]->sendMessage(message, mode, x, y);
void OGL_Consumer::reshape(unsigned int width, unsigned int height)
	m_Sample[m_SampleNum]->reshape(width, height);
void OGL_Consumer::drawGLScene()
	m_Sample[m_SampleNum]->drawGLScene();
char* OGL_Consumer::getSampleName()
	return m_Sample[m_SampleNum]->getName(
CollisionModel::CollisionModel(Model *model) : model_(model) {
  collision_model_ = newCollisionModel3D();
  try {
    Vec3Vector vertices = model_->vertices();
    std::size_t size = vertices.size();
    for (std::size_t i = 0; i <= size - 3; i += 3) {
      Vec3 v1 = vertices[i];
      Vec3 v2 = vertices[i + 1];
      Vec3 v3 = vertices[i + 2];
	  collision_model_->addTriangle(glm::value_ptr(v1), 
                                    glm::value_ptr(v2), 
                                    glm::value_ptr(v3));
    }
    collision_model_->finalize();
  }
  catch(...) {
    delete collision_model_;
    throw;
  }
CollisionModel::~CollisionModel() {
  delete collision_model_;
Model* CollisionModel::model() const {
  return model_;
CollisionModel3D* CollisionModel::collision_model() const {
  return collision_model_;
bool CollisionModel::Collision(CollisionModel &colmod) {
  Model *mod = colmod.model();
  CollisionModel3D *col = colmod.collision_model();
  Mat4 transform1 = model_->transf
/**
 * @file SampleMergeManager.h
 * @brief interfaces of SampleMergeManager class
 *
 * @author S.Tanaka
 * @date 2009.03.03
 * 
 * Copyright(C) 2006-2014 Eisai Co., Ltd. All rights reserved.
 */
namespace kome {
	namespace merged {
		class MergedSampleSet;
		/**
		 * @class SampleMergeManager
		 * @brief merged management class
		 */
		class SampleMergeManager : public kome::objects::DefaultDataManager {
		protected:
			/**
			 * @fn SampleMergeManager()
			 * @brief constructor
			 */
			SampleMergeManager();
			/**
			 * @fn virtual ~SampleMergeManager()
			 * @brief destructor
			 */
			virtual ~SampleMergeManager();
		protected:
			/** merged sample ID */
			unsigned int m_id;
			/** merged sample sets */
			std::vector< MergedSampleSet* > m_sampleSets;
		
		public:
			/**
			 * @fn void addSampleSet( MergedSampleSet* sampleSet )
			 * @brief adds sample set
			 * @param sampleSet sample set object to be added
			 */
			void addSampleSet( MergedSampleSet* sampleSet );
			/**
			 
using namespace vox;
ChunkLoader::ChunkLoader(void)	:
	_running(true), _thread(nullptr)
ChunkLoader::~ChunkLoader(void)
bool
ChunkLoader::Init(void)
	_thread = new (std::nothrow) std::thread(&vox::ChunkLoader::Run, this);
	if (_thread == nullptr)
		return false;
	return true;
void
ChunkLoader::Destroy(void)
	if (_thread != nullptr)
	{
		Quit();
		_thread->join();
		delete _thread;
	}
void
ChunkLoader::Run(void)
	while (_running)
	{
		ChunkToLoad*	toLoad = _GetChunkToLoad();
		
		if (toLoad == nullptr)
			Sleep(15);
		else
		{
			if (!_LoadChunk(toLoad))
				Quit();
		}
	}
bool
ChunkLoader::AddChunkToLoad(int x, int y, int z, void* data, int compressSize)
	try
	{
		ChunkToLoad*	toLoad = new (std::nothrow) ChunkToLoad;
		toLoad->x = x;
		toLoad->y = y;
		toLoad->z = z;
		toLoad->data = data;
		toLoad->compressSize = compressSize;
		 std::lock_guard<std::mutex> locker(_chunkToLoadMutex);
		_chunkToLoad.push(toLoad);
	}
	catch (std::bad_alloc)
	{
		delete data;
		return false;
	} 
	return 

Chunk*
ChunkLoader::GetLoadedChunks(void)
	 std::unique_lock<std::mutex> locker(_chunkLoadedMutex,std::defer_lock);
	 if (locker.try_lock() && !_chunkLoaded.empty())
	 {
		 Chunk* toReturn = _chunkLoaded.front();
		 _chunkLoaded.pop();
		 return toReturn;
	 }
	 else
		 return nullptr;
ChunkLoader::ChunkToLoad*
ChunkLoader::_GetChunkToLoad(void)
	ChunkToLoad*	toLoad = nullptr;
	std::lock_guard<std::mutex> toLoadlocker(_chunkToLoadMutex);
	std::lock_guard<std::mutex> loadedlocker(_chunkLoadedMutex);
	if (!_chunkToLoad.empty() && _chunkLoaded.size() < 5)
	{
		toLoad = _chunkToLoad.front();
		_chunkToLoad.pop();
	}
	return toLoad;
bool
ChunkLoader::_LoadChunk(ChunkToLoad* toLoad)
	const int uncompressSize = Chunk::CHUNK_SIZE * Chunk::CHUNK_SIZE * Chunk::CHUNK_SIZE * sizeof(char);
	Bytef* uncompressData = new (std::nothrow) Bytef[uncompressSize];
	if (uncompressData == nullptr)
	{
		delete toLoad->data;
		delete toLoad;
		return false;
	}
	uLongf size = uncompressSize;
	uLongf compSize = t
bool Chunk::isStrictelyInside(const sf::Vector3i & blockPosition)
	return blockPosition.x > 0 && blockPosition.y > 0 && blockPosition.z > 0 &&
			blockPosition.x < SIZE_1 && blockPosition.y < SIZE_1 && blockPosition.z < SIZE_1;
Chunk::Chunk() : mPosition(), mNeedRebuild(false), mIsModified(false)
	mData = new ChunkData();
void Chunk::reset() {
	mPosition.x=mPosition.y=mPosition.z=0x7FFFFFFF;
	mIsModified = false;
const ChunkCoordinate & Chunk::getPosition() const
	return mPosition;
void Chunk::setPosition(const ChunkCoordinate &position)
	mPosition = position;
bool Chunk::rebuild()
	if (hasData() && mNeedRebuild) {
		const LocalChunkSystem local(*mManager, this);
		mData->rebuild(local);
		mNeedRebuild = false;
		return true;
	}
	return false;
void Chunk::draw(const MeshDetail detail) const
	glDisable(GL_LIGHTING);
	if (!hasData())
		glBegin(GL_POINTS);
	else
		glBegin(GL_LINES);
		if (!hasData())
			glColor3f(1,.7,1);
		else	
			glColor3f(.7,detail,detail/2.0);
		glVertex3f(0,0,0);glV

		glVertex3f(0,0,0);glVertex3f(0,Chunk::SIZE,0);
		glVertex3f(0,0,0);glVertex3f(0,0,Chunk::SIZE);
		
		glVertex3f(Chunk::SIZE,Chunk::SIZE,Chunk::SIZE);glVertex3f(Chunk::SIZE,0,Chunk::SIZE);
		glVertex3f(Chunk::SIZE,Chunk::SIZE,Chunk::SIZE);glVertex3f(0,Chunk::SIZE,Chunk::SIZE);
		glVertex3f(Chunk::SIZE,Chunk::SIZE,Chunk::SIZE);glVertex3f(Chunk::SIZE,Chunk::SIZE,0);
		
		glVertex3f(Chunk::SIZE,0,0);glVertex3f(Chunk::SIZE,Chunk::SIZE,0);
		glVertex3f(Chunk::SIZE,0,0);glVertex3f(Chunk::SIZE,0,Chunk::SIZE);
		glVertex3f(Chunk::SIZE,0,Chunk::SIZE);glVertex3f(0,0,Chunk::SIZE);
		
		glVertex3f(0,Chunk::SIZE,0);glVertex3f(Chunk::SIZE,Chunk::SIZE,0);
		glVertex3f(0,Chunk::SIZE,0);glVertex3f(0,Chunk::SIZE,Chunk::SIZE);
		glVertex3f(0,Chunk::SIZE,Chunk::SIZE);glVertex3f(0,0,Chunk::SIZE);
	glEnd();
	glEnable(GL_LIGHTING);
	if (hasData())
		mData->getMesh().draw(detail);
void Chunk::load()
	mManager->loadChunk(this);
void Chunk::beginSet(bool playerAction)
	mIsModified = playerAction;	
void Chunk:
{ Chunk names }
  const
        MingChunk_BASI               = $49534142; { BASI }
        MingChunk_DEFI               = $49464544; { DEFI }
        MingChunk_FRAM               = $4D415246; { FRAM }
        MingChunk_GAMA               = $414D4167; { gAMA }
        MingChunk_IDAT               = $54414449; { IDAT }
        MingChunk_IEND               = $444E4549; { IEND }
        MingChunk_IHDR               = $52444849; { IHDR }
        MingChunk_JHDR               = $5244484A; { JHDR }
        MingChunk_JDAT               = $5441444A; { JDAT }
        MingChunk_JSEP               = $00000000; { JSEP }
        MingChunk_MEND               = $444E454D; { MEND }
        MingChunk_MHDR               = $5244484D; { MHDR }
        MingChunk_PLTE               = $45544C50; { PLTE }
        MingChunk_TEXT               = $74584574; { tEXt }
        MingChunk_ZTXT               = $7458547A; { zTXt }
        MingChunk_NoChunk            = $40402020;
  { Long chunk names }
  const MingChunk_
/*===================================================================
BlueBerry Platform
Copyright (c) German Cancer Research Center,
Division of Medical and Biological Informatics.
All rights reserved.
This software is distributed WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.
===================================================================*/
namespace berry {
struct IServiceLocator;
class Object;
/**
 * A factory for creating services for use with the
 * <code>org.blueberry.ui.services</code> extension point. You are given a
 * service locator to look up other services, and can retrieve your parent
 * service (if one has already been created).
 */
struct BERRY_UI_QT IServiceFactory {
  virtual ~IServiceFactory();
  /**
   * When a service locator cannot find a service it will request one from the
   * registry, which will call this factory create method.
   * <p>
   * You can use the locator to get any needed service

   * locator will be provided if you need access to the parent service. If the
   * parent object return from the parent locator is not <code>null</code>
   * it can be cast to the service interface that is requested. The parent
   * service locator will only return the serviceInterface service.
   * </p>
   *
   * @param serviceInterface
   *            the service we need to create. Will not be <code>null</code>.
   * @param parentLocator
   *            A locator that can return a parent service instance if
   *            desired. The parent service can be cast to serviceInterface.
   *            Will not be <code>null</code>.
   * @param locator
   *            the service locator which can be used to retrieve dependent
   *            services. Will not be <code>null</code>
   * @return the created service or <code>null</code>
   */
  template<class S>
  S* Create(IServiceLocator* parentLocator, IServiceLocator* locator) const
  {
    return dynamic_cast<S*>(this->Create(qobjec
namespace bookmarks {
void BaseBookmarkModelObserver::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BaseBookmarkModelObserver::BookmarkModelBeingDeleted(
    BookmarkModel* model) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
                                                  int index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeRemoved(
    BookmarkModel* model,
    const BookmarkNode* parent,
    int old_index,
    const BookmarkNode* node,
    const std::set<GURL>& removed_urls) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::B
extern MDS* mds;
void Syncer::pullRepo(HostInfo &localHost,
        HostInfo &remoteHost,
        const std::string &uuid)
    RepoInfo local = localHost.getRepo(uuid);
    RepoInfo remote = remoteHost.getRepo(uuid);
    RepoControl repo = RepoControl(local.getPath());
    DLOG("Local and Remote heads mismatch on repo %s", uuid.c_str());
    repo.open();
    if (!repo.hasCommit(remote.getHead())) {
        LOG("Pulling from %s:%s",
            remoteHost.getPreferredIp().c_str(),
            remote.getPath().c_str());
        repo.pull(remoteHost.getPreferredIp(), remote.getPath());
    }
    repo.close();
void Syncer::checkRepo(HostInfo &infoSnapshot, const std::string &uuid)
    std::map<std::string, HostInfo *> hostSnapshot;
    std::map<std::string, HostInfo *>::iterator it;
    RepoInfo localInfo = infoSnapshot.getRepo(uuid);
    hostSnapshot = MDS::instance().hosts;
    for (it = hostSnapshot.begin(); it != hostSnapshot.end(); it++) {
    	std::list<std::string> repos = it->secon
namespace Graphics
    /**
      * GÃ¨re l'affichage des tiles d'un chunk dans un QGraphicsItem
      * @brief GÃ¨re l'affichage des tiles d'un chunk
      * @author Sam101
      */
    class TileChunkItem : public QGraphicsItem
    {
        protected:
            /**
              * Position X du chunk
              */
            qint32 _xChunk;
            /**
              * Position Y du chunk
              */
            qint32 _yChunk;
            /**
              * Pointeur vers le Chunk duquel on doit dessiner les tiles
              */
            Chunk::Chunk *_chunk;
            /**
              * Tableau contenant les pixmap des tiles
              */
            static QVector<QImage> _tiles;
            /**
              * BoundingRect de l'item
              */
            QRectF _boundingRect;
        public:
            /**
              * Constructeur
              */
            TileChunkItem(Chunk::Chunk *chunk);
            /**
              * Renvoie le bounding
namespace net {
namespace {
TEST(LoadLogUtilTest, Basic) {
  scoped_refptr<LoadLog> log(new LoadLog(10));
  log->Add(LoadLog::Entry(MakeTime(1),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_BEGIN)));
  log->Add(
      LoadLog::Entry(
          MakeTime(5),
          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                         LoadLog::PHASE_BEGIN)));
  log->Add(
       LoadLog::Entry(
           MakeTime(8),
           LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                          LoadLog::PHASE_END)));
  log->Add(LoadLog::Entry(MakeTime(12),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  log->Add(LoadLog::Entry(MakeTime(131),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_END

  EXPECT_EQ(
    "t=  1: +HOST_RESOLVER_IMPL                    [dt=130]\n"
    "t=  5:    HOST_RESOLVER_IMPL_OBSERVER_ONSTART [dt=  3]\n"
    "t= 12:    CANCELLED\n"
    "t=131: -HOST_RESOLVER_IMPL",
    LoadLogUtil::PrettyPrintAsEventTree(log));
TEST(LoadLogUtilTest, Basic2) {
  scoped_refptr<LoadLog> log(new LoadLog(10));
  log->Add(LoadLog::Entry(MakeTime(1),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_BEGIN)));
  log->Add(LoadLog::Entry(MakeTime(12), "Sup foo"));
  log->Add(LoadLog::Entry(MakeTime(12), ERR_UNEXPECTED));
  log->Add(LoadLog::Entry(MakeTime(14), "Multiline\nString"));
  log->Add(LoadLog::Entry(MakeTime(131),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_END)));
  EXPECT_EQ(
    "t=  1: +HOST_RESOLVER_IMPL   [dt=130]\n"
    "t= 12:    \"Sup foo\"\n"
    "t= 12:    error code: -9 (net::ERR_UNEXPECTE

    "t= 14:    \"Multiline\n"
    "String\"\n"
    "t=131: -HOST_RESOLVER_IMPL",
    LoadLogUtil::PrettyPrintAsEventTree(log));
TEST(LoadLogUtilTest, UnmatchedOpen) {
  scoped_refptr<LoadLog> log(new LoadLog(10));
  log->Add(LoadLog::Entry(MakeTime(3),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_BEGIN)));
  log->Add(
      LoadLog::Entry(
          MakeTime(6),
          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                         LoadLog::PHASE_BEGIN)));
  log->Add(
      LoadLog::Entry(
          MakeTime(7),
          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                         LoadLog::PHASE_BEGIN)));
  log->Add(
      LoadLog::Entry(
          MakeTime(8),
          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                         LoadLog::PHASE_BEGIN)));
  log->Add(LoadLog::Entry(MakeTime(10),
                

                                         LoadLog::PHASE_NONE)));
  log->Add(LoadLog::Entry(MakeTime(16),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_END)));
  EXPECT_EQ(
    "t= 3: +HOST_RESOLVER_IMPL                          [dt=13]\n"
    "t= 6:   +HOST_RESOLVER_IMPL_OBSERVER_ONSTART       [dt=10]\n"
    "t= 7:     +HOST_RESOLVER_IMPL_OBSERVER_ONSTART     [dt= 9]\n"
    "t= 8:       +HOST_RESOLVER_IMPL_OBSERVER_ONSTART   [dt= 8]\n"
    "t=10:          CANCELLED\n"
    "t=16: -HOST_RESOLVER_IMPL",
    LoadLogUtil::PrettyPrintAsEventTree(log));
TEST(LoadLogUtilTest, DisplayOfTruncated) {
  size_t kMaxNumEntries = 5;
  scoped_refptr<LoadLog> log(new LoadLog(kMaxNumEntries));
  log->Add(LoadLog::Entry(MakeTime(0),
                          LoadLog::Event(LoadLog::TYPE_TCP_CONNECT,
                                         LoadLog::PHASE_BEGIN)));
  for (size_t i = 1; i < 8; ++i) {
    log->Add(LoadLog:
/*
 *  hdata_writer.h
 *  C Library
 *
 *  Created by hailong zhang on 10-10-10.
 *  Copyright 2010 hailongz. All rights reserved.
 *
 */
extern "C" {
	extern hdata_class_t hdata_class;
	hdata_t hdata_null_alloc(InvokeTickDeclare);
	hdata_t hdata_object_alloc(InvokeTickDeclare);
	hdata_t hdata_array_alloc(hint32 capacity,hint32 extendSize,InvokeTickDeclare);
	hdata_t hdata_int16_alloc(hint16 value,InvokeTickDeclare);
	hdata_t hdata_int32_alloc(hint32 value,InvokeTickDeclare);
	hdata_t hdata_int64_alloc(hint64 value,InvokeTickDeclare);
	hdata_t hdata_double_alloc(hdouble value,InvokeTickDeclare);
	hdata_t hdata_boolean_alloc(hbool value,InvokeTickDeclare);
	hdata_t hdata_string_alloc(hcchar * value,InvokeTickDeclare);
    hdata_t hdata_bytes_alloc(hbyte * data,hint32 length,InvokeTickDeclare);
	void hdata_object_put(hdata_t data,hcchar * key,hdata_t value,InvokeTickDeclare);
	void hdata_object_remove(hdata_t data,hcchar * key,InvokeTickDeclare);
	hmap_t hdata_object_map(hdata_t data,Inv
void FStream_Destroy(FStream* pfStream)
    if (pfStream->pFile != NULL)
    {
        fclose(pfStream->pFile);
    }
    String_Destroy(&pfStream->fileName);
Result FStream_Init(FStream* pfStream)
    pfStream->line = 1;
    pfStream->col = 1;
    String_Init(&pfStream->fileName, NULL);
    pfStream->pFile = NULL;
    return RESULT_OK;
Result FStream_Open(FStream* pfStream,
                    const char* fileName)
    Result result = RESULT_FAIL;
    FILE* pFile = fopen(fileName, "r,ccs=UTF-8");
    if (pFile != NULL)
    {
        pfStream->pFile = pFile;
        result = String_Change(&pfStream->fileName,
                               fileName);
    }
    return result;
Result FStream_InitOpen(FStream* pfStream, const char* fileName)
    Result result = FStream_Init(pfStream);
    if (result == RESULT_OK)
    {
        result = FStream_Open(pfStream, fileName);
        if (result != RESULT_OK)
        {
            pfStream->pFile = NULL;
        }
    }
    return result;
Result 

    int c = fgetwc(pfStream->pFile);
    if (ferror(pfStream->pFile) != 0)
    {
        return RESULT_FAIL;
    }
    if (c == WEOF)
    {
        *ch = L'\0';
        return RESULT_EOF;
    }
    if (c == L'\n' ||
            c == L'\r')
    {
        pfStream->line++;
        pfStream->col = 1;
    }
    else
    {
        pfStream->col++;
    }
    *ch = (wchar_t)c;
    return RESULT_OK;
Result FStream_Unget(FStream* pfStream, wchar_t ch)
    int r = ungetwc(ch, pfStream->pFile);
    if (r == WEOF)
    {
    }
    if (ch == L'\r' || ch == L'\n')
    {
        if (pfStream->line > 1)
        {
            pfStream->line--;
        }
    }
    else
    {
        if (pfStream->col > 1)
        {
            pfStream->col--;
        }
    }
    return RESULT_OK;
void SStream_Destroy(SStream* pfStream)
    String_Destroy(&pfStream->name);
Result SStream_Init(SStream* pfStream,
                    const char* pszName,
                    const wchar_t* psz)
    String_Init(&pfStream->na

    pfStream->line = 1;
    pfStream->col = 0;
    pfStream->pCharacteres = psz;
    pfStream->pCurrentChar = pfStream->pCharacteres;
    pfStream->putBackCharacter = L'\0';
    return RESULT_OK;
Result SStream_Get(SStream* pfStream, wchar_t* ch)
    Result result;
    if (pfStream->putBackCharacter != L'\0')
    {
        *ch = pfStream->putBackCharacter;
        pfStream->putBackCharacter = L'\0';
        result = RESULT_OK;
    }
    else if (*pfStream->pCurrentChar == L'\0')
    {
        *ch = L'\0';
        result = RESULT_OK;
    }
    else
    {
        *ch = *pfStream->pCurrentChar;
        pfStream->pCurrentChar++;
        result = RESULT_OK;
    }
    if (result == RESULT_OK &&
            (*ch == L'\n' ||
             *ch == L'\r'))
    {
        pfStream->line++;
        pfStream->col = 1;
    }
    else
    {
        pfStream->col++;
    }
    return result;
Result SStream_Unget(SStream* pfStream, wchar_t ch)
    if (ch == L'\r' || ch == L'\n')
    {
        if (pfStream

        {
            pfStream->line--;
        }
    }
    else
    {
        if (pfStream->col > 1)
        {
            pfStream->col--;
        }
    }
    pfStream->putBackCharacter = ch;
    return RESULT_OK;
void Stream_Destroy(Stream* pfStream)
    if (pfStream->type == 1)
        FStream_Destroy(&pfStream->streamObj.fstream);
    else if (pfStream->type == 2)
        SStream_Destroy(&pfStream->streamObj.sstream);
Result Stream_InitOpen(Stream* pfStream,
                       const char* fileName)
    pfStream->type = 1;
    return FStream_InitOpen(&pfStream->streamObj.fstream, fileName);
Result Stream_InitStr(Stream* pfStream,
                      const char* pszName,
                      const wchar_t* psz)
    pfStream->type = 2;
    return SStream_Init(&pfStream->streamObj.sstream, pszName, psz);
const char* Stream_GetName(Stream* pfStream)
    if (pfStream->type == 1)
        return pfStream->streamObj.fstream.fileName;
    return pfStream->streamObj.sstream.name;
Res
String Decl::dump()
    String str = "int ";
    str += this->identifier;
    if(this->array)
    {
        str += "[";
        str += (long)this->arraySize;
        str += "]";
    }
    return str;
String Decls::dump()
    String str = "";
    for(int i=0; i<decls->getSize();i++)
    {
        Decl *decl = this->decls->getValue(i);
        str += decl->dump();
        
        str += "; ";
    }
    return str;
String OpExp::dump()
    String str = "";
    if(this->op != NULL && this->exp != NULL)
    {
        str += op->dump();
        str += exp->dump();
    }
    return str; 
String Op::dump()
    static String items[] = { "+", "-", "*", "/", "<", "=", ">", "<=>", "&", "!" };
    String str = " ";
    str += items[this->type];
    str += " ";
    return str;
String Index::dump()
{ 
    if(exp != NULL)
    {
        String str = "[";
        str += exp->dump();
        str += "]";
        return str; 
    }
    return "";
String Exp2_1::dump() 
    String str = "(";
    str += exp

    str += ")";
    return str; 
String Exp2_2::dump()
    String str = this->identifier;
    str += index->dump();
    return str; 
String Exp2_3::dump() 
    String str = "";
    str += integer;
    return str; 
String Exp2_4::dump()
    String str = "-";
    str += exp2->dump();
    return str;
String Exp2_5::dump()
    String str = "!";
    str += exp2->dump();
    return str;
String Exp::dump() 
{ 
    String str = exp2->dump();
    str += opexp->dump();
    return str;
String Statement_1::dump()
    String str = this->identifier;
    if(index != NULL)
        str += index->dump();
    str += " = ";
    str += exp->dump();
    return str; 
String Statement_2::dump()
    String str = "print( ";
    str += exp->dump();
    str += " )";
    return str; 
String Statement_3::dump()
    String str = "read( ";
    str += identifier;
    str += " )";
    return str; 
String Statement_4::dump() 
{ 
    String str = "{\n";
    str += statements->dump();
    str += "}";
    return str; 
Str
CPPUNIT_TEST_SUITE_REGISTRATION(ChunkListTest);
namespace tr1 { using namespace std::tr1; }
torrent::Chunk*
func_create_chunk(uint32_t index, int prot_flags) {
  char* memory_part1 = (char*)mmap(NULL, 10, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
  if (memory_part1 == MAP_FAILED)
    throw torrent::internal_error("func_create_chunk() failed: " + std::string(strerror(errno)));
  std::memset(memory_part1, index, 10);
  torrent::Chunk* chunk = new torrent::Chunk();
  chunk->push_back(torrent::ChunkPart::MAPPED_MMAP, torrent::MemoryChunk(memory_part1, memory_part1, memory_part1 + 10, torrent::MemoryChunk::prot_read, 0));
  if (chunk == NULL)
    throw torrent::internal_error("func_create_chunk() failed: chunk == NULL.");
  return chunk;
uint64_t
func_free_diskspace(torrent::ChunkList* chunk_list) {
  return 0;
void
func_storage_error(torrent::ChunkList* chunk_list, const std::string& message) {
void
ChunkListTest::test_basic() {
  torrent::ChunkManager chunk_manager;
  torren

  CPPUNIT_ASSERT(chunk_list.flags() == 0);
  CPPUNIT_ASSERT(chunk_list.chunk_size() == 0);
  chunk_list.set_chunk_size(1 << 16);
  chunk_list.set_manager(&chunk_manager);
  chunk_list.resize(32);
  CPPUNIT_ASSERT(chunk_list.size() == 32);
  CPPUNIT_ASSERT(chunk_list.chunk_size() == (1 << 16));
  for (unsigned int i = 0; i < 32; i++)
    CPPUNIT_ASSERT(chunk_list[i].index() == i);
void
ChunkListTest::test_get_release() {
  SETUP_CHUNK_LIST();
  CPPUNIT_ASSERT(!(*chunk_list)[0].is_valid());
  torrent::ChunkHandle handle_0 = chunk_list->get(0);
  CPPUNIT_ASSERT(handle_0.object() != NULL);
  CPPUNIT_ASSERT(handle_0.object()->index() == 0);
  CPPUNIT_ASSERT(handle_0.index() == 0);
  CPPUNIT_ASSERT(!handle_0.is_writable());
  CPPUNIT_ASSERT(!handle_0.is_blocking());
  CPPUNIT_ASSERT((*chunk_list)[0].is_valid());
  CPPUNIT_ASSERT((*chunk_list)[0].references() == 1);
  CPPUNIT_ASSERT((*chunk_list)[0].writable() == 0);
  CPPUNIT_ASSERT((*chunk_list)[0].blocking() == 0);
  chunk_list->release(&

  torrent::ChunkHandle handle_1 = chunk_list->get(1, torrent::ChunkList::get_writable);
  CPPUNIT_ASSERT(handle_1.object() != NULL);
  CPPUNIT_ASSERT(handle_1.object()->index() == 1);
  CPPUNIT_ASSERT(handle_1.index() == 1);
  CPPUNIT_ASSERT(handle_1.is_writable());
  CPPUNIT_ASSERT(!handle_1.is_blocking());
  CPPUNIT_ASSERT((*chunk_list)[1].is_valid());
  CPPUNIT_ASSERT((*chunk_list)[1].references() == 1);
  CPPUNIT_ASSERT((*chunk_list)[1].writable() == 1);
  CPPUNIT_ASSERT((*chunk_list)[1].blocking() == 0);
  chunk_list->release(&handle_1);
  torrent::ChunkHandle handle_2 = chunk_list->get(2, torrent::ChunkList::get_blocking);
  CPPUNIT_ASSERT(handle_2.object() != NULL);
  CPPUNIT_ASSERT(handle_2.object()->index() == 2);
  CPPUNIT_ASSERT(handle_2.index() == 2);
  CPPUNIT_ASSERT(!handle_2.is_writable());
  CPPUNIT_ASSERT(handle_2.is_blocking());
  CPPUNIT_ASSERT((*chunk_list)[2].is_valid());
  CPPUNIT_ASSERT((*chunk_list)[2].references() == 1);
  CPPUNIT_ASSERT((*chunk_list)[2].writa
/*
** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;
static void error(LoadState* S, const char* why)
 luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
 luaD_throw(S->L,LUA_ERRSYNTAX);
static void LoadBlock(LoadState* S, void* b, size_t size)
 size_t r=luaZ_read(S->Z,b,size);
 IF (r!=0, "unexpected end");
static int LoadChar(LoadState* S)
 char x;
 LoadVar(S,x);
 return x;
static int LoadInt(LoadState* S)
 int x;
 LoadVar(S,x);
 IF (x<0, "bad integer");
 return x;
static lua_Number LoadNumber(LoadState* S)
 lua_Number x;
 LoadVar(S,x);
 return x;
static TString* LoadString(LoadState* S)
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S->L,S->b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
 }
static void LoadCode

 int n=LoadInt(S);
 f->code=luaM_newvector(S->L,n,Instruction);
 f->sizecode=n;
 LoadVector(S,f->code,n,sizeof(Instruction));
static Proto* LoadFunction(LoadState* S, TString* p);
static void LoadConstants(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->k=luaM_newvector(S->L,n,TValue);
 f->sizek=n;
 for (i=0; i<n; i++) setnilvalue(&f->k[i]);
 for (i=0; i<n; i++)
 {
  TValue* o=&f->k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S)!=0);
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S->L,o,LoadString(S));
	break;
   default:
	error(S,"bad constant");
	break;
  }
 }
 n=LoadInt(S);
 f->p=luaM_newvector(S->L,n,Proto*);
 f->sizep=n;
 for (i=0; i<n; i++) f->p[i]=NULL;
 for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
static void LoadDebug(LoadState* S, Proto* f)
 int i,n;
 n=LoadInt(S);
 f->lineinfo=luaM_newvector(S->L,n,int);
 f->sizelinei

 LoadVector(S,f->lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f->locvars=luaM_newvector(S->L,n,LocVar);
 f->sizelocvars=n;
 for (i=0; i<n; i++) f->locvars[i].varname=NULL;
 for (i=0; i<n; i++)
 {
  f->locvars[i].varname=LoadString(S);
  f->locvars[i].startpc=LoadInt(S);
  f->locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f->upvalues=luaM_newvector(S->L,n,TString*);
 f->sizeupvalues=n;
 for (i=0; i<n; i++) f->upvalues[i]=NULL;
 for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
static Proto* LoadFunction(LoadState* S, TString* p)
 Proto* f;
 if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,"code too deep");
 f=luaF_newproto(S->L);
 setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
 f->source=LoadString(S); if (f->source==NULL) f->source=p;
 f->linedefined=LoadInt(S);
 f->lastlinedefined=LoadInt(S);
 f->nups=LoadByte(S);
 f->numparams=LoadByte(S);
 f->is_vararg=LoadByte(S);
 f->maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), "bad code");
 
using namespace std;
int ston(string s){
    int ret=0;
    int i,j;
    if(s[0] == '-'){
        for(i=s.size()-1, j=1;i>=1;i--,j*=10){
            ret += -int(s[i]-'0')*j;
        }
    }else{
        for(i=s.size()-1, j=1;i>=0;i--,j*=10){
            ret += int(s[i]-'0')*j;
        }
    }
    return ret;
int main(){
    while(1){
        int n;
        int sample[1002];
        cin >> n;
        if(n == 0) break;
        for(int i=1;i<=n;i++){
            string s;
            cin >> s;
            if(s == "x"){
                if(i%2 == 0){
                    sample[i] = INF;
                }else{
                    sample[i] = -INF;
                }
            }else{
                sample[i] = ston(s);
            }
        }
        sample[0] = INF;
        if(n%2 == 0){
            sample[n+1] = -INF;
        }else{
            sample[n+1] = INF;
        }
        int mmin = -INF;
        int mmax = INF;
        bool nonef = false;
        for(int i=1;i<=n;i++){
         
const uint BondChunkHeader::CHUNK_SIZE = 16;
/** ìì±ì.
  */
BondChunkHeader::BondChunkHeader(
        const QString &chunkName
        ) :
    chunkName_(chunkName),
    attrSize_(0),
    subChunkSize_(0),
    chunkDataSize_(0)
/** BondChunkHeader ì­ì§ë ¬í ìíì.
  @throw í¬ë©§ ê²½ê³ê° ìëª»ë ê²½ì° BondReadExceptionë¥¼ ëì§ëë¤.
  */
QDataStream& operator>>(
        )
    char chunkName[5] = {'\0',};
    if ( in.readRawData(chunkName, 4) == -1 ) {
        throw BondReadException();
    }
    if ( bondChunkHeader.chunkName_ != chunkName ) {
        throw BondReadException();
    }
    in >> bondChunkHeader.attrSize_;
    in >> bondChunkHeader.subChunkSize_;
    in >> bondChunkHeader.chunkDataSize_;
    return in;
/** ì²­í¬ì ì´ë¦ì ë°íí©ëë¤.
  @return ì²­í¬ì ì´ë¦
  */
QString BondChunkHeader::chunkName() const
    return chunkName_;
/** ìì± ì²­í¬ì í¬ê¸°ë¥¼ ë°íí©ëë¤.
  @return ìì± ì²­í¬ì í¬ê¸°
  */
quint32 BondChunkHeader::attrSize() const
    return attrSize_;
/** ëª¨ë  íì ì²­í¬ì í¬ê¸°ì í©ì ë°íí©ëë¤.
  @return ëª¨ë  íì ì²­í¬ì í¬ê¸°ì í©
  */
quint32 BondChunkHeader::su
namespace Tests 
void CassandraTests::timeSeriesModelLoadsParamNames()
    GUI::TimeSeriesModel model;
    model.loadGroupFile("../data/EDA/groupResults.csv");
    QCOMPARE(int(model.paramNames().size()),2);
    QCOMPARE(model.paramNames().at(0).c_str(),"width_size");
    QCOMPARE(model.paramNames().at(1).c_str(),"value_numAgents");
void CassandraTests::timeSeriesModelLoadsResultNames()
    GUI::TimeSeriesModel model;
    model.loadGroupFile("../data/EDA/groupResults.csv");
    QCOMPARE(int(model.resultNames().size()),4);
    
    QCOMPARE(model.resultNames().at(0).c_str(),"Sum exists");
    QCOMPARE(model.resultNames().at(1).c_str(),"Mean resources");
    QCOMPARE(model.resultNames().at(2).c_str(),"Mean x");
    QCOMPARE(model.resultNames().at(3).c_str(),"Mean y");
void CassandraTests::timeSeriesModelLoadsTimeSteps()
    GUI::TimeSeriesModel model;
    model.loadGroupFile("../data/EDA/groupResults.csv");
    QCOMPARE(int(model.timeSteps().size()),11);
    for(size_t i=0; i<model.timeS

    {
        QCOMPARE(int(model.timeSteps().at(i)),int(i));
    }
void CassandraTests::timeSeriesModelLoadParams()
    GUI::TimeSeriesModel model;
    model.loadGroupFile("../data/EDA/groupResults.csv");
    QCOMPARE(int(model.numRuns()),100);
    QCOMPARE(float(model.params(25, 0)),80.0f);
    QCOMPARE(float(model.params(48, 1)),10.0f);
void CassandraTests::timeSeriesModelLoadResults()
    GUI::TimeSeriesModel model;
    model.loadGroupFile("../data/EDA/groupResults.csv");
    QCOMPARE(float(model.results(14, 0, 8)), 5.00f);
    QCOMPARE(float(model.results(14, 1, 5)), 13.40f);
    QCOMPARE(float(model.results(14, 2, 0)), 4.20f);
    QCOMPARE(float(model.results(14, 3, 10)), 5.20f);
void CassandraTests::timeSeriesModelMean()
    GUI::TimeSeriesModel model;
    model.loadGroupFile("../data/EDA/groupResults.csv");
    model.selectResult(0);
    QCOMPARE(float(model.mean(5)), 5.5f);
    model.selectResult(1);
    QCOMPARE(float(model.mean(1)), 6.4528f);
    model.selectResult(2);
    Q
/*
 * Copyright (c) 2014-2015 TIBCO Software Inc.
 * All rights reserved.
 * For more information, please contact:
 * TIBCO Software Inc., Palo Alto, California, USA
 */
using namespace ASApi;
InvokeResult::InvokeResult(SharedPtr<tibasInvokeResult>& invokeResult)
: m_invokeResult(invokeResult),
  m_invokeResultPtr(m_invokeResult.get())
InvokeResult::InvokeResult(tibasInvokeResult& invokeResult)
: m_invokeResultPtr(&invokeResult)
InvokeResult::~InvokeResult()
    
const tibasInvokeResult& InvokeResult::get() const
 return *m_invokeResult;
tibasInvokeResult& InvokeResult::get()
 return *m_invokeResult;
bool InvokeResult::hasError() const
    tibas_boolean isError = TIBAS_FALSE;
    isError = tibasInvokeResult_HasError(*m_invokeResultPtr);
    if(isError == TIBAS_FALSE)
    {
        return false;
    }
    else
    {
        return true;
    }
Status InvokeResult::getStatus() const
    Status status = TIBAS_OK;
    AS_CALL(tibasInvokeResult_GetStatus(*m_invokeResultPtr, &status));
    re
/* This file is part of the FaCT++ DL reasoner
Copyright (C) 2003-2009 by Dmitry Tsarkov
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
void TBox :: dump ( dumpInterface* dump ) const
	dump->prologue();
	dumpAllRoles(dump);
	for ( c_const_iterator pc = c_begin(); pc != c_end(); ++pc )
		if ( isRelevant(*pc) )
			dumpConcept( dump, *pc );
	f

		if ( isRelevant(*pi) )
			dumpConcept( dump, *pi );
	if ( getTG() != bpTOP )
	{
		dump->startAx (diImpliesC);
		dump->dumpTop();
		dump->contAx (diImpliesC);
		dumpExpression ( dump, getTG() );
		dump->finishAx (diImpliesC);
	}
	dump->epilogue();
void TBox :: dumpConcept ( dumpInterface* dump, const TConcept* p ) const
	dump->startAx (diDefineC);
	dump->dumpConcept(p);
	dump->finishAx (diDefineC);
	if ( p->pBody != bpTOP )
	{
		diAx Ax = p->isNonPrimitive() ? diEqualsC : diImpliesC;
		dump->startAx (Ax);
		dump->dumpConcept(p);
		dump->contAx (Ax);
		dumpExpression ( dump, p->pBody );
		dump->finishAx (Ax);
	}
void TBox :: dumpRole ( dumpInterface* dump, const TRole* p ) const
	if ( p->getId() > 0 || !isRelevant(p->inverse()) )
	{
		const TRole* q = ( p->getId()>0 ? p : p->inverse() );
		dump->startAx (diDefineR);
		dump->dumpRole(q);
		dump->finishAx (diDefineR);
		for ( ClassifiableEntry::const_iterator i = q->told_begin(); i != q->told_end(); ++i )
		{
			dump->startAx (diImplies

			dump->dumpRole(q);
			dump->contAx (diImpliesR);
			dump->dumpRole(static_cast<const TRole*>(*i));
			dump->finishAx (diImpliesR);
		}
	}
	if ( p->isTransitive() )
	{
		dump->startAx (diTransitiveR);
		dump->dumpRole(p);
		dump->finishAx (diTransitiveR);
	}
	if ( p->isTopFunc() )
	{
		dump->startAx (diFunctionalR);
		dump->dumpRole(p);
		dump->finishAx (diFunctionalR);
	}
	if ( p->getBPDomain() != bpTOP )
	{
		dump->startAx (diDomainR);
		dump->dumpRole(p);
		dump->contAx (diDomainR);
		dumpExpression ( dump, p->getBPDomain() );
		dump->finishAx (diDomainR);
	}
	if ( p->getBPRange() != bpTOP )
	{
		dump->startAx (diRangeR);
		dump->dumpRole(p);
		dump->contAx (diRangeR);
		dumpExpression ( dump, p->getBPRange() );
		dump->finishAx (diRangeR);
	}
void TBox :: dumpExpression ( dumpInterface* dump, BipolarPointer p ) const
	fpp_assert ( isValid(p) );
	if ( p == bpTOP )
		return dump->dumpTop();
	if ( p == bpBOTTOM )
		return dump->dumpBottom();
	if ( isNegative(p) )
	{
		dump->startOp

		dumpExpression ( dump, inverse(p) );
		return dump->finishOp (diNot);
	}
	const DLVertex& v = DLHeap [getValue(p)];
	switch ( v.Type() )
	{
	case dtTop:
		return dump->dumpTop();
	case dtName:
		return dump->dumpConcept(static_cast<const TConcept*>(v.getConcept()));
	case dtAnd:
		dump->startOp (diAnd);
		for ( DLVertex::const_iterator q = v.begin(); q != v.end(); ++q )
		{
			if ( q != v.begin() )
				dump->contOp (diAnd);
			dumpExpression ( dump, *q );
		}
		dump->finishOp (diAnd);
		return;
	case dtForall:
		dump->startOp (diForall);
		dump->dumpRole (v.getRole());
		dump->contOp(diForall);
		dumpExpression ( dump, v.getC() );
		dump->finishOp (diForall);
		return;
	case dtLE:
		dump->startOp ( diLE, v.getNumberLE() );
		dump->dumpRole (v.getRole());
		dump->contOp(diLE);
		dumpExpression ( dump, v.getC() );
		dump->finishOp (diLE);
		return;
	default:
		std::cerr << "Error dumping vertex of type " << v.getTagName() << "(" << v.Type () << ")";
		fpp_unreachable();
	}
void TBox :

	RoleMaster::const_iterator p;
	for ( p = ORM.begin(); p != ORM.end(); ++p )
		if ( isRelevant(*p) )
		{
			fpp_assert ( !(*p)->isSynonym() );
			dumpRole ( dump, *p );
		}
	for ( p = DRM.begin(); p != DRM.end(); ++p )
		if ( isRelevant(*p) )
		{
			fpp_assert ( !(*p)->isSynonym() );
			dumpRole ( dump, *p );
		}
void dumpCExpression ( dumpInterface* dump, const DLTree* C )
	if ( C == NULL )
		return;
	Token t = C->Element().getToken();
	diOp tag;
	switch (t)
	{
	case TOP:
		return dump->dumpTop();
	case BOTTOM:
		return dump->dumpBottom();
	case CNAME:
	case INAME:
		return dump->dumpConcept(static_cast<TConcept*>(C->Element().getNE()));
	case NOT:
		dump->startOp(diNot);
		dumpCExpression ( dump, C->Left() );
		return dump->finishOp(diNot);
	case AND:
	case OR:
	case ONEOF:
		tag = t == AND ? diAnd : t == OR ? diOr : diOneOf;
		dump->startOp(tag);
		dumpCExpression ( dump, C->Left() );
		dump->contOp(tag);
		dumpCExpression ( dump, C->Right() );
		return dump->finishOp(tag);
	case E
class Sample
public:
        int width_;
        int height_;
        FeatureChannel fc_;
        int label_;
        vector<float> aux_feature_vec_;
        static vector<Sample> train_sample_vec_;
public:
        Sample(){aux_feature_vec_.clear(); label_=0; width_=height_=0;}
        Sample(Size& s, int label=0);
        Sample(unsigned int patch_width, unsigned int patch_height, int label);
        Sample(Mat& img, int label=0);
        Sample(Size& size, FeatureChannel& fc, int label=0);
        bool isPositive();
        void getPatch(Rect& roi, Sample& sample_patch) const;
        Size getSize() const;
        const Size size() const;
        const Sample operator () (Rect& roi) const;
        static void load(string& sample_dir, string& type, int label, vector<Sample>& sample_vec,
                                                                            int max_sample_num=1000000);
        static void LoadFDDBSample(const string& dir, const string& sub_dir, int start_sub_index

                int end_sub_index, Size& sample_size, vector<Sample>& sample_vec);
        static void genSample(vector<Mat>& img_vec, int label, vector<Sample>& sample_vec);
        static void genRandomNegSample(const vector<Mat>& img_vec, vector<Sample>& sample_vec, 
                                                Size& sample_size, int label, unsigned max_sample_num);
        static void genRandomSample(const vector<Mat>& img_vec, vector<Sample>& sample_vec, 
                                                Size& sample_size, int label, unsigned max_sample_num);
        static void genRandomSample(string& img_path, vector<Sample>& sample_vec, Size& sample_size,
                                                int label, unsigned max_sample_num);
        static void genRandomNegSample(string& img_path, vector<Sample>& sample_vec, Size& sample_size,
                                                int label, unsigned max_sample_num);
        static void GenRandPatchSample(const string&
using namespace std;
SampleRecordReader::SampleRecordReader() {
SampleRecordReader::~SampleRecordReader() {
vector<Sample> SampleRecordReader::read(istream& is) {
	int32_t sampleRecordCount;
	readLE(is, &sampleRecordCount);
	vector<Sample> sampleRecords(sampleRecordCount);
	for (int32_t i = 0; i < sampleRecordCount; ++i) {
		read(is, sampleRecords[i]);
	}
	return sampleRecords;
istream& SampleRecordReader::read(istream& is, Sample& sampleRecord) const {
	readLE(is, &sampleRecord.ifovId);
	readLE(is, &sampleRecord.randomNumber);
	readLE(is, &sampleRecord.ifovInEfovIndex);
	readLE(is, &sampleRecord.lat);
	readLE(is, &sampleRecord.lon);
	readLE(is, &sampleRecord.month);
	readLE(is, &sampleRecord.cloudType);
	readLE(is, &sampleRecord.ifovValid);
	readLE(is, &sampleRecord.efovValid);
	readLE(is, &sampleRecord.elevatedPolarRegion);
	readLE(is, &sampleRecord.desertRegion);
	readLE(is, &sampleRecord.dustStorm);
	readLE(is, &sampleRecord.fractionalLandCover);
	for (size_t i = 0; i < sampleRecor
/*****************************************************************
 * $Id: sail_modelfactory.cpp 2166 2014-09-25 13:23:18Z rutger $
 * Created: Jul 26, 2012 14:24:25 AM - rutger
 *
 * Copyright (C) 2012 Red-Bag. All rights reserved.
 * This file is part of the Biluna SAIL project.
 *
 *****************************************************************/
SAIL_ModelFactory* SAIL_ModelFactory::mActiveFactory = NULL;
/**
 * Constructor
 */
SAIL_ModelFactory::SAIL_ModelFactory(RB_MainWindow* mw) : RB_ModelFactory(mw) {
    RB_DEBUG->print("SAIL_ModelFactory::SAIL_ModelFactory()");
    this->setObjectFactory(SAIL_OBJECTFACTORY);
    DB_MODELFACTORY->registerFactory(this);
/**
 * Destructor
 */
SAIL_ModelFactory::~SAIL_ModelFactory() {
    DB_MODELFACTORY->unregisterFactory(this);
    mActiveFactory = NULL;
    RB_DEBUG->print("SAIL_ModelFactory::~SAIL_ModelFactory() OK");
/**
 * Create instance of factory
 */
SAIL_ModelFactory* SAIL_ModelFactory::getInstance(RB_MainWindow* mw) {
    if (!mActiv

        mActiveFactory = new SAIL_ModelFactory(mw);
    }
    return mActiveFactory;
/**
 * @param type model type
 * @param shared true if model is to be created as unique/single/shared model
 * @return model manager
 */
RB_MmProxy* SAIL_ModelFactory::getModel(int type, bool shared) {
    RB_MmProxy* model = NULL;
    if (shared) {
        std::map<int, RB_MmProxy*>::iterator iter;
        iter = mModelList.find(type);
        if (iter != mModelList.end()) {
            model = (*iter).second;
        }
        if (model) return model;
    }
    QSqlDatabase db = getDatabase();
    switch (type) {
    case ModelCoordinate:
        model = getTableModel(db, mObjectFactory, type, "SAIL_CoordinateList", shared);
        model->setSourceSortOrder(RB2::SortOrderAscending, "mname");
        break;
    case ModelMap:
        model = getTableModel(db, mObjectFactory, type, "SAIL_MapList", shared);
        model->setSourceSortOrder(RB2::SortOrderAscending, "mname");
        break;
    case Mo

        model = getTableModel(db, mObjectFactory, type, "SAIL_ProjectList", shared);
        model->setSourceSortOrder(RB2::SortOrderDescending, "created");
        break;
    case ModelProjectEdit:
        model = getTableModel(db, mObjectFactory, type, "SAIL_ProjectList", shared);
        model->setSourceSortOrder(RB2::SortOrderDescending, "created");
        break;
    case ModelRoute:
        model = getTableModel(db, mObjectFactory, type, "SAIL_RouteList", shared);
        break;
    case ModelRouteCoordinate:
        model = getTableModel(db, mObjectFactory, type, "SAIL_RouteCoordinateList", shared);
        model->setSourceSortOrder(RB2::SortOrderAscending, "seqno");
        break;
    case ModelSymbol:
        model = getTableModel(db, mObjectFactory, type, "SAIL_SymbolList", shared);
        model->setSourceSortOrder(RB2::SortOrderAscending, "mname");
        break;
    case ModelTrack:
        model = getTableModel(db, mObjectFactory, type, "SAIL_TrackList", shared);
       

    default:
        RB_DEBUG->print(RB_Debug::D_ERROR,
                        "SAIL_ModelFactory::getModel()"
                        "non-existing model ERROR");
        break;
    }
    return model;
/**
 * Get parent model. Used in child models or models depending on selection of
 * a parent model.
 * @param type child model type
 * @return parent model or NULL if not exists
 */
RB_MmProxy* SAIL_ModelFactory::getParentModel(int type) {
    RB_MmProxy* model = NULL;
    std::map<int, RB_MmProxy*>::iterator iter;
    switch (type) {
    case ModelCoordinate:
        iter = mModelList.find(ModelNone);
        break;
    case ModelMap:
        iter = mModelList.find(ModelNone);
        break;
    case ModelProject:
        iter = mModelList.find(ModelNone);
        break;
    case ModelProjectEdit:
        iter = mModelList.find(ModelNone);
        break;
    case ModelRoute:
        iter = mModelList.find(ModelNone);
        break;
    case ModelRouteCoordinate:
        iter = mMode
ModelIdHolder::ModelIdHolder()
	this->m_modelIds[0] = ModelId("Char");
	this->m_modelIds[2] = ModelId("PoisonTurret", "color", "glowIntensity");
	this->m_modelIds[3] = ModelId("LightningTurret", "color", "glowIntensity");
	this->m_modelIds[4] = ModelId("DeathTurret", "color", "glowIntensity");
	this->m_modelIds[5] = ModelId("FrostGun", "color", "glowIntensity");
	this->m_modelIds[6] = ModelId("FrostBase");
	this->m_modelIds[7] = ModelId("CloudOfDarkness");
	this->m_modelIds[8] = ModelId("Pentagram");
	this->m_modelIds[9] = ModelId("redKnightPassiveAura");
	this->m_modelIds[10] = ModelId("wall");
	this->m_modelIds[11] = ModelId("Arrow");
	this->m_modelIds[12] = ModelId("Bench");
	this->m_modelIds[13] = ModelId("barrel");
	this->m_modelIds[14] = ModelId("box");
	this->m_modelIds[15] = ModelId("Church");
	this->m_modelIds[16] = ModelId("cross");
	this->m_modelIds[17] = ModelId("tree");
	this->m_modelIds[18] = ModelId("fence");
	this->m_modelIds[19] = ModelId("fencePillar");
	this->m_model

	this->m_modelIds[21] = ModelId("gravestone");
	this->m_modelIds[22] = ModelId("lampPost");
	this->m_modelIds[23] = ModelId("CloudOfDarkness");
	this->m_modelIds[24] = ModelId("demonblade");
	this->m_modelIds[25] = ModelId("colum");
	this->m_modelIds[26] = ModelId("columSign");
	this->m_modelIds[27] = ModelId("treeMedium");
	this->m_modelIds[28] = ModelId("treeSmall");
	this->m_modelIds[29] = ModelId("gateBigHigh");
	this->m_modelIds[30] = ModelId("gateBigLow");
	this->m_modelIds[31] = ModelId("gateSmallHigh");
	this->m_modelIds[32] = ModelId("gateSmallLow");
	this->m_modelIds[33] = ModelId("cityHall");
	this->m_modelIds[34] = ModelId("asylum");
	this->m_modelIds[35] = ModelId("FountainAngel");
	this->m_modelIds[74] = ModelId("House05");
	this->m_modelIds[75] = ModelId("House00");
	this->m_modelIds[76] = ModelId("House01");
	this->m_modelIds[77] = ModelId("House02");
	this->m_modelIds[78] = ModelId("House03");
	this->m_modelIds[79] = ModelId("House04");
	this->m_modelIds[88] = ModelId

	this->m_modelIds[89].weapons[WEAPON_TYPE::MELEE] = WeaponSet("demonblade", "demonblade");
	this->m_modelIds[89].weapons[WEAPON_TYPE::RANGED] = WeaponSet("HexaGun", "lantern");
	this->m_modelIds[89].weapons[WEAPON_TYPE::AOE] = WeaponSet("demonblade", "");
	this->m_modelIds[95].weapons[WEAPON_TYPE::MELEE] = WeaponSet("OfficerRapier", "lantern");
	this->m_modelIds[95].weapons[WEAPON_TYPE::RANGED] = WeaponSet("HexaGun", "lantern");
	this->m_modelIds[96].weapons[WEAPON_TYPE::MELEE] = WeaponSet("Sword", "lantern");
	this->m_modelIds[96].weapons[WEAPON_TYPE::AOE] = WeaponSet("Mace", "");
	this->m_modelIds[97].weapons[WEAPON_TYPE::MELEE] = WeaponSet("Wrench", "lantern");
	this->m_modelIds[97].weapons[WEAPON_TYPE::RANGED] = WeaponSet("Crossbow", "lantern");
	this->m_modelIds[98].weapons[WEAPON_TYPE::MELEE] = WeaponSet("MeatClever", "lantern");
	this->m_modelIds[98].weapons[WEAPON_TYPE::RANGED] = WeaponSet("DoctorRevolver", "lantern");
	this->m_modelIds[99].weapons[WEAPON_TYPE::MELEE] = Weapon

	this->m_modelIds[99].weapons[WEAPON_TYPE::RANGED] = WeaponSet("MentalistRevolver", "lantern");
std::string ModelIdHolder::getHat(unsigned int id)
	if(id < ModelIdHolder::MAX_IDS)
	{
		return this->m_modelIds[id].hat;
	}
	else
	{
		return "";
	}
std::string ModelIdHolder::getRightHand(unsigned int id, unsigned short weaponType)
	if(id < ModelIdHolder::MAX_IDS && weaponType < 4)
	{
		return this->m_modelIds[id].weapons[weaponType].rightHand;
	}
	else
	{
		return "";
	}
std::string ModelIdHolder::getLeftHand(unsigned int id, unsigned short weaponType)
	if(id < ModelIdHolder::MAX_IDS && weaponType < 4)
	{
		return this->m_modelIds[id].weapons[weaponType].leftHand;
	}
	else
	{
		return "";
	}
std::string ModelIdHolder::getModel(unsigned int id)
	if(id < ModelIdHolder::MAX_IDS)
	{
		return this->m_modelIds[id].model;
	}
	else
	{
		return "";
	}
std::string ModelIdHolder::getTexture(int _index)const
	if(_index < ModelIdHolder::MAX_IDS)
	{
		return this->m_modelIds[_index].textures;
	}
	else
struct VirtActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct VirtFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct VirtActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R,

struct VirtFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct VirtActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct VirtFuncInvoker2
	typedef R (*Func)(void*, T1, T2, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		r

	}
};
template <typename T1, typename T2, typename T3>
struct VirtActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct VirtFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct VirtActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke 

	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct VirtFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		(

	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct VirtActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename R, typename T1, typenam

struct VirtFuncInvoker6
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct VirtActionInvoker7
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typen

struct VirtFuncInvoker7
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct VirtFuncInvoker8
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, T8, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, p8, invokeData.method);
	}
};
template <typename R, typename T1, typenam
using namespace std;
class NewHandlerHolder 
    public:
        explicit NewHandlerHolder(std::new_handler nh): handler(nh)
        {
        }
        ~NewHandlerHolder()
        {
            std::set_new_handler(handler);
        }
    private:
        std::new_handler handler;
        NewHandlerHolder(const NewHandlerHolder&);
        NewHandlerHolder& operator=(const NewHandlerHolder&);
};
template<typename T>
std::new_handler NewHandlerSupport<T>::currentHandler = 0;
    template<typename T>
std::new_handler NewHandlerSupport<T>::set_new_handler(std::new_handler p) throw()
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
template<typename T>
void* NewHandlerSupport<T>::operator new(std::size_t size) throw(std::bad_alloc)
    NewHandlerHolder h(std::set_new_handler(currentHandler));
    return ::operator new(size);
void OutOfMem()
    cout << __func__ << endl;
int main()
    Widget::set_new_handler(OutOfMem);
    Widget* pw1 = new W
namespace stdair {
  
  const std::string PassengerChoiceModel::_labels[LAST_VALUE] =
    { "HardRestrictionModel", "PriceOrientedModel", "HybridModel"};
  const char PassengerChoiceModel::
  _modelLabels[LAST_VALUE] = { 'R', 'P', 'H'};
  
  PassengerChoiceModel::PassengerChoiceModel()
    : _model (LAST_VALUE) {
    assert (false);
  }
  PassengerChoiceModel::
  PassengerChoiceModel (const PassengerChoiceModel& iPassengerChoiceModel)
    : _model (iPassengerChoiceModel._model) {
  }
  PassengerChoiceModel::
  PassengerChoiceModel (const EN_PassengerChoiceModel& iPassengerChoiceModel)
    : _model (iPassengerChoiceModel) {
  }
  PassengerChoiceModel::PassengerChoiceModel (const char iModel) {
    switch (iModel) {
    case 'R': _model = HARD_RESTRICTION; break;
    case 'P': _model = PRICE_ORIENTED; break;
    case 'H': _model = HYBRID; break;
    default: _model = LAST_VALUE; break;
    }
    if (_model == LAST_VALUE) {
      const std::string& lLabels = describeLabels();
      std::o

      oMessage << "The passenger choice model '"
               << "' is not known. Known passenger choice models " << lLabels;
      throw stdair::CodeConversionException (oMessage.str());
    }
  }
  
  const std::string& PassengerChoiceModel::
  getLabel (const EN_PassengerChoiceModel& iModel) {
    return _labels[iModel];
  }
  
  char PassengerChoiceModel::getModelLabel (const EN_PassengerChoiceModel& iModel) {
    return _modelLabels[iModel];
  }
  std::string PassengerChoiceModel::
  getModelLabelAsString (const EN_PassengerChoiceModel& iModel) {
    std::ostringstream oStr;
    oStr << _modelLabels[iModel];
    return oStr.str();
  }
  std::string PassengerChoiceModel::describeLabels() {
    std::ostringstream ostr;
    for (unsigned short idx = 0; idx != LAST_VALUE; ++idx) {
      if (idx != 0) {
        ostr << ", ";
      }
      ostr << _labels[idx] << " (" << _modelLabels[idx] << ")";
    }
    return ostr.str();
  }
  PassengerChoiceModel::EN_PassengerChoiceModel Passeng
struct VirtActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct VirtFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct VirtActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R,

struct VirtFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct VirtActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct VirtFuncInvoker2
	typedef R (*Func)(void*, T1, T2, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		r

	}
};
template <typename T1, typename T2, typename T3>
struct VirtActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct VirtFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct VirtActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke 

	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct VirtFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		(

	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct VirtActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename R, typename T1, typenam

struct VirtFuncInvoker6
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct VirtFuncInvoker7
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetVirtualInvokeData (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@macgitver.org>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
Listener::Listener(Log::Channel channel)
    : repoManChannel(channel)
    RM::Events::addReceiver(this);
Listener::~Listener()
    RM::Events::delReceiver(this);
void Listener::repositoryOpened(RM::Repo* repo)
    Log::Event e = Log::Event::create(TMPL_REPO_ACTIVITY);
    Q_ASSERT(e.isValid());
    e.se

    e.setParam(QLatin1String("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::repositoryAboutToClose(RM::Repo* repo)
    Log::Event e = Log::Event::create(TMPL_REPO_ACTIVITY);
    Q_ASSERT(e.isValid());
    e.setParam(QLatin1String("Action"),     tr("closed"));
    e.setParam(QLatin1String("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::repositoryActivated(RM::Repo* repo)
    Log::Event e = Log::Event::create(TMPL_REPO_ACTIVITY);
    Q_ASSERT(e.isValid());
    e.setParam(QLatin1String("Action"),     tr("activated"));
    e.setParam(QLatin1String("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::repositoryDeactivated(RM::Repo* repo)
void Listener::objectCreated(RM::Repo* repo, RM::Base* object)
void Listener::objectAboutToBeDeleted(RM::Repo* repo, RM::Base* object)
void Listener::refTreeNodeCreated(RM::Repo* repo, RM::RefTreeNode* node)
void Listener::refTreeNodeAboutToBeDeleted(

void Listener::refCreated(RM::Repo* repo, RM::Ref* ref)
void Listener::refAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref)
void Listener::refMoved(RM::Repo* repo, RM::Ref* ref)
void Listener::refHeadDetached(RM::Repo* repo, RM::Ref* ref)
void Listener::tagCreated(RM::Repo* repo, RM::Tag* tag)
    Log::Event e = Log::Event::create(TMPL_FOUND_NEW_REF);
    Q_ASSERT(e.isValid());
    e.setParam(QLatin1String("Type"),       tr("tag"));
    e.setParam(QLatin1String("ObjName"),    tag->displayName());
    e.setParam(QLatin1String("SHA"),        tag->displaySha1());
    e.setParam(QLatin1String("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::tagAboutToBeDeleted(RM::Repo* repo, RM::Tag* tag)
void Listener::branchCreated(RM::Repo* repo, RM::Branch* branch)
void Listener::branchAboutToBeDeleted(RM::Repo* repo, RM::Branch* branch)
void Listener::branchMoved(RM::Repo* repo, RM::Branch* branch)
    Log::Event e = Log::Event::create(TMPL_BRANCH_MOVED);
    Q_ASSER

    e.setParam(QLatin1String("ObjName"),    branch->displayName());
    e.setParam(QLatin1String("SHA"),        branch->displaySha1());
    e.setParam(QLatin1String("RepoName"),   repo->displayAlias());
    repoManChannel.addEvent(e);
void Listener::branchUpstreamChanged(RM::Repo* repo, RM::Branch* branch)
void Listener::namespaceCreated(RM::Repo* repo, RM::Namespace* nameSpace)
void Listener::namespaceAboutToBeDeleted(RM::Repo* repo, RM::Namespace* nameSpace)
void Listener::refLogChanged(RM::Repo* repo, RM::RefLog* reflog)
void Listener::refLogNewEntry(RM::Repo* repo, RM::RefLog* reflog)
void Listener::stageCreated(RM::Repo* repo, RM::Ref* ref)
void Listener::stageAboutToBeDeleted(RM::Repo* repo, RM::Ref* ref)
void Listener::remoteCreated(RM::Repo* repo, RM::Remote* remote)
void Listener::remoteAboutToBeDeleted(RM::Repo* repo, RM::Remote* remote)
void Listener::remoteModified(RM::Repo* repo, RM::Remote* remote)
void Listener::submoduleCreated(RM::Repo* repo, RM::Submodule* submodule)
/*
 * SingleApplicationInvoker.cpp
 *
*  Created on: Jan 14, 2014
 *      Author: sgrigoryan
 */
SingleApplicationInvoker* SingleApplicationInvoker::m_theInstance = NULL;
SingleApplicationInvoker& SingleApplicationInvoker::instance(){
	if(!m_theInstance){
		m_theInstance =  new SingleApplicationInvoker();
	}
	return *m_theInstance;
void SingleApplicationInvoker::destoryInstance(){
	delete m_theInstance;
	m_theInstance = NULL;
SingleApplicationInvoker::SingleApplicationInvoker()
: m_invokeScheduler(NULL)
, m_invokeTargetReply(NULL)
	m_invokeScheduler = new QTimer(this);
	connect(m_invokeScheduler, SIGNAL(timeout()), this, SLOT(onScheduleTimeout()));
SingleApplicationInvoker::~SingleApplicationInvoker(){
	delete m_invokeScheduler;
void SingleApplicationInvoker::start(){
	if(m_invokeScheduler)
			m_invokeScheduler->start();
	invokeApp();
void SingleApplicationInvoker::invokeApp(){
	fprintf(stderr, "%s\n", "invokeApp(): ");
	if(m_targetUrl.isEmpty()){
		return;
	}
	bb::system::InvokeManage

	bb::system::InvokeRequest request;
	request.setTarget(m_targetUrl);
	request.setAction("bb.action.OPEN");
	fprintf(stderr, "%s\n", "Invoking Twitter app OPEN " );
	fprintf(stderr, "%s\n",m_targetUrl.toStdString().c_str());
	m_invokeTargetReply = invokeManager.invoke(request);
	connect(m_invokeTargetReply, SIGNAL(finished()), this,  SLOT(onInvokeResult()));
	bb::system::SystemToast* toast = new bb::system::SystemToast(this);
	toast->setBody("OPEN request sent");
	toast->exec();
void SingleApplicationInvoker::onInvokeResult()
    switch(m_invokeTargetReply->error()) {
    case bb::system::InvokeReplyError::NoTarget: {
    	fprintf(stderr, "%s\n", "onInvokeResult(): Error: no target");
            break;
        }
    case bb::system::InvokeReplyError::BadRequest: {
    	fprintf(stderr, "%s\n", "onInvokeResult(): Error: bad request" );
            break;
        }
    case bb::system::InvokeReplyError::Internal: {
    	fprintf(stderr, "%s\n", "onInvokeResult(): Error: internal" );
     
namespace RCF {
    template<typename StubT, typename IdT, typename T>
    void StubAccess::invoke(StubT &stub, const IdT &id, Connection &connection, T &t)
    {
        stub.invoke(id, connection, t);
    }
    template<typename StubT, typename ImplementationT>
    ServerStub<StubT, ImplementationT>::ServerStub(ImplementationT &x) : 
            px(),
            x(x)
    {}
    template<typename StubT, typename ImplementationT>
    ServerStub<StubT, ImplementationT>::ServerStub(std::auto_ptr<ImplementationT> px) : 
            px(px.release()),
            x(*this->px)
    {}
    template<typename StubT, typename ImplementationT>
        ServerStub<StubT, ImplementationT>::ServerStub(boost::shared_ptr<ImplementationT> px) : 
            px(px),
            x(*px)
    {}
    template<typename StubT, typename ImplementationT>
    void ServerStub<StubT, ImplementationT>::invoke(int id, RCF::Connection &connection)
    {
        RCF_TRACE("")(id);
        switch (id) {
            case 

            case  1: invoke( stub, Meta::Int< 1>(), connection, x ); break;
            case  2: invoke( stub, Meta::Int< 2>(), connection, x ); break;
            case  3: invoke( stub, Meta::Int< 3>(), connection, x ); break;
            case  4: invoke( stub, Meta::Int< 4>(), connection, x ); break;
            case  5: invoke( stub, Meta::Int< 5>(), connection, x ); break;
            case  6: invoke( stub, Meta::Int< 6>(), connection, x ); break;
            case  7: invoke( stub, Meta::Int< 7>(), connection, x ); break;
            case  8: invoke( stub, Meta::Int< 8>(), connection, x ); break;
            case  9: invoke( stub, Meta::Int< 9>(), connection, x ); break;
            case 10: invoke( stub, Meta::Int<10>(), connection, x ); break;
            case 11: invoke( stub, Meta::Int<11>(), connection, x ); break;
            case 12: invoke( stub, Meta::Int<12>(), connection, x ); break;
            case 13: invoke( stub, Meta::Int<13>(), connection, x ); break;
           

            case 15: invoke( stub, Meta::Int<15>(), connection, x ); break;
            case 16: invoke( stub, Meta::Int<16>(), connection, x ); break;
            case 17: invoke( stub, Meta::Int<17>(), connection, x ); break;
            case 18: invoke( stub, Meta::Int<18>(), connection, x ); break;
            case 19: invoke( stub, Meta::Int<19>(), connection, x ); break;
            case 20: invoke( stub, Meta::Int<20>(), connection, x ); break;
            case 21: invoke( stub, Meta::Int<21>(), connection, x ); break;
            case 22: invoke( stub, Meta::Int<22>(), connection, x ); break;
            case 23: invoke( stub, Meta::Int<23>(), connection, x ); break;
            case 24: invoke( stub, Meta::Int<24>(), connection, x ); break;
            case 25: invoke( stub, Meta::Int<25>(), connection, x ); break;
            default: RCF_ASSERT(0);
        }
    }
    template<typename StubT, typename ImplementationT>
    template<typename IdT>
    void ServerStub<StubT, Im
ModelOperator::Model ModelOperator::construct(Point3D distanceToTarget, Point3D targetVelocity, Point3D missleVelocity)
    std::pair<float, Vector3D> distance = dekartToPolar(distanceToTarget);
    std::pair<float, Vector3D> targetV = dekartToPolar(targetVelocity);
    std::pair<float, Vector3D> chaserV = dekartToPolar(missleVelocity);
    Model result = {
        distance.first, distance.second.Alpha(), distance.second.Beta(),
        targetV.first, targetV.second.Alpha(), targetV.second.Beta(),
        chaserV.first, chaserV.second.Alpha(), chaserV.second.Beta()
     };
    return result;
void ModelOperator::setTargetSpeed(Model &model, const Point3D& speed)
    model[TARGET_SPEED] = speed.Scalar();
    Vector3D v = speed.direction();
    model[TARGET_SPEED_ALPHA] = v.Alpha();
    model[TARGET_SPEED_BETA] = v.Beta();
void ModelOperator::setChaserSpeed(Model &model, const Point3D& speed)
    model[MISSLE_SPEED] = speed.Scalar();
    Vector3D v = speed.direction();
    model[MISSLE_SP

    model[MISSLE_SPEED_BETA] = v.Beta();
void ModelOperator::setDistance(Model& model, const Point3D& distance)
    model[DISTANCE] = distance.Scalar();
    Vector3D v = distance.direction();
    model[DISTANCE_ALPHA] = v.Alpha();
    model[DISTANCE_BETA] = v.Beta();
Point3D ModelOperator::targetSpeed(const Model& model)
    return Vector3D(model[TARGET_SPEED_ALPHA], model[TARGET_SPEED_BETA]) * model[TARGET_SPEED];
Point3D ModelOperator::chaserSpeed(const Model& model)
    return Vector3D(model[MISSLE_SPEED_ALPHA], model[MISSLE_SPEED_BETA]) * model[MISSLE_SPEED];
Point3D ModelOperator::distance(const Model &model)
    return Vector3D(model[DISTANCE_ALPHA], model[DISTANCE_BETA]) * model[DISTANCE];
Point3D ModelOperator::MissleVelocity(const Model& model) {
    Point3D res = polarToDekart(model[MISSLE_SPEED], Vector3D(model[MISSLE_SPEED_ALPHA], model[MISSLE_SPEED_BETA]));
     return res;
Point3D ModelOperator::TargetVelocity(const Model& model) {
    Point3D res = polarToDekart(model[T
using query_row = pqxx::result::const_iterator;
namespace DAO {
template <typename Model, typename Dependencies = NoDependencies, typename ModelDependencies = NoModelDependencies>
class ModelDAOTemplate : public AbstractDAO<Model, ModelDAOTemplate<Model, Dependencies, ModelDependencies>>{
private:
	Dependencies      dependencies;
	ModelDependencies modelDependencies;
	ModelDAOTemplate* parseResult(query_row);
public:
	ModelDAOTemplate(                            );
	ModelDAOTemplate(int                         );
	ModelDAOTemplate(const ModelDAOTemplate&     );
	ModelDAOTemplate(shared_ptr<ModelDAOTemplate>);
	ModelDAOTemplate(shared_ptr<Model>                                       , int = 0);
	ModelDAOTemplate(shared_ptr<Model>,               shared_ptr<Connection>&, int = 0);
	ModelDAOTemplate(shared_ptr<Model>, Dependencies                         , int = 0);
	ModelDAOTemplate(shared_ptr<Model>, Dependencies, shared_ptr<Connection>&, int = 0);
	const string& getAllQuery             

	const string& getByIdQuery            ();
	const string& getDeleteQuery          ();
	const string& getInsertQuery          ();
	const string& getUpdateQuery          ();
	const string& getSerialization        ();
	const string& getTableCreationQuery   ();
	const string& getFindByAttributesQuery();
 protected:
	void initializeFunctors();
	template <typename D>string synchronizeDependency(bool serialization);
	template <typename D, typename R>function<shared_ptr<R>()> depend_getter();
	static const string INSERT_QUERY            ;
	static const string UPDATE_QUERY            ;
	static const string DELETE_QUERY            ;
	static const string GET_ALL_QUERY           ;
	static const string SERIALIZATION           ;
	static const string GET_BY_ID_QUERY         ;
	static const string GET_BY_ATTRIBUTES_QUERY ;
	static const string GET_TABLE_CREATION_QUERY;
};
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependenci

    this->id = 0;
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependencies>::ModelDAOTemplate(int id){
	this->id         = id;
	this->connection = make_shared<Connection>(Connection());
    this->initializeFunctors();
	auto x = this->getById(id);
	this->model      = x->model;
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependencies>::ModelDAOTemplate(shared_ptr<ModelDAOTemplate> modelDAOTemplate){
	this->id           = modelDAOTemplate->id;
	this->model        = modelDAOTemplate->model;
	this->connection   = modelDAOTemplate->connection;
	this->dependencies = modelDAOTemplate->dependencies;
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependencies>::ModelDAOTemplate(const ModelDAOTemplate& modelDAOT

	this->id         = modelDAOTemplate.id;
	this->model      = make_shared<ModelDAOTemplate>(*modelDAOTemplate.model);
	this->connection = make_shared<Connection>(Connection());
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependencies>::ModelDAOTemplate(shared_ptr<Model> model, int id){
	this->id           = id ;
	this->model        = model;
	this->connection   = make_shared<Connection>(Connection());
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependencies>::ModelDAOTemplate(shared_ptr<Model> model, shared_ptr<Connection>& connection, int id){
	this->id           = id ;
	this->model        = model;
	this->connection   = connection;
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencie

	this->id           = id ;
	this->model        = model;
	this->connection   = make_shared<Connection>(Connection());
	this->dependencies = dependencies;
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies>
ModelDAOTemplate<Model, Dependencies, ModelDependencies>::ModelDAOTemplate(shared_ptr<Model> model, Dependencies dependencies, shared_ptr<Connection>& connection, int id){
	this->id           = id ;
	this->model        = model;
	this->connection   = connection;
	this->dependencies = dependencies;
    this->initializeFunctors();
template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getAllQuery             () { return this->GET_ALL_QUERY           ;}
template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getByIdQuery            () { return this

template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getDeleteQuery          () { return this->DELETE_QUERY            ;}
template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getInsertQuery          () { return this->INSERT_QUERY            ;}
template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getUpdateQuery          () { return this->UPDATE_QUERY            ;}
template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getSerialization        () { return this->SERIALIZATION           ;}
template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies

template <typename Model, typename Dependencies, typename ModelDependencies> const string& ModelDAOTemplate<Model, Dependencies, ModelDependencies>::getFindByAttributesQuery() { return this->GET_BY_ATTRIBUTES_QUERY ;}
template <typename Model, typename Dependencies, typename ModelDependencies>
template <typename D>
string ModelDAOTemplate<Model, Dependencies, ModelDependencies>::synchronizeDependency(bool serialization){
	if(boost::fusion::has_key<D>(this->dependencies)){
		auto depend = boost::fusion::at_key<D>(this->dependencies);
		using innerModelDAO = typename D::first;
		using innerModel    = typename innerModelDAO::modelType;
		if(depend == nullptr){
			depend = shared_ptr<innerModelDAO>(new innerModelDAO(depend_getter<D, innerModel>()()));
			if(depend->synchronizeToDB() == 0){
				throw "Synchronization failed : failed to synchronize with db";
		}}
		if(serialization)
			return *(depend->serialize());
		return to_string(depend->getId());
	}
	throw "Synchronization failed : re
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
PRLogModuleInfo *gLoadManagerLog = nullptr;
namespace mozilla {
/* static */ StaticRefPtr<LoadManagerSingleton> LoadManagerSingleton::sSingleton;
NS_IMPL_ISUPPORTS(LoadManagerSingleton, nsIObserver)
LoadManagerSingleton::LoadManagerSingleton(int aLoadMeasurementInterval,
                                           int aAveragingMeasurements,
                                           float aHighLoadThreshold,
                                           float aLowLoadThreshold)
  : mLock("LoadManager"),
    mCurrentState(webrtc::kLoadNormal),
    mOveruseActive(false),
    mLoadSum(0.0f),
    mLoadSumMeasurements(0),
    mLoadMeasurementInterval(aLoadMeasurementInterval),
    mAveragingMeasurements(aAveragingMeasurements),
    mHighLoadThreshold(aHighLoadThreshold),
   

  if (!gLoadManagerLog)
    gLoadManagerLog = PR_NewLogModule("LoadManager");
  LOG(("LoadManager - Initializing (%dms x %d, %f, %f)",
       mLoadMeasurementInterval, mAveragingMeasurements,
       mHighLoadThreshold, mLowLoadThreshold));
  MOZ_ASSERT(mHighLoadThreshold > mLowLoadThreshold);
  mLoadMonitor = new LoadMonitor(mLoadMeasurementInterval);
  mLoadMonitor->Init(mLoadMonitor);
  mLoadMonitor->SetLoadChangeCallback(this);
LoadManagerSingleton::~LoadManagerSingleton()
  LOG(("LoadManager: shutting down LoadMonitor"));
  MOZ_ASSERT(!mLoadMonitor, "why wasn't the LoadMonitor shut down in xpcom-shutdown?");
  if (mLoadMonitor) {
    mLoadMonitor->Shutdown();
  }
nsresult
LoadManagerSingleton::Observe(nsISupports* aSubject, const char* aTopic,
                     const char16_t* aData)
  NS_ASSERTION(NS_IsMainThread(), "Observer invoked off the main thread");
  nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
  if (!strcmp(aTopic, "xpcom-shutdown")) {
    obs->R

    {
      MutexAutoLock lock(mLock);
      mObservers.Clear();
    }
    if (mLoadMonitor) {
      mLoadMonitor->Shutdown();
      mLoadMonitor = nullptr;
    }
    LOG(("Releasing LoadManager singleton and thread"));
    sSingleton = nullptr;
  }
  return NS_OK;
void
LoadManagerSingleton::LoadChanged(float aSystemLoad, float aProcesLoad)
  MutexAutoLock lock(mLock);
  mLoadSum += aSystemLoad;
  mLoadSumMeasurements++;
  if (mLoadSumMeasurements >= mAveragingMeasurements) {
    double averagedLoad = mLoadSum / (float)mLoadSumMeasurements;
    webrtc::CPULoadState oldState = mCurrentState;
    if (mOveruseActive || averagedLoad > mHighLoadThreshold) {
      LOG(("LoadManager - LoadStressed"));
      mCurrentState = webrtc::kLoadStressed;
    } else if (averagedLoad < mLowLoadThreshold) {
      LOG(("LoadManager - LoadRelaxed"));
      mCurrentState = webrtc::kLoadRelaxed;
    } else {
      LOG(("LoadManager - LoadNormal"));
      mCurrentState = webrtc::kLoadNormal;
    }
    if (ol

      LoadHasChanged();
    mLoadSum = 0;
    mLoadSumMeasurements = 0;
  }
void
LoadManagerSingleton::OveruseDetected()
  LOG(("LoadManager - Overuse Detected"));
  MutexAutoLock lock(mLock);
  mOveruseActive = true;
  if (mCurrentState != webrtc::kLoadStressed) {
    mCurrentState = webrtc::kLoadStressed;
    LoadHasChanged();
  }
void
LoadManagerSingleton::NormalUsage()
  LOG(("LoadManager - Overuse finished"));
  MutexAutoLock lock(mLock);
  mOveruseActive = false;
void
LoadManagerSingleton::LoadHasChanged()
  mLock.AssertCurrentThreadOwns();
  LOG(("LoadManager - Signaling LoadHasChanged to %d listeners", mObservers.Length()));
  for (size_t i = 0; i < mObservers.Length(); i++) {
    mObservers.ElementAt(i)->onLoadStateChanged(mCurrentState);
  }
void
LoadManagerSingleton::AddObserver(webrtc::CPULoadStateObserver * aObserver)
  LOG(("LoadManager - Adding Observer"));
  MutexAutoLock lock(mLock);
  mObservers.AppendElement(aObserver);
  if (mObservers.Length() == 1) {
    if (!mLo
/**
 * \file dcs/perfeval/energy/any_model.hpp
 *
 * \brief Generic class for energy models implementing the EnergyModel concept.
 *
 * Copyright (C) 2009-2010  Distributed Computing System (DCS) Group, Computer
 * Science Department - University of Piemonte Orientale, Alessandria (Italy).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 *
 * \author Marco Guazzone (marco.guazzone@gmail.com)
 */
namespace dcs { namespace perfeval { namespace energy {
/**
 * \brief Cla

 *
 * \tparam RealT The type for real numbers.
 *
 * \author Marco Guazzone (marco.guazzone@gmail.com)
 */
template <typename RealT>
struct any_model
	public: typedef RealT real_type;
	public: any_model()
	{
	}
	/*
	 * \brief Wrap a concrete energy model.
	 * \tparam EnergyModelT The concrete energy model type.
	 */
	public: template <typename EnergyModelT>
		any_model(EnergyModelT const& model)
		: ptr_model_(new model_adaptor<EnergyModelT>(model))
	{
	}
	/*
	 * \brief Wrap a concrete energy model.
	 * \tparam EnergyModelT The concrete energy model type.
	 *
	 * This is used for example when you want to pass a reference value instead
	 * of a const reference value.
	 */
	public: template <typename EnergyModelT>
		any_model(::dcs::util::holder<EnergyModelT> const& wrap_model)
		: ptr_model_(new model_adaptor<EnergyModelT>(wrap_model.get()))
	{
	}
	public: template <typename EnergyModelT>
		void model(EnergyModelT const& model)
	{
		ptr_model_ = new model_adaptor<EnergyModelT>(model);


	/**
	 * \brief Compute the energy consumed for the given system utilization.
	 * \param u The system utilization.
	 * \return The energy consumed for the given system utilization.
	 */
	public: real_type consumed_energy(real_type u) const
	{
		return ptr_model_->consumed_energy(u);
	}
};
template <typename EnergyModelT, typename EnergyModelTraitsT=typename ::dcs::type_traits::remove_reference<EnergyModelT>::type>
struct make_any_model_type
	typedef any_model<typename EnergyModelTraitsT::real_type> type;
};
namespace detail {
template <typename EnergyModelT, typename EnergyModelTraitsT=typename ::dcs::type_traits::remove_reference<EnergyModelT>::type>
struct make_any_model_impl;
template <typename EnergyModelT, typename EnergyModelTraitsT>
struct make_any_model_impl
	typedef typename make_any_model_type<EnergyModelT,EnergyModelTraitsT>::type any_model_type;
	static any_model_type apply(EnergyModelT& model)
	{
		return any_model_type(model);
	}
};
template <typename EnergyModelT, typen
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using namespace android; 
static KeyedVector<int, SampleTable_mtk*> mtkSampleTableObjList; 
static Mutex mtkSampleTableObjListLock; 
namespace android { 
SampleTable::SampleTable(const sp<DataSource> & source)
{ 
    SampleTable_mtk* mtkInst = new SampleTable_mtk(source); 
    mtkSampleTableObjListLock.lock(); 
    mtkSampleTableObjList.add((int)this, mtkInst); 
    mtkSampleTableObjListLock.unlock(); 
} 
bool    SampleTable::i

{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (bool)inst->isValid(); 
} 
status_t    SampleTable::setChunkOffsetParams(uint32_t type,off64_t data_offset,size_t data_size)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->setChunkOffsetParams(type,data_offset,data_size); 
} 
status_t    SampleTable::setSampleToChunkParams(off64_t data_offset,size_t data_size)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->setSampleToChunkParams(data_offset,data_size); 
} 
status_t    SampleTable::setSampleSizeParams(uint32_t type,off64_t data_offset,size_t data_size)
{ 

    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->setSampleSizeParams(type,data_offset,data_size); 
} 
status_t    SampleTable::setTimeToSampleParams(off64_t data_offset,size_t data_size)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->setTimeToSampleParams(data_offset,data_size); 
} 
status_t    SampleTable::setCompositionTimeToSampleParams(off64_t data_offset,size_t data_size)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->setCompositionTimeToSampleParams(data_offset,data_size); 
} 
status_t    SampleTable::setSyncSampleParams(off64_t data

{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->setSyncSampleParams(data_offset,data_size); 
} 
uint32_t    SampleTable::countChunkOffsets()  const
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (uint32_t)inst->countChunkOffsets(); 
} 
uint32_t    SampleTable::countSamples()  const
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (uint32_t)inst->countSamples(); 
} 
status_t    SampleTable::getMaxSampleSize(size_t * size)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTable

    return (status_t)inst->getMaxSampleSize(size); 
} 
status_t    SampleTable::getMetaDataForSample(uint32_t sampleIndex,off64_t * offset,size_t * size,uint32_t * compositionTime,bool * isSyncSample)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->getMetaDataForSample(sampleIndex,offset,size,compositionTime,isSyncSample); 
} 
status_t    SampleTable::findSampleAtTime(uint32_t req_time,uint32_t * sample_index,uint32_t flags)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTableObjListLock.lock(); 
    inst = mtkSampleTableObjList.valueFor((int)this); 
    mtkSampleTableObjListLock.unlock(); 
    return (status_t)inst->findSampleAtTime(req_time,sample_index,flags); 
} 
status_t    SampleTable::findSyncSampleNear(uint32_t start_sample_index,uint32_t * sample_index,uint32_t flags)
{ 
    SampleTable_mtk *inst = NULL; 
    mtkSampleTabl
template <class T>
inline T determineZero() {
	return T();
template <>
inline float determineZero<float>() {
	return 0.0f;
template <>
inline double determineZero<double>() {
	return 0.0;
template <>
inline int determineZero<int>() {
	return 0;
template <class T>
class MovingAverage : public Savable {
	vector<T> samples;
	bool arrayFilled;
	int curSample;
	T lastAverage;
	unsigned int sampleId;
	int sampleSkip;
public:
	MovingAverage(int size, int sampleSkip = 0) : samples(size/((sampleSkip <= 0) ? 1 : sampleSkip)) {
		curSample = 0;
		sampleId = 0;
		this->sampleSkip = sampleSkip;
		arrayFilled = false;
		lastAverage = determineZero<T>();
	}
	void AddSample(T sample) {
		if (sampleSkip > 0) {
			sampleId++;
			if ((sampleId % sampleSkip) != 0)
				return;
		}
		samples[curSample] = sample;
		curSample = (curSample + 1) % (int)samples.size();
		if (curSample == 0)
			arrayFilled = true;
		if (arrayFilled) {
			T total = determineZero<T>();
			for (auto sample : samples)
				total += sa
GitRepository::GitRepository(git_repository* repo) :
  repo(repo)
GitRepository::GitRepository(GitRepository&& other)
  this->repo = other.repo;
  other.repo = NULL;
GitRepository& GitRepository::operator=(GitRepository&& other)
  this->repo = other.repo;
  other.repo = NULL;
  return *this;
GitRepository::~GitRepository()
  git_repository_free(repo);
const git_repository* GitRepository::get_repo() const
  return repo;
GitReference GitRepository::get_head_reference()
  git_reference* ref = NULL;
  int error = git_repository_head(&ref, repo);
  if (error != 0)
  {
  }
  GitReference reference(ref);
  return reference;
GitCommit GitRepository::commit_lookup(GitObjectID& oid)
  git_commit* commit_p = NULL;
  git_commit_lookup(&commit_p, this->repo, oid.oid);
  GitCommit commit(commit_p);
  return commit;
/* static */ GitRepository GitRepository::init_or_clone_repo(
    std::string url,
    std::string path)
  git_repository* repo;
  int error = git_repository_open(&repo, path.c_str());
  
/*
 * File automatically generated by
 * gengen 1.2 by Lorenzo Bettini 
 */
void
required_option_gen_class::generate_required_option(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (checkrange)
    {
      stream << "if (";
      generate_string (mode_condition, stream, indent + indent_str.length ());
      stream << "check_multiple_option_occurrences(";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_given, args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_min, args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_max, \"";
      generate_string (option_descr, stream, indent + indent_str.length ());
      stream << "\"))";
      stream << "\n";
      stream << in

      stream << "   error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "if (";
      generate_string (mode_condition, stream, indent + indent_str.length ());
      stream << "! args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_given)";
      stream << "\n";
      stream << indent_str;
      stream << "  {";
      stream << "\n";
      stream << indent_str;
      stream << "    fprintf (stderr, \"%s: ";
      generate_string (option_descr, stream, indent + indent_str.length ());
      stream << " option required%s\\n\", ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", (additional_error ? additional_error : \"\"));";
      stream << "\n";
      stream << indent_str;
      stream << "    error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "  }";
      
/* $Id: TestFileStream.cpp,v 1.1 2002/09/15 07:46:30 pgr Exp $ */
char const TestFileStream::fileName[] = "HelloFile";
/*----------------------------------------------=-------TestFileStream::title-+
|                                                                             |
+----------------------------------------------------------------------------*/
char const * TestFileStream::title() {
   return "TestFileStream";
/*---------------------------------------------TestFileStream::TestFileStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
TestFileStream::TestFileStream() {
   pStream = 0;
/*--------------------------------------------TestFileStream::~TestFileStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
TestFileStream::~TestFileStream() {
   dele

/*-----------------------------------------------TestFileStream::newOutStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
ostream * TestFileStream::newOutStream() {
   if (pStream) delete pStream;
   pStream = new PalmFileStream(
      fileName,
      fileModeReadWrite | fileModeAnyTypeCreator
   );
   return pStream;
/*------------------------------------------------TestFileStream::newInStream-+
|                                                                             |
+----------------------------------------------------------------------------*/
istream * TestFileStream::newInStream() {
   if (pStream) delete pStream;
   pStream = new PalmFileStream(
      fileName,
      fileModeReadOnly | fileModeAnyTypeCreator
   );
   return pStream;
/*---------------------------------------------TestFileStream::newInOutStream-+
|                                            
static char THIS_FILE[] = __FILE__;
CEditRepo::CEditRepo(wxWindow* pParent /*=NULL*/)
	: wxDialog(CEditRepo::IDD, pParent)
	m_strName = _T("");
	m_strAddr = _T("");
void CEditRepo::DoDataExchange(CDataExchange* pDX)
	wxDialog::DoDataExchange(pDX);
	if (!pDX->m_bSaveAndValidate)
	{
		ValueToData();
	}
	DDX_Text(pDX, IDC_NAME, m_strName);
	DDX_Text(pDX, IDC_ADDR, m_strAddr);
	if (pDX->m_bSaveAndValidate)
	{
		DataToValue();
	}
void CEditRepo::DataToValue()
	m_repo.m_strName = m_strName;
	m_repo.m_strAddr = m_strAddr;
	m_repo.Calc();
void CEditRepo::ValueToData()
	m_strName = m_repo.m_strName;
	m_strAddr = m_repo.m_strAddr;
BEGIN_EVENT_TABLE(CEditRepo, wxDialog)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
END_EVENT_TABLE()
void CEditRepo::OnDelete() 
	if (m_repo.m_i<0)
	{
		OnCancel();
	}
	else
	{
		if (theApp.ConfirmDelete("repository"))
		{
			if (m_repo.m_pDoc->HasChildren(m_repo))
			{
				AfxMessageBox(_T("You cannot delete this repository because it has other ")
					_T("records that depen
/*****************************************************************************
 * 
 * SAMPLE.CXX
 *
 * Sample Class
 *
 * R. Kwan
 * August 3, 1995
 *
 * (C) Copyright 1995 by R.Kwan
 *
 *****************************************************************************/
/*****************************************************************************
 * Sample Class
 *****************************************************************************/
/*****************************************************************************
 * Sample constructors
 *****************************************************************************/
Sample::Sample() : Event() {
   _save_sample = &Sample::_print_sample;
   _event_type = SAMPLE;
   _clientData = this;
Sample::Sample(Time_ms t) : Event(t) {
   _save_sample = &Sample::_print_sample;
   _event_type = SAMPLE;
   _clientData = this;
Sample::Sample(Time_ms t, void (*f)(Vector_3D&,void *), void *data) 
   : Event(t) {
   _save_sample = f;
   _clientData  = data;

   _event_type = SAMPLE;
Sample::Sample(const Sample& s) : Event((Event&)s) {
   _save_sample = s._save_sample;
   _clientData  = s._clientData;
   
/*****************************************************************************
 * Sample::apply
 * Sample the magnetization vector at the event time.
 *****************************************************************************/
Vector_3D& Sample::apply(Spin_Model& m){
   static Vector_3D sample;
   m.update(_event_time);
   sample = m.get_net_magnetization();
   _save_sample(sample, _clientData);
   return sample;
void Sample::get_descriptor_string(char s[]){
   sprintf((char *)s,"Sample %8.2lf",(double)_event_time);
Event *Sample::make_new_copy_of_event(void){
   return (Event *)new Sample(*this);
/*****************************************************************************
 * Sample::_print_sample
 * Default save sample method.  Displays the sample on stdout.
 **************************************************************************
/* 
 * File:   RepoClient.h
 * Author: johadunf
 *
 * Created on May 20, 2014, 6:52 PM
 */
typedef std::vector<std::string> StringVector;
typedef std::pair<RepositoryInfo, std::string> RepoFile;
typedef std::map<int, RepoFile> FileCache;
class RepoCommand {
public:
    std::string cmd;
    StringVector args;
};
class RepoClient {
public:
    RepoClient() {
        globalFileIndex = 0;
    }
    /**
     * Process client input for handling remote rev files
     * 
     * @param command   Command to process
     * @return          Returns true if command was relevant, otherwise false
     */
    bool processCommand(std::vector<RepositoryInfo> repositories, std::string cmd) {
        boost::trim(cmd);
        if(cmd.size() == 0){
            return false;
        }
        
        RepoCommand rc;
        boost::split(rc.args, cmd, boost::is_any_of(" "));
        rc.cmd = pop_front(rc.args);
        if (rc.cmd == "repo-list") {
            globalFileIndex = 0;
            BOOST_FOREACH(Re

                if (browser) {
                    HttpResponse httpResponse = browser->getIndex();
                    httpResponse.data = pushIndex(repo, httpResponse.data);
                    repoObserver->notifyGetIndexComplete(httpResponse, repo);
                }
            }
            return true;
        } else if (rc.cmd == "repo-get") {
            if (fileCache.size() <= 0) {
                repoObserver->notifyError("Cache not set, initializing now... Try download again when complete!");
                processCommand(repositories, "repo-list");
                return true;
            }
            std::string error = "Valid syntax to download a file is:\n 1) repo-get <file index>\n 2) repo-get <repository>.<filename>";
            if (rc.args.size() != 1) {
                repoObserver->notifyError(error);
                return true;
            }
            int index;
            try {
                index = boost::lexical_cast<int>(rc.args.at(0));
            }

                repoObserver->notifyError(error);
                return true;
            }
            if (!fileCache.count(index)) {
                repoObserver->notifyError("The provided file index does not exist.");
                return true;
            }
            RepositoryInfo repo = fileCache[index].first;
            if (browser) {
                repoObserver->notifyGetFileComplete(browser->getFile(fileCache[index].second), repo);
                return true;
            }
            repoObserver->notifyError("Error, something went wrong requesting file at '" + repo.GetName() + "'.");
            return true;
        }
        return false;
    }
    static StringVector getHelp() {
        StringVector v;
        return v;
    }
    void setObserver(IRepoObserver *repoObserver) {
        this->repoObserver = repoObserver;
    }
private:
    IRepoObserver *repoObserver;
    int globalFileIndex;
    FileCache fileCache;
    StringVector pushIndex(RepositoryInfo repo, S
StarField::StarField()
  :chunkGrid(NULL),
  position(0,0,0)
void StarField::init(Eigen::Vector3f pos)
  int i,j,k;
  position[0] = floor(pos[0]/CHUNK_SIZE)-CHUNK_NUMBER/2;
  position[1] = floor(pos[1]/CHUNK_SIZE)-CHUNK_NUMBER/2;
  position[2] = floor(pos[2]/CHUNK_SIZE)-CHUNK_NUMBER/2;
  chunkGrid = new Chunk***[CHUNK_NUMBER+3];
  for(i=0; i<CHUNK_NUMBER; i++)
  {
    chunkGrid[i] = new Chunk**[CHUNK_NUMBER];
    for(j=0; j<CHUNK_NUMBER; j++)
    {
      chunkGrid[i][j] = new Chunk*[CHUNK_NUMBER];
      for(k=0; k<CHUNK_NUMBER; k++)
      {
        chunkGrid[i][j][k] = new Chunk(position[0]+i, position[1]+j, position[2]+k);
      }
    }
  }
void StarField::updateDelete(int x, int y, int z)
  int i,j,k;
  if(x < 0)
  {
    for(i=CHUNK_NUMBER+x; i<CHUNK_NUMBER; i++)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          if(chunkGrid[i][j][k] != NULL)
          {
            delete chunkGrid[i][j][k];
            chunkGrid[i][j][k] = N

          }
        }
      }
    }
  }
  else if(x > 0)
  {
    for(i=0; i<x; i++)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          if(chunkGrid[i][j][k] != NULL)
          {
            delete chunkGrid[i][j][k];
            chunkGrid[i][j][k] = NULL;
          }
        }
      }
    }
  }
  if(y < 0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=CHUNK_NUMBER-y; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          if(chunkGrid[i][j][k] != NULL)
          {
            delete chunkGrid[i][j][k];
            chunkGrid[i][j][k] = NULL;
          }
        }
      }
    }
  }
  else if(y > 0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=0; j<y; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          if(chunkGrid[i][j][k] != NULL)
          {
            delete chunkGrid[i][j][k];
            chunkGrid[i][j][k] = NULL;
          }
        }
      }
    }
  }
 

  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=CHUNK_NUMBER+z; k<CHUNK_NUMBER; k++)
        {
          if(chunkGrid[i][j][k] != NULL)
          {
            delete chunkGrid[i][j][k];
            chunkGrid[i][j][k] = NULL;
          }
        }
      }
    }
  }
  else if(z > 0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<z; k++)
        {
          if(chunkGrid[i][j][k] != NULL)
          {
            delete chunkGrid[i][j][k];
            chunkGrid[i][j][k] = NULL;
          }
        }
      }
    }
  }
void StarField::updateMove(int x, int y, int z)
  int i,j,k;
  if(x < 0)
  {
    for(i=CHUNK_NUMBER-1+x; i > 0; i--)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          chunkGrid[i-x][j][k] = chunkGrid[i][j][k];
          chunkGrid[i][j][k] = NULL;
        }
      }
    }
  }
  else if(x>0)
  {
    for(i=x; i

    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          chunkGrid[i-x][j][k] = chunkGrid[i][j][k];
          chunkGrid[i][j][k] = NULL;
        }
      }
    }
  }
  if(y < 0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=CHUNK_NUMBER-1+y; j > 0; j--)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          chunkGrid[i][j-y][k] = chunkGrid[i][j][k];
          chunkGrid[i][j][k] = NULL;
        }
      }
    }
  }
  else if(y>0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=y; j<CHUNK_NUMBER; j++)
      {
        for(k=0; k<CHUNK_NUMBER; k++)
        {
          chunkGrid[i][j-y][k] = chunkGrid[i][j][k];
          chunkGrid[i][j][k] = NULL;
        }
      }
    }
  }
  if(z < 0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=CHUNK_NUMBER-1+z; k > 0; k--)
        {
          chunkGrid[i][j][k-z] = chunkGrid[i][j][k];
          chunkGrid[i][j][k] = NULL

        }
      }
    }
  }
  else if(z>0)
  {
    for(i=0; i<CHUNK_NUMBER; i++)
    {
      for(j=0; j<CHUNK_NUMBER; j++)
      {
        for(k=z; k<CHUNK_NUMBER; k++)
        {
          chunkGrid[i][j][k-z] = chunkGrid[i][j][k];
          chunkGrid[i][j][k] = NULL;
        }
      }
    }
  }
void StarField::updateNew()
  int i,j,k;
  for(i=0; i<CHUNK_NUMBER; i++)
  {
    for(j=0; j<CHUNK_NUMBER; j++)
    {
      for(k=0; k<CHUNK_NUMBER; k++)
      {
        if(chunkGrid[i][j][k] == NULL)
        {
          chunkGrid[i][j][k] = new Chunk(position[0]+i, position[1]+j, position[2]+k);
        }
      }
    }
  }
void StarField::update(Eigen::Vector3f pos)
  int x,y,z;
  x = floor(pos[0]/CHUNK_SIZE)-CHUNK_NUMBER/2 - position[0];
  y = floor(pos[1]/CHUNK_SIZE)-CHUNK_NUMBER/2 - position[1];
  z = floor(pos[2]/CHUNK_SIZE)-CHUNK_NUMBER/2 - position[2];
  position[0] += x;
  position[1] += y;
  position[2] += z;
  updateDelete(x,y,z);
  updateMove(x,y,z);
  updateNew();
  void StarField::
/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2009 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/
namespace osgVolume {
class OSGVOLUME_EXPORT Locator : public osg::Object
    public:
        
        Locator() {}
        Locator(const osg::Matrixd& transform) { setTransform(transform); }
        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Locator(const Locator& locator,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY):
            osg::Object(locator, copyop),
            _transform(locator._trans

        
        META_Object(osgVolume, Locator);
        /** Set the transformation from local coordinates to model coordinates.*/
        void setTransform(const osg::Matrixd& transform) { _transform = transform; _inverse.invert(_transform); locatorModified(); }
        /** Set the transformation from local coordinates to model coordinates.*/
        const osg::Matrixd& getTransform() const { return _transform; }
        /** Set the extents of the local coords.*/
        void setTransformAsExtents(double minX, double minY, double maxX, double maxY, double minZ, double maxZ);
        virtual bool convertLocalToModel(const osg::Vec3d& /*local*/, osg::Vec3d& /*world*/) const;
        virtual bool convertModelToLocal(const osg::Vec3d& /*world*/, osg::Vec3d& /*local*/) const;
        static bool convertLocalCoordBetween(const Locator& source, const osg::Vec3d& sourceNDC, 
                                             const Locator& destination, osg::Vec3d& destinationNDC)
        {
      

            if (!source.convertLocalToModel(sourceNDC, model)) return false;
            if (!destination.convertModelToLocal(model, destinationNDC)) return false;
            return true;
        }
        
        bool computeLocalBounds(osg::Vec3d& bottomLeft, osg::Vec3d& topRight) const;
        bool computeLocalBounds(Locator& source, osg::Vec3d& bottomLeft, osg::Vec3d& topRight) const;
        /** Callback interface for enabling the monitoring of changes to the Locator.*/
        class LocatorCallback : virtual public osg::Object
        {
            public:
                LocatorCallback() {}
                LocatorCallback(const LocatorCallback& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY): osg::Object(rhs,copyop) {}
                META_Object(osgVolume, LocatorCallback);
                virtual void locatorModified(Locator* locator) {};
            protected:
                virtual ~LocatorCallback() {}
        };
        void addCallback(LocatorCallback* cal
class RepoDownloadInfo;
class ApiError;
class DownloadRepoDialog : public QDialog,
                           public Ui::DownloadRepoDialog
    Q_OBJECT
public:
    DownloadRepoDialog(const Account& account,
                       const ServerRepo& repo,
                       QWidget *parent=0);
    void setMergeWithExisting(const QString& localPath);
private slots:
    void onOkBtnClicked();
    void chooseDirAction();
    void onDownloadRepoRequestSuccess(const RepoDownloadInfo& info);
    void onDownloadRepoRequestFailed(const ApiError& error);
    void switchMode();
private:
    Q_DISABLE_COPY(DownloadRepoDialog);
    enum SyncMode {
        CREATE_NEW_FOLDER,
        MERGE_WITH_EXISTING_FOLDER
    };
    
    
    bool validateInputs();
    void setAllInputsEnabled(bool enabled);
    void setDirectoryText(const QString& path);
    void updateSyncMode();
    ServerRepo repo_;
    bool sync_with_existing_;
    Account account_;
    SyncMode mode_;
    QString saved_create_new_path_
/*=========================================================================
  Program:   Insight Segmentation & Registration Toolkit
  Module:    $RCSfile: itkFEMLoadImplementationsRegister.cxx,v $
  Language:  C++
  Date:      $Date: 2009-01-30 21:10:18 $
  Version:   $Revision: 1.30 $
  Copyright (c) Insight Software Consortium. All rights reserved.
     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
=========================================================================*/
namespace itk {
namespace fem {
/* This macro makes registering Load implementations easier. */
  { ElementClass::LoadImplementationFunctionPointer fp=&FunctionName; \
    /* NOTE: Borland compiler (bcc 5.5.1) crashes if the pointer to templated function is not stored in a variable, before it is used in a function call below. */ \
    VisitorDispatcher<El

    ::RegisterVisitor((LoadClass*)0, fp); }
/* Use this macro to also automatically declare load implementation function. */
  extern void FunctionName(ElementClass::ConstPointer, ElementClass::LoadPointer, ElementClass::VectorType& ); \
  REGISTER_LOAD_EX(ElementClass,LoadClass,FunctionName)
/**
 * Registers all Load classes in the FEM library with VisitorDispatcher.
 * This function must be called before the FEM library is functional!.
 */
void LoadImplementationsRegister(void)
  REGISTER_LOAD_EX(Element2DC0LinearLineStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC1Beam,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStress,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStrain,LoadGravConst

  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStress,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStrain,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularMembra
/* ========================================================================= */
/* ------------------------------------------------------------------------- */
/*!
  \file			sample.cc
  \date			Apr 2013
  \author		TNick
  \brief		Contains the implementation of Sample class
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Please read COPYING and README files in root folder
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/
/* ------------------------------------------------------------------------- */
/* ========================================================================= */
/*  INCLUDES    ------------------------------------------------------------ */
/*  INCLUDES    ============================================================ */
/*  DEFINITIONS    --------------------------------------------------------- */
using namespace april;
/*  DEFINITIONS    ========================================================= */
/*  DATA    -----------

/*  DATA    ================================================================ */
/*  CLASS    --------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */
Sample::Sample	( void )
	: AprilPluginInterf()
	APRDBG_CDTOR;
	qDebug() << "Sample plug-in was constructed\n";
/* ========================================================================= */
/* ------------------------------------------------------------------------- */
Sample::~Sample	( void )
	APRDBG_CDTOR;
	qDebug() << "Sample plug-in was destructed\n";
/* ========================================================================= */
/* ------------------------------------------------------------------------- */
bool			Sample::initialised	( void )
	qDebug() << "Sample plug-in was initialised\n";
	return true;
/* ========================================================================= */
/* ----------------------------------------------------------
/*  YTP King - Easy to use sentence mixer
 *  Copyright (C) 2013  Alex "rainChu" Haddad et al.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
*/
	namespace ytpking
	{
	namespace smp
	{
class Sample;
class SampleManager;
/** Base class for classes which are affected when a Sample is added or removed. */
class SampleUser
friend class SampleManager;
public:
	explicit SampleUser( SampleManager &manager );
	virtual ~SampleUser( void );
private:
	explicit Sample

	void operator=( const SampleUser & );
protected:
	/** A new Sample has been added to SampleManager object.
	\param sampleName  The name of the added Sample.
	\param speakerName The name of the speaker
	\param addedSample The newly added Sample. */
	virtual void
		onAddSample( char const *sampleName, char const *speakerName, Sample *addedSample );
	/** Called when a Sample is selected.
	\param selectedSample The newly selected Sample */
	virtual void
		onSelectSample( Sample *selectedSample );
	/** Called when a Sample is about to be deleted.
	If a pointer matching deletedSample is held, it should be set to NULL or otherwise
	set to no longer match the sample, as that data is soon to be destroyed.
	\param deletedSample The sample which will soon be destroyed by SampleManager */
	virtual void
		onDeleteSample( Sample *deletedSample );
	/** Called when a Sample has been renamed.
	\param newSampleName The new name of the sample
	\param sample        A pointer to the sample being renamed.
namespace VideoCapture {
template<typename Sample> class RecyclingSampleQueuePair {
 public:
  typedef Sample SampleType;
  typedef SampleQueue<SampleType> SampleQueueType;
  typedef boost::shared_ptr<SampleQueueType> SampleQueueSharedPtr;
  RecyclingSampleQueuePair() {
  }
  RecyclingSampleQueuePair(
      const SampleQueueSharedPtr& pSampleQueue,
      const SampleQueueSharedPtr& pRecycledSampeQueue)
      : m_pSampleQueue(pSampleQueue),
        m_pRecycledSampleQueue(pRecycledSampeQueue) {
  }
  SampleQueueSharedPtr sampleQueue() {
    return m_pSampleQueue;
  }
  SampleQueueSharedPtr recycledSampleQueue() {
    return m_pRecycledSampleQueue;
  }
 private:
  SampleQueueSharedPtr m_pSampleQueue;
  SampleQueueSharedPtr m_pRecycledSampleQueue;
};
template<typename Sample, typename SampleQueue> RecyclingSampleQueuePair<
  Sample> recyclingSampleQueuePair(
    std::size_t maxCountSamples) {
  typedef Sample SampleType;
  typedef RecyclingSampleQueuePair<Sample> RecyclingSampleQueuePairTy
using namespace std;
const int MAX_C = 36, MAX_D = 28, MAX_N = 100;
int T, C, D, N;
map<string, string> repl;
string clear[MAX_D];
string invoke;
void solve() {
  for (map<string, string>::iterator i = repl.begin(); i != repl.end(); i++) {
    string::size_type i1, i2;
    while (1) {
      i1 = invoke.find((*i).first);
      string tmp = (*i).first;
      reverse(tmp.begin(), tmp.end());
      i2 = invoke.find(tmp);
      if (i1 != string::npos && i2 != string::npos) {
        invoke = invoke.replace(min(i1,i2), 2, (*i).second);
      } else if (i1 != string::npos) {
        invoke = invoke.replace(i1, 2, (*i).second);
      } else if (i2 != string::npos) {
        invoke = invoke.replace(i2, 2, (*i).second);
      } else {
        break;
      }
    }
  }
  for (int i = 0; i < D; i++) {
    string::size_type index;
    while ((index = invoke.find(clear[i])) != string::npos) {
      invoke = invoke.replace(index, 2, "");
    }
  }
int main(int argc, char *argv[]) {
  scanf("%d", &T);

void bar() {
  const char * (^block1)() = ^() {
    return __FUNCTION__;
  };
  const char * (^block2)() = ^() {
    return __FUNCTION__;
  };
void baz() {
  const char * (^block1)() = ^() {
    return __PRETTY_FUNCTION__;
  };
  const char * (^block2)() = ^() {
    return __PRETTY_FUNCTION__;
  };
namespace foonamespace {
class Foo {
public:
  Foo() {
    const char * (^block1)() = ^() {
      return __PRETTY_FUNCTION__;
    };
    const char * (^block2)() = ^() {
      return __PRETTY_FUNCTION__;
    };
    const char * (^block3)() = ^() {
      return __func__;
    };
    bar();
    inside_lambda();
  }
  ~Foo() {
    const char * (^block1)() = ^() {
      return __func__;
    };
    const char * (^block2)() = ^() {
      return __PRETTY_FUNCTION__;
    };
  }
  void bar() {
    const char * (^block1)() = ^() {
      return __PRETTY_FUNCTION__;
    };
    const char * (^block2)() = ^() {
      return __PRETTY_FUNCTION__;
    };
    const char * (^block3)() = ^() {
      return __fun
void MapUpdater::run()
	if(-xTrn > MAP_SIZE * cellSize * 0.5f)
	{
		xTrn += MAP_SIZE * cellSize;
		chunk[0] = chunk[1];
		chunk[3] = chunk[4];
		chunk[6] = chunk[7];
		chunk[1] = chunk[2];
		chunk[4] = chunk[5];
		chunk[7] = chunk[8];
		
		chunk[2].clear();
		chunk[2].setSide(Chunk::Left, chunk[1].heightMap);
		chunk[2].generate();
		
		chunk[5].clear();
		chunk[5].setSide(Chunk::Left, chunk[4].heightMap);
		chunk[5].setSide(Chunk::Bottom, chunk[2].heightMap);
		chunk[5].generate();
		
		chunk[8].clear();
		chunk[8].setSide(Chunk::Left, chunk[7].heightMap);
		chunk[8].setSide(Chunk::Bottom, chunk[5].heightMap);
		chunk[8].generate();
		
		glDeleteLists(chunkList[0], 9);
		
		updateDisplayLists();
	}
	if(-xTrn < -MAP_SIZE * cellSize * 0.5f)
	{
		xTrn -= MAP_SIZE * cellSize;
		chunk[2] = chunk[1];
		chunk[5] = chunk[4];
		chunk[8] = chunk[7];
		chunk[1] = chunk[0];
		chunk[4] = chunk[3];
		chunk[7] = chunk[6];
		
		chunk[0].clear();
		chunk[0].setSide(Chunk::Right, chunk[1].heightMap);
	

		
		chunk[3].clear();
		chunk[3].setSide(Chunk::Right, chunk[4].heightMap);
		chunk[3].setSide(Chunk::Bottom, chunk[0].heightMap);
		chunk[3].generate();
		
		chunk[6].clear();
		chunk[6].setSide(Chunk::Right, chunk[7].heightMap);
		chunk[6].setSide(Chunk::Bottom, chunk[3].heightMap);
		chunk[6].generate();
		
		glDeleteLists(chunkList[0], 9);
		
		updateDisplayLists();
	}
	if(-zTrn > MAP_SIZE * cellSize * 0.5f)
	{
		zTrn += MAP_SIZE * cellSize;
		chunk[0] = chunk[3];
		chunk[1] = chunk[4];
		chunk[2] = chunk[5];
		chunk[3] = chunk[6];
		chunk[4] = chunk[7];
		chunk[5] = chunk[8];
		
		chunk[6].clear();
		chunk[6].setSide(Chunk::Bottom, chunk[3].heightMap);
		chunk[6].generate();
		
		chunk[7].clear();
		chunk[7].setSide(Chunk::Left, chunk[6].heightMap);
		chunk[7].setSide(Chunk::Bottom, chunk[4].heightMap);
		chunk[7].generate();
		
		chunk[8].clear();
		chunk[8].setSide(Chunk::Left, chunk[7].heightMap);
		chunk[8].setSide(Chunk::Bottom, chunk[5].heightMap);
		chunk[8].generate();
	

		glDeleteLists(chunkList[0], 9);
		
		updateDisplayLists();
	}
	if(-zTrn < -MAP_SIZE * cellSize * 0.5f)
	{
		zTrn -= MAP_SIZE * cellSize;
		chunk[6] = chunk[3];
		chunk[7] = chunk[4];
		chunk[8] = chunk[5];
		chunk[3] = chunk[0];
		chunk[4] = chunk[1];
		chunk[5] = chunk[2];
		
		chunk[0].clear();
		chunk[0].setSide(Chunk::Top, chunk[3].heightMap);
		chunk[0].generate();
		
		chunk[1].clear();
		chunk[1].setSide(Chunk::Top, chunk[4].heightMap);
		chunk[1].setSide(Chunk::Left, chunk[0].heightMap);
		chunk[1].generate();
		
		chunk[2].clear();
		chunk[2].setSide(Chunk::Top, chunk[5].heightMap);
		chunk[2].setSide(Chunk::Left, chunk[1].heightMap);
		chunk[2].generate();
		
		glDeleteLists(chunkList[0], 9);
		
		updateDisplayLists();
	}
void MapUpdater::updateDisplayLists()
	GLfloat deltaTextureSize;
	GLfloat textureX;
	GLfloat textureY;
	GLfloat mapX;
	GLfloat mapZ;
	chunkList[0] = glGenLists(9);
	for(int i = 0; i < 9; ++i)
	{
		chunkList[i] = (i > 0) ? chunkList[i - 1] + 1 : chunkList[
namespace stlplus
  void dump_char(dump_context&, const char& data) throw(persistent_dump_failed);
  void restore_char(restore_context&, char& data) throw(persistent_restore_failed);
  void dump_signed_char(dump_context&, const signed char& data) throw(persistent_dump_failed);
  void restore_signed_char(restore_context&, signed char& data) throw(persistent_restore_failed);
  void dump_unsigned_char(dump_context&, const unsigned char& data) throw(persistent_dump_failed);
  void restore_unsigned_char(restore_context&, unsigned char& data) throw(persistent_restore_failed);
  void dump_short(dump_context&, const short& data) throw(persistent_dump_failed);
  void restore_short(restore_context&, short& data) throw(persistent_restore_failed);
  void dump_unsigned_short(dump_context&, const unsigned short& data) throw(persistent_dump_failed);
  void restore_unsigned_short(restore_context&, unsigned short& data) throw(persistent_restore_failed);
  void dump_int(dump_context&, const int& data) t
/**
 * @author Robert Waury
 * @date September 22, 2011
 * @file unittests/xmltest.hpp
 */
namespace test {
/**
 * This class tests the XML loading and saving facilities for:
 *		the config file		(load)
 *		levels				(load)
 *		the material file	(load)
 */
class xmlTest : public CPPUNIT_NS::TestFixture {
	CPPUNIT_TEST_SUITE(xmlTest);
	/* config file */
	CPPUNIT_TEST(noConfigFileTest);
	CPPUNIT_TEST(loadConfigTest);
	CPPUNIT_TEST(loadConfigKeyMissingTest);
	CPPUNIT_TEST(loadConfigValueMissingTest);
    CPPUNIT_TEST(loadConfigNoRootTest);
	CPPUNIT_TEST(loadConfigEmptyRootTest);
	CPPUNIT_TEST(loadConfigUnknownTagTest);
	CPPUNIT_TEST(loadConfigBrokenTest);
	/* config file end */
	/* level files */
	CPPUNIT_TEST(noLevelFileTest);
	CPPUNIT_TEST(loadLevelTest);
	CPPUNIT_TEST(loadLevelEmptyRootTest);
	CPPUNIT_TEST(loadLevelEnvOnlyTest);
	CPPUNIT_TEST(loadLevelNoEnvTest);
	CPPUNIT_TEST(loadLevelNoRootTest);
	CPPUNIT_TEST(loadLevelRootUpBrokenTest);
	CPPUNIT_TEST(loadLevelRootPositionBrokenTest)

	CPPUNIT_TEST(loadLevelRootEyeBrokenTest);
	CPPUNIT_TEST(loadLevelCompoundMatrixBrokenTest);
	CPPUNIT_TEST(loadLevelJointTypeBrokenTest);
	CPPUNIT_TEST(loadLevelJointPivotBrokenTest);
	CPPUNIT_TEST(loadLevelJointPinDirBrokenTest);
	CPPUNIT_TEST(loadLevelObjectTypeBrokenTest);
	CPPUNIT_TEST(loadLevelObjectMaterialBrokenTest);
	CPPUNIT_TEST(loadLevelObjectMatrixBrokenTest);
	CPPUNIT_TEST(loadLevelObjectDampingBrokenTest);
	CPPUNIT_TEST(loadLevelEnvNoSuchModelTest);
	/* level files end*/
	/* materials file */
	CPPUNIT_TEST(noMaterialsFileTest);
	CPPUNIT_TEST(loadMaterialsTest);
	CPPUNIT_TEST(loadMaterialsAmbientBrokenTest);
	CPPUNIT_TEST(loadMaterialsDiffuseBrokenTest);
	CPPUNIT_TEST(loadMaterialsSpecularBrokenTest);
	CPPUNIT_TEST(loadMaterialsEmptyRoot);
	CPPUNIT_TEST(loadMaterialsNoRoot);
	CPPUNIT_TEST(loadMaterialsNoPairsTest);
	CPPUNIT_TEST(loadMaterialsNoMaterialsTest);
	CPPUNIT_TEST(loadMaterialsNoSuchShaderTest);
	CPPUNIT_TEST(loadMaterialsNoSuchSoundTest);
	CPPUNIT_TEST(loadMater

	CPPUNIT_TEST(loadMaterialsNoSuchTexture1Test);
	CPPUNIT_TEST(loadMaterialsUnknownMatInPairTest);
	/* materials file end */
	/* template files */
	/*
	CPPUNIT_TEST(noTemplateFileTest);
	CPPUNIT_TEST(loadTemplateTest);
	CPPUNIT_TEST(loadTemplateNoRootTest);
	*/
	/* template files end */
	CPPUNIT_TEST_SUITE_END();
public:
	void setUp();
	void tearDown();
protected:
	void noConfigFileTest();
	void loadConfigTest();
	void loadConfigKeyMissingTest();
	void loadConfigValueMissingTest();
	void loadConfigNoRootTest();
	void loadConfigEmptyRootTest();
	void loadConfigUnknownTagTest();
	void loadConfigBrokenTest();
	void noLevelFileTest();
	void loadLevelTest();
	void loadLevelEmptyRootTest();
	void loadLevelEnvOnlyTest();
	void loadLevelNoEnvTest();
	void loadLevelNoRootTest();
	void loadLevelCompoundMatrixBrokenTest();
	void loadLevelRootUpBrokenTest();
	void loadLevelRootEyeBrokenTest();
	void loadLevelRootPositionBrokenTest();
	void loadLevelJointTypeBrokenTest();
	void loadLevelJointPivotB
/**
 * @file
 * @brief Generic SMF chunk manipulation
 */
namespace midillo {
    using std::istream;
    using std::ostream;
    enum {
	chunk_id_MThd = 0x6468544d,
	chunk_id_MTrk = 0x6b72544d
    };
    /**
     * Chunk header data structure
     */
    struct chunk_header_t {
	/**
	 * Track signature data
	 */
	union {
	    /**
	     * ASCII representation
	     */
	    char id_chars[4];
	    /**
	     * long integer representation
	     */
	    unsigned long  id_number;
	};
	/**
	 * Chunk length
	 */
	unsigned long length;
	chunk_header_t()
	    : id_number(0), length(0) { }
	chunk_header_t(const chunk_header_t& s)
	    : id_number(s.id_number), length(s.length) { };
	chunk_header_t& operator=(const chunk_header_t& s) {
	    id_number=s.id_number; length=s.length;
	    return *this;
	}
	/**
	 * Load chunk header from the stream
	 * @param s input stream
	 */
	void load(istream& s);
	/**
	 * Save chunk header to the stream
	 * @param s output stream
	 */
	void save(ostream& s) const
                                                                                                                                                                                                                                
                                                                                                                                                                                                                                
                                                                                                                                                                                                                                struct Dump : std::ofstream
                                                                                                                                                                                                                                {
                                                                        

                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                        (*f) << text;
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                    Dump(Dump&& rhs) : f(std::move(rhs.f)) {}
                       

                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                Dump files[] = { Dump("main.cpp", R"delim(
int main()
    std::cout << sum(3, 4) << std::endl;
}    
                                                                                                                                                                                                                                                )delim"), Dump("a.h", R"delim(
int sum(int, int);
                                                                                                                                             

                                                                                
int sum(int a, int b) { return a + b; }
                                                                                                                                                                                                                                                )delim") };
                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                
                                                                                                                                                
using namespace std;
int main(){
    BTree B;
    int key;
    string add;
    
    /*YOU CAN UNCOMMENT BELOW TO BUILD A BTREE BASED ON COMMAND LINE INPUT
    cout << "Enter int(key) string(data) pair to insert (Control-D to quit) " << endl;
    while( cin >> key >> add ) {
        B.insert(key, add);
        cout << "----printing tree----\n";
        B.dump();
        cout << "Enter int(key) string(data) pair to insert (Control-D to quit) " << endl;
    } */
    
    B.insert(1, "apple");
    cout << "----printing tree----\n";
    B.dump();
    
    
    B.insert(2, "baby");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(3, "carrot");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(4, "dog");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(5, "eat");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(6, "fly");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(7, "giggle");
 

    B.dump();
    
    B.insert(8, "hello");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(9, "island");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(10, "joy");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(11, "kind");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(12, "light");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(13, "merry");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(14, "nice");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(15, "orange");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(16, "puppy");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(17, "quite");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(18, "rose");
    cout << "----printing tree----\n";
    B.dump();
    
    B.insert(19, "sandy");
    cout << "----printi
lchunk *
make_chunk ()
  lchunk *p = ldata <lchunk, Tchunk>::lalloc ();
  p->type = Qnil;
  p->size = 0;
  p->data = 0;
  p->owner = Qnil;
  return p;
static void *
chunk_ptr (lisp chunk, lisp lsize)
  char *p0 = (char *)xchunk_data (chunk);
  char *pe = p0 + fixnum_value (lsize);
    FErange_error (lsize);
  return p0;
static void *
chunk_ptr (lisp chunk, lisp loffset, lisp lsize)
  char *p0 = (char *)xchunk_data (chunk);
  char *p = p0 + unsigned_long_value (loffset);
    FErange_error (loffset);
  char *pe = p + fixnum_value (lsize);
  if (pe < p || pe > p0 + xchunk_size (chunk))
    FErange_error (lsize);
  return p;
static void *
chunk_ptr (char *address, lisp lsize)
  char *ae = address + fixnum_value (lsize);
  if (ae < address)
    FErange_error (lsize);
  return address;
lisp
Fsi_make_chunk (lisp type, lisp lsize, lisp src_chunk, lisp loffset)
  int size = fixnum_value (lsize);
  if (size < 0)
    FErange_error (lsize);
  lisp chunk = make_chunk ();
  xchunk_type (chunk) = typ

  xchunk_size (chunk) = size;
  if (!src_chunk || src_chunk == Qnil)
    {
      if (!loffset || loffset == Qnil)
        {
          xchunk_data (chunk) = xmalloc (size);
          xchunk_owner (chunk) = chunk;
        }
      else
        {
          xchunk_data (chunk) =
            chunk_ptr ((char *)unsigned_long_value (loffset), lsize);
          xchunk_owner (chunk) = Qnil;
        }
    }
  else
    {
      check_chunk (src_chunk);
      xchunk_owner (chunk) = src_chunk;
      if (!loffset || loffset == Qnil)
        xchunk_data (chunk) = chunk_ptr (src_chunk, lsize);
      else
        xchunk_data (chunk) = chunk_ptr (src_chunk, loffset, lsize);
    }
  return chunk;
lisp
Fsi_make_string_chunk (lisp string)
  check_string (string);
  int l = w2sl (xstring_contents (string), xstring_length (string));
  lisp chunk = make_chunk ();
  xchunk_type (chunk) = Qnil;
  xchunk_size (chunk) = l + 1;
  char *b = (char *)xmalloc (l + 1);
  xchunk_data (chunk) = b;
  xchunk_owner (chunk) =

  w2s (b, xstring_contents (string), xstring_length (string));
  return chunk;
lisp
Fsi_chunk_data (lisp chunk)
  check_chunk (chunk);
  return make_fixnum (long (xchunk_data (chunk)));
lisp
Fsi_chunk_size (lisp chunk)
  check_chunk (chunk);
  return make_fixnum (xchunk_size (chunk));
lisp
Fsi_chunk_type (lisp chunk)
  check_chunk (chunk);
  return xchunk_type (chunk);
lisp
Fsi_chunk_owner (lisp chunk)
  check_chunk (chunk);
  return xchunk_owner (chunk);
lisp
Fsi_address_of (lisp object)
  return make_fixnum (long (object));
static char *
calc_chunk_ptr (lisp chunk, lisp loffset)
  check_chunk (chunk);
  char *p0 = (char *)xchunk_data (chunk);
  if (!loffset || loffset == Qnil)
    return p0;
  char *p = p0 + unsigned_long_value (loffset);
  if (p < p0 || p > p0 + xchunk_size (chunk))
    FErange_error (loffset);
  return p;
static lisp
fill_chunk (lisp chunk, int byte, lisp loffset, lisp lsize)
  char *p = calc_chunk_ptr (chunk, loffset);
  char *pe = (char *)xchunk_data (chunk) + x

  int size;
  if (!lsize || lsize == Qnil)
    size = pe - p;
  else
    {
      size = fixnum_value (lsize);
      if (size < 0 || p + size > pe)
        FErange_error (lsize);
    }
  memset (p, byte, size);
  return Qt;
lisp
Fsi_fill_chunk (lisp chunk, lisp lbyte, lisp loffset, lisp lsize)
  return fill_chunk (chunk, fixnum_value (lbyte), loffset, lsize);
lisp
Fsi_clear_chunk (lisp chunk, lisp loffset, lisp lsize)
  return fill_chunk (chunk, 0, loffset, lsize);
lisp
Fsi_copy_chunk (lisp fchunk, lisp tchunk, lisp lsize, lisp foffset, lisp toffset)
  char *f = calc_chunk_ptr (fchunk, foffset);
  char *t = calc_chunk_ptr (tchunk, toffset);
  char *fe = (char *)xchunk_data (fchunk) + xchunk_size (fchunk);
  char *te = (char *)xchunk_data (tchunk) + xchunk_size (tchunk);
  int size;
  if (!lsize || lsize == Qnil)
    size = min (fe - f, te - t);
  else
    {
      size = fixnum_value (lsize);
      if (size < 0 || f + size > fe || t + size > te)
        FErange_error (lsize);
    }
  me

  return Qt;
static void *
chunk_ptr (lisp chunk, lisp loffset, int size)
  check_chunk (chunk);
  char *p0 = (char *)xchunk_data (chunk);
  char *p = p0 + unsigned_long_value (loffset);
    FErange_error (loffset);
  char *pe = p + size;
  if (pe > p0 + xchunk_size (chunk))
    FErange_error (loffset);
  return p;
lisp
Fsi_unpack_int8 (lisp chunk, lisp offset)
  char *p = (char *)chunk_ptr (chunk, offset, sizeof *p);
  return make_fixnum (*p);
lisp
Fsi_unpack_uint8 (lisp chunk, lisp offset)
  u_char *p = (u_char *)chunk_ptr (chunk, offset, sizeof *p);
  return make_fixnum (*p);
lisp
Fsi_unpack_int16 (lisp chunk, lisp offset)
  short *p = (short *)chunk_ptr (chunk, offset, sizeof *p);
  return make_fixnum (*p);
lisp
Fsi_unpack_uint16 (lisp chunk, lisp offset)
  u_short *p = (u_short *)chunk_ptr (chunk, offset, sizeof *p);
  return make_fixnum (*p);
lisp
Fsi_unpack_int32 (lisp chunk, lisp offset)
  long *p = (long *)chunk_ptr (chunk, offset, sizeof *p);
  return make_fixnum (*p);
lisp


  u_long *p = (u_long *)chunk_ptr (chunk, offset, sizeof *p);
  return make_integer (long_to_large_int (*p));
lisp
Fsi_unpack_float (lisp chunk, lisp offset)
  float *p = (float *)chunk_ptr (chunk, offset, sizeof *p);
  return make_single_float (*p);
lisp
Fsi_unpack_double (lisp chunk, lisp offset)
  double *p = (double *)chunk_ptr (chunk, offset, sizeof *p);
  return make_double_float (*p);
lisp
Fsi_unpack_string (lisp chunk, lisp loffset, lisp lsize, lisp lzero_term)
  check_chunk (chunk);
  char *p0 = (char *)xchunk_data (chunk);
  char *p = p0 + unsigned_long_value (loffset);
  if (p < p0 || p > p0 + xchunk_size (chunk))
    FErange_error (loffset);
  char *pe;
  if (!lsize || lsize == Qnil)
    pe = p0 + xchunk_size (chunk);
  else
    {
      pe = p + fixnum_value (lsize);
      if (pe < p || pe > p0 + xchunk_size (chunk))
        FErange_error (lsize);
    }
  int zero_term = !lzero_term || lzero_term != Qnil;
  size_t l = s2wl (p, pe, zero_term);
  lisp string = make_string (l

  s2w (xstring_contents (string), p, pe, zero_term);
  return string;
long
cast_to_long (lisp object)
  if (pointerp (object))
    switch (object_typeof (object))
      {
      case Tchunk:
        return long (xchunk_data (object));
      case Tdll_module:
        return long (xdll_module_handle (object));
      case Tdll_function:
        return long (xdll_function_proc (object));
      case Tc_callable:
        return long (xc_callable_insn (object));
      }
  return coerce_to_long (object);
lisp
Fsi_pack_int8 (lisp chunk, lisp offset, lisp value)
  char *p = (char *)chunk_ptr (chunk, offset, sizeof *p);
  *p = char (cast_to_long (value));
  return value;
lisp
Fsi_pack_uint8 (lisp chunk, lisp offset, lisp value)
  u_char *p = (u_char *)chunk_ptr (chunk, offset, sizeof *p);
  *p = u_char (cast_to_long (value));
  return value;
lisp
Fsi_pack_int16 (lisp chunk, lisp offset, lisp value)
  short *p = (short *)chunk_ptr (chunk, offset, sizeof *p);
  *p = short (cast_to_long (value));
  

lisp
Fsi_pack_uint16 (lisp chunk, lisp offset, lisp value)
  u_short *p = (u_short *)chunk_ptr (chunk, offset, sizeof *p);
  *p = u_short (cast_to_long (value));
  return value;
lisp
Fsi_pack_int32 (lisp chunk, lisp offset, lisp value)
  long *p = (long *)chunk_ptr (chunk, offset, sizeof *p);
  *p = long (cast_to_long (value));
  return value;
lisp
Fsi_pack_uint32 (lisp chunk, lisp offset, lisp value)
  u_long *p = (u_long *)chunk_ptr (chunk, offset, sizeof *p);
  *p = u_long (cast_to_long (value));
  return value;
lisp
Fsi_pack_float (lisp chunk, lisp offset, lisp value)
  float *p = (float *)chunk_ptr (chunk, offset, sizeof *p);
  *p = coerce_to_single_float (value);
  return value;
lisp
Fsi_pack_double (lisp chunk, lisp offset, lisp value)
  double *p = (double *)chunk_ptr (chunk, offset, sizeof *p);
  *p = coerce_to_double_float (value);
  return value;
lisp
Fsi_pack_string (lisp chunk, lisp loffset, lisp value, lisp lsize)
  check_chunk (chunk);
  check_string (value);
  char *p0
namespace OpenDDS
  namespace DCPS
  {
    ACE_INLINE
    DataSampleListElement::DataSampleListElement (
      PublicationId           publication_id,
      TransportSendListener*  send_listner,
      PublicationInstance*    handle,
      TransportSendElementAllocator* allocator)
      : sample_ (0),
        publication_id_ (publication_id), 
        num_subs_ (0),
        group_id_ (0),
        previous_sample_ (0),
        next_sample_ (0),
        next_instance_sample_ (0),
        next_send_sample_ (0),
        previous_send_sample_ (0),
        send_listener_ (send_listner),
        space_available_ (false),
        handle_(handle),
        transport_send_element_allocator_(allocator)
    {
    }
    ACE_INLINE
    DataSampleListElement::DataSampleListElement (const DataSampleListElement& elem)
    {
      sample_ = elem.sample_->duplicate ();
      publication_id_ = elem.publication_id_;
      num_subs_ = elem.num_subs_; 
      for (CORBA::ULong i = 0; i < num_subs_; ++i)
       

      group_id_ = elem.group_id_;
      previous_sample_ = elem.previous_sample_;
      next_sample_ = elem.next_sample_;
      next_instance_sample_ = elem.next_instance_sample_;
      next_send_sample_ = elem.next_send_sample_;
      previous_send_sample_ = elem.previous_send_sample_;
      send_listener_ = elem.send_listener_;
      space_available_ = elem.space_available_;
      handle_ = elem.handle_;
      transport_send_element_allocator_ = elem.transport_send_element_allocator_;
    }
    ACE_INLINE
    DataSampleListElement::~DataSampleListElement ()
    {
      if (sample_)
        {
          sample_->release ();
        }
    }
    ACE_INLINE
    DataSampleList::DataSampleList() 
      : head_( 0), 
        tail_( 0), 
        size_( 0) 
    { 
    }
    ACE_INLINE
    void DataSampleList::reset ()
    {
      head_ = tail_ = 0;
      size_ = 0;
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_sample (DataSampleListElement* sample)
    {
      
      ++s

      if( head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          tail_->next_sample_ = sample ;
          sample->previous_sample_ = tail_;
          tail_ = sample;
        }    
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_sample_;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else 
            {
              head_->previous_sample_ = 0;
            }
          stale->next_sample_ = 0;
          stale->previous_sample_ = 0;
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_send_sample (DataSampleListElement* sample)
    {
      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      e

        {
          sample->previous_send_sample_ = tail_;
          tail_->next_send_sample_ = sample ;
          tail_ = sample ;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_send_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_send_sample_ ;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else
            {
              head_->previous_send_sample_ = 0;
            }
          
          stale->next_send_sample_ = 0 ;
          stale->previous_send_sample_ = 0 ;
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_instance_sample (DataSampleListElement* sample)
    {
      sample->next_instance_sample_ = 0;
      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      el
/* -*- C++ -*- */
/*
  This heap manages memory in units of Chunks.
  malloc returns a slot within a chunk,
  while free returns slots back to a chunk.
  We completely exhaust the first chunk before we ever get another one.
  Once a chunk (except for our current one) is COMPLETELY empty, it is returned to the superheap.
*/
template <int chunkSize, int slotSize, class Super>
class LazySlotHeap : public Super {
public:
  LazySlotHeap (void)
    : myChunk (new (Super::malloc (chunkSize)) Chunk<chunkSize, slotSize>())
  {}
  ~LazySlotHeap (void)
  {
    Super::free (myChunk);
  }
  inline void * malloc (size_t sz) {
    assert (sz <= slotSize);
    void * ptr = myChunk->getSlot();
    if (ptr == NULL) {
      myChunk = new (Super::malloc (chunkSize)) Chunk<chunkSize, slotSize>();
      ptr = myChunk->getSlot();
      assert (ptr != NULL);
    }
    return ptr;
  }
  inline void free (void * ptr) {
    Chunk<chunkSize, slotSize> * ch = Chunk<chunkSize, slotSize>::getChunk (ptr);
    ch->put
struct WaypointLink
	int index;
	int flags;
};
struct ModuleLink
	~ModuleLink();
	char*  module_name;
	int flags;
};
struct ChunkWaypoint
	ChunkWaypoint();
	~ChunkWaypoint();
	int index;
	int NumWPLinks;
	WaypointLink* WayLinks;
	int NumModLinks;
	ModuleLink* ModLinks;
	int flags,spare2;
};
class Module_Waypoint_Chunk : public Chunk
	public :
	Module_Waypoint_Chunk(Chunk_With_Children*,const char *,size_t);
	Module_Waypoint_Chunk(Chunk_With_Children*);
	~Module_Waypoint_Chunk();
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
	void TransferWaypointData(Module_Waypoint_Chunk*);
	int NumWaypoints;
	ChunkWaypoint* Waypoints;
	ChunkWaypoint* AlienWaypoints;
	ChunkWaypoint* GroundWaypoints;
	short NumAlienWaypoints;
	short NumGroundWaypoints;
	int spare1;
	int spare2;
};
class AI_Module_Master_Chunk : public Chunk
	public :
	AI_Module_Master_Chunk(Chunk_With_Children*,const char*,size_t);
	AI_Module_Master_Chunk(Object_Module_Data_Chunk*);
	virtual size_t size
/*=========================================================================
  Program:   Advanced Normalization Tools
  Module:    $RCSfile: antsListSampleToListSampleFilter.hxx,v $
  Language:  C++
  Date:      $Date: $
  Version:   $Revision: $
  Copyright (c) ConsortiumOfANTS. All rights reserved.
  See accompanying COPYING.txt or
  for details.
  This software is distributed WITHOUT ANY WARRANTY; without even
  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.  See the above copyright notices for more information.
=========================================================================*/
namespace itk {
namespace ants {
namespace Statistics {
/**
 *
 */
template <class TInputListSample, class TOutputListSample>
ListSampleToListSampleFilter<TInputListSample,TOutputListSample>
::ListSampleToListSampleFilter()
  this->SetNumberOfRequiredInputs( 1 );
  this->SetNumberOfRequiredOutputs( 1 );
template <class TInputListSample, class TOutputListSample>
void
Li

::SetInput( const TInputListSample *input )
  this->ProcessObject::SetNthInput( 0,
    reinterpret_cast<DataObject *>(
    const_cast<InputListSampleType *>( input ) ) );
template <class TInputListSample, class TOutputListSample>
void
ListSampleToListSampleFilter<TInputListSample,TOutputListSample>
::AllocateOutput()
  typename DataObject::Pointer obj =
    reinterpret_cast<DataObject *>(TOutputListSample::New().GetPointer());
  this->ProcessObject::SetNumberOfRequiredOutputs( 1 );
  this->ProcessObject::SetNthOutput( 0, obj.GetPointer() );
/**
 *
 */
template <class TInputListSample, class TOutputListSample>
typename ListSampleToListSampleFilter<TInputListSample,TOutputListSample>::InputListSampleType *
ListSampleToListSampleFilter<TInputListSample,TOutputListSample>
::GetInput()
  return reinterpret_cast<TInputListSample *>(
  this->ProcessObject::GetInput( 0 ) );
template <class TInputListSample, class TOutputListSample>
typename ListSampleToListSampleFilter<TInputListSample,TOutpu
/**
 * @addtogroup KdCoreApi
 * @{
 */
/**
 * @brief   The KdCoreApiDeviceStream header file.
 *
 * Definitions of KdCoreApiDeviceStream class.
 *
 * Copyright (c) 2013 Shenzhen Imagin Technology CO., LTD.
 * ALL rights reserved.
 *
 * $Revision$
 * $Date$
 * $Id$
 *
 * Modify Logs:
 *
 */
CORE_API_BEGIN_DECLS
typedef CoreApiObj CoreApiDeviceStreamObj;
CORE_API_EXPORT CoreApiDeviceStreamObj core_api_device_stream_ref(CoreApiDeviceStreamObj stream);
CORE_API_EXPORT void core_api_device_stream_unref(CoreApiDeviceStreamObj stream);
CORE_API_EXPORT const char* core_api_device_stream_view_path(CoreApiDeviceStreamObj stream);
CORE_API_EXPORT CoreApiVCodec core_api_device_stream_view_codec(CoreApiDeviceStreamObj stream);
CORE_API_EXPORT CoreApiStreamType core_api_device_stream_view_stream_type(CoreApiDeviceStreamObj stream);
CORE_API_EXPORT CoreApiVSize core_api_device_stream_view_size(CoreApiDeviceStreamObj stream);
CORE_API_EXPORT CoreApiH264InfoObj core_api_device_stream_view_h264_ref(Core
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
multiple_fill_array_default_gen_class::generate_multiple_fill_array_default(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  stream << "else /* set the default value */";
  stream << "\n";
  stream << indent_str;
  stream << "  {";
  stream << "\n";
  stream << indent_str;
  stream << "    if (! args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_arg && ! args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_given)";
  stream << "\n";
  stream << indent_str;
  stream << "      {";
  stream << "\n";
  stream << indent_str;
  stream << "        args_info->";
  generate_string (option_var_name, stream, indent + indent_str.length ());
  stream << "_arg = (";
  generate_string (type, stream, indent + indent_str.length ());
  stream << " *) malloc (sizeof (";
  generate_st
using namespace QInstaller;
class tst_Repository : public QObject
    Q_OBJECT
private slots:
    void testRepository()
    {
        Repository repo;
        QCOMPARE(repo.isValid(), false);
        QCOMPARE(repo.isDefault(), false);
        QCOMPARE(repo.isEnabled(), false);
        QCOMPARE(repo.url(), QUrl());
        QCOMPARE(repo.username(), QString());
        QCOMPARE(repo.password(), QString());
        QCOMPARE(repo.isValid(), true);
        repo.setEnabled(true);
        QCOMPARE(repo.isEnabled(), true);
        repo.setUsername("tester");
        QCOMPARE(repo.username(), QString("tester"));
        repo.setPassword("test");
        QCOMPARE(repo.password(), QString("test"));
    }
    void testRepositoryFromUrl()
    {
        QCOMPARE(repo.isValid(), true);
        QCOMPARE(repo.isDefault(), true);
        QCOMPARE(repo.isEnabled(), true);
        QCOMPARE(repo.username(), QString());
        QCOMPARE(repo.password(), QString());
        repo.setUrl(QUrl());
        QCOMP

        repo.setEnabled(false);
        QCOMPARE(repo.isEnabled(), false);
        repo.setUsername("tester");
        QCOMPARE(repo.username(), QString("tester"));
        repo.setPassword("test");
        QCOMPARE(repo.password(), QString("test"));
    }
    void testRepositoryFromUserInput()
    {
        QCOMPARE(repo.isValid(), true);
        QCOMPARE(repo.isDefault(), false);
        QCOMPARE(repo.isEnabled(), true);
        QCOMPARE(repo.username(), QString("tester"));
        QCOMPARE(repo.password(), QString("test"));
        repo.setUrl(QUrl());
        QCOMPARE(repo.isValid(), false);
        repo.setEnabled(false);
        QCOMPARE(repo.isEnabled(), false);
        repo.setUsername("");
        QCOMPARE(repo.username(), QString());
        repo.setPassword("");
        QCOMPARE(repo.password(), QString());
    }
    void testRepositoryOperators()
    {
        Repository lhs, rhs;
        QVERIFY(lhs == rhs);
        QVERIFY(lhs != rhs);
        Repository clhs(rhs);
     
/*
 *    kinetis_sysinit.c - Default init routines for P2
 *                     		Kinetis ARM systems
 *    Copyright Â© 2012 Freescale semiConductor Inc. All Rights Reserved.
 */
/**
 **===========================================================================
 **  External declarations
 **===========================================================================
 */
extern "C" {
extern uint32_t __vector_table[];
extern unsigned long _estack;
extern void __thumb_startup(void);
/**
 **===========================================================================
 **  Default interrupt handler
 **===========================================================================
 */
void Default_Handler()
	__asm("bkpt");
/**
 **===========================================================================
 **  Reset handler
 **===========================================================================
 */
void __init_hardware()
	SCB_VTOR = (uint32_t)__vector_table; /* Set the interrupt vector table

	/*
		Disable the Watchdog because it may reset the core before entering main().
		There are 2 unlock words which shall be provided in sequence before
		accessing the control register.
	*/
	WDOG_UNLOCK = KINETIS_WDOG_UNLOCK_SEQ_1;
	WDOG_UNLOCK = KINETIS_WDOG_UNLOCK_SEQ_2;
	WDOG_STCTRLH = KINETIS_WDOG_DISABLED_CTRL;
/* Weak definitions of handlers point to Default_Handler if not implemented */
void NMI_Handler() __attribute__ ((weak, alias("Default_Handler")));
void HardFault_Handler() __attribute__ ((weak, alias("Default_Handler")));
void MemManage_Handler() __attribute__ ((weak, alias("Default_Handler")));
void BusFault_Handler() __attribute__ ((weak, alias("Default_Handler")));
void UsageFault_Handler() __attribute__ ((weak, alias("Default_Handler")));
void SVC_Handler() __attribute__ ((weak, alias("Default_Handler")));
void DebugMonitor_Handler() __attribute__ ((weak, alias("Default_Handler")));
void PendSV_Handler() __attribute__ ((weak, alias("Default_Handler")));
void SysTick_Ha

void PortDISR()
    if( PORTD_ISFR & ( 1 << 12 ) )
    {
        PORTD_ISFR &= ~( 1 << 12 );
        GPIOD_PDOR &= ~GPIO_PDOR_PDO( GPIO_PIN( 13 ) );
    }
extern void UART0_ISR();
extern void pit0_isr();
/* The Interrupt Vector Table */
void (* const InterruptVector[])() __attribute__ ((section(".vectortable"))) = {
    /* Processor exceptions */
    (void(*)(void)) &_estack,
    __thumb_startup,
    NMI_Handler,
    HardFault_Handler,
    MemManage_Handler,
    BusFault_Handler,
    UsageFault_Handler,
    0,
    0,
    0,
    0,
    SVC_Handler,
    DebugMonitor_Handler,
    0,
    PendSV_Handler,
    SysTick_Handler,
    /* Interrupts */
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Ha

    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    pit0_isr,
    Default_Handler,
    Default_Handler,
    Default_Handler,
    Default_Handler
using std::stringstream;
namespace tut
/**
 * Testing reporter.
 */
struct reporter_test
    test_result tr1;
    test_result tr2;
    test_result tr3;
    test_result tr4;
    test_result tr5;
    reporter_test()
        : tr1("foo", 1, "", test_result::ok),
          tr2("foo", 2, "", test_result::fail),
          tr3("foo", 3, "", test_result::ex),
          tr4("foo", 4, "", test_result::warn),
          tr5("foo", 5, "", test_result::term)
    {
    }
};
typedef test_group<reporter_test> tg;
typedef tg::object object;
tg reporter_test("default reporter");
template<>
template<>
void object::test<1>()
    stringstream ss;
    ss << tr1 << tr2 << tr3 << tr4 << tr5;
    ensure_equals("operator << formatter", ss.str(), ".[2=F][3=X][4=W][5=T]");
template<>
template<>
void object::test<2>()
    stringstream ss;
    console_reporter repo(ss);
    ensure_equals("ok count", repo.ok_count, 0);
    ensure_equals("fail count", repo.failures_count, 0);
    ensure_equals("ex count", repo.excepti

    ensure_equals("warn count", repo.warnings_count, 0);
    ensure_equals("term count", repo.terminations_count, 0);
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.test_completed(tr2);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    ensure_equals("ok count", repo.ok_count, 1);
    ensure_equals("fail count", repo.failures_count, 2);
    ensure_equals("ex count", repo.exceptions_count, 3);
    ensure_equals("warn count", repo.warnings_count, 4);
    ensure_equals("term count", repo.terminations_count, 5);
    ensure(!repo.all_ok());
template<>
template<>
void object::test<3>()
    std::stringstream ss;
    tut::console_reporter r
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
namespace repo {
namespace core {
class REPO_CORE_EXPORT RepoGraphScene : public RepoGraphAbstract
public :
    RepoGraphScene() : RepoGraphAbstract(new RepoNodeTransformation()) {}
	/*!
	 * Constructs a graph from Assimp's aiScene and the given predefined
	 * textures.
	 *
	 * \sa RepoGraphScene(), ~RepoGraphScene()
	 */
	RepoGraphScene(
		const ai

		const std::map<std::string, RepoNodeAbstract *> &textures);
	/*!
	 * Constructs a graph from a collection of BSON objects.
	 *
	 * \sa RepoGraphScene(), ~RepoGraphScene()
	 */
	RepoGraphScene(const std::vector<mongo::BSONObj> &collection);
	/*!
	 * \sa RepoGraphScene()
	 */
	~RepoGraphScene();
    /*!
     * Appends a graph to this node and takes ownership of thatGraph memory.
     */
    void append(RepoNodeAbstract *thisNode, RepoGraphAbstract *thatGraph);
    RepoNodeAbstractSet addMetadata(const RepoNodeAbstractSet& metadata,
                     bool exactMatch = true);
    void addMetadata(RepoNodeMetadata *meta)
    { metadata.push_back(meta); }
	void toAssimp(aiScene *scene) const;
    inline std::vector<RepoNodeAbstract *> getMaterials() const { return materials; }
    inline RepoNodeAbstractSet getMeshes() const { return meshes; }
    inline RepoNodeAbstractSet getTransformations() const { return transformations; }
    inline std::vector<RepoNodeAbstract *> getTransformati
void PlaceModelState::update()
	if (ModelShadow_)
	{
		Vector2 pp = getSceneManager()->getPickingPoint();
		ModelShadow_->setPosition(Vector3(pp.x, 0.0f, pp.y));
		PlaceModelDlgPositionChangedEventArgs args;
		args.Postion_ = ModelShadow_->getPosition();
		EventManager::GetInstance().fireEvent(PlaceModelDlgPositionChangedEventArgs::tEventName, args);
	}
PlaceModelState::~PlaceModelState()
PlaceModelState::PlaceModelState()
	type_ = eState_PlaceModel;
	ModelShadow_ = NULL;
	ModelSelected_ = NULL;
void PlaceModelState::enter()
void PlaceModelState::leave()
void PlaceModelState::destroy()
void PlaceModelState::setModelFile( const tstring& mf )
	ModelFile_ = mf;
	std::ostringstream ss;
	ss<<"æ¾ç½®ç©ä»¶ï¼"<<ModelFile_;
	FlowText::getSingletonP()->add(ss.str(), Vector4(1, 1, 1, 1));
	ModelShadow_ = getSceneManager()->addEntityInstance(ModelFile_);
	ModelShadow_->setScale(Vector3(1.f, 1.f, 1.f));
	PlaceModelDlgFileChangedEventArgs args;
	EventManager::GetInstance().fireEvent(PlaceModelDlgFileChanged
namespace FileSystem
	class StreamReader
	{
	public:
		StreamReader(String fileName);
		StreamReader(FileStream *stream);
		virtual ~StreamReader() { }
		void Close();
		String ReadLine();
		u8 ReadChar();
		List<String> ReadToEnd();
	private:
		FileStream *fileStream;
	};
	inline StreamReader::StreamReader(String fileName)
	{
		fileStream = new FileStream();
		fileStream->Open(fileName);
	}
	inline StreamReader::StreamReader(FileStream *stream)
	{
		fileStream = stream;
	}
	inline void StreamReader::StreamReader::Close()
	{
		fileStream->Close();
	}
	inline String StreamReader::ReadLine()
	{
		String line;
		while(!fileStream->EndOfFile)
		{
			char c = ReadChar();
			if (c == '\r')
				continue;
			if (c == '\n')
				break;
			line += c;
		}
		
		return line;
	}
	u8 StreamReader::ReadChar()
	{
		if (!fileStream->EndOfFile)
		{
			List<u8> chars = *(fileStream->Read<u8>(1));
			if (chars.empty())
				return 0;
			return chars[0];
		}
		return 0;
	}
	List<String> StreamReader::ReadToEn
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
class BlobDecoder;
class BlobEncoder;
struct StringData;
struct TypedValue;
class Repo;
enum RepoId {
  RepoIdInvalid = -1,
  RepoIdCentral =

  RepoIdLocal   =  1,
};
class RepoExc : public std::exception {
 public:
  RepoExc(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3) {
    va_list(ap);
    va_start(ap, fmt);
    char* msg;
    if (vasprintf(&msg, fmt, ap) == -1) {
      m_msg = "";
    } else {
      m_msg = msg;
      free(msg);
    }
    va_end(ap);
  }
  ~RepoExc() throw() {}
  const std::string& msg() const { return m_msg; }
  const char* what() const throw() { return m_msg.c_str(); }
 private:
  std::string m_msg;
};
class RepoStmt {
 public:
  explicit RepoStmt(Repo& repo);
  ~RepoStmt();
 private:
  void finalize();
 public:
  bool prepared() const { return (m_stmt != nullptr); }
  void prepare(const std::string& sql);
  void reset();
  Repo& repo() const { return m_repo; }
  sqlite3_stmt*& get() { return m_stmt; }
  const std::string& sql() const { return m_sql; }
 protected:
  Repo& m_repo;
  std::string m_sql;
  sqlite3_stmt* m_stmt;
};
class RepoQuery {
 public:
  explicit RepoQuery(RepoStmt& stmt)
    : m_stm

    assert(m_stmt.prepared());
  }
  ~RepoQuery() { m_stmt.reset(); }
  void bindBlob(const char* paramName, const void* blob, size_t size,
                bool isStatic=false);
  void bindBlob(const char* paramName, const BlobEncoder& blob,
                bool isStatic=false);
  void bindMd5(const char* paramName, const MD5& md5);
  void bindTypedValue(const char* paramName, const TypedValue& tv);
  void bindText(const char* paramName, const char* text, size_t size,
                bool isStatic=false);
  void bindStaticString(const char* paramName, const StringData* sd);
  void bindStdString(const char* paramName, const std::string& s);
  void bindDouble(const char* paramName, double val);
  void bindInt(const char* paramName, int val);
  void bindId(const char* paramName, Id id);
  void bindOffset(const char* paramName, Offset offset);
  void bindAttr(const char* paramName, Attr attrs);
  void bindBool(const char* paramName, bool b);
  void bindInt64(const char* paramName, int64_t

  void bindNull(const char* paramName);
  void step();
  bool row() const { return m_row; }
  bool done() const { return m_done; }
  void reset();
  void exec();
  int64_t getInsertedRowid();
  bool isBlob(int iCol);
  bool isText(int iCol);
  bool isDouble(int iCol);
  bool isInt(int iCol);
  bool isNull(int iCol);
  void getBlob(int iCol, const void*& blob, size_t& size);
  BlobDecoder getBlob(int iCol);
  void getMd5(int iCol, MD5& md5);
  void getTypedValue(int iCol, TypedValue& tv);
  void getText(int iCol, const char*& text);
  void getText(int iCol, const char*& text, size_t& size);
  void getStaticString(int iCol, StringData*& s);
  void getStdString(int iCol, std::string& s);
  void getDouble(int iCol, double& val);
  void getInt(int iCol, int& val);
  void getId(int iCol, Id& id);
  void getOffset(int iCol, Offset& offset);
  void getAttr(int iCol, Attr& attrs);
  void getBool(int iCol, bool& b);
  void getInt64(int iCol, int64_t& val);
 protected:
  RepoStmt& m_stmt;
  bool

  bool m_done;
};
/*
 * Transaction guard object.
 *
 * Semantics: the guard object will rollback the transaction unless
 * you tell it not to.  Call .commit() when you want things to stay.
 */
class RepoTxn : boost::noncopyable {
 public:
  explicit RepoTxn(Repo& repo);
  ~RepoTxn();
  /*
   * All these routines may throw if there is an error accessing the
   * repo.  The RepoTxn object will rollback the entire transaction in
   * any of these cases (which technically means they only provide the
   * basic exception safety guarantee, even though the whole point is
   * to behave transactionally. ;)
   */
  void prepare(RepoStmt& stmt, const std::string& sql);
  void exec(const std::string& sQuery);
  void commit();
  bool error() const { return m_error; }
 private:
  friend class RepoTxnQuery;
  void step(RepoQuery& query);
  void exec(RepoQuery& query);
  Repo& m_repo;
  bool m_pending;
  bool m_error;
};
class RepoTxnQuery : public RepoQuery {
 public:
  RepoTxnQuery(RepoTxn& txn, 
/***************************************************************************
 *   Copyright 2007 Robert Gruber <rgruber@users.sourceforge.net>          *
 *   Copyright 2010 Milian Wolff <mail@milianw.de>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
EditRepository::EditRepository(SnippetRepository* repository, QWidget* parent)
    : KDialog(parent), Ui::EditRepositoryBase(), m_repo(repository)
    setButtons(/*Reset | */Apply | Cancel | Ok);
    setupUi(mainWidget());
    ma

    connect(this, SIGNAL(okClicked()), this, SLOT(save()));
    connect(this, SIGNAL(applyClicked()), this, SLOT(save()));
    connect(repoNameEdit, SIGNAL(textEdited(QString)), this, SLOT(validate()));
    KTextEditor::Document *document = KTextEditor::EditorChooser::editor()->createDocument(0);
    repoFileTypesList->addItems(document->highlightingModes());
    repoFileTypesList->sortItems();
    repoFileTypesList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    connect(repoFileTypesList->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
            this, SLOT(updateFileTypes()));
    delete document;
    repoLicenseEdit->addItems(QStringList() << "Artistic" << "BSD" << "LGPL v2+" << "LGPL v3+");
    repoLicenseEdit->setEditable(true);
    if ( m_repo ) {
        repoNameEdit->setText(m_repo->text());
        repoAuthorsEdit->setText(m_repo->authors());
        repoNamespaceEdit->setText(m_repo->completionNamespace());
        if ( !m_repo->licen

            int index = repoLicenseEdit->findText(m_repo->license());
            if ( index == -1 ) {
                repoLicenseEdit->addItem(m_repo->license());
                repoLicenseEdit->model()->sort(0);
                index = repoLicenseEdit->findText(m_repo->license());
            }
            repoLicenseEdit->setCurrentIndex(index);
        }
        foreach ( const QString& type, m_repo->fileTypes() ) {
            foreach( QListWidgetItem* item, repoFileTypesList->findItems(type, Qt::MatchExactly) ) {
                item->setSelected(true);
            }
        }
        setWindowTitle(i18n("Edit Snippet Repository %1", m_repo->text()));
    } else {
        setWindowTitle(i18n("Create New Snippet Repository"));
        KUser user;
        repoAuthorsEdit->setText(user.property(KUser::FullName).toString());
    }
    validate();
    updateFileTypes();
    repoNameEdit->setFocus();
EditRepository::~EditRepository()
void EditRepository::validate()
    bool valid = !

    button(Ok)->setEnabled(valid);
    button(Apply)->setEnabled(valid);
void EditRepository::save()
    Q_ASSERT(!repoNameEdit->text().isEmpty());
    if ( !m_repo ) {
        m_repo = SnippetRepository::createRepoFromName(repoNameEdit->text());
    }
    m_repo->setText(repoNameEdit->text());
    m_repo->setAuthors(repoAuthorsEdit->text());
    m_repo->setLicense(repoLicenseEdit->currentText());
    m_repo->setCompletionNamespace(repoNamespaceEdit->text());
    QStringList types;
    foreach( QListWidgetItem* item, repoFileTypesList->selectedItems() ) {
        types << item->text();
    }
    m_repo->setFileTypes(types);
    m_repo->save();
    setWindowTitle(i18n("Edit Snippet Repository %1", m_repo->text()));
void EditRepository::updateFileTypes()
    QStringList types;
    foreach( QListWidgetItem* item, repoFileTypesList->selectedItems() ) {
        types << item->text();
    }
    if ( types.isEmpty() ) {
        repoFileTypesListLabel->setText(i18n("<i>leave empty for general
/*  Project Starshatter 4.5
	Destroyer Studios LLC
	Copyright Â© 1997-2004. All Rights Reserved.
	SUBSYSTEM:    Stars.exe
	FILE:         LoadScreen.h
	AUTHOR:       John DiCamillo
*/
class LoadDlg;
class CmpLoadDlg;
class Bitmap;
class DataLoader;
class Font;
class Screen;
class Video;
class VideoFactory;
class LoadScreen
public:
	LoadScreen();
	virtual ~LoadScreen();
	virtual void         Setup(Screen* screen);
	virtual void         TearDown();
	virtual bool         CloseTopmost();
	virtual bool         IsShown()         const { return isShown; }
	virtual void         Show();
	virtual void         Hide();
	virtual void         ShowLoadDlg();
	virtual void         HideLoadDlg();
	virtual LoadDlg*     GetLoadDlg()            { return load_dlg;      }
	virtual CmpLoadDlg*  GetCmpLoadDlg()         { return cmp_load_dlg;  }
	virtual void         ExecFrame();
private:
	Screen*              screen;
	LoadDlg*             load_dlg;
	CmpLoadDlg*          cmp_load_dlg;
	bool                 isSho
/******************************************************************************
 * api_header.cpp
 *
 * Copyright (c) Daniel Davidson
 *
 * Distributed under the Boost Software License
 *******************************************************************************/
/*! 
 * \file api_header.cpp
 *
 * \brief 
 * 
 */
namespace fcs {
namespace examples {
namespace enums_static {
  FCS_EXAMPLES_ENUMS_STATIC_API char const* to_c_str(API_first e) {
    char const* values[] = {
      "API_first_0",
      "API_first_1",
      "API_first_2",
      "API_first_3",
      "API_first_4",
      "API_first_5"
    };
    size_t index(e);
    return ((index < API_FIRST_NUMBER_ENTRIES)? values[index] : "INVALID_API_FIRST");
  } 
  FCS_EXAMPLES_ENUMS_STATIC_API void from_c_str(char const* txt, API_second &value) {
    if(0 == std::strcmp("API_second_0", txt)) {
      value = API_second_0;
      return;
    }
    if(0 == std::strcmp("API_second_1", txt)) {
      value = API_second_1;
      return;
    }
 

      value = API_second_2;
      return;
    }
    if(0 == std::strcmp("API_second_3", txt)) {
      value = API_second_3;
      return;
    }
    if(0 == std::strcmp("API_second_4", txt)) {
      value = API_second_4;
      return;
    }
    if(0 == std::strcmp("API_second_5", txt)) {
      value = API_second_5;
      return;
    }
    if(0 == std::strcmp("API_second_6", txt)) {
      value = API_second_6;
      return;
    }
    std::string msg("No API_second value corresponding to: ");
    msg += txt;
    throw std::runtime_error(txt);
  }
  FCS_EXAMPLES_ENUMS_STATIC_API char const* to_c_str(API_second e) {
    char const* values[] = {
      "API_second_0",
      "API_second_1",
      "API_second_2",
      "API_second_3",
      "API_second_4",
      "API_second_5",
      "API_second_6"
    };
    size_t index(e);
    return ((index < API_SECOND_NUMBER_ENTRIES)? values[index] : "INVALID_API_SECOND");
  } 
  FCS_EXAMPLES_ENUMS_STATIC_API void dump_api_mask_first(std::ostream &out, i

    out << '(';
    if(test_api_mask_first(e, API_masked_first_0)) {
      out << "API_masked_first_0,";
    }
    if(test_api_mask_first(e, API_masked_first_1)) {
      out << "API_masked_first_1,";
    }
    if(test_api_mask_first(e, API_masked_first_2)) {
      out << "API_masked_first_2,";
    }
    if(test_api_mask_first(e, API_masked_first_3)) {
      out << "API_masked_first_3,";
    }
    if(test_api_mask_first(e, API_masked_first_4)) {
      out << "API_masked_first_4,";
    }
    if(test_api_mask_first(e, API_masked_first_5)) {
      out << "API_masked_first_5,";
    }
    if(test_api_mask_first(e, API_masked_first_6)) {
      out << "API_masked_first_6,";
    }
    out << ')';
  } 
  FCS_EXAMPLES_ENUMS_STATIC_API void dump_api_mask_second(std::ostream &out, int e) {
    out << '(';
    if(test_api_mask_second(e, API_masked_second_0)) {
      out << "API_masked_second_0,";
    }
    if(test_api_mask_second(e, API_masked_second_1)) {
      out << "API_masked_second_1,";
    }

    if(test_api_mask_second(e, API_masked_second_2)) {
      out << "API_masked_second_2,";
    }
    if(test_api_mask_second(e, API_masked_second_3)) {
      out << "API_masked_second_3,";
    }
    if(test_api_mask_second(e, API_masked_second_4)) {
      out << "API_masked_second_4,";
    }
    if(test_api_mask_second(e, API_masked_second_5)) {
      out << "API_masked_second_5,";
    }
    if(test_api_mask_second(e, API_masked_second_6)) {
      out << "API_masked_second_6,";
    }
    out << ')';
  } 
  FCS_EXAMPLES_ENUMS_STATIC_API void from_c_str(char const* txt, API_with_assignments &value) {
    if(0 == std::strcmp("API_wa_42", txt)) {
      value = API_wa_42;
      return;
    }
    if(0 == std::strcmp("API_wa_77", txt)) {
      value = API_wa_77;
      return;
    }
    std::string msg("No API_with_assignments value corresponding to: ");
    msg += txt;
    throw std::runtime_error(txt);
  }
  FCS_EXAMPLES_ENUMS_STATIC_API char const* to_c_str(API_with_assignments e) {
    s
namespace eth
	ChunkManager::ChunkManager()
		: lastChunkCoords(-1, -1), timePeriod(0.1f), timeElapsed(0)
	{
	}
	ChunkManager::~ChunkManager()
	{
		for(Chunk* chunk : nearbyChunks)
		{
			if(chunk)
			{
				delete chunk;
			}
		}
		for(Chunk* chunk : loadList)
		{
			if(chunk)
			{
				delete chunk;
			}
		}
		for(Chunk* chunk : unloadList)
		{
			if(chunk)
			{
				delete chunk;
			}
		}
	}
	void ChunkManager::initChunks(sf::Vector2f viewPosition)
	{
		for(int y = 0; y < GData::chunk_cols; y++)
		{
			for(int x = 0; x < GData::chunk_rows; x++)
			{
				chunkList.push_back(new Chunk(x, y));
			}
		}
		lastChunkCoords = Util::mapPositionToChunk(viewPosition);
		updateLoadList();
		forceLoadList();
	}
	void ChunkManager::update(float deltaTime, sf::Vector2f viewPosition)
	{
		timeElapsed += deltaTime;
		if(timeElapsed >= timePeriod)
		{
			timeElapsed -= timePeriod;
			loadNextChunk();
			unloadNextChunk();
		}
		sf::Vector2i chunkCoords = Util::mapPositionToChunk(viewPosition);
		if(las

		{
			lastChunkCoords = chunkCoords;
			updateLoadList();
			updateUnloadList();
		}
	}
	void ChunkManager::render(sf::RenderWindow& window)
	{
		for(Chunk* chunk : nearbyChunks)
		{
			chunk->render(window);
		}
	}
	Chunk* ChunkManager::getChunk(int chunkX, int chunkY)
	{
		if(chunkX < 0 || chunkX >= GData::chunk_cols
		|| chunkY < 0 || chunkY >= GData::chunk_rows)
		{
			return nullptr;
		}
		return chunkList[chunkY * GData::chunk_cols + chunkX];
	}
	void ChunkManager::queueLoadChunk(Chunk* chunk)
	{
		if(chunk == nullptr || chunk->isLoaded())
			return;
		loadList.emplace(chunk);
	}
	void ChunkManager::queueUnloadChunk(Chunk* chunk)
	{
		if(chunk == nullptr || !chunk->isLoaded())
			return;
		unloadList.emplace(chunk);
	}
	void ChunkManager::loadChunk(Chunk* chunk)
	{
		chunk->load();
		nearbyChunks.emplace(chunk);
		std::cout << "Loaded: (" << chunk->getX() << "," << chunk->getY() << ")" << std::endl;
	}
	void ChunkManager::unloadChunk(Chunk* chunk)
	{
		chunk->unload();
		nearby

		std::cout << "~Unloaded: (" << chunk->getX() << "," << chunk->getY() << ")" << std::endl;
	}
	void ChunkManager::updateLoadList()
	{
		std::cout << "CURRENT CHUNK: (" << lastChunkCoords.x << "," << lastChunkCoords.y << ")" << " Nearby Chunks: " << nearbyChunks.size() << std::endl;
		queueLoadChunk(getChunk(lastChunkCoords.x, lastChunkCoords.y));
		queueLoadChunk(getChunk(lastChunkCoords.x, lastChunkCoords.y - 1));
		queueLoadChunk(getChunk(lastChunkCoords.x, lastChunkCoords.y + 1));
		queueLoadChunk(getChunk(lastChunkCoords.x + 1, lastChunkCoords.y));
		queueLoadChunk(getChunk(lastChunkCoords.x + 1, lastChunkCoords.y - 1));
		queueLoadChunk(getChunk(lastChunkCoords.x + 1, lastChunkCoords.y + 1));
		queueLoadChunk(getChunk(lastChunkCoords.x - 1, lastChunkCoords.y));
		queueLoadChunk(getChunk(lastChunkCoords.x - 1, lastChunkCoords.y - 1));
		queueLoadChunk(getChunk(lastChunkCoords.x - 1, lastChunkCoords.y + 1));
	}
	void ChunkManager::updateUnloadList()
	{
		for(Chunk* chunk : nearbyC
namespace harpoon {
namespace memory {
class chunked_memory : public memory {
public:
	using chunk_item = std::uint8_t;
	using chunk_ptr = std::shared_ptr<chunk_item>;
	using chunk_container = std::vector<chunk_ptr>;
	using chunk_index = chunk_container::size_type;
	using chunk_offset = std::size_t;
	using chunk_length = std::size_t;
	chunked_memory(const std::string& name = {}, const address_range& address_range = {}, chunk_length chunk_length = 65536)
		: memory(name, address_range), _chunk_length(chunk_length) {}
	chunked_memory(const chunked_memory&) = delete;
	chunked_memory& operator=(const chunked_memory&) = delete;
	virtual void prepare();
	virtual void cleanup();
	virtual void get(address address, uint8_t& value);
	virtual void set(address address, uint8_t value);
	virtual void serialize(serializer::serializer& serializer);
	virtual void deserialize(serializer::serializer& serializer);
	virtual ~chunked_memory();
protected:
	chunk_index get_chunk_index(address address) const {
/*
 *  XMLParserTest.h
 *  MWorksCore
 *
 *  Created by bkennedy on 12/21/08.
 *  Copyright 2008 mit. All rights reserved.
 *
 */
BEGIN_NAMESPACE_MW
	class XMLParserTestFixture : public FullCoreEnvironmentTestFixture {
		
		
		CPPUNIT_TEST_SUITE( XMLParserTestFixture );
		CPPUNIT_TEST( testLoadBool_1 );
		CPPUNIT_TEST( testLoadBool_0 );
		CPPUNIT_TEST( testLoadBool_true );
		CPPUNIT_TEST( testLoadBool_false );
		CPPUNIT_TEST( testLoadBool_TRUE );
		CPPUNIT_TEST( testLoadBool_FALSE );
		CPPUNIT_TEST( testLoadBool_yes );
		CPPUNIT_TEST( testLoadBool_no );
		CPPUNIT_TEST( testLoadBool_YES );
		CPPUNIT_TEST( testLoadBool_NO );
		CPPUNIT_TEST( testLoadInt );
		CPPUNIT_TEST( testLoadIntNegative );
		CPPUNIT_TEST( testLoadIntExpression );
		CPPUNIT_TEST( testLoadIntSpaces );
		CPPUNIT_TEST( testLoadIntAttribute );
		CPPUNIT_TEST( testLoadIntAttributeClosingTag );
		CPPUNIT_TEST( testLoadFloat );
		CPPUNIT_TEST( testLoadString );
		CPPUNIT_TEST( testLoadStringAttribute );
		CPPUNIT_TEST( testL

		CPPUNIT_TEST( testLoadDictionary );
		CPPUNIT_TEST( testLoadDictionaryInDictionary );
		CPPUNIT_TEST( testLoadList );
		CPPUNIT_TEST( testLoadListWithinList );
		CPPUNIT_TEST( testLoadListInDictionary );
		CPPUNIT_TEST( testLoadDictionaryInList );
		CPPUNIT_TEST( testSaveThenLoadBool );
		CPPUNIT_TEST( testSaveThenLoadInteger );
		CPPUNIT_TEST( testSaveThenLoadFloat );
		CPPUNIT_TEST( testSaveThenLoadString );
		CPPUNIT_TEST( testSaveThenLoadDict );
		CPPUNIT_TEST( testSaveThenLoadList );
		CPPUNIT_TEST( testSaveThenLoadListInList );
		CPPUNIT_TEST( testSaveThenLoadDictInDict );
		CPPUNIT_TEST( testSaveThenLoadListInDict );
		CPPUNIT_TEST( testSaveThenLoadDictInList );
		CPPUNIT_TEST_SUITE_END();
	public:
		void setUp();
		void tearDown();
		
		void testLoadBool_1();
		void testLoadBool_0();
		void testLoadBool_true();
		void testLoadBool_false();
		void testLoadBool_TRUE();
		void testLoadBool_FALSE();
		void testLoadBool_yes();
		void testLoadBool_no();
		void testLoadBool_YES();


		void testLoadInt();
		void testLoadIntNegative();
		void testLoadIntExpression();
		void testLoadIntSpaces();
		void testLoadIntAttribute();
		void testLoadIntAttributeClosingTag();
		void testLoadFloat();
		void testLoadString();
		void testLoadStringAttribute();
		void testLoadStringSpaces();
		void testLoadDictionary();
		void testLoadDictionaryInDictionary();
		void testLoadList();
		void testLoadListWithinList();
		void testLoadListInDictionary();
		void testLoadDictionaryInList();
		
		void testSaveThenLoadBool();
		void testSaveThenLoadInteger();
		void testSaveThenLoadFloat();
		void testSaveThenLoadString();
		void testSaveThenLoadDict();
		void testSaveThenLoadList();
		void testSaveThenLoadListInList();
		void testSaveThenLoadDictInDict();
		void testSaveThenLoadListInDict();
		void testSaveThenLoadDictInList();
		
	private:
		boost::filesystem::path temp_xml_file_path;
		boost::shared_ptr<mw::GlobalVariable> testVar;
		
		void writeToFile(const std::string &text);
	};
EN
namespace mU {
namespace Z
	API void Set(Var,uint);
	API void Set(Var,sint);
	API void Set(Var,double);
	API void Set(Var,const char*,int);
	API void Set(Var,Var);
	API void SetQ(Var,Var);
	API void SetF(Var,Var);
	API void Abs(Var,Var);
	API void Neg(Var,Var);
	API void Com(Var,Var);
	API void And(Var,Var,Var);
	API void Ior(Var,Var,Var);
	API void Xor(Var,Var,Var);
	API void Add(Var,Var,Var);
	API void Add(Var,Var,uint);
	API void Sub(Var,Var,Var);
	API void Sub(Var,Var,uint);
	API void Sub(Var,uint,Var);
	API void Mul(Var,Var,Var);
	API void Mul(Var,Var,uint);
	API void Mul(Var,Var,int);
	API void Div(Var,Var,Var);
	API void Div(Var,Var,uint);
	API void Mod(Var,Var,Var);
	API uint Mod(Var,uint);
	API void Pow(Var,Var,uint);
	API void Pow(Var,uint,uint);
	API void Inv(Var,Var,Var);
	API int Cmp(Var,Var);
	API int Cmp(Var,uint);
	API int Cmp(Var,int);
	API int Cmp(Var,double);
	API int Sgn(Var);
	API uint UI(Var);
	API sint SI(Var);
	API double D(Var);
};
namespace Q
	API void Set(Var

	API void Set(Var,sint,uint);
	API void Set(Var,double);
	API void Set(Var,const char*,int);
	API void Set(Var,Var);
	API void SetZ(Var,Var);
	API void SetZ(Var,Var,Var);
	API void SetNum(Var,Var);
	API void SetDen(Var,Var);
	API void SetF(Var,Var);
	API void Num(Var,Var);
	API void Den(Var,Var);
	API void Canonicalize(Var);
	API void Abs(Var,Var);
	API void Neg(Var,Var);
	API void Add(Var,Var,Var);
	API void Sub(Var,Var,Var);
	API void Mul(Var,Var,Var);
	API void Div(Var,Var,Var);
	API int Cmp(Var,Var);
	API int Cmp(Var,uint,uint);
	API int Cmp(Var,int,uint);
	API int Sgn(Var);
	API double D(Var);
};
namespace F
	API void Set(Var,uint);
	API void Set(Var,sint);
	API void Set(Var,double);
	API void Set(Var,const char*,int);
	API void Set(Var,Var);
	API void SetZ(Var,Var);
	API void SetQ(Var,Var);
	API void Abs(Var,Var);
	API void Neg(Var,Var);
	API void Add(Var,Var,Var);
	API void Sub(Var,Var,Var);
	API void Mul(Var,Var,Var);
	API void Div(Var,Var,Var);
	API void Pow(Var,Var,uint);
	A
class ProductionApiRouter implements ApiRouter {
  public function __construct(
    private ApiInjector $apiInjector,
    private Logger $logger
  ) {}
  public function route(
    ApiType $type,
    UserAgent $user_agent,
    ImmMap<string, mixed> $raw_request_fields
  ): ApiResult {
    $this->logger->info("Routing api request", $type);
    $this->logger->info("Request payload", $raw_request_fields);
    $api = null;
    switch ($type) {
      case ApiType::CREATE_USER:
        $api = $this->apiInjector->getCreateUserApi();
        break;
      case ApiType::GET_USER:
        $api = $this->apiInjector->getGetUserByEmailApi();
        break;
      case ApiType::RESERVE_ORDER:
        $api = $this->apiInjector->getReserveOrderApi();
        break;
      case ApiType::CONFIRM_ORDER:
        $api = $this->apiInjector->getConfirmOrderApi();
        break;
      case ApiType::UPDATE_CONFIRMED_ORDER:
        $api = $this->apiInjector->getUpdateConfirmedOrderApi();
        break;
      case 

        $api = $this->apiInjector->getUpdateCellLabelApi(); 
        break;
      case ApiType::DELETE_CELL_LABEL:
        $api = $this->apiInjector->getDeleteCellLabelApi();
        break;
      case ApiType::DELETE_CONFIRMED_ORDER:
        $api = $this->apiInjector->getDeleteConfirmedOrderApi();
        break;
      case ApiType::DELETE_RESERVED_ORDER:
        $api = $this->apiInjector->getDeleteReservedOrderApi();
        break;
      case ApiType::GET_USERS_CONFIRMED_ORDERS:
        $api = $this->apiInjector->getGetUsersConfirmedOrdersApi();
        break;
      case ApiType::UPLOAD_BASIC_VIDEO:
        $api = $this->apiInjector->getUploadBasicVideoApi();
        break;
      case ApiType::UPLOAD_EDITED_VIDEO:
        $api = $this->apiInjector->getUploadEditedVideoApi();
        break;
      case ApiType::COMPLETE_ORDER:
        $api = $this->apiInjector->getCompleteOrderApi();
        break;
      case ApiType::GET_ALL_USERS:
        $api = $this->apiInjector->getGetAllUsersApi()

        break;
      case ApiType::GET_USERS_RSVD_ORDERS:
        $api = $this->apiInjector->getGetUsersReservedOrdersApi();
        break;
      case ApiType::GET_USERS_COMPLETED_ORDERS:
        $api = $this->apiInjector->getGetUsersCompletedOrdersApi();
        break;
      case ApiType::MARK_BASIC_VIDEO_DOWNLOADED:
        $api = $this->apiInjector->getMarkBasicVideoDownloadedApi();
        break;
      case ApiType::DELETE_BASIC_VIDEO:
        $api = $this->apiInjector->getDeleteBasicVideoApi();
        break;
      case ApiType::GET_SESSION_INFO:
        $api = $this->apiInjector->getGetSessionInfoApi();
        break;
      case ApiType::GET_ORDER_PRICE_POLICY:
        $api = $this->apiInjector->getGetOrderPricePolicyApi();
        break;
      case ApiType::GET_STARTUP_DATA:
        $api = $this->apiInjector->getGetStartupDataApi();
        break;
      default:
        throw new Exception("Unhandled api type!");
        break;
    }
    invariant($api !== null, "api can't be n
/*
 * zrtp.org is a ZRTP protocol implementation  
 * Copyright (C) 2010 - PrivateWave Italia S.p.A.
 *  
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License
 *  
 * For more information, please contact PrivateWave Italia S.p.A. at
 */
namespace ZORG
namespace Log
namespace Internals
static char * dumpChar(char c, char * dump)
    *dump ++ = c;
    return dump;
static char * dumpRawByte(unsigned char b, char * dump)
    char c;
    if(b < 32 || b >= 

	c = '.';
    else
	c = static_cast<char>(b);
    return dumpChar(c, dump);
static char * dumpHexNybble(unsigned char n, char * dump)
    char c;
    if(n < 10)
	c = '0' + n;
    else if(n < 16)
	c = 'A' + (n - 10);
    else
    {
	assert(false);
	c = '?';
    }
    return dumpChar(c, dump);
static char * dumpHexByte(unsigned char b, char * dump)
    dump = dumpHexNybble((b & 0xf0) >> 4, dump);
    dump = dumpHexNybble((b & 0x0f) >> 0, dump);
    return dump;
static char * dumpOffset(size_t off, char * dump)
    for(size_t shift = (sizeof(off) - 1) * CHAR_BIT, mask = 0xff << shift; mask != 0; mask >>= CHAR_BIT, shift -= CHAR_BIT)
	dump = dumpHexByte(static_cast<unsigned char>((off & mask) >> shift), dump);
    return dump;
const char * hexDump(const void * p, size_t n, char * dump)
    static const size_t BYTES_PER_LINE = 16;
    const unsigned char * pb = static_cast<const unsigned char *>(p);
    const char * ret = dump;
    for(size_t cb = n, o = 0; cb > 0; cb -= BYTES_PER_LINE, pb

    {
	if(o)
	    dump = dumpChar('\n', dump);
	size_t lineSize = std::min(cb, BYTES_PER_LINE);
	dump = dumpOffset(o, dump);
	dump = dumpChar(' ', dump);
	for(size_t i = 0; i < lineSize; ++ i)
	{
	    dump = dumpHexByte(pb[i], dump);
	    dump = dumpChar(' ', dump);
	}
	for(size_t i = lineSize; i < BYTES_PER_LINE; ++ i)
	{
	    dump = dumpChar(' ', dump);
	    dump = dumpChar(' ', dump);
	    dump = dumpChar(' ', dump);
	}
	for(size_t i = 0; i < lineSize; ++ i)
	    dump = dumpRawByte(pb[i], dump);
	if(lineSize < BYTES_PER_LINE)
	    break;
    }
    *dump ++ = 0;
    return ret;
const char * textDump(const void * p, size_t n, char * dump)
    const char * ret = dump;
    const unsigned char * pb = static_cast<const unsigned char *>(p);
    for(size_t i = 0; i < n; ++ i)
	dump = dumpRawByte(pb[i], dump);
    *dump ++ = 0;
    return ret;
const char * hexLineDump(const void * p, size_t n, char * dump)
    const char * ret = dump;
    const unsigned char * pb = static_cast<const unsigne
namespace xxbc {
MemoryPool::MemoryPool() : block_list_(NULL), free_chunk_list_(NULL) 
MemoryPool::~MemoryPool() 
    Block* block;
    while (block_list_) {
        block = block_list_;
        block_list_ = block_list_->next;
        free(block);
    }
void MemoryPool::MallocBlock() 
    Block* ptr = (Block*) malloc(sizeof(Block));
    assert(ptr != NULL);
    ptr->next = block_list_;
    block_list_ = ptr;
    Chunk* new_chunk = (Chunk*) ptr;
    int new_chunk_count = kBlockSize / kChunkSize;
    for (int i=0; i<new_chunk_count; ++i) {
        new_chunk->used_size = 0;
        new_chunk->free_size = kChunkSize - sizeof(Chunk);
        new_chunk->data = (char*) ptr + sizeof(Chunk);
        new_chunk->next = free_chunk_list_;
        free_chunk_list_ = new_chunk;
        new_chunk++;
    }
Chunk* MemoryPool::Malloc() 
    if (free_chunk_list_ == NULL) {
        MallocBlock();
    }
    Chunk* chunk = free_chunk_list_;
    free_chunk_list_ = free_chunk_list_->next;
    return chunk;
vo
/*
    _____               __  ___          __            ____        _      __
   / ___/__ ___ _  ___ /  |/  /__  ___  / /_____ __ __/ __/_______(_)__  / /_
                                               /___/             /_/
                                             
  See Copyright Notice in gmMachine.h
*/
gmMemChain::gmMemChain(unsigned int a_elementSize, unsigned int a_numElementsInChunk)
  m_chunkSize = a_numElementsInChunk * a_elementSize;
  m_elementSize = a_elementSize;
  m_rootChunk = NULL;
  m_currentChunk = NULL;
gmMemChain::~gmMemChain()
  FreeChunks();
void gmMemChain::FreeChunks()
  if(m_rootChunk)
  {
    MemChunk *curChunk;
    curChunk = m_rootChunk;
    while(curChunk)
    {
      MemChunk *chunkToFree;
      
      chunkToFree = curChunk;
      curChunk = curChunk->m_nextChunk;
      
      delete [] (char*)chunkToFree;
    }
  }
void gmMemChain::ResetAndFreeMemory()
  FreeChunks();
  m_rootChunk = NULL;
  m_currentChunk = NULL;
void gmMemChain::Presize(int a_kby

  int numChunks = ((a_kbytes + 1) * 1024) / m_chunkSize;
  MemChunk *curChunk;
  curChunk = m_rootChunk;
  while(curChunk)
  {
    --numChunks;
    curChunk = curChunk->m_nextChunk;
  }
  MemChunk * currentChunk = m_currentChunk;
  while(numChunks > 0)
  {
    NewChunk();
    --numChunks;
  }
  if(currentChunk)
  {
    m_currentChunk = currentChunk;
  }
gmMemChain::MemChunk* gmMemChain::NewChunk()
  MemChunk* newChunk;
  if(m_currentChunk && m_currentChunk->m_nextChunk)
  {
    newChunk = m_currentChunk->m_nextChunk;
    newChunk->m_curAddress = newChunk->m_minAddress;    
    m_currentChunk = newChunk;
  }
  {
    char * mem = (char *) GM_NEW( char[sizeof(MemChunk) + m_chunkSize] );
    newChunk = (MemChunk *) mem;
  
    newChunk->m_minAddress = mem + sizeof(MemChunk);
    newChunk->m_lastAddress = (void*)((gmuptr)newChunk->m_minAddress + m_chunkSize);
    newChunk->m_curAddress = newChunk->m_minAddress;
    newChunk->m_lastChunk = m_currentChunk;
    newChunk->m_nextChunk = NULL;
 

    {
      m_currentChunk->m_nextChunk = newChunk;
    }
    m_currentChunk = newChunk;
    if(!m_rootChunk)
    {
      m_rootChunk = m_currentChunk;
    }
  }
  return newChunk;
void* gmMemChain::Alloc()
  void *retPtr;
  
  if(!m_rootChunk)
  {
    NewChunk();
  }
  if(((gmuptr)m_currentChunk->m_curAddress + m_elementSize) > (gmuptr)m_currentChunk->m_lastAddress)
  {
    NewChunk();    
  }
  retPtr = m_currentChunk->m_curAddress;
  m_currentChunk->m_curAddress = (void*)((gmuptr)m_currentChunk->m_curAddress + m_elementSize);
  return retPtr;
void* gmMemChain::AllocBytes(unsigned int a_numBytes, unsigned int a_alignNumBytes)
  void *retPtr;
  
  if(!m_rootChunk)
  {
    NewChunk();
  }
  retPtr = _gmAlignMem(m_currentChunk->m_curAddress, a_alignNumBytes);
  if(((gmuptr)retPtr + a_numBytes) > (gmuptr)m_currentChunk->m_lastAddress)
  {
    NewChunk();    
    
    retPtr = _gmAlignMem(m_currentChunk->m_curAddress, a_alignNumBytes);
  }
  
  m_currentChunk->m_curAddress = (void*)((gmu
namespace noiseless
	std::istream& operator>>(std::istream& _stream, Vector2& _val)
	{
		_stream>>_val.x;
		_stream>>_val.y;
		return _stream;
	}
	std::ostream& operator<<(std::ostream& _stream, Vector2& _val)
	{
		_stream<<_val.x;
		_stream<<' ';
		_stream<<_val.y;
		_stream<<' ';
		return _stream;
	}
	std::istream& operator>>(std::istream& _stream, Vector3& _val)
	{
		_stream>>_val.x;
		_stream>>_val.y;
		_stream>>_val.z;
		return _stream;
	}
	std::ostream& operator<<(std::ostream& _stream, Vector3& _val)
	{
		_stream<<_val.x;
		_stream<<' ';
		_stream<<_val.y;
		_stream<<' ';
		_stream<<_val.z;
		_stream<<' ';
		return _stream;
	}
	std::istream& operator>>(std::istream& _stream, Vector4& _val)
	{
		_stream>>_val.x;
		_stream>>_val.y;
		_stream>>_val.z;
		_stream>>_val.w;
		return _stream;
	}
	std::ostream& operator<<(std::ostream& _stream, Vector4& _val)
	{
		_stream<<_val.x;
		_stream<<' ';
		_stream<<_val.y;
		_stream<<' ';
		_stream<<_val.z;
		_stream<<' ';
		_stream<<_val.w;
		_
/* --------------------------------------------------------------
	File:			AXMeshChunkEntity.cpp
	Description:	See AXMeshChunkEntity.h
	Date:			January 5, 2006
	Author:			James Long
-------------------------------------------------------------- */
AXMeshChunkEntity::AXMeshChunkEntity() : _MeshChunkInstance(NULL), _Shader(NULL), _ParentMeshEntity(NULL) {
AXMeshChunkEntity::~AXMeshChunkEntity() {
AXResult AXMeshChunkEntity::AssignEffect(unsigned int ID) {
	_EffectID = ID;
	_Shader = AXBaseSystem::GetResourceMgr()->GetShader(ID);
	if(!_Shader)
		return AXFAILURE;
	return AXSUCCESS;
void AXMeshChunkEntity::SelectShader() {
	if(_Shader) _Shader->Enter();
void AXMeshChunkEntity::PrepareShader() {
	if(_Shader) {
		_Shader->FillCache(_MeshChunkInstance);
		_Shader->SetParameters(this);
		_MeshChunkInstance->SetDataSources();
	}
void AXMeshChunkEntity::ReleaseShader() {
	if(_Shader) {
		_Shader->Exit();
	}
void AXMeshChunkEntity::Render() {
	if(_Shader) _MeshChunkInstance->Draw();
void AXMeshCh
namespace views {
TEST(ViewModelUtils, SetViewBoundsToIdealBounds) {
  View v1;
  ViewModel model;
  model.Add(&v1, 0);
  gfx::Rect v1_bounds(1, 2, 3, 4);
  model.set_ideal_bounds(0, v1_bounds);
  ViewModelUtils::SetViewBoundsToIdealBounds(model);
  EXPECT_EQ(v1_bounds, v1.bounds());
TEST(ViewModelUtils, DetermineMoveIndex) {
  View v1, v2, v3;
  ViewModel model;
  model.Add(&v1, 0);
  model.Add(&v2, 1);
  model.Add(&v3, 2);
  model.set_ideal_bounds(0, gfx::Rect(0, 0, 10, 10));
  model.set_ideal_bounds(1, gfx::Rect(10, 0, 1000, 10));
  model.set_ideal_bounds(2, gfx::Rect(1010, 0, 2, 10));
  EXPECT_EQ(0, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::HORIZONTAL, -10, 0));
  EXPECT_EQ(0, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::HORIZONTAL, 4, 0));
  EXPECT_EQ(1, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::HORIZONTAL, 506, 0));
  EXPECT_EQ(2, ViewModelUtils::DetermineMoveIndex(
    

  EXPECT_EQ(2, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::HORIZONTAL, 2000, 0));
  EXPECT_EQ(0, ViewModelUtils::DetermineMoveIndex(
                model, &v2, ViewModelUtils::HORIZONTAL, -10, 0));
  EXPECT_EQ(0, ViewModelUtils::DetermineMoveIndex(
                model, &v2, ViewModelUtils::HORIZONTAL, 4, 0));
  EXPECT_EQ(2, ViewModelUtils::DetermineMoveIndex(
                model, &v2, ViewModelUtils::HORIZONTAL, 12, 0));
  model.set_ideal_bounds(0, gfx::Rect(0, 0, 10, 10));
  model.set_ideal_bounds(1, gfx::Rect(0, 10, 10, 1000));
  model.set_ideal_bounds(2, gfx::Rect(0, 1010, 10, 2));
  EXPECT_EQ(0, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::VERTICAL, 0, -10));
  EXPECT_EQ(0, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::VERTICAL, 0, 4));
  EXPECT_EQ(1, ViewModelUtils::DetermineMoveIndex(
                model, &v1, ViewModelUtils::VERTICAL, 0, 506));
  EXPECT_EQ(2, ViewMode
namespace skia {
namespace {
const char kMallocBackingType[] = "malloc";
SkiaTraceMemoryDumpImpl::SkiaTraceMemoryDumpImpl(
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : SkiaTraceMemoryDumpImpl("", level_of_detail, process_memory_dump) {}
SkiaTraceMemoryDumpImpl::SkiaTraceMemoryDumpImpl(
    const std::string& dump_name_prefix,
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : dump_name_prefix_(dump_name_prefix),
      process_memory_dump_(process_memory_dump),
      request_level_(
          level_of_detail == base::trace_event::MemoryDumpLevelOfDetail::LIGHT
              ? SkTraceMemoryDump::kLight_LevelOfDetail
              : SkTraceMemoryDump::kObjectsBreakdowns_LevelOfDetail) {}
SkiaTraceMemoryDumpImpl::~SkiaTraceMemoryDumpImpl() {}
void SkiaTraceMemoryDumpImpl::dumpNumericValue(const char* dumpName,
            

                                               const char* units,
                                               uint64_t value) {
  auto* dump = process_memory_dump_->GetOrCreateAllocatorDump(dumpName);
  dump->AddScalar(valueName, units, value);
void SkiaTraceMemoryDumpImpl::setMemoryBacking(const char* dumpName,
                                               const char* backingType,
                                               const char* backingObjectId) {
  if (strcmp(backingType, kMallocBackingType) == 0) {
    auto* dump = process_memory_dump_->GetOrCreateAllocatorDump(dumpName);
    const char* system_allocator_name =
        base::trace_event::MemoryDumpManager::GetInstance()
            ->system_allocator_pool_name();
    if (system_allocator_name) {
      process_memory_dump_->AddSuballocation(dump->guid(),
                                             system_allocator_name);
    }
  } else {
    NOTREACHED();
  }
void SkiaTraceMemoryDumpImpl::setDiscardableMemoryBacking(

RenRenAPI::RenRenAPI()
    m_request = new Request;
    assert(m_request);
    m_adminAPI = new AdminAPI(m_request);
    assert(m_adminAPI);
    m_friendsAPI = new FriendsAPI(m_request);
    assert(m_friendsAPI);
    m_invitationsAPI = new InvitationsAPI(m_request);
    assert(m_invitationsAPI);
    m_notificationsAPI = new NotificationsAPI(m_request);
    assert(m_notificationsAPI);
    m_pagesAPI = new PagesAPI(m_request);
    assert(m_pagesAPI);
    m_payAPI = new PayAPI(m_request);
    assert(m_payAPI);
    m_photosAPI = new PhotosAPI(m_request);
    assert(m_photosAPI);
    m_statusAPI = new StatusAPI(m_request);
    assert(m_statusAPI);
    m_usersAPI = new UsersAPI(m_request);
    assert(m_usersAPI);
RenRenAPI::~RenRenAPI()
    delete m_adminAPI;
    delete m_friendsAPI;
    delete m_invitationsAPI;
    delete m_notificationsAPI;
    delete m_pagesAPI;
    delete m_payAPI;
    delete m_photosAPI;
    delete m_statusAPI;
    delete m_usersAPI;
    delete m_request;
    m_adminAPI
/*
 * chunk.c
 *  Created on: 2012-12-25
 *      Author: qianqians
 * chunk 
 */
struct chunk * _create_chunk(size_t size){
	size = (size + 4095)/4096*4096;
	struct chunk * _chunk = (struct chunk*)VirtualAlloc(0, size, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	_chunk->count.store(0);
	_chunk->size = size;
	_chunk->flag = _flag;
	_chunk->rec_count = 0;
	_chunk->slide = sizeof(struct chunk);
	return _chunk;
void * _brk(struct chunk * _chunk, size_t size){
	void * ret = 0;
	if ((_chunk->slide + size) <= _chunk->size){
		ret = (void*)((char*)_chunk + _chunk->slide);
		_chunk->slide += size;
	}
	return ret;
bool _isfree(struct chunk * _chunk){
	return (_chunk->count.load() == 0);
bool _isoldchunk(struct chunk * _chunk){
	return (_chunk->rec_count > 3);
void * _malloc(struct chunk * _chunk, size_t size){
	void * ret = 0;
	size_t newsize = sizeof(struct chunk*) + sizeof(size_t) + size;
	struct chunk ** tmp = (struct chunk **)_brk(_chunk, newsize);
	if (tmp != 0){
		*tmp = _chunk;
		size_t * _
/*
 * Load.cpp
 *	 Source file for the Load.h file
 *  Created on: Nov 25, 2014
 *      Author: kumaar6
 */
Load::Load(){
	ID 		= ID_NOT_INIT;
Load::Load(pin_t rpin, pin_t wpin, id_t ID, prio_t prio, load_t load){
	_rpin = rpin;
	_wpin = wpin;
	pinMode(_wpin, PIN_OUTPUT);
	Status 		= LOAD_INIT;
	this->ID 	= ID;
	this->PRIO 	= prio;
	DL	 		= load;
uint16_t Load::readLoad(void){
	return analogRead(_rpin);
status_t Load::writeLoad(uint8_t Logic){
	}
	digitalWrite(_wpin, State);
	return State;
status_t Load::setLoadStatus(uint8_t Logic){
	return State = Logic;
status_t Load::getLoadStatus(void){
	return State;
status_t Load::setLoadState(LoadState_t* state){
	/*
	 * This methods sets he load values as requested
	 */
	this->ID 		= state->ID;
	this->PRIO 		= state->PRIO;
	this->State 	= state->State;
	this->ASL 		= state->ASL;
	this->DCL	 	= state->DCL;
	return LOAD_INIT;
status_t Load::getLoadState(LoadState_t *Buf){
	Buf-> ID 		= this-> ID;
	return LOAD_INIT;
prio_t Load::getLoadPrio(void)
CVoxelChunk::CVoxelChunk() {
	chunkLocation.iX = 0;
	chunkLocation.iY = 0;
	chunkLocation.iZ = 0;
	voxelList = (unsigned char *)calloc(CHUNK_XSIZE*CHUNK_YSIZE*CHUNK_ZSIZE, sizeof(unsigned char));
CVoxelChunk::CVoxelChunk(int iX, int iY, int iZ) {
	chunkLocation.iX = iX;
	chunkLocation.iY = iY;
	chunkLocation.iZ = iZ;
	voxelList = (unsigned char *)calloc(CHUNK_XSIZE*CHUNK_YSIZE*CHUNK_ZSIZE, sizeof(unsigned char));
void CVoxelChunk::setChunkLocation(int iX, int iY, int iZ) {
	chunkLocation.iX = iX;
	chunkLocation.iY = iY;
	chunkLocation.iZ = iZ;
unsigned char CVoxelChunk::getVoxel(int iX, int iY, int iZ) {
	int index = iX + iY*CHUNK_XSIZE + iZ*CHUNK_XSIZE*CHUNK_YSIZE;
	if (index >= 0 && index < CHUNK_VOXELCOUNT) {
		return voxelList[index];
	}
	return 0;
unsigned char CVoxelChunk::getVoxel(SLocation voxelLocation) {
	int index = voxelLocation.iX + voxelLocation.iY*CHUNK_XSIZE + voxelLocation.iZ*CHUNK_XSIZE*CHUNK_YSIZE;
	if (index >= 0 && index < CHUNK_VOXELCOUNT) {
		return voxelList[ind
/*
 * Copyright (c) 2014 Juniper Networks, Inc. All rights reserved.
 */
extern "C" {
};
using OVSDB::PhysicalLocatorTable;
using OVSDB::PhysicalLocatorEntry;
PhysicalLocatorEntry::PhysicalLocatorEntry(PhysicalLocatorTable *table,
        const std::string &dip_str) : OvsdbEntry(table), dip_(dip_str),
    create_req_owner_(NULL) {
PhysicalLocatorEntry::~PhysicalLocatorEntry() {
    assert(create_req_owner_ == NULL);
bool PhysicalLocatorEntry::IsLess(const KSyncEntry &entry) const {
    const PhysicalLocatorEntry &pl_entry =
        static_cast<const PhysicalLocatorEntry&>(entry);
    return (dip_ < pl_entry.dip_);
KSyncEntry *PhysicalLocatorEntry::UnresolvedReference() {
    return NULL;
bool PhysicalLocatorEntry::AcquireCreateRequest(KSyncEntry *creator) {
    if (create_req_owner_ == NULL) {
        create_req_owner_ = creator;
        return true;
    }
    return false;
void PhysicalLocatorEntry::ReleaseCreateRequest(KSyncEntry *creator) {
    assert(create_req_owner_ == creator);


        table_->BackRefReEval(this);
    }
    create_req_owner_ = NULL;
PhysicalLocatorTable::PhysicalLocatorTable(OvsdbClientIdl *idl) :
    OvsdbObject(idl) {
    idl->Register(OvsdbClientIdl::OVSDB_PHYSICAL_LOCATOR,
                  boost::bind(&PhysicalLocatorTable::OvsdbNotify, this, _1, _2));
PhysicalLocatorTable::~PhysicalLocatorTable() {
void PhysicalLocatorTable::OvsdbNotify(OvsdbClientIdl::Op op,
        struct ovsdb_idl_row *row) {
    const char *dip_str = ovsdb_wrapper_physical_locator_dst_ip(row);
    PhysicalLocatorEntry key(this, dip_str);
    PhysicalLocatorEntry *entry =
        static_cast<PhysicalLocatorEntry *>(Find(&key));
    if (op == OvsdbClientIdl::OVSDB_DEL) {
        if (entry != NULL && entry->IsActive()) {
            OVSDB_TRACE(Trace, "Delete received for Physical Locator " +
                    entry->dip_);
            Delete(entry);
        }
    } else if (op == OvsdbClientIdl::OVSDB_ADD) {
        if (entry == NULL) {
            entry = static_c
typedef struct
    int id;
    int dataOffset;
    int len;
    int rate;
} Sample;
typedef struct
    LList* samples;
    unsigned char* data;
    int offset;
    int len;
    int id;
} SampleBank;
SampleBank* SampleBank_create(VGMCommand* command);
void SampleBank_addBlock(SampleBank* bank, VGMCommand* command);
VGMCommand* SampleBank_getDataBlockCommand(SampleBank* bank);
LList* SampleBank_getDeclarationCommands(SampleBank* bank);
Sample* SampleBank_getSampleByOffset(SampleBank* bank, int dataOffset);
Sample* SampleBank_getSampleById(SampleBank* bank, int id);
Sample* SampleBank_addSample(SampleBank* bank, int dataOffset, int len, int rate);
int Sample_getFrameSize(Sample* sample);
Sample* Sample_create(int id, int dataOffset, int len, int rate);
void Sample_setRate(Sample* sample, int value);
VGMCommand* Sample_getSetRateCommand(SampleBank* bank, Sample* sample, int value);
VGMCommand* Sample_getStartLongCommandEx(SampleBank* bank, Sample* sample, int value);
VGMCommand* Sample_get
using std::vector;
using std::priority_queue;
using Poco::FastMutex;
using Poco::Logger;
namespace CoolDown{
    namespace Client{
        class LocalSockManager;
        enum ChunkStatus{
            FREE = 1,
            DOWNLOADING = 2,
            FINISHED = 3,
            FAILED = 4,
            NOOWNER = 5,
        };
        struct ChunkInfo{
            ChunkInfo()
            :status(FREE), priority(0), chunk_num(0){
            }
            ChunkStatus status;
            string fileid;
            int priority;
            int chunk_num;
            vector<FileOwnerInfoPtr> clientLists;
        };
        typedef SharedPtr<ChunkInfo> ChunkInfoPtr;
        
        struct chunk_cmp{
            bool operator()(const ChunkInfoPtr& left, const ChunkInfoPtr& right){
                return left->priority < right->priority;
            }
        };
        class ChunkSelector{
            public:
                ChunkSelector(JobInfo& info, LocalSockManager& sockManager);
       
collisionscorekeeper::collisionscorekeeper(b2ContactListener *listener) : listener(listener) {}
void collisionscorekeeper::BeginContact(b2Contact *contact) {
  if (listener) {
    listener->BeginContact(contact);
  }
  b2Body *bodyA = contact->GetFixtureA()->GetBody();
  b2Body *bodyB = contact->GetFixtureB()->GetBody();
  void *bodyUserData = contact->GetFixtureA()->GetBody()->GetUserData();
  if ( bodyUserData ) {
    Model *model = static_cast<Model*>( bodyUserData );
    if(((bodyA == model->player1_bottom || bodyA == model->player1_top) && (bodyB == model->ball)) ||
       ((bodyB == model->player1_bottom || bodyB == model->player1_top) && (bodyA == model->ball))) {
      if (model->player1_top->IsActive()) {
        model->IncrementPlayerOneCount();
      }
    } else if(((bodyA == model->player2_bottom || bodyA == model->player2_top) && (bodyB == model->ball)) ||
              ((bodyB == model->player2_bottom || bodyB == model->player2_top) && (bodyA == model->ball))) {
      if
/*-----------------------------------------------------------------------
 * File: BioAPI_API.H
 *
 *-----------------------------------------------------------------------
 */
/* API Functions */
extern "C" {
/*************************************************************************/
/*** BioAPI Core Functions ***********************************************/
/*************************************************************************/
BioAPI_RETURN BioAPI BioAPI_Init(
						const BioAPI_VERSION *Version,
						uint32 Reserved1,
						const void *Reserved2,
						uint32 Reserved3,
						const void *Reserved4 );
BioAPI_RETURN BioAPI BioAPI_Terminate(
						void );
BioAPI_RETURN BioAPI BioAPI_ModuleLoad(
						const BioAPI_UUID *ModuleGuid,
						uint32 Reserved,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
BioAPI_RETURN BioAPI BioAPI_ModuleUnload(
						const BioAPI_UUID *ModuleGuid,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *A

BioAPI_RETURN BioAPI BioAPI_ModuleAttach(
						const BioAPI_UUID *ModuleGuid,
						const BioAPI_VERSION *Version,
						const BioAPI_MEMORY_FUNCS *MemoryFuncs,
						uint32 DeviceID,
						uint32 Reserved1,
						uint32 Reserved2,
						uint32 Reserved3,
						BioAPI_FUNC_NAME_ADDR *FunctionTable,
						uint32 NumFunctionTable,
						const void *Reserved4,
						BioAPI_HANDLE_PTR NewModuleHandle );
BioAPI_RETURN BioAPI BioAPI_ModuleDetach(
						BioAPI_HANDLE ModuleHandle );
BioAPI_RETURN BioAPI BioAPI_QueryDevice(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_SERVICE_UID_PTR ServiceUID );
/*************************************************************************/
/*** BioAPI Service Functions ********************************************/
/*************************************************************************/
BioAPI_RETURN BioAPI BioAPI_FreeBIRHandle(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle );
BioAPI_RETURN BioAPI BioAPI_GetBIRFromHandle(
						BioAP

						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_PTR *BIR );
BioAPI_RETURN BioAPI BioAPI_GetHeaderFromHandle(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_HEADER_PTR Header );
BioAPI_RETURN BioAPI BioAPI_EnableEvents(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_MODULE_EVENT_MASK *Events );
BioAPI_RETURN BioAPI BioAPI_SetGUICallbacks(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_GUI_STREAMING_CALLBACK GuiStreamingCallback,
						void *GuiStreamingCallbackCtx,
						BioAPI_GUI_STATE_CALLBACK GuiStateCallback,
						void *GuiStateCallbackCtx );
BioAPI_RETURN BioAPI BioAPI_SetStreamCallback(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_STREAM_CALLBACK StreamCallback,
						void *StreamCallbackCtx );
BioAPI_RETURN BioAPI BioAPI_StreamInputOutput(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DATA_PTR InMessage,
						BioAPI_DATA_PTR OutMessage );
BioAPI_RETURN BioAPI BioAPI_Capture(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPO

						BioAPI_BIR_HANDLE_PTR CapturedBIR,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_CreateTemplate(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload );
BioAPI_RETURN BioAPI BioAPI_Process(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						BioAPI_BIR_HANDLE_PTR ProcessedBIR );
BioAPI_RETURN BioAPI BioAPI_VerifyMatch(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE *AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload );
BioAPI_RETURN BioAPI BioAPI_IdentifyMatc

						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout );
BioAPI_RETURN BioAPI BioAPI_Enroll(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpose,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_Verify(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR AdaptedBIR,
						BioAPI_BOOL *R

						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_Identify(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
BioAPI_RETURN BioAPI BioAPI_Import(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_DATA *InputData,
						BioAPI_BIR_BIOMETRIC_DATA_FORMAT InputFormat,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR ConstructedBIR );
BioAPI_RETURN BioAPI BioAPI_SetPowerMode(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_POWER_MODE PowerMode );
BioAPI_RETURN BioAPI BioAPI_DbOpen(
			

						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
BioAPI_RETURN BioAPI BioAPI_DbClose(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle );
BioAPI_RETURN BioAPI BioAPI_DbCreate(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle );
BioAPI_RETURN BioAPI BioAPI_DbDelete(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName );
BioAPI_RETURN BioAPI BioAPI_DbSetCursor(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_DB_CURSOR_PTR Cursor );
BioAPI_RETURN BioAPI BioAPI_DbFreeCursor(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
BioAPI_RETURN BioAPI BioAPI_DbStoreBIR(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *BIRToStore,
						BioAPI_DB_HANDLE DbHandle,
						BioAPI_UUID_PTR Uui
/*
 * Copyright 2011, Haiku Inc. All rights reserved.
 * This file may be used under the terms of the MIT License.
 *
 * Authors:
 *		JÃ©rÃ´me Duval
 */
Chunk::Chunk(struct btrfs_chunk* chunk, fsblock_t offset)
	:
	fChunk(NULL),
	fInitStatus(B_OK)
	fChunkOffset = offset;
	fChunk = (struct btrfs_chunk*)malloc(sizeof(struct btrfs_chunk)
		+ chunk->StripeCount() * sizeof(struct btrfs_stripe));
	if (fChunk == NULL)
		fInitStatus = B_NO_MEMORY;
	memcpy(fChunk, chunk, sizeof(struct btrfs_chunk)
		+ chunk->StripeCount() * sizeof(struct btrfs_stripe));
	TRACE("chunk[0] length %" B_PRIu64 " owner %" B_PRIu64 " stripe_length %"
		B_PRIu64 " type %" B_PRIu64 " stripe_count %u sub_stripes %u "
		"sector_size %" B_PRIu32 "\n", chunk->Length(), chunk->Owner(), 
		chunk->StripeLength(), chunk->Type(), chunk->StripeCount(), 
		chunk->SubStripes(), chunk->SectorSize());
	for(int32 i = 0; i < chunk->StripeCount(); i++) {
		TRACE("chunk.stripe[%" B_PRId32 "].physical %" B_PRId64 " deviceid %"
			B_PRId64 "
using namespace msg;
BasicMessage::~BasicMessage()
void LogMessage::Handle(MessageHandler& handler)
	handler.HandleLogMessage(*this);
void DebugMessage::Handle(MessageHandler& handler)
	handler.HandleDebugMessage(*this);
void InternalCommand::Handle(MessageHandler& handler)
	handler.HandleInternalCommand(*this);
void HeartBeat::Handle(MessageHandler& handler)
	handler.HandleHeartBeat(*this);
void ThreadDie::Handle(MessageHandler& handler) 
	handler.HandleThreadDie(*this);
void ThreadDead::Handle(MessageHandler& handler) 
	handler.HandleThreadDead(*this);
void GroupProgress::Handle(MessageHandler& handler) 
	handler.HandleGroupProgressReport(*this);
void ChannelProgress::Handle(MessageHandler& handler) 
	handler.HandleChannelProgressReport(*this);
void RequestProgress::Handle(MessageHandler& handler) 
	handler.HandleRequestProgress(*this);
void TogglePause::Handle(MessageHandler& handler)
	handler.HandleTogglePause(*this);
void AutoPaused::Handle(MessageHandler& handler) 
	handler.Handl
template <unsigned int N, typename T>
struct Sample {
  
    explicit Sample(const Interval<T> &interval, T x[] = nullptr, T y[] = nullptr);
    explicit Sample(const Interval<T> &interval, const std::function<Point<T>(unsigned int, Interval<T>)> &lambda);
    
    Sample(const Sample<N,T> &other);
    
    template <unsigned int P, unsigned int Q>
    explicit Sample(const Sample<P,T> &a, const Sample<Q,T> &b);
    virtual ~Sample();
    Interval<T> interval;
    Point<T> data[N];
    void operator+=(const Sample<N,T> &b);
    void operator+=(T b);
    
    void operator*=(const Sample<N,T> &b);
    void operator*=(T b);
    Point<T> operator[](unsigned int k);
    void plotPoints(Gnuplot &gp, const PlotBox<T> &box, unsigned int maxNumber = 0) const;
    void plotLine(Gnuplot &gp, const PlotBox<T> &box) const;
    T norm2() const;
    T norm() const;
    T normInf() const;
};
    
template <unsigned int N, typename T>
Sample<N,T>::Sample(const Interval<T> &interval, const std::functio

    interval(interval)
        for (unsigned int i = 0; i < N; i++) {
            Point<T> sample = lambda(i, interval);
            this->data[i] = sample;
        }
template <unsigned int N, typename T>
Sample<N,T>::Sample(const Interval<T> &interval, T _x[], T _y[]) :
    interval(interval) {
        for (unsigned int i = 0; i < N; i++) {
            this->data[i].x = (_x == nullptr ? T(0) : _x[i]);
            this->data[i].y = (_y == nullptr ? T(0) : _y[i]);
        }
template <unsigned int N, typename T>
Sample<N,T>::Sample(const Sample<N,T> &other) :
    interval(other.interval) {
template <unsigned int N, typename T>
template <unsigned int P, unsigned int Q>
Sample<N,T>::Sample(const Sample<P,T> &a, const Sample<Q,T> &b) {
    
    assert(P+Q == N);
    T inf = std::min(a.interval().inf, b.interval().inf);
    T sup = std::max(a.interval().max, b.interval().max);
    Sample<N,T> sample(Interval<T>(inf, sup));
    for (unsigned int i = 0; i < P; i++) {
        sample[i] = a[i];

    }
    for (unsigned int i = 0; i < Q; i++) {
        sample[P+i] = b[i];
    }
    
template <unsigned int N, typename T>
Sample<N,T>::~Sample() {
template <unsigned int N, typename T>
void Sample<N,T>::operator+=(const Sample<N,T> &b) {
    for(unsigned int i = 0; i < N; i++) {
        data[i].y += b.data[i].y;
    }
template <unsigned int N, typename T>
void Sample<N,T>::operator+=(T b) {
    for(unsigned int i = 0; i < N; i++) {
        data[i].y += b;
    }
template <unsigned int N, typename T>
void Sample<N,T>::operator*=(const Sample<N,T> &b) {
    for(unsigned int i = 0; i < N; i++) {
        data[i].y *= b.data[i].y;
    }
template <unsigned int N, typename T>
void Sample<N,T>::operator*=(T b) {
    for(unsigned int i = 0; i < N; i++) {
        data[i].y *= b;
    }
template <unsigned int N, typename T>
Sample<N,T> operator+(const Sample<N,T>&a, const Sample<N,T> &b) {
    Sample<N,T> sample(a);
    for(unsigned int i = 0; i < N; i++) {
        sample.data[i].x = a.data[i]

        sample.data[i].y = a.data[i].y + b.data[i].y;
    }
    return sample;
template <unsigned int N, typename T>
Sample<N,T> operator-(const Sample<N,T>&a, const Sample<N,T> &b) {
    Sample<N,T> sample(a);
    for(unsigned int i = 0; i < N; i++) {
        sample.data[i].x = a.data[i].x;
        sample.data[i].y = a.data[i].y - b.data[i].y;
    }
    return sample;
template <unsigned int N, typename T>
Sample<N,T> operator*(const Sample<N,T>&a, const Sample<N,T> &b) {
    Sample<N,T> sample(a);
    for(unsigned int i = 0; i < N; i++) {
        sample.data[i].x = a.data[i].x;
        sample.data[i].y = a.data[i].y * b.data[i].y;
    }
    return sample;
template <unsigned int N, typename T>
Sample<N,T> operator*(T a, const Sample<N,T> &b) {
    Sample<N,T> sample(a);
    for(unsigned int i = 0; i < N; i++) {
        sample.data[i].x = a.data[i].x;
        sample.data[i].y = a * b.data[i].y;
    }
    return sample;
template <unsigned int N, typename T>
Sample<N,T> operator*(const S

    Sample<N,T> sample(a);
    for(unsigned int i = 0; i < N; i++) {
        sample.data[i].x = a.data[i].x;
        sample.data[i].y = a.data[i].y * b;
    }
    return sample;
    
template <unsigned int N, typename T>
Point<T> Sample<N,T>::operator[](unsigned int k) {
    assert(k < N);
    return Point<T>(this->data[k]);
template <unsigned int N, typename T>
void Sample<N,T>::plotLine(Gnuplot &gp, const PlotBox<T> &box ) const {
    std::vector<std::tuple<float, float>> pts;
    Point<T> Xmin, Xmax;
    for (unsigned int i = 0; i < N; i++) {
        Point<T> X = this->data[i];
        Xmin.x = (X.x < Xmin.x ? X.x : Xmin.x);
        Xmin.y = (X.y < Xmin.y ? X.y : Xmin.y);
        Xmax.x = (X.x > Xmax.x ? X.x : Xmax.x);
        Xmax.y = (X.y > Xmax.y ? X.y : Xmax.y);
        pts.push_back(std::make_tuple(X.x,X.y));
    }
    std::sort(pts.begin(), pts.end());
    gp << box;
    gp << "set style line 1 lt rgb 'red' lw 1 pt 7\n";
    gp << "plot '-' with lines ls 1 notitle\n";
    gp.

template <unsigned int N, typename T>
void Sample<N,T>::plotPoints(Gnuplot &gp, const PlotBox<T> &box, unsigned int maxNumber) const {
    std::vector<std::tuple<float, float>> pts;
    unsigned int maxPts;
    if(maxNumber == 0)
        maxPts = N;
    else 
        maxPts = std::min(N, maxNumber);
    for (unsigned int i = 0; i < maxPts; i++) {
        Point<T> X = this->data[i];
        pts.push_back(std::make_tuple(X.x,X.y));
    }
    gp << box;
    gp << "plot '-' with points ls 1 notitle\n";
    gp.send1d(pts);
template <unsigned int N, typename T>
T Sample<N,T>::norm2() const {
    T norm2 = T(0);
    for (unsigned int i = 0; i < N; i++) {
        norm2 += this->data[i].y*this->data[i].y;
    }
    return norm2;
template <unsigned int N, typename T>
T Sample<N,T>::norm() const {
    return std::pow<T>(this->norm2(), 0.5);
template <unsigned int N, typename T>
T Sample<N,T>::normInf() const {
    T normInf = T(0);
    for (unsigned int i = 0; i < N; i++) {
        T val = std::
namespace EffekseerRendererDX9
ModelLoader::ModelLoader( Renderer* renderer, ::Effekseer::FileInterface* fileInterface )
	: m_renderer		( renderer )
	, m_fileInterface	( fileInterface )
	if( m_fileInterface == NULL )
	{
		m_fileInterface = &m_defaultFileInterface;
	}
ModelLoader::~ModelLoader()
void* ModelLoader::Load( const EFK_CHAR* path )
	std::auto_ptr<::Effekseer::FileReader> 
		reader( m_fileInterface->OpenRead( path ) );
	if( reader.get() == NULL ) return false;
	if( reader.get() != NULL )
	{
		HRESULT hr;
		size_t size_model = reader->GetLength();
		uint8_t* data_model = new uint8_t[size_model];
		reader->Read( data_model, size_model );
		Model* model = new Model( data_model, size_model );
		model->ModelCount = Effekseer::Min( Effekseer::Max( model->GetModelCount(), 1 ), 40);
		model->VertexCount = model->GetVertexCount();
		IDirect3DVertexBuffer9* vb = NULL;
		hr = m_renderer->GetDevice()->CreateVertexBuffer(
			sizeof(Effekseer::Model::VertexWithIndex) * model->VertexCount * 

			D3DUSAGE_WRITEONLY,
			0,
			D3DPOOL_MANAGED,
			&vb,
			NULL );
		if( FAILED( hr ) )
		{
			/* DirectX9ExâÃâÃD3DPOOL_MANAGEDÅ½gâpâ¢sâ°Ã */
			hr = m_renderer->GetDevice()->CreateVertexBuffer(
				sizeof(Effekseer::Model::VertexWithIndex) * model->VertexCount * model->ModelCount,
				D3DUSAGE_WRITEONLY,
				0,
				D3DPOOL_DEFAULT,
				&vb,
				NULL );
		}
		if( vb != NULL )
		{
			uint8_t* resource = NULL;
			vb->Lock( 0, 0, (void**)&resource, 0 );
			for(int32_t m = 0; m < model->ModelCount; m++ )
			{
				for( int32_t i = 0; i < model->GetVertexCount(); i++ )
				{
					Effekseer::Model::VertexWithIndex v;
					v.Position = model->GetVertexes()[i].Position;
					v.Normal = model->GetVertexes()[i].Normal;
					v.Binormal = model->GetVertexes()[i].Binormal;
					v.Tangent = model->GetVertexes()[i].Tangent;
					v.UV = model->GetVertexes()[i].UV;
					v.Index[0] = m;
					memcpy( resource, &v, sizeof(Effekseer::Model::VertexWithIndex) );
					resource += sizeof(Effekseer::Model::Vertex

				}
			}
			vb->Unlock();
		}
		model->VertexBuffer = vb;
		model->FaceCount = model->GetFaceCount();
		model->IndexCount = model->FaceCount * 3;
		IDirect3DIndexBuffer9* ib = NULL;
		hr = m_renderer->GetDevice()->CreateIndexBuffer( 
			sizeof(Effekseer::Model::Face) * model->FaceCount * model->ModelCount,
			D3DUSAGE_WRITEONLY, 
			D3DFMT_INDEX32, 
			D3DPOOL_MANAGED, 
			&ib, 
			NULL );
		if( FAILED( hr ) )
		{
			hr = m_renderer->GetDevice()->CreateIndexBuffer( 
				sizeof(Effekseer::Model::Face) * model->FaceCount * model->ModelCount,
				D3DUSAGE_WRITEONLY, 
				D3DFMT_INDEX32, 
				D3DPOOL_DEFAULT, 
				&ib, 
				NULL );
		}
		if( ib != NULL )
		{
			uint8_t* resource = NULL;
			ib->Lock( 0, 0, (void**)&resource, 0 );
			for(int32_t m = 0; m < model->ModelCount; m++ )
			{
				for( int32_t i = 0; i < model->FaceCount; i++ )
				{
					Effekseer::Model::Face f;
					f.Indexes[0] = model->GetFaces()[i].Indexes[0] + model->GetVertexCount() * m;
					f.Indexes[1] = model->GetFace
struct Frame
	int Texture;
	int CentreX;
	int CentreY;
	int UVCoords[4][2];
	int OldTexNum;
};
class Sprite_Header_Chunk : public Chunk_With_Children
public:
	Sprite_Header_Chunk(Chunk_With_Children* const parent,const char*,size_t const);
	Sprite_Header_Chunk(const char* file_name, Chunk_With_Children * parent = NULL);
	Sprite_Header_Chunk()
	: Chunk_With_Children(0,"SPRIHEAD"){}
	Sprite_Header_Chunk(Chunk_With_Children* parent)
	: Chunk_With_Children(parent,"SPRIHEAD"){}
										 
	write_file(const char* fname);
	virtual BOOL output_chunk(HANDLE &hand);
	virtual void post_input_processing();
		
};
class PC_Sprite_Chunk : public Chunk_With_Children
public:
	PC_Sprite_Chunk(Sprite_Header_Chunk* parent,const char*,size_t);
	PC_Sprite_Chunk(Sprite_Header_Chunk* parent)
	: Chunk_With_Children(parent,"SPRITEPC"){}
};
class Saturn_Sprite_Chunk : public Chunk_With_Children
public:
	Saturn_Sprite_Chunk(Sprite_Header_Chunk* parent,const char*,size_t);
	Saturn_Sprite_Chunk(Sprite_Header_Chunk

	: Chunk_With_Children(parent,"SPRITESA"){}
};
class Playstation_Sprite_Chunk : public Chunk_With_Children
public:
	Playstation_Sprite_Chunk(Sprite_Header_Chunk* parent,const char*,size_t);
	Playstation_Sprite_Chunk(Sprite_Header_Chunk* parent)
	: Chunk_With_Children(parent,"SPRITEPS"){}
};
class Sprite_Action_Chunk  : public Chunk
public:
	Sprite_Action_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Action_Chunk(Chunk_With_Children* parent);
	~Sprite_Action_Chunk(); 
	virtual BOOL output_chunk (HANDLE &hand);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	int Action;
	int NumYaw;
	int NumPitch;
	int NumFrames;
	Frame*** FrameList;
	int Flags;
	int FrameTime;
	 
};
class Sprite_Size_Chunk  : public Chunk
public:
	Sprite_Size_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Size_Chunk(Chunk_With_Children* parent);
	virtual BOOL output_chunk (HANDLE &hand);
	virtual size_t size_chunk();
	virtual void fill_data_block(

public:
	double scale;
	double maxy; 
	double maxx;
	int radius;
	int Flags ;
};
class Sprite_Extent_Chunk  : public Chunk
public:
	Sprite_Extent_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Extent_Chunk(Chunk_With_Children* parent);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	double minx;
	double maxx; 
	double miny;
	double maxy;
	int spare1,spare2;
};
class Sprite_Version_Number_Chunk  : public Chunk
public:
	Sprite_Version_Number_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Version_Number_Chunk(Chunk_With_Children* parent);
	virtual BOOL output_chunk (HANDLE &hand);
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
public:
	int version_num;
};
class Sprite_Bitmap_Scale_Chunk : public Chunk
public :
	Sprite_Bitmap_Scale_Chunk(Chunk_With_Children* parent,const char*,size_t);
	Sprite_Bitmap_Scale_Chunk(Chunk_With_Children* parent);
	~Sprite_Bitmap_Scale_Chunk();
	virtual size_
ACE_INLINE
TAO::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",5);
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find",5);
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      return 0;
    }
  return value._retn();
ACE_INLINE size_t
TAO::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",5);
  return this->map_.current_size();
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",5);
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      value = new RepoIdSet();
      if (this->map_.bind(key, value) != 0)
        {
           ACE_ERROR((LM_ERROR,
                      "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                      "the RepoIdSetMap.\n"));
           return 0;
        }
    }
  return value._retn();
ACE_INLINE TAO::DCPS::Repo
World::World(Server* server, const int seed, QObject *parent) : QObject(parent), m_server(server), i_seed(seed)
	m_physicEngine = new PhysicEngine(this, this);
	m_chunks = new QHash<ChunkPosition, Chunk*>();
	m_voidChunk = new Chunk(this, ChunkPosition(999999,999999));
World::~World()
	QHashIterator<ChunkPosition, Chunk*> it(*m_chunks);
	while (it.hasNext()) {
		it.next();
	}
	delete m_chunks;
	delete m_voidChunk;
	delete m_physicEngine;
const PhysicObject* World::po(const int id) const
	return m_physicEngine->po(id);
Chunk* World::chunk(const ChunkPosition& position) const
	{
		return m_chunks->value(position);
	}
	{
		return m_voidChunk;
	}
Chunk* World::chunk(const BlockPosition& position) const
	return chunk(chunkPosition(position.x, position.z));
ChunkPosition World::chunkPosition(const int x, const int z) const
	int cx, cz;
	if(x < 0) {
		cx = x / CHUNK_X_SIZE - 1;
	}
	else {
		cx = x / CHUNK_X_SIZE;
	}
	if(z < 0) {
		cz = z / CHUNK_Z_SIZE - 1;
	}
	else {
		cz = z / CHUNK_Z_SIZE;

	}
	return ChunkPosition(cx, cz);
ChunkPosition World::chunkPosition(const BlockPosition& position) const
	return chunkPosition(position.x, position.z);
bool World::isChunkLoaded(const ChunkPosition& position) const
	return m_chunks->contains(position);
void World::loadChunk(const ChunkPosition& position)
	{
		return;
	}
	{
		Chunk* newChunk = new Chunk(this, position);
		ChunkGenerator* chunkGenerator = new ChunkGenerator(newChunk, i_seed);
		connect(chunkGenerator, SIGNAL(finished()), newChunk, SLOT(activate()));
		connect(chunkGenerator, SIGNAL(finished()), chunkGenerator, SLOT(deleteLater()));
		chunkGenerator->start();
		m_chunks->insert(position, newChunk);
	}
void World::unloadChunk(Chunk* chunk)
	unloadChunk(m_chunks->key(chunk));
void World::unloadChunk(const ChunkPosition& position)
	delete m_chunks->value(position);
	m_chunks->remove(position);
BlockInfo* World::block(const BlockPosition& bp) const
	ChunkPosition chunkPos = chunkPosition(bp);
	if(bp.x < 0) {
		chunkBlockX =

	}
		chunkBlockX = bp.x % CHUNK_X_SIZE;
	}
	if(bp.z < 0) {
		chunkBlockZ = bp.z - chunkPos.second * CHUNK_Z_SIZE;
	}
	else {
		chunkBlockZ = bp.z % CHUNK_Z_SIZE;
	}
	if(isChunkLoaded(chunkPos)) {
		return chunk(chunkPos)->block(chunkBlockX, bp.y, chunkBlockZ);
	}
	else {
		return BlockInfo::voidBlock();
	}
BlockInfo* World::block(const Vector& position)
	return this->block(bp);
int World::altitude(const int x, const int z)
	ChunkPosition chunkPos = chunkPosition(x, z);
	if(x < 0) {
		chunkBlockX = x - chunkPos.first * CHUNK_X_SIZE;
	}
		chunkBlockX = x % CHUNK_X_SIZE;
	}
	if(z < 0) {
		chunkBlockZ = z - chunkPos.second * CHUNK_Z_SIZE;
	}
	else {
		chunkBlockZ = z % CHUNK_Z_SIZE;
	}
	return chunk(chunkPos)->altitude(chunkBlockX, chunkBlockZ);
BlockPosition World::highestBlock(const Vector& position)
	BlockPosition blockPosition = position.toBlock();
	blockPosition.y = altitude(blockPosition.x, blockPosition.z);
	return blockPosition;
void World::render3D()
	QHash<ChunkPosition, Chunk*>
/*
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
made by ALACN
alacn@bol.com.br
uhahaa@msn.com
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*/
DWORD _3dsCalcChunkSize(CHUNK *root)
	DWORD dwSize = sizeof(CHUNK_HDR);
	if(root->data) dwSize += root->data_size;
	CHUNK *chunk = root->Child;
	if(chunk) do
	{
		dwSize += _3dsCalcChunkSize(chunk);
		chunk = chunk->Next;
	}
	while(chunk != root->Child);
	root->hdr.length = dwSize;
	return dwSize;
void _3dsDestroyChunk(CHUNK *root)
	if(root->data)
	{
		free(root->data);
		root->data = 0;
	}
	while(root->Child)
	{
		CHUNK *child = root->Child;
		UNLINK(root->Child, child);
		_3dsDestroyChunk(child);
		delete child;
	}
bool _3dsWriteChunk(HANDLE h, CHUNK *root)
	DWORD dwW;
	dwW = 0;
	WriteFile(h, &root->hdr, sizeof(CHUNK_HDR), &dwW, 0);
	if(dwW != sizeof(CHUNK_HDR)) return false;
	dwW = 0;
	WriteFile(h, root->data, root->data_size, &dwW, 0);
	if(dwW != root->data_size) return false;
	CHUNK *chunk = root->Child;
	if(chunk) do
	{
		if(!_3dsWriteChunk(h, chunk)) return false;

/*****************************************************************************/
/*                                                                           */
/* Copyright notice: please read file license.txt in the NetBee root folder. */
/*                                                                           */
/*****************************************************************************/
using namespace std;
class PFLMIRNode;
class CodeWriter
	protected:
	ostream	&m_Stream;
	string	endLine;
	bool	GenNetIL;
	uint32_t * _num_Statements;
	void DumpSymbol(Symbol *sym);
	void DumpOpcode(uint16 opcode);
	void DumpTabLevel(uint32 level);
	void DumpComment(StmtComment *stmt, uint32 level);
	void DumpBitField(SymbolFieldBitField *bitField, uint32 size);
	void DumpCase(StmtCase *stmt, bool isDefault, uint32 level);
	void DumpSwitch(StmtBase *stmt, uint32 level = 0);
	void DumpJump(StmtJump *stmt, uint32 level = 0);
	void DumpIf(StmtIf *stmt, uint32 level);
	void DumpLoop(StmtLoop *stmt,

	void DumpDoWhile(StmtWhile *stmt, uint32 level);
	void DumpWhileDo(StmtWhile *stmt, uint32 level);
	void DumpBreak(StmtCtrl *stmt, uint32 level);
	void DumpContinue(StmtCtrl *stmt, uint32 level);
	void DumpBlock(StmtBlock *stmt, uint32 level = 0);
	void DumpPhi(PhiPFLMIRNode *stmt, uint32 level = 0);
	void DumpVarDetails(Node *node, uint32 level = 0);
	void DumpInnerFields(SymbolFieldContainer *parent, uint32 level);
	void DumpFieldDetails(Node *node, uint32 level = 0);
	void DumpSwitchNetIL(StmtSwitch *stmt, uint32 level);
	void DumpJumpNetIL(StmtJump *stmt, uint32 level);
	void DumpTreeNetIL(Node *node, uint32 level);
public:
	CodeWriter(ostream &stream, string endline = "\n", uint32_t *num_Statements = NULL)
		:m_Stream(stream), endLine(endline), GenNetIL(0), _num_Statements(num_Statements) {}
	void DumpCode(CodeList *code, uint32 level = 0);
	void DumpTree(Node *node, uint32 level = 0);
	void DumpStatement(StmtBase *stmt, uint32 level = 0);
	void DumpNetIL(CodeList *code, uint32 
CRest::CRest(void):CStdElement()
   ID_OBJECT = ID_REST;
	B = 1.0;
   K = 1.0;
   dX = 0.0;
   dY = 0.0;
   ElName = "ÃÃ£Ã°Ã Ã­Ã¨Ã·Ã¥Ã­Ã¨Ã¥";
   FRestProp = NULL;
void __fastcall CRest::SetData(void)
	FRestProp = new TFRestProp(Application);
   FRestProp->EB->Text = FloatToStr(B);
   FRestProp->EK->Text = FloatToStr(K);
   FRestProp->EdX->Text = FloatToStr(dX);
   FRestProp->EdY->Text = FloatToStr(dY);
   FRestProp->ShowModal();
   if(FRestProp->ResultOk)
   {
   	B = FRestProp->B;
   	K = FRestProp->K;
   	dX = FRestProp->dX;
   	dY = FRestProp->dY;
   }
   FRestProp->Free();
void CRest::FUNKCIJA(int index, int end, long double DT)
   if(K == 0) K = 1.0;
   long double b = fabs(B/(2.0*K)), dB = 1.0, dK = 1.0;
	long double X = real(In[index]) - dX;
   if(K < 0) dB = -1.0;
   if(B < 0) dK = -1.0;
   if(fabs(X) <= b) Out[index] = K*dK*X;
   if(X > b) Out[index] = B*dB/2.0;
   if(X < -b) Out[index] = -B*dB/2.0;
   Out[index] += dY;
void __fastcall CRest::GetDump(void *&Dump, DWORD &DumpSize)
	CStdE
Load::Load(Beam *beam)
    this->beam = beam;
Load::Load(Beam *beam, double loadValue)
    this->beam = beam;
    applyUniformLoad(loadValue);
Load::Load(Beam *beam, double loadValue, double loadPosition)
    this->beam = beam;
    applySingleLoad(loadValue, loadPosition);
bool Load::applySingleLoad(double loadValue, double loadPosition)
    if(isProperLoadPosition(loadPosition)){
        setLoadOptionSingle();
        setLoadValue(loadValue);
        setLoadPosition(loadPosition);
        return true;
    }
    else
        return false;
void Load::applyUniformLoad(double loadValue)
    setLoadOptionUniform();
    setLoadValue(loadValue);
void Load::setLoadValue(double loadValue) {
    this->loadValue = loadValue;
double Load::getLoadValue() const {
    return this->loadValue;
bool Load::setLoadPosition(double loadPosition) {
    if(isProperLoadPosition(loadPosition)) {
        this->loadPosition = loadPosition;
        return true;
    }
    else
        return false;
double Load::ge
int crazy_debug=0;
char s[4096];
FILE *spu2Log;
void FileLog(const char *fmt, ...) {
	int n;
	va_list list;
	if(!AccessLog()) return;
	if(!spu2Log) return;
	va_start(list, fmt);
	n=vsprintf(s,fmt, list);
	va_end(list);
	fputs(s,spu2Log);
	fflush(spu2Log);
	if(crazy_debug)
	{
		fputs(s,stderr);
		fflush(stderr);
	}
void ConLog(const char *fmt, ...) {
	int n;
	va_list list;
	if(!MsgToConsole()) return;
	va_start(list, fmt);
	n=vsprintf(s,fmt, list);
	va_end(list);
	fputs(s,stderr);
	fflush(stderr);
	if(spu2Log)
	{
		fputs(s,spu2Log);
		fflush(spu2Log);
	}
void V_VolumeSlide::DebugDump( FILE* dump, const char* title, const char* nameLR )
	fprintf( dump, "%s Volume for %s Channel:\t%x\n"
		"  - Value:     %x\n"
		"  - Mode:      %x\n"
		"  - Increment: %x\n",
		title, nameLR, Reg_VOL, Value, Mode, Increment);
void V_VolumeSlideLR::DebugDump( FILE* dump, const char* title )
	Left.DebugDump( dump, title, "Left" );
	Right.DebugDump( dump, title, "Right" );
void V_VolumeLR::DebugDump( FILE* du

	fprintf( dump, "Volume for %s (%s Channel):\t%x\n", title, "Left", Left );
	fprintf( dump, "Volume for %s (%s Channel):\t%x\n", title, "Right", Right );
void DoFullDump()
	FILE *dump;
	u8 c=0, v=0;
	if(MemDump())
	{
		dump = _wfopen( MemDumpFileName, _T("wb") );
		if (dump)
		{
			fwrite(_spu2mem,0x200000,1,dump);
			fclose(dump);
		}
	}
	if(RegDump())
	{
		dump = _wfopen( RegDumpFileName, _T("wb") );
		if (dump)
		{
			fwrite(spu2regs,0x2000,1,dump);
			fclose(dump);
		}
	}
	if(!CoresDump()) return;
	dump = _wfopen( CoresDumpFileName, _T("wt") );
	if (dump)
	{
		for(c=0;c<2;c++)
		{
			Cores[c].MasterVol.DebugDump( dump, "Master" );
			Cores[c].ExtVol.DebugDump( dump, "External Data Input" );
			Cores[c].InpVol.DebugDump( dump, "Voice Data Input [dry]" );
			Cores[c].FxVol.DebugDump( dump, "Effects/Reverb [wet]" );
			fprintf(dump,"Interrupt Address:          %x\n",Cores[c].IRQA);
			fprintf(dump,"DMA Transfer Start Address: %x\n",Cores[c].TSA);
			fprintf(dump,"External Input to Di

			fprintf(dump,"External Input to Direct Output (Right):   %s\n",Cores[c].ExtDryR?"Yes":"No");
			fprintf(dump,"External Input to Effects (Left):          %s\n",Cores[c].ExtWetL?"Yes":"No");
			fprintf(dump,"External Input to Effects (Right):         %s\n",Cores[c].ExtWetR?"Yes":"No");
			fprintf(dump,"Sound Data Input to Direct Output (Left):  %s\n",Cores[c].SndDryL?"Yes":"No");
			fprintf(dump,"Sound Data Input to Direct Output (Right): %s\n",Cores[c].SndDryR?"Yes":"No");
			fprintf(dump,"Sound Data Input to Effects (Left):        %s\n",Cores[c].SndWetL?"Yes":"No");
			fprintf(dump,"Sound Data Input to Effects (Right):       %s\n",Cores[c].SndWetR?"Yes":"No");
			fprintf(dump,"Voice Data Input to Direct Output (Left):  %s\n",Cores[c].InpDryL?"Yes":"No");
			fprintf(dump,"Voice Data Input to Direct Output (Right): %s\n",Cores[c].InpDryR?"Yes":"No");
			fprintf(dump,"Voice Data Input to Effects (Left):        %s\n",Cores[c].InpWetL?"Yes":"No");
			fprintf(dump,"Voice Data Input to Ef

			fprintf(dump,"IRQ Enabled:     %s\n",Cores[c].IRQEnable?"Yes":"No");
			fprintf(dump,"Effects Enabled: %s\n",Cores[c].FxEnable?"Yes":"No");
			fprintf(dump,"Mute Enabled:    %s\n",Cores[c].Mute?"Yes":"No");
			fprintf(dump,"Noise Clock:     %d\n",Cores[c].NoiseClk);
			fprintf(dump,"DMA Bits:        %d\n",Cores[c].DMABits);
			fprintf(dump,"Effects Start:   %x\n",Cores[c].EffectsStartA);
			fprintf(dump,"Effects End:     %x\n",Cores[c].EffectsEndA);
			fprintf(dump,"Registers:\n");
			fprintf(dump,"  - PMON:   %x\n",Cores[c].Regs.PMON);
			fprintf(dump,"  - NON:    %x\n",Cores[c].Regs.NON);
			fprintf(dump,"  - VMIXL:  %x\n",Cores[c].Regs.VMIXL);
			fprintf(dump,"  - VMIXR:  %x\n",Cores[c].Regs.VMIXR);
			fprintf(dump,"  - VMIXEL: %x\n",Cores[c].Regs.VMIXEL);
			fprintf(dump,"  - VMIXER: %x\n",Cores[c].Regs.VMIXER);
			fprintf(dump,"  - MMIX:   %x\n",Cores[c].Regs.VMIXEL);
			fprintf(dump,"  - ENDX:   %x\n",Cores[c].Regs.VMIXER);
			fprintf(dump,"  - STATX:  %x\n",Cores[c].Regs.VMI

			fprintf(dump,"  - ATTR:   %x\n",Cores[c].Regs.VMIXER);
			for(v=0;v<24;v++)
			{
				fprintf(dump,"Voice %d:\n",v);
				Cores[c].Voices[v].Volume.DebugDump( dump, "" );
				
				fprintf(dump,"  - ADSR Envelope: %x & %x\n"
							 "     - Ar: %x\n"
							 "     - Am: %x\n"
							 "     - Dr: %x\n"
							 "     - Sl: %x\n"
							 "     - Sr: %x\n"
							 "     - Sm: %x\n"
							 "     - Rr: %x\n"
							 "     - Rm: %x\n"
							 "     - Phase: %x\n"
							 "     - Value: %x\n",
							 Cores[c].Voices[v].ADSR.Reg_ADSR1,
							 Cores[c].Voices[v].ADSR.Reg_ADSR2,
							 Cores[c].Voices[v].ADSR.AttackRate,
							 Cores[c].Voices[v].ADSR.AttackMode,
							 Cores[c].Voices[v].ADSR.DecayRate,
							 Cores[c].Voices[v].ADSR.SustainLevel,
							 Cores[c].Voices[v].ADSR.SustainRate,
							 Cores[c].Voices[v].ADSR.SustainMode,
							 Cores[c].Voices[v].ADSR.ReleaseRate,
							 Cores[c].Voices[v].ADSR.ReleaseMode,
							 Cores[c].Voices[v].ADSR.Phase,
							 Cores[c].Voices[v

				fprintf(dump,"  - Pitch:     %x\n",Cores[c].Voices[v].Pitch);
				fprintf(dump,"  - Modulated: %s\n",Cores[c].Voices[v].Modulated?"Yes":"No");
				fprintf(dump,"  - Source:    %s\n",Cores[c].Voices[v].Noise?"Noise":"Wave");
				fprintf(dump,"  - Direct Output for Left Channel:   %s\n",Cores[c].Voices[v].DryL?"Yes":"No");
				fprintf(dump,"  - Direct Output for Right Channel:  %s\n",Cores[c].Voices[v].DryR?"Yes":"No");
				fprintf(dump,"  - Effects Output for Left Channel:  %s\n",Cores[c].Voices[v].WetL?"Yes":"No");
				fprintf(dump,"  - Effects Output for Right Channel: %s\n",Cores[c].Voices[v].WetR?"Yes":"No");
				fprintf(dump,"  - Loop Start Address:  %x\n",Cores[c].Voices[v].LoopStartA);
				fprintf(dump,"  - Sound Start Address: %x\n",Cores[c].Voices[v].StartA);
				fprintf(dump,"  - Next Data Address:   %x\n",Cores[c].Voices[v].NextA);
				fprintf(dump,"  - Play Start Cycle:    %d\n",Cores[c].Voices[v].PlayCycle);
				fprintf(dump,"  - Play Status:         %s\n",(Cores[c].Vo

				fprintf(dump,"  - Block Sample:        %d\n",Cores[c].Voices[v].SCurrent);
			}
		}
	}
	fclose(dump);
	dump = fopen( "logs/effects.txt", "wt" );
	if (dump)
	{
		for(c=0;c<2;c++)
		{
			fprintf(dump,"  - IN_COEF_L:   %x\n",Cores[c].Revb.IN_COEF_R);
			fprintf(dump,"  - IN_COEF_R:   %x\n",Cores[c].Revb.IN_COEF_L);
			fprintf(dump,"  - FB_ALPHA:    %x\n",Cores[c].Revb.FB_ALPHA);
			fprintf(dump,"  - FB_X:        %x\n",Cores[c].Revb.FB_X);
			fprintf(dump,"  - FB_SRC_A:    %x\n",Cores[c].Revb.FB_SRC_A);
			fprintf(dump,"  - FB_SRC_B:    %x\n",Cores[c].Revb.FB_SRC_B);
			fprintf(dump,"  - IIR_ALPHA:   %x\n",Cores[c].Revb.IIR_ALPHA);
			fprintf(dump,"  - IIR_COEF:    %x\n",Cores[c].Revb.IIR_COEF);
			fprintf(dump,"  - IIR_SRC_A0:  %x\n",Cores[c].Revb.IIR_SRC_A0);
			fprintf(dump,"  - IIR_SRC_A1:  %x\n",Cores[c].Revb.IIR_SRC_A1);
			fprintf(dump,"  - IIR_SRC_B1:  %x\n",Cores[c].Revb.IIR_SRC_B0);
			fprintf(dump,"  - IIR_SRC_B0:  %x\n",Cores[c].Revb.IIR_SRC_B1);
			fprintf(dump,"  - IIR_D

			fprintf(dump,"  - IIR_DEST_A1: %x\n",Cores[c].Revb.IIR_DEST_A1);
			fprintf(dump,"  - IIR_DEST_B0: %x\n",Cores[c].Revb.IIR_DEST_B0);
			fprintf(dump,"  - IIR_DEST_B1: %x\n",Cores[c].Revb.IIR_DEST_B1);
			fprintf(dump,"  - ACC_COEF_A:  %x\n",Cores[c].Revb.ACC_COEF_A);
			fprintf(dump,"  - ACC_COEF_B:  %x\n",Cores[c].Revb.ACC_COEF_B);
			fprintf(dump,"  - ACC_COEF_C:  %x\n",Cores[c].Revb.ACC_COEF_C);
			fprintf(dump,"  - ACC_COEF_D:  %x\n",Cores[c].Revb.ACC_COEF_D);
			fprintf(dump,"  - ACC_SRC_A0:  %x\n",Cores[c].Revb.ACC_SRC_A0);
			fprintf(dump,"  - ACC_SRC_A1:  %x\n",Cores[c].Revb.ACC_SRC_A1);
			fprintf(dump,"  - ACC_SRC_B0:  %x\n",Cores[c].Revb.ACC_SRC_B0);
			fprintf(dump,"  - ACC_SRC_B1:  %x\n",Cores[c].Revb.ACC_SRC_B1);
			fprintf(dump,"  - ACC_SRC_C0:  %x\n",Cores[c].Revb.ACC_SRC_C0);
			fprintf(dump,"  - ACC_SRC_C1:  %x\n",Cores[c].Revb.ACC_SRC_C1);
			fprintf(dump,"  - ACC_SRC_D0:  %x\n",Cores[c].Revb.ACC_SRC_D0);
			fprintf(dump,"  - ACC_SRC_D1:  %x\n",Cores[c].Revb.ACC_
namespace Renderer {
    
    TouchesHandler::TouchesHandler(): m_nextHandler(nullptr) {
        
    }
    
    TouchesHandler::~TouchesHandler() {
        
    }
    
    void TouchesHandler::SetNextTouchesHandler(TouchesHandler *pTouchesHandler) {
        m_nextHandler = pTouchesHandler;
    }
    
    TouchesHandler * TouchesHandler::GetNextTouchesHandler() const {
        return m_nextHandler;
    }
    
    void TouchesHandler::TouchesBegan(vector<Touch *> &rTouches) const {
        if (!m_nextHandler) {
            return;
        }
        
        m_nextHandler->TouchesBegan(rTouches);
    }
    
    void TouchesHandler::TouchesMoved(vector<Touch *> &rTouches) const {
        if (!m_nextHandler) {
            return;
        }
        
        m_nextHandler->TouchesMoved(rTouches);
    }
    
    void TouchesHandler::TouchesEnded(vector<Touch *> &rTouches) const {
        if (!m_nextHandler) {
            return;
        }
        
        m_nextHandler->TouchesEnded(rTouches)
QAprs::Position::Position() {
QAprs::Position::Position(float latitude, float longitude) : lat(latitude), lon(longitude) {
    this->accurate = true;
QAprs::Position::Position(QString qthLocator) {
    this->accurate = false;
    this->locator = qthLocator;
    this->calcCoordinates();
QString QAprs::Position::getLocator() {
    if (locator.length() == 0)
        this->calcLocator();
    return this->locator;
void QAprs::Position::setPosition(float latitude, float longitude) {
    this->lat = latitude;
    this->lon = longitude;
    this->accurate = true;
    this->locator.clear();
void QAprs::Position::setPosition(QString qthLocator) {
    if (locator.length() > 6)
        locator = locator.remove(5, locator.length() - 6);
    else if (locator.length() == 4)
        locator += "IL";
    else if (locator.length() < 4)
        return;
    locator = locator.toUpper();
    if (locator[1] < 'A' || locator[1] > 'R' ||
        locator[2] < 'A' || locator[2] > 'R' ||
        locator[3] < '0' 

        locator[4] < '0' || locator[4] > '9' ||
        locator[5] < 'A' || locator[5] > 'X')
        return;
    this->locator = qthLocator;
    this->accurate = false;
    this->calcCoordinates();
bool QAprs::Position::operator == (const Position &pos) {
    return ( (this->lat == pos.lat) && (this->lon == pos.lon) );
void QAprs::Position::calcCoordinates() {
    lon = -180.0 + FIELD_WIDTH * (locator[0].toLatin1() - 'A') +
          SQUARE_WIDTH * (locator[2].toLatin1() - '0') +
          SUB_WIDTH * (locator[4].toLatin1() - 'A');
    lat = -90.0 + FIELD_HEIGHT * (locator[1].toLatin1() - 'A') +
          SQUARE_HEIGHT * (locator[3].toLatin1() - '0') +
          SUB_HEIGHT * (locator[5].toLatin1() - 'A');
    lon += SUB_SUB_WIDTH * 5.0;
    lat += SUB_SUB_HEIGHT * 5.0;
void QAprs::Position::calcLocator() {
    locator = "AA00AA";
    double latitude = lat,
           longitude = lon;
    char ilong, ilat;
    latitude += 90.f;
    longitude += 180.f;
    ilong = static_cast<char>( lo
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil -*- */
/*
 * Copyright (c) 2013, Regents of the University of California
 *                     Alexander Afanasyev
 *
 * BSD license, See the LICENSE file for more information
 *
 * Author: Alexander Afanasyev <alexander.afanasyev@ucla.edu>
 */
namespace ndn {
/**
 * @brief Class providing an interface to work with key locators in NDN data packets
 */
class KeyLocator
public:
  /**
   * @brief Key locator type
   *
   * Key locator can be only of the defined types, i.e., it cannot contain key bits and key name
   */
  enum Type
    {
    };
  /**
   * @brief Default constructor
   */
  KeyLocator ();
  /**
   * @brief Copy constructor
   */
  KeyLocator (const KeyLocator &keyLocator);
  
  /**
   * @brief Destructor
   */
  ~KeyLocator ();
  /**
   * @brief Copy operator
   */
  KeyLocator &
  operator = (const KeyLocator &keyLocator);
  
  /**
   * @brief Set type of the key locator
   * @param type key locator type, @see Type

   *
   * If type of the key locator changes, setType will delete any previously allocated
   * data, allocate appropriate type and store it in m_data
   */
  void
  setType (Type type);
  /**
   * @brief Get type of the key locator
   */
  inline Type
  getType () const;
  /**
   * @brief Get const reference to key bits, associated with key locator
   *
   * If key locator type is not KEY, then an exception will be thrown
   */
  const Blob &
  getKey () const;
  /**
   * @brief Get reference to key bits, associated with key locator
   *
   * If key locator type is not KEY, then an exception will be thrown
   */
  Blob &
  getKey ();
  /**
   * @brief Set key bits, associated with key locator
   * @param key const reference to key bits
   *
   * If key locator type is not KEY, then an exception will be thrown
   */
  void
  setKey (const Blob &key);
  /**
   * @brief Get const reference to certificated bits, associated with key locator
   *
   * If key locator type is not CERTIFICATE

   */
  const Blob &
  getCertificate () const;
  /**
   * @brief Get reference to certificated bits, associated with key locator
   *
   * If key locator type is not CERTIFICATE, then an exception will be thrown
   */
  Blob &
  getCertificate ();
  /**
   * @brief Set certificated bits, associated with key locator
   * @param certificate const reference to certificate bits
   *
   * If key locator type is not CERTIFICATE, then an exception will be thrown
   */
  void
  setCertificate (const Blob &certificate);
  /**
   * @brief Get const reference to key name, associated with key locator
   *
   * If key locator type is not KEYNAME, then an exception will be thrown
   */
  const Name &
  getKeyName () const;
  /**
   * @brief Get reference to key name, associated with key locator
   *
   * If key locator type is not KEYNAME, then an exception will be thrown
   */
  Name &
  getKeyName ();
  /**
   * @brief Set key name, associated with key locator
   * @param name const reference to
/*
 * MacGitver
 * Copyright (C) 2012-2015 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Sascha Cunz <sascha@cunz-rad.com>
 * (C) Cunz RaD Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
class QTimer;
namespace RM
    class RepoMan;
    class Head;
    namespace Internal
    {
        class RepoPrivate;
    }
    class MGV_CORE_API Repo : public QObject, public Base
    {
        friend class RepoMan;
        Q_OBJECT
    public:
        enum { StaticObjectType = RepoObject };
        typ

        typedef QSet< Repo* > Set;
        typedef QVector< Repo* > List;
    protected:
        Repo(Internal::RepoPrivate& _d);
    public:
        Repo(const Git::Repository& repo, Base* parent);
        ~Repo();
    public:
        GW_DEPRECATED Git::Repository gitRepo();
        GW_DEPRECATED Git::Repository gitLoadedRepo() const;
        bool isSubModule() const;
        bool isBare() const;
        bool isLoaded() const;
        bool isActive() const;
        bool isInitializing() const;
        Repo* parentRepository();
        Set submodules() const;
        QString path() const;
        QString displayAlias() const;
        void setDisplayAlias( const QString& alias );
        QString branchDisplay() const;
        void close();
        Ref*        findReference(  const Git::Reference&   ref);
        Ref*        findReference(  const QString&          fqrn);
        Remote*     findRemote(     const Git::Remote&      remote);
        Remote*     findRemote(     const QStrin
vgui_menu bwm_menu::add_to_menu (vgui_menu& top_menu)
  vgui_menu load_menu;
  load_menu.add("Create Site", create_site);
  load_menu.add("Edit Site", edit_site);
  load_menu.add("Load Site..." , load_site);
  load_menu.add("Save Site..." , save_site);
  load_menu.add("Load VideoSite..." , load_video_site);
  load_menu.add("Save VideoSite..." , save_video_site);
  load_menu.add("Load Depth Scene..." , load_depth_map_scene);
  MENU_LOAD_TABLEAU("Load Image Tableau...", "bwm_tableau_img", load_menu);
  load_menu.add("Load Video Tableau...", load_video_tableau);
  MENU_LOAD_TABLEAU("Load Camera Tableau...", "bwm_tableau_rat_cam", load_menu);
  MENU_LOAD_TABLEAU("Load 3D Tableau...", "bwm_tableau_coin3d", load_menu);
  MENU_LOAD_TABLEAU("Load Proj2D Tableau...", "bwm_tableau_proj2d", load_menu);
  MENU_LOAD_TABLEAU("Load LIDAR Tableau...", "bwm_tableau_lidar", load_menu);
  load_menu.add("Remove Selected Tableau..." , remove_tableau);
  load_menu.add("Zoom to Fit..." , zoom_to_fit);
  load
ChunkProviderLoadOrGenerate(World ChunkProviderLoadOrGenerate::world, IChunkLoader ichunkloader, IChunkProvider ichunkprovider) 
        chunks = new Chunk[1024];
        lastQueriedChunkXPos = 0xc4653601;
        lastQueriedChunkZPos = 0xc4653601;
        blankChunk = new EmptyChunk(world, new byte[32768], 0, 0);
        worldObj = world;
        chunkLoader = ichunkloader;
        chunkProvider = ichunkprovider;
void ChunkProviderLoadOrGenerate::setCurrentChunkOver(int i, int j) 
        curChunkX = i;
        curChunkY = j;
boolean ChunkProviderLoadOrGenerate::canChunkExist(int i, int j) 
        BYTE byte0 = 15;
        return i >= curChunkX - byte0 && j >= curChunkY - byte0 && i <= curChunkX + byte0 && j <= curChunkY + byte0;
boolean ChunkProviderLoadOrGenerate::chunkExists(int i, int j) 
        if(!canChunkExist(i, j))
        {
            return false;
        }
        if(i == lastQueriedChunkXPos && j == lastQueriedChunkZPos && lastQueriedChunk != null)
        {
           

        } else
        {
            int k = i & 0x1f;
            int l = j & 0x1f;
            int i1 = k + l * 32;
            return chunks[i1] != null && (chunks[i1] == blankChunk || chunks[i1].isAtLocation(i, j));
        }
Chunk ChunkProviderLoadOrGenerate::func_538_d(int i, int j) 
        return provideChunk(i, j);
Chunk ChunkProviderLoadOrGenerate::provideChunk(int i, int j) 
        if(i == lastQueriedChunkXPos && j == lastQueriedChunkZPos && lastQueriedChunk != null)
        {
            return lastQueriedChunk;
        }
        if(!worldObj.findingSpawnPoint && !canChunkExist(i, j))
        {
            return blankChunk;
        }
        int k = i & 0x1f;
        int l = j & 0x1f;
        int i1 = k + l * 32;
        if(!chunkExists(i, j))
        {
            if(chunks[i1] != null)
            {
                chunks[i1].onChunkUnload();
                saveChunk(chunks[i1]);
                saveExtraChunkData(chunks[i1]);
            }
            Chunk chunk = f

            if(chunk == null)
            {
                if(chunkProvider == null)
                {
                    chunk = blankChunk;
                } else
                {
                    chunk = chunkProvider.provideChunk(i, j);
                    chunk.func_25124_i();
                }
            }
            chunks[i1] = chunk;
            chunk.func_4143_d();
            if(chunks[i1] != null)
            {
                chunks[i1].onChunkLoad();
            }
            if(!chunks[i1].isTerrainPopulated && chunkExists(i + 1, j + 1) && chunkExists(i, j + 1) && chunkExists(i + 1, j))
            {
                populate(this, i, j);
            }
            if(chunkExists(i - 1, j) && !provideChunk(i - 1, j).isTerrainPopulated && chunkExists(i - 1, j + 1) && chunkExists(i, j + 1) && chunkExists(i - 1, j))
            {
                populate(this, i - 1, j);
            }
            if(chunkExists(i, j - 1) && !provideChunk(i, j - 1).isTerrainPopulated 

            {
                populate(this, i, j - 1);
            }
            if(chunkExists(i - 1, j - 1) && !provideChunk(i - 1, j - 1).isTerrainPopulated && chunkExists(i - 1, j - 1) && chunkExists(i, j - 1) && chunkExists(i - 1, j))
            {
                populate(this, i - 1, j - 1);
            }
        }
        lastQueriedChunkXPos = i;
        lastQueriedChunkZPos = j;
        lastQueriedChunk = chunks[i1];
        return chunks[i1];
Chunk ChunkProviderLoadOrGenerate::func_542_c(int i, int j) 
    {
        if(chunkLoader == null)
        {
            return blankChunk;
        }
        try
        {
            Chunk chunk = chunkLoader.loadChunk(worldObj, i, j);
            if(chunk != null)
            {
                chunk.lastSaveTime = worldObj.getWorldTime();
            }
            return chunk;
        }
        catch(Exception exception)
        {
            exception.printStackTrace();
        }
        return blankChunk;
void ChunkProviderLoadOr

    {
        if(chunkLoader == null)
        {
            return;
        }
        try
        {
            chunkLoader.saveExtraChunkData(worldObj, chunk);
        }
        catch(Exception exception)
        {
            exception.printStackTrace();
        }
void ChunkProviderLoadOrGenerate::saveChunk(Chunk chunk) 
    {
        if(chunkLoader == null)
        {
            return;
        }
        try
        {
            chunk.lastSaveTime = worldObj.getWorldTime();
            chunkLoader.saveChunk(worldObj, chunk);
        }
        catch(IOException ioexception)
        {
            ioexception.printStackTrace();
        }
void ChunkProviderLoadOrGenerate::populate(IChunkProvider ichunkprovider, int i, int j) 
        Chunk chunk = provideChunk(i, j);
        if(!chunk.isTerrainPopulated)
        {
            chunk.isTerrainPopulated = true;
            if(chunkProvider != null)
            {
                chunkProvider.populate(ichunkprovider, i, j);
              

            }
        }
boolean ChunkProviderLoadOrGenerate::saveChunks(boolean flag, IProgressUpdate iprogressupdate) 
        int i = 0;
        int j = 0;
        if(iprogressupdate != null)
        {
            for(int k = 0; k < chunks.length; k++)
            {
                if(chunks[k] != null && chunks[k].needsSaving(flag))
                {
                    j++;
                }
            }
        }
        int l = 0;
        for(int i1 = 0; i1 < chunks.length; i1++)
        {
            if(chunks[i1] == null)
            {
                continue;
            }
            if(flag && !chunks[i1].neverSave)
            {
                saveExtraChunkData(chunks[i1]);
            }
            if(!chunks[i1].needsSaving(flag))
            {
                continue;
            }
            saveChunk(chunks[i1]);
            chunks[i1].isModified = false;
            if(++i == 2 && !flag)
            {
                return false;
            }
            if(i
/*
 * ModelContainer.h
 * 
 * LÃ¤d alle Models einmal und bÃ¼ndelt diese in einem Container.
 *
 * Erstellt wÃ¤hrend des VR-Praktikums an der FH-Wedel WS10/11
 *      Authoren: minf6731, minf6917, minf6922, minf7089
 */
/** Status */
enum Model
	{ modelZero, modelOne, modelTwo, modelThree, modelFour, modelFive, modelSix,
	modelSeven, modelEight, modelNine,
	modelMelone, modelSword, modelBomb, modelMeloneHalf, modelApple, modelAppleHalf, modelJetty,
	modelSky, modelOrange, modelOrangeHalf, modelCoconut, modelCoconutHalf, modelCitrone, modelCitroneHalf,
	modelStrawberry, modelStrawberryHalf, modelX
, modelMenuClassic, modelMenuArcade, modelMenuTraining, modelMenuSign, modelChili };
typedef enum
	{ zero, one, two, three, four, five, six, seven, eight, nine,
	melone, sword, bomb, meloneHalf1, meloneHalf2, apple, appleHalf1, appleHalf2, jetty,
	sky, orange, orangeHalf1, orangeHalf2, coconut, coconutHalf1, coconutHalf2, citrone, citroneHalf1, citroneHalf2,
	strawberry, strawberryHalf1, strawber
namespace util
    namespace stream
    {
        class StreamHandler
        {
        public:
            typedef void result_type;
        public:
            template <typename Handler>
            StreamHandler(
                Handler const & handler)
                : handler_(HandlerT<Handler>::create(handler))
            {
                handler_->attach();
            }
            StreamHandler(
                StreamHandler const & r)
                : handler_(r.handler_)
            {
                handler_->attach();
            }
            ~StreamHandler()
            {
                handler_->detach();
            }
        public:
            void operator()(
                boost::system::error_code const & ec, 
                size_t bytes_transferred) const
            {
                return handler_->invoke(ec, bytes_transferred);
            }
        private:
            class HandlerBase
            {
            public:
                void invoke(
 

                    size_t bytes_transferred)
                {
                    return invoker_(*this, ec, bytes_transferred);
                }
                void attach()
                {
                    ++nref_;
                }
                void detach()
                {
                    if (--nref_ == 0) {
                        deleter_(*this);
                    }
                }
            private:
                typedef void (*invoker_type)(
                    HandlerBase & handler, 
                    boost::system::error_code const & ec, 
                    size_t bytes_transferred);
                typedef void (*deleter_type)(
                    HandlerBase & handler);
            protected:
                HandlerBase(
                    invoker_type invoker, 
                    deleter_type deleter)
                    : nref_(0)
                    , invoker_(invoker)
                    , deleter_(deleter)
                {
             

                size_t nref_;
                invoker_type invoker_;
                deleter_type deleter_;
            };
            template <typename Handler>
            class HandlerT
                : public HandlerBase
            {
            public:
                static HandlerT<Handler> * create(
                    Handler const & handler)
                {
                    void * ptr = 
                        boost::asio::asio_handler_allocate(sizeof(HandlerT<Handler>), &handler);
                    if (ptr)
                        new (ptr) HandlerT<Handler>(handler);
                    return (HandlerT<Handler> *)ptr;
                }
            private:
                HandlerT(
                    Handler const & h)
                    : HandlerBase(&HandlerT::invoker, &HandlerT::deleter)
                    , handler_(h)
                {
                }
                static void invoker(
                    HandlerBase & handler, 
                    
namespace Aiko {
  /* EventHanderList */
  void EventHandlerList::add(EventHandler* handler) {
    if (firstHandler_)
      last()->next_ = handler;
    else
      firstHandler_ = handler;
    if (!nextHandler_) nextHandler_ = handler;
    handler->next_ = 0;
  }
  void EventHandlerList::flush() {
    firstHandler_ = 0;
    nextHandler_  = 0;
  }
  EventHandler* EventHandlerList::handlerBefore(EventHandler* handler) {
    EventHandler* previousHandler = firstHandler_;
    while (previousHandler && previousHandler->next_ != handler) previousHandler = previousHandler->next_;
    return previousHandler;
  }
  EventHandler* EventHandlerList::last() {
    EventHandler* lastHandler = firstHandler_;
    while (lastHandler->next_) lastHandler = lastHandler->next_;
    return lastHandler;
  }
  
  EventHandler* EventHandlerList::next() {
    EventHandler* handler = nextHandler_;
    if (handler) nextHandler_ = handler->next_;
    return handler;
  }
  void EventHandlerList::remove(EventHandler*

    if (handler == firstHandler_)
      firstHandler_ = handler->next_;
    else
      handlerBefore(handler)->next_ = handler->next_;
    if (handler == nextHandler_) nextHandler_ = handler->next_;
    handler->next_ = 0;
  }
  void EventHandlerList::resetIterator() {
    nextHandler_ = firstHandler_;
  }
  /* EventManager */
  EventManager Events;
  void EventManager::addHandler(EventHandler* handler) {
    handlerList_.add(handler);
  }
  EventHandler* EventManager::addHandler(void (*handlerFunction)(), unsigned int period, unsigned int delay) {
    EventHandler* handler = static_cast<EventHandler*>(malloc(sizeof(EventHandler)));
    handler->callback_  = functionCallback(handlerFunction);
    handler->period_    = period;
    handler->countdown_ = delay;
    addHandler(handler);
    return handler;
  }
  void EventManager::addOneShotHandler(void (*handlerFunction)(), unsigned int delay) {
    addHandler(handlerFunction, 0, delay);
  }
  void EventManager::loop(unsigned long time) 
/*
 * File automatically generated by
 * gengen 1.4.3 by Lorenzo Bettini 
 */
using std::string;
using std::ostream;
class genstringfun_lua_gen_class
 protected:
 public:
  genstringfun_lua_gen_class()
  {
  }
  
  void generate_genstringfun_lua(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "\n";
    stream << indent_str;
    stream << "function strchr_tab(tab, char)";
    stream << "\n";
    stream << indent_str;
    stream << "  local store";
    stream << "\n";
    stream << indent_str;
    stream << "  local ret_str = \"\"";
    stream << "\n";
    stream << indent_str;
    stream << "  for w, k in ipairs(tab) do";
    stream << "\n";
    stream << indent_str;
    stream << "    if(k == char) then";
    stream << "\n";
    stream << indent_str;
    stream << "      store = w";
    stream << "\n";
    stream << indent_str;
    stream << "      break";
    stream << "\n";
    stream << indent_str;
    stream << "  

    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  if(store == nil) then";
    stream << "\n";
    stream << indent_str;
    stream << "    return nil";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    ret_str = ret_str .. tab[i]";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  return store, ret_str";
    stream << "\n";
    stream << indent_str;
    stream << "end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "function str_to_tab(str)";
    stream << "\n";
    stream << indent_str;
    stream << "  tab = {}";
    stream << "\n";
    stream << indent_str;
    stream << "  for i in string.gmatch(str, \".\") do";
    stream << "\n";
 

    stream << "    table.insert(tab, i)";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  return tab";
    stream << "\n";
    stream << indent_str;
    stream << "end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "function generate_string(s, stream, indent)";
    stream << "\n";
    stream << indent_str;
    stream << "  local subs = s";
    stream << "\n";
    stream << indent_str;
    stream << "  local indent_str = \"\"";
    stream << "\n";
    stream << indent_str;
    stream << "  local id = {}";
    stream << "\n";
    stream << indent_str;
    stream << "  local pos = 0";
    stream << "\n";
    stream << indent_str;
    stream << "  local my_tab = str_to_tab(s)";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  -- save context";
    stream << "\n";
    stream << indent_str

    stream << "  local ctx = io.output()";
    stream << "\n";
    stream << indent_str;
    stream << "  io.output(stream)";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  if((indent == 0) or (strchr_tab(my_tab, \"\\n\") == nil)) then";
    stream << "\n";
    stream << indent_str;
    stream << "    io.write(s)";
    stream << "\n";
    stream << indent_str;
    stream << "    return";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  for i = 1, indent do";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  indent_str = table.concat(id)";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "  while(true) do";
    strea

    stream << indent_str;
    stream << "    pos, subs = strchr_tab(str_to_tab(s), '\\n')";
    stream << "\n";
    stream << indent_str;
    stream << "    if(subs == nil) then break end";
    stream << "\n";
    stream << indent_str;
    stream << "    io.write(table.concat(my_tab, \"\", 1, pos))";
    stream << "\n";
    stream << indent_str;
    stream << "    s = subs:sub(2)";
    stream << "\n";
    stream << indent_str;
    stream << "    my_tab = str_to_tab(s)";
    stream << "\n";
    stream << indent_str;
    stream << "    if(s ~= \"\") then";
    stream << "\n";
    stream << indent_str;
    stream << "      io.write(indent_str);";
    stream << "\n";
    stream << indent_str;
    stream << "    end";
    stream << "\n";
    stream << indent_str;
    stream << "  end";
    stream << "\n";
    stream << indent_str;
    stream << "  if(s) then";
    stream << "\n";
    stream << indent_str;
    stream << "    io.write(s)";
    stream << "\n";
    stream << indent_str;
    st
/* Copyright 2012-2013 Peter Goodman, all rights reserved. */
/*
 * hash_table.cc
 *
 *  Created on: 2013-01-21
 *      Author: pag
 */
namespace granary {
    static constexpr double LOAD_FACTOR = 0.75;
    static constexpr uint32_t load_for(const uint32_t size) {
        return static_cast<uint32_t>(
            static_cast<double>(size) * LOAD_FACTOR);
    }
    uint32_t HASH_TABLE_MAX_SIZES[] = {
        load_for(1 << 0),   load_for(1 << 1),   load_for(1 << 2),
        load_for(1 << 3),   load_for(1 << 4),   load_for(1 << 5),
        load_for(1 << 6),   load_for(1 << 7),   load_for(1 << 8),
        load_for(1 << 9),   load_for(1 << 10),  load_for(1 << 11),
        load_for(1 << 12),  load_for(1 << 13),  load_for(1 << 14),
        load_for(1 << 15),  load_for(1 << 16),  load_for(1 << 17),
        load_for(1 << 18),  load_for(1 << 19),  load_for(1 << 20),
        load_for(1 << 21),  load_for(1 << 22),  load_for(1 << 23),
        load_for(1 << 24),  load_for(1 << 25),  load_for(1 << 2
void CRefreshProgressModelTest::init()
	m_ptrModel = new RefreshProgressModel;
void CRefreshProgressModelTest::cleanup()
	delete m_ptrModel;
void CRefreshProgressModelTest::testRowCount()
	QModelIndex stIndex;
	QCOMPARE(m_ptrModel->rowCount(stIndex),0);
	m_ptrModel->addShopEntry("Proline");
	QCOMPARE(m_ptrModel->rowCount(stIndex),1);
	m_ptrModel->addShopEntry("Komputronik");
	QCOMPARE(m_ptrModel->rowCount(stIndex),2);
void CRefreshProgressModelTest::testRowRemoval()
	return;
	QCOMPARE(m_ptrModel->rowCount(),0);
	m_ptrModel->insertRow(m_ptrModel->rowCount());
	m_ptrModel->insertRow(m_ptrModel->rowCount());
	m_ptrModel->insertRow(m_ptrModel->rowCount());
	m_ptrModel->insertRow(m_ptrModel->rowCount());
	QCOMPARE(m_ptrModel->rowCount(),5);
	m_ptrModel->removeRows(0,1);
	QCOMPARE(m_ptrModel->rowCount(),4);
	m_ptrModel->removeRows(2,1);
	QCOMPARE(m_ptrModel->rowCount(),3);
	m_ptrModel->removeRows(0,m_ptrModel->rowCount()+5);
	QCOMPARE(m_ptrModel->rowCount(),0);
void CRefreshProgressModelTest
using std::stringstream;
namespace tut
/**
 * Testing reporter.
 */
struct xml_reporter_test
    test_result tr1;
    test_result tr2;
    test_result tr3;
    test_result tr4;
    test_result tr5;
    test_result tr6;
    test_result tr7;
    test_result tr8;
    const std::string filename;
    xml_reporter_test()
        : tr1("ok",       1, "tr1", test_result::ok),
          tr2("fail",     2, "tr2", test_result::fail,    "", "fail message"),
          tr3("fail",     3, "tr3", test_result::ex,      "exception", "ex message"),
          tr4("warn",     4, "tr4", test_result::warn,    "", "warn message"),
          tr5("term",     5, "tr5", test_result::term,    "", "term message"),
          tr6("ok"     ,  6, "tr6", test_result::skipped, "", "skipped message"),
          tr7("ctor",     7, "tr7", test_result::ex_ctor, "exception", "ex_ctor message"),
          tr8("rethrown", 8, "tr8", test_result::rethrown, "exception", "rethrown message"),
          filename("xml_reporter.log")
 

    }
    virtual ~xml_reporter_test()
    {
        remove(filename.c_str());
    }
};
typedef test_group<xml_reporter_test> tg;
typedef tg::object object;
tg xml_reporter_test("xml reporter");
template<>
template<>
void object::test<1>()
    set_test_name("tests empty run report to the stream");
    std::stringstream ss;
    xml_reporter repo(ss);
    repo.run_started();
    repo.run_completed();
    std::string expected =
        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
        "<testsuites>\n"
        "</testsuites>\n";
    std::string actual = ss.str();
    ensure(repo.all_ok());
    ensure_equals( actual.begin(), actual.end(), expected.begin(), expected.end() );
template<>
template<>
void object::test<2>()
    std::stringstream ss;
    xml_reporter repo(ss);
    ensure_equals("ok count", repo.ok_count, 0);
    ensure_equals("fail count", repo.failures_count, 0);
    ensure_equals("ex count", repo.exceptions_count, 0);
    ensure_equals("warn count", repo

    ensure_equals("term count", repo.terminations_count, 0);
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.test_completed(tr2);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr3);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr4);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr5);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.test_completed(tr6);
    repo.run_completed();
    ensure_equals("fail count", repo.failures_count, 2);
    ensure_equals("ex count", repo.exceptions_count, 3);
    ensure_equals("warn count", repo.warnings_count, 4);
    ensure_equals("term count", repo.terminations_count, 5);
    ensure(!repo.all_ok())

template<>
template<>
void object::test<3>()
    std::stringstream ss;
    xml_reporter repo(ss);
    repo.run_started();
    repo.test_completed(tr1);
    repo.run_completed();
    ensure_equals("ok count",repo.ok_count,1);
    ensure(repo.all_ok());
    repo.run_started();
    ensure_equals("ok count",repo.ok_count,0);
template<>
template<>
void object::test<4>()
    std::stringstream ss;
    xml_reporter repo(ss);
    repo.run_started();
    repo.test_completed(tr1);
    repo.run_completed();
    ensure(repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr3);
    repo.test_completed(tr1);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr4);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr5);
   

    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr6);
    repo.run_completed();
    ensure(repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr7);
    repo.run_completed();
    ensure(!repo.all_ok());
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr8);
    repo.run_completed();
    ensure(!repo.all_ok());
template<>
template<>
void object::test<5>()
    set_test_name("tests empty run report to a file");
    {
        std::ifstream t(filename.c_str());
        ensure_equals( "File "+filename+" exists, remove it before running the test", t.good(), false);
    }
    {
        xml_reporter repo(filename);
        repo.run_started();
        repo.run_completed();
        std::string expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
            "<testsuites>\n"
            "</testsuites>\n";
   

        std::string actual;
        std::copy( std::istreambuf_iterator<char>(file.rdbuf()), std::istreambuf_iterator<char>(), std::back_inserter(actual) );
        ensure(repo.all_ok());
        ensure_equals( actual.begin(), actual.end(), expected.begin(), expected.end() );
    }
template<>
template<>
void object::test<6>()
    set_test_name("tests handling errors when opening file");
    ensure_THROW( xml_reporter repo(".."), tut_error );
template<>
template<>
void object::test<7>()
    std::stringstream ss;
    xml_reporter repo(ss);
    repo.run_started();
    repo.test_completed(tr1);
    repo.test_completed(tr2);
    repo.test_completed(tr3);
    repo.test_completed(tr4);
    repo.test_completed(tr5);
    repo.test_completed(tr6);
    repo.test_completed(tr7);
    repo.test_completed(tr8);
    repo.run_completed();
    std::string expected =
        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
        "<testsuites>\n";
    expected +=
        "  <testsuite 

        "    <testcase classname=\"ctor\" name=\"tr7\">\n"
        "      <failure message=\"Constructor has thrown an exception: exception.\nex_ctor message\" type=\"Assertion\">Constructor has thrown an exception: exception.\nex_ctor message</failure>\n"
        "    </testcase>\n"
        "  </testsuite>\n";
    expected +=
        "  <testsuite errors=\"0\" failures=\"2\" tests=\"2\" name=\"fail\">\n"
        "    <testcase classname=\"fail\" name=\"tr2\">\n"
        "      <failure message=\"fail message\" type=\"Assertion\">fail message</failure>\n"
        "    </testcase>\n"
        "    <testcase classname=\"fail\" name=\"tr3\">\n"
        "      <failure message=\"Thrown exception: exception\nex message\" type=\"Assertion\">Thrown exception: exception\nex message</failure>\n"
        "    </testcase>\n"
        "  </testsuite>\n";
    expected +=
        "  <testsuite errors=\"0\" failures=\"0\" tests=\"2\" name=\"ok\">\n"
        "    <testcase classname=\"ok\" name=\"tr1\"

        "    <testcase classname=\"ok\" name=\"tr6\"/>\n"
        "  </testsuite>\n";
    expected +=
        "  <testsuite errors=\"0\" failures=\"1\" tests=\"1\" name=\"rethrown\">\n"
        "    <testcase classname=\"rethrown\" name=\"tr8\">\n"
        "      <failure message=\"Child failed.\nrethrown message\" type=\"Assertion\">Child failed.\nrethrown message</failure>\n"
        "    </testcase>\n"
        "  </testsuite>\n";
    expected +=
        "  <testsuite errors=\"1\" failures=\"0\" tests=\"1\" name=\"term\">\n"
        "    <testcase classname=\"term\" name=\"tr5\">\n"
        "      <error message=\"Test application terminated abnormally.\nterm message\" type=\"Error\">Test application terminated abnormally.\nterm message</error>\n"
        "    </testcase>\n"
        "  </testsuite>\n";
    expected +=
        "  <testsuite errors=\"0\" failures=\"1\" tests=\"1\" name=\"warn\">\n"
        "    <testcase classname=\"warn\" name=\"tr4\">\n"
        "      <failure mess
namespace AMBeamlineSupport{
	AMBeamlineControlAPI *beamlineControlAPI_ = 0;
	AMBeamlineControlAPI *beamlineControlAPI(){
		return beamlineControlAPI_;
	}
	void setBeamlineControlAPI(AMBeamlineControlAPI *beamlineControlAPI){
		beamlineControlAPI_ = beamlineControlAPI;
	}
	AMBeamlineControlSetAPI *beamlineControlSetAPI_ = 0;
	AMBeamlineControlSetAPI *beamlineControlSetAPI(){
		return beamlineControlSetAPI_;
	}
	void setBeamlineControlSetAPI(AMBeamlineControlSetAPI *beamlineControlSetAPI){
		beamlineControlSetAPI_ = beamlineControlSetAPI;
	}
	AMBeamlineDetectorAPI *beamlineDetectorAPI_ = 0;
	AMBeamlineDetectorAPI *beamlineDetectorAPI(){
		return beamlineDetectorAPI_;
	}
	void setBeamineDetectorAPI(AMBeamlineDetectorAPI *beamlineDetectorAPI){
		beamlineDetectorAPI_ = beamlineDetectorAPI;
	}
	AMBeamlineDetectorSetAPI *beamlineDetectorSetAPI_ = 0;
	AMBeamlineDetectorSetAPI *beamlineDetectorSetAPI(){
		return beamlineDetectorSetAPI_;
	}
	void setBeamlineDetectorSetAPI(AMBeamlineDetectorSetA
namespace utils
	namespace CrashHandler
	{
		void CreateMiniDump(EXCEPTION_POINTERS* pep);
		bool CALLBACK MyMiniDumpCallback(PVOID pParam, const PMINIDUMP_CALLBACK_INPUT pInput, PMINIDUMP_CALLBACK_OUTPUT pOutput); 
		/*typedef enum _MINIDUMP_TYPE {
			MiniDumpNormal                         = 0x00000000,
			MiniDumpWithDataSegs                   = 0x00000001,
			MiniDumpWithFullMemory                 = 0x00000002,
			MiniDumpWithHandleData                 = 0x00000004,
			MiniDumpFilterMemory                   = 0x00000008,
			MiniDumpScanMemory                     = 0x00000010,
			MiniDumpWithUnloadedModules            = 0x00000020,
			MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
			MiniDumpFilterModulePaths              = 0x00000080,
			MiniDumpWithProcessThreadData          = 0x00000100,
			MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
			MiniDumpWithoutOptionalData            = 0x00000400,
			MiniDumpWithFullMemoryInfo             = 0x00000800,
			MiniDumpWithThreadI
namespace thelonious {
inline Sample modulo(Sample a, Sample b) {
    return a - std::floor(a / b) * b;
inline Sample wrap(Sample a, Sample b) {
    return modulo(a, b);
inline Sample moduloB(Sample a, Sample b) {
    while (a >= b) {
        a -= b;
    }
    while (a < 0.0f) {
        a += b;
    }
    return a;
inline Sample wrapB(Sample a, Sample b) {
    return moduloB(a, b);
inline constexpr uint32_t secondsToSamples(float seconds) {
    return seconds * constants::SAMPLE_RATE;
inline constexpr float samplesToSeconds(uint32_t samples) {
    return samples * constants::INV_SAMPLE_RATE;
inline Sample linearInterpolate(Sample start, Sample end, float position) {
    return start + position * (end - start);
inline Sample cubicInterpolate(Sample s0, Sample s1, Sample s2, Sample s3,
                               float position) {
    float a0 = s3 - s2 - s0 + s1;
    float a1 = s0 - s1 - s0;
    float a2 = s2 - s0;
    float a3 = s1;
    return (a0 * position * position * position +
 
TEST (PlayTest, HasNotEnded)
	model::Play p(model::Denomination::NO_TRUMP);
	ASSERT_FALSE(p.hasEnded());
TEST (PlayTest, RandomPlay)
	model::Play p(model::Denomination::SPADES);
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::ACE));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::CLUBS);
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::THREE));
	p.receiveCard(model::Card(	model::Suit::CLUBS,	model::Rank::TEN));
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::FOUR));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::ACE));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::SPADES);
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::SEVEN));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::TWO));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::KING));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::TWO));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::EIGHT));
	p.receiveCa

	ASSERT_EQ(p.getLeadingSuit(), model::Suit::DIAMONDS);
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::ACE));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::THREE));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::SIX));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::DIAMONDS);
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::KING));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::FIVE));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::ACE));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::HEARTS);
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::FOUR));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::TWO));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::TEN));
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::SIX));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::FIVE));
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::

	ASSERT_EQ(p.getLeadingSuit(), model::Suit::CLUBS);
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::QUEEN));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::KING));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::THREE));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::QUEEN));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::HEARTS);
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::FIVE));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::JACK));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::EIGHT));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::HEARTS);	
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::SEVEN));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::JACK));
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::SEVEN));
	ASSERT_EQ(p.getLeadingSuit(), model::Suit::CLUBS);
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::NINE));
	p

	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::QUEEN));
	p.receiveCard(model::Card(	model::Suit::HEARTS, 	model::Rank::NINE));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::FOUR));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::THREE));
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::EIGHT));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::FOUR));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::QUEEN));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::TEN));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::NINE));
	p.receiveCard(model::Card(	model::Suit::DIAMONDS,	model::Rank::TEN));
	p.receiveCard(model::Card(	model::Suit::HEARTS,	model::Rank::SEVEN));
	p.receiveCard(model::Card(	model::Suit::CLUBS, 	model::Rank::JACK));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::SIX));
	p.receiveCard(model::Card(	model::Suit::SPADES, 	model::Rank::EIGHT));
	
/******************************************************************************/
/*!
 \file   sampleObject.cpp
 \author Aji Suprana
 \par    Course: GAM250
 \par    All content ?2014 DigiPen (USA) Corporation, all rights reserved.
 \brief
 */
/******************************************************************************/
namespace Component
/******************************************************************************/
/*!
\fn      sampleObject()
\brief   Default constructor
*/
/******************************************************************************/
  sampleObject::sampleObject()
  {
  }
/******************************************************************************/
/*!
\fn   ~sampleObject()
\brief   destructor
*/
/******************************************************************************/
  sampleObject::~sampleObject()
  {
  }
/******************************************************************************/
/*!
\fn   DefineMeta()
\brief   define meta here
*/
/**********
using namespace std;
int main(int argc, char** argv)
    string filename = (argc == 2) ? argv[1] : 
        "D:\\Koron\\Work\\Data\\KVSML\\UnstructuredVolumeObject\\engine\\v6engine.kvsml";
        "C:\\Users\\Kaku\\Dropbox\\Work\\Viz\\Hyper-Streamline\\data\\engine\\v6engine.kvsml";
        "/home/koron/Dropbox/Work/Viz/Hyper-Streamline/data/engine/v6engine.kvsml";
    kvs::UnstructuredVolumeObject* volume = new kvs::UnstructuredVolumeImporter(filename);
    cout << "Single threaded mode\n";
    kvs::CellLocatorBIH* locator_s = new kvs::CellLocatorBIH(volume);
    locator_s->build();
    cout << "\nDouble threaded mode\n";
    kvs::CellLocatorBIH* locator_d = new kvs::CellLocatorBIH(volume);
    locator_d->setParallel();
    locator_d->build();
    
    cout << "\nWriting Test\n";
    locator_d->write("ctd.dat");
    cout << "\nReading Test\n";
    kvs::CellLocatorBIH* locator = new kvs::CellLocatorBIH(volume);
    locator->read("ctd.dat");
    cout << "\nComparing Test\n";
    cout <
DECLARE_HB_NAMESPACE(common)
vl_mempool::vl_mempool(int64_t chunk_size, int64_t chunk_num)
: _chunks_list(NULL), _current_chunk(NULL), _chunk_size(chunk_size),
  _chunk_num(chunk_num), _used_chunk_num(0), _init(false)
    if(_chunk_size <= 0)
    {
    }
    if (_chunk_num <= 0)
    {
        _chunk_num = 0;
    }
vl_mempool::~vl_mempool()
    _destroy();
bool vl_mempool::init(void)
    bool retval = false;
    chunk_t* chunk_tmp = NULL;
    int64_t i = 0;
    if (!_init)
    {
        if (_chunk_num > 0)
        {
            _chunks_list = (chunk_t*)_alloc_chunk();
            if (NULL != _chunks_list)
            {
                _current_chunk = _chunks_list;
                for(i = 0; i < _chunk_num -1; i++)
                {
                    chunk_tmp = (chunk_t*)_alloc_chunk();
                    if (NULL == chunk_tmp)
                    {
                        break;
                    }
                    _current_chunk->_next = chunk_tmp;
                    _curren

                if(i == _chunk_num - 1)
                {
                    retval = true;
                }
        }
        else
        {
            _chunks_list = NULL;
            retval = true;
        }
        _init = retval;
        if(_init)
        {
            _current_chunk = _chunks_list;
        }
        else
        {
            _destroy();
        }
    }
    return _init;
void* vl_mempool::_alloc_chunk(void)
    chunk_t* chunk_tmp = NULL;
    chunk_tmp = (chunk_t*)malloc(sizeof(chunk_t));
    if (NULL != chunk_tmp)
    {
        chunk_tmp->_next = 0;
        chunk_tmp->_alloc_pos = 0;
        chunk_tmp->_data = malloc((size_t)_chunk_size);
        if (NULL == chunk_tmp->_data)
        {
            free(chunk_tmp);
            chunk_tmp = NULL;
        }
    }
    return chunk_tmp;
void vl_mempool::_reset_chunk(chunk_t* chunk, int64_t valid_pos)
    chunk_t* next_chunk = chunk;
    if(valid_pos < 0 || valid_pos > _chunk_size)
    {
        valid_pos = 0;
    }

    if (NULL != next_chunk)
    {
        next_chunk->_alloc_pos = valid_pos;
        while(NULL != (next_chunk = next_chunk->_next))
        {
            next_chunk->_alloc_pos = 0;
        }
    }
void vl_mempool::_destroy(void)
    chunk_t* chunk_tmp = NULL;
    while (NULL != _chunks_list)
    {
        chunk_tmp = _chunks_list;
        _chunks_list = _chunks_list->_next;
        if (NULL != chunk_tmp)
        {
            if(NULL != chunk_tmp->_data)
            {
                free(chunk_tmp->_data);
                chunk_tmp->_data = NULL;
            }
            free(chunk_tmp);
            chunk_tmp = NULL;
        }
    }
    _current_chunk = NULL;
    _chunk_num = 0;
    _used_chunk_num = 0;
int vl_mempool::reset(void)
    int retval = -1;
    if (_init)
    {
        _reset_chunk(_chunks_list);
        _current_chunk = _chunks_list;
        _used_chunk_num = 0;
        retval = 0;
    }
    return retval;
int vl_mempool::recycle(void)
    int retval = -1;
    if (_in
namespace ProxyModel{
Test::Test()
    EmptyModel = new QStandardItemModel;
    EmptyProxy = ProxyModel::Factory::produce(this);
    EmptyProxy->setSourceModel(EmptyModel);
    QStandardItemModel* model = new QStandardItemModel;
    model->setColumnCount(3);
    model->setRowCount(3);
    model->setData(model->index(0,0), 1);
    model->setData(model->index(0,1), 1);
    model->setData(model->index(0,2), "Root 1");
    model->setData(model->index(1,0), 2);
    model->setData(model->index(1,1), 1);
    model->setData(model->index(1,2), "Child");
    model->setData(model->index(2,0), 3);
    model->setData(model->index(2,1), 3);
    model->setData(model->index(2,2), "Root 2");
    PlainModel = model;    
    PlainProxy = ProxyModel::Factory::produce(this);
    PlainProxy->setSourceModel(PlainModel);
    model = new QStandardItemModel;
    model->setColumnCount(3);
    model->setRowCount(1);
    model->setData(model->index(0,0), 1);
    model->setData(model->index(0,1), 1);
    model->set
/*
 * $Id$
 *
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSet::RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","RepoIdSet",6);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::insert_id(RepoId key, RepoId value)
  DBG_ENTRY_LVL("RepoIdSet","insert_id",6);
  return OpenDDS::DCPS::bind(map_, key, value);
ACE_INLINE int
OpenDDS::DCPS::RepoIdSet::remove_id(RepoId id)
  DBG_ENTRY_LVL("RepoIdSet","remove_id",6);
  int result = unbind(map_, id);
  if (result != 0) {
    VDBG((LM_DEBUG, "(%P|%t) RepoId (%C) not found in map_.\n",
          LogGuid(id).c_str()));
  }
  return result;
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSet::size() const
  DBG_ENTRY_LVL("RepoIdSet","size",6);
  return map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map()
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this->map_;
ACE_INLINE const OpenDDS::DCPS::RepoIdSet::MapType&
OpenDDS::DCPS::RepoIdSet::map() const
  DBG_ENTRY_LVL("RepoIdSet","map",6);
  return this-
void int_handler_0();
void int_handler_1();
void int_handler_2();
void int_handler_3();
void int_handler_4();
void int_handler_5();
void int_handler_6();
void int_handler_7();
void int_handler_8();
void int_handler_9();
void int_handler_10();
void int_handler_11();
void int_handler_12();
void int_handler_13();
void int_handler_14();
void int_handler_15();
void int_handler_16();
void int_handler_17();
void int_handler_18();
void int_handler_19();
void int_handler_20();
void int_handler_21();
void int_handler_22();
void int_handler_23();
void int_handler_24();
void int_handler_25();
void int_handler_26();
void int_handler_27();
void int_handler_28();
void int_handler_29();
void int_handler_30();
void int_handler_31();
void int_handler_32();
void int_handler_33();
void int_handler_34();
void int_handler_35();
void int_handler_36();
void int_handler_37();
void int_handler_38();
void int_handler_39();
void int_handler_40();
void int_handler_41();
void int_handler_42();
void int_handler_43()

void int_handler_44();
void int_handler_45();
void int_handler_46();
void int_handler_47();
void int_handler_48();
void int_handler_49();
void int_handler_50();
void int_handler_51();
void int_handler_52();
void int_handler_53();
void int_handler_54();
void int_handler_55();
void int_handler_56();
void int_handler_57();
void int_handler_58();
void int_handler_59();
void int_handler_60();
void int_handler_61();
void int_handler_62();
void int_handler_63();
void int_handler_64();
void int_handler_65();
void int_handler_66();
void int_handler_67();
void int_handler_68();
void int_handler_69();
void int_handler_70();
void int_handler_71();
void int_handler_72();
void int_handler_73();
void int_handler_74();
void int_handler_75();
void int_handler_76();
void int_handler_77();
void int_handler_78();
void int_handler_79();
void int_handler_80();
void int_handler_81();
void int_handler_82();
void int_handler_83();
void int_handler_84();
void int_handler_85();
void int_handler_86();
void int_h

void int_handler_88();
void int_handler_89();
void int_handler_90();
void int_handler_91();
void int_handler_92();
void int_handler_93();
void int_handler_94();
void int_handler_95();
void int_handler_96();
void int_handler_97();
void int_handler_98();
void int_handler_99();
void int_handler_100();
void int_handler_101();
void int_handler_102();
void int_handler_103();
void int_handler_104();
void int_handler_105();
void int_handler_106();
void int_handler_107();
void int_handler_108();
void int_handler_109();
void int_handler_110();
void int_handler_111();
void int_handler_112();
void int_handler_113();
void int_handler_114();
void int_handler_115();
void int_handler_116();
void int_handler_117();
void int_handler_118();
void int_handler_119();
void int_handler_120();
void int_handler_121();
void int_handler_122();
void int_handler_123();
void int_handler_124();
void int_handler_125();
void int_handler_126();
void int_handler_127();
void int_handler_128();
void int_handler_129();
voi

void int_handler_131();
void int_handler_132();
void int_handler_133();
void int_handler_134();
void int_handler_135();
void int_handler_136();
void int_handler_137();
void int_handler_138();
void int_handler_139();
void int_handler_140();
void int_handler_141();
void int_handler_142();
void int_handler_143();
void int_handler_144();
void int_handler_145();
void int_handler_146();
void int_handler_147();
void int_handler_148();
void int_handler_149();
void int_handler_150();
void int_handler_151();
void int_handler_152();
void int_handler_153();
void int_handler_154();
void int_handler_155();
void int_handler_156();
void int_handler_157();
void int_handler_158();
void int_handler_159();
void int_handler_160();
void int_handler_161();
void int_handler_162();
void int_handler_163();
void int_handler_164();
void int_handler_165();
void int_handler_166();
void int_handler_167();
void int_handler_168();
void int_handler_169();
void int_handler_170();
void int_handler_171();
void int_handle

void int_handler_173();
void int_handler_174();
void int_handler_175();
void int_handler_176();
void int_handler_177();
void int_handler_178();
void int_handler_179();
void int_handler_180();
void int_handler_181();
void int_handler_182();
void int_handler_183();
void int_handler_184();
void int_handler_185();
void int_handler_186();
void int_handler_187();
void int_handler_188();
void int_handler_189();
void int_handler_190();
void int_handler_191();
void int_handler_192();
void int_handler_193();
void int_handler_194();
void int_handler_195();
void int_handler_196();
void int_handler_197();
void int_handler_198();
void int_handler_199();
void int_handler_200();
void int_handler_201();
void int_handler_202();
void int_handler_203();
void int_handler_204();
void int_handler_205();
void int_handler_206();
void int_handler_207();
void int_handler_208();
void int_handler_209();
void int_handler_210();
void int_handler_211();
void int_handler_212();
void int_handler_213();
void int_handle

void int_handler_215();
void int_handler_216();
void int_handler_217();
void int_handler_218();
void int_handler_219();
void int_handler_220();
void int_handler_221();
void int_handler_222();
void int_handler_223();
void int_handler_224();
void int_handler_225();
void int_handler_226();
void int_handler_227();
void int_handler_228();
void int_handler_229();
void int_handler_230();
void int_handler_231();
void int_handler_232();
void int_handler_233();
void int_handler_234();
void int_handler_235();
void int_handler_236();
void int_handler_237();
void int_handler_238();
void int_handler_239();
void int_handler_240();
void int_handler_241();
void int_handler_242();
void int_handler_243();
void int_handler_244();
void int_handler_245();
void int_handler_246();
void int_handler_247();
void int_handler_248();
void int_handler_249();
void int_handler_250();
void int_handler_251();
void int_handler_252();
void int_handler_253();
void int_handler_254();
void int_handler_255();
void idt_init()
namespace verihy {
void* mem_list::get() {
    mem_chunk *chunk = nullptr;
    if (available){
        chunk = available;
        if (available->next){
            available->next->prev = nullptr;
        }
        available = available->next;
    } else{
        chunk = reinterpret_cast<mem_chunk*>(new unsigned char[size + extra_size]);
        chunk->size = size;
    }
    if (used){
        used->prev = chunk;
    }
    chunk->next = used;
    chunk->prev = nullptr;
    used = chunk;
    return chunk + sizeof(chunk);
void mem_list::put(mem_chunk *chunk) {
    if (chunk){
        auto prev = chunk->prev;
        auto nxt = chunk->next;
        if (nxt){
            nxt->prev = chunk->prev;
        }
        if (prev){
            prev->next = chunk->next;
        } else {
            used = chunk->next;
        }
        if (available){
            available->prev = chunk;
        }
        chunk->next = available;
        available = chunk;
    }
void mem_list::free_chunklist(mem_ch
GnImplementRTTI(GnExtraData, GnObject);
void GnExtraData::LoadStream(GnObjectStream* pStream)
	GnObject::LoadStream( pStream );
	pStream->LoadStream( mID );
	pStream->LoadStream( mType );
void GnExtraData::LinkObject(GnObjectStream* pStream)
	GnObject::LinkObject( pStream );
void GnExtraData::SaveStream(GnObjectStream* pStream)
	GnObject::SaveStream( pStream );
	pStream->SaveStream( mID );
	pStream->SaveStream( mType );
void GnExtraData::RegisterSaveObject(GnObjectStream* pStream)
	GnObject::RegisterSaveObject( pStream );
GnImplementRTTI(GnIntExtraData, GnExtraData);
GnImplementCreateObject(GnIntExtraData);
void GnIntExtraData::LoadStream(GnObjectStream* pStream)
	GnExtraData::LoadStream( pStream );
	pStream->LoadStream( mVal );
void GnIntExtraData::LinkObject(GnObjectStream* pStream)
	GnExtraData::LinkObject( pStream );
void GnIntExtraData::SaveStream(GnObjectStream* pStream)
	GnExtraData::SaveStream( pStream );
	pStream->SaveStream( mVal );
void GnIntExtraData::RegisterSaveObject(GnO
using namespace bb::cascades;
using namespace bb::system;
NSRFileSharer::NSRFileSharer () :
	QObject (NULL)
NSRFileSharer *
NSRFileSharer::getInstance ()
	static NSRFileSharer *sharer = NULL;
	if (sharer == NULL)
		sharer = new NSRFileSharer ();
	return sharer;
void
NSRFileSharer::shareFiles (const QStringList& list)
	if (list.isEmpty ())
		return;
	QUrl	uri;
	QString	data;
	QString	mimeType;
	if (list.count () == 1) {
		QString	extension = QFileInfo(list.first ()).suffix().toLower ();
		if (extension == "pdf")
			mimeType = "application/pdf";
		else if (extension == "djvu" || extension == "djv")
			mimeType = "image/vnd.djvu";
		else if (extension == "tiff" || extension == "tif")
			mimeType = "image/tiff";
		else
			mimeType = "text/plain";
		uri = QUrl::fromLocalFile (list.first ());
	} else {
		mimeType = "filelist/mixed";
		int count = list.count ();
		for (int i = 0; i < count; ++i)
		data = "[ " + data.left (data.count () - 1) + " ]";
	}
	Invocation *invocation = Invocation::cre

									  .uri(uri)
									  .data(data.toUtf8 ())
									  .mimeType(mimeType));
	bool ok = connect (invocation, SIGNAL (armed ()), this, SLOT (onArmed ()));
	Q_UNUSED (ok);
	Q_ASSERT (ok);
	ok = connect (invocation, SIGNAL (finished ()), invocation, SLOT (deleteLater ()));
	Q_ASSERT (ok);
bool
NSRFileSharer::isSharable (const QString& path)
	return !path.startsWith ("app/native/assets", Qt::CaseSensitive);
void
NSRFileSharer::invokeUri (const QString& uri, const QString& target, const QString& action)
	InvokeManager		invokeManager;
	InvokeRequest		invokeRequest;
	InvokeTargetReply	*invokeReply;
	invokeRequest.setUri (QUrl (uri));
	invokeRequest.setAction (action);
	invokeRequest.setTarget (target);
	invokeReply = invokeManager.invoke (invokeRequest);
	if (invokeReply != NULL) {
		invokeReply->setParent (this);
		bool ok = connect (invokeReply, SIGNAL (finished ()), invokeReply, SLOT (deleteLater ()));
		Q_UNUSED (ok);
		Q_ASSERT (ok);
	}
void
NSRFileSharer::onArmed ()
	if (send
namespace gin {
typedef V8Test V8MemoryDumpProviderTest;
TEST_F(V8MemoryDumpProviderTest, DumpStatistics) {
  const char track_objects_flag[] = "--track-gc-object-stats";
  v8::V8::SetFlagsFromString(track_objects_flag,
                             static_cast<int>(strlen(track_objects_flag)));
  std::unique_ptr<base::trace_event::ProcessMemoryDump> process_memory_dump(
      new base::trace_event::ProcessMemoryDump(nullptr));
  base::trace_event::MemoryDumpArgs dump_args = {
      base::trace_event::MemoryDumpLevelOfDetail::DETAILED};
  instance_->isolate_memory_dump_provider_for_testing()->OnMemoryDump(
      dump_args, process_memory_dump.get());
  const base::trace_event::ProcessMemoryDump::AllocatorDumpsMap&
      allocator_dumps = process_memory_dump->allocator_dumps();
  bool did_dump_isolate_stats = false;
  bool did_dump_space_stats = false;
  bool did_dump_objects_stats = false;
  for (const auto& it : allocator_dumps) {
    const std::string& dump_name = it.first;
    if (du
/*
 * BaseLocator.cpp - Methods for BaseLocator class.
 * 
 * Author: Patrick O'Leary
 * Created: October 17, 2010
 * Copyright: 2010. All rights reserved.
 */
/*
 * BaseLocator
 * 
 * parameter _locatorTool - Vrui::LocatorTool*
 * parameter _pointe_samhlaigh - Pointe_Samhlaigh*
 */
BaseLocator::BaseLocator(Vrui::LocatorTool* _locatorTool, Pointe_Samhlaigh* _pointe_samhlaigh) :
    Vrui::LocatorToolAdapter(_locatorTool) {
    pointe_samhlaigh = _pointe_samhlaigh;
/*
 * ~BaseLocator - Destructor
 */
BaseLocator::~BaseLocator(void) {
    pointe_samhlaigh = 0;
/*
 * highlightLocator - Render actual locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::highlightLocator(GLContextData& glContextData) const {
/*
 * glRenderAction - Render opaque elements of locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::glRenderAction(GLContextData& glContextData) const {
/*
 * glRenderActionTransparent - Render transparent elements of locator
 * 
 * para
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
file_save_gen_class::generate_file_save(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (check_given)
    {
      stream << "if (args_info->";
      generate_string (given, stream, indent + indent_str.length ());
      stream << ") {";
      stream << "\n";
      stream << indent_str;
    }
  if (has_arg)
    {
      stream << "  if (args_info->";
      generate_string (arg, stream, indent + indent_str.length ());
      stream << ") {";
      stream << "\n";
      stream << indent_str;
      stream << "    fprintf(outfile, \"%s=\\\"%s\\\"\\n\", \"";
      generate_string (opt_name, stream, indent + indent_str.length ());
      stream << "\", args_info->";
      generate_string (arg, stream, indent + indent_str.length ());
      stream << ");";
      stream << "\n";
      stream << indent_str;
      stream << "  } else {";
      stream << "\n";
      stream << ind
    if (keys['J'])                                                                                                                      
    {                                                                                                                                   
             moveModel[0]         -=  .01;                                                                                              
    }	                                                                                                                                  
    if (keys['L'])                                                                                                                      
    {	                                                                                                                                  
             moveModel[0]         +=  .01;                                                                                              
    }                                    

    if (keys['I'])                                                                                                                      
    {	                                                                                                                                  
             moveModel[1]         +=  .01;                                                                                              
    }	                                                                                                                                  
    if (keys['K'])                                                                                                                      
    {	                                                                                                                                  
             moveModel[1]         -=  .01;                                                                                              
    }                                   

    if (keys['O'])                                                                                                                      
    {	                                                                                                                                  
             moveModel[2]         +=  .01;                                                                                              
    }	                                                                                                                                  
    if (keys['U'])                                                                                                                      
    {	                                                                                                                                  
             moveModel[2]         -=  .01;                                                                                              
    }                                   
 *
 * @file l2.hpp
 *
namespace madlib {
namespace modules {
namespace convex {
using namespace madlib::dbal::eigen_integration;
template <class Model, class Hessian = Matrix>
class L2 {
public:
    typedef Model model_type;
    typedef Hessian hessian_type;
    static double lambda;
    static int n_tuples;
    static void gradient(
            const model_type &model,
            model_type &gradient);
    static void scaling(
            model_type &model,
            const double &stepsize);
    static void hessian(
            const model_type &model,
            hessian_type &hessian);
    static double loss(
            const model_type &model);
};
template <class Model, class Hessian>
double
L2<Model, Hessian>::lambda = 0.;
template <class Model, class Hessian>
int
L2<Model, Hessian>::n_tuples = 1;
template <class Model, class Hessian>
void
L2<Model, Hessian>::gradient(
        const model_type &model,
        model_type &gradient) {
    gradient += lambda * model;
template <cl
using namespace std;
template <typename T, int32_t ChunkSizeXV = 16, int32_t ChunkSizeYV = 16, int32_t ChunkSizeZV = 16, bool TransmitCompressedV = true>
struct BlockChunk
    const PositionI basePosition;
    static constexpr int32_t chunkSizeX = ChunkSizeXV;
    static constexpr int32_t chunkSizeY = ChunkSizeYV;
    static constexpr int32_t chunkSizeZ = ChunkSizeZV;
    static_assert(chunkSizeX > 0, "chunkSizeX must be positive");
    static_assert(chunkSizeY > 0, "chunkSizeY must be positive");
    static_assert(chunkSizeZ > 0, "chunkSizeZ must be positive");
    static_assert((chunkSizeX & (chunkSizeX - 1)) == 0, "chunkSizeX must be a power of 2");
    static_assert((chunkSizeY & (chunkSizeY - 1)) == 0, "chunkSizeY must be a power of 2");
    static_assert((chunkSizeZ & (chunkSizeZ - 1)) == 0, "chunkSizeZ must be a power of 2");
    static constexpr bool transmitCompressed = TransmitCompressedV;
    mutable ChangeTracker changeTracker;
    constexpr BlockChunk(PositionI basePositio

        : basePosition(basePosition)
    {
    }
    static constexpr PositionI getChunkBasePosition(PositionI pos)
    {
        return PositionI(pos.x & ~(chunkSizeX - 1), pos.y & ~(chunkSizeY - 1), pos.z & ~(chunkSizeZ - 1), pos.d);
    }
    static constexpr PositionI getChunkRelativePosition(PositionI pos)
    {
        return PositionI(pos.x & (chunkSizeX - 1), pos.y & (chunkSizeY - 1), pos.z & (chunkSizeZ - 1), pos.d);
    }
    array<array<array<T, chunkSizeZ>, chunkSizeY>, chunkSizeX> blocks;
    BlockChunk(const BlockChunk & rt)
        : basePosition(rt.basePosition), blocks(rt.blocks)
    {
        changeTracker.onChange();
    }
private:
    static void readInternal(shared_ptr<BlockChunk> chunk, stream::Reader &reader, VariableSet &variableSet)
    {
        for(int32_t x = 0; x < chunkSizeX; x++)
        {
            for(int32_t y = 0; y < chunkSizeY; y++)
            {
                for(int32_t z = 0; z < chunkSizeZ; z++)
                {
                    chunk->

                }
            }
        }
    }
    void writeInternal(stream::Writer &writer, VariableSet &variableSet) const
    {
        for(int32_t x = 0; x < chunkSizeX; x++)
        {
            for(int32_t y = 0; y < chunkSizeY; y++)
            {
                for(int32_t z = 0; z < chunkSizeZ; z++)
                {
                    stream::write<T>(writer, variableSet, blocks[x][y][z]);
                }
            }
        }
        changeTracker.onWrite(variableSet);
    }
    static bool checkPosition(PositionI p)
    {
        return p.x % chunkSizeX == 0 && p.y % chunkSizeY == 0 && p.z % chunkSizeZ == 0;
    }
    static void readTemplateParameters(stream::Reader &reader)
    {
        stream::read_limited<int32_t>(reader, chunkSizeX, chunkSizeX);
        stream::read_limited<int32_t>(reader, chunkSizeY, chunkSizeY);
        stream::read_limited<int32_t>(reader, chunkSizeZ, chunkSizeZ);
        stream::read_checked<bool>(reader, [](bool v){return v == transmitC

    }
    static void writeTemplateParameters(stream::Writer &writer)
    {
        stream::write<int32_t>(writer, chunkSizeX);
        stream::write<int32_t>(writer, chunkSizeY);
        stream::write<int32_t>(writer, chunkSizeZ);
        stream::write<bool>(writer, transmitCompressed);
    }
public:
    static shared_ptr<BlockChunk> read(stream::Reader &reader, VariableSet &variableSet)
    {
        PositionI basePosition = stream::read_checked<PositionI>(reader, checkPosition);
        readTemplateParameters(reader);
        shared_ptr<BlockChunk> retval = shared_ptr<BlockChunk>(new BlockChunk(basePosition));
        if(transmitCompressed)
        {
            stream::ExpandReader expandReader(reader);
            readInternal(retval, expandReader, variableSet);
        }
        else
            readInternal(retval, reader, variableSet);
        return retval;
    }
    void write(stream::Writer &writer, VariableSet &variableSet) const
    {
        stream::write<PositionI>(writ
namespace CUtil
{ 
	void* ChunkData::operator new (size_t size , UINT32 extra)
	{ 
		return malloc(size + extra);
	}
	void  ChunkData::operator delete (void *p , UINT32 extra)
	{ 
		free(p); 
	}
/*		, m_pBuf(NULL)*/
/*		, m_bMustRelease(TRUE)*/
	bool ChunkData::operator ==(const ChunkData & objChunk) const
	{
		if (objChunk.GetDataLen() == m_unDataLen && !memcmp(this->GetData() , objChunk.GetData() , m_unDataLen))
		{
			return true;
		}
		return false;
	}
	bool ChunkData::operator !=(const ChunkData & objChunk) const
	{
		if (objChunk.GetDataLen() != m_unDataLen || memcmp(this->GetData() , objChunk.GetData() , m_unDataLen))
		{
			return true;
		}
		return false;
	}
	ChunkData	* ChunkData::Reverse(UINT32 unSize)
	{
		if (m_refCount >= 0 || unSize > m_unSize)
		{
			unSize = FitSize(unSize);
			if (unSize > m_unSize)
			{
				ChunkData * pBuf = Create(unSize);
				memcpy(pBuf->GetData() , this->GetData() , pBuf->m_unDataLen = m_unDataLen);
				DecRef();
				return pBuf;
			}
		}
		retu

	}
	UINT32 ChunkData::FitSize(UINT32 unSize)
	{
		UINT32 unTmp = 8;
		while (unSize > unTmp)
		{
			unTmp <<= 1;
		}
		return unTmp;
	}
	ChunkData	* ChunkData::Create(UINT32 unSize)
	{ 
		ChunkData * pData = new (unSize) ChunkData;
		pData->m_unSize = unSize;
		pData->m_unDataLen = 0;
		pData->AddRef();
		return pData;
	}
	void * ChunkData::Insert(void * pPos , void * pBegin , UINT32 unLen)
	{
		PtrDiff off = (char *)pPos - (char *)GetData();
		ChunkData * pData = Reverse(m_unDataLen + unLen);
		MsgAssert_Re0(pData , "no space.");
		pPos = (char *)(pData->GetData()) + off;
		if (unAdjust)
		{
			FastMemmove((char *)pPos + unLen , pPos , unAdjust);
		}
		FastMemmove((char *)pPos , pBegin , unLen);
		pData->m_unDataLen += unLen;
		return pData->GetData();
	}
	void * ChunkData::Pushback(void * pBegin , UINT32 unLen)
	{
		ChunkData * pData = Reverse(m_unDataLen + unLen);
		FastMemmove((char *)(pData->GetData())+ pData->m_unDataLen , pBegin , unLen);
		pData->m_unDataLen += unLen;
		return

	}
	void    * ChunkData::End(void)
	{
		return (char *)GetData() + m_unDataLen;
	}
	void    * ChunkData::Begin(void)
	{
		return (void*)this;
	}
	ChunkData   & ChunkData::Erase(void * pBegin , void * pEnd)
	{
		if (pBegin != pEnd)
		{
			FastMemmove(pBegin , pEnd , ((char *)GetData() + m_unDataLen ) - (char *)pBegin);
			m_unDataLen = m_unDataLen - (UINT32)((char*)pEnd - (char*)pBegin);
			MsgAssert_Re(m_unDataLen >= 0 , *this ,"chunk erase so long.");
		}
		return *this;
	}
	void ChunkData::Clear(void)
	{ 
		memset((char*)(this+1) , 0 , m_unDataLen);
		m_unDataLen = 0;
	}
	void ChunkData::AddRef(void)
	{
		if (m_refCount >= 0)
		{
			++m_refCount;
		}
	}
	void ChunkData::DecRef(void)
	{
		if (m_refCount > 0)
		{
			--m_refCount;
			if (m_unSize != 0 && m_refCount == 0)
			{
				delete((void*)this);
			}
		}
	}
	ChunkData	& ChunkData::Null()
	{
		static ChunkData s_null(-1);
		return s_null;
	}
	Chunk::Chunk(const Chunk & objChunk)
		: m_pData(objChunk.m_pData)
	{
		GetChunkData()->Ad

	}
	Chunk	& Chunk::operator=(const Chunk & objChunk)
	{
		if (&objChunk != this)
		{
			this->GetChunkData()->DecRef();
			m_pData = objChunk.m_pData;
			GetChunkData()->AddRef();
		}
		return * this;
	}
	bool Chunk::operator!=(const Chunk & objChunk) const
	{ 
		return *GetChunkData() != (*objChunk.GetChunkData());
	}
	bool Chunk::operator==(const Chunk & objChunk) const
	{
		return *GetChunkData() == (*objChunk.GetChunkData());
	}
	Chunk & Chunk::Insert(void * pPos , void * pBegin , UINT32 unLen)
	{
		m_pData = GetChunkData()->Insert(pPos , pBegin , unLen);
		return * this;
	}
	Chunk & Chunk::Pushback(void * pBegin , UINT32 unLen)
	{
		m_pData = GetChunkData()->Pushback(pBegin , unLen);
		return * this;
	}
	Chunk & Chunk::Erase(void * pBegin , void * pEnd)
	{ 
		GetChunkData()->Erase(pBegin , pEnd);
		return * this;
	}
	Chunk & Chunk::Reverse(UINT32 unSize)
	{
		m_pData = GetChunkData()->Reverse(unSize)->GetData();
		return * this;
	}
	void * Chunk::Begin(void)
	{
		return m_pData;

using namespace UnitTest;
using namespace std;
namespace {
TEST(DefaultIsEmptyString)
    MemoryOutStream const stream;
    CHECK(stream.GetText() != 0);
    CHECK_EQUAL("", stream.GetText());
TEST(StreamingTextCopiesCharacters)
    MemoryOutStream stream;
    stream << "Lalala";
    CHECK_EQUAL("Lalala", stream.GetText());
TEST(StreamingMultipleTimesConcatenatesResult)
    MemoryOutStream stream;
    stream << "Bork" << "Foo" << "Bar";
    CHECK_EQUAL("BorkFooBar", stream.GetText());
TEST(StreamingIntWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << (int)123;
    CHECK_EQUAL("123", stream.GetText());
TEST(StreamingUnsignedIntWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << (unsigned int)123;
    CHECK_EQUAL("123", stream.GetText());
TEST(StreamingLongWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << (long)(-123);
    CHECK_EQUAL("-123", stream.GetText());
TEST(StreamingUnsignedLongWritesCorrectCharacters)
    MemoryOutStream stream;


    CHECK_EQUAL("123", stream.GetText());
TEST(StreamingFloatWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << 3.1415f;
    CHECK(strstr(stream.GetText(), "3.1415"));
TEST(StreamingDoubleWritesCorrectCharacters)
    MemoryOutStream stream;
    stream << 3.1415;
    CHECK(strstr(stream.GetText(), "3.1415"));
TEST(StreamingPointerWritesCorrectCharacters)
    MemoryOutStream stream;
    int* p = (int*)0x1234;
    stream << p;
    CHECK(strstr(stream.GetText(), "1234"));
TEST(StreamingSizeTWritesCorrectCharacters)
    MemoryOutStream stream;
    size_t const s = 53124;
    stream << s;
    CHECK_EQUAL("53124", stream.GetText());
TEST(StreamInitialCapacityIsCorrect)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    CHECK_EQUAL((int)MemoryOutStream::GROW_CHUNK_SIZE, stream.GetCapacity());
TEST(StreamInitialCapacityIsMultipleOfGrowChunkSize)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE + 1);
    CHECK_EQUAL((int)MemoryOutStream::GROW_CHUNK_SIZE

TEST(ExceedingCapacityGrowsBuffer)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    stream << "012345678901234567890123456789";
    char const* const oldBuffer = stream.GetText();
    stream << "0123456789";
    CHECK(oldBuffer != stream.GetText());
TEST(ExceedingCapacityGrowsBufferByGrowChunk)
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    stream << "0123456789012345678901234567890123456789";
    CHECK_EQUAL(MemoryOutStream::GROW_CHUNK_SIZE * 2, stream.GetCapacity());
TEST(WritingStringLongerThanCapacityFitsInNewBuffer)
    MemoryOutStream stream(8);
    stream << "0123456789ABCDEF";
    CHECK_EQUAL("0123456789ABCDEF", stream.GetText());
TEST(WritingIntLongerThanCapacityFitsInNewBuffer)
    MemoryOutStream stream(8);
    stream << "aaaa" << 123456;;
    CHECK_EQUAL("aaaa123456", stream.GetText());
TEST(WritingFloatLongerThanCapacityFitsInNewBuffer)
    MemoryOutStream stream(8);
    stream << "aaaa" << 123456.0f;;
    CHECK_EQUAL("aaaa123456.000000
struct ISampleA
    virtual void showA() = 0;
};
struct ISampleAImpl
    :public ISampleA
    void* self;
    void showA();
};
void ISampleAImpl::showA()
    lua_State* L;
    
    luaL_setmetatable(L, "ISampleA");
    
struct ISampleB
    virtual void showB() = 0;
};
struct ISampleC
    virtual void showC() = 0;
};
class SampleA
    :public framework::Component, ISampleA
    virtual void showA();
    
public:
    static int luaShowA(lua_State* L);
};
int SampleA::luaShowA(lua_State *L)
    SampleA* self = (SampleA*)luaL_testudata(L, 1, "SampleA");
    
    self->showA();
    return 0;
static struct luaL_Reg sSampleA_Facade_ISampleA[] = {
    {"showA", &SampleA::luaShowA},
    {NULL,NULL}
};
class SampleB
    :public framework::Component, ISampleB
    virtual void showB();
};
class SampleC
    :public framework::Component
public:
    SampleC();
private:
    SampleA*    m_sampleA;
    SampleB*    m_sampleB;
    ISampleC*   m_ISampleC;
};
SampleC::SampleC()
    m_sampleA = new SampleA;
 
/*
 * per_array_chunk_list.cpp
 *
 *  Created on: Jul 21, 2015
 *      Author: basbas
 */
namespace sip {
std::ostream& operator<<(std::ostream& os, const Chunk& obj){
	os << "data_: " << obj.data_;
	os << ", file_offset_: " << obj.file_offset_;
	os << " num_allocated_doubles_: "<< obj.num_allocated_doubles_;
	os << " valid_on_disk_: " << obj. valid_on_disk_;
	os << std::endl;
	return os;
size_t ChunkManager::new_chunk() {
	double* chunk_data = new double[chunk_size_];
    int chunk_number = chunks_.size();
	SIPMPIAttr& mpi_attr = SIPMPIAttr::get_instance();
	int num_servers = mpi_attr.company_size();
	int rank = mpi_attr.company_rank();
	offset_val_t offset = (num_servers*chunk_number + rank) * chunk_size_;
	chunks_.push_back(Chunk(chunk_data, chunk_size_, offset, false));
	return chunk_size_;
size_t ChunkManager::assign_block_data_from_chunk(size_t num_doubles, bool initialize,
		int& chunk_number, size_t& offset){
	size_t num_newly_allocated = 0;
	if (chunk_it == chunks_.rend() || (
namespace media {
int SampleFormatToBytesPerChannel(SampleFormat sample_format) {
  switch (sample_format) {
    case kUnknownSampleFormat:
      return 0;
    case kSampleFormatU8:
      return 1;
    case kSampleFormatS16:
    case kSampleFormatPlanarS16:
      return 2;
    case kSampleFormatS32:
    case kSampleFormatF32:
    case kSampleFormatPlanarF32:
      return 4;
    case kSampleFormatMax:
      break;
  }
  NOTREACHED() << "Invalid sample format provided: " << sample_format;
  return 0;
const char* SampleFormatToString(SampleFormat sample_format) {
  switch(sample_format) {
    case kUnknownSampleFormat:
      return "Unknown sample format";
    case kSampleFormatU8:
      return "Unsigned 8-bit with bias of 128";
    case kSampleFormatS16:
      return "Signed 16-bit";
    case kSampleFormatS32:
      return "Signed 32-bit";
    case kSampleFormatF32:
      return "Float 32-bit";
    case kSampleFormatPlanarS16:
      return "Signed 16-bit planar";
    case kSampleFormatPl
namespace ld3d
	namespace voxel
	{
		
		class ChunkManager : public std::enable_shared_from_this<ChunkManager>
		{
		public:
			typedef std::list<ChunkPtr, std_allocator_adapter<ChunkPtr>>	DirtyChunkList;
			ChunkManager(void);
			virtual ~ChunkManager(void);
			bool											AddBlock(const Coord& c, uint8 type);
			bool											ReplaceBlock(const Coord& c, uint8 type);
			bool											RemoveBlock(const Coord& c);
			bool											IsEmpty(const Coord& c);
			uint8											GetBlock(const Coord& c);
			void											UpdateBlock(const Coord& c);
			ChunkPtr										FindChunk(const ChunkKey& key, bool& loaded);
			const DirtyChunkList&							GetDirtyChunks() const;
			void											ClearDirtyChunks();
			void											Clear();
			ChunkPtr										CreateChunk(const ChunkKey& key, const ChunkData& data);
			bool											AddChunk(const ChunkKey& chunk_key, ChunkPtr pChunk = nullptr);
			bool											AddChunk(ChunkPtr pChunk);
			void											RemoveChunk(const ChunkKey& key)

			void											RemoveChunk(ChunkPtr pChunk);
			void											Update(float dt);
			void											AddDirtyChunkHandler(const std::function<void (ChunkPtr)>& handler);
			uint32											GetChunkCount() const;
			void											PickChunk(const Coord& center, uint32 radius, uint32 height, const std::function<void(const ChunkKey&)>& op);
			void											PickAdjacentChunks(const ChunkKey& key, const std::function<void(const ChunkKey& , ChunkPtr, bool)>& op);
			void											PickSurroundingChunks(const ChunkKey& key, const std::function<void(const ChunkKey& , ChunkPtr, bool)>& op);
		private:
			void											Spiral(uint32 w, uint32 h, const std::function<void(int32, int32)>& op);
		private:
			typedef 
				std::unordered_map<uint64, 
				ChunkPtr, 
				std::hash<uint64>, 
				std::equal_to<uint64>,
				std_allocator_adapter<
				std::pair<uint64, ChunkPtr>
				>>											ChunkMap;										
			ChunkMap										m_chunkmap;
			DirtyChunkList									m_dirtyList;
			Bound							
/*
 * Copyright (c) 2011-2013, Ingo Weinhold <ingo_weinhold@gmx.de>
 *
 * This program is licensed under the BSD license, read LICENSE.BSD
 * for further information
 */
using namespace BPackageKit;
using namespace BPackageKit::BHPKG;
static void add_dependency(Repo *repo, Offset &dependencies, const char *name,
  const char *version, int flags, const char* compatVersion = NULL)
  Pool *pool = repo->pool;
  Id dependency = pool_str2id(pool, name, 1);
  if (version && version[0] != '\0')
  {
    Id versionId = pool_str2id(pool, version, 1);
    if (compatVersion && compatVersion[0] != '\0')
      {
        versionId = pool_rel2id(pool, versionId, pool_str2id(pool, compatVersion, 1),
          REL_COMPAT, 1);
      }
    dependency = pool_rel2id(pool, dependency, versionId, flags, 1);
  }
  dependencies = repo_addid_dep(repo, dependencies, dependency, 0);
static void add_dependency(Repo *repo, Offset &dependencies, const char *name,
  const BPackageVersion &version, int flags)
  add_depe

    flags);
static void add_resolvables(Repo *repo, Offset &dependencies,
  const BObjectList<BPackageResolvable> &resolvables)
  for (int32 i = 0; BPackageResolvable *resolvable = resolvables.ItemAt(i); i++)
    {
      add_dependency(repo, dependencies, resolvable->Name(),
        resolvable->Version().ToString(), REL_EQ,
        resolvable->CompatibleVersion().ToString());
    }
static void add_resolvable_expressions(Repo *repo, Offset &dependencies,
  const BObjectList<BPackageResolvableExpression> &expressions)
  for (int32 i = 0;
    BPackageResolvableExpression *expression = expressions.ItemAt(i); i++)
    {
      if (expression->Version().InitCheck() != B_OK)
        {
          BPackageVersion version;
          add_dependency(repo, dependencies, expression->Name(), NULL, 0);
          continue;
        }
      int flags = 0;
      switch (expression->Operator())
        {
          case B_PACKAGE_RESOLVABLE_OP_LESS:
            flags |= REL_LT;
            break;
          c

            flags |= REL_LT | REL_EQ;
            break;
          case B_PACKAGE_RESOLVABLE_OP_EQUAL:
            flags |= REL_EQ;
            break;
          case B_PACKAGE_RESOLVABLE_OP_NOT_EQUAL:
            break;
          case B_PACKAGE_RESOLVABLE_OP_GREATER_EQUAL:
            flags |= REL_GT | REL_EQ;
            break;
          case B_PACKAGE_RESOLVABLE_OP_GREATER:
              flags |= REL_GT;
            break;
        }
      add_dependency(repo, dependencies, expression->Name(),
        expression->Version(), flags);
    }
static void add_replaces_list(Repo *repo, Offset &dependencies,
  const BStringList &packageNames)
  int32 count = packageNames.CountStrings();
  for (int32 i = 0; i < count; i++)
    {
      const BString &packageName = packageNames.StringAt(i);
      add_dependency(repo, dependencies, packageName, BPackageVersion(), 0);
    }
static Id add_package_info_to_repo(Repo *repo, Repodata *repoData,
  const BPackageInfo &packageInfo)
  Pool *pool = repo->p

  Id solvableId = repo_add_solvable(repo);
  Solvable *solvable = pool_id2solvable(pool, solvableId);
  BString name("pkg:");
  name << packageInfo.Name();
  solvable->name = pool_str2id(pool, name, 1);
  if (packageInfo.Architecture() == B_PACKAGE_ARCHITECTURE_ANY)
    solvable->arch = ARCH_ANY;
  else if (packageInfo.Architecture() == B_PACKAGE_ARCHITECTURE_SOURCE)
    solvable->arch = ARCH_SRC;
  else
    solvable->arch = pool_str2id(pool,
      BPackageInfo::kArchitectureNames[packageInfo.Architecture()], 1);
  solvable->evr = pool_str2id(pool, packageInfo.Version().ToString(), 1);
  solvable->vendor = pool_str2id(pool, packageInfo.Vendor(), 1);
  repodata_set_str(repoData, solvable - pool->solvables, SOLVABLE_SUMMARY,
    packageInfo.Summary());
  repodata_set_str(repoData, solvable - pool->solvables, SOLVABLE_DESCRIPTION,
    packageInfo.Description());
  repodata_set_str(repoData, solvable - pool->solvables, SOLVABLE_PACKAGER,
    packageInfo.Packager());
  if (!packageInfo.Che

    repodata_set_checksum(repoData, solvable - pool->solvables,
      SOLVABLE_CHECKSUM, REPOKEY_TYPE_SHA256, packageInfo.Checksum());
  solvable->provides = repo_addid_dep(repo, solvable->provides,
    pool_rel2id(pool, solvable->name, solvable->evr, REL_EQ, 1), 0);
  add_resolvables(repo, solvable->provides, packageInfo.ProvidesList());
  add_resolvable_expressions(repo, solvable->requires,
    packageInfo.RequiresList());
  add_resolvable_expressions(repo, solvable->supplements,
    packageInfo.SupplementsList());
  add_resolvable_expressions(repo, solvable->conflicts,
    packageInfo.ConflictsList());
  add_resolvable_expressions(repo, solvable->enhances,
    packageInfo.FreshensList());
  add_replaces_list(repo, solvable->obsoletes, packageInfo.ReplacesList());
  return solvableId;
static void add_installed_packages(Repo *repo, Repodata *repoData,
  BPackageInstallationLocation location)
  BPackageRoster roster;
  BPackageInfoSet packageInfos;
  if (roster.GetActivePackages(locat

    {
      BRepositoryCache::Iterator it = packageInfos.GetIterator();
      while (const BPackageInfo *packageInfo = it.Next())
        add_package_info_to_repo(repo, repoData, *packageInfo);
    }
int repo_add_haiku_installed_packages(Repo *repo, const char *rootdir,
  int flags)
  Repodata *repoData = repo_add_repodata(repo, flags);
  add_installed_packages(repo, repoData,
    B_PACKAGE_INSTALLATION_LOCATION_SYSTEM);
  add_installed_packages(repo, repoData, B_PACKAGE_INSTALLATION_LOCATION_HOME);
  if (!(flags & REPO_NO_INTERNALIZE))
    repodata_internalize(repoData);
  return 0;
Id repo_add_haiku_package(Repo *repo, const char *hpkgPath, int flags)
  BPackageInfo packageInfo;
  if (packageInfo.ReadFromPackageFile(hpkgPath) != B_OK)
    return 0;
  return repo_add_haiku_package_info(repo, packageInfo, flags);
int repo_add_haiku_packages(Repo *repo, const char *repoName, int flags)
  BPackageRoster roster;
  BRepositoryCache cache;
  if (roster.GetRepositoryCache(repoName, &cache) 
namespace urchin
	SoundSphereReaderWriter::SoundSphereReaderWriter()
	{
	}
	SoundSphereReaderWriter::~SoundSphereReaderWriter()
	{
	}
	SoundShape *SoundSphereReaderWriter::loadFrom(std::shared_ptr<XmlChunk> shapeChunk, const XmlParser &xmlParser) const
	{
		std::shared_ptr<XmlChunk> radiusChunk = xmlParser.getUniqueChunk(true, RADIUS_TAG, XmlAttribute(), shapeChunk);
		float radius = radiusChunk->getFloatValue();
		std::shared_ptr<XmlChunk> positionChunk = xmlParser.getUniqueChunk(true, POSITION_TAG, XmlAttribute(), shapeChunk);
		Point3<float> position = positionChunk->getPoint3Value();
		std::shared_ptr<XmlChunk> marginChunk = xmlParser.getUniqueChunk(true, MARGIN_TAG, XmlAttribute(), shapeChunk);
		float margin = marginChunk->getFloatValue();
		return new SoundSphere(radius, position, margin);
	}
	void SoundSphereReaderWriter::writeOn(std::shared_ptr<XmlChunk> shapeChunk, const SoundShape *soundShape, XmlWriter &xmlWriter) const
	{
		shapeChunk->setAttribute(XmlAttribute(TYPE_ATTR, 
static bool checkLocatorCallbacks( const osgVolume::Locator& locator )
    return locator.getLocatorCallbacks().size()>0;
static bool readLocatorCallbacks( osgDB::InputStream& is, osgVolume::Locator& locator )
    unsigned int size = is.readSize(); is >> is.BEGIN_BRACKET;
    for ( unsigned int i=0; i<size; ++i )
    {
        osgVolume::Locator::LocatorCallback* cb =
            dynamic_cast<osgVolume::Locator::LocatorCallback*>( is.readObject() );
        if ( cb ) locator.addCallback( cb );
    }
    is >> is.END_BRACKET;
    return true;
static bool writeLocatorCallbacks( osgDB::OutputStream& os, const osgVolume::Locator& locator )
    const osgVolume::Locator::LocatorCallbacks& callbacks = locator.getLocatorCallbacks();
    os.writeSize( callbacks.size() ); os << os.BEGIN_BRACKET << std::endl;
    for ( osgVolume::Locator::LocatorCallbacks::const_iterator itr=callbacks.begin();
          itr!=callbacks.end(); ++itr )
    {
        os << itr->get();
    }
    os << os.END_BRACKET <
namespace base {
typedef HistogramBase::Count Count;
typedef HistogramBase::Sample Sample;
SampleMap::SampleMap() : SampleMap(0) {}
SampleMap::SampleMap(uint64_t id) : HistogramSamples(id) {}
SampleMap::~SampleMap() {}
void SampleMap::Accumulate(Sample value, Count count) {
  sample_counts_[value] += count;
  IncreaseSum(count * value);
  IncreaseRedundantCount(count);
Count SampleMap::GetCount(Sample value) const {
  std::map<Sample, Count>::const_iterator it = sample_counts_.find(value);
  if (it == sample_counts_.end())
    return 0;
  return it->second;
Count SampleMap::TotalCount() const {
  Count count = 0;
  for (const auto& entry : sample_counts_) {
    count += entry.second;
  }
  return count;
scoped_ptr<SampleCountIterator> SampleMap::Iterator() const {
  return scoped_ptr<SampleCountIterator>(new SampleMapIterator(sample_counts_));
bool SampleMap::AddSubtractImpl(SampleCountIterator* iter,
                                HistogramSamples::Operator op) {
  Sample min;
  Samp
/*
 * Sample.cpp
 *
 *  Created on: May 4, 2012
 *      Author: nhatuan
 */
/**
 * constructor
 */
Sample::Sample() {
	name = "";
	contrast = 0;
	strength = 0;
	clusterIndex = 3;
/**
 *
 */
Sample::Sample(const Sample &s) {
	name = s.name;
	contrast = s.contrast;
	strength = s.strength;
	clusterIndex = s.clusterIndex;
/**
 * custom constructor
 */
Sample::Sample(string _name, float x, float y) {
	name = _name;
	contrast = x;
	strength = y;
Sample::~Sample() {
/**
 * set name for sample
 */
void Sample::setName(string _name) {
	name = _name;
/**
 * set the intensities values (or contrast and strength)
 */
void Sample::setValues(float x, float y) {
	contrast = x;
	strength = y;
/**
 * get sample's name
 */
string Sample::getName() {
	return name;
/**
 * get the x intensities (or contrast)
 */
float Sample::getContrast() {
	return contrast;
/**
 * get the y intensities (or strength)
 */
float Sample::getStrength() {
	return strength;
/**
 * set index of cluster for sample, there are four 
namespace fnord {
    template<typename buffer_type, typename chunk_id, chunk_id INITIAL_CHUNK_ID, size_t MAX_CHUNK_LENGTH>
    class chunk_assembler {
    public:
        using chunk_info = struct {
            chunk_id id;
            size_t length;
        };
        using cursor_type = class buffer_type::cursor;
        using callback_type = void(chunk_id, const buffer_type, chunk_info &);
    private:
        uint8_t scratch_data[MAX_CHUNK_LENGTH];
        cursor_type scratch;
        chunk_info current;
    public:
        constexpr chunk_assembler() noexcept :
                scratch(buffer_type(scratch_data, MAX_CHUNK_LENGTH).begin()),
                current{INITIAL_CHUNK_ID, 0}
        {}
        void assemble(const buffer_type buffer, function<callback_type> chunk_handler) {
            cursor_type c = buffer.begin();
            if (scratch.position()) {
                size_t missing = current.length - scratch.position();
                if (c.remaining() < missing) {
    
/**
 *  @file LB_LoadMinimum.h
 *
 *  $Id: LB_LoadMinimum.h 77001 2007-02-12 07:54:49Z johnnyw $
 *
 *  @author Jaiganesh Balasubramanian <jai@dre.vanderbilt.edu>
 *          Ossama Othman <ossama@uci.edu>
 */
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO_LB
  /**
   * @name Default LoadMinimum strategy parameters.
   *
   * Defaults defined by the Load Balancing specification.
   */
  const CORBA::Float LM_DEFAULT_TOLERANCE = 1;
  const CORBA::Float LM_DEFAULT_DAMPENING = 0;
  const CORBA::Float LM_DEFAULT_PER_BALANCE_LOAD = 0;
  /**
   * @name TAO-specific LoadMinimum strategy parameters.
   *
   * Parameters internal to TAO's LoadMinimum strategy
   * implementation.
   */
  /**
   * If the percent difference between two loads, i.e.:
   *   (Old Load - New Load) / New Load
   * is less than or equal to this value, the two loads will be
   * considered equivalent.  In such a case, an object group member
   * residing at the location corresponding to one of the two loads
   * will 

   */
/**
 * @class TAO_LB_LoadMinimum
 *
 * @brief "Least loaded" load balancing strategy
 *
 * This load balancing strategy is designed to select an object group
 * member residing at a location with the smallest load.
 */
class TAO_LB_LoadMinimum
  : public virtual POA_CosLoadBalancing::Strategy
public:
  TAO_LB_LoadMinimum (PortableServer::POA_ptr poa);
  /**
   * @name CosLoadBalancing::Strategy methods
   *
   * Methods required by the CosLoadBalancing::Strategy interface.
   */
  virtual char * name (void);
  virtual CosLoadBalancing::Properties * get_properties ();
  virtual void push_loads (
      const PortableGroup::Location & the_location,
      const CosLoadBalancing::LoadList & loads);
  virtual CosLoadBalancing::LoadList * get_loads (
      CosLoadBalancing::LoadManager_ptr load_manager,
      const PortableGroup::Location & the_location);
  virtual CORBA::Object_ptr next_member (
      PortableGroup::ObjectGroup_ptr object_group,
      CosLoadBalancing::LoadManager_ptr

  virtual void analyze_loads (
      PortableGroup::ObjectGroup_ptr object_group,
      CosLoadBalancing::LoadManager_ptr load_manager);
  virtual PortableServer::POA_ptr _default_POA (
    );
  void init (const PortableGroup::Properties & props);
protected:
  ~TAO_LB_LoadMinimum (void);
  CORBA::Boolean get_location (CosLoadBalancing::LoadManager_ptr load_manager,
                               const PortableGroup::Locations & locations,
                               PortableGroup::Location & location);
  CORBA::Float effective_load (CORBA::Float previous_load,
                               CORBA::Float new_load);
  void push_loads (
      const PortableGroup::Location & the_location,
      const CosLoadBalancing::LoadList & loads,
      CosLoadBalancing::Load & effective_load);
  void extract_float_property (const PortableGroup::Property & property,
                               CORBA::Float & value);
private:
  PortableServer::POA_var poa_;
  TAO_LB_LoadMap * load_map_;
  TAO_SY
/*
 * SampledTone.cpp
 *
 *  Created on: Mar 5, 2010
 *      Author: ross
 */
SampledTone::SampledTone(jack_default_audio_sample_t freq, int framesPerSecond, float _amplitude) : frequency(freq)
        , sampleRate(framesPerSecond), sampleCount(0)
        , amplitude(_amplitude)
        , framesPerCycle((jack_default_audio_sample_t)framesPerSecond / frequency)
        , cycleEndSample(floor((framesPerCycle * 100000) + 0.5f)) {
SampledTone::SampledTone() {
SampledTone::~SampledTone() {
void SampledTone::init(jack_default_audio_sample_t freq, int framesPerSecond) {
    frequency = freq;
    sampleRate = framesPerSecond;
    sampleCount = 0;
    framesPerCycle = (jack_default_audio_sample_t)framesPerSecond / frequency;
    cycleEndSample = floor((framesPerCycle * 100000) + 0.5f);
jack_default_audio_sample_t SampledTone::getSample() {
    jack_default_audio_sample_t value = amplitude * sin(2.0f * SAMPLEDTONE_PI * (jack_default_audio_sample_t)sampleCount
            / framesPerCycle);
    +
using namespace BlendInt;
FileSystemModelTest1::FileSystemModelTest1()
: testing::Test()
FileSystemModelTest1::~FileSystemModelTest1()
/**
 * test InsertRows() method
 *
 * Insert 5 rows into an empty model
 * Expected result:
 * 	check the row created and make sure all data are deleted in the destructor
 */
TEST_F(FileSystemModelTest1, InsertRows1)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 5);
/**
 * test InsertRows() method
 *
 * Insert 5 rows into an empty model, and insert 2 another rows at 0
 *
 * Expected result: 
 *
 * 	row become 7
 */
TEST_F(FileSystemModelTest1, InsertRows2)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.InsertRows(0, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 7);
/**
 * test InsertRows() method
 *
 * Insert 5 rows into an empty model, and insert 2 another rows at 2
 *
 * E

 *
 * 	row become 7
 */
TEST_F(FileSystemModelTest1, InsertRows3)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.InsertRows(2, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 7);
/**
 * test InsertRows() method
 *
 * Insert 5 rows into an empty model, and append 2 another rows
 *
 * Expected result:
 *
 * 	row become 7
 */
TEST_F(FileSystemModelTest1, InsertRows4)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.InsertRows(5, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 7);
/**
 * test InsertRows() method
 *
 * Insert 5 rows into an empty model, and append 5 another rows at 2
 *
 * Expected result:
 *
 * 	row become 10
 */
TEST_F(FileSystemModelTest1, InsertRows5)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.InsertRows(2, 5, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(roo

/**
 * test InsertColumns() method
 *
 * Insert 2 rows into an empty model, and add 2 another columns at 0
 *
 * Expected result:
 *
 * 	column become 5 (default) + 2
 */
TEST_F(FileSystemModelTest1, InsertColumns1)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 2, root);
	model.InsertColumns(0, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 7);
/**
 * test InsertColumns() method
 *
 * Insert 2 rows into an empty model, and add 2 another columns at 2
 *
 * Expected result:
 *
 * 	column become 5 (default) + 2
 */
TEST_F(FileSystemModelTest1, InsertColumns2)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 2, root);
	model.InsertColumns(2, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 7);
/**
 * test InsertColumns() method
 *
 * Insert 2 rows into an empty model, and append 2 another columns
 *
 * Expected result:
 *
 * 	column become 5 (default) + 2
 */
TEST_F(FileS

	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 2, root);
	model.InsertColumns(2, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 7);
/**
 * test InsertColumns() method
 *
 * Insert 5 rows into an empty model, and remove 2 rows at 0
 *
 * Expected result:
 *
 * 	rows is 3 now
 */
TEST_F(FileSystemModelTest1, RemoveRows1)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.RemoveRows(0, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 3);
/**
 * test InsertColumns() method
 *
 * Insert 5 rows into an empty model, and try to remove 6 rows at 1
 *
 * Expected result:
 *
 * 	row count is 1 now
 */
TEST_F(FileSystemModelTest1, RemoveRows2)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.RemoveRows(1, 6, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 1);
/**
 * test InsertColumns() method
 *
 * I

 *
 * Expected result:
 *
 * 	row count is 3 now
 */
TEST_F(FileSystemModelTest1, RemoveRows3)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.RemoveRows(3, 3, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 3);
/**
 * test InsertColumns() method
 *
 * Insert 5 rows into an empty model, and try to remove 2 rows at 6
 *
 * Expected result:
 *
 * 	nothing happen, row count is still 5
 */
TEST_F(FileSystemModelTest1, RemoveRows4)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 5, root);
	model.RemoveRows(6, 2, root);
	model.Print();
	ASSERT_TRUE(model.GetRowCount(root) == 5);
/**
 * test RemoveColumns() method
 *
 * Insert 3 rows into an empty model, and try to remove 1 columns at 0
 *
 * Expected result:
 *
 * 	column count is 4
 */
TEST_F(FileSystemModelTest1, RemoveColumns1)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 3, root);
	model.Re

	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 4);
/**
 * test RemoveColumns() method
 *
 * Insert 5 rows into an empty model, and try to remove 1 columns at 1
 *
 * Expected result:
 *
 * 	column count is 4
 */
TEST_F(FileSystemModelTest1, RemoveColumns2)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 3, root);
	model.RemoveColumns(1, 1, root);
	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 4);
/**
 * test RemoveColumns() method
 *
 * Insert 5 rows into an empty model, and try to remove 1 columns at 4
 *
 * Expected result:
 *
 * 	column count is 4
 */
TEST_F(FileSystemModelTest1, RemoveColumns3)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 3, root);
	model.RemoveColumns(4, 1, root);
	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 4);
/**
 * test RemoveColumns() method
 *
 * Insert 3 rows into an empty model, and try to remove > 5 columns at 1
 *
 * Expected result:
 *
 

 */
TEST_F(FileSystemModelTest1, RemoveColumns4)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 3, root);
	model.RemoveColumns(1, 9, root);
	model.Print();
	DBG_PRINT_MSG("columns: %d", model.GetColumnCount(root));
	ASSERT_TRUE(model.GetColumnCount(root) == 1);
/**
 * test RemoveColumns() method
 *
 * Insert 3 rows into an empty model, and try to remove 6 columns at 0, this remove all data
 *
 * Expected result:
 *
 * 	column count is 0
 */
TEST_F(FileSystemModelTest1, RemoveColumns5)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 3, root);
	model.RemoveColumns(0, 6, root);
	model.Print();
	ASSERT_TRUE((model.GetColumnCount(root) == 0) && (model.GetRowCount(root) == 0));
/**
 * test RemoveColumns() method
 *
 * Insert 3 rows into an empty model, and try to remove 7 columns at 0, this remove all data
 *
 * Expected result:
 *
 * 	column count is 0
 */
TEST_F(FileSystemModelTest1, RemoveColumns6)
	FileSystemMo

	ModelIndex root = model.GetRootIndex();
	model.InsertRows(0, 3, root);
	model.RemoveColumns(0, 7, root);
	model.Print();
	ASSERT_TRUE((model.GetColumnCount(root) == 0) && (model.GetRowCount(root) == 0));
/**
 * test Load() method
 *
 * Load file list in a given path
 *
 * Expected result:
 *
 * 	see print
 */
TEST_F(FileSystemModelTest1, Load1)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.Load(".");
	model.Print();
	ASSERT_TRUE(model.GetColumnCount(root) == 5);
/**
 * test GetIndex() method
 *
 * Load file list in a given path, use GetIndex to check the index data
 *
 * Expected result:
 *
 * 	see print
 */
TEST_F(FileSystemModelTest1, GetIndex1)
	FileSystemModel model;
	ModelIndex root = model.GetRootIndex();
	model.Load(".");
	ModelIndex index = model.GetIndex(0, 0, root);
	while(index.valid()) {
		index = index.GetDownIndex();
	}
	ASSERT_TRUE(model.GetColumnCount(root) == 5);
/**
 * test GetIndex() method
 *
 * Load file list in a given path, use GetInde
class Model;
class Clip;
class ClipLink;
class ModelClipFootInfo;
class BaseModel;
class ANIMA_CORE_API ModelLibrary  : public BObject
private:
	QMap<QString,BaseModel *> baseModelList;
	QList<Model *> guiModelList;
	QList<Model *> fullModelList;
	QList<QString> categoryList;
public:
	ModelLibrary(void);
	virtual ~ModelLibrary(void);
	QList<Model *> &GUIModelList(){return guiModelList;}
	QList<Model *> &FullModelList(){return fullModelList;}
	void FindModels(const QString &category,QList<Model *> &models,bool onlyGUI);
	void GetBaseModelList(QList<BaseModel *> &list);
	QList<QString> &GetCategoryList(){return categoryList;}
	void Load();
	void Save(Model *model,const QString &clipID );
	void Init();
	BaseModel *GetBaseModel(const QString &name);
	Model *GetDefaultModel();
	QString GetBaseModelDefinePath(Model *model);
	QString GetModelPath(Model *model);
	QString GetModelName(Model *model);
	QString GetModelSkeletonPath(Model *model);
	QString GetModelDir(Model *model);
	QString GetMod
namespace content {
WebProcessMemoryDumpImpl::WebProcessMemoryDumpImpl()
    : owned_process_memory_dump_(
          new base::trace_event::ProcessMemoryDump(nullptr)),
      process_memory_dump_(owned_process_memory_dump_.get()),
      level_of_detail_(base::trace_event::MemoryDumpLevelOfDetail::DETAILED) {}
WebProcessMemoryDumpImpl::WebProcessMemoryDumpImpl(
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : process_memory_dump_(process_memory_dump),
      level_of_detail_(level_of_detail) {}
WebProcessMemoryDumpImpl::~WebProcessMemoryDumpImpl() {
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createMemoryAllocatorDump(
    const blink::WebString& absolute_name) {
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocatorDump(absolute_name.utf8());
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
Web

    const blink::WebString& absolute_name,
    blink::WebMemoryAllocatorDumpGuid guid) {
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocatorDump(
          absolute_name.utf8(),
          base::trace_event::MemoryAllocatorDumpGuid(guid));
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createWebMemoryAllocatorDump(
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump) {
  if (!memory_allocator_dump)
    return nullptr;
  WebMemoryAllocatorDumpImpl* web_memory_allocator_dump_impl =
      new WebMemoryAllocatorDumpImpl(memory_allocator_dump);
  memory_allocator_dumps_.set(memory_allocator_dump,
                              make_scoped_ptr(web_memory_allocator_dump_impl));
  return web_memory_allocator_dump_impl;
blink::WebMemoryAllocatorDump* WebProcessMemoryDumpImpl::getMemoryAllocatorDump(
    const blink::WebString& absolute_name) const {
  ba

      process_memory_dump_->GetAllocatorDump(absolute_name.utf8());
  if (!memory_allocator_dump)
    return nullptr;
  blink::WebMemoryAllocatorDump* web_memory_allocator_dump =
      memory_allocator_dumps_.get(memory_allocator_dump);
  DCHECK(web_memory_allocator_dump);
  return web_memory_allocator_dump;
void WebProcessMemoryDumpImpl::clear() {
  memory_allocator_dumps_.clear();
  process_memory_dump_->Clear();
void WebProcessMemoryDumpImpl::takeAllDumpsFrom(
    blink::WebProcessMemoryDump* other) {
  auto other_impl = static_cast<WebProcessMemoryDumpImpl*>(other);
  process_memory_dump_->TakeAllDumpsFrom(other_impl->process_memory_dump_);
  const size_t expected_final_size = memory_allocator_dumps_.size() +
                                     other_impl->memory_allocator_dumps_.size();
  while (!other_impl->memory_allocator_dumps_.empty()) {
    auto first_entry = other_impl->memory_allocator_dumps_.begin();
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
  

    memory_allocator_dumps_.set(
        memory_allocator_dump,
        other_impl->memory_allocator_dumps_.take_and_erase(first_entry));
  }
  DCHECK_EQ(expected_final_size, memory_allocator_dumps_.size());
  DCHECK(other_impl->memory_allocator_dumps_.empty());
void WebProcessMemoryDumpImpl::addOwnershipEdge(
    blink::WebMemoryAllocatorDumpGuid source,
    blink::WebMemoryAllocatorDumpGuid target,
    int importance) {
  process_memory_dump_->AddOwnershipEdge(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      base::trace_event::MemoryAllocatorDumpGuid(target), importance);
void WebProcessMemoryDumpImpl::addOwnershipEdge(
    blink::WebMemoryAllocatorDumpGuid source,
    blink::WebMemoryAllocatorDumpGuid target) {
  process_memory_dump_->AddOwnershipEdge(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      base::trace_event::MemoryAllocatorDumpGuid(target));
void WebProcessMemoryDumpImpl::addSuballocation(
    blink::WebMemoryAllocatorDumpGuid source,
    c

  process_memory_dump_->AddSuballocation(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      target_node_name.utf8());
SkTraceMemoryDump* WebProcessMemoryDumpImpl::createDumpAdapterForSkia(
    const blink::WebString& dump_name_prefix) {
  sk_trace_dump_list_.push_back(new skia::SkiaTraceMemoryDumpImpl(
      dump_name_prefix.utf8(), level_of_detail_, process_memory_dump_));
  return sk_trace_dump_list_.back();
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::CreateDiscardableMemoryAllocatorDump(
    const std::string& name,
    base::DiscardableMemory* discardable) {
  base::trace_event::MemoryAllocatorDump* dump =
      discardable->CreateMemoryAllocatorDump(name.c_str(),
                                             process_memory_dump_);
  return createWebMemoryAllocatorDump(dump);
void WebProcessMemoryDumpImpl::dumpHeapUsage(
    const base::hash_map<base::trace_event::AllocationContext, size_t>&
        bytes_by_context,
    base::trace_event::TraceEventMemor
namespace dart {
class ProfileSampleBufferTestHelper {
 public:
  static intptr_t IterateCount(const SampleBuffer& sample_buffer) {
    intptr_t c = 0;
    for (Sample* i = sample_buffer.FirstSample();
         i != sample_buffer.LastSample();
         i = sample_buffer.NextSample(i)) {
      c++;
    }
    return c;
  }
  static intptr_t IterateSumPC(const SampleBuffer& sample_buffer) {
    intptr_t c = 0;
    for (Sample* i = sample_buffer.FirstSample();
         i != sample_buffer.LastSample();
         i = sample_buffer.NextSample(i)) {
      c += i->pcs[0];
    }
    return c;
  }
};
TEST_CASE(ProfilerSampleBufferWrapTest) {
  SampleBuffer* sample_buffer = new SampleBuffer(3);
  EXPECT_EQ(0, ProfileSampleBufferTestHelper::IterateSumPC(*sample_buffer));
  Sample* s;
  s = sample_buffer->ReserveSample();
  s->pcs[0] = 2;
  EXPECT_EQ(2, ProfileSampleBufferTestHelper::IterateSumPC(*sample_buffer));
  s = sample_buffer->ReserveSample();
  s->pcs[0] = 4;
  EXPECT_EQ(6, ProfileSampleBuff
/* Generated file.  Do not edit */
VTE_SEQUENCE_HANDLER(vte_sequence_handler_AL)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DC)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DL)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DO)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_IC)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_LE)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_RI)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_SF)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_SR)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_UP)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ae)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_al)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_application_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_as)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bt)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cS)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cd)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ce)
VTE_SEQUENCE_HANDLER(vte_sequ

VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_cursor_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cm)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cs)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ct)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_character_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_lower_left)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_preceding_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cv)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dec_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler

VTE_SEQUENCE_HANDLER(vte_sequence_handler_decset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_delete_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_do)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_eA)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ec)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ei)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_characters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_display)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_form_feed)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_fs)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_full_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ho)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_horizontal_and_vertical_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ic)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_im)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_index)
VTE_SE

VTE_SEQUENCE_HANDLER(vte_sequence_handler_insert_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_kb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ke)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ks)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_le)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_line_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ll)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_local_charset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_manage_ime)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_md)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_me)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mh)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mk)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mp)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_nd)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_noop)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_normal_keypad)
VTE_SEQUEN

VTE_SEQUENCE_HANDLER(vte_sequence_handler_rc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_request_terminal_parameters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_restore_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_id)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_status)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reverse_index)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_save_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_screen_alignment_test)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_down)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_se)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_primary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_secondary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_and_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon

VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region_from_start)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region_to_end)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sf)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_so)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_soft_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ta)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_tab_clear)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ts)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_uc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ue)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_us)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_utf_8_charset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_vb)
VTE_SEQ
inline world_position NullPosition()
    world_position Result = {};
    Result.ChunkX = TILE_CHUNK_UNINITIALIZED;
    return Result;
inline bool32 IsValid(world_position P)
    bool32 Result = (P.ChunkX != TILE_CHUNK_UNINITIALIZED);
    return Result;
inline bool32 IsCanonical(real32 ChunkDim, real32 TileRel)
    real32 Epsilon = 0.01f;
    bool32 Result = ((TileRel >= -(0.5f*ChunkDim + Epsilon)) &&
                     (TileRel <= (0.5f*ChunkDim + Epsilon)));
    return Result;
inline bool32 IsCanonical(world* World, v3 Offset)
    bool32 Result = (IsCanonical(World->ChunkDimInMeters.x, Offset.x) && 
                     IsCanonical(World->ChunkDimInMeters.y, Offset.y) &&
                     IsCanonical(World->ChunkDimInMeters.z, Offset.z));
    return Result;
inline bool32 AreInSameChunk(world* World, world_position* A, world_position* B)
    Assert(IsCanonical(World, A->Offset_));
    Assert(IsCanonical(World, B->Offset_));
    bool Result = ((A->ChunkX == B->ChunkX) &&
          

                   (A->ChunkZ == B->ChunkZ));
    return Result;
inline world_chunk* GetWorldChunk(world * World, int32 ChunkX, int32 ChunkY,
    int32 ChunkZ, memory_arena* Arena = 0)
    Assert(ChunkX > -TILE_CHUNK_SAFE_MARGIN);
    Assert(ChunkY > -TILE_CHUNK_SAFE_MARGIN);
    Assert(ChunkZ > -TILE_CHUNK_SAFE_MARGIN);
    Assert(ChunkX < TILE_CHUNK_SAFE_MARGIN);
    Assert(ChunkY < TILE_CHUNK_SAFE_MARGIN);
    Assert(ChunkZ < TILE_CHUNK_SAFE_MARGIN);
    uint32 HashValue = 19*ChunkX + 7*ChunkY + 3*ChunkZ;
    uint32 HashSlot = HashValue & (ArrayCount(World->ChunkHash) - 1);
    Assert(HashSlot < ArrayCount(World->ChunkHash));
    world_chunk *Chunk = World->ChunkHash + HashSlot;
    do
    {
        if ((ChunkX == Chunk->ChunkX) &&
            (ChunkY == Chunk->ChunkY) &&
            (ChunkZ == Chunk->ChunkZ))
        {
            break;
        }
        if (Arena && (Chunk->ChunkX != TILE_CHUNK_UNINITIALIZED) && (!Chunk->NextInHash))
        {
            Chunk->NextInHash = Pus

            Chunk = Chunk->NextInHash;
            Chunk->ChunkX = TILE_CHUNK_UNINITIALIZED;
        }
        if (Arena && ((Chunk->ChunkX == TILE_CHUNK_UNINITIALIZED)))
        {
            Chunk->ChunkX = ChunkX;
            Chunk->ChunkY = ChunkY;
            Chunk->ChunkZ = ChunkZ;
            Chunk->NextInHash = 0;
            break;
        }
        Chunk = Chunk->NextInHash;
    }
    while (Chunk);
    return Chunk;
internal void InitializeWorld(world* World, v3 ChunkDimInMeters)
    World->ChunkDimInMeters = ChunkDimInMeters;
    World->FirstFree = 0;
    for (uint32 ChunkIndex = 0;
        ChunkIndex < ArrayCount(World->ChunkHash);
        ++ChunkIndex)
    {
        World->ChunkHash[ChunkIndex].ChunkX = TILE_CHUNK_UNINITIALIZED;
        World->ChunkHash[ChunkIndex].FirstBlock.EntityCount = 0;
    }
inline void RecanonicalizeCoord(real32 ChunkDim, int32* Tile, real32* TileRel)
    int32 Offset = RoundReal32ToInt32(*TileRel / ChunkDim);
    *Tile += Offset;
    *TileRel -=

    Assert(IsCanonical(ChunkDim, *TileRel));
internal world_position MapIntoChunkSpace(world* World, world_position BasePos, v3 Offset)
    world_position Result = BasePos;
    Result.Offset_ += Offset;
    RecanonicalizeCoord(World->ChunkDimInMeters.x, &Result.ChunkX, &Result.Offset_.x);
    RecanonicalizeCoord(World->ChunkDimInMeters.y, &Result.ChunkY, &Result.Offset_.y);
    RecanonicalizeCoord(World->ChunkDimInMeters.z, &Result.ChunkZ, &Result.Offset_.z);
    return Result;
v3 Subtract(world* World, world_position* A, world_position* B)
    v3 dTile = { (real32)A->ChunkX - (real32)B->ChunkX,
                 (real32)A->ChunkY - (real32)B->ChunkY,
                 (real32)A->ChunkZ - (real32)B->ChunkZ };
    v3 Result = Hadamard(World->ChunkDimInMeters, dTile)  + (A->Offset_ - B->Offset_);
    return  Result;
inline world_position CenteredChunkPoint(int32 AbsTileX, int32 AbsTileY, int32 AbsTileZ)
    world_position Result = {};
    Result.ChunkX = AbsTileX;
    Result.ChunkY = AbsT

    Result.ChunkZ = AbsTileZ;
    return Result;
inline world_position CenteredChunkPoint(world_chunk *Chunk)
    world_position Result = CenteredChunkPoint(Chunk->ChunkX, Chunk->ChunkY, Chunk->ChunkZ);
    return Result;
inline void ChangeEntityLocationRaw(memory_arena* Arena, world* World, uint32 LowEntityIndex,
    world_position *OldP, world_position *NewP)
    Assert(!OldP || IsValid(*OldP));
    Assert(!NewP || IsValid(*NewP));
    if (OldP && NewP && AreInSameChunk(World, OldP, NewP))
    {
    }
    else
    {
        if (OldP)
        {
            world_chunk *Chunk = GetWorldChunk(World, OldP->ChunkX, OldP->ChunkY, OldP->ChunkZ);
            Assert(Chunk);
            if (Chunk)
            {
                bool32 NotFound = true;
                world_entity_block *FirstBlock = &Chunk->FirstBlock;
                for (world_entity_block *Block = FirstBlock;
                    Block && NotFound;
                    Block = Block->Next)
                {
                  

                    {
                        if (Block->LowEntityIndex[Index] == LowEntityIndex)
                        {
                            Assert(FirstBlock->EntityCount > 0);
                            Block->LowEntityIndex[Index] =
                                FirstBlock->LowEntityIndex[--FirstBlock->EntityCount];
                            if (FirstBlock->EntityCount == 0)
                            {
                                if (FirstBlock->Next)
                                {
                                    world_entity_block *NextBlock = FirstBlock->Next;
                                    *FirstBlock = *NextBlock;
                                    NextBlock->Next = World->FirstFree;
                                    World->FirstFree = NextBlock;
                                }
                            }
                            NotFound = false;
                        }
                    }
                }
            }
        

        if(NewP)
        {
            world_chunk *Chunk = GetWorldChunk(World, NewP->ChunkX, NewP->ChunkY, NewP->ChunkZ, Arena);
            Assert(Chunk);
            world_entity_block* Block = &Chunk->FirstBlock;
            if (Block->EntityCount == ArrayCount(Block->LowEntityIndex))
            {
                world_entity_block *OldBlock = World->FirstFree;
                if (OldBlock)
                {
                    World->FirstFree = OldBlock->Next;
                }
                else
                {
                    OldBlock = PushStruct(Arena, world_entity_block);
                }
                *OldBlock = *Block;
                Block->Next = OldBlock;
                Block->EntityCount = 0;
            }
            Assert(Block->EntityCount < ArrayCount(Block->LowEntityIndex));
            Block->LowEntityIndex[Block->EntityCount++] = LowEntityIndex;
        }
    }
inline void ChangeEntityLocation(memory_arena* Arena, world* World,
    uint32 LowEnt
namespace ll {
namespace stream_helper {
struct input {
    page *_first_chunk;
    char *_firstp;
    size_t _size;
    input() noexcept : _first_chunk(), _firstp(), _size() {}
    input(const input_struct &x) noexcept : 
        _first_chunk(x._first_chunk),
        _firstp(x._firstp),
        _size(x._size) {}
    input(const input &x, size_t size) noexcept : 
        _first_chunk(x._first_chunk),
        _firstp(x._firstp),
        _size(size) {
        assert(size && x._size >= size);
    }
    input(input &&x) : noexcept {
        swap(x);
    }
    void swap(input &x) {
        std::swap(_first_chunk, x._first_chunk);
        std::swap(_firstp, x._firstp);
        std::swap(_size, x._size);
    }
    void discard(unsigned size) noexcept {
        assert(size && _size >= size);
        _size -= size;
        register page *chunk = _first_chunk;
        register size_t n = chunk->endp - _firstp;
        if (ll_likely(n >= size)) {
            _firstp += size;
        }
        els

            while (1) {
                size -= n;
                if (!size) {
                    _firstp += n;
                    break;
                }
                chunk = chunk->next;
                _firstp = chunk->firstp;
                n = chunk->endp - _firstp;
                if (n > size) {
                    n = size;
                }
            }
            _first_chunk = chunk;
        }
    }
    static void read(input_struct *data, void *buf, size_t size) noexcept {
        assert(buf && size && _size >= size);
        _size -= size;
        register char *p = (char*)buf;
        register page *chunk = _first_chunk;
        register size_t n = chunk->endp - _firstp;
        if (ll_likely(n >= size)) {
            memcpy(p, _firstp, size);
            _firstp += size;
            return;
        }
        while (1) {
            if (ll_likely(n)) {
                memcpy(p, _firstp, n);
                size -= n;
                if (!size) {
               

                    return;
                }
                p += n;
            }
            chunk = chunk->next;
            _firstp = chunk->firstp;
            n = chunk->endp - _firstp;
            if (n > size) {
                n = size;
            }
        }
    }
};
struct output : input {
    page_allocator *_pa;
    page *_end_chunk;
    output(page_allocator *pa) noexcept : input() {
        if (!pa) {
            pa = page_allocator::global();
        }
        _pa = pa;
        init();
    }
    output(const output &x) noexcept : input(x) {
        _pa = x._pa;
        init();
        load(x);
    }
    output(output &&x) noexcept : input(std::move(x)), _end_chunk() {
        std::swap(_pa, x._pa);
        std::swap(_end_chunk, x._end_chunk);
    }
    ~output() noexcept {
        if (_end_chunk) {
            page *chunk = _end_chunk->next;
            while (1) {
                page *tmp = chunk->next;
                free_chunk(chunk);
                if (chunk =

                    break;
                }
                chunk = tmp;
            }
        }
    }
    void init(page *chunk = nullptr) noexcept {
        if (!chunk) {
            chunk = _pa->alloc();
        }
        _first_chunk = _end_chunk = chunk;
        chunk->next = chunk;
        _firstp = chunk->endp = chunk->firstp;
        _size = 0;
    }
    void swap(output &x) {
        std::swap(_pa, x._pa);
        std::swap(_end_chunk, x._end_chunk);
        input::swap(x);
    }
    page *alloc_chunk(size_t size = 1) noexcept {
        page *chunk = _pa->alloc(size);
        chunk->p = chunk->endp;
        return chunk;
    }
    void free_chunk(page *chunk) noexcept {
        _pa->free(chunk);
    }
};
class stream {
private:
    stream_helper::output _data;
public:
    stream(page_allocator *pa = nullptr) noexcept : _data(pa) {}
    stream(const stream &x) noexcept : _data(x._data) {}
    stream(stream &&x) noexcept : 
        _pa(x._pa), 
        _first_chunk(x._first_ch

        _end_chunk(x._end_chunk),
        _firstp(x._firstp),
        _size(x._size) 
    {
        x._end_chunk = nullptr;
    }
    ~stream() noexcept {
    }
    stream &operator=(const stream &x) noexcept {
        clear();
        load(x);
        return *this;
    }
    stream &operator=(stream &&x) noexcept {
        std::swap(_pa, x._pa);
        std::swap(_first_chunk, x._first_chunk);
        std::swap(_end_chunk, x._end_chunk);
        std::swap(_firstp, x._firstp);
        std::swap(_size, x._size);
        return *this;
    }
    size_t size() noexcept {
        return _size;
    }
    void clear() {
        page *chunk = _end_chunk->next;
        while (chunk != _end_chunk) {
            page *tmp = chunk->next;
            _pa->free(chunk);
            chunk = tmp;
        }
        init(chunk);
    }
    void reclaim() {
        if (!_size) {
            _first_chunk = _end_chunk;
            _firstp = _first_chunk->endp = _first_chunk->firstp;
        }
        else i

            _first_chunk = _first_chunk->next;
            _firstp = _first_chunk->firstp;
        }
        page *chunk = _end_chunk->next;
        while (chunk != _first_chunk) {
            page *tmp = chunk->next;
            _pa->free(chunk);
            chunk = tmp;
        }
        _end_chunk->next = _first_chunk;
    }
    void write(const void *buf, size_t size) noexcept {
        assert(size);
        
        _size += size;
        register char *p = (char*)buf;
        register page *chunk = _end_chunk;
        register size_t n = chunk->p - chunk->endp;
        if (ll_likely(n >= size)) {
            memcpy(chunk->endp, p, size);
            chunk->endp += size;
            return;
        }
        while (1) {
            memcpy(chunk->endp, p, n);
            chunk->endp += n;
            size -= n;
            if (!size) {
                return;
            }
            p += n;
            chunk = chunk->next;
            if (chunk == _first_chunk) {
               

                chunk->next = _end_chunk->next;
                _end_chunk->next = chunk;
            }
            _end_chunk = chunk;
            chunk->endp = chunk->firstp;
            n = chunk->p - chunk->endp;
            if (n > size) {
                n = size;
            }
        }
    }
    void *blank(size_t size) {
        assert(size);
        page *chunk = _end_chunk;
        void *p;
        _size += size;
        size_t n = chunk->p - chunk->endp;
        if (n >= size) {
            p = chunk->endp;
            chunk->endp += size;
            return p;
        }
        chunk = chunk->next;
        if (chunk == _first_chunk || (chunk->p < (chunk->firstp + size))) {
            chunk = alloc_chunk(size);
            chunk->next = _end_chunk->next;
            _end_chunk->next = chunk;
        }
        _end_chunk = chunk;
        chunk->endp = chunk->firstp + size;
        return chunk->firstp;
    }
    template <typename _F>
    void foreach_chunk(_F &&f) const n

        register page *chunk = _first_chunk;
        register char *p = _firstp;
        while (1) {
            if (chunk->endp != p) {
                if (!f(p, chunk->endp)) {
                    break;
                }
            }
            if (chunk == _end_chunk) {
                break;
            }
            chunk = chunk->next;
            p = chunk->firstp;
        }
    }
    void load(const stream &x) noexcept {
        x.foreach_chunk([this](const char *firstp, const char *endp) {
            write(firstp, endp - firstp);
            return true;
        });
    }
    int load(int fd) noexcept {
        page *chunk = _end_chunk;
        int count = 0;
        int n;
        while (1) {
            size_t csize = chunk->p - chunk->endp;
            if (csize) {
                ll_failed_return(n = file_io::read(fd, chunk->endp, csize));
                chunk->endp += n;
                csize -= n;
                count += n;
                if (csize) {
           

                }
            }
            chunk = chunk->next;
            if (chunk == _first_chunk) {
                chunk = alloc_chunk();
                chunk->next = _end_chunk->next;
                _end_chunk->next = chunk;
            }
            _end_chunk = chunk;
            chunk->endp = chunk->firstp;
        }
    }
    int load(file_io &io) noexcept {
        return load((int)io);
    }
    void output(stream &stream) noexcept {
        stream.load(*this);
        clear();
    }
    int output(int fd) noexcept {
        int count = 0;
        int n;
        unsigned size;
        while (1) {
            size = _first_chunk->endp - _firstp;
            if (size) {
                ll_failed_return(n = file_io::write(fd, _firstp, size));
                _firstp += n;
                count += n;
                size -= n;
                _size -= n;
                if (size) {
                    break;
                }
            }
            if (_first_chunk == _
namespace tema1
	class CurvesAndSurfaces
	{
	private:
		manager::ModelManager* model_manager;
		manager::UserInteractionManager* user_interaction_manager;
		manager::CameraManager* camera_manager;
		GLuint model_id = 1;
		std::map<model::CurveType, std::vector<model::ModelFormat*>> models;
		model::ModelFormat* current_model = nullptr;
		model::ModelFormat* previous_model = nullptr;
		
	public:
		CurvesAndSurfaces(manager::ModelManager* model_manager, manager::UserInteractionManager* user_interaction_manager, manager::CameraManager* camera_manager);
		model::ModelFormat* axis_model = nullptr;
		bool isConsistent();
		bool isModelUnderProcessing();
		void startNewModelProcessing(model::CurveType curve_type);
		void insertPoint(glm::vec3 point);
		bool canActivateEditing();
		void endModelProcessing();
		void increaseCurvesNo();
		void decreaseCurvesNo();
		void updateCurvePointsNo(GLint no);
		void addAxisModel();
		model::ModelFormat* getAxisModel();
		void setCurrentModel(model::Model
MenuManager::MenuManager(void)
    PushHandler(new EditHandler(wxID_COPY));
    PushHandler(new EditHandler(wxID_CUT));
    PushHandler(new EditHandler(wxID_PASTE));
    PushHandler(new EditHandler(wxID_UNDO));
    PushHandler(new EditHandler(wxID_REDO));
    PushHandler(new EditHandler(XRCID("label_current_state")));
    PushHandler(new EditHandler(wxID_SELECTALL));
    PushHandler(new EditHandler(wxID_DUPLICATE));
    PushHandler(new EditHandler(wxID_DELETE));
    PushHandler(new EditHandler(XRCID("delete_line")));
    PushHandler(new EditHandler(XRCID("delete_line_end")));
    PushHandler(new EditHandler(XRCID("delete_line_start")));
    PushHandler(new EditHandler(XRCID("copy_line")));
    PushHandler(new EditHandler(XRCID("cut_line")));
    PushHandler(new EditHandler(XRCID("transpose_lines")));
    PushHandler(new EditHandler(XRCID("trim_trailing")));
    PushHandler(new EditHandler(XRCID("to_upper")));
    PushHandler(new EditHandler(XRCID("to_lower")));
    PushHandler(new Edit

    PushHandler(new EditHandler(XRCID("move_line_down")));
    PushHandler(new EditHandler(XRCID("move_line_up")));
    PushHandler(new EditHandler(XRCID("center_line_roll")));
    PushHandler(new EditHandler(XRCID("convert_indent_to_tabs")));
    PushHandler(new EditHandler(XRCID("convert_indent_to_spaces")));
    PushHandler(new BraceMatchHandler(XRCID("select_to_brace")));
    PushHandler(new BraceMatchHandler(XRCID("match_brace")));
    PushHandler(new FindReplaceHandler(wxID_FIND));
    PushHandler(new FindReplaceHandler(wxID_REPLACE));
    PushHandler(new FindReplaceHandler(XRCID("ID_QUICK_ADD_NEXT")));
    PushHandler(new FindReplaceHandler(XRCID("ID_QUICK_FIND_ALL")));
    PushHandler(new GotoHandler(XRCID("goto_linenumber")));
    PushHandler(new BookmarkHandler(XRCID("toggle_bookmark")));
    PushHandler(new BookmarkHandler(XRCID("next_bookmark")));
    PushHandler(new BookmarkHandler(XRCID("previous_bookmark")));
    PushHandler(new BookmarkHandler(XRCID("removeall_current_

    PushHandler(new BookmarkHandler(XRCID("removeall_bookmarks")));
    PushHandler(new GotoDefinitionHandler(XRCID("goto_definition")));
    PushHandler(new GotoDefinitionHandler(XRCID("goto_previous_definition")));
    PushHandler(new WordWrapHandler(XRCID("word_wrap")));
    PushHandler(new FoldHandler(XRCID("toggle_fold")));
    PushHandler(new FoldHandler(XRCID("fold_topmost_in_selection")));
    PushHandler(new FoldHandler(XRCID("fold_all_in_selection")));
    PushHandler(new FoldHandler(XRCID("fold_all")));
    PushHandler(new DebuggerMenuHandler(XRCID("add_breakpoint")));
    PushHandler(new DebuggerMenuHandler(XRCID("disable_all_breakpoints")));
    PushHandler(new DebuggerMenuHandler(XRCID("enable_all_breakpoints")));
    PushHandler(new DebuggerMenuHandler(XRCID("delete_all_breakpoints")));
    PushHandler(new DebuggerMenuHandler(XRCID("insert_temp_breakpoint")));
    PushHandler(new DebuggerMenuHandler(XRCID("insert_disabled_breakpoint")));
    PushHandler(new DebuggerMenu
namespace gui
	class ControllerWrapper : public ObjectWrapper
	{
		Q_OBJECT
	public:
		typedef std::shared_ptr<ControllerWrapper> Ptr;
		ControllerWrapper( Controller::Ptr controller );
		virtual ~ControllerWrapper();
		static Ptr create( Controller::Ptr controller );
	private:
		Controller::Ptr m_controller;
	};
	class LoadGeometryWrapper : public ControllerWrapper
	{
		Q_OBJECT
	public:
		typedef std::shared_ptr<LoadGeometryWrapper> Ptr;
		LoadGeometryWrapper( LoadGeometry::Ptr controller );
		virtual ~LoadGeometryWrapper();
		static Ptr create( LoadGeometry::Ptr controller );
		void setFilename( const std::string& filename );
		std::string getFilename();
		void reload();
	private:
		LoadGeometry::Ptr m_loadGeometry;
	};
	class LoadVolumeWrapper : public ControllerWrapper
	{
		Q_OBJECT
	public:
		typedef std::shared_ptr<LoadVolumeWrapper> Ptr;
		LoadVolumeWrapper( LoadVolume::Ptr controller );
		virtual ~LoadVolumeWrapper();
		static Ptr create( LoadVolume::Ptr controller );
		void s
namespace xTunnel
    class Speedometer
    {
    public:
        Speedometer()
        {
            sample_index_ = -1;
        }
        void SetValue(int64_t value)
        {
            sample_index_ = next_index(sample_index_);
            samples_[sample_index_] = ValueSample(value, GetTickCount());
        }
        double speed() const
        {
            int last_index = sample_index_;
            if (last_index < 0)
            {
                return 0;
            }
            const ValueSample& last = samples_[last_index];
            
            ValueSample first;
            int first_index = next_index(last_index);
            for (int i = 1; i < SampleCount; ++i, first_index = next_index(first_index))
            {
                ValueSample sample = samples_[first_index];
                if (last.time > sample.time && sample.time != 0)
                {
                    first = sample;
                    break;
                }
            }
            if
/**
*  Copyright (C) 2014 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
	namespace worker {
		class ProjectSettingsWorker : public RepoAbstractWorker
		{
			Q_OBJECT
		public:
			/**
			* Default worker constructor.
			* @param token repo token for the connection
			* @param controller controller to talk to the core library
			* @param database name of the database where users are stored
			* @param user user to update/del
template<class T>
class SAChunk
public:
    SAChunk<T> *        next;
    uint32              startIndex;
    T *                 data[];
};
template<class T>
class SparseArray
private:
    ArenaAllocator *    alloc;
    uint32              chunkSize;
    SAChunk<T> *        firstChunk;
public:
    static SparseArray<T> * New(ArenaAllocator *allocator, uint32 chunkSize)
    {
        SparseArray<T> * array;
        if (!Math::IsPow2(chunkSize))
        {
            chunkSize = Math::NextPowerOf2(chunkSize);
        }
        UInt32Math::MulAdd<sizeof(T*), sizeof(SAChunk<T>)>(chunkSize);
        array = Anew(allocator, SparseArray<T>);
        array->alloc = allocator;
        array->chunkSize = chunkSize;
        array->firstChunk = NULL;
        return array;
    }
    void Set(uint32 index, T *element)
    {
        SAChunk<T> * chunk, **pPrev = &(this->firstChunk);
        uint32 indexInChunk = (index % this->chunkSize);
        for (chunk = this->firstChunk; chunk; chunk = chunk->

        {
            if (index < chunk->startIndex)
            {
                chunk = NULL;
                break;
            }
            if (index < chunk->startIndex + this->chunkSize)
            {
                break;
            }
            pPrev = &(chunk->next);
        }
        if (chunk == NULL)
        {
            chunk = (SAChunk<T> *)this->alloc->AllocZero(sizeof(SAChunk<T>) + (chunkSize * sizeof(T *)));
            chunk->startIndex = index - indexInChunk;
            UInt32Math::Add(chunk->startIndex, chunkSize);
            chunk->next = *pPrev;
            *pPrev = chunk;
        }
        chunk->data[indexInChunk] = element;
    }
    T * Get(uint32 index)
    {
        SAChunk<T> * chunk;
        uint32 indexInChunk = (index % this->chunkSize);
        for (chunk = this->firstChunk; chunk; chunk = chunk->next)
        {
            if (index < chunk->startIndex)
            {
                return NULL;
            }
            if (index < chunk->sta

            {
                return chunk->data[indexInChunk];
            }
        }
        return NULL;
    }
    SparseArray<T> * Copy()
    {
        SparseArray<T> * newSA = SparseArray<T>::New(this->alloc, this->chunkSize);
        SAChunk<T> * chunk, *pred = NULL;
        for (chunk = this->firstChunk; chunk; chunk = chunk->next)
        {
            SAChunk<T> *newChunk = (SAChunk<T> *)this->alloc->Alloc(sizeof(SAChunk<T>) + (sizeof(T *) * this->chunkSize));
            newChunk->startIndex = chunk->startIndex;
            js_memcpy_s(newChunk->data, sizeof(T *) * this->chunkSize, chunk->data, sizeof(T *) * this->chunkSize);
            if (pred)
            {
                pred->next = newChunk;
            }
            else
            {
                newSA->firstChunk = newChunk;
            }
            pred = newChunk;
        }
        if (pred)
        {
            pred->next = NULL;
        }
        else
        {
            newSA->firstChunk = NULL;
     

        return newSA;
    }
    void And(SparseArray<T> *this2)
    {
        SAChunk<T> * chunk, *pred = NULL;
        SAChunk<T> * chunk2;
        AssertMsg(this->chunkSize == this2->chunkSize, "Anding incompatible arrays");
        chunk2 = this2->firstChunk;
        for (chunk = this->firstChunk; chunk; chunk = chunk->next)
        {
            while (chunk2 && chunk->startIndex > chunk2->startIndex)
            {
                chunk2 = chunk2->next;
            }
            if (chunk2 == NULL || chunk->startIndex < chunk2->startIndex)
            {
                if (pred)
                {
                    pred->next = chunk->next;
                }
                else
                {
                    this->firstChunk = chunk->next;
                }
                continue;
            }
            AssertMsg(chunk->startIndex == chunk2->startIndex, "Huh??");
            for (int i = 0; i < this->chunkSize; i++)
            {
                if (chunk->data[i])
 
/* Generated file.  Do not edit */
VTE_SEQUENCE_HANDLER(vte_sequence_handler_AL)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DC)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DL)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_DO)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_IC)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_LE)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_RI)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_SF)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_SR)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_UP)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ae)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_al)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_application_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_as)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bt)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cS)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cd)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ce)
VTE_SEQUENCE_HANDLER(vte_sequ

VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_cursor_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cm)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cs)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ct)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_character_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_lower_left)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_preceding_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cv)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dec_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler

VTE_SEQUENCE_HANDLER(vte_sequence_handler_decset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_delete_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dl)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_do)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_eA)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ec)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ei)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_characters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_display)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_form_feed)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_fs)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_full_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ho)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_horizontal_and_vertical_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ic)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_im)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_index)
VTE_SE

VTE_SEQUENCE_HANDLER(vte_sequence_handler_insert_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_kb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ke)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ks)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_le)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_line_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ll)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_local_charset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_md)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_me)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mh)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mk)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mp)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_mr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_nd)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_noop)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_normal_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_nw)
VTE_SEQUENCE_HANDL

VTE_SEQUENCE_HANDLER(vte_sequence_handler_request_terminal_parameters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_restore_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_id)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_status)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reverse_index)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_save_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_screen_alignment_test)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_down)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_se)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_primary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_secondary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_and_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_title)
VTE_SEQUENCE_HANDLER(vte_sequence_hand

VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region_from_start)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_scrolling_region_to_end)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sf)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_so)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_soft_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_sr)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ta)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_tab_clear)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ts)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_uc)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ue)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_us)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_utf_8_charset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_vb)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ve)
VTE_SEQUENCE_
using namespace boost::python;
using namespace Game;
using namespace Util::STG;
void Defs::Util::LocatorObject::Configurate()
	class_<Locator::LinearF>( "LocatorLinearF", init<>() )
		.def( init<const Locator::LinearF &>() )
		.def( init<const Vector2DF &>() )
		.def( init<const Vector2DF &, const Vector2DF &, const Vector2DF &>() )
		.def( "update", &Locator::LinearF::Update )
		.def_readwrite( "position", &Locator::LinearF::mPos )
		.def_readwrite( "speed", &Locator::LinearF::mSp )
		.def_readwrite( "accel", &Locator::LinearF::mAc )
		.def( "applyExternalForce", &Locator::LinearF::ApplyExternalForce )
		;
	class_<Locator::RotateF>( "LocatorRotateF", init<>() )
		.def( init<const Locator::RotateF &>() )
		.def( "update", &Locator::RotateF::Update )
		.add_property( "position", &Locator::RotateF::GetPosition )
		.def( "applyExternalForce", &Locator::RotateF::ApplyExternalForce )
		.def_readwrite( "center", &Locator::RotateF::mCenter )
		.def_readwrite( "centerSpeed", &Locator::RotateF:

		.def_readwrite( "centerAccel", &Locator::RotateF::mCenterAc )
		.add_property( "radius", &Locator::RotateF::GetRadius, &Locator::RotateF::SetRadius )
		.add_property( "radiusSpeed", &Locator::RotateF::GetRadiusSpeed, &Locator::RotateF::SetRadiusSpeed )
		.add_property( "radiusAccel", &Locator::RotateF::GetRadiusAccel, &Locator::RotateF::SetRadiusAccel )
		.add_property( "angle", &Locator::RotateF::GetAngle, &Locator::RotateF::SetAngle )
		.add_property( "angleSpeed", &Locator::RotateF::GetAngleSpeed, &Locator::RotateF::SetAngleSpeed )
		.add_property( "angleAccel", &Locator::RotateF::GetAngleAccel, &Locator::RotateF::SetAngleAccel )
		;
	class_<Locator::TraceF>( "LocatorTraceF", init<>() )
		.def( init<const Locator::TraceF &>() )
		.def( init<float>() )
		.add_property( "tracing", &Locator::TraceF::IsTracing, &Locator::TraceF::SetTracing )
		.def( "update", &Locator::TraceF::Update )
		.def_readwrite( "position", &Locator::TraceF::mPos )
		.def_readwrite( "targetPosition", &Locator
using namespace vox;
ChunkColumn::ChunkColumn(void) :
	_chunks(nullptr)
ChunkColumn::~ChunkColumn(void)
	if (_chunks != nullptr)
		delete[] _chunks;
bool
ChunkColumn::Init(int PosX, int PosZ, unsigned char* data)
	const int chunkSizeCube = Chunk::CHUNK_SIZE * Chunk::CHUNK_SIZE * Chunk::CHUNK_SIZE;
	_chunks = new (std::nothrow) Chunk[CHUNK_COUNT];
	if (_chunks == nullptr)
		return false;
	_posX = PosX;
	_posZ = PosZ;
	const int spaceBetweenChunk = Chunk::CHUNK_SIZE * 2 * Chunk::CHUNK_SCALE;
	for (int i = 0; i < CHUNK_COUNT; ++i)
	{
		for (int x = 0; x < Chunk::CHUNK_SIZE; ++x)
		{
			for (int y = 0; y < Chunk::CHUNK_SIZE; ++y)
			{
				for (int z = 0; z < Chunk::CHUNK_SIZE; ++z)
				{
					int id = data[i * chunkSizeCube + x + z * 16 + y * 256];
					_chunks[i].setBlockActive(x, y, z, id);
				}
			}
		}
		if (!_chunks[i].createMesh())
			return false;
	}
	return true;
bool
ChunkColumn::InitGL(void)
	for (int i = 0; i < CHUNK_COUNT; ++i)
	{
		if (!_chunks[i].initGL())
			return false;
	

	}
	return true;
bool
ChunkColumn::Render(GLint attrCoord3D, GLint attrVertexColor, GLint attrVertexNormal,
					GLint attrUniformModel, Frustum& frustum, GLint attrTexture)
	glm::mat4	Model;
	float		chunkScale = (float)Chunk::CHUNK_SCALE;
	for (int i = 0 ; i < CHUNK_COUNT ; ++i)
	{
		glm::vec3	pos;
		_chunks[i].getPosition(pos);
		if (frustum.BoxInFrustum(pos.x, pos.y, pos.z, pos.x + Chunk::CHUNK_SIZE * 2,
								 pos.y + Chunk::CHUNK_SIZE * 2, pos.z + Chunk::CHUNK_SIZE * 2) != Frustum::Outside)
		{
			Model = glm::translate(glm::mat4(), pos) *
				glm::scale(chunkScale, chunkScale, chunkScale);
			glUniformMatrix4fv(attrUniformModel, 1, GL_FALSE, &Model[0][0]);
		}
	}
	return true;
void
ChunkColumn::Destroy(void)
bool
ChunkColumn::getBlockAt(int chunkKey, int x, int y, int z, int id)
	if (chunkKey >= 16)
		return false;
	if (x >= 0 && y >= 0 && z >= 0)
	{
		if (x >= 16)
			x = 15;
		if (z >= 16)
			z = 15;
		_chunks[chunkKey].setBlockActive(x, y, z, id);
		_chunks[chunkKey].createM
namespace aspect
  namespace Postprocess
  {
    template <int dim>
    class MaterialModelDependencies : public Interface<dim>,
      public SimulatorAccess<dim>
    {
      public:
        virtual
        std::pair<std::string,std::string>
        execute (TableHandler &statistics)
        {
          using namespace MaterialModel;
          using namespace NonlinearDependence;
          const aspect::MaterialModel::Interface<dim> &model
            = this->get_material_model();
          std::cout << "viscosity depends on"
                    << ((model.get_model_dependence().viscosity & MaterialModel::NonlinearDependence::pressure)
                        ?
                        " pressure" : "")
                    << ((model.get_model_dependence().viscosity & MaterialModel::NonlinearDependence::temperature)
                        ?
                        " temperature" : "")
                    << ((model.get_model_dependence().viscosity & MaterialModel::NonlinearDependence::

                        ?
                        " strainrate" : "")
                    << ((model.get_model_dependence().viscosity & MaterialModel::NonlinearDependence::compositional_fields)
                        ?
                        " composition" : "")
                    << std::endl;
          std::cout << "density depends on"
                    << ((model.get_model_dependence().density & MaterialModel::NonlinearDependence::pressure)
                        ?
                        " pressure" : "")
                    << ((model.get_model_dependence().density & MaterialModel::NonlinearDependence::temperature)
                        ?
                        " temperature" : "")
                    << ((model.get_model_dependence().density & MaterialModel::NonlinearDependence::strain_rate)
                        ?
                        " strainrate" : "")
                    << ((model.get_model_dependence().density & MaterialModel::NonlinearDependence::composition

                        ?
                        " composition" : "")
                    << std::endl;
          std::cout << "compressibility depends on"
                    << ((model.get_model_dependence().compressibility & MaterialModel::NonlinearDependence::pressure)
                        ?
                        " pressure" : "")
                    << ((model.get_model_dependence().compressibility & MaterialModel::NonlinearDependence::temperature)
                        ?
                        " temperature" : "")
                    << ((model.get_model_dependence().compressibility & MaterialModel::NonlinearDependence::strain_rate)
                        ?
                        " strainrate" : "")
                    << ((model.get_model_dependence().compressibility & MaterialModel::NonlinearDependence::compositional_fields)
                        ?
                        " composition" : "")
                    << std::endl;
          std::cout << "specific_heat 

                    << ((model.get_model_dependence().specific_heat & MaterialModel::NonlinearDependence::pressure)
                        ?
                        " pressure" : "")
                    << ((model.get_model_dependence().specific_heat & MaterialModel::NonlinearDependence::temperature)
                        ?
                        " temperature" : "")
                    << ((model.get_model_dependence().specific_heat & MaterialModel::NonlinearDependence::strain_rate)
                        ?
                        " strainrate" : "")
                    << ((model.get_model_dependence().specific_heat & MaterialModel::NonlinearDependence::compositional_fields)
                        ?
                        " composition" : "")
                    << std::endl;
          std::cout << "thermal_conductivity depends on"
                    << ((model.get_model_dependence().thermal_conductivity & MaterialModel::NonlinearDependence::pressure)
                       

                        " pressure" : "")
                    << ((model.get_model_dependence().thermal_conductivity & MaterialModel::NonlinearDependence::temperature)
                        ?
                        " temperature" : "")
                    << ((model.get_model_dependence().thermal_conductivity & MaterialModel::NonlinearDependence::strain_rate)
                        ?
                        " strainrate" : "")
                    << ((model.get_model_dependence().thermal_conductivity & MaterialModel::NonlinearDependence::compositional_fields)
                        ?
                        " composition" : "")
                    << std::endl;
          std::cout << "model is "
                    << (model.is_compressible() ? "compressible" : "incompressible")
                    << std::endl;
          return std::pair<std::string,std::string>();
        }
    };
  }
namespace aspect
  namespace Postprocess
  {
    ASPECT_REGISTER_POSTPROCESSOR(MaterialModelDe
/* 
 * File:   HandlerFactoryConfigure.h
 * Author: wo1fsea
 *
 * Created on March 22, 2014, 10:56 PM
 */
/* The Handler List*/
/* For a new feature handler, add c++ head here. */
/* For example: 
 */
/* For a new feature handler, add the macro here. */
/* For example: 
 *      CREATE_HANDLER(DummyHandler,"/dummy.cgi")  
 */
 CREATE_HANDLER(DummyHandler,"/dummy.cgi")                  \
 CREATE_HANDLER(SigninHandler,"/signin.cgi")                \
 CREATE_HANDLER(SignoutHandler,"/signout.cgi")              \
 CREATE_HANDLER(SignupHandler,"/signup.cgi")                \
 CREATE_HANDLER(FetchNodesHandler,"/fetchnodes.cgi")        \
 CREATE_HANDLER(FetchBriefsHandler,"/fetchbriefs.cgi")      \
 CREATE_HANDLER(FetchArticlesHandler,"/fetcharticles.cgi")  \
 CREATE_HANDLER(CreateArticleHandler,"/createarticle.cgi")  \
 CREATE_HANDLER(ChangeArticleHandler,"/changearticle.cgi")  \
 CREATE_HANDLER(DeleteArticleHandler,"/deletearticle.cgi")  \
 CREATE_HANDLER(CreateNodeHandler,"/createnode.cgi") 
SoftwareRepoRepository::SoftwareRepoRepository(soci::session& db) : dataBase(db)
SoftwareRepoPtr SoftwareRepoRepository::select(const SoftwareRepo& obj)
	soci::row row;
	SoftwareRepoPtr softwarerepo(new SoftwareRepo);
	dataBase << "SELECT  software_repo.software_repo_id as SoftwareRepo_software_repo_id, software_repo.sys_userid as SoftwareRepo_sys_userid, software_repo.sys_groupid as SoftwareRepo_sys_groupid, software_repo.sys_perm_user as SoftwareRepo_sys_perm_user, software_repo.sys_perm_group as SoftwareRepo_sys_perm_group, software_repo.sys_perm_other as SoftwareRepo_sys_perm_other, software_repo.repo_name as SoftwareRepo_repo_name, software_repo.repo_url as SoftwareRepo_repo_url, software_repo.repo_username as SoftwareRepo_repo_username, software_repo.repo_password as SoftwareRepo_repo_password, software_repo.active as SoftwareRepo_active"
	" FROM software_repo "
	"WHERE software_repo.software_repo_id = :SoftwareRepo_software_repo_id", into(row), use(obj);
	if(!dataBase.got_data()

		softwarerepo.reset();
	else
		type_conversion<SoftwareRepo>::from_base(row, i_ok, *softwarerepo);
	return softwarerepo;
SoftwareRepoList SoftwareRepoRepository::select(const string& where)
	soci::rowset<row> rs = 	dataBase.prepare << "SELECT  software_repo.software_repo_id as SoftwareRepo_software_repo_id, software_repo.sys_userid as SoftwareRepo_sys_userid, software_repo.sys_groupid as SoftwareRepo_sys_groupid, software_repo.sys_perm_user as SoftwareRepo_sys_perm_user, software_repo.sys_perm_group as SoftwareRepo_sys_perm_group, software_repo.sys_perm_other as SoftwareRepo_sys_perm_other, software_repo.repo_name as SoftwareRepo_repo_name, software_repo.repo_url as SoftwareRepo_repo_url, software_repo.repo_username as SoftwareRepo_repo_username, software_repo.repo_password as SoftwareRepo_repo_password, software_repo.active as SoftwareRepo_active "
	" FROM software_repo" 
	<< (where.size()?" WHERE "+where:"");
	SoftwareRepoList softwarerepoList;
	for(row& r: rs)
	{
		SoftwareRepoPtr

		type_conversion<SoftwareRepo>::from_base(r, i_ok, *softwarerepo);
		softwarerepoList.push_back(softwarerepo);
	}
	return softwarerepoList;
int SoftwareRepoRepository::insert(const SoftwareRepo& softwarerepo)
	dataBase << "insert into software_repo(software_repo_id, sys_userid, sys_groupid, sys_perm_user, sys_perm_group, sys_perm_other, repo_name, repo_url, repo_username, repo_password, active)\
values(:SoftwareRepo_software_repo_id, :SoftwareRepo_sys_userid, :SoftwareRepo_sys_groupid, :SoftwareRepo_sys_perm_user, :SoftwareRepo_sys_perm_group, :SoftwareRepo_sys_perm_other, :SoftwareRepo_repo_name, :SoftwareRepo_repo_url, :SoftwareRepo_repo_username, :SoftwareRepo_repo_password, :SoftwareRepo_active)", use(softwarerepo);
	int id=0;
	dataBase << "SELECT LAST_INSERT_ID()", soci::into(id);
	return id;
void SoftwareRepoRepository::remove(const SoftwareRepo& softwarerepo)
	dataBase << "DELETE from software_repo WHERE software_repo_id=:SoftwareRepo_software_repo_id", use(softwarerepo);
void

	dataBase << "update software_repo set software_repo_id=:SoftwareRepo_software_repo_id, sys_userid=:SoftwareRepo_sys_userid, sys_groupid=:SoftwareRepo_sys_groupid, sys_perm_user=:SoftwareRepo_sys_perm_user, sys_perm_group=:SoftwareRepo_sys_perm_group, sys_perm_other=:SoftwareRepo_sys_perm_other, repo_name=:SoftwareRepo_repo_name, repo_url=:SoftwareRepo_repo_url, repo_username=:SoftwareRepo_repo_username, repo_password=:SoftwareRepo_repo_password, active=:SoftwareRepo_active WHERE software_repo_id=:SoftwareRepo_software_repo_id", use(softwarerepo);
void SoftwareRepoRepository::update(const SoftwareRepo& oldObj, const SoftwareRepo& newObj)
	dataBase << "update software_repo set software_repo_id=:SoftwareRepo_software_repo_id, sys_userid=:SoftwareRepo_sys_userid, sys_groupid=:SoftwareRepo_sys_groupid, sys_perm_user=:SoftwareRepo_sys_perm_user, sys_perm_group=:SoftwareRepo_sys_perm_group, sys_perm_other=:SoftwareRepo_sys_perm_other, repo_name=:SoftwareRepo_repo_name, repo_url=:SoftwareRep
using namespace HWLib;
DumpableObject::DumpableObject() 
: isDumpStringValid(false)
, dumpString("")
, dumpShortString("")
, isInDump(false)
, SetDumpStringToDo(nullptr)
{};
DumpableObject::DumpableObject(DumpableObject const&other)
: isDumpStringValid(other.isDumpStringValid)
, dumpString(other.dumpString)
, dumpShortString(other.dumpShortString)
, isInDump(false)
, SetDumpStringToDo(nullptr)
{};
DumpableObject::~DumpableObject(){
    SetDumpStringQueueEntry::Remove(SetDumpStringToDo);
bool DumpableObject::EnableSetDumpString = false;
bool DumpableObject::EnableSetDumpStringAsync = true;
void DumpableObject::SetDumpString(){
    if(!c_.IsDebuggerPresent)
        return;
    
    if(!EnableSetDumpString)
        return;
    
    if(EnableSetDumpStringAsync)
        SetDumpStringToDo = SetDumpStringQueueEntry::Insert(*this);
    else
        SetDumpStringWorker();
void DumpableObject::SetDumpStringQueueEntryWait(){
    SetDumpStringQueueEntry::Wait();
String const DumpableObject::SetDum
namespace android {
CFrameDump::CFrameDump() {
    DBGT_PROLOG("");
    mDumpReplay[EPreview].mKey = DynSetting::EPreviewDump;
    mDumpReplay[EPreview].mPrefix = kPreviewFilePfx;
    mDumpReplay[ERecording].mKey = DynSetting::ERecordingDump;
    mDumpReplay[ERecording].mPrefix = kRecordingFilePfx;
    DBGT_EPILOG("");
    return;
CFrameDump::~CFrameDump() {
    DBGT_PROLOG("");
    DBGT_EPILOG("");
    return;
void CFrameDump::getNextFileName(TDumpReplayType aDumpType, const char* aLocation) {
    DBGT_PROLOG("aDumpType: %d, aLocation: %s",aDumpType,aLocation);
    DBGT_ASSERT(aDumpType<EMaxDumpReplay,"invalid Dump Request");
    if (aLocation) {
        snprintf(mDumpReplay[aDumpType].mFilename,FILENAME_MAX,"%s",(char*)aLocation);
    } else {
        mkdir(kFileLocationBase, 777);
        snprintf(mDumpReplay[aDumpType].mFilename,FILENAME_MAX,"%s%s_%d_%d_%s",
                kFileLocationBase,mDumpReplay[aDumpType].mPrefix,
                mDumpReplay[aDumpType].mWidth,mDumpReplay[a

                g_ColorFmtInfo[mDumpReplay[aDumpType].mColorFormat].mColorFmtExtStr);
    }
    DBGT_PTRACE("dumpFilename: %s",mDumpReplay[aDumpType].mFilename);
    DBGT_EPILOG("");
    return;
void CFrameDump::dumpBuffer(void* pBuffer, int aLength, TDumpReplayType aDumpType) {
    if(mDumpReplay[aDumpType].mContinue) {
        DBGT_PROLOG("aDumpType: %d, buffer: 0x%p, length: %d",aDumpType, pBuffer, aLength);
        DBGT_ASSERT(NULL != pBuffer, "pBuffer is NULL");
        DBGT_ASSERT(0 != aLength, "aLength is zero");
        DBGT_ASSERT(aDumpType<EMaxDumpReplay,"invalid Dump Request");
        if(mDumpReplay[aDumpType].mCameraHal && (mDumpReplay[aDumpType].mBufferAllocLen > 0)) {
            OMX_ERRORTYPE omxerr = mDumpReplay[aDumpType].mCameraHal->synchCBData(MMHwBuffer::ESyncAfterWriteHwOperation,
                                                                                  *mDumpReplay[aDumpType].mMMHwBuffer,
                                                                  

            DBGT_PTRACE("omxerr : %d",omxerr);
        }
        int bytesWritten = fwrite(pBuffer,1,aLength,mDumpReplay[aDumpType].mFile);
        if(bytesWritten < aLength) {
            DBGT_CRITICAL("Error dumping frames. Check space available on sdcard/device");
        }
        DBGT_EPILOG();
        return;
    }
void CFrameDump::dumpBuffer(void* pBuffer, TDumpReplayType aDumpType) {
    dumpBuffer(pBuffer,
               (mDumpReplay[aDumpType].mWidth*mDumpReplay[aDumpType].mHeight*g_ColorFmtInfo[mDumpReplay[aDumpType].mColorFormat].mBpp/8),
               aDumpType);
bool CFrameDump::startDump(TDumpReplayType aDumpType, int aWidth, int aHeight, TColorFmt aColorFormat,
                           STECamera* aCameraHal, int aAllocLen, MMHwBuffer* aMMHwBuffer) {
    DBGT_PROLOG("");
    DBGT_PTRACE("aDumpType: %d, aWidth: %d, aHeight: %d",aDumpType, aWidth, aHeight);
    DBGT_ASSERT(aDumpType<EMaxDumpReplay,"invalid Dump Request");
    DBGT_ASSERT(0 != aWidth, "aWidth is zero");

    DBGT_ASSERT(0 != aHeight, "aHeight is zero");
    DBGT_ASSERT(aColorFormat<EMaxColorFmt,"invalid Color Format");
    mDumpReplay[aDumpType].resetData();
    mDumpReplay[aDumpType].setData(aWidth, aHeight, aColorFormat,aCameraHal,aAllocLen,aMMHwBuffer);
    char key[FILENAME_MAX + 1];
    DynSetting::get(mDumpReplay[aDumpType].mKey, key);
    DBGT_PTRACE("key: %s",key);
    if((!strcmp(key,"0")) || (!strcmp(key,""))) {
        mDumpReplay[aDumpType].resetData();
        DBGT_PTRACE("Key not set, not dumping");
        DBGT_EPILOG("");
        return false;
    }
    if (!strcmp(key,"1")) {
        getNextFileName(aDumpType,NULL);
    } else {
        getNextFileName(aDumpType,key);
    }
    mDumpReplay[aDumpType].mFile = fopen(mDumpReplay[aDumpType].mFilename,"wb");
    if(!mDumpReplay[aDumpType].mFile) {
        mDumpReplay[aDumpType].resetData();
        DBGT_PTRACE("Can't open file, not dumping");
        DBGT_EPILOG("");
        return false;
    }
    mDumpReplay[aDumpType].m
namespace chromeos {
static NetworkHandler* g_network_handler = NULL;
NetworkHandler::NetworkHandler()
    : message_loop_(base::MessageLoopProxy::current()) {
  CHECK(DBusThreadManager::IsInitialized());
  network_event_log::Initialize();
  network_state_handler_.reset(new NetworkStateHandler());
  network_device_handler_.reset(new NetworkDeviceHandlerImpl());
  network_profile_handler_.reset(new NetworkProfileHandler());
  network_configuration_handler_.reset(new NetworkConfigurationHandler());
  managed_network_configuration_handler_.reset(
      new ManagedNetworkConfigurationHandlerImpl());
  if (CertLoader::IsInitialized()) {
    network_cert_migrator_.reset(new NetworkCertMigrator());
    client_cert_resolver_.reset(new ClientCertResolver());
  }
  network_activation_handler_.reset(new NetworkActivationHandler());
  network_connection_handler_.reset(new NetworkConnectionHandler());
  network_sms_handler_.reset(new NetworkSmsHandler());
  geolocation_handler_.reset(new Geolocatio

NetworkHandler::~NetworkHandler() {
  network_event_log::Shutdown();
void NetworkHandler::Init() {
  network_state_handler_->InitShillPropertyHandler();
  network_device_handler_->Init(network_state_handler_.get());
  network_profile_handler_->Init();
  network_configuration_handler_->Init(network_state_handler_.get());
  managed_network_configuration_handler_->Init(
      network_state_handler_.get(),
      network_profile_handler_.get(),
      network_configuration_handler_.get(),
      network_device_handler_.get());
  network_connection_handler_->Init(
      network_state_handler_.get(),
      network_configuration_handler_.get(),
      managed_network_configuration_handler_.get());
  if (network_cert_migrator_)
    network_cert_migrator_->Init(network_state_handler_.get());
  if (client_cert_resolver_) {
    client_cert_resolver_->Init(network_state_handler_.get(),
                                managed_network_configuration_handler_.get());
  }
  network_sms_handler_->Init();
 

void NetworkHandler::Initialize() {
  CHECK(!g_network_handler);
  g_network_handler = new NetworkHandler();
  g_network_handler->Init();
void NetworkHandler::Shutdown() {
  CHECK(g_network_handler);
  delete g_network_handler;
  g_network_handler = NULL;
NetworkHandler* NetworkHandler::Get() {
  CHECK(g_network_handler)
      << "NetworkHandler::Get() called before Initialize()";
  return g_network_handler;
bool NetworkHandler::IsInitialized() {
  return g_network_handler;
NetworkStateHandler* NetworkHandler::network_state_handler() {
  return network_state_handler_.get();
NetworkDeviceHandler* NetworkHandler::network_device_handler() {
  return network_device_handler_.get();
NetworkProfileHandler* NetworkHandler::network_profile_handler() {
  return network_profile_handler_.get();
NetworkConfigurationHandler* NetworkHandler::network_configuration_handler() {
  return network_configuration_handler_.get();
ManagedNetworkConfigurationHandler*
NetworkHandler::managed_network_configurati
namespace cell_stream {
void buffer::init(const u32_t size) {
	for (chunk_vector_t::iterator i = _chunk.begin(); i != _chunk.end(); i++) {
		_free_align( *i );
	}
	_chunk.resize( size );
	for (chunk_vector_t::iterator i = _chunk.begin(); i != _chunk.end(); i++) {
		(*i) = (chunk_t*)_malloc_align( sizeof(chunk_t), 7 );
		(*i)->state = E_CHUNK_FREE;
	}
	for (u8_t i = 0; i < E_CHUNK_LENGTH; i++) {
		_index[i]	= 0;
		_count[i]	= 0;
	}
	_count[E_CHUNK_FREE] = _chunk.size();
void buffer::step_chunk(chunk_t* chunk, const chunk_state_t current, const chunk_state_t next) {
	boost::mutex::scoped_lock lock1(_mutex[current]);
	boost::mutex::scoped_lock lock2(_mutex[next]);
	chunk->state = next;
	_count[current]--;
	_count[next]++;
chunk_t* buffer::find_chunk(const chunk_state_t current, const chunk_state_t next) {
	if ( _count[current] == 0 ) return NULL;
	boost::mutex::scoped_lock lock1(_mutex[current]);
	boost::mutex::scoped_lock lock2(_mutex[next]);
	for (
		u32_t i = _index[current];
		((i + 1
/*
* Copyright (C) 2011 The Android Open Source Project
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
typedef void (*GL_FUNC_PTR)();
static GL_FUNC_PTR getGLFuncAddress(const char *funcName) {
    GL_FUNC_PTR ret = NULL;
    static osUtils::dynLibrary* libGL = osUtils::dynLibrary::open("libGL.so");
    ret = (GL_FUNC_PTR)glXGetProcAddress((const GLubyte*)funcName);
    static osUtils::dynLibrary* libGL = osUtils::dynLibrary::open("opengl32");
    ret = (GL_FUNC_PTR)wglGetProcAddress(funcName);
    if(!ret && libGL){
        ret = libGL->findSymbo

    }
    return ret;
                if(funcAddrs)                                         \
                    *(void**)(&name) = funcAddrs;                     \
                else                          \
GLDispatch::GLDispatch():m_isLoaded(false){};
void GLDispatch::dispatchFuncs() {
    android::Mutex::Autolock mutex(m_lock);
    if(m_isLoaded)
        return;
    LOAD_GL_FUNC(glActiveTexture);
    LOAD_GL_FUNC(glAlphaFunc);
    LOAD_GL_FUNC(glBegin);
    LOAD_GL_FUNC(glBindBuffer);
    LOAD_GL_FUNC(glBindTexture);
    LOAD_GL_FUNC(glBlendFunc);
    LOAD_GL_FUNC(glBufferData);
    LOAD_GL_FUNC(glBufferSubData);
    LOAD_GL_FUNC(glClear);
    LOAD_GL_FUNC(glClearColor);
    LOAD_GL_FUNC(glClearDepth);
    LOAD_GL_FUNC(glClearStencil);
    LOAD_GL_FUNC(glClientActiveTexture);
    LOAD_GL_FUNC(glClipPlane);
    LOAD_GL_FUNC(glColor4d);
    LOAD_GL_FUNC(glColor4f);
    LOAD_GL_FUNC(glColor4fv);
    LOAD_GL_FUNC(glColor4ub);
    LOAD_GL_FUNC(glColor4ubv);
    LOAD_GL_FUNC(glColo

    LOAD_GL_FUNC(glColorPointer);
    LOAD_GL_FUNC(glCompressedTexImage2D);
    LOAD_GL_FUNC(glCompressedTexSubImage2D);
    LOAD_GL_FUNC(glCopyTexImage2D);
    LOAD_GL_FUNC(glCopyTexSubImage2D);
    LOAD_GL_FUNC(glCullFace);
    LOAD_GL_FUNC(glDeleteBuffers);
    LOAD_GL_FUNC(glDeleteTextures);
    LOAD_GL_FUNC(glDepthFunc);
    LOAD_GL_FUNC(glDepthMask);
    LOAD_GL_FUNC(glDepthRange);
    LOAD_GL_FUNC(glDisable);
    LOAD_GL_FUNC(glDisableClientState);
    LOAD_GL_FUNC(glDrawArrays);
    LOAD_GL_FUNC(glDrawElements);
    LOAD_GL_FUNC(glEnable);
    LOAD_GL_FUNC(glEnableClientState);
    LOAD_GL_FUNC(glEnd);
    LOAD_GL_FUNC(glFinish);
    LOAD_GL_FUNC(glFlush);
    LOAD_GL_FUNC(glFogf);
    LOAD_GL_FUNC(glFogfv);
    LOAD_GL_FUNC(glFrontFace);
    LOAD_GL_FUNC(glFrustum);
    LOAD_GL_FUNC(glGenBuffers);
    LOAD_GL_FUNC(glGenTextures);
    LOAD_GL_FUNC(glGetBooleanv);
    LOAD_GL_FUNC(glGetBufferParameteriv);
    LOAD_GL_FUNC(glGetClipPlane);
    LOAD_GL_FUNC(glGetDoublev);
    LOA

    LOAD_GL_FUNC(glGetFloatv);
    LOAD_GL_FUNC(glGetIntegerv);
    LOAD_GL_FUNC(glGetLightfv);
    LOAD_GL_FUNC(glGetMaterialfv);
    LOAD_GL_FUNC(glGetPointerv);
    LOAD_GL_FUNC(glGetString);
    LOAD_GL_FUNC(glGetTexEnvfv);
    LOAD_GL_FUNC(glGetTexEnviv);
    LOAD_GL_FUNC(glGetTexParameterfv);
    LOAD_GL_FUNC(glGetTexParameteriv);
    LOAD_GL_FUNC(glHint);
    LOAD_GL_FUNC(glIsBuffer);
    LOAD_GL_FUNC(glIsEnabled);
    LOAD_GL_FUNC(glIsTexture);
    LOAD_GL_FUNC(glLightf);
    LOAD_GL_FUNC(glLightfv);
    LOAD_GL_FUNC(glLightModelf);
    LOAD_GL_FUNC(glLightModelfv);
    LOAD_GL_FUNC(glLineWidth);
    LOAD_GL_FUNC(glLoadIdentity);
    LOAD_GL_FUNC(glLoadMatrixf);
    LOAD_GL_FUNC(glLogicOp);
    LOAD_GL_FUNC(glMaterialf);
    LOAD_GL_FUNC(glMaterialfv);
    LOAD_GL_FUNC(glMultiTexCoord2fv);
    LOAD_GL_FUNC(glMultiTexCoord2sv);
    LOAD_GL_FUNC(glMultiTexCoord3fv);
    LOAD_GL_FUNC(glMultiTexCoord3sv);
    LOAD_GL_FUNC(glMultiTexCoord4fv);
    LOAD_GL_FUNC(glMultiTexCoord4sv);


    LOAD_GL_FUNC(glMultMatrixf);
    LOAD_GL_FUNC(glNormal3f);
    LOAD_GL_FUNC(glNormal3fv);
    LOAD_GL_FUNC(glNormal3sv);
    LOAD_GL_FUNC(glOrtho);
    LOAD_GL_FUNC(glPointParameterf);
    LOAD_GL_FUNC(glPointParameterfv);
    LOAD_GL_FUNC(glPointSize);
    LOAD_GL_FUNC(glPolygonOffset);
    LOAD_GL_FUNC(glRotatef);
    LOAD_GL_FUNC(glScalef);
    LOAD_GL_FUNC(glTexEnvf);
    LOAD_GL_FUNC(glTexEnvfv);
    LOAD_GL_FUNC(glTexParameterf);
    LOAD_GL_FUNC(glTexParameterfv);
    LOAD_GL_FUNC(glMatrixMode);
    LOAD_GL_FUNC(glNormalPointer);
    LOAD_GL_FUNC(glPixelStorei);
    LOAD_GL_FUNC(glPopMatrix);
    LOAD_GL_FUNC(glPushMatrix);
    LOAD_GL_FUNC(glReadPixels);
    LOAD_GL_FUNC(glSampleCoverage);
    LOAD_GL_FUNC(glScissor);
    LOAD_GL_FUNC(glShadeModel);
    LOAD_GL_FUNC(glStencilFunc);
    LOAD_GL_FUNC(glStencilMask);
    LOAD_GL_FUNC(glStencilOp);
    LOAD_GL_FUNC(glTexCoordPointer);
    LOAD_GL_FUNC(glTexEnvi);
    LOAD_GL_FUNC(glTexEnviv);
    LOAD_GL_FUNC(glTexImage2D);
  
class Dummy_Object_Data_Chunk;
class Dummy_Object_Chunk : public Chunk_With_Children
public:
	Dummy_Object_Chunk(Chunk_With_Children* parent,const char* _name ,ChunkVectorInt& _location,ChunkVectorInt& min ,ChunkVectorInt& max ,ChunkQuat& orient);
	Dummy_Object_Chunk (Chunk_With_Children * const parent,const char *, size_t const);
};
class  Dummy_Object_Data_Chunk : public Chunk
public :
	Dummy_Object_Data_Chunk(Dummy_Object_Chunk* parent,const char* _name ,ChunkVectorInt& _location,ChunkVectorInt& min ,ChunkVectorInt& max ,ChunkQuat& orient);
	Dummy_Object_Data_Chunk (Chunk_With_Children * parent, const char * data, size_t );
	~Dummy_Object_Data_Chunk();
/*------------------------**
** Main dummy object data **
**------------------------*/
	char* name;
	ChunkVectorInt location;
	ChunkQuat orientation;
	ChunkVectorInt min_extents;
	ChunkVectorInt max_extents;
/*------------------------**
** Main dummy object data **
**------------------------*/
	size_t size_chunk();
	void fill_data_blo
namespace gin {
typedef V8Test V8MemoryDumpProviderTest;
TEST_F(V8MemoryDumpProviderTest, DumpStatistics) {
  const char track_objects_flag[] = "--track-gc-object-stats";
  v8::V8::SetFlagsFromString(track_objects_flag,
                             static_cast<int>(strlen(track_objects_flag)));
  base::trace_event::MemoryDumpArgs dump_args = {
      base::trace_event::MemoryDumpLevelOfDetail::DETAILED};
  std::unique_ptr<base::trace_event::ProcessMemoryDump> process_memory_dump(
      new base::trace_event::ProcessMemoryDump(nullptr, dump_args));
  instance_->isolate_memory_dump_provider_for_testing()->OnMemoryDump(
      dump_args, process_memory_dump.get());
  const base::trace_event::ProcessMemoryDump::AllocatorDumpsMap&
      allocator_dumps = process_memory_dump->allocator_dumps();
  bool did_dump_isolate_stats = false;
  bool did_dump_space_stats = false;
  bool did_dump_objects_stats = false;
  for (const auto& it : allocator_dumps) {
    const std::string& dump_name = it.first;
namespace Advanced2D {
    Sample::Sample()
    {
        sample = NULL;
        channel = NULL;
    }
    
    Sample::~Sample()
    {
        if (sample != NULL) {
            FMOD_Sound_Release(sample);
            sample = NULL;
        }
    }
    Audio::Audio()
    {
        system = NULL;
    }
    
    Audio::~Audio()
    {
        for (Iterator i = samples.begin(); i != samples.end(); ++i)
        {
            (*i) = NULL;
        }
        
        FMOD_System_Release(system);
    }
    
    bool Audio::Init()
    {
        if (FMOD_System_Create(&system) != FMOD_OK) {
            return false;
        }
    
        if (FMOD_System_Init(system,100,FMOD_INIT_NORMAL,NULL) != FMOD_OK) {
            return false;
        }
    
        return true;
    }
    
    void Audio::Update()
    {
        FMOD_System_Update(system);
    }
    
    
    Sample* Audio::Load(std::string filename)
    {
        if (filename.length() == 0) return false;
        
        Sample *sample = new

    
        try {
            FMOD_RESULT res;
            res = FMOD_System_CreateSound(
            if (res != FMOD_OK) {
                sample = NULL;
            }
        } catch (...) {
            sample = NULL;
        }
            
        return sample;
    }
    
    bool Audio::Load(std::string filename, std::string name)
    {
        if (filename.length() == 0 || name.length() == 0) return false;
        
        Sample *sample = new Sample();
        sample->setName(name);
    
        FMOD_RESULT res;
        res = FMOD_System_CreateSound(
        if (res != FMOD_OK) {
            return false;
        }
        samples.push_back(sample);
    
        return true;    
    }
    
    bool Audio::SampleExists(std::string name)
    {
        for (Iterator i = samples.begin(); i != samples.end(); ++i)
        {
            if ((*i)->getName() == name)
            {
                return true;
            }         
        }
    
        return false;
    }
    
    bo

    {
        Sample *samp = FindSample(name);
        if (samp == NULL) return false;
        
        int index;
        FMOD_Channel_GetIndex(samp->channel, &index);
        
        return (index > 0);
        
    }
        
    Sample *Audio::FindSample(std::string name)
    {
        Sample *sample = NULL;
        for (Iterator i = samples.begin(); i != samples.end(); ++i)
        {
            if ((*i)->getName() == name)
            {
                sample = (*i);
                break;
            }
        }
        return sample;
    }
    
    
    bool Audio::Play(std::string name)
    {
        FMOD_RESULT res;
        Sample *sample = FindSample(name);
    
        if (sample->sample != NULL) {
            try {
                res = FMOD_System_PlaySound(
                    system,
                    FMOD_CHANNEL_FREE, 
                    sample->sample, 
                    true, 
                    &sample->channel);
                if (res!= FMOD_OK) return fa

                
                FMOD_Channel_SetLoopCount(sample->channel, -1);
                FMOD_Channel_SetPaused(sample->channel, false);
                
            } catch (...) {
                return false;
            }
        }
    
        return true;
    }
    
    bool Audio::Play(Sample *sample)
    {
        FMOD_RESULT res;
        if (sample == NULL) return false;
        if (sample->sample == NULL) return false;
    
        res = FMOD_System_PlaySound(
            system,
            FMOD_CHANNEL_FREE,
            sample->sample,
            true,
            &sample->channel);
        if (res!= FMOD_OK) return false;
        FMOD_Channel_SetLoopCount(sample->channel, -1);
        FMOD_Channel_SetPaused(sample->channel, false);
    
        return true;
    }
    
    void Audio::Stop(std::string name)
    {
        if (!IsPlaying(name)) return;
    
        Sample *sample = FindSample(name);
        if (sample == NULL) return;
        
        FMOD_Channel_S
namespace {
struct ChunkProperty {
  uint32_t samples_per_chunk;
  uint32_t sample_description_index;
};
namespace shaka {
namespace media {
namespace mp4 {
const uint32_t kNumChunks = 100;
const ChunkInfo kChunkInfos[] = {
    {1, 8, 1}, {9, 5, 1}, {25, 7, 2}, {48, 63, 2}, {80, 2, 1}};
class ChunkInfoIteratorTest : public testing::Test {
 public:
  ChunkInfoIteratorTest() {
    uint32_t length = sizeof(kChunkInfos) / sizeof(ChunkInfo);
    CHECK(kChunkInfos[0].first_chunk == 1);
    CHECK(kChunkInfos[length - 1].first_chunk <= kNumChunks);
    uint32_t chunk_index = kChunkInfos[0].first_chunk;
    for (uint32_t i = 0; i < length; ++i) {
      uint32_t next_first_chunk =
          (i == length - 1) ? kNumChunks + 1 : kChunkInfos[i + 1].first_chunk;
      for (; chunk_index < next_first_chunk; ++chunk_index) {
        ChunkProperty chunk = {kChunkInfos[i].samples_per_chunk,
                               kChunkInfos[i].sample_description_index};
        chunk_info_table_.push_back(chunk

      }
    }
    sample_to_chunk_.chunk_info.assign(kChunkInfos, kChunkInfos + length);
    chunk_info_iterator_.reset(new ChunkInfoIterator(sample_to_chunk_));
  }
 protected:
  std::vector<ChunkProperty> chunk_info_table_;
  SampleToChunk sample_to_chunk_;
  std::unique_ptr<ChunkInfoIterator> chunk_info_iterator_;
 private:
  DISALLOW_COPY_AND_ASSIGN(ChunkInfoIteratorTest);
};
TEST_F(ChunkInfoIteratorTest, EmptyChunkInfo) {
  SampleToChunk sample_to_chunk;
  ChunkInfoIterator iterator(sample_to_chunk);
  EXPECT_FALSE(iterator.IsValid());
  EXPECT_EQ(0u, iterator.LastFirstChunk());
TEST_F(ChunkInfoIteratorTest, LastFirstChunk) {
  ASSERT_EQ(
      kChunkInfos[sizeof(kChunkInfos) / sizeof(ChunkInfo) - 1].first_chunk,
      chunk_info_iterator_->LastFirstChunk());
TEST_F(ChunkInfoIteratorTest, NumSamples) {
  for (uint32_t i = 0; i < kNumChunks; ++i) {
    for (uint32_t num_samples = 0, j = i; j < kNumChunks; ++j) {
      num_samples += chunk_info_table_[j].samples_per_chunk;
      AS

    }
  }
TEST_F(ChunkInfoIteratorTest, AdvanceChunk) {
  for (uint32_t chunk = 0; chunk < kNumChunks; ++chunk) {
    ASSERT_TRUE(chunk_info_iterator_->IsValid());
    EXPECT_EQ(chunk + 1, chunk_info_iterator_->current_chunk());
    EXPECT_EQ(chunk_info_table_[chunk].samples_per_chunk,
              chunk_info_iterator_->samples_per_chunk());
    EXPECT_EQ(chunk_info_table_[chunk].sample_description_index,
              chunk_info_iterator_->sample_description_index());
    ASSERT_TRUE(chunk_info_iterator_->AdvanceChunk());
  }
TEST_F(ChunkInfoIteratorTest, AdvanceSample) {
  for (uint32_t chunk = 0; chunk < kNumChunks; ++chunk) {
    uint32_t samples_per_chunk = chunk_info_table_[chunk].samples_per_chunk;
    for (uint32_t sample = 0; sample < samples_per_chunk; ++sample) {
      ASSERT_TRUE(chunk_info_iterator_->IsValid());
      EXPECT_EQ(chunk + 1, chunk_info_iterator_->current_chunk());
      EXPECT_EQ(chunk_info_table_[chunk].samples_per_chunk,
                chunk_info_iterato
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
class Repo : public RepoProxy {
  static SimpleMutex s_lock;
  static unsigned s_nRepos;
public:
  struct GlobalData;
  static Repo& get();
 

  static void postfork(pid_t pid);
  /*
   * In some command line programs that use the repo, it is necessary
   * to shut it down at some point in the process.  (See hhbbc.)  This
   * function accomplishes this.
   */
  static void shutdown();
  Repo();
  ~Repo();
  const char* dbName(int repoId) const {
    assert(repoId < RepoIdCount);
    return kDbs[repoId];
  }
  sqlite3* dbc() const { return m_dbc; }
  int repoIdForNewUnit(UnitOrigin unitOrigin) const {
    switch (unitOrigin) {
    case UnitOrigin::File:
      return m_localWritable ? RepoIdLocal : RepoIdCentral;
    case UnitOrigin::Eval:
      return m_evalRepoId;
    default:
      assert(false);
      return RepoIdInvalid;
    }
  }
  std::string repoName(int repoId) const {
    switch (repoId) {
    case RepoIdLocal: return m_localRepo;
    case RepoIdCentral: return m_centralRepo;
    default: return "?";
    }
  }
  UnitRepoProxy& urp() { return m_urp; }
  PreClassRepoProxy& pcrp() { return m_pcrp; }
  FuncRepoProxy& f

  LitstrRepoProxy& lsrp() { return m_lsrp; }
  static void setCliFile(const std::string& cliFile);
  std::unique_ptr<Unit> loadUnit(const std::string& name, const MD5& md5);
  bool findFile(const char* path, const std::string& root, MD5& md5);
  bool insertMd5(UnitOrigin unitOrigin, UnitEmitter* ue, RepoTxn& txn);
  void commitMd5(UnitOrigin unitOrigin, UnitEmitter* ue);
  /*
   * Return the largest size for a static string that can be inserted into the
   * repo.
   */
  size_t stringLengthLimit() const;
  /*
   * Return a vector of (filepath, MD5) for every unit in central
   * repo.
   */
  std::vector<std::pair<std::string,MD5>> enumerateUnits(
    int repoId, bool preloadOnly, bool warn);
  /*
   * Load the repo-global metadata table, including the global litstr
   * table.  Normally called during process initialization.
   */
  void loadGlobalData(bool allowFailure = false);
  /*
   * Access to global data.
   *
   * Pre: loadGlobalData() already called, and
   * RuntimeOption::

   */
  static const GlobalData& global() {
    assert(RuntimeOption::RepoAuthoritative);
    return s_globalData;
  }
  /*
   * Used during repo creation to associate the supplied GlobalData
   * with the repo that was being built.  Also saves the global litstr
   * table.
   *
   * No other threads may be reading or writing the repo GlobalData
   * when this is called.
   */
  void saveGlobalData(GlobalData newData);
 private:
  /*
   * RepoStmts for setting/getting file hashes.
   */
  struct InsertFileHashStmt : public RepoProxy::Stmt {
    InsertFileHashStmt(Repo& repo, int repoId) : Stmt(repo, repoId) {}
    void insert(RepoTxn& txn, const StringData* path, const MD5& md5);
  };
  struct GetFileHashStmt : public RepoProxy::Stmt {
    GetFileHashStmt(Repo& repo, int repoId) : Stmt(repo, repoId) {}
    bool get(const char* path, MD5& md5);
  };
  InsertFileHashStmt m_insertFileHash[RepoIdCount];
  GetFileHashStmt m_getFileHash[RepoIdCount];
 public:
  std::string table(int repoId,

  void exec(const std::string& sQuery);
  void begin();
 private:
  void txPop();
 public:
  void commit();
  bool insertUnit(UnitEmitter* ue, UnitOrigin unitOrigin,
 private:
  static const char* kMagicProduct;
  static const char* kSchemaPlaceholder;
  static const char* kDbs[RepoIdCount];
  void connect();
  void disconnect();
  void initCentral();
  std::string insertSchema(const char* path);
  bool openCentral(const char* repoPath, std::string& errorMsg);
  void initLocal();
  void attachLocal(const char* repoPath, bool isWritable);
  void pragmas(int repoId);
  void getIntPragma(int repoId, const char* name, int& val);
  void setIntPragma(int repoId, const char* name, int val);
  void getTextPragma(int repoId, const char* name, std::string& val);
  void setTextPragma(int repoId, const char* name, const char* val);
  bool initSchema(int repoId, bool& isWritable, std::string& errorMsg);
  bool schemaExists(int repoId);
  bool createSchema(int repoId, std::string& errorMsg);
  bool
WmoGroup::WmoGroup( BufferS_t &grp_buf ) {
  std::stringbuf str_buf( grp_buf );
  std::istream i_str( &str_buf );
  uint32_t chunk_size = 0;
  chunk_size = readChunkHead( i_str, "MVER", (char*)&_mverChunk, sizeof( MverChunk_s ) );
  chunk_size = readChunkHead( i_str, "MOGP", (char*)&_mogpChunk, sizeof( MogpChunk_s ) );
  chunk_size = readChunkHead( i_str, "MOPY", (char*)&_mopyChunk );
  if ( _mopyChunk.size ) {
    _mopyChunk.infos.resize( _mopyChunk.size / sizeof( MopyChunk_s::MaterialInformation_s ) );
    i_str.read( (char*)&_mopyChunk.infos[0], _mopyChunk.size );
  }
  chunk_size = readChunkHead( i_str, "MOVI", (char*)&_moviChunk );
  if ( _moviChunk.size ) {
    _moviChunk.indices.resize( _moviChunk.size / sizeof( uint16_t ) );
    i_str.read( (char*)&_moviChunk.indices[0], _moviChunk.size );
  }
  chunk_size = readChunkHead( i_str, "MOVT", (char*)&_movtChunk );
  if ( _movtChunk.size ) {
    _movtChunk.vertices.resize( _movtChunk.size / sizeof( glm::vec3 ) );
    i_str.read( (cha
using namespace System;
const char* InjectionID::MODEL_A = "InjectionID_MODEL_A";
const char* InjectionID::MODEL_B = "InjectionID_MODEL_B";
int main(array<System::String ^> ^args)
    Console::WriteLine(L"Starting InjectorTests");
    ModelAPtr modelA = ModelAPtr(new ModelA());
    ModelBPtr modelB = ModelBPtr(new ModelB());
    Injector injector;
    injector.Map(modelA, InjectionID::MODEL_A);
    injector.Map(modelB, InjectionID::MODEL_B);
    Console::WriteLine(L"Number of injection " + injector.GetNumInjections());
    if (injector.GetInstanceById<ModelAPtr>(InjectionID::MODEL_A))
    {
        Console::WriteLine(L"Model A found in injector");
    }
    injector.UnMap(modelA);
    if (!injector.HasInjection(InjectionID::MODEL_A))
    {
        Console::WriteLine(L"Model A not found in injector");
    }
    Console::WriteLine(L"Number of injection " + injector.GetNumInjections());
    injector.UnMap(InjectionID::MODEL_B);
    Console::WriteLine(L"Number of injection " + injector.Get
namespace Space
void ChunkWalker::setChunkIndex( const ChunkIndex & index )
    Q_ASSERT( terrain() );
    chunkIndex_ = index;
    if ( const Terrain * terrain = TerrainWalker::terrain() )
    {
        chunkNode_.current = terrain->chunk(index);
        chunkNode_.left = terrain->chunk( index.left() );
        chunkNode_.right = terrain->chunk( index.right() );
        chunkNode_.front = terrain->chunk( index.front() );
        chunkNode_.back = terrain->chunk( index.back() );
    }
Block * ChunkWalker::block( BlockIndex index ) const
    if (!chunkNode_.current)
        return 0;
    if ( const Terrain * terrain = TerrainWalker::terrain() )
    {
        Chunk * target = chunkNode_.current;
        const Size & chunkSize = terrain->chunkSize();
        if ( index.p[2] < 0 || index.p[2] >= static_cast<qint32>(chunkSize.p[2]) )
        {
            return 0;
        }
        if ( index.p[0] < 0 && chunkNode_.left )
        {
            index.p[0] = chunkSize.p[0] - index.p[0];
    
namespace hp_fp
	Maybe<Model>& getModel_IO( Renderer& renderer, Resources& resources,
		const LoadedModelDef& modelDef )
	{
		if ( resources.loadedModels.count( modelDef ) == 0 )
		{
			resources.loadedModels.emplace( modelDef, loadModelFromFile_IO( renderer,
				modelDef.filename, modelDef.scale ) );
		}
		return resources.loadedModels.at( modelDef );
	}
	Maybe<Model>& getModel_IO( Renderer& renderer, Resources& resources,
		const BuiltInModelDef& modelDef )
	{
		if ( resources.builtInModels.count( modelDef ) == 0 )
		{
			switch ( modelDef.type )
			{
			case BuiltInModelType::Cube:
			{
				resources.builtInModels.emplace( modelDef,
					cubeMesh_IO( renderer, modelDef.dimensions ) );
			}
			break;
			default:
				WAR( "Missing built-In model for type " +
					std::to_string( static_cast<UInt8>( modelDef.type ) ) + "." );
			}
		}
		return resources.builtInModels.at( modelDef );
	}
	Maybe<Material>& getMaterial_IO( Renderer& renderer, Resources& resources,
		const MaterialDef& mate

	{
		if ( resources.materials.count( materialDef ) == 0 )
		{
			resources.materials.emplace( materialDef, loadMaterial_IO( renderer, materialDef ) );
		}
		return resources.materials.at( materialDef );
	}
	Maybe<ActorResources> getActorResources_IO( Renderer& renderer, Resources& resources,
		const ActorModelDef& actorModelDef )
	{
		if ( actorModelDef.model.is<LoadedModelDef>( ) )
		{
			Maybe<Model>& model = getModel_IO( renderer, resources,
				actorModelDef.model.loaded );
			return getMaterialForModel_IO( renderer, resources, model,
				actorModelDef.material );
		}
		else if ( actorModelDef.model.is<BuiltInModelDef>( ) )
		{
			Maybe<Model>& model = getModel_IO( renderer, resources,
				actorModelDef.model.builtIn );
			return getMaterialForModel_IO( renderer, resources, model,
				actorModelDef.material );
		}
		return nothing<ActorResources>( );
	}
	namespace
	{
		Maybe<ActorResources> getMaterialForModel_IO( Renderer& renderer, Resources& resources,
			Maybe<Model>& model, c
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
PRLogModuleInfo *gLoadManagerLog = nullptr;
namespace mozilla {
LoadManager::LoadManager(int aLoadMeasurementInterval,
                         int aAveragingMeasurements,
                         float aHighLoadThreshold,
                         float aLowLoadThreshold)
  : mLoadSum(0.0f),
    mLoadSumMeasurements(0),
    mOveruseActive(false),
    mLoadMeasurementInterval(aLoadMeasurementInterval),
    mAveragingMeasurements(aAveragingMeasurements),
    mHighLoadThreshold(aHighLoadThreshold),
    mLowLoadThreshold(aLowLoadThreshold),
    mCurrentState(webrtc::kLoadNormal)
  if (!gLoadManagerLog)
    gLoadManagerLog = PR_NewLogModule("LoadManager");
  LOG(("LoadManager - Initializing (%dms x %d, %f, %f)",
       mLoadMeasurementInterval, mAveragingMeasurements,
   

  MOZ_ASSERT(mHighLoadThreshold > mLowLoadThreshold);
  mLoadMonitor = new LoadMonitor(mLoadMeasurementInterval);
  mLoadMonitor->Init(mLoadMonitor);
  mLoadMonitor->SetLoadChangeCallback(this);
LoadManager::~LoadManager()
  mLoadMonitor->Shutdown();
void
LoadManager::LoadChanged(float aSystemLoad, float aProcesLoad)
  mLoadSum += aSystemLoad;
  mLoadSumMeasurements++;
  if (mLoadSumMeasurements >= mAveragingMeasurements) {
    double averagedLoad = mLoadSum / (float)mLoadSumMeasurements;
    webrtc::CPULoadState oldState = mCurrentState;
    if (mOveruseActive || averagedLoad > mHighLoadThreshold) {
      LOG(("LoadManager - LoadStressed"));
      mCurrentState = webrtc::kLoadStressed;
    } else if (averagedLoad < mLowLoadThreshold) {
      LOG(("LoadManager - LoadRelaxed"));
      mCurrentState = webrtc::kLoadRelaxed;
    } else {
      LOG(("LoadManager - LoadNormal"));
      mCurrentState = webrtc::kLoadNormal;
    }
    if (oldState != mCurrentState)
      LoadHasChanged();
    
namespace gin {
V8IsolateMemoryDumpProvider::V8IsolateMemoryDumpProvider(
    IsolateHolder* isolate_holder)
    : isolate_holder_(isolate_holder) {
  base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(
      this, "V8Isolate", base::ThreadTaskRunnerHandle::Get());
V8IsolateMemoryDumpProvider::~V8IsolateMemoryDumpProvider() {
  base::trace_event::MemoryDumpManager::GetInstance()->UnregisterDumpProvider(
      this);
bool V8IsolateMemoryDumpProvider::OnMemoryDump(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* process_memory_dump) {
  if (isolate_holder_->access_mode() == IsolateHolder::kUseLocker) {
    v8::Locker locked(isolate_holder_->isolate());
    DumpHeapStatistics(args, process_memory_dump);
  } else {
    DumpHeapStatistics(args, process_memory_dump);
  }
  return true;
namespace {
void DumpCodeStatistics(
    base::trace_event::MemoryAllocatorDump* heap_spaces_dump,
    IsolateHolder* isolate_holder) {
  boo

  TRACE_EVENT_CATEGORY_GROUP_ENABLED(
      TRACE_DISABLED_BY_DEFAULT("memory-infra.v8.code_stats"),
      &dump_code_stats);
  if (!dump_code_stats)
    return;
  v8::HeapCodeStatistics code_statistics;
  if (!isolate_holder->isolate()->GetHeapCodeAndMetadataStatistics(
          &code_statistics)) {
    return;
  }
  heap_spaces_dump->AddScalar(
      "code_and_metadata_size",
      base::trace_event::MemoryAllocatorDump::kUnitsBytes,
      code_statistics.code_and_metadata_size());
  heap_spaces_dump->AddScalar(
      "bytecode_and_metadata_size",
      base::trace_event::MemoryAllocatorDump::kUnitsBytes,
      code_statistics.bytecode_and_metadata_size());
void V8IsolateMemoryDumpProvider::DumpHeapStatistics(
    const base::trace_event::MemoryDumpArgs& args,
    base::trace_event::ProcessMemoryDump* process_memory_dump) {
  std::string dump_base_name = base::StringPrintf(
      "v8/isolate_0x%" PRIXPTR,
      reinterpret_cast<uintptr_t>(isolate_holder_->isolate()));
  std::string

  v8::HeapStatistics heap_statistics;
  isolate_holder_->isolate()->GetHeapStatistics(&heap_statistics);
  size_t known_spaces_used_size = 0;
  size_t known_spaces_size = 0;
  size_t known_spaces_physical_size = 0;
  size_t number_of_spaces = isolate_holder_->isolate()->NumberOfHeapSpaces();
  for (size_t space = 0; space < number_of_spaces; space++) {
    v8::HeapSpaceStatistics space_statistics;
    isolate_holder_->isolate()->GetHeapSpaceStatistics(&space_statistics,
                                                       space);
    const size_t space_size = space_statistics.space_size();
    const size_t space_used_size = space_statistics.space_used_size();
    const size_t space_physical_size = space_statistics.physical_space_size();
    known_spaces_size += space_size;
    known_spaces_used_size += space_used_size;
    known_spaces_physical_size += space_physical_size;
    std::string space_dump_name =
        space_name_prefix + "/" + space_statistics.space_name();
    auto* sp

        process_memory_dump->CreateAllocatorDump(space_dump_name);
    space_dump->AddScalar(base::trace_event::MemoryAllocatorDump::kNameSize,
                          base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                          space_physical_size);
    space_dump->AddScalar("virtual_size",
                          base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                          space_size);
    space_dump->AddScalar("allocated_objects_size",
                          base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                          space_used_size);
  }
  std::string other_spaces_name = space_name_prefix + "/other_spaces";
  auto* other_dump =
      process_memory_dump->CreateAllocatorDump(other_spaces_name);
  other_dump->AddScalar(
      base::trace_event::MemoryAllocatorDump::kNameSize,
      base::trace_event::MemoryAllocatorDump::kUnitsBytes,
      heap_statistics.total_physical_size() - known_spaces_physical_size);
  other_dump->

      "allocated_objects_size",
      base::trace_event::MemoryAllocatorDump::kUnitsBytes,
      heap_statistics.used_heap_size() - known_spaces_used_size);
  other_dump->AddScalar("virtual_size",
                        base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                        heap_statistics.total_heap_size() - known_spaces_size);
  if (heap_statistics.does_zap_garbage()) {
    auto* zap_dump = process_memory_dump->CreateAllocatorDump(
        dump_base_name + "/zapped_for_debug");
    zap_dump->AddScalar(base::trace_event::MemoryAllocatorDump::kNameSize,
                        base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                        heap_statistics.total_heap_size() -
                            heap_statistics.total_physical_size());
  }
  std::string malloc_name = dump_base_name + "/malloc";
  auto* malloc_dump = process_memory_dump->CreateAllocatorDump(malloc_name);
  malloc_dump->AddScalar(base::trace_event::MemoryAllocatorDump::kNameSize

                         base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                         heap_statistics.malloced_memory());
  malloc_dump->AddScalar("peak_size",
                         base::trace_event::MemoryAllocatorDump::kUnitsBytes,
                         heap_statistics.peak_malloced_memory());
  const char* system_allocator_name =
      base::trace_event::MemoryDumpManager::GetInstance()
          ->system_allocator_pool_name();
  if (system_allocator_name) {
    process_memory_dump->AddSuballocation(malloc_dump->guid(),
                                          system_allocator_name);
  }
  auto* heap_spaces_dump =
      process_memory_dump->CreateAllocatorDump(space_name_prefix);
  DumpCodeStatistics(heap_spaces_dump, isolate_holder_);
  if (args.level_of_detail !=
      base::trace_event::MemoryDumpLevelOfDetail::DETAILED) {
    return;
  }
  std::string object_name_prefix = dump_base_name + "/heap_objects_at_last_gc";
  bool did_dump_object_stats = false;

  const size_t object_types =
      isolate_holder_->isolate()->NumberOfTrackedHeapObjectTypes();
  for (size_t type_index = 0; type_index < object_types; type_index++) {
    v8::HeapObjectStatistics object_statistics;
    if (!isolate_holder_->isolate()->GetHeapObjectStatisticsAtLastGC(
            &object_statistics, type_index))
      continue;
    std::string dump_name =
        object_name_prefix + "/" + object_statistics.object_type();
    if (object_statistics.object_sub_type()[0] != '\0')
      dump_name += std::string("/") + object_statistics.object_sub_type();
    auto* object_dump = process_memory_dump->CreateAllocatorDump(dump_name);
    object_dump->AddScalar(
        base::trace_event::MemoryAllocatorDump::kNameObjectCount,
        base::trace_event::MemoryAllocatorDump::kUnitsObjects,
        object_statistics.object_count());
    object_dump->AddScalar(base::trace_event::MemoryAllocatorDump::kNameSize,
                           base::trace_event::MemoryAllocatorDump::
/*
 * Copyright 2009  Gregory Haynes <greg@greghaynes.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 */
namespace QInfinity
TextChunk::TextChunk( InfTextChunk *infChunk,
    bool own_chunk )
    : m_infChunk( infChunk )
    , m_own_chunk( own_chunk )
TextChunk::TextChunk( const QString &encoding )
    : m_infChunk( inf_text_chunk_new( encoding.toAscii() ) )
    , m_own_chunk( true )
TextChunk::TextChunk( const TextChunk &other )
    m_infChunk = inf_text_chunk_

    m_own_chunk = true;
TextChunk::~TextChunk()
    if( m_own_chunk )
        inf_text_chunk_free( m_infChunk );
QString TextChunk::encoding() const
    return inf_text_chunk_get_encoding( infChunk() );
unsigned int TextChunk::length() const
    return inf_text_chunk_get_length( infChunk() );
QByteArray TextChunk::text() const
    void *data;
    gsize size;
    data = inf_text_chunk_get_text( infChunk(), &size );
    return QByteArray( (const char*)data, size );
void TextChunk::insertText( unsigned int offset,
    const QByteArray &data,
    unsigned int length,
    unsigned int author )
    inf_text_chunk_insert_text( m_infChunk,
        offset, data.data(),
        data.size(), length,
        author );
void TextChunk::insertChunk( unsigned int offset,
    const TextChunk &chunk )
    inf_text_chunk_insert_chunk( infChunk(), offset,
        chunk.infChunk() );
void TextChunk::erase( unsigned int begin,
    unsigned int end )
    inf_text_chunk_erase( infChunk(),
        begin, end 
/*
* Copyright (C) 2011 The Android Open Source Project
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
typedef void (*GL_FUNC_PTR)();
static GL_FUNC_PTR getGLFuncAddress(const char *funcName) {
    GL_FUNC_PTR ret = NULL;
    static osUtils::dynLibrary* libGL = osUtils::dynLibrary::open("libGL.so.1");
    ret = (GL_FUNC_PTR)glXGetProcAddress((const GLubyte*)funcName);
    static osUtils::dynLibrary* libGL = osUtils::dynLibrary::open("opengl32");
    ret = (GL_FUNC_PTR)wglGetProcAddress(funcName);
    if(!ret && libGL){
        ret = libGL->findSym

    }
    return ret;
                if(funcAddrs)                                         \
                    *(void**)(&name) = funcAddrs;                     \
                else                          \
GLDispatch::GLDispatch():m_isLoaded(false){};
void GLDispatch::dispatchFuncs() {
    android::Mutex::Autolock mutex(m_lock);
    if(m_isLoaded)
        return;
    LOAD_GL_FUNC(glActiveTexture);
    LOAD_GL_FUNC(glAlphaFunc);
    LOAD_GL_FUNC(glBegin);
    LOAD_GL_FUNC(glBindBuffer);
    LOAD_GL_FUNC(glBindTexture);
    LOAD_GL_FUNC(glBlendFunc);
    LOAD_GL_FUNC(glBufferData);
    LOAD_GL_FUNC(glBufferSubData);
    LOAD_GL_FUNC(glClear);
    LOAD_GL_FUNC(glClearColor);
    LOAD_GL_FUNC(glClearDepth);
    LOAD_GL_FUNC(glClearStencil);
    LOAD_GL_FUNC(glClientActiveTexture);
    LOAD_GL_FUNC(glClipPlane);
    LOAD_GL_FUNC(glColor4d);
    LOAD_GL_FUNC(glColor4f);
    LOAD_GL_FUNC(glColor4fv);
    LOAD_GL_FUNC(glColor4ub);
    LOAD_GL_FUNC(glColor4ubv);
    LOAD_GL_FUNC(glColo

    LOAD_GL_FUNC(glColorPointer);
    LOAD_GL_FUNC(glCompressedTexImage2D);
    LOAD_GL_FUNC(glCompressedTexSubImage2D);
    LOAD_GL_FUNC(glCopyTexImage2D);
    LOAD_GL_FUNC(glCopyTexSubImage2D);
    LOAD_GL_FUNC(glCullFace);
    LOAD_GL_FUNC(glDeleteBuffers);
    LOAD_GL_FUNC(glDeleteTextures);
    LOAD_GL_FUNC(glDepthFunc);
    LOAD_GL_FUNC(glDepthMask);
    LOAD_GL_FUNC(glDepthRange);
    LOAD_GL_FUNC(glDisable);
    LOAD_GL_FUNC(glDisableClientState);
    LOAD_GL_FUNC(glDrawArrays);
    LOAD_GL_FUNC(glDrawElements);
    LOAD_GL_FUNC(glEnable);
    LOAD_GL_FUNC(glEnableClientState);
    LOAD_GL_FUNC(glEnd);
    LOAD_GL_FUNC(glFinish);
    LOAD_GL_FUNC(glFlush);
    LOAD_GL_FUNC(glFogf);
    LOAD_GL_FUNC(glFogfv);
    LOAD_GL_FUNC(glFrontFace);
    LOAD_GL_FUNC(glFrustum);
    LOAD_GL_FUNC(glGenBuffers);
    LOAD_GL_FUNC(glGenTextures);
    LOAD_GL_FUNC(glGetBooleanv);
    LOAD_GL_FUNC(glGetBufferParameteriv);
    LOAD_GL_FUNC(glGetClipPlane);
    LOAD_GL_FUNC(glGetDoublev);
    LOA

    LOAD_GL_FUNC(glGetFloatv);
    LOAD_GL_FUNC(glGetIntegerv);
    LOAD_GL_FUNC(glGetLightfv);
    LOAD_GL_FUNC(glGetMaterialfv);
    LOAD_GL_FUNC(glGetPointerv);
    LOAD_GL_FUNC(glGetString);
    LOAD_GL_FUNC(glGetTexEnvfv);
    LOAD_GL_FUNC(glGetTexEnviv);
    LOAD_GL_FUNC(glGetTexParameterfv);
    LOAD_GL_FUNC(glGetTexParameteriv);
    LOAD_GL_FUNC(glHint);
    LOAD_GL_FUNC(glIsBuffer);
    LOAD_GL_FUNC(glIsEnabled);
    LOAD_GL_FUNC(glIsTexture);
    LOAD_GL_FUNC(glLightf);
    LOAD_GL_FUNC(glLightfv);
    LOAD_GL_FUNC(glLightModelf);
    LOAD_GL_FUNC(glLightModelfv);
    LOAD_GL_FUNC(glLineWidth);
    LOAD_GL_FUNC(glLoadIdentity);
    LOAD_GL_FUNC(glLoadMatrixf);
    LOAD_GL_FUNC(glLogicOp);
    LOAD_GL_FUNC(glMaterialf);
    LOAD_GL_FUNC(glMaterialfv);
    LOAD_GL_FUNC(glMultiTexCoord2fv);
    LOAD_GL_FUNC(glMultiTexCoord2sv);
    LOAD_GL_FUNC(glMultiTexCoord3fv);
    LOAD_GL_FUNC(glMultiTexCoord3sv);
    LOAD_GL_FUNC(glMultiTexCoord4fv);
    LOAD_GL_FUNC(glMultiTexCoord4sv);


    LOAD_GL_FUNC(glMultMatrixf);
    LOAD_GL_FUNC(glNormal3f);
    LOAD_GL_FUNC(glNormal3fv);
    LOAD_GL_FUNC(glNormal3sv);
    LOAD_GL_FUNC(glOrtho);
    LOAD_GL_FUNC(glPointParameterf);
    LOAD_GL_FUNC(glPointParameterfv);
    LOAD_GL_FUNC(glPointSize);
    LOAD_GL_FUNC(glPolygonOffset);
    LOAD_GL_FUNC(glRotatef);
    LOAD_GL_FUNC(glScalef);
    LOAD_GL_FUNC(glTexEnvf);
    LOAD_GL_FUNC(glTexEnvfv);
    LOAD_GL_FUNC(glTexParameterf);
    LOAD_GL_FUNC(glTexParameterfv);
    LOAD_GL_FUNC(glMatrixMode);
    LOAD_GL_FUNC(glNormalPointer);
    LOAD_GL_FUNC(glPixelStorei);
    LOAD_GL_FUNC(glPopMatrix);
    LOAD_GL_FUNC(glPushMatrix);
    LOAD_GL_FUNC(glReadPixels);
    LOAD_GL_FUNC(glSampleCoverage);
    LOAD_GL_FUNC(glScissor);
    LOAD_GL_FUNC(glShadeModel);
    LOAD_GL_FUNC(glStencilFunc);
    LOAD_GL_FUNC(glStencilMask);
    LOAD_GL_FUNC(glStencilOp);
    LOAD_GL_FUNC(glTexCoordPointer);
    LOAD_GL_FUNC(glTexEnvi);
    LOAD_GL_FUNC(glTexEnviv);
    LOAD_GL_FUNC(glTexImage2D);
  
SignalHandler* SignalHandler :: instance = NULL;
EventHandler* SignalHandler :: signal_handlers [ NSIG ];
SignalHandler :: SignalHandler () {
SignalHandler* SignalHandler :: getInstance () {
	if ( instance == NULL )
		instance = new SignalHandler ();
	return instance;
void SignalHandler :: destruir () {
	if ( instance != NULL ) {
		delete ( instance );
		instance = NULL;
	}
EventHandler* SignalHandler :: registrarHandler ( int signum,EventHandler* eh ) {
	EventHandler* old_eh = SignalHandler :: signal_handlers [ signum ];
	SignalHandler :: signal_handlers [ signum ] = eh;
	struct sigaction sa;
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = SignalHandler :: dispatcher;
	sigaddset ( &sa.sa_mask,signum );
	return old_eh;
void SignalHandler :: dispatcher ( int signum ) {
	if ( SignalHandler :: signal_handlers [ signum ] != 0 )
		SignalHandler :: signal_handlers [ signum ]->handleSignal ( signum );
int SignalHandler :: removerHandler ( int signum ) {
	SignalHandler :: signal_handlers [ signu
TEST_CASE("ModelTest")
const int N = 10;
SECTION("SpinHalfModel")
    {
    SpinHalf model(N);
    model.op("Sz",2); 
    model.op("S+",2); 
    model.op("S-",2); 
    model.op("Sp",2); 
    model.op("Sm",2); 
    model.op("Sx",2); 
    model.op("Sy",2); 
    model.op("ISy",2); 
    }
SECTION("SpinOneModel")
    {
    SpinOne model(N);
    model.op("Sz",2); 
    model.op("S+",2); 
    model.op("S-",2); 
    model.op("Sp",2); 
    model.op("Sm",2); 
    model.op("Sx",2); 
    model.op("Sy",2); 
    model.op("ISy",2); 
    }
SECTION("HubbardModel")
    {
    Hubbard model(N);
    model.op("Nup",2); 
    model.op("Ndn",2); 
    model.op("Nupdn",2); 
    model.op("Ntot",2); 
    model.op("Sz",2); 
    model.op("Cup",2); 
    model.op("Cdn",2); 
    model.op("Aup",2); 
    model.op("Adn",2); 
    model.op("F",2); 
    }
SECTION("SpinlessModel")
    {
    Spinless model(N);
    model.op("N",2); 
    model.op("A",2); 
    model.op("Adag",2); 
    model.op("F",2); 
    }
SECTION("tJModel")
   
namespace ofxPatches {
	class BlurGaussian : public Base5x5KernelEffect {	
	public:
		BlurGaussian * create() { return new BlurGaussian(); };
		
		BlurGaussian(){
			name = "Gaussian Blur";
			
			fragmentShader += STRINGIFY(
										vec4 sample[25];
										
										void main(void){											
			
											if(pass == 0){											
												for (int i = 0; i < 25; i++){												
													sample[i] = texture2DRect(tex0, gl_TexCoord[0].st + offset[i]);
												}
											}else{
												for (int i = 0; i < 25; i++){												
													sample[i] = texture2DRect(backbuffer, gl_TexCoord[0].st + offset[i]);
												}
											}
											
			
											
											gl_FragColor = (
														   (1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +
														   (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +
														   (7.0  * (sample[2] + sample[10] + sample[14] + s
/* 
 * File:   ObjectModel.cpp
 * Author: Ralph Bisschops <ralph.bisschops@student.uhasselt.be>
 * 
 * Created on June 10, 2014, 8:00 PM
 */
ObjectModel::ObjectModel() {
    pos = new Coordinate(0, 0, 0);
    xsize = 1;
    ysize = 1;
    zsize = 1;
    model = NULL;
    modelOwner = false;
ObjectModel::ObjectModel(double xpos, double ypos, double zpos, double xsize, double ysize, double zsize, Model* model, bool modelOwner){
    pos = new Coordinate(xpos, ypos, zpos);
    this->xsize = xsize;
    this->ysize = ysize;
    this->zsize = zsize;
    this->model = model;
    modelOwner = modelOwner;
ObjectModel::ObjectModel(const ObjectModel& orig) {
    pos = orig.pos;
    xsize = orig.xsize;
    ysize = orig.ysize;
    zsize = orig.zsize;
    model = orig.model;
    modelOwner = false;
void ObjectModel::Draw(){
    glTranslatef(pos->x, pos->y, pos->z);
    model->Draw();
    glTranslatef(-pos->x, -pos->y, -pos->z);
float ObjectModel::getModelZ(float x, float y){
    if(model == NULL){
  
TEST( EnvelopeGenerator, GenerateLinear )
    AudioEngineProps::SAMPLE_RATE = 44100;
    int length = randomInt( 24, 512 );
    SAMPLE_TYPE startAmplitude = randomSample( 0.0, MAX_PHASE );
    SAMPLE_TYPE endAmplitude   = randomSample( 0.0, MAX_PHASE );
    bool fadeIn = ( endAmplitude > startAmplitude );
    SAMPLE_TYPE* table = EnvelopeGenerator::generateLinear( length, startAmplitude, endAmplitude );
    SAMPLE_TYPE sample;
    SAMPLE_TYPE lastSample = fadeIn ? 0.0f : MAX_PHASE;
    for ( int i = 0; i < length; ++i )
    {
        sample = table[ i ];
        ASSERT_TRUE( fadeIn ? sample > lastSample : sample < lastSample )
            << "sample value " << sample << " doesn't match the expectation relative to previous value " << lastSample;
        lastSample = sample;
    }
    delete table;
TEST( EnvelopeGenerator, GenerateExponential )
    int length = randomInt( 25, 1024 );
    SAMPLE_TYPE* table = EnvelopeGenerator::generateExponential( length );
    EXPECT_EQ( 0.0, table[ 0 ]
/**
 * @file ClrSampleReader.h
 * @brief Clr Sample Reader
 * @author OKADA, H.
 * @date 2012/07/18
 * Copyright (C) 2014 Shimadzu Corporation All rights reserved.
 */
namespace kome {
	namespace clr {
		
		/** 
		 * @class ClrSampleReader
		 * @ brief Clr Sample Reader class
		 */
		class ClrSampleReader : public kome::objects::SampleReader{
			
		public:
			/**
			 * @fn ClrSampleReader();
			 * @brief constructor
			 */
			ClrSampleReader();
			
			/**
			 * @fn ~ClrSampleReader();
			 * @brief destructor
			 */
			virtual ~ClrSampleReader();
			/**
			 * @fn void setBaseSampleReader( ClrSampleReaderBase^ baseSampleReader )
			 * @brief set the base sample reader
			 * @param[in] baseSampleReader ClrSampleReaderBase object
			 */
			/**
			 * @fn kome::clr::ClrSampleReaderBase^ ClrSampleReader::getBaseSampleReader()
			 * @brief get the base sample reader
			 * @return ClrSampleReaderBase object
			 */
		private:
			/** base sample reader objec */
			gcroot <ClrSampleReaderBase ^> m
/*
 *  KeyboardController.cpp
 *  openFrameworks
 *
 *  Created by Peter Uithoven on 5/8/09.
 *  Copyright 2009 __MyCompanyName__. All rights reserved.
 *
 */
KeyboardController::KeyboardController()
void KeyboardController::keyPressed(int keyCode)
	cout << "KeyboardController::keyPressed\n";
	switch (keyCode)
	{
		case ' ':
			model->learnBackground();
			break;
		case '+':
		case '=':
			model->setThreshold(model->threshold+1);
			break;
		case '-':
		case '_':
			model->setThreshold(model->threshold-1);
			break;
		case ']':
			model->setHitThreshold(model->hitThreshold+1);
			break;
		case '[':
			model->setHitThreshold(model->hitThreshold-1);
			break;
		case 'd':
			model->debugDetection = !model->debugDetection;
			break;
		case OF_KEY_RETURN:
				model->setState(STATE_GAME);
			break;
		case 'q':
			model->clip6EmptyCorrection -= 1;
			cout << "  model->clip6EmptyCorrection: " << model->clip6EmptyCorrection << "\n";
			break;
		case 'w':
			model->clip6EmptyCorrection += 1;
			
/*
 * graphic/sound.cpp
 *
 */
Sound::Sample::Sample()
    filename     (),
    sample       (0),
    unique       (true),
    loud         (false),
    quiet        (false),
    last_was_loud(false)
Sound::Sample::Sample(const std::string& f)
    filename     (f),
    sample       (0),
    unique       (true),
    loud         (false),
    quiet        (false),
    last_was_loud(false)
    sample = load_sample(filename.c_str());
Sound::Sample::Sample(const Sample& s)
    filename     (s.filename),
    sample       (0),
    unique       (s.unique),
    loud         (s.loud),
    quiet        (s.quiet),
    last_was_loud(s.last_was_loud)
    sample = load_sample(filename.c_str());
Sound::Sample::~Sample()
    if (sample) destroy_sample(sample);
Sound::Sample& Sound::Sample::operator = (const Sample& s)
    if (&s == this) return *this;
    filename      = s.filename;
    unique        = s.unique;
    loud          = s.loud;
    quiet         = s.quiet;
    last_was_loud = s.last_was_lou

    if (sample) destroy_sample(sample);
    sample = load_sample(filename.c_str());
    return *this;
void Sound::Sample::draw()
    if (sample) {
        if (unique && (loud || (quiet && !last_was_loud))) stop_sample(sample);
        if (loud) {
            last_was_loud = true;
            play_sample(sample, useR->sound_volume
             * 256 / 20, 127, 1000, 0);
        }
        else if (quiet) {
            last_was_loud = false;
            play_sample(sample, useR->sound_volume
             *  64 / 20, 127, 1000, 0);
        }
        loud  = false;
        quiet = false;
    }
Sound* Sound::singleton = 0;
Sound::Sound()
    sample(MAX)
        install_sound(DIGI_AUTODETECT, MIDI_NONE, 0);
        install_sound   (DIGI_ALSA, MIDI_NONE, 0)
        && install_sound(DIGI_OSS,  MIDI_NONE, 0);
    set_volume(225, 0);
    const std::string dds = gloB->dir_data_sound.get_rootful();
    sample[DISKSAVE]    = Sample(dds + "disksave.wav");
    sample[JOIN]        = Sample(dds + "join

    sample[PANEL]       = Sample(dds + "panel.wav");
    sample[PANEL_EMPTY] = Sample(dds + "panel_em.wav");
    sample[ASSIGN]      = Sample(dds + "assign.wav");
    sample[CLOCK]       = Sample(dds + "clock.wav");
    sample[LETS_GO]     = Sample(dds + "lets_go.wav");
    sample[HATCH_OPEN]  = Sample(dds + "hatch.wav");
    sample[HATCH_CLOSE] = Sample(dds + "hatch.wav");
    sample[OBLIVION]    = Sample(dds + "oblivion.wav");
    sample[FIRE]        = Sample(dds + "fire.wav");
    sample[WATER]       = Sample(dds + "water.wav");
    sample[GOAL]        = Sample(dds + "goal.wav");
    sample[GOAL_BAD]    = Sample(dds + "goal_bad.wav");
    sample[YIPPIE]      = Sample(dds + "yippie.wav");
    sample[NUKE]        = Sample(dds + "nuke.wav");
    sample[OVERTIME]    = Sample(dds + "overtime.wav");
    sample[OUCH]        = Sample(dds + "ouch.wav");
    sample[SPLAT]       = Sample(dds + "splat.wav");
    sample[OHNO]        = Sample(dds + "ohno.wav");
    sample[POP]         = Sample(d

    sample[BRICK]       = Sample(dds + "brick.wav");
    sample[STEEL]       = Sample(dds + "steel.wav");
    sample[JUMPER]      = Sample(dds + "jumper.wav");
    sample[CLIMBER]     = Sample(dds + "climber.wav");
    sample[BATTER_MISS] = Sample(dds + "bat_miss.wav");
    sample[BATTER_HIT]  = Sample(dds + "bat_hit.wav");
    sample[AWARD_1]     = Sample(dds + "award_1.wav");
    sample[AWARD_2]     = Sample(dds + "award_2.wav");
    sample[AWARD_3]     = Sample(dds + "award_3.wav");
    sample[AWARD_4]     = Sample(dds + "award_4.wav");
Sound::~Sound()
    sample.clear();
    remove_sound();
void Sound::initialize()
    if (singleton) return;
    singleton = new Sound();
void Sound::deinitialize()
    if (!singleton) return;
    delete singleton;
    singleton = 0;
void Sound::play_loud(const Id& id)
    if (!singleton) return;
    if (id < MAX) singleton->sample[id].set_loud();
void Sound::play_quiet(const Id& id)
    if (!singleton) return;
    if (id < MAX) singleton->sample[id]
/*
 * MazingerFF.h
 *
 *  Created on: 22/11/2010
 *      Author: u07286
 */
typedef const char* (*GetUrlHandler) (long  docid);
typedef const char* (*GetTitleHandler) (long  docid);
typedef const char* (*GetDomainHandler) (long  docid);
typedef long (*GetDocumentElementHandler) (long  docid);
typedef char* (*GetCookieHandler) (long  docid);
typedef long* (*GetElementsByTagNameHandler) (long  docid, const char *name);
typedef long (*GetElementByIdHandler) (long  docid, const char *id);
typedef long* (*GetImagesHandler) (long  docid);
typedef long* (*GetLinksHandler) (long  docid);
typedef long* (*GetAnchorsHandler) (long  docid);
typedef long* (*GetFormsHandler) (long  docid);
typedef void (*WriteHandler) (long  docid, const char *str);
typedef void (*WriteLnHandler) (long  docid, const char *str);
typedef long (*CreateElementHandler) (long  docid, const char *str);
typedef const char *(*AppendChildHandler) (long  docid, long parentid, long elementid);
typedef const char *(*InsertBefore

typedef const char *(*GetPropertyHandler) (long  docid, long elementid, const char *attribute);
typedef const char *(*GetAttributeHandler) (long  docid, long elementid, const char *attribute);
typedef const char *(*RemoveAttributeHandler) (long  docid, long elementid, const char *attribute);
typedef const char *(*RemoveChildHandler) (long  docid, long elementid, long childid);
typedef const long *(*GetChildrenHandler) (long  docid, long elementid);
typedef const char *(*GetTagNameHandler) (long  docid, long elementid);
typedef void (*SetPropertyHandler) (long  docid, long elementid, const char* atribute, const char *value);
typedef void (*SetAttributeHandler) (long  docid, long elementid, const char* atribute, const char *value);
typedef long (*GetOffsetParentHandler) (long  docid, long elementid);
typedef long (*GetParentHandler) (long  docid, long elementid);
typedef long (*GetPreviousSiblingHandler) (long  docid, long elementid);
typedef long (*GetNextSiblingHandler) (long  docid, 

typedef const char* (*GetComputedStyleHandler) (long  docid, long elementid, const char *style);
typedef long (*AlertHandler) (long  docid, const char *msg);
typedef long (*SetTextContentHandler) (long  docid, long elementid, const char *msg);
typedef void (*ClickHandler) (long  docid, long elementid);
typedef void (*FocusHandler) (long  docid, long elementid);
typedef void (*BlurHandler) (long  docid, long elementid);
typedef void (*SubscribeHandler) (long  docid, long elementid, const char *event, long eventId);
typedef void (*UnsubscribeHandler) (long  docid, long elementid, const char *event, long eventId);
class AfroditaHandler {
public:
	GetUrlHandler getUrlHandler;
	GetTitleHandler getTitleHandler;
	GetDomainHandler getDomainHandler;
	GetDocumentElementHandler getDocumentElementHandler;
	GetCookieHandler getCookieHandler;
	GetElementsByTagNameHandler getElementsByTagNameHandler;
	GetElementByIdHandler getElementByIdHandler;
	GetImagesHandler getImagesHandler;
	GetLinksHandler g

	GetAnchorsHandler getAnchorsHandler;
	GetFormsHandler getFormsHandler;
	WriteHandler writeHandler;
	WriteLnHandler writeLnHandler;
	CreateElementHandler createElementHandler;
	AlertHandler alertHandler;
	InsertBeforeHandler insertBeforeHandler;
	AppendChildHandler appendChildHandler;
	GetPropertyHandler getPropertyHandler;
	SetPropertyHandler setPropertyHandler;
	GetAttributeHandler getAttributeHandler;
	SetAttributeHandler setAttributeHandler;
	RemoveAttributeHandler removeAttributeHandler;
	RemoveChildHandler removeChildHandler;
	GetParentHandler getParentHandler;
	GetOffsetParentHandler getOffsetParentHandler;
	GetPreviousSiblingHandler getPreviousSiblingHandler;
	GetNextSiblingHandler getNextSiblingHandler;
	GetChildrenHandler getChildrenHandler;
	GetTagNameHandler getTagNameHandler;
	SetTextContentHandler setTextContentHandler;
	GetComputedStyleHandler getComputedStyleHandler;
	ClickHandler clickHandler;
	FocusHandler focusHandler;
	BlurHandler blurHandler;
	SubscribeHandler sub
ModelCollection::ModelCollection(string f)
	fileName=f;
ModelCollection::ModelCollection(void)
ModelCollection::~ModelCollection(void)
bool ModelCollection::ParseModelData()
	int modelCount=0;
	int currentVertex;
	ifstream modelFile;
	modelFile.open(fileName+".txt");
	string line;
	char buffer[100];
	while(modelFile)
	{
		modelFile.getline(buffer,100);
		line=buffer;
		if(buffer[0]=='v')
		{
			/*modelFile >> model.m_model[currentVertex].x >> model.m_model[currentVertex].y >> model.m_model[currentVertex].z;
			modelFile >> model.m_model[currentVertex].tu >> model.m_model[currentVertex].tv;
			modelFile >> model.m_model[currentVertex].nx >> model.m_model[currentVertex].ny >> model.m_model[currentVertex].nz;*/
			float f[8];
			int start=2;
			int end=start;
			for(int i=0;i<8;i++)
			{
				while((buffer[end]!=' ' ) && ( end<line.length()))
				{
					end++;
				}
				f[i]=stof(line.substr(start,end-start));
				
				start=end+1;
				end=start+1;
			}
			model->m_model[currentVertex].x=f

			model->m_model[currentVertex].y=f[1];
			model->m_model[currentVertex].z=f[2];
			model->m_model[currentVertex].tu=f[3];
			model->m_model[currentVertex].tv=f[4];
			model->m_model[currentVertex].nx=f[5];
			model->m_model[currentVertex].ny=f[6];
			model->m_model[currentVertex].nz=f[7];
			currentVertex++;
		}
		if(buffer[0]=='c')
		{
			int start=6;
			int end=start;
			while(buffer[end]!=' ')
			{
				end++;
			}
			end++;
			int vertexCount=stoi(line.substr(start,end-start));
			model->setNumVerts(vertexCount);
		}
		if(buffer[0]=='M')
		{
		}
		if(buffer[0]=='T')
		{
			int start=3;
			int end=start;
			while(buffer[end]!=' ')
			{
				end++;
			}
			end++;
			model->textureName=line.substr(start,end-start);
		}
			
		if((buffer[0]=='D') && (buffer[1]=='i'))
		{
			int start=3;
			int end=start;
			float f[3];
			for(int i=0;i<3;i++)
			{
				while((buffer[end]!=' ' ) && ( end<line.length()))
				{
					end++;
				}
				f[i]=stof(line.substr(start,end-start));
				
				start=e

				end=start+1;
			}
			model->setDiffuseColor(f[0],f[1],f[2]);
		}
		if(buffer[0]=='A')
		{
			int start=3;
			int end=start;
			float f[3];
			for(int i=0;i<3;i++)
			{
				while((buffer[end]!=' ' ) && ( end<line.length()))
				{
					end++;
				}
				f[i]=stof(line.substr(start,end-start));
				
				start=end+1;
				end=start+1;
			}
			model->setAmbientColor(f[0],f[1],f[2]);
		}
		{
			int start=3;
			int end=start;
			while(buffer[end]!=' ')
			{
				end++;
			}
			end++;
			model->textureName2=line.substr(start,end-start);
		}
		if(buffer[0]=='S')
		{
			int start=3;
			int end=start;
			float f[3];
			for(int i=0;i<3;i++)
			{
				while((buffer[end]!=' ' ) && ( end<line.length()))
				{
					end++;
				}
				f[i]=stof(line.substr(start,end-start));
				
				start=end+1;
				end=start+1;
			}
			model->setSpecularColor(f[0],f[1],f[2]);
		}
		if(buffer[0]=='O')
		{
		}
		if(buffer[0]=='o')
		{
			if(modelCount>0)
			{
				modelMeshes.push_back(model);
				
			}
			int start=2;
	
CMap::CMap() {
int CMap::getKey(int iChunkX, int iChunkY) {
	iChunkX &= 0xFFFF;
	iChunkY &= 0xFFFF;
	return (iChunkY << 16) | iChunkX;
void CMap::addMapChunk(int iChunkX, int iChunkY) {
	if (!mapChunkExist(iChunkX, iChunkY)) {
		CMapChunk *newMapChunk = new CMapChunk(iChunkX, iChunkY);
		mapChunks[getKey(iChunkX, iChunkY)] = newMapChunk;
	}
	fixChunkBorder(iChunkX, iChunkY);
void CMap::remMapChunk(int iChunkX, int iChunkY) {
	if (mapChunkExist(iChunkX, iChunkY)) {
		mapChunks.erase(getKey(iChunkX, iChunkY));
	}
	fixChunkBorder(iChunkX, iChunkY);
CMapChunk *CMap::getMapChunk(int iChunkX, int iChunkY) {
	if (mapChunkExist(iChunkX, iChunkY)) {
		return mapChunks[getKey(iChunkX, iChunkY)];
	}
	return NULL;
bool CMap::mapChunkExist(int iChunkX, int iChunkY) {
	if (mapChunks.count(getKey(iChunkX, iChunkY))) {
		return true;
	}
	return false;
void CMap::fixChunkBorder(int iChunkX, int iChunkY) {
	CMapChunk *centerChunk = getMapChunk(iChunkX, iChunkY);
	CMapChunk *request = getMapChunk(iChunkX

	if (centerChunk && request) {
		centerChunk->addState(CMAPCHUNK_STATE_HASUP);
		request->addState(CMAPCHUNK_STATE_HASDOWN);
	}
	else if (centerChunk) {
		centerChunk->remState(CMAPCHUNK_STATE_HASUP);
	}
	else if (request) {
		request->remState(CMAPCHUNK_STATE_HASDOWN);
	}
	request = getMapChunk(iChunkX - 1, iChunkY);
	if (centerChunk && request) {
		centerChunk->addState(CMAPCHUNK_STATE_HASLEFT);
		request->addState(CMAPCHUNK_STATE_HASRIGHT);
	}
	else if (centerChunk) {
		centerChunk->remState(CMAPCHUNK_STATE_HASLEFT);
	}
	else if (request) {
		request->remState(CMAPCHUNK_STATE_HASRIGHT);
	}
	request = getMapChunk(iChunkX, iChunkY - 1);
	if (centerChunk && request) {
		centerChunk->addState(CMAPCHUNK_STATE_HASDOWN);
		request->addState(CMAPCHUNK_STATE_HASUP);
	}
	else if (centerChunk) {
		centerChunk->remState(CMAPCHUNK_STATE_HASDOWN);
	}
	else if (request) {
		request->remState(CMAPCHUNK_STATE_HASUP);
	}
	request = getMapChunk(iChunkX + 1, iChunkY);
	if (centerChunk && request) {
		
/**
 * @author William R. Otte <wotte@dre.vanderbilt.edu>
 * @author Johnny Willemsen (jwillemsen@remedy.nl)
 *
 * $Id: SampleInfoSeq.h 95809 2012-06-03 17:56:00Z johnnyw $
 *
 * Wrapper facade for NDDS.
 */
inline void
operator<<= (::DDS::SampleInfo& sample_info, const ::DDS_SampleInfo& dds_sample_info)
  sample_info.sample_state = dds_sample_info.sample_state;
  sample_info.view_state = dds_sample_info.view_state;
  sample_info.instance_state = dds_sample_info.instance_state;
  sample_info.source_timestamp <<= dds_sample_info.source_timestamp;
  sample_info.instance_handle <<= dds_sample_info.instance_handle;
  sample_info.publication_handle <<= dds_sample_info.publication_handle;
  sample_info.disposed_generation_count = dds_sample_info.disposed_generation_count;
  sample_info.no_writers_generation_count = dds_sample_info.no_writers_generation_count;
  sample_info.sample_rank = dds_sample_info.sample_rank;
  sample_info.generation_rank = dds_sample_info.generation_rank;
  sample_inf
namespace content {
WebProcessMemoryDumpImpl::WebProcessMemoryDumpImpl()
    : owned_process_memory_dump_(
          new base::trace_event::ProcessMemoryDump(nullptr)),
      process_memory_dump_(owned_process_memory_dump_.get()),
      level_of_detail_(base::trace_event::MemoryDumpLevelOfDetail::DETAILED) {}
WebProcessMemoryDumpImpl::WebProcessMemoryDumpImpl(
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : process_memory_dump_(process_memory_dump),
      level_of_detail_(level_of_detail) {}
WebProcessMemoryDumpImpl::~WebProcessMemoryDumpImpl() {
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createMemoryAllocatorDump(
    const blink::WebString& absolute_name) {
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocatorDump(absolute_name.utf8());
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
Web

    const blink::WebString& absolute_name,
    blink::WebMemoryAllocatorDumpGuid guid) {
  base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
      process_memory_dump_->CreateAllocatorDump(
          absolute_name.utf8(),
          base::trace_event::MemoryAllocatorDumpGuid(guid));
  return createWebMemoryAllocatorDump(memory_allocator_dump);
blink::WebMemoryAllocatorDump*
WebProcessMemoryDumpImpl::createWebMemoryAllocatorDump(
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump) {
  if (!memory_allocator_dump)
    return nullptr;
  WebMemoryAllocatorDumpImpl* web_memory_allocator_dump_impl =
      new WebMemoryAllocatorDumpImpl(memory_allocator_dump);
  memory_allocator_dumps_.set(memory_allocator_dump,
                              make_scoped_ptr(web_memory_allocator_dump_impl));
  return web_memory_allocator_dump_impl;
blink::WebMemoryAllocatorDump* WebProcessMemoryDumpImpl::getMemoryAllocatorDump(
    const blink::WebString& absolute_name) const {
  ba

      process_memory_dump_->GetAllocatorDump(absolute_name.utf8());
  if (!memory_allocator_dump)
    return nullptr;
  blink::WebMemoryAllocatorDump* web_memory_allocator_dump =
      memory_allocator_dumps_.get(memory_allocator_dump);
  DCHECK(web_memory_allocator_dump);
  return web_memory_allocator_dump;
void WebProcessMemoryDumpImpl::clear() {
  memory_allocator_dumps_.clear();
  process_memory_dump_->Clear();
void WebProcessMemoryDumpImpl::takeAllDumpsFrom(
    blink::WebProcessMemoryDump* other) {
  auto other_impl = static_cast<WebProcessMemoryDumpImpl*>(other);
  process_memory_dump_->TakeAllDumpsFrom(other_impl->process_memory_dump_);
  const size_t expected_final_size = memory_allocator_dumps_.size() +
                                     other_impl->memory_allocator_dumps_.size();
  while (!other_impl->memory_allocator_dumps_.empty()) {
    auto first_entry = other_impl->memory_allocator_dumps_.begin();
    base::trace_event::MemoryAllocatorDump* memory_allocator_dump =
  

    memory_allocator_dumps_.set(
        memory_allocator_dump,
        other_impl->memory_allocator_dumps_.take_and_erase(first_entry).Pass());
  }
  DCHECK_EQ(expected_final_size, memory_allocator_dumps_.size());
  DCHECK(other_impl->memory_allocator_dumps_.empty());
void WebProcessMemoryDumpImpl::addOwnershipEdge(
    blink::WebMemoryAllocatorDumpGuid source,
    blink::WebMemoryAllocatorDumpGuid target,
    int importance) {
  process_memory_dump_->AddOwnershipEdge(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      base::trace_event::MemoryAllocatorDumpGuid(target), importance);
void WebProcessMemoryDumpImpl::addOwnershipEdge(
    blink::WebMemoryAllocatorDumpGuid source,
    blink::WebMemoryAllocatorDumpGuid target) {
  process_memory_dump_->AddOwnershipEdge(
      base::trace_event::MemoryAllocatorDumpGuid(source),
      base::trace_event::MemoryAllocatorDumpGuid(target));
void WebProcessMemoryDumpImpl::addSuballocation(
    blink::WebMemoryAllocatorDumpGuid source
namespace skia {
namespace {
const char kMallocBackingType[] = "malloc";
SkiaTraceMemoryDumpImpl::SkiaTraceMemoryDumpImpl(
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : SkiaTraceMemoryDumpImpl("", level_of_detail, process_memory_dump) {}
SkiaTraceMemoryDumpImpl::SkiaTraceMemoryDumpImpl(
    const std::string& dump_name_prefix,
    base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
    base::trace_event::ProcessMemoryDump* process_memory_dump)
    : dump_name_prefix_(dump_name_prefix),
      process_memory_dump_(process_memory_dump),
      request_level_(
          level_of_detail == base::trace_event::MemoryDumpLevelOfDetail::LIGHT
              ? SkTraceMemoryDump::kLight_LevelOfDetail
              : SkTraceMemoryDump::kObjectsBreakdowns_LevelOfDetail) {}
SkiaTraceMemoryDumpImpl::~SkiaTraceMemoryDumpImpl() {}
void SkiaTraceMemoryDumpImpl::dumpNumericValue(const char* dumpName,
            

                                               const char* units,
                                               uint64_t value) {
  auto dump = process_memory_dump_->GetOrCreateAllocatorDump(dumpName);
  dump->AddScalar(valueName, units, value);
void SkiaTraceMemoryDumpImpl::setMemoryBacking(const char* dumpName,
                                               const char* backingType,
                                               const char* backingObjectId) {
  if (strcmp(backingType, kMallocBackingType) == 0) {
    auto dump = process_memory_dump_->GetOrCreateAllocatorDump(dumpName);
    const char* system_allocator_name =
        base::trace_event::MemoryDumpManager::GetInstance()
            ->system_allocator_pool_name();
    if (system_allocator_name) {
      process_memory_dump_->AddSuballocation(dump->guid(),
                                             system_allocator_name);
    }
  } else {
    NOTREACHED();
  }
void SkiaTraceMemoryDumpImpl::setDiscardableMemoryBacking(
  
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoNodeTexture::RepoNodeTexture(
        const std::string &name,
        const char *data,
		const unsigned int byteCount,
		const unsigned int width,
        const unsigned int height)
    : RepoNodeAbstract (
			REPO_NODE_TYPE_TEXTURE, 
			REPO_NODE_API_LEVEL_1,
            boost::uuids::random_generator()(),
            name)
    , 

    , height(height) /*,
		bitDepth(bitDepth),
		format(format) */
	this->data = new std::vector<char>(byteCount);
    if (!this->data)
        std::cerr << "Memory allocation for texture " << name << " failed." << std::endl;
    else
        memcpy(&(this->data->at(0)), data, byteCount);
		
	this->name = boost::filesystem::path(name).stem().string();
	this->extension = boost::filesystem::extension(name);
    this->extension = this->extension.substr(1, this->extension.size());
repo::core::RepoNodeTexture::RepoNodeTexture(const mongo::BSONObj &obj)
    : RepoNodeAbstract(obj)
    , data(NULL)
    if (obj.hasField(REPO_LABEL_WIDTH))
        width = obj.getField(REPO_LABEL_WIDTH).numberInt();
    if (obj.hasField(REPO_LABEL_HEIGHT))
        height = obj.getField(REPO_LABEL_HEIGHT).numberInt();
	if (obj.hasField(REPO_NODE_LABEL_EXTENSION)) {
		extension = obj.getField(REPO_NODE_LABEL_EXTENSION).str();
	}
    if (obj.hasField(REPO_LABEL_DATA) &&
		obj.hasField(REPO_NODE_LABEL_DATA_BYTE_COU

	{
        std::cerr << "Texture" << std::endl;
		data = new std::vector<char>();
		RepoTranscoderBSON::retrieve(
            obj.getField(REPO_LABEL_DATA),
			obj.getField(REPO_NODE_LABEL_DATA_BYTE_COUNT).numberInt(),
			data);
	}	
repo::core::RepoNodeTexture::~RepoNodeTexture() 
	if (NULL != data)
	{
		data->clear();
		delete data;
		data = NULL;
	}
bool repo::core::RepoNodeTexture::operator==(const RepoNodeAbstract& other) const
    const RepoNodeTexture *otherTexture = dynamic_cast<const RepoNodeTexture*>(&other);
    return otherTexture &&
            RepoNodeAbstract::operator==(other) &&
            this->getWidth() == otherTexture->getWidth() &&
            this->getHeight() == otherTexture->getHeight() &&
            this->getExtension() == otherTexture->getExtension() &&
            std::equal(this->getData()->begin(),
                       this->getData()->end(),
                       otherTexture->getData()->begin());
mongo::BSONObj repo::core::RepoNodeTexture::toBSONObj
/*
 * MacGitver
 * Copyright (C) 2012-2013 The MacGitver-Developers <dev@macgitver.org>
 *
 * (C) Nils Fenner <nils@macgitver.org>
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU General Public License (Version 2) as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if
 *
 */
typedef Fixture IndexFixture;
TEST_F(IndexFixture, CanRead)
    Git::Result r;
    TempRepoOpener tempRepo(this, "SimpleRepo1", r);
    CHECK_GIT_RESULT(r);
    Git::Repository repo(tempRepo);
    ASSERT_TRUE( repo.isValid() );
    Git::Index repoIndex = repo.index( r );
    CHECK_GIT_RESULT( r );
    ASSERT_TRUE( repoIndex.is
struct WaypointLink
	int index;
	int flags;
};
struct ModuleLink
	~ModuleLink();
	char*  module_name;
	int flags;
};
struct ChunkWaypoint
	ChunkWaypoint();
	~ChunkWaypoint();
	int index;
	int NumWPLinks;
	WaypointLink* WayLinks;
	int NumModLinks;
	ModuleLink* ModLinks;
	int flags,spare2;
};
class Module_Waypoint_Chunk : public Chunk
	public :
	Module_Waypoint_Chunk(Chunk_With_Children*,const char *,size_t);
	Module_Waypoint_Chunk(Chunk_With_Children*);
	~Module_Waypoint_Chunk();
	virtual size_t size_chunk();
	virtual void fill_data_block(char* data_start);
	void TransferWaypointData(Module_Waypoint_Chunk*);
	int NumWaypoints;
	ChunkWaypoint* Waypoints;
	ChunkWaypoint* AlienWaypoints;
	ChunkWaypoint* GroundWaypoints;
	short NumAlienWaypoints;
	short NumGroundWaypoints;
	int spare1;
	int spare2;
};
class AI_Module_Master_Chunk : public Chunk
	public :
	AI_Module_Master_Chunk(Chunk_With_Children*,const char*,size_t);
	AI_Module_Master_Chunk(Object_Module_Data_Chunk*);
	virtual size_t size
using content::BrowserThread;
BookmarkModelTask::BookmarkModelTask(BookmarkModel* model)
    : model_(model) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(model_);
  model_->BlockTillLoaded();
BookmarkModel* BookmarkModelTask::model() const {
  return model_;
BookmarkModelObserverTask::BookmarkModelObserverTask(
    BookmarkModel* bookmark_model)
    : BookmarkModelTask(bookmark_model) {
  model()->AddObserver(this);
BookmarkModelObserverTask::~BookmarkModelObserverTask() {
  model()->RemoveObserver(this);
void BookmarkModelObserverTask::BookmarkModelLoaded(BookmarkModel* model,
                                                    bool ids_reassigned) {}
void BookmarkModelObserverTask::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
void BookmarkModelObserverTask::BookmarkNodeAdded(BookmarkModel* model,
                                                  cons
template<unsigned short n>
void
eye_capture(Goban<n> g)
  g.play(2, 3, Black);
  g.play(3, 3, White);
  g.play(2, 6, Black);
  g.play(3, 4, White);
  g.play(2, 4, White);
  g.play(1, 3, White);
  /* White captures one black stone */
  g.play(2, 2, White);
  g.play(1, 2, White);
  g.play(0, 2, Black);
  g.play(0, 3, Black);
  g.play(1, 1, Black);
  g.play(1, 4, Black);
  g.play(2, 1, Black);
  g.play(3, 2, Black);
  g.play(2, 5, Black);
  g.play(3, 5, Black);
  g.play(4, 3, Black);
  g.play(4, 4, Black);
  g.dump();
  g.dump_groups();
  g.play(2, 3, Black);
  g.dump();
  g.dump_groups();
  /* Black kills the white false-eye */
  g.play(0, 1, Black);
  g.play(0, 4, Black);
  g.play(3, 1, Black);
  g.play(4, 2, Black);
  g.play(2, 4, Black);
  g.dump();
  g.dump_groups();
  /* And forms two eyes */
template<unsigned short n>
void
links(Goban<n> g)
  g.play(6, 5, Black);
  g.play(8, 7, Black);
  g.play(10, 5, Black);
  g.play(8, 3, Black);
  g.dump();
  g.dump_groups();
  g.dump_links();
 
/*
** $Id: ldump.c,v 2.34 2014/11/02 19:19:04 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
  lua_State *L;
  lua_Writer writer;
  void *data;
  int strip;
  int status;
} DumpState;
/*
** All high-level dumps go through DumpVector; you can change it to
** change the endianness of the result
*/
static void DumpBlock (const void *b, size_t size, DumpState *D) {
  if (D->status == 0) {
    lua_unlock(D->L);
    D->status = (*D->writer)(D->L, b, size, D->data);
    lua_lock(D->L);
  }
static void DumpByte (int y, DumpState *D) {
  lu_byte x = (lu_byte)y;
  DumpVar(x, D);
static void DumpInt (int x, DumpState *D) {
  DumpVar(x, D);
static void DumpNumber (lua_Number x, DumpState *D) {
  DumpVar(x, D);
static void DumpInteger (lua_Integer x, DumpState *D) {
  DumpVar(x, D);
static void DumpString (const TString *s, DumpState *D) {
  if (s == NULL)
    DumpByte(0, D);
  else {
    if (size < 0xFF)
      DumpByte(cast_int(size), D);
    else

      DumpByte(0xFF, D);
      DumpVar(size, D);
    }
    DumpVector(getstr(s), size - 1, D);  /* no need to save '\0' */
  }
static void DumpCode (const Proto *f, DumpState *D) {
  DumpInt(f->sizecode, D);
  DumpVector(f->code, f->sizecode, D);
static void DumpFunction(const Proto *f, TString *psource, DumpState *D);
static void DumpConstants (const Proto *f, DumpState *D) {
  int i;
  int n = f->sizek;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    const TValue *o = &f->k[i];
    DumpByte(ttype(o), D);
    switch (ttype(o)) {
    case LUA_TNIL:
      break;
    case LUA_TBOOLEAN:
      DumpByte(bvalue(o), D);
      break;
    case LUA_TNUMFLT:
      DumpNumber(fltvalue(o), D);
      break;
    case LUA_TNUMINT:
      DumpInteger(ivalue(o), D);
      break;
    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      DumpString(tsvalue(o), D);
      break;
    default:
      lua_assert(0);
    }
  }
static void DumpProtos (const Proto *f, DumpState *D) {
  int i;
  int n = f->sizep;
  DumpIn

  for (i = 0; i < n; i++)
    DumpFunction(f->p[i], f->source, D);
static void DumpUpvalues (const Proto *f, DumpState *D) {
  int i, n = f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpByte(f->upvalues[i].instack, D);
    DumpByte(f->upvalues[i].idx, D);
  }
static void DumpDebug (const Proto *f, DumpState *D) {
  int i, n;
  n = (D->strip) ? 0 : f->sizelineinfo;
  DumpInt(n, D);
  DumpVector(f->lineinfo, n, D);
  n = (D->strip) ? 0 : f->sizelocvars;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpString(f->locvars[i].varname, D);
    DumpInt(f->locvars[i].startpc, D);
    DumpInt(f->locvars[i].endpc, D);
  }
  n = (D->strip) ? 0 : f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpString(f->upvalues[i].name, D);
static void DumpFunction (const Proto *f, TString *psource, DumpState *D) {
  if (D->strip || f->source == psource)
    DumpString(NULL, D);  /* no debug info or same source as its parent */
  else
    DumpString(f->source, D);
  D
ACEXML_INLINE
ACEXML_Parser_Context::ACEXML_Parser_Context()
  : instream_ (0),
    locator_ (0)
ACEXML_INLINE
ACEXML_Parser_Context::ACEXML_Parser_Context (ACEXML_InputSource* instream,
                                              ACEXML_LocatorImpl* locator)
  : instream_ (instream),
    locator_ (locator)
ACEXML_INLINE
ACEXML_Parser_Context::ACEXML_Parser_Context (const ACEXML_Parser_Context& src)
  : instream_ (src.instream_),
    locator_ (src.locator_)
ACEXML_INLINE bool
ACEXML_Parser_Context::operator!= (const ACEXML_Parser_Context& src)
  return (this->instream_ != src.instream_ && this->locator_ != src.locator_);
ACEXML_INLINE ACEXML_Parser_Context&
ACEXML_Parser_Context::operator= (const ACEXML_Parser_Context& src)
  ACEXML_Parser_Context tmp (src);
  std::swap (this->instream_, tmp.instream_);
  std::swap (this->locator_, tmp.locator_);
  return *this;
ACEXML_INLINE ACEXML_InputSource*
ACEXML_Parser_Context::getInputSource (void)
  return this->instream_;
ACEXML_INLINE ACEX
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
PRLogModuleInfo *gLoadManagerLog = nullptr;
namespace mozilla {
LoadManager::LoadManager(int aLoadMeasurementInterval,
                         int aAveragingMeasurements,
                         float aHighLoadThreshold,
                         float aLowLoadThreshold)
  : mLastSystemLoad(0),
    mLoadSum(0.0f),
    mLoadSumMeasurements(0),
    mOveruseActive(false),
    mLoadMeasurementInterval(aLoadMeasurementInterval),
    mAveragingMeasurements(aAveragingMeasurements),
    mHighLoadThreshold(aHighLoadThreshold),
    mLowLoadThreshold(aLowLoadThreshold),
    mCurrentState(webrtc::kLoadNormal)
  if (!gLoadManagerLog)
    gLoadManagerLog = PR_NewLogModule("LoadManager");
  LOG(("LoadManager - Initializing (%dms x %d, %f, %f)",
       mLoadMeasurementInterval, mAv

       mHighLoadThreshold, mLowLoadThreshold));
  MOZ_ASSERT(mHighLoadThreshold > mLowLoadThreshold);
  mLoadMonitor = new LoadMonitor(mLoadMeasurementInterval);
  mLoadMonitor->Init(mLoadMonitor);
  mLoadMonitor->SetLoadChangeCallback(this);
LoadManager::~LoadManager()
  mLoadMonitor->Shutdown();
void
LoadManager::LoadChanged(float aSystemLoad, float aProcesLoad)
  mLoadSum += aSystemLoad;
  mLoadSumMeasurements++;
  if (mLoadSumMeasurements >= mAveragingMeasurements) {
    double averagedLoad = mLoadSum / (float)mLoadSumMeasurements;
    webrtc::CPULoadState oldState = mCurrentState;
    if (mOveruseActive || averagedLoad > mHighLoadThreshold) {
      LOG(("LoadManager - LoadStressed"));
      mCurrentState = webrtc::kLoadStressed;
    } else if (averagedLoad < mLowLoadThreshold) {
      LOG(("LoadManager - LoadRelaxed"));
      mCurrentState = webrtc::kLoadRelaxed;
    } else {
      LOG(("LoadManager - LoadNormal"));
      mCurrentState = webrtc::kLoadNormal;
    }
    if (oldStat

      LoadHasChanged();
    mLoadSum = 0;
    mLoadSumMeasurements = 0;
  }
void
LoadManager::OveruseDetected()
  LOG(("LoadManager - Overuse Detected"));
  mOveruseActive = true;
  if (mCurrentState != webrtc::kLoadStressed) {
    mCurrentState = webrtc::kLoadStressed;
    LoadHasChanged();
  }
void
LoadManager::NormalUsage()
  LOG(("LoadManager - Overuse finished"));
  mOveruseActive = false;
void
LoadManager::LoadHasChanged()
  LOG(("LoadManager - Signaling LoadHasChanged to %d listeners", mObservers.Length()));
  for (size_t i = 0; i < mObservers.Length(); i++) {
    mObservers.ElementAt(i)->onLoadStateChanged(mCurrentState);
  }
void
LoadManager::AddObserver(webrtc::CPULoadStateObserver * aObserver)
  LOG(("LoadManager - Adding Observer"));
  mObservers.AppendElement(aObserver);
void
LoadManager::RemoveObserver(webrtc::CPULoadStateObserver * aObserver)
  LOG(("LoadManager - Removing Observer"));
  if (!mObservers.RemoveElement(aObserver)) {
    LOG(("LOadManager - Element to remo
class QStandardItem;
class QModelIndex;
class QWidget;
class ServerRepo;
class RepoItem;
class RepoCategoryItem;
class RepoItemDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit RepoItemDelegate(QObject *parent=0);
    void paint(QPainter *painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const;
    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const;
    void showRepoItemToolTip(const RepoItem *item,
                             const QPoint& global_pos,
                             QWidget *viewport,
                             const QRect& rect) const;
private:
    QStandardItem* getItem(const QModelIndex &index) const;
    void paintRepoItem(QPainter *painter,
                       const QStyleOptionViewItem& opt,
                       const RepoItem *item) const;
    void paintRepoCategoryItem(QPainter *painter,
                               const QStyleO
/* Copyright 2014-2015 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
typedef enum __attr_packed___
  OPERAND_LITERAL,
  OPERAND_TMP
} operand_type;
typedef struct
  operand_type type;
  union
  {
    idx_t uid;
    lit_cpointer_t lit_id;
  } data;
} operand;
typedef enum __attr_packed___
  VARG_FUNC_DECL,
  VARG_FUNC_EXPR,
  VARG_ARRAY_DECL,
  VARG_OBJ_DECL,
  VARG_CONSTRUCT_EXPR,
  VARG_CALL_EXPR
} varg_list_type;
operand empty_operand (void);
operand literal_operand (lit_cpointer_t);
bool operand_i

void dumper_init (void);
void dumper_free (void);
void dumper_new_statement (void);
void dumper_new_scope (void);
void dumper_finish_scope (void);
bool dumper_is_intrinsic (operand);
operand dump_intrinsic (operand, operand);
void dump_boolean_assignment (operand, bool);
operand dump_boolean_assignment_res (bool);
void dump_string_assignment (operand, lit_cpointer_t);
operand dump_string_assignment_res (lit_cpointer_t);
void dump_number_assignment (operand, lit_cpointer_t);
operand dump_number_assignment_res (lit_cpointer_t);
void dump_smallint_assignment (operand, idx_t);
operand dump_smallint_assignment_res (idx_t);
void dump_undefined_assignment (operand);
operand dump_undefined_assignment_res (void);
void dump_null_assignment (operand);
operand dump_null_assignment_res (void);
void dump_variable_assignment (operand, operand);
operand dump_variable_assignment_res (operand);
void dump_varg_header_for_rewrite (varg_list_type, operand);
operand rewrite_varg_header_set_args_count (uint

void dump_this_arg (operand);
void dump_varg (operand);
void dump_prop_name_and_value (operand, operand);
void dump_prop_getter_decl (operand, operand);
void dump_prop_setter_decl (operand, operand);
void dump_prop_getter (operand, operand, operand);
operand dump_prop_getter_res (operand, operand);
void dump_prop_setter (operand, operand, operand);
void dump_function_end_for_rewrite (void);
void rewrite_function_end (varg_list_type);
void dump_this (operand);
operand dump_this_res (void);
void dump_post_increment (operand, operand);
operand dump_post_increment_res (operand);
void dump_post_decrement (operand, operand);
operand dump_post_decrement_res (operand);
void dump_pre_increment (operand, operand);
operand dump_pre_increment_res (operand);
void dump_pre_decrement (operand, operand);
operand dump_pre_decrement_res (operand);
void dump_unary_plus (operand, operand);
operand dump_unary_plus_res (operand);
void dump_unary_minus (operand, operand);
operand dump_unary_minus_res (opera

void dump_bitwise_not (operand, operand);
operand dump_bitwise_not_res (operand);
void dump_logical_not (operand, operand);
operand dump_logical_not_res (operand);
void dump_multiplication (operand, operand, operand);
operand dump_multiplication_res (operand, operand);
void dump_division (operand, operand, operand);
operand dump_division_res (operand, operand);
void dump_remainder (operand, operand, operand);
operand dump_remainder_res (operand, operand);
void dump_addition (operand, operand, operand);
operand dump_addition_res (operand, operand);
void dump_substraction (operand, operand, operand);
operand dump_substraction_res (operand, operand);
void dump_left_shift (operand, operand, operand);
operand dump_left_shift_res (operand, operand);
void dump_right_shift (operand, operand, operand);
operand dump_right_shift_res (operand, operand);
void dump_right_shift_ex (operand, operand, operand);
operand dump_right_shift_ex_res (operand, operand);
void dump_less_than (operand, operand, 

operand dump_less_than_res (operand, operand);
void dump_greater_than (operand, operand, operand);
operand dump_greater_than_res (operand, operand);
void dump_less_or_equal_than (operand, operand, operand);
operand dump_less_or_equal_than_res (operand, operand);
void dump_greater_or_equal_than (operand, operand, operand);
operand dump_greater_or_equal_than_res (operand, operand);
void dump_instanceof (operand, operand, operand);
operand dump_instanceof_res (operand, operand);
void dump_in (operand, operand, operand);
operand dump_in_res (operand, operand);
void dump_equal_value (operand, operand, operand);
operand dump_equal_value_res (operand, operand);
void dump_not_equal_value (operand, operand, operand);
operand dump_not_equal_value_res (operand, operand);
void dump_equal_value_type (operand, operand, operand);
operand dump_equal_value_type_res (operand, operand);
void dump_not_equal_value_type (operand, operand, operand);
operand dump_not_equal_value_type_res (operand, operand);


operand dump_bitwise_and_res (operand, operand);
void dump_bitwise_xor (operand, operand, operand);
operand dump_bitwise_xor_res (operand, operand);
void dump_bitwise_or (operand, operand, operand);
operand dump_bitwise_or_res (operand, operand);
void start_dumping_logical_and_checks (void);
void dump_logical_and_check_for_rewrite (operand);
void rewrite_logical_and_checks (void);
void start_dumping_logical_or_checks (void);
void dump_logical_or_check_for_rewrite (operand);
void rewrite_logical_or_checks (void);
void dump_conditional_check_for_rewrite (operand);
void rewrite_conditional_check (void);
void dump_jump_to_end_for_rewrite (void);
void rewrite_jump_to_end (void);
void start_dumping_assignment_expression (void);
operand dump_prop_setter_or_variable_assignment_res (operand, operand);
operand dump_prop_setter_or_addition_res (operand, operand);
operand dump_prop_setter_or_multiplication_res (operand, operand);
operand dump_prop_setter_or_division_res (operand, operand);
operan

operand dump_prop_setter_or_substraction_res (operand, operand);
operand dump_prop_setter_or_left_shift_res (operand, operand);
operand dump_prop_setter_or_right_shift_res (operand, operand);
operand dump_prop_setter_or_right_shift_ex_res (operand, operand);
operand dump_prop_setter_or_bitwise_and_res (operand, operand);
operand dump_prop_setter_or_bitwise_xor_res (operand, operand);
operand dump_prop_setter_or_bitwise_or_res (operand, operand);
void dumper_set_break_target (void);
void dumper_set_continue_target (void);
void dumper_set_next_interation_target (void);
opcode_counter_t
dump_simple_or_nested_jump_for_rewrite (bool is_simple_jump,
                                        opcode_counter_t next_jump_for_tg_oc);
opcode_counter_t
rewrite_simple_or_nested_jump_and_get_next (opcode_counter_t jump_oc,
                                            opcode_counter_t target_oc);
void dump_continue_iterations_check (operand);
void start_dumping_case_clauses (void);
void dump_case_clause

void dump_default_clause_check_for_rewrite (void);
void rewrite_case_clause (void);
void rewrite_default_clause (void);
void finish_dumping_case_clauses (void);
void dump_delete (operand, operand, bool, locus);
operand dump_delete_res (operand, bool, locus);
void dump_typeof (operand, operand);
operand dump_typeof_res (operand);
opcode_counter_t dump_with_for_rewrite (operand);
void rewrite_with (opcode_counter_t);
void dump_with_end (void);
void dump_try_for_rewrite (void);
void rewrite_try (void);
void dump_catch_for_rewrite (operand);
void rewrite_catch (void);
void dump_finally_for_rewrite (void);
void rewrite_finally (void);
void dump_end_try_catch_finally (void);
void dump_throw (operand);
bool dumper_variable_declaration_exists (lit_cpointer_t);
void dump_variable_declaration (lit_cpointer_t);
opcode_counter_t dump_scope_code_flags_for_rewrite (void);
void rewrite_scope_code_flags (opcode_counter_t scope_code_flags_oc,
                               opcode_scope_code_flags_t sc
namespace ppapi {
enum ApiID {
  API_ID_NONE = 0,
  API_ID_PPB_AUDIO = 1,
  API_ID_PPB_AUDIO_CONFIG,
  API_ID_PPB_AUDIO_INPUT_DEV,
  API_ID_PPB_BROKER,
  API_ID_PPB_BUFFER,
  API_ID_PPB_CONTEXT_3D,
  API_ID_PPB_CORE,
  API_ID_PPB_CURSORCONTROL,
  API_ID_PPB_FILE_CHOOSER,
  API_ID_PPB_FILE_IO,
  API_ID_PPB_FILE_REF,
  API_ID_PPB_FILE_SYSTEM,
  API_ID_PPB_FLASH,
  API_ID_PPB_FLASH_CLIPBOARD,
  API_ID_PPB_FLASH_FILE_FILEREF,
  API_ID_PPB_FLASH_FILE_MODULELOCAL,
  API_ID_PPB_FLASH_MENU,
  API_ID_PPB_FLASH_MOBILE,
  API_ID_PPB_FLASH_NETCONNECTOR,
  API_ID_PPB_FONT,
  API_ID_PPB_GRAPHICS_2D,
  API_ID_PPB_GRAPHICS_3D,
  API_ID_PPB_IMAGE_DATA,
  API_ID_PPB_INSTANCE,
  API_ID_PPB_INSTANCE_PRIVATE,
  API_ID_PPB_OPENGLES2,
  API_ID_PPB_PDF,
  API_ID_PPB_SURFACE_3D,
  API_ID_PPB_TCPSOCKET_PRIVATE,
  API_ID_PPB_TESTING,
  API_ID_PPB_TEXT_INPUT,
  API_ID_PPB_UDPSOCKET_PRIVATE,
  API_ID_PPB_URL_LOADER,
  API_ID_PPB_URL_RESPONSE_INFO,
  API_ID_PPB_VAR_ARRAY_BUFFER,
  API_ID_PPB_VAR_DEPRECATED,
  API_I
namespace slib {
	TokenizerError::TokenizerError( const std::string & error ) : error_( error ) {
	}
	std::string TokenizerError::GetError( ) {
		return error_;
	}
	std::string GetNumber( std::istream & stream ) {
		std::string number;
		if( stream.peek( ) >= '0' && stream.peek( ) <= '9' || stream.peek( ) == '-' || stream.peek( ) == '+' ) {
			number += stream.get( );
			for( ; stream.peek( ) >= '0' && stream.peek( ) <= '9' || stream.peek( ) == '.'; number += stream.get( ) );
		}
		return number;
	}
	std::string GetIdentifier( std::istream & stream ) {
		std::string ident;
		if( stream.peek( ) >= 'A' && stream.peek( ) <= 'Z' || stream.peek( ) >= 'a' && stream.peek( ) <= 'z' || stream.peek( ) == '_' ) {
			ident += stream.get( );
			for( ; stream.peek( ) >= 'A' && stream.peek( ) <= 'Z' || stream.peek( ) >= 'a' && stream.peek( ) <= 'z' || stream.peek( ) >= '0' && stream.peek( ) <= '9' || stream.peek( ) == '_'; ident += stream.get( ) );
		}
		return ident;
	}
	std::string GetStringConst( 

		std::string str( 1, stream.get( ) );
		while( stream.peek( ) >= ' ' && stream.peek( ) <= '~' && stream.peek( ) != '"' ) {
			if( stream.peek( ) == '\\' ) {
				stream.get( );
				if( stream.peek( ) == 'n' ) {
					stream.get( );
					str += '\n';
				} else if( stream.peek( ) == 't' ) {
					stream.get( );
					str += '\t';
				} else if( stream.peek( ) == '0' ) {
					stream.get( );
					str += '\0';
				} else if( stream.peek( ) == '"' ) {
					stream.get( );
					str += '"';
				} else if( stream.peek( ) == '\\' ) {
					stream.get( );
					str += '\\';
				} else {
					stream.get( );
				}
			} else {
				str += stream.get( );
			}
		}
		str += stream.get( );
		return str;
	}
	std::string GetComment( std::istream & stream ) {
		std::string str;
		for( ; stream.peek( ) != '\n'; str += stream.get( ) );
		return str;
	}
	std::string GetToken( std::istream & stream ) {
		for( ; stream.peek( ) == 9 || stream.peek( ) == 10 || stream.peek( ) == 13 || stream.peek( ) == 32; stream.get( 
namespace android {
class BpDumpTunnel : public BpInterface<IDumpTunnel> {
public:
    BpDumpTunnel(const sp<IBinder>& impl)
        :   BpInterface<IDumpTunnel>(impl) {
    }
    virtual ~BpDumpTunnel();
    virtual status_t kickDump(String8& result, const char* prefix) {
        Parcel data, reply;
        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
        data.writeString8(result);
        data.writeCString(prefix);
        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
        if (err != NO_ERROR) {
            ALOGE("kickDump could not contact remote\n");
            return err;
        }
        result = reply.readString8();
        err = reply.readInt32();
        return err;
    }
};
BpDumpTunnel::~BpDumpTunnel() {}
IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
    switch (code) {
        case DUMPTUNNEL_DUMP: {
            CHECK_I

            String8 result;
            const char* prefix = NULL;
            result = data.readString8();
            prefix = data.readCString();
            status_t ret = kickDump(result, prefix);
            reply->writeString8(result);
            reply->writeInt32(ret);
            return NO_ERROR;
        }
    }
    return BBinder::onTransact(code, data, reply, flags);
ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
DumpTunnelHelper::DumpTunnelHelper() :
    mSoHandle(NULL),
    mRegDumpPtr(NULL),
    mUnregDumpPtr(NULL)
    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
    typedef bool (*UnregDumpPrototype)(const String8&);
    mSoHandle = dlopen("libgui_ext.so", RTLD_LAZY);
    if (mSoHandle) {
        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
        if (NULL == mRegDumpPtr) {
            ALOGE("finding regDump(
/*
 * FreeSliceLocator - Constructor for FreeSliceLocator class.
 *
 * parameter locatorTool - Vrui::LocatorTool *
 * parameter ExampleVTKReader - ExampleVTKReader *
 */
FreeSliceLocator::FreeSliceLocator(Vrui::LocatorTool * locatorTool,
  ExampleVTKReader* ExampleVTKReader) :
  BaseLocator(locatorTool, ExampleVTKReader)
/*
 * ~FreeSliceLocator - Destructor for FreeSliceLocator class.
 */
FreeSliceLocator::~FreeSliceLocator(void) {
/*
 * motionCallback
 *
 * parameter callbackData - Vrui::LocatorTool::MotionCallbackData *
 */
void FreeSliceLocator::motionCallback(
		Vrui::LocatorTool::MotionCallbackData* callbackData) {
          Vrui::Point position = callbackData->currentTransformation.getOrigin();
          Vrui::Vector planeNormal =
            callbackData->currentTransformation.transform(Vrui::Vector(0,1,0));
          this->application->setFreeSliceOrigin(position.getComponents());
          this->application->setFreeSliceNormal(planeNormal.getComponents());
/*
 * buttonPressCal
/**
 *    Copyright (C) 2012 10gen Inc.
 *
 *    This program is free software: you can redistribute it and/or  modify
 *    it under the terms of the GNU Affero General Public License, version 3,
 *    as published by the Free Software Foundation.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Affero General Public License for more details.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the GNU Affero General Public License in all respects
 *    for

 *    file(s) with this exception, you may extend this exception to your
 *    version of the file(s), but you are not obligated to do so. If you do not
 *    wish to do so, delete this exception statement from your version. If you
 *    delete this exception statement from all source files in the program,
 *    then also delete it in the license file.
 */
namespace {
using namespace mongo;
using std::string;
TEST(ChunkType, MissingRequiredFields) {
    ChunkType chunk;
    BSONArray version = BSON_ARRAY(Date_t::fromMillisSinceEpoch(1) << OID::gen());
    BSONObj objModNS =
        BSON(ChunkType::name("test.mycol-a_MinKey")
             << ChunkType::min(BSON("a" << 10 << "b" << 10)) << ChunkType::max(BSON("a" << 20))
             << ChunkType::version(version) << ChunkType::shard("shard0001"));
    StatusWith<ChunkType> chunkRes = ChunkType::fromBSON(objModNS);
    ASSERT_FALSE(chunkRes.isOK());
    BSONObj objModName =
        BSON(ChunkType::ns("test.mycol")
             << ChunkT

             << ChunkType::version(version) << ChunkType::shard("shard0001"));
    chunkRes = ChunkType::fromBSON(objModName);
    ASSERT_FALSE(chunkRes.isOK());
    BSONObj objModKeys = BSON(ChunkType::name("test.mycol-a_MinKey")
                              << ChunkType::ns("test.mycol") << ChunkType::version(version)
                              << ChunkType::shard("shard0001"));
    chunkRes = ChunkType::fromBSON(objModKeys);
    ASSERT_FALSE(chunkRes.isOK());
    BSONObj objModShard =
        BSON(ChunkType::name("test.mycol-a_MinKey")
             << ChunkType::ns("test.mycol") << ChunkType::min(BSON("a" << 10 << "b" << 10))
             << ChunkType::max(BSON("a" << 20)) << ChunkType::version(version));
    chunkRes = ChunkType::fromBSON(objModShard);
    ASSERT_FALSE(chunkRes.isOK());
TEST(ChunkType, DifferentNumberOfColumns) {
    BSONArray version = BSON_ARRAY(Date_t::fromMillisSinceEpoch(1) << OID::gen());
    BSONObj obj =
        BSON(ChunkType::name("test.mycol-a_MinKe

             << ChunkType::ns("test.mycol") << ChunkType::min(BSON("a" << 10 << "b" << 10))
             << ChunkType::max(BSON("a" << 20)) << ChunkType::version(version)
             << ChunkType::shard("shard0001"));
    StatusWith<ChunkType> chunkRes = ChunkType::fromBSON(obj);
    ASSERT(chunkRes.isOK());
    ASSERT_FALSE(chunkRes.getValue().validate().isOK());
TEST(ChunkType, DifferentColumns) {
    BSONArray version = BSON_ARRAY(Date_t::fromMillisSinceEpoch(1) << OID::gen());
    BSONObj obj = BSON(ChunkType::name("test.mycol-a_MinKey")
                       << ChunkType::ns("test.mycol") << ChunkType::min(BSON("a" << 10))
                       << ChunkType::max(BSON("b" << 20)) << ChunkType::version(version)
                       << ChunkType::shard("shard0001"));
    StatusWith<ChunkType> chunkRes = ChunkType::fromBSON(obj);
    ASSERT(chunkRes.isOK());
    ASSERT_FALSE(chunkRes.getValue().validate().isOK());
TEST(ChunkType, NotAscending) {
    BSONArray version = BSON_ARRA

    BSONObj obj = BSON(ChunkType::name("test.mycol-a_MinKey")
                       << ChunkType::ns("test.mycol") << ChunkType::min(BSON("a" << 20))
                       << ChunkType::max(BSON("a" << 10)) << ChunkType::version(version)
                       << ChunkType::shard("shard0001"));
    StatusWith<ChunkType> chunkRes = ChunkType::fromBSON(obj);
    ASSERT(chunkRes.isOK());
    ASSERT_FALSE(chunkRes.getValue().validate().isOK());
TEST(ChunkType, NewFormatVersion) {
    ChunkType chunk;
    OID epoch = OID::gen();
    BSONArray version = BSON_ARRAY(Date_t::fromMillisSinceEpoch(1) << epoch);
    BSONObj obj = BSON(ChunkType::name("test.mycol-a_MinKey")
                       << ChunkType::ns("test.mycol") << ChunkType::min(BSON("a" << 10))
                       << ChunkType::max(BSON("a" << 20)) << ChunkType::version(version)
                       << ChunkType::shard("shard0001"));
    StatusWith<ChunkType> chunkRes = ChunkType::fromBSON(obj);
    ASSERT(chunkRes.isOK());

    chunk = chunkRes.getValue();
    ASSERT_EQUALS(chunk.getName(), "test.mycol-a_MinKey");
    ASSERT_EQUALS(chunk.getNS(), "test.mycol");
    ASSERT_EQUALS(chunk.getMin(), BSON("a" << 10));
    ASSERT_EQUALS(chunk.getMax(), BSON("a" << 20));
    ChunkVersion fetchedVersion = chunk.getVersion();
    ASSERT_EQUALS(fetchedVersion._combined, 1ULL);
    ASSERT_EQUALS(fetchedVersion._epoch, epoch);
    ASSERT_EQUALS(chunk.getShard(), "shard0001");
    ASSERT_TRUE(chunk.validate().isOK());
TEST(ChunkType, OldFormatVersion) {
    ChunkType chunk;
    OID epoch = OID::gen();
    BSONObj obj = BSON(ChunkType::name("test.mycol-a_MinKey")
                       << ChunkType::ns("test.mycol") << ChunkType::min(BSON("a" << 10))
                       << ChunkType::max(BSON("a" << 20))
                       << ChunkType::DEPRECATED_lastmod(Date_t::fromMillisSinceEpoch(1))
                       << ChunkType::DEPRECATED_epoch(epoch) << ChunkType::shard("shard0001"));
    StatusWith<ChunkType> chun
DyMechicalAPI* gv_API=NULL;
DYMECHNICALPLATFORM_API bool API_SysInit( void )
	if (gv_API==NULL)
	{
		gv_API=new DyMechicalAPI;
		return gv_API->SysInit();
	}
	else
	{
		return false;
	}
DYMECHNICALPLATFORM_API void API_SysQuit( void )
	gv_API->SysQuit();
	gv_API=NULL;
	delete gv_API;
DYMECHNICALPLATFORM_API bool API_FeedMotor_Start( void )
	if (gv_API==NULL)
		return false;
	return gv_API->FeedMotor_Start();
DYMECHNICALPLATFORM_API bool API_FeedMotor_Stop( void )
	if (gv_API==NULL)
		return false;
	return gv_API->FeedMotor_Stop();
DYMECHNICALPLATFORM_API bool API_MotorStart( int motorNum,int direction,int stepNum )
	if (gv_API==NULL)
		return false;
	return gv_API->MotorStart(motorNum,direction,stepNum);
DYMECHNICALPLATFORM_API bool API_MotorStop( int motorNum )
	if (gv_API==NULL)
		return false;
	return gv_API->MotorStop(motorNum);
DYMECHNICALPLATFORM_API bool API_MotorReset( int motorNum )
	if (gv_API==NULL)
		return false;
	return gv_API->MotorReset(motorNum);
DYMECHNICALPLATFORM_AP

	if (gv_API==NULL)
		return false;
	return gv_API->SetMotorSpeed(motorNum,speed);
DYMECHNICALPLATFORM_API bool API_solenAction( int solenNum,int statue )
	if (gv_API==NULL)
		return false;
	return gv_API->solenAction(solenNum,statue);
DYMECHNICALPLATFORM_API bool API_solenAdvace( int platformNum,int statue )
	if (gv_API==NULL)
		return false;
	return gv_API->solenAdvace(platformNum,statue);
DYMECHNICALPLATFORM_API void API_getSolenStatue( int* SolenStatue )
	if (gv_API==NULL)
		return;
	gv_API->getSolenStatue(SolenStatue);
DYMECHNICALPLATFORM_API bool API_getMotorStatue( int* motorStatue )
	if (gv_API==NULL)
		return false;
	return gv_API->getMotorStatue(motorStatue);
DYMECHNICALPLATFORM_API bool API_getPlatformStatue( int PlatformNum,int* platformStatue )
	if (gv_API==NULL)
		return false;
	return gv_API->getPlatformStatue(PlatformNum,platformStatue);
DYMECHNICALPLATFORM_API bool API_getSensorStatue( int* SensorStatue )
	if (gv_API==NULL)
		return false;
	return gv_API->getSensorStat
/*
Copyright (C) 1997-2001 Id Software, Inc.
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
typedef struct
	menuFramework_s	menu;
	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuPicButton_s	save;
	menuPicButton_s	load;
	menuPicButton_s	done;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];
} uiSaveLoad_t;
static uiSaveLoad_t	uiSaveLoad;
/*
==========

UI_SaveLoad_Callback
=================
*/
static void UI_SaveLoad_Callback( void *self, int event )
	menuCommon_s	*item = (menuCommon_s *)self;
	if( event != QM_ACTIVATED )
		return;
	switch( item->id )
	{
	case ID_LOAD:
		UI_LoadGame_Menu();
		break;
	case ID_SAVE:
		UI_SaveGame_Menu();
		break;
	case ID_DONE:
		UI_PopMenu();
		break;
	}
/*
=================
UI_SaveLoad_Init
=================
*/
static void UI_SaveLoad_Init( void )
	memset( &uiSaveLoad, 0, sizeof( uiSaveLoad_t ));
	uiSaveLoad.menu.vidInitFunc = UI_SaveLoad_Init;
	strcat( uiSaveLoad.hintText, "During play, you can quickly save your game by pressing " );
	strcat( uiSaveLoad.hintText, KEY_KeynumToString( KEY_GetKey( "save quick" )));
	strcat( uiSaveLoad.hintText, ".\nLoad this game again by pressing " );
	strcat( uiSaveLoad.hintText, KEY_KeynumToString( KEY_GetKey( "load quick" )));
	strcat( uiSaveLoad.hintText, ".\n" );
	uiSaveLoad.background.generic.id = ID_BACKGROUND;
	uiSaveLoad.background.generic.type = QMTYPE_BITM

	uiSaveLoad.background.generic.flags = QMF_INACTIVE;
	uiSaveLoad.background.generic.x = 0;
	uiSaveLoad.background.generic.y = 0;
	uiSaveLoad.background.generic.width = 1024;
	uiSaveLoad.background.generic.height = 768;
	uiSaveLoad.background.pic = ART_BACKGROUND;
	uiSaveLoad.banner.generic.id = ID_BANNER;
	uiSaveLoad.banner.generic.type = QMTYPE_BITMAP;
	uiSaveLoad.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiSaveLoad.banner.generic.x = UI_BANNER_POSX;
	uiSaveLoad.banner.generic.y = UI_BANNER_POSY;
	uiSaveLoad.banner.generic.width = UI_BANNER_WIDTH;
	uiSaveLoad.banner.generic.height = UI_BANNER_HEIGHT;
	uiSaveLoad.banner.pic = ART_BANNER;
	uiSaveLoad.load.generic.id = ID_LOAD;
	uiSaveLoad.load.generic.type = QMTYPE_BM_BUTTON;
	uiSaveLoad.load.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiSaveLoad.load.generic.name = "Load game";
	uiSaveLoad.load.generic.statusText = "Load a previously saved game";
	uiSaveLoad.load.generic.x = 72;
	uiSaveLoad.load.gene

	uiSaveLoad.load.generic.callback = UI_SaveLoad_Callback;
	UI_UtilSetupPicButton( &uiSaveLoad.load, PC_LOAD_GAME );
	uiSaveLoad.save.generic.id = ID_SAVE;
	uiSaveLoad.save.generic.type = QMTYPE_BM_BUTTON;
	uiSaveLoad.save.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiSaveLoad.save.generic.name = "Save game";
	uiSaveLoad.save.generic.statusText = "Save current game";
	uiSaveLoad.save.generic.x = 72;
	uiSaveLoad.save.generic.y = 280;
	uiSaveLoad.save.generic.callback = UI_SaveLoad_Callback;
	UI_UtilSetupPicButton( &uiSaveLoad.save, PC_SAVE_GAME );
	uiSaveLoad.done.generic.id = ID_DONE;
	uiSaveLoad.done.generic.type = QMTYPE_BM_BUTTON;
	uiSaveLoad.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiSaveLoad.done.generic.name = "Done";
	uiSaveLoad.done.generic.statusText = "Go back to the Main Menu";
	uiSaveLoad.done.generic.x = 72;
	uiSaveLoad.done.generic.y = 330;
	uiSaveLoad.done.generic.callback = UI_SaveLoad_Callback;
	UI_UtilSetupPicButton( &

	uiSaveLoad.hintMessage.generic.id = ID_MSGHINT;
	uiSaveLoad.hintMessage.generic.type = QMTYPE_ACTION;
	uiSaveLoad.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiSaveLoad.hintMessage.generic.color = uiColorHelp;
	uiSaveLoad.hintMessage.generic.name = uiSaveLoad.hintText;
	uiSaveLoad.hintMessage.generic.x = 360;
	uiSaveLoad.hintMessage.generic.y = 480;
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.background );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.banner );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.load );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.save );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.done );
	UI_AddItem( &uiSaveLoad.menu, (void *)&uiSaveLoad.hintMessage );
/*
=================
UI_SaveLoad_Precache
=================
*/
void UI_SaveLoad_Precache( void )
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
/*
=================
UI_SaveLoad_Menu
=================
*/
void UI_SaveLoad_Menu( void )
	if( gMenu.m_gameinfo.ga
/*-----------------------------------------------------------------------
 * File: bioapi_typecast.htp
 *
 *-----------------------------------------------------------------------
 */
/* API Functions */
extern "C" {
/*************************************************************************/
/*** This file is automatically generated. Do not hand edit **************/
/*************************************************************************/
/*************************************************************************/
/*** BioAPI Core Functions ***********************************************/
/*************************************************************************/
typedef BioAPI_RETURN (BioAPI *BioAPI_Init_ptr)(
						const BioAPI_VERSION *Version,
						uint32 Reserved1,
						const void *Reserved2,
						uint32 Reserved3,
						const void *Reserved4 );
typedef BioAPI_RETURN (BioAPI *BioAPI_Terminate_ptr)(
						void );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleLoad_ptr)(
						cons

						uint32 Reserved,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleUnload_ptr)(
						const BioAPI_UUID *ModuleGuid,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleAttach_ptr)(
						const BioAPI_UUID *ModuleGuid,
						const BioAPI_VERSION *Version,
						const BioAPI_MEMORY_FUNCS *MemoryFuncs,
						uint32 DeviceID,
						uint32 Reserved1,
						uint32 Reserved2,
						uint32 Reserved3,
						BioAPI_FUNC_NAME_ADDR *FunctionTable,
						uint32 NumFunctionTable,
						const void *Reserved4,
						BioAPI_HANDLE_PTR NewModuleHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleDetach_ptr)(
						BioAPI_HANDLE ModuleHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_QueryDevice_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_SERVICE_UID_PTR ServiceUID );
/**************************************************************

/*** BioAPI Service Provider APIs ***************************************/
/************************************************************************/
typedef BioAPI_RETURN (BioAPI *BioAPI_FreeBIRHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_GetBIRFromHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_PTR *BIR );
typedef BioAPI_RETURN (BioAPI *BioAPI_GetHeaderFromHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_HEADER_PTR Header );
typedef BioAPI_RETURN (BioAPI *BioAPI_EnableEvents_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_MODULE_EVENT_MASK *Events );
typedef BioAPI_RETURN (BioAPI *BioAPI_SetGUICallbacks_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_GUI_STREAMING_CALLBACK GuiStreamingCallback,
						void *GuiStreamingCallbackCtx,
						BioAPI_GUI_STATE_CALLBACK GuiStateCallback,
						void *GuiSta

typedef BioAPI_RETURN (BioAPI *BioAPI_SetStreamCallback_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_STREAM_CALLBACK StreamCallback,
						void *StreamCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_StreamInputOutput_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DATA_PTR InMessage,
						BioAPI_DATA_PTR OutMessage );
typedef BioAPI_RETURN (BioAPI *BioAPI_Capture_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR CapturedBIR,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_CreateTemplate_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload );
typedef BioAPI_RETURN (BioAPI *BioAPI_Process_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						BioAPI_BIR_HANDLE_PTR ProcessedBIR );
type

						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE *AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload );
typedef BioAPI_RETURN (BioAPI *BioAPI_IdentifyMatch_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout );
typedef BioAPI_RETURN (BioAPI *BioAPI_Enroll_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpos

						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Verify_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Identify_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,


						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Import_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_DATA *InputData,
						BioAPI_BIR_BIOMETRIC_DATA_FORMAT InputFormat,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR ConstructedBIR );
typedef BioAPI_RETURN (BioAPI *BioAPI_SetPowerMode_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_POWER_MODE PowerMode );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbOpen_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbClose_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbCreate_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_D

						BioAPI_DB_HANDLE_PTR DbHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbDelete_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbSetCursor_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbFreeCursor_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbStoreBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *BIRToStore,
						BioAPI_DB_HANDLE DbHandle,
						BioAPI_UUID_PTR Uuid );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbGetBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_BIR_HANDLE_PTR RetrievedBIR,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbGetNextBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
		
ModelCoefficients::ModelCoefficients (UInt32 n)
  :m_coefficients (n, 0)
ModelCoefficients::~ModelCoefficients ()
const Float32&
ModelCoefficients::operator[] (UInt32 n) const
  return m_coefficients[n];
Float32&
ModelCoefficients::operator[] (UInt32 n)
  return m_coefficients[n];
ModelCoefficients::iterator
ModelCoefficients::begin ()
  return m_coefficients.begin ();
ModelCoefficients::const_iterator
ModelCoefficients::begin () const
  return m_coefficients.begin ();
ModelCoefficients::iterator
ModelCoefficients::end ()
  return m_coefficients.end ();
ModelCoefficients::const_iterator
ModelCoefficients::end () const
  return m_coefficients.end ();
ModelCoefficients::reverse_iterator
ModelCoefficients::rbegin ()
  return m_coefficients.rbegin ();
ModelCoefficients::const_reverse_iterator
ModelCoefficients::rbegin () const
  return m_coefficients.rbegin ();
ModelCoefficients::reverse_iterator
ModelCoefficients::rend ()
  return m_coefficients.rend ();
ModelCoefficients::const_reverse_i
ACE_INLINE
OpenDDS::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",6);
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0)
    {
      return 0;
    }
  return value._retn();
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",6);
  return this->map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0)
    {
      value = new RepoIdSet();
      if (bind(map_, key, value) != 0)
        {
           ACE_ERROR((LM_ERROR,
                      "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                      "the RepoIdSetMap.\n"));
           return 0;
        }
    }
  return value._ret
GridCharacteristics::GridCharacteristics() {
GridCharacteristics::~GridCharacteristics(){
double GridCharacteristics::getTimeZone() {
    return timeZone;
double GridCharacteristics::getPeakLoadWeekday() {
    return peakLoadWeekday;
double GridCharacteristics::getOffLoadWeekday() {
    return offLoadWeekday;
double GridCharacteristics::getPeakLoadHoliday() {
    return peakLoadHoliday;
double GridCharacteristics::getOffLoadHoliday() {
    return offLoadHoliday;
Distribution* GridCharacteristics::getLoadAdjusting() {
    return loadAdjusting;
vector<double>& GridCharacteristics::getWeekdayLoad() {
    return weekdayLoad;
vector<double>& GridCharacteristics::getHolidayLoad() {
    return holidayLoad;
void GridCharacteristics::setTimeZone (double timeZone) {
    this->timeZone = timeZone;
void GridCharacteristics::setPeakLoadWeekday (double peakLoadWeekday) {
    this->peakLoadWeekday = peakLoadWeekday;
void GridCharacteristics::setOffLoadWeekday (double offLoadWeekday){
    this->offLoa
extern pthread_mutex_t mutex_LoadData;
extern pthread_cond_t cond_LoadData;
extern tLoadDataList * LoadDataList;
int tmpint=0;
void Initthread_LoadData()
	LoadDataList = new tLoadDataList;
	LoadDataList->Data=NULL;
	LoadDataList->DataPath[0]=0;
	LoadDataList->DataPointer=NULL;
	LoadDataList->DataType=0;
	LoadDataList->NextNode=NULL;
	LoadDataList->DataSet=NULL;
	pthread_attr_t attr_LoadData; 
	pthread_attr_init(&attr_LoadData); 
	pthread_attr_setscope(&attr_LoadData, PTHREAD_SCOPE_PROCESS);
    pthread_attr_setdetachstate(&attr_LoadData, PTHREAD_CREATE_DETACHED);
	pthread_t threadID_LoadData;
	pthread_mutex_init(&mutex_LoadData, NULL);
	pthread_cond_init(&cond_LoadData,NULL);
	pthread_create( &threadID_LoadData, &attr_LoadData, LoadData, NULL);
void* LoadData(void* Param)
	while(true)
	{
		pthread_mutex_lock( &mutex_LoadData );
		pthread_cond_wait( &cond_LoadData ,&mutex_LoadData);
		pthread_cond_init(&cond_LoadData,NULL);
		tLoadDataList * loadnod=LoadDataList;
		while(loadnod)
		{
		

			{
				case DATATYPE_TEXTURE: Textures * pLoadTexture;
					pLoadTexture = new Textures;
					pLoadTexture->loadfile(loadnod->DataPath);
					loadnod->Data = pLoadTexture;
					break;
				case DATATYPE_FONT2D: CFont2D * pLoadFont2D;
					pLoadFont2D = new CFont2D;
					
					if(loadnod->DataSet)
					{
						tFont2Dset * Font2Dset = (tFont2Dset *)loadnod->DataSet;
						pLoadFont2D->LoadFont(
						loadnod->DataPath,
						Font2Dset->FontSizeW,
						Font2Dset->FontSizeH,
						Font2Dset->FontW,
						Font2Dset->FontH,
						Font2Dset->CHARSET
						);
					}
					else
						pLoadFont2D->LoadFont(loadnod->DataPath,0,0);
					loadnod->Data = pLoadFont2D;
					break;
				case DATATYPE_FONT3D: CFont3D * pLoadFont3D;
					pLoadFont3D = new CFont3D;
					if(loadnod->DataSet)
						pLoadFont3D->LoadFont(loadnod->DataPath,*(int*)loadnod->DataSet);
					else
						pLoadFont3D->LoadFont(loadnod->DataPath);
					loadnod->Data = pLoadFont3D;
					break;
			}
			loadnod = loadnod->NextNode;
		}
namespace Wanderlust
	space::space()
	{
		mChunkGenPtr = 0;
		mTerrain.clear();
	}
	space::~space()
	{
		map<chunkposition, chunk*>::iterator iter = mTerrain.begin();
		while(iter != mTerrain.end())
		{
			iter++;
		}
		mTerrain.clear();
	}
	chunk* space::getChunk(real X, real Y, real Z)
	{
		if(mTerrain.find(chunkposition(X, Y, Z)) != mTerrain.end())
		{
			return mTerrain.find(chunkposition(X, Y, Z))->second;
		}
		else
		{
			return 0;
		}
	}
	chunk* space::getChunk(int X, int Y, int Z)
	{
		if(mTerrain.find(chunkposition(X, Y, Z)) != mTerrain.end())
		{
			return mTerrain.find(chunkposition(X, Y, Z))->second;
		}
		else
		{
			return 0;
		}
	}
	blockID space::getBlock(long int X, long int Y, long int Z)
	{
		real ChunkX, ChunkY, ChunkZ;
		ChunkX = (real)X/CHUNK_SIZE;
		ChunkY = (real)Y/CHUNK_SIZE;
		ChunkZ = (real)Z/CHUNK_SIZE;
		
		ChunkX = floor(ChunkX);
		ChunkY = floor(ChunkY);
		ChunkZ = floor(ChunkZ);
		chunk* FromWhich = getChunk(ChunkX, ChunkY, ChunkZ);
		if(FromWhich)
		{


			Y %= CHUNK_SIZE; 
			Z %= CHUNK_SIZE;
			if(X < 0)
			{
				X = CHUNK_SIZE + X;
			}
			if(Y < 0)
			{
				Y = CHUNK_SIZE + Y;
			}
			if(Z < 0)
			{
				Z = CHUNK_SIZE + Z;
			}
			return FromWhich->getBlock(X, Y, Z);
		}
		else
		{
			return 0;
		}
	}
	bool space::getBlockExists(long int X, long int Y, long int Z)
	{
		real ChunkX, ChunkY, ChunkZ;
		ChunkX = (real)X/CHUNK_SIZE;
		ChunkY = (real)Y/CHUNK_SIZE;
		ChunkZ = (real)Z/CHUNK_SIZE;
		
		ChunkX = floor(ChunkX);
		ChunkY = floor(ChunkY);
		ChunkZ = floor(ChunkZ);
		chunk* ToWhich = getChunk(ChunkX, ChunkY, ChunkZ);
		if(ToWhich)
		{
			return true;
		}
		return false;
	}
	void space::setBlock(long int X, long int Y, long int Z, blockID SetTo)
	{
		real ChunkX, ChunkY, ChunkZ;
		ChunkX = (real)X/CHUNK_SIZE;
		ChunkY = (real)Y/CHUNK_SIZE;
		ChunkZ = (real)Z/CHUNK_SIZE;
		
		ChunkX = floor(ChunkX);
		ChunkY = floor(ChunkY);
		ChunkZ = floor(ChunkZ);
		chunk* ToWhich = getChunk(ChunkX, ChunkY, ChunkZ);
		if(ToWhich)
		{
			X %= 

			Y %= CHUNK_SIZE; 
			Z %= CHUNK_SIZE;
			if(X < 0)
			{
				X = CHUNK_SIZE + X;
			}
			if(Y < 0)
			{
				Y = CHUNK_SIZE + Y;
			}
			if(Z < 0)
			{
				Z = CHUNK_SIZE + Z;
			}
			ToWhich->setBlock(X, Y, Z, SetTo);
		}
	}
	/*blockID* space::getBlockPtr(long int X, long int Y, long int Z)
	{
		real ChunkX, ChunkY, ChunkZ;
		ChunkX = (real)X/CHUNK_SIZE;
		ChunkY = (real)Y/CHUNK_SIZE;
		ChunkZ = (real)Z/CHUNK_SIZE;
		
		ChunkX = floor(ChunkX);
		ChunkY = floor(ChunkY);
		ChunkZ = floor(ChunkZ);
		chunk* FromWhich = getChunk(ChunkX, ChunkY, ChunkZ);
		if(FromWhich)
		{
			X %= CHUNK_SIZE; 
			Y %= CHUNK_SIZE; 
			Z %= CHUNK_SIZE;
			if(X < 0)
			{
				X = CHUNK_SIZE + X;
			}
			if(Y < 0)
			{
				Y = CHUNK_SIZE + Y;
			}
			if(Z < 0)
			{
				Z = CHUNK_SIZE + Z;
			}
			return FromWhich->getBlockPtr(X, Y, Z);
		}
		else
		{
			return 0;
		}
	}*/
	bool space::genChunk(int X, int Y, int Z)
	{
		if(mTerrain.find(chunkposition(X, Y, Z)) == mTerrain.end())
		{
			if(mChunkGenPtr)
			{
		
namespace Stream
	class OV_API IOutputStreamHelper : public Stream::IOutputStream
	{
	public:
		virtual Stream::boolean setEndianness(const Stream::EEndianness& eEndianness)=0;
		virtual Stream::EEndianness getEndianness(void)=0;
		virtual Stream::boolean sendUInteger8(Stream::uint8 uiValue)=0;
		virtual Stream::boolean sendUInteger16(Stream::uint16 uiValue)=0;
		virtual Stream::boolean sendUInteger32(Stream::uint32 uiValue)=0;
		virtual Stream::boolean sendUInteger64(Stream::uint64 uiValue)=0;
		virtual Stream::boolean sendSInteger8(Stream::int8 iValue)=0;
		virtual Stream::boolean sendSInteger16(Stream::int16 iValue)=0;
		virtual Stream::boolean sendSInteger32(Stream::int32 iValue)=0;
		virtual Stream::boolean sendSInteger64(Stream::int64 iValue)=0;
		virtual Stream::boolean sendFloat32(Stream::float32 fValue)=0;
		virtual Stream::boolean sendFloat64(Stream::float64 fValue)=0;
		virtual Stream::boolean sendASCIIString(const char* sString)=0;
		virtual Stream::boolean sendUTF8String(c
template <typename T>
class MultiRepo
public:
	using init_list = std::initializer_list < typename MultiplyList<T*>::Comparator > ;
	using MultiplyListFactory = std::function < MultiplyList<T*>*() > ;
private:
	MultiplyList<T*>* elements;
	IRepo<T*, MultiplyList<T*>>* repo;
	MultiplyListFactory factory;
public:
	MultiRepo(MultiplyListFactory, IRepo<T*, MultiplyList<T*>>*);
	~MultiRepo();
	const MultiplyList<T*>* getAll();
	template<typename Predicate>
	MultiplyList<T*>* getALL(Predicate p);
	template<typename Predicate>
	T* get(Predicate p);
	template <typename Predicate>
	bool remove(Predicate);
	void saveALL();
	bool addElement(T*);
};
template<typename T>
MultiRepo<T>::MultiRepo(MultiplyListFactory pfactory, IRepo<T*, MultiplyList<T*>>* prepo)
	: factory(pfactory), elements(pfactory()), repo(prepo)
	prepo->readALL(*elements, []( MultiplyList<T*> &list, T* e)
	{
		list.add(e);
	});
template<typename T>
MultiRepo<T>::~MultiRepo()
	elements->foreach([](T* e){delete e; });
	delete elemen
namespace dmz {
class DMZ_FOUNDATION_LINK_SYMBOL StreamZip : public Stream, public WriterZip {
   public:
      StreamZip ();
      virtual ~StreamZip ();
      virtual Stream &write_raw_data (const UInt8 *Data, const Int32 Size);
      virtual Stream &flush ();
      virtual Stream &newline ();
      virtual Stream &operator<< (const UInt16 Value);
      virtual Stream &operator<< (const UInt32 Value);
      virtual Stream &operator<< (const UInt64 Value);
      virtual Stream &operator<< (const Int16 Value);
      virtual Stream &operator<< (const Int32 Value);
      virtual Stream &operator<< (const Int64 Value);
      virtual Stream &operator<< (const Float32 Value);
      virtual Stream &operator<< (const Float64 Value);
      virtual Stream &operator<< (const String &Value);
      virtual Stream &operator<< (const char Value);
      virtual Stream &operator<< (const char *Data);
      virtual Stream &operator<< (const void *Value);
      virtual Stream &operator<< (stream_operato
enum ENUM_LOCATOR_UNIT
	LOCATOR_UNIT_INVALID	= -1,
	LOCATOR_UNIT_NUMBERS
};
INT GetLocatorName( ENUM_LOCATOR eLocator, const char **paszOutLocatorName )
	static LPCSTR lpszLocatorInvalid = "èä¸ååç¹";
	static LPCSTR alpszLocatorName[LOCATOR_UNIT_NUMBERS] = {
	};
	INT nNumResult = 0;
	switch ( eLocator )
	{
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_CENTER];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HEAD];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_L];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_R];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_WEAPON_L];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_WEAPON_R];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_FOOT_L];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpsz

		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_FOOT_CENTER];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_CALVARIA];
		break;
		nNumResult = 2;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_L];
		paszOutLocatorName[1]	= alpszLocatorName[LOCATOR_UNIT_HAND_R];
		break;
		nNumResult = 1;
		paszOutLocatorName[0]	= alpszLocatorName[LOCATOR_UNIT_HAND_CENTER];
		break;
	default:
		nNumResult = 0;
		break;
	}
	return nNumResult;
const char *szIDSTRING_WEAPON			= ("æ­¦å¨");
const char *szIDSTRING_CAP				= ("å¸½å­");
const char *szIDSTRING_ARMOUR			= ("è¡£æ");
const char *szIDSTRING_CUFF				= ("æ¤è");
const char *szIDSTRING_BOOT				= ("é´å­");
const char *szIDSTRING_NECKLACE			= ("é¡¹é¾");
const char *szIDSTRING_SASH				= ("è°é¥°");
const char *szIDSTRING_RING				= ("ææ");
const char *szIDSTRING_FACE_MESH		= ("FaceMesh");
const char *szIDSTRING_FACE_MAT			= ("FaceMat");
const char *szIDSTRING_HAIR_MESH		= ("HairMesh");
cons
/**
 * This work is licensed under the Creative Commons
 * Attribution-NonCommercial 3.0 Unported License. To view a copy of this
 * letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View,
 * California, 94041, USA.
 */
/**
 * @file repo_base.cpp
 * @date 19.06.2009
 * @author gerd
 */
namespace repo
_Repo_base::_Repo_base() :
	C_(0), N_(0), nStored_(0), minID_(0), maxID_(0)
	_init();
_Repo_base::_Repo_base(category_t cat) :
	C_(cat), N_(100), nStored_(0), count_(cat + 1, 0), offset_(cat + 1, 0),
			nums_(N_, 0), ids_(N_, 0), minID_(0), maxID_(0)
	assert(C_ > 0);
	_init();
_Repo_base::_Repo_base(const category_t cat, const id_size_t n) :
	C_(cat), N_(n), nStored_(0), count_(cat + 1, 0), offset_(cat + 1, 0),
			nums_(N_, 0), ids_(N_, 0), minID_(0), maxID_(0)
	_init();
_Repo_base::_Repo_base(const _Repo_base& r) :
	C_(r.C_), N_(r.nStored_), count_(C_ + 1, 0), offset_(C_ + 1, 0)
	_init();
_Repo_base::~_Repo_base()
void _Repo_base::_init()
	nStored_ = 0;
	nums_.reserve(N_)
namespace dStorm {
namespace fit_window {
inline void chunkify_base(const fit_window::Plane& input, nonlinfit::plane::GenericData& output) {
    output.pixel_size = input.pixel_size;
    for (int d = 0; d < 2; ++d) {
        output.min[d] = input.min_coordinate[d];
        output.max[d] = input.max_coordinate[d];
    }
template <bool NeedLogOutput, typename Number, int ChunkSize>
void chunkify(const fit_window::Plane& input, nonlinfit::plane::DisjointData<Number, ChunkSize>& output) {
    chunkify_base(input, output);
    int chunk_count = input.points.size() / ChunkSize;
    assert(input.window_width == ChunkSize);
    assert(input.points.size() % ChunkSize == 0);
    output.data.resize(chunk_count);
    for (int chunk = 0; chunk < chunk_count; ++chunk) {
        output.data[chunk].inputs[0] = input.points[chunk * ChunkSize].position.y();
    }
    for (int i = 0; i < ChunkSize; ++i) {
        output.xs[i] = input.points[i].position.x();
    }
    for (int chunk = 0; chunk < chunk_cou

        for (int i = 0; i < ChunkSize; ++i) {
            const DataPoint& point = input.points[chunk * ChunkSize + i];
            assert(std::abs(output.data[chunk].inputs[0] - point.position.y()) < 1E-10);
            assert(std::abs(output.xs[i] - point.position.x()) < 1E-10);
            output.data[chunk].output[i] = point.value;
            output.data[chunk].background[i] = point.background;
            if (NeedLogOutput) {
                output.data[chunk].logoutput[i] =
                    (point.value < 1E-10) ? -23*point.value : log(point.value);
            }
            output.data[chunk].residues[i] = 0;
        }
    }
template <bool NeedLogOutput, typename Number, int ChunkSize>
void chunkify(const fit_window::Plane& input, nonlinfit::plane::JointData<Number, ChunkSize>& output) {
    chunkify_base(input, output);
    int chunk_count = input.points.size() / ChunkSize;
    if (ChunkSize > 1 && input.points.size() % ChunkSize >= ChunkSize / 2) {
        chunk_count += 
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
namespace mozilla {
LoadManager* LoadManagerBuild(void)
  MOZ_ASSERT(NS_IsMainThread());
  int loadMeasurementInterval =
    mozilla::Preferences::GetInt("media.navigator.load_adapt.measure_interval", 1000);
  int averagingSeconds =
    mozilla::Preferences::GetInt("media.navigator.load_adapt.avg_seconds", 3);
  float highLoadThreshold =
    mozilla::Preferences::GetFloat("media.navigator.load_adapt.high_load", 0.90);
  float lowLoadThreshold =
    mozilla::Preferences::GetFloat("media.navigator.load_adapt.low_load", 0.40);
  return new LoadManager(loadMeasurementInterval,
                         averagingSeconds,
                         highLoadThreshold,
                         lowLoadThreshold);
void LoadManagerDestroy(mozilla::LoadManager* aLoadManager)
  dele
/*
  Copyright (c) 2003-2011 Gordon Gremme <gremme@zbh.uni-hamburg.de>
  Copyright (c) 2003-2008 Center for Bioinformatics, University of Hamburg
  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
/* The GenomeTools ``all-in-one'' header.
   Include only this header if you program against the libgenometools. */
/* the core module */

using namespace test_classes;
Base base;
Class clazz;
Derived derived;
Class* rawPointer;
Pointer smartPointer;
ValueConversion valueConversion;
ReferenceConversion referenceConversion;
Mixed mixed;
ConstMixed constMixed;
int main()
  using functional::option2::invoke;
  invoke(&Class::normal, Class{});
  invoke(&Class::normal, clazz);
  invoke(&Class::normal, derived);
  invoke(&Class::normal, rawPointer);
  invoke(&Class::normal, smartPointer);
  invoke(&Class::normal, valueConversion);
  invoke(&Class::normal, referenceConversion);
  invoke(&Class::normal, mixed);
  invoke(&Class::reference, clazz);
  invoke(&Class::reference, derived);
  invoke(&Class::reference, rawPointer);
  invoke(&Class::reference, smartPointer);
  invoke(&Class::reference, referenceConversion);
  invoke(&Class::reference, mixed);
  invoke(&Class::member, Class{});
  invoke(&Class::member, clazz);
  invoke(&Class::member, derived);
  invoke(&Class::member, rawPointer);
  invoke(&Class::member, smartPointer);
 
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla browser.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications, Inc.
 * Portions created by the Initial Developer are Copyright (C) 1999
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Travis Bogard <travis@netscape.com>
 *
 * Alternatively, the contents of this file may

 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Load flag for error pages. This uses one of the reserved flag
 * values from nsIWebNavigation.
 */
/**
 * These are flags that confuse ConvertLoadTypeToDocShellLoadInfo and should
 * above 0xffff (e.g

 * just shift them out anyway.
 */
                          LOAD_FLAGS_FIRST_LOAD              | \
                          LOAD_FLAGS_ALLOW_POPUPS            | \
                          0xffff0000)
/* load types are legal combinations of load commands and flags 
 *  
 * NOTE:
 *  Remember to update the IsValidLoadType function below if you change this
 *  enum to ensure bad flag combinations will be rejected.
 */
enum LoadType {
    LOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_NORMAL_EXTERNAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_FROM_EXTERNAL),
    LOAD_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_HISTORY, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_NORMAL_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LO

    LOAD_NORMAL_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_NORMAL = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_NONE),
    LOAD_RELOAD_BYPASS_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE),
    LOAD_RELOAD_BYPASS_PROXY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_RELOAD_BYPASS_PROXY_AND_CACHE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE | nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY),
    LOAD_LINK = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_LINK),
    LOAD_REFRESH = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_IS_REFRESH),
    LOAD_RELOAD_CHARSET_CHANGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_RELOAD, nsIWebNavigation::LOA

    LOAD_BYPASS_HISTORY = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_BYPASS_HISTORY),
    LOAD_STOP_CONTENT = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT),
    LOAD_STOP_CONTENT_AND_REPLACE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, nsIWebNavigation::LOAD_FLAGS_STOP_CONTENT | nsIWebNavigation::LOAD_FLAGS_REPLACE_HISTORY),
    LOAD_PUSHSTATE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_PUSHSTATE, nsIWebNavigation::LOAD_FLAGS_NONE),
    /**
     * Load type for an error page. These loads are never triggered by users of
     * Docshell. Instead, Docshell triggers the load itself when a
     * consumer-triggered load failed.
     */
    LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(nsIDocShell::LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE)
};
static inline PRBool IsValidLoadType(PRUint32 aLoadType)
    switch (aLoadType)
    {
    case LOAD_NORMAL:
    case LOAD_NORMAL_REPLACE:
    case LOAD_NORMAL_EXTERNAL:
    case LOAD_NORMAL_BYPASS_
namespace net {
namespace {
TEST(LoadLogTest, Nullable) {
  LoadLog::BeginEvent(NULL, LoadLog::TYPE_HOST_RESOLVER_IMPL);
  LoadLog::AddEvent(NULL, LoadLog::TYPE_HOST_RESOLVER_IMPL);
  LoadLog::EndEvent(NULL, LoadLog::TYPE_HOST_RESOLVER_IMPL);
TEST(LoadLogTest, Basic) {
  scoped_refptr<LoadLog> log(new LoadLog(10));
  EXPECT_EQ(0u, log->entries().size());
  EXPECT_EQ(0u, log->num_entries_truncated());
  log->Add(LoadLog::Entry(MakeTime(0),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_BEGIN)));
  log->Add(LoadLog::Entry(MakeTime(2),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  log->Add(
      LoadLog::Entry(
          MakeTime(11),
          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                         LoadLog::PHASE_END)));
  EXPECT_EQ(3u, log->entries().size());
  EXPECT_EQ(0u, log->num

  EXPECT_TRUE(LogContainsEventAtTime(
      *log, 0, MakeTime(0), LoadLog::TYPE_HOST_RESOLVER_IMPL,
      LoadLog::PHASE_BEGIN));
  EXPECT_TRUE(LogContainsEventAtTime(
      *log, 1, MakeTime(2), LoadLog::TYPE_CANCELLED, LoadLog::PHASE_NONE));
  EXPECT_TRUE(LogContainsEventAtTime(
      *log, 2, MakeTime(11), LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
      LoadLog::PHASE_END));
TEST(LoadLogTest, Truncation) {
  size_t kMaxNumEntries = 10;
  scoped_refptr<LoadLog> log(new LoadLog(kMaxNumEntries));
  for (size_t i = 0; i < kMaxNumEntries; ++i) {
    log->Add(LoadLog::Entry(MakeTime(i),
                            LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                           LoadLog::PHASE_NONE)));
  }
  EXPECT_EQ(kMaxNumEntries, log->entries().size());
  EXPECT_EQ(0u, log->num_entries_truncated());
  EXPECT_TRUE(LogContainsEventAtTime(
      *log, 9, MakeTime(9), LoadLog::TYPE_CANCELLED, LoadLog::PHASE_NONE));
  log->Add(LoadLog::Entry(MakeTime(0),
        

                                         LoadLog::PHASE_NONE)));
  log->Add(LoadLog::Entry(MakeTime(1),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  log->Add(LoadLog::Entry(MakeTime(2),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  EXPECT_EQ(kMaxNumEntries, log->entries().size());
  EXPECT_EQ(3u, log->num_entries_truncated());
  EXPECT_TRUE(LogContainsEventAtTime(
      *log, 9, MakeTime(2), LoadLog::TYPE_CANCELLED, LoadLog::PHASE_NONE));
TEST(LoadLogTest, Append) {
  scoped_refptr<LoadLog> log1(new LoadLog(10));
  scoped_refptr<LoadLog> log2(new LoadLog(10));
  log1->Add(LoadLog::Entry(MakeTime(0),
                           LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                          LoadLog::PHASE_BEGIN)));
  log2->Add(LoadLog::Entry(MakeTime(3),
                           LoadLog

                                          LoadLog::PHASE_NONE)));
  log2->Add(LoadLog::Entry(MakeTime(9),
                           LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                          LoadLog::PHASE_END)));
  log1->Append(log2);
  log2->Add(LoadLog::Entry(MakeTime(19),
                           LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                          LoadLog::PHASE_NONE)));
  EXPECT_EQ(3u, log1->entries().size());
  EXPECT_EQ(0u, log1->num_entries_truncated());
  EXPECT_TRUE(LogContainsEventAtTime(
      *log1, 0, MakeTime(0), LoadLog::TYPE_HOST_RESOLVER_IMPL,
      LoadLog::PHASE_BEGIN));
  EXPECT_TRUE(LogContainsEventAtTime(
      *log1, 1, MakeTime(3), LoadLog::TYPE_CANCELLED,
      LoadLog::PHASE_NONE));
  EXPECT_TRUE(LogContainsEventAtTime(
      *log1, 2, MakeTime(9), LoadLog::TYPE_HOST_RESOLVER_IMPL,
      LoadLog::PHASE_END));
TEST(LoadLogTest, AppendWithTruncation) {
  size_t kMaxNumEntries = 10;
  scoped_refpt

  scoped_refptr<LoadLog> log2(new LoadLog(kMaxNumEntries));
  for (size_t i = 0; i < 6; ++i) {
    log1->Add(LoadLog::Entry(MakeTime(i),
                             LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                            LoadLog::PHASE_NONE)));
    log2->Add(LoadLog::Entry(MakeTime(2 * i),
                             LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                            LoadLog::PHASE_NONE)));
  }
  log1->Append(log2);
  EXPECT_EQ(10u, log1->entries().size());
  EXPECT_EQ(2u, log1->num_entries_truncated());
  EXPECT_TRUE(LogContainsEventAtTime(
      *log1, 9, MakeTime(10), LoadLog::TYPE_CANCELLED, LoadLog::PHASE_NONE));
TEST(LoadLogTest, EventTypeToString) {
  EXPECT_STREQ("HOST_RESOLVER_IMPL",
               LoadLog::EventTypeToString(LoadLog::TYPE_HOST_RESOLVER_IMPL));
  EXPECT_STREQ("HOST_RESOLVER_IMPL_OBSERVER_ONSTART",
               LoadLog::EventTypeToString(
                  LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER
/**
@file Chunk.cpp
@author nieznanysprawiciel
@copyright File is part of Sleeping Wombat Libraries.
*/
namespace sw
Chunk::Chunk		( ChunkReprPtr chunkRepr )
	:	m_chunkPtr( chunkRepr )
{}
Chunk			Chunk::CreateChunk		()
	if( IsValid() )
		return m_chunkPtr->CreateChunk();
	return Chunk( nullptr );
Chunk			Chunk::NextChunk()
	if( IsValid() )
		return m_chunkPtr->NextChunk();
	return Chunk( nullptr );
Chunk			Chunk::FirstChild()
	if( IsValid() )
		return m_chunkPtr->FirstChild();
	return Chunk( nullptr );
bool			Chunk::HasChildren()
	if( IsValid() )
		return m_chunkPtr->HasChildren();
	return false;
Chunk			Chunk::ParentChunk()
	if( IsValid() )
		return m_chunkPtr->ParentChunk();
	return Chunk( nullptr );
Attribute		Chunk::AddAttribute		( AttributeType type, const DataPtr data, Size dataSize )
	if( IsValid() )
		return m_chunkPtr->AddAttribute( type, data, dataSize );
	return Attribute( nullptr );
bool			Chunk::Fill				( const DataPtr data, Size dataSize )
	if( IsValid() )
		return m_chun
/*
 * bufferedreader.cpp
 *
 *  Created on: 6 janv. 2010
 *      Author: francois
 */
namespace Xem
  BufferedReader::BufferedReader ()
  {
    encoding = Encoding_UTF8;
    buffer = NULL;
    bufferSz = 0;
    bufferIdx = 0;
    totalParsed = 0;
    totalLinesParsed = 0;
  }
  BufferedReader::~BufferedReader ()
  {
  }
  void BufferedReader::setEncoding ( Encoding _encoding )
  {
    encoding = _encoding;
  }
  Encoding BufferedReader::getEncoding ()
  {
    return encoding;
  }
  String BufferedReader::dumpCurrentContext ()
  {
    String context;
    stringPrintf ( context, "at file='%s', line %llu, char %llu : ",
        getCurrentURI().c_str(),
        totalLinesParsed, totalParsed );
    if ( buffer )
      {
        static const __ui64 MaxBufferDumpSize = 256;
        char _dumpBuff[MaxBufferDumpSize];
        __ui64 _dumpBuffStart, _dumpBuffSize = 0;
        _dumpBuffStart = bufferIdx;
        while ( _dumpBuffStart && buffer[_dumpBuffStart] != '\n' &&
                ( bufferI
/*
 * Copyright 2000-2008, Ingo Weinhold <ingo_weinhold@gmx.de>.
 * All Rights Reserved. Distributed under the terms of the MIT license.
 */
template<int BYTES_PER_SAMPLE>
class SampleBuffer {
 protected:
	typedef	uint8				sample_block_t[BYTES_PER_SAMPLE];
 public:
	inline						SampleBuffer(void* buffer)
									: fBuffer((sample_block_t*)buffer) { }
	inline	void				operator+=(int samples) {
		fBuffer += samples;
	}
	inline	void				operator-=(int samples) {
		fBuffer -= samples;
	}
	inline	void				operator++(int) {
		fBuffer++;
	}
	inline	void				operator--(int) {
		fBuffer--;
	}
	inline	void*				operator+(int samples) {
		return fBuffer + samples;
	}
	inline	void*				operator-(int samples) {
		return fBuffer + samples;
	}
 protected:
			sample_block_t*		fBuffer;
};
template<typename sample_t>
class FloatSampleBuffer : public SampleBuffer<sizeof(float)> {
 public:
	inline						FloatSampleBuffer(void* buffer)
									: SampleBuffer<sizeof(float)>(buffer) {
	}
	inline	sample_t			ReadSa

		return *((float*)fBuffer);
	}
	inline	void				WriteSample(sample_t value) {
		*((float*)fBuffer) = value;
	}
};
template<typename sample_t>
class IntSampleBuffer : public SampleBuffer<sizeof(int)> {
 public:
	inline						IntSampleBuffer(void* buffer)
									: SampleBuffer<sizeof(int)>(buffer) {
	}
	inline	sample_t			ReadSample() const {
		return (sample_t)*((int*)fBuffer) / (sample_t)0x7fffffff;
	}
	inline	void				WriteSample(sample_t value) {
		*((int*)fBuffer) = int(value * (sample_t)0x7fffffff);
	}
};
template<typename sample_t>
class ShortSampleBuffer : public SampleBuffer<sizeof(short)> {
 public:
	inline						ShortSampleBuffer(void* buffer)
									: SampleBuffer<sizeof(short)>(buffer) {
	}
	inline	sample_t			ReadSample() const {
		return (sample_t)*((short*)fBuffer) / (sample_t)32767;
	}
	inline	void				WriteSample(sample_t value) {
		*((short*)fBuffer) = short(value * (sample_t)32767);
	}
};
template<typename sample_t>
class UCharSampleBuffer : public SampleBuffer<sizeof(
namespace terrain {
	using namespace utils;
	using ChunkCache = ChunkLoader::ChunkCache;
	ChunkLoader::~ChunkLoader() {
		LoadedChunkCache.empty();
	}
	bool ChunkLoader::IsChunkGenerated(const ChunkOffsetVector & offset) const {
		return LoadedChunkCache.find(offset) != LoadedChunkCache.end();
	}
	ChunkDataPtr ChunkLoader::GetGeneratedChunk(const ChunkOffsetVector & offset) {
		auto found = LoadedChunkCache.find(offset);
		if (found != LoadedChunkCache.end())
			return found->second;
		else
			return LoadChunkFromDisk(offset);
	}
	ChunkDataPtr ChunkLoader::LoadChunkFromDisk(const ChunkOffsetVector & offset) {
		return NULL;
	}
	ChunkDataPtr ChunkLoader::GenerateMissingChunk(const ChunkOffsetVector & offset) {
		const auto & props = BRLoader->GetGeneratorParameters();
		const auto point = TerrainGenParams.ToRealCoordSpace(offset).Truncate();
		const auto biomeTri = BRLoader->FindContainingBiomeTriangle(point);
		const auto regionPos = props.ToBiomeRegionCoordinates(point);
		const UVWVe

		double height = ((
			biomeTri[1]->GetElevation() * uvw.X +
			biomeTri[2]->GetElevation() * uvw.Y +
			biomeTri[0]->GetElevation() * uvw.Z) - 0.75) * 10000;
		auto data = new ChunkData(TerrainGenParams.GridCellCount, offset);
		SetDefaultHeight(*data, (Int32) height);
		auto cd = ChunkDataPtr(data);
		LoadedChunkCache.insert({ offset, cd });
		return cd;
	}
	ChunkDataPtr ChunkLoader::GetChunkAt(const ChunkOffsetVector & offset) {
		auto loaded = GetGeneratedChunk(offset);
		if (!loaded) {
			loaded = GenerateMissingChunk(offset);
		}
		return loaded;
	}
	const TerrainGeneratorParameters & ChunkLoader::GetGeneratorParameters() const {
		return TerrainGenParams;
	}
	void ChunkLoader::SetDefaultHeight(ChunkData & data, const Int32 height) {
		auto chunkHeight = TerrainGenParams.ChunkScale;
		if (((data.ChunkOffset.Z + 1) * (Int64) chunkHeight) < height) {
		} else if ((data.ChunkOffset.Z * (Int64) chunkHeight) > height) {
		} else {
			auto localHeight = TerrainGenParams.GridCellCount
void create_wfilter(f_complex* wfilter, const char* name);
void create_longpass_filter(f_complex* wfilter, float_type lambda);
void create_shortpass_filter(f_complex* wfilter, float_type lambda);
class dump_type_empty_class
protected:
	FILE* dumpfid;
	int   tN, xN, yN, zN;
	int   nz_denom;
	int  iscomplex;
	long int piece_size;
	long int header_ofs;
	dump_type_empty_class() {};
	virtual long int fileofs() = 0;
public:
   ~dump_type_empty_class();
    virtual void init_dumpfile(const char* filename);
	virtual void init_dumpfile(FILE* fid, int i);
	virtual  void dump();
    virtual  void dump_write(void* buf);
	virtual  void dump_noflush() = 0;
};
class dump_type_full_class : public dump_type_empty_class
protected:
	dump_type_full_class() {};
    virtual long int fileofs();
public:
	dump_type_full_class(FILE* optfid, int i);
    
	virtual void dump_noflush();
	~dump_type_full_class() {};
};
class dump_type_maxI_class : public dump_type_empty_class
protected:
		f_complex* wfilter;
       

		dump_type_maxI_class() {};
public:
	     dump_type_maxI_class(FILE* optfid, int i);
		 ~dump_type_maxI_class();
	     virtual void dump_noflush();
	    
};
class dump_type_flux_class : public dump_type_maxI_class
public:
	dump_type_flux_class(FILE* optfid, int i) : dump_type_maxI_class(optfid, i) {};
	~dump_type_flux_class() {};
	virtual void dump_noflush();
	  
};
class dump_type_duration_class : public dump_type_maxI_class
public:
	dump_type_duration_class(FILE* optfid, int i) : dump_type_maxI_class(optfid, i) {}; 
	~dump_type_duration_class() {};
	virtual void dump_noflush(); 
};
class dump_type_fluxk_class : public dump_type_maxI_class
public:
		dump_type_fluxk_class() {};
		dump_type_fluxk_class(FILE* optfid, int i); 
		~dump_type_fluxk_class() {};
		virtual void dump_noflush();
		virtual long int fileofs();
};
class dump_type_ysection_class : public dump_type_empty_class
protected:
	int ny;
	bool mydump;
	virtual long int fileofs();
	virtual void init_ny(FILE* fid, int num);
	

	fftwt_plan fft_bwplan_sectiont; 
public:
	dump_type_ysection_class(FILE* optfid, int num);
   ~dump_type_ysection_class() {};
   virtual void dump_noflush();
};
class dump_type_ysectionk_class : public dump_type_ysection_class
protected:
	virtual void init_ny(FILE* fid, int num);
	virtual long int fileofs();
public:
	dump_type_ysectionk_class(FILE* optfid, int num);
	virtual void dump_noflush();
};
class dump_type_ysection_maxI_class : public dump_type_ysection_class
protected:
	f_complex* wfilter; 
	dump_type_ysection_maxI_class() {};
public:
	dump_type_ysection_maxI_class(FILE* optfid, int num);
   ~dump_type_ysection_maxI_class();
	virtual void dump_noflush();
};
class dump_type_ysection_flux_class : public dump_type_ysection_maxI_class
public:
	dump_type_ysection_flux_class(FILE* optfid, int num) : dump_type_ysection_maxI_class(optfid,num) {};
   ~dump_type_ysection_flux_class() {};
   virtual void dump_noflush();
};
class dump_type_youngy_class : public dump_type_ysection_maxI_c

public:
	dump_type_youngy_class(FILE* optfid, int num);
	~dump_type_youngy_class();
	virtual void dump_noflush(); 
	virtual long int fileofs();
};
class dump_type_field_axis_class : public dump_type_empty_class
protected:
	virtual long int fileofs();
	dump_type_field_axis_class() {};
public:
	dump_type_field_axis_class(FILE* optfid, int num);
	~dump_type_field_axis_class() {};
	virtual void dump_noflush();
};
class dump_type_plasma_axis_class : public dump_type_field_axis_class
protected:
	dump_type_plasma_axis_class() {};
public:
	dump_type_plasma_axis_class(FILE* optfid, int num);
	~dump_type_plasma_axis_class() {};
	virtual void dump_noflush();
};
class dump_type_Z_axis_class : public dump_type_plasma_axis_class
protected:
	dump_type_Z_axis_class() {};
public:
	dump_type_Z_axis_class(FILE* optfid, int num) : dump_type_plasma_axis_class(optfid, num) {};
	~dump_type_Z_axis_class() {};
	virtual void dump_noflush(); 
};
class dump_type_average_spectrum_class : public dump_type_field_ax

protected:
	dump_type_average_spectrum_class() {};
public:
	dump_type_average_spectrum_class(FILE* optfid, int num);
	~dump_type_average_spectrum_class() {};
	virtual void dump_noflush();
};
class dump_type_full_plasma_class : public dump_type_full_class
protected:
	dump_type_full_plasma_class() {};
public:
	dump_type_full_plasma_class(FILE* fid, int num);
   ~dump_type_full_plasma_class() {};
	virtual void dump_noflush();
};
class dump_type_plasma_max_class : public dump_type_maxI_class
protected:
	dump_type_plasma_max_class() {};
public:
	dump_type_plasma_max_class(FILE* fid, int num);
   ~dump_type_plasma_max_class() {};
	virtual void dump_noflush();
};
class dump_type_ysection_plasma_class : public dump_type_ysection_class
protected:
	dump_type_ysection_plasma_class() {};
public:
	dump_type_ysection_plasma_class(FILE* fid, int num);
   ~dump_type_ysection_plasma_class() {};
	virtual void dump_noflush();
};
class dump_type_ysection_plasma_max_class : public dump_type_ysection_plasm
/*
 * $Id$
 *
 * Copyright 2010 Object Computing, Inc.
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",6);
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0) {
    return 0;
  }
  return value._retn();
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",6);
  return this->map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0) {
    value = new RepoIdSet();
    if (bind(map_, key, value) != 0) {
      ACE_ERROR((LM_ERROR,
                 "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                 "the RepoIdSetMa
typedef OpenDDS::DCPS::DomainParticipantImpl::RepoIdSequence RepoIdSequence;
typedef OpenDDS::DCPS::RepoId RepoId;
namespace {
  namespace Factory {
    RepoId not_default_repo_id() {
      RepoId result;
      int i = 1;
      result.guidPrefix[ 0] =  i += 2;
      result.guidPrefix[ 1] =  i += 2;
      result.guidPrefix[ 2] =  i += 2;
      result.guidPrefix[ 3] =  i += 2;
      result.guidPrefix[ 4] =  i += 2;
      result.guidPrefix[ 5] =  i += 2;
      result.guidPrefix[ 6] =  i += 2;
      result.guidPrefix[ 7] =  i += 2;
      result.guidPrefix[ 8] =  i += 2;
      result.guidPrefix[ 9] =  i += 2;
      result.guidPrefix[10] =  i += 2;
      result.guidPrefix[11] =  i += 2;
      result.entityId.entityKey[0] = 0;
      result.entityId.entityKey[1] = 0;
      result.entityId.entityKey[2] = 0;
      result.entityId.entityKind = 123;
      return result;
    }
  };
  long entityKey(const RepoId& id) {
    long result = (((id.entityId.entityKey[0]  << 8) |
                     id.en

                     id.entityId.entityKey[2];
    return result;
  }
};
int
ACE_TMAIN(int, ACE_TCHAR*[])
    RepoId repoId;
    memset(&repoId, 0, sizeof(repoId));
    RepoIdSequence seq(repoId);
    TEST_ASSERT(entityKey(seq.next()) == 1);
    TEST_ASSERT(entityKey(seq.next()) == 2);
    TEST_ASSERT(entityKey(seq.next()) == 3);
    TEST_ASSERT(entityKey(seq.next()) == 4);
  }
    RepoId repoId = Factory::not_default_repo_id();
    RepoIdSequence seq(repoId);
    {
      RepoId result = seq.next();
      TEST_ASSERT(!memcmp(repoId.guidPrefix,
                          result.guidPrefix,
                          sizeof repoId.guidPrefix));
      TEST_ASSERT(entityKey(result) == 1);
      TEST_ASSERT(repoId.entityId.entityKind == result.entityId.entityKind);
    }
    {
      RepoId result = seq.next();
      TEST_ASSERT(!memcmp(repoId.guidPrefix,
                          result.guidPrefix,
                          sizeof repoId.guidPrefix));
      TEST_ASSERT(entityKey(result) == 2
void model::setX(double fromX)
	this->x = fromX;
double model::getX()
	return this->x;
void model::setY(double fromY)
	this->y = fromY;
double model::getY()
	return y;
void model::setZ(double fromZ)
	z = fromZ;
double model::getZ()
	return z;
void model::setW(double fromW)
	w = fromW;
double model::getW()
	return w;
void model::setInitClass(int fromInitClass)
	initClass = fromInitClass;
int model::getInitClass()
	return initClass;
void model::setCalcClass(int fromCalcClass)
	calcClass = fromCalcClass;	
int model::getCalcClass()
	return calcClass;
model model::operator=(const model &data)
	x = data.x;
	y = data.y;
	z = data.z;
	w = data.w;
	initClass = data.initClass;
    calcClass = data.calcClass;
	return *this;
model model::operator+=(const model &data)
    x += data.x;
    y += data.y;
    z += data.z;
    w += data.w;
    
    return *this;
/*
model model::operator+(const model &data)
    x += data.x;
    y += data.y;
    z += data.z;
    w += data.w;
    
    return *this;
 */
mod

    x /= d;
    y /= d;
    z /= d;
    w /= d;
    
    return *this;
centerModel centerModel::operator=(const model &data)
	x = data.x;
	y = data.y;
	z = data.z;
	w = data.w;
	initClass = data.initClass;
    calcClass = data.calcClass;
	return *this;
centerModel centerModel::operator=(const centerModel &data)
    x = data.x;
	y = data.y;
	z = data.z;
	w = data.w;
	initClass = data.initClass;
    calcClass = data.calcClass;
    
	return *this;
centerModel centerModel::operator+(const model &data)
    x += data.x;
    y += data.y;
    z += data.z;
    w += data.w;
    
    return *this;
centerModel centerModel::operator/(int d)
    x /= d;
    y /= d;
    z /= d;
    w /= d;
    
    return *this;
bool centerModel::operator==(const centerModel &data)
    if (x==data.x && y==data.y && z==data.z && w==data.w)
    {
        return 1;
    }
    else
        return 0;
ostream &operator<<(std::ostream &os, const centerModel &data)
    os<<data.x<<'\t'<<data.y<<'\t'<<data.z<<'\t'<<data.w;
  
USING_NS_CC;
using namespace cocostudio;
using namespace cocos2d::ui;
bool LoadBar::initWithFile(const std::string &file) {
    _rootNode = CSLoader::getInstance()->createNodeWithFlatBuffersFile(file);
    _loadBar = static_cast<cocos2d::ui::LoadingBar*>(_rootNode->getChildByName("loadedBar"));
    addChild(_rootNode);
    setContentSize(_rootNode->getContentSize());
    _loadAsset = new LoadAssert(this);
    this->setProgressValue(0);
    return true;
LoadBar *LoadBar::createWithLoadBar(const std::string &file) {
    auto load = new (std::nothrow)LoadBar();
    if(load && load->initWithFile(file))
    {
        load->autorelease();
        return load;
    }else CC_SAFE_DELETE(load);
    return nullptr;
void LoadBar::setProgressValue(int value) {
    _loadBar->setPercent(value);
void LoadBar::finish() {
    CCLOG("load finish...");
    if(_callfun)
    {
        _callfun();
    }
    removeFromParent();
void LoadBar::progress(int value) {
   this->setProgressValue(value);
LoadBar::~Lo
using namespace std;
namespace tms {
namespace common {
namespace contraption {
template<class T>
class ModelWrapper;
namespace tms {
namespace common {
namespace contraption {
template< class T >
class ModelWrapper : public Model {
  typedef T* TP;
  public:
    static ModelP GetModelLink(ModelBackendP backend) {
      TP model = model_ ? dynamic_cast<T*>(&*(model_)) : 0;
        model_.reset(new T(backend));
      }
      return model_;
    }
    static ModelP GetModelLink(ModelBackend *backend) {
      TP model = model_ ? dynamic_cast<T*>(&*(model_)) : 0;
      if (!model || true) {
        model_.reset(new T(backend));
      }
      return model_;
    }
    static void PrepareModel(ModelBackendP backend) {
      GetModelLink(backend);
    }
    static void PrepareModel(ModelBackend *backend) {
      GetModelLink(backend);
    }
    static ModelP GetModel() {
      TP model = dynamic_cast<T*>(&*model_);
      if (!model->initialized_) {
        model->initialized_ = true;
        mo
/*
 * InvocationWrapper.hpp
 *
 *  Created on: May 6, 2013
 *      Author: Bakhshi
 */
class InvocationWrapper: public QObject {
Q_OBJECT
Q_PROPERTY(QString mimeType READ mimeType WRITE setMimeType NOTIFY mimeTypeChanged)
Q_PROPERTY(QUrl uri READ uri WRITE setUri NOTIFY uriChanged)
Q_PROPERTY(QString invokeActionId READ invokeActionId WRITE setInvokeActionId NOTIFY invokeActionIdChanged)
Q_PROPERTY(QString invokeTargetId READ invokeTargetId WRITE setInvokeTargetId NOTIFY invokeTargetIdChanged)
public:
	InvocationWrapper(QObject* parent = 0);
	QString mimeType() const;
	void setMimeType(const QString& mimeType);
	QUrl uri() const;
	void setUri(const QUrl& uri);
	QString invokeActionId() const;
	Q_INVOKABLE
	void setInvokeActionId(const QString& actionId);
	QString invokeTargetId() const;Q_INVOKABLE
	void setInvokeTargetId(const QString& targetId);
	Q_INVOKABLE
	void invoke();
Q_SIGNALS:
	void mimeTypeChanged(const QString&);
	void uriChanged(const QUrl&);
	void invokeActionIdChanged(con
namespace ld3d
	namespace voxel
	{
		ChunkLoader::ChunkLoader(void)
		{
			m_pendingCount = 0;
		}
		ChunkLoader::~ChunkLoader(void)
		{
		}
		bool ChunkLoader::Initialize(ChunkManagerPtr pChunkManager, OctreeManagerPtr pOctreeManager, MeshizerPtr pMeshizer, WorldGenPtr pWorldGen)
		{
			m_pChunkManager		= pChunkManager;
			m_pOctreeManager	= pOctreeManager;
			m_pMeshizer			= pMeshizer;
			m_service.Initialize(*pMeshizer, *pWorldGen);
			return true;
		}
		void ChunkLoader::Release()
		{
			m_service.Release();
		}
		void ChunkLoader::Update()
		{
			m_service.Run();
		}
		bool ChunkLoader::RequestChunk(const ChunkKey& key, const ChunkLoadedHandler& on_loaded)
		{
			bool loaded = false;
			ChunkPtr pChunk = m_pChunkManager->FindChunk(key, loaded);
			if(pChunk != nullptr)
			{
				pChunk->IncRef();
				if(on_loaded)
				{
					on_loaded(key);
				}
				return true;
			}
			if(loaded == true)
			{
				return true;
			}
			m_pendingCount++;
			m_service.GenChunk(key, [=](const ChunkKey

			{
				_on_chunk_gen_complete(key, data, adj, is_empty);
				if(on_loaded)
				{
					on_loaded(key);
				}
				m_pendingCount--;
			});
			
			return true;
		}
		void ChunkLoader::_on_chunk_gen_complete(const ChunkKey& key, const ChunkData& data, const ChunkAdjacency& adj, bool is_empty)
		{
			ChunkPtr pChunk = nullptr;
			if(is_empty == false)
			{
				pChunk = m_pChunkManager->CreateChunk(key, data.GetData());
				pChunk->SetAdjacency(adj);
				pChunk->SetGenerated(true);
			}
			m_pChunkManager->AddChunk(key, pChunk);
			UpdateChunkAdjacency(key);
		}
		
		uint32 ChunkLoader::GetPendingCount() const
		{
			return m_pendingCount;
		}
		
		bool ChunkLoader::RequestChunk(const Coord& center, uint32 radius, uint32 height, const std::function<bool(const ChunkKey&)>& pre_load)
		{
			m_pChunkManager->PickChunk(center, radius, height, [&](const ChunkKey& key)
			{
				Coord c = key.ToChunkOrigin();
				if((c.y + (int32)CHUNK_SIZE) < -16 || (c.y > 128))
				{
					return;
				}
				if(

				{
					RequestChunk(key, nullptr);
				}
			});
			return true;
		}
		
		void ChunkLoader::UpdateChunkAdjacency(const ChunkKey& key)
		{
			bool loaded = false;
			ChunkPtr pChunk = m_pChunkManager->FindChunk(key, loaded);
			if(loaded == false)
			{
				return;
			}
			Coord this_coord = key.ToChunkCoord();
			m_pChunkManager->PickSurroundingChunks(key, [&](const ChunkKey& adjKey, ChunkPtr pAdj, bool adjLoaded)
			{
				Coord this_coord = key.ToChunkCoord();
				Coord c = adjKey.ToChunkCoord();
				if(adjLoaded == false)
				{
					return;
				}
				if(pChunk != nullptr)
				{
					pChunk->GetAdjacency().UpdateChunkAdjacency(adjKey, pAdj);
					if(pChunk->GetAdjacency().IsComplete())
					{
						RequestMesh(pChunk);
					}
				}
				
				if(pAdj == nullptr)
				{
					return;
				}
				
				pAdj->GetAdjacency().UpdateChunkAdjacency(key, pChunk);
				if(pAdj->GetAdjacency().IsComplete())
				{
					RequestMesh(pAdj);
				}
			});
		}
		
		bool ChunkLoader::RequestUnloadChunk(Chun

		{
			pChunk->DecRef();
			if(pChunk->GetRef() != 0)
			{
				return true;
			}
			m_pOctreeManager->RemoveChunk(pChunk);
			m_pChunkManager->RemoveChunk(pChunk);
			UpdateChunkAdjacency(pChunk->GetKey());
			return true;
		}
		bool ChunkLoader::RequestUnloadChunk(const ChunkKey& key)
		{
			bool loaded = false;
			ChunkPtr pChunk = m_pChunkManager->FindChunk(key, loaded);
			if(loaded == false)
			{
				return true;
			}
			if(pChunk)
			{
				pChunk->DecRef();
				if(pChunk->GetRef() != 0)
				{
					return true;
				}
			}
			m_pOctreeManager->RemoveChunk(pChunk);
			m_pChunkManager->RemoveChunk(key);
			UpdateChunkAdjacency(key);
			return true;
		}
		
		bool ChunkLoader::RequestMesh(ChunkPtr pChunk)
		{
			++m_pendingCount;
			m_service.GenMesh(pChunk->GetKey(), pChunk->GetData(), pChunk->GetAdjacency(), [=](const ChunkKey& key, ChunkMesh* mesh)
			{
				_on_mesh_gen_complete(key, mesh);
				--m_pendingCount;
			});
			return true;
		}
		void ChunkLoader::_on_mesh_gen_complete(c

		{
			bool loaded = false;
			ChunkPtr pChunk = m_pChunkManager->FindChunk(key, loaded);
			if(pChunk == nullptr)
			{
				return;
			}
			
			if(mesh->GetSubsetCount() == 0)
			{
				return;
			}
			if(pChunk->GetMesh() != nullptr && pChunk->GetMesh()->GetSubsetCount() != 0)
			{
				return;
			}
			ChunkMeshPtr pMesh = pool_manager()->AllocChunkMesh();
			pMesh->AllocVertexBuffer(mesh->GetVertexCount());
			pMesh->AllocIndexBuffer(mesh->GetIndexCount());
			memcpy(pMesh->GetVertexBuffer(), mesh->GetVertexBuffer(), sizeof(ChunkMesh::VoxelVertex) * mesh->GetVertexCount());
			memcpy(pMesh->GetIndexBuffer(), mesh->GetIndexBuffer(), sizeof(uint16) * mesh->GetIndexCount());
			for(uint32 i = 0; i < mesh->GetSubsetCount(); ++i)
			{
				ChunkMesh::Subset s = mesh->GetSubset(i);
				uint64 offset = (uint8*)s.vertexBuffer - (uint8*)mesh->GetVertexBuffer();
				s.vertexBuffer = (uint8*)pMesh->GetVertexBuffer() + offset;
				offset = (uint8*)s.indexBuffer - (uint8*)mesh->GetIndexBuffer();
		
/*
 * ResourceLocator.cpp
 *
 *  Created on: Aug 18, 2011
 *      Author: muhrin
 */
namespace spl {
namespace io {
namespace fs = boost::filesystem;
namespace algorithm = boost::algorithm;
ResourceLocator::ResourceLocator()
ResourceLocator::ResourceLocator(const fs::path & path) :
    myPath(path)
ResourceLocator::ResourceLocator(const fs::path & path,
    const std::string & resourceId) :
    myPath(path), myResourceId(resourceId)
bool
ResourceLocator::set(const std::string & locatorString)
  typedef std::vector< std::string> SplitVector;
  if(locatorString.empty())
    return false;
  fs::path newPath;
  std::string newResourceId;
  SplitVector splitStrings;
  algorithm::split(splitStrings, locatorString,
      algorithm::is_any_of(ID_DELIMITER));
  if(splitStrings.size() > 2)
    return false;
  else if(splitStrings.size() == 2)
    newResourceId = splitStrings[1];
  newPath = fs::path(splitStrings[0]);
  setPath(newPath);
  if(!newResourceId.empty())
    setId(newResourceId);
  re

::std::string
ResourceLocator::string() const
  std::string str = myPath.string();
  if(!myResourceId.empty())
    str += ID_DELIMITER + myResourceId;
  return str;
const fs::path &
ResourceLocator::path() const
  return myPath;
void
ResourceLocator::setPath(const fs::path & path)
  myPath = path;
void
ResourceLocator::clearPath()
  myPath.clear();
const std::string &
ResourceLocator::id() const
  return myResourceId;
void
ResourceLocator::setId(const std::string & resourceId)
  myResourceId = resourceId;
void
ResourceLocator::clearId()
  myResourceId.clear();
bool
ResourceLocator::empty() const
  return myPath.empty() && myResourceId.empty();
ResourceLocator &
ResourceLocator::operator =(const ResourceLocator & rhs)
  setPath(rhs.path());
  setId(rhs.id());
  return *this;
ResourceLocator &
ResourceLocator::makeRelative(const boost::filesystem::path & from)
  myPath = make_relative(from, myPath);
  return *this;
bool
equivalent(const ResourceLocator & loc1, const ResourceLocator & lo
namespace ssf {
namespace io {
template <class CompHandlerT, class ContextHandlerT>
struct ComposedOp {
 private:
  typedef typename std::remove_reference<CompHandlerT>::type CompHandler;
  typedef typename std::remove_reference<ContextHandlerT>::type ContextHandler;
 public:
  ComposedOp(CompHandler h, ContextHandler c)
      : handler(std::move(h)), context(std::move(c)) {}
  inline void operator()(const boost::system::error_code& ec,
                         std::size_t length) {
    handler(ec, length);
  }
  inline void operator()(const boost::system::error_code& ec,
                         std::size_t length) const {
    handler(ec, length);
  }
  inline void operator()(const boost::system::error_code& ec) { handler(ec); }
  inline void operator()(const boost::system::error_code& ec) const {
    handler(ec);
  }
  CompHandler handler;
  ContextHandler context;
};
template <typename CompHandler, typename ContextHandler>
inline void* asio_handler_allocate(
    std::size_t size, Co

  return boost_asio_handler_alloc_helpers::allocate(size,
                                                    this_handler->context);
template <typename CompHandler, typename ContextHandler>
inline void asio_handler_deallocate(
    void* pointer, std::size_t size,
    ComposedOp<CompHandler, ContextHandler>* this_handler) {
  boost_asio_handler_alloc_helpers::deallocate(pointer, size,
                                               this_handler->context);
template <typename CompHandler, typename ContextHandler>
inline bool asio_handler_is_continuation(
    ComposedOp<CompHandler, ContextHandler>* this_handler) {
  return boost_asio_handler_cont_helpers::is_continuation(
      this_handler->context);
template <typename Function, typename CompHandler, typename ContextHandler>
inline void asio_handler_invoke(
    const Function& function,
    ComposedOp<CompHandler, ContextHandler>* this_handler) {
  boost_asio_handler_invoke_helpers::invoke(function, this_handler->context);
template <typ
/*
 * Copyright (C) 2008-2010 Josh A. Beam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBST

 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
namespace DromeAudio {
/*
 * Sample class
 */
Sample::Sample()
	m_channelValues[0] = 0.0f;
	m_channelValues[1] = 0.0f;
float &
Sample::operator [] (int index)
	return m_channelValues[index];
const float &
Sample::operator [] (int index) const
	return m_channelValues[index];
Sample
Sample::operator + (const Sample &s) const
	Sample sample;
	for(int i = 0; i < 2; i++)
		sample[i] = (*this)[i] + s[i];
	return sample;
void
Sample::operator += (const Sample &s)
	*this = *this + s;
Sample
Sample::operator - (const Sample &s) const
	Sample sample;
	for(int i = 0; i < 2; i++)
		sample[i] = (*this)[i] - s[i];
	return sample;
void
Sample::operator -= (const Sample &s)
	*this = *this - s;
Sample
Sample::operator * (const Sampl

	Sample sample;
	for(int i = 0; i < 2; i++)
		sample[i] = (*this)[i] * s[i];
	return sample;
void
Sample::operator *= (const Sample &s)
	*this = *this * s;
Sample
Sample::operator * (float f) const
	Sample sample;
	for(int i = 0; i < 2; i++)
		sample[i] = (*this)[i] * f; 
	return sample;
void
Sample::operator *= (float f)
	*this = *this * f;
Sample
Sample::operator / (const Sample &s) const
	Sample sample;
	for(int i = 0; i < 2; i++)
		sample[i] = (*this)[i] / s[i];
	return sample;
void
Sample::operator /= (const Sample &s)
	*this = *this / s;
Sample
Sample::operator / (float f) const
	Sample sample;
	for(int i = 0; i < 2; i++)
		sample[i] = (*this)[i] / f;
	return sample;
void
Sample::operator /= (float f)
	*this = *this / f;
Sample
Sample::clamp() const
	Sample sample;
	for(int i = 0; i < 2; i++) {
		sample[i] = (*this)[i];
		if(sample[i] < -1.0f)
			sample[i] = -1.0f;
		else if(sample[i] > 1.0f)
			sample[i] = 1.0f;
	}
	return sample;
Sample
Sample::balance(float amount) const
	Sam

	if(amount < 0.0f) {
		float f = m_channelValues[1] * (-amount);
		tmp[0] += f;
		tmp[1] -= f;
	} else {
		float f = m_channelValues[0] * amount;
		tmp[0] -= f;
		tmp[1] += f;
	}
	return tmp;
Sample
Sample::toMono() const
	float average = (m_channelValues[0] + m_channelValues[1]) / 2.0f;
	Sample sample;
	sample[0] = average;
	sample[1] = average;
	return sample;
Sample
Sample::fromInt8(const int8_t values[], unsigned int numChannels)
	const float max = 127.0f;
	Sample sample;
	switch(numChannels) {
		default:
			throw Exception("Sample::fromInt8(): Unsupported number of channels (%u)\n", numChannels);
			break;
		case 1:
			sample[0] = (float)values[0] / max;
			sample[1] = sample[0];
			break;
		case 2:
			sample[0] = (float)values[0] / max;
			sample[1] = (float)values[1] / max;
			break;
	}
	return sample;
Sample
Sample::fromInt16(const int16_t values[], unsigned int numChannels)
	const float max = 32767.0f;
	Sample sample;
	switch(numChannels) {
		default:
			throw Exception("Samp
class Invoke {
	public:
		int abc;
		Invoke() : abc(0) { printf("%p ctor!\n", this); }
		~Invoke() { printf("dtor!\n"); }
		void invoke(int a, double b, const char *c)
		{
			printf("a: %d, b: %f, c: %s\n", a, b, c);
		}
		void invokeObj(Invoke *obj) { printf("%p invokeObj: %p\n", this, obj); }
		Invoke *objInvoke(void) { printf("return this\n"); return this; }
		void fromlua() { printf("from lua!\n"); }
		
		void luaCallback(std::function<void(int)> f) { printf("calling std::func\n"); f(123); }
		
		static void luaStaticCallback(std::function<void(int)> f) { printf("calling std::func\n"); f(123); }
};
int main(int, char **)
	LuaGlue state;
	auto &Class = state.Class<Invoke>("Invoke").
		ctor("new").
		method("invoke", &Invoke::invoke).
		method("invokeObj", &Invoke::invokeObj).
		method("objInvoke", &Invoke::objInvoke).
		method("fromlua", &Invoke::fromlua).
		method("luaCallback", &Invoke::luaCallback).
		method("luaStaticCallback", &Invoke::luaStaticCallback);
		
	state.open().glue(

	printf("running lua script!\n");
	if(!state.doFile("invoke.lua"))
	{
		printf("failed to dofile: invoke.lua\n");
		printf("err: %s\n", state.lastError().c_str());
	}
	printf("testing invoking methods from C++\n");
	Invoke *test_obj = new Invoke();
	test_obj->abc = 123;
	Class.invokeVoidMethod("invoke", test_obj, 1, 2.0, "three");
	Class.invokeVoidMethod("invoke_lua", test_obj, 2, 3.0, "four");
	Class.invokeVoidMethod("invokeObj", test_obj, test_obj);
	Invoke *ret_obj = Class.invokeMethod<Invoke *>("objInvoke", test_obj);
	if(ret_obj != test_obj)
	{
		printf("ret_obj(%p) != test_obj(%p) ! :o\n", ret_obj, test_obj);
	}
	printf("test_obj.abc: %i, ret_obj.abc: %i\n", test_obj->abc, ret_obj->abc);
	state.invokeVoidFunction("from_c");
	int ret = state.invokeFunction<int>("from_c_ret");
	printf("from_c_ret ret: %i\n", ret);
	int ret2 = state.invokeFunction<int>("from_c_args", 1, 2.0, "three");
	printf("from_c_args ret: %i\n", ret2);
	if(state.globalExists("from_c_ret"))
	{
		printf("from_c_
namespace dragonpoop
    model_frame::model_frame( model_writelock *ml, dpid id ) : model_component( ml, id, model_component_type_frame, 0 )
    {
    }
    model_frame::~model_frame( void )
    {
        model_component_writelock *l;
        shared_obj_guard g;
        l = (model_component_writelock *)g.writeLock( this );
        g.unlock();
    }
    shared_obj_readlock *model_frame::genReadLock( shared_obj *p, dpmutex_readlock *l )
    {
        return new model_frame_readlock( (model_frame *)p, l );
    }
    shared_obj_writelock *model_frame::genWriteLock( shared_obj *p, dpmutex_writelock *l )
    {
        return new model_frame_writelock( (model_frame *)p, l );
    }
    shared_obj_ref *model_frame::genRef( shared_obj *p, std::shared_ptr<shared_obj_refkernal> *k )
    {
        return new model_frame_ref( (model_frame *)p, k );
    }
    void model_frame::onRun( dpthread_lock *thd, gfx_writelock *g, model_writelock *m, model_component_writelock *l )
    {
    }
    void model_fr
extern "C" MY_EXPORT LVPS_GraphicModel* FORTRAN()
	LVPS_GraphicModel* model = new LVPS_FORTRAN();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* DOTD()
	LVPS_GraphicModel* model = new LVPS_DOTD();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* PRUG()
	LVPS_GraphicModel* model = new LVPS_PRUG();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* AERHT()
	LVPS_GraphicModel* model = new LVPS_AERHT();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* GSV()
	LVPS_GraphicModel* model = new LVPS_GSV();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* GRETS()
	LVPS_GraphicModel* model = new LVPS_GRETS();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* AKLAB()
	LVPS_GraphicModel* model = new LVPS_AKLAB();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* AKLAB3D()
	LVPS_GraphicModel* model = new LVPS_AKLAB3D();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* D3LAB()
	LVPS_GraphicModel* model = new LVPS_D3LAB();
	return model;
extern "C" MY_EXPOR

	LVPS_GraphicModel* model = new LVPS_GROT2();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* GROT3()
	LVPS_GraphicModel* model = new LVPS_GROT3();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* TRTER()
	LVPS_GraphicModel* model = new LVPS_TRTER();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* KN3EFV()
	LVPS_GraphicModel* model = new LVPS_KN3EF();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* KN3FFV()
	LVPS_GraphicModel* model = new LVPS_KN3FF();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* EL3DP()
	LVPS_GraphicModel* model = new LVPS_EL3DP();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* LSK3D()
	LVPS_GraphicModel* model = new LVPS_LSK3D();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* Point()
	LVPS_GraphicModel* model = new LVPS_Point();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* PRLGRM()
	LVPS_GraphicModel* model = new LVPS_PRLGRM();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* CIL3DC()
	LVPS_Graphic

	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* RECTD()
	LVPS_GraphicModel* model = new LVPS_RECTD();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* LSK()
	LVPS_GraphicModel* model = new LVPS_LSK();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* Lined()
	LVPS_GraphicModel* model = new LVPS_Lined();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* Linev()
	LVPS_GraphicModel* model = new LVPS_Linev();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* AMORT()
	LVPS_GraphicModel* model = new LVPS_AMORT();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* ARROW()
	LVPS_GraphicModel* model = new LVPS_ARROW();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* GCYL()
	LVPS_GraphicModel* model = new LVPS_GCYL();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* GTRANS()
	LVPS_GraphicModel* model = new LVPS_GTRANS();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* CMASS()
	LVPS_GraphicModel* model = new LVPS_CMASS();
	return model;
extern 

	LVPS_GraphicModel* model = new LVPS_GNIRS();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* HS2VS()
	LVPS_GraphicModel* model = new LVPS_HS2VS();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* OPORA()
	LVPS_GraphicModel* model = new LVPS_OPORA();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* OPORAD()
	LVPS_GraphicModel* model = new LVPS_OPORAD();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* SILUET()
	LVPS_GraphicModel* model = new LVPS_SILUET();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* KONTUR()
	LVPS_GraphicModel* model = new LVPS_KONTUR();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* PRUZS()
	LVPS_GraphicModel* model = new LVPS_PRUZS();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* ELP3D()
	LVPS_GraphicModel* model = new LVPS_ELP3D();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* SHAPE()
	LVPS_GraphicModel* model = new LVPS_Shape();
	return model;
extern "C" MY_EXPORT LVPS_GraphicModel* GCAM()
	LVPS_Graphic
MCLSample* ObserveGoal::sample;
bool ObserveGoal::sample_set = false;
ObserveGoal::ObserveGoal()
void
ObserveGoal::SetSample(MCLSample* input)
	sample = input;
	sample_set = true;
void
ObserveGoal::Observation(GoalInformation _input)
	if(!sample_set) return;
	int pixels = state.self.cdt[_input.goal_color_id].value;
	DirectionOfGoal(_input.goal_color_id,_input.directionRight,_input.directionLeft);
	double sum = 0.0;
	for(int i=0;i<SAMPLE_NUMBER;i++)
		sum += sample->sample[i].m_w;
	if(sum < 0.02)
		sample->ExpansionResetting();
	else
	{
		for(int i=0;i<SAMPLE_NUMBER;i++)	
			sample->sample[i].m_w /= sum;
	}
	state.self.position = sample->CalcAverageAndStdDev();
void
ObserveGoal::DirectionOfGoal(COLOR_NAME_TAG color,double direction0,double direction1)
	double thr;
	thr = PI/12.0;
	double direction_rad0 = direction0*3.141592/180.0;
	double direction_rad1 = direction1*3.141592/180.0;
	double x,y,th1,th2;
	if(color == SKYBLUE)
	{
		int harf_goal_width = GOAL_WIDTH/2;
		for(int t=0;t<SAMPLE

		{
			sample->sample[t].m_t &= MCLSample::m_nSinCosMask;
			unsigned int a = sample->sample[t].m_t;
			{
				sample->sample[t].m_w *= 0.0001;
				continue;
			}
			double goal_x = -FIELD_MAX_X - sample->sample[t].m_x;
			double goal_y0 = -harf_goal_width - sample->sample[t].m_y;
			double goal_y1 = harf_goal_width - sample->sample[t].m_y;
			
			x = goal_x*MCLSample::m_dCos[a] + goal_y0*MCLSample::m_dSin[a];
			y = -goal_x*MCLSample::m_dSin[a] + goal_y0*MCLSample::m_dCos[a];
			th1 = atan2(y,x);
			x = goal_x*MCLSample::m_dCos[a] + goal_y1*MCLSample::m_dSin[a];
			y = -goal_x*MCLSample::m_dSin[a] + goal_y1*MCLSample::m_dCos[a];
			th2 = atan2(y,x);
			if(sample->sample[t].m_x > -FIELD_MAX_X)
			{
				if(th1 + thr < direction_rad0 || th2 - thr > direction_rad0)
				{
					sample->sample[t].m_w *= 0.0001;
				}
				if(th1 + thr < direction_rad1 || th2 - thr > direction_rad1)
				{
					sample->sample[t].m_w *= 0.0001;
				}
			}
			else
			{
				if(th1 > 0 && th2 < 0)
				{
					if(th1

					{
						sample->sample[t].m_w *= 0.0001;
					}
					if(th1 + thr < direction_rad1 || th2 - thr > direction_rad1)
					{
						sample->sample[t].m_w *= 0.0001;
					}
				}
				else if(th1 < 0)
				{
					if(th2 - thr > direction_rad0)
					{
						sample->sample[t].m_w *= 0.0001;
					}
					if(th2 - thr > direction_rad1)
					{
						sample->sample[t].m_w *= 0.0001;
					}
				}
				else if(th2 > 0)
				{
					if(th1 + thr < direction_rad0)
					{
						sample->sample[t].m_w *= 0.0001;
					}
					if(th1 + thr < direction_rad1)
					{
						sample->sample[t].m_w *= 0.0001;
					}
				}
			}
		}
	}
	{
		int harf_goal_width = GOAL_WIDTH/2;
		for(int t=0;t<SAMPLE_NUMBER;t++)
		{
			sample->sample[t].m_t &= MCLSample::m_nSinCosMask;
			unsigned int a = sample->sample[t].m_t;
			{
				sample->sample[t].m_w *= 0.0001;
				continue;
			}
			double goal_x = FIELD_MAX_X - sample->sample[t].m_x;
			double goal_y0 = harf_goal_width - sample->sample[t].m_y;
			double goal_y1 = -harf_goal_w

			
			x = goal_x*MCLSample::m_dCos[a] + goal_y0*MCLSample::m_dSin[a];
			y = -goal_x*MCLSample::m_dSin[a] + goal_y0*MCLSample::m_dCos[a];
			th1 = atan2(y,x);
			x = goal_x*MCLSample::m_dCos[a] + goal_y1*MCLSample::m_dSin[a];
			y = -goal_x*MCLSample::m_dSin[a] + goal_y1*MCLSample::m_dCos[a];
			th2 = atan2(y,x);
			if(sample->sample[t].m_x < FIELD_MAX_X)
			{
				if(th1 + thr < direction_rad0 || th2 - thr > direction_rad0)
				{
					sample->sample[t].m_w *= 0.0001;
				}
				if(th1 + thr < direction_rad1 || th2 - thr > direction_rad1)
				{
					sample->sample[t].m_w *= 0.0001;
				}
			}
			else
			{
				if(th1 > 0 && th2 < 0)
				{
					if(th1 + thr < direction_rad0 || th2 - thr > direction_rad0)
					{
						sample->sample[t].m_w *= 0.0001;
					}
					if(th1 + thr < direction_rad1 || th2 - thr > direction_rad1)
					{
						sample->sample[t].m_w *= 0.0001;
					}
				}
				else if(th1 < 0)
				{
					if(th2 - thr > direction_rad0)
					{
						sample->sample[t].m_w *= 0.0001;
	
/*
** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConsta

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
class QStandardItem;
class QModelIndex;
class QWidget;
class ServerRepo;
class RepoItem;
class RepoCategoryItem;
class RepoItemDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit RepoItemDelegate(QObject *parent=0);
    void paint(QPainter *painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const;
    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const;
    void showRepoItemToolTip(const RepoItem *item,
                             const QPoint& global_pos,
                             QWidget *viewport,
                             const QRect& rect) const;
private:
    QStandardItem* getItem(const QModelIndex &index) const;
    void paintRepoItem(QPainter *painter,
                       const QStyleOptionViewItem& opt,
                       const RepoItem *item) const;
    void paintRepoCategoryItem(QPainter *painter,
                               const QStyleO
/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2012 Nokia Corporation and/or its subsidiary(-ies).
**
** Contact: Nokia Corporation (qt-info@nokia.com)
**
**
** GNU Lesser General Public License Usage
**
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** Please review the following information to ensure the GNU Lesser General
** Public License version 2.1 requirements will be met:
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
**
** Other Usage
**
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
****

namespace Debugger {
namespace Internal {
QDataStream &operator<<(QDataStream &stream, const ThreadData &d)
    stream << (qint64)d.id;
    stream << d.address;
    stream << d.function;
    stream << d.fileName;
    stream << d.state;
    stream << d.lineNumber;
    stream << d.name;
    return stream;
QDataStream &operator>>(QDataStream &stream, ThreadData &d)
    qint64 id;
    stream >> id;
    d.id = id;
    stream >> d.address;
    stream >> d.function;
    stream >> d.fileName;
    stream >> d.state;
    stream >> d.lineNumber;
    stream >> d.name;
    return stream;
QDataStream &operator<<(QDataStream &stream, const Threads &threads)
    stream << (quint64)threads.count();
    for (int i = 0; i < threads.count(); i++)
    {
        const ThreadData &d = threads.at(i);
        stream << d;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, Threads &threads)
    quint64 count;
    stream >> count;
    threads.clear();
    for (quint64 i = 0; i < count; ++i)
 

        ThreadData d;
        stream >> d;
        threads.append(d);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrame &s)
    stream << (quint64)s.level;
    stream << s.function;
    stream << s.file;
    stream << s.from;
    stream << s.to;
    stream << s.line;
    stream << s.address;
    stream << s.usable;
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrame &s)
    quint64 level;
    stream >> level;
    s.level = level;
    stream >> s.function;
    stream >> s.file;
    stream >> s.from;
    stream >> s.to;
    stream >> s.line;
    stream >> s.address;
    stream >> s.usable;
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrames &frames)
    stream << (quint64)frames.count();
    for (int i = 0; i < frames.count(); i++)
    {
        const StackFrame &s = frames.at(i);
        stream << s;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrames &frames)
    qui

    stream >> count;
    frames.clear();
    for (quint64 i = 0; i < count; ++i)
    {
        StackFrame s;
        stream >> s;
        frames.append(s);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointResponse &s)
    stream << s.id.majorPart();
    stream << s.condition;
    stream << s.ignoreCount;
    stream << s.fileName;
    stream << s.lineNumber;
    stream << s.threadSpec;
    stream << s.functionName;
    stream << s.address;
    stream << s.hitCount;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointResponse &s)
    int majorPart;
    stream >> majorPart;
    s.id = BreakpointResponseId(majorPart);
    stream >> s.condition;
    stream >> s.ignoreCount;
    stream >> s.fileName;
    stream >> s.lineNumber;
    stream >> s.threadSpec;
    stream >> s.functionName;
    stream >> s.address;
    stream >> s.hitCount;
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointParameters &s)
    

    stream << s.condition;
    stream << quint64(s.ignoreCount);
    stream << quint64(s.lineNumber);
    stream << quint64(s.address);
    stream << s.functionName;
    stream << int(s.pathUsage);
    stream << s.tracepoint;
    stream << s.module;
    stream << s.command;
    stream << s.message;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointParameters &s)
    quint64 t;
    QString str;
    QByteArray ba;
    bool b;
    stream >> str; s.fileName = str;
    stream >> ba; s.condition = ba;
    stream >> t; s.ignoreCount = t;
    stream >> t; s.lineNumber = t;
    stream >> t; s.address = t;
    stream >> str; s.functionName = str;
    stream >> t; s.pathUsage = static_cast<BreakpointPathUsage>(t);
    stream >> b; s.tracepoint = b;
    stream >> str ; s.module = str;
    stream >> str ; s.command = str;
    stream >> str ; s.message = str;
    return stream;
QDataStream &operator<<(QDataStream &stream, const WatchData &wd)
    stream << wd.id;
    stream 

    stream << wd.exp;
    stream << wd.name;
    stream << wd.value;
    stream << wd.editvalue;
    stream << wd.editformat;
    stream << wd.valuetooltip;
    stream << wd.typeFormats;
    stream << wd.type;
    stream << wd.displayedType;
    stream << wd.variable;
    stream << wd.address;
    stream << wd.size;
    stream << wd.hasChildren;
    stream << wd.generation;
    stream << wd.valueEnabled;
    stream << wd.valueEditable;
    stream << wd.error;
    stream << wd.state;
    stream << wd.changed;
    return stream;
QDataStream &operator>>(QDataStream &stream, WatchData &wd)
    stream >> wd.id;
    stream >> wd.iname;
    stream >> wd.exp;
    stream >> wd.name;
    stream >> wd.value;
    stream >> wd.editvalue;
    stream >> wd.editformat;
    stream >> wd.valuetooltip;
    stream >> wd.typeFormats;
    stream >> wd.type;
    stream >> wd.displayedType;
    stream >> wd.variable;
    stream >> wd.address;
    stream >> wd.size;
    stream >> wd.hasChildren;
    stream >>

    stream >> wd.valueEnabled;
    stream >> wd.valueEditable;
    stream >> wd.error;
    stream >> wd.state;
    stream >> wd.changed;
    return stream;
QDataStream &operator<<(QDataStream& stream, const DisassemblerLine &o)
    stream << o.address;
    stream << o.function;
    stream << o.offset;
    stream << o.lineNumber;
    stream << o.data;
    return stream;
QDataStream &operator>>(QDataStream& stream, DisassemblerLine &o)
    stream >> o.address;
    stream >> o.function;
    stream >> o.offset;
    stream >> o.lineNumber;
    stream >> o.data;
    return stream;
QDataStream &operator<<(QDataStream& stream, const DisassemblerLines &o)
    stream << quint64(o.size());
    for (int i = 0; i < o.size(); ++i)
    {
        stream << o.at(i);
    }
    return stream;
QDataStream &operator>>(QDataStream& stream, DisassemblerLines &o)
    DisassemblerLines r;
    quint64 count;
    stream >> count;
    for (quint64 i = 0; i < count; ++i)
    {
        DisassemblerLine line;
     
using namespace std;
static string tiles[5] = { "Red.png", "Blue.png", "Green.png", "Purple.png", "Yellow.png" };
LoadAssets* LoadAssets::pinstance = 0;
LoadAssets* LoadAssets::Instance()
    if (pinstance == 0)
    {
        pinstance = new LoadAssets;
    }
    
    return pinstance;
LoadAssets::~LoadAssets()
    
LoadAssets::LoadAssets()
    background = LoadImage("BackGround.jpg");
    redTile = LoadImage(tiles[0]);
    blueTile = LoadImage(tiles[1]);
    greenTile = LoadImage(tiles[2]);
    purpleTile = LoadImage(tiles[3]);
    yellowTile = LoadImage(tiles[4]);
    
    tilesTextures[0] = redTile;
    tilesTextures[1] = blueTile;
    tilesTextures[2] = greenTile;
    tilesTextures[3] = purpleTile;
    tilesTextures[4] = yellowTile;
void LoadAssets::CleanUp()
    SDL_FreeSurface(background);
    SDL_FreeSurface(redTile);
    SDL_FreeSurface(blueTile);
    SDL_FreeSurface(greenTile);
    SDL_FreeSurface(purpleTile);
    SDL_FreeSurface(yellowTile);
    
    tilesTextures[0] = NULL;

/***************************************************************************
 *   Copyright 2007 Robert Gruber <rgruber@users.sourceforge.net>          *
 *   Copyright 2010 Milian Wolff <mail@milianw.de>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
EditRepository::EditRepository(SnippetRepository* repository, QWidget* parent)
    : KDialog(parent), Ui::EditRepositoryBase(), m_repo(repository)
    setButtons(/*Reset | */Apply | Cancel | Ok);
    setupUi(mainWidget());
    ma

    connect(this, SIGNAL(okClicked()), this, SLOT(save()));
    connect(this, SIGNAL(applyClicked()), this, SLOT(save()));
    connect(repoNameEdit, SIGNAL(textEdited(QString)), this, SLOT(validate()));
    KTextEditor::Document *document = KTextEditor::Editor::instance()->createDocument(0);
    repoFileTypesList->addItems(document->highlightingModes());
    repoFileTypesList->sortItems();
    repoFileTypesList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    connect(repoFileTypesList->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
            this, SLOT(updateFileTypes()));
    delete document;
    repoLicenseEdit->addItems(QStringList() << "Artistic" << "BSD" << "LGPL v2+" << "LGPL v3+");
    repoLicenseEdit->setEditable(true);
    if ( m_repo ) {
        repoNameEdit->setText(m_repo->text());
        repoAuthorsEdit->setText(m_repo->authors());
        repoNamespaceEdit->setText(m_repo->completionNamespace());
        if ( !m_repo->license().

            int index = repoLicenseEdit->findText(m_repo->license());
            if ( index == -1 ) {
                repoLicenseEdit->addItem(m_repo->license());
                repoLicenseEdit->model()->sort(0);
                index = repoLicenseEdit->findText(m_repo->license());
            }
            repoLicenseEdit->setCurrentIndex(index);
        }
        foreach ( const QString& type, m_repo->fileTypes() ) {
            foreach( QListWidgetItem* item, repoFileTypesList->findItems(type, Qt::MatchExactly) ) {
                item->setSelected(true);
            }
        }
        setWindowTitle(i18n("Edit Snippet Repository %1", m_repo->text()));
    } else {
        setWindowTitle(i18n("Create New Snippet Repository"));
        KUser user;
        repoAuthorsEdit->setText(user.property(KUser::FullName).toString());
    }
    validate();
    updateFileTypes();
    repoNameEdit->setFocus();
EditRepository::~EditRepository()
void EditRepository::validate()
    bool valid = !

    button(Ok)->setEnabled(valid);
    button(Apply)->setEnabled(valid);
void EditRepository::save()
    Q_ASSERT(!repoNameEdit->text().isEmpty());
    if ( !m_repo ) {
        m_repo = SnippetRepository::createRepoFromName(repoNameEdit->text());
    }
    m_repo->setText(repoNameEdit->text());
    m_repo->setAuthors(repoAuthorsEdit->text());
    m_repo->setLicense(repoLicenseEdit->currentText());
    m_repo->setCompletionNamespace(repoNamespaceEdit->text());
    QStringList types;
    foreach( QListWidgetItem* item, repoFileTypesList->selectedItems() ) {
        types << item->text();
    }
    m_repo->setFileTypes(types);
    m_repo->save();
    setWindowTitle(i18n("Edit Snippet Repository %1", m_repo->text()));
void EditRepository::updateFileTypes()
    QStringList types;
    foreach( QListWidgetItem* item, repoFileTypesList->selectedItems() ) {
        types << item->text();
    }
    if ( types.isEmpty() ) {
        repoFileTypesListLabel->setText(i18n("<i>leave empty for general
/* -*- Mode: C++; tab-width: 50; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
PRLogModuleInfo *gLoadManagerLog = nullptr;
namespace mozilla {
/* static */ StaticRefPtr<LoadManagerSingleton> LoadManagerSingleton::sSingleton;
NS_IMPL_ISUPPORTS(LoadManagerSingleton, nsIObserver)
LoadManagerSingleton::LoadManagerSingleton(int aLoadMeasurementInterval,
                                           int aAveragingMeasurements,
                                           float aHighLoadThreshold,
                                           float aLowLoadThreshold)
  : mLock("LoadManager"),
    mCurrentState(webrtc::kLoadNormal),
    mOveruseActive(false),
    mLoadSum(0.0f),
    mLoadSumMeasurements(0),
    mLoadMeasurementInterval(aLoadMeasurementInterval),
    mAveragingMeasurements(aAveragingMeasurements),
    mHighLoadThreshold(aHighLoadThreshold),
   

  if (!gLoadManagerLog)
    gLoadManagerLog = PR_NewLogModule("LoadManager");
  LOG(("LoadManager - Initializing (%dms x %d, %f, %f)",
       mLoadMeasurementInterval, mAveragingMeasurements,
       mHighLoadThreshold, mLowLoadThreshold));
  MOZ_ASSERT(mHighLoadThreshold > mLowLoadThreshold);
  mLoadMonitor = new LoadMonitor(mLoadMeasurementInterval);
  mLoadMonitor->Init(mLoadMonitor);
  mLoadMonitor->SetLoadChangeCallback(this);
LoadManagerSingleton::~LoadManagerSingleton()
  LOG(("LoadManager: shutting down LoadMonitor"));
  MOZ_ASSERT(!mLoadMonitor, "why wasn't the LoadMonitor shut down in xpcom-shutdown?");
  if (mLoadMonitor) {
    mLoadMonitor->Shutdown();
  }
nsresult
LoadManagerSingleton::Observe(nsISupports* aSubject, const char* aTopic,
                     const char16_t* aData)
  NS_ASSERTION(NS_IsMainThread(), "Observer invoked off the main thread");
  nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
  if (!strcmp(aTopic, "xpcom-shutdown")) {
    obs->R

    {
      MutexAutoLock lock(mLock);
      mObservers.Clear();
    }
    if (mLoadMonitor) {
      mLoadMonitor->Shutdown();
      mLoadMonitor = nullptr;
    }
    LOG(("Releasing LoadManager singleton and thread"));
    sSingleton = nullptr;
  }
  return NS_OK;
void
LoadManagerSingleton::LoadChanged(float aSystemLoad, float aProcesLoad)
  MutexAutoLock lock(mLock);
  mLoadSum += aSystemLoad;
  mLoadSumMeasurements++;
  if (mLoadSumMeasurements >= mAveragingMeasurements) {
    double averagedLoad = mLoadSum / (float)mLoadSumMeasurements;
    webrtc::CPULoadState oldState = mCurrentState;
    if (mOveruseActive || averagedLoad > mHighLoadThreshold) {
      LOG(("LoadManager - LoadStressed"));
      mCurrentState = webrtc::kLoadStressed;
    } else if (averagedLoad < mLowLoadThreshold) {
      LOG(("LoadManager - LoadRelaxed"));
      mCurrentState = webrtc::kLoadRelaxed;
    } else {
      LOG(("LoadManager - LoadNormal"));
      mCurrentState = webrtc::kLoadNormal;
    }
    if (ol

      LoadHasChanged();
    mLoadSum = 0;
    mLoadSumMeasurements = 0;
  }
void
LoadManagerSingleton::OveruseDetected()
  LOG(("LoadManager - Overuse Detected"));
  MutexAutoLock lock(mLock);
  mOveruseActive = true;
  if (mCurrentState != webrtc::kLoadStressed) {
    mCurrentState = webrtc::kLoadStressed;
    LoadHasChanged();
  }
void
LoadManagerSingleton::NormalUsage()
  LOG(("LoadManager - Overuse finished"));
  MutexAutoLock lock(mLock);
  mOveruseActive = false;
void
LoadManagerSingleton::LoadHasChanged()
  mLock.AssertCurrentThreadOwns();
  LOG(("LoadManager - Signaling LoadHasChanged to %d listeners", mObservers.Length()));
  for (size_t i = 0; i < mObservers.Length(); i++) {
    mObservers.ElementAt(i)->onLoadStateChanged(mCurrentState);
  }
void
LoadManagerSingleton::AddObserver(webrtc::CPULoadStateObserver * aObserver)
  LOG(("LoadManager - Adding Observer"));
  MutexAutoLock lock(mLock);
  mObservers.AppendElement(aObserver);
  if (mObservers.Length() == 1) {
    if (!mLo
int ChunkManager::CHUNK_LOAD_PER_FRAME = 1;
int ChunkManager::CHUNK_REBUILD_PER_FRAME = 3;
int ChunkManager::ACTIVE_CHUNKS_SIZE = 12;
ChunkManager::ChunkManager(GLRenderer* renderer)
	pRenderer = renderer;
	mGenerator = new TerrainGenerator();
	mGenerator->setAmplitude(2.0);
	mGenerator->setFrequency(1.0);
	mGenerator->setOctaves(1.5);
	lastCameraPos = glm::vec3(0,0,0);
	lastCameraDir = glm::vec3(0,0,0);
	low_x = low_z = low_z = 0;
	chunkList.reserve(1000);
	initializeChunks();
ChunkManager::~ChunkManager(void)
void ChunkManager::initializeChunks()
	float sizexz = ACTIVE_CHUNKS_SIZE;
	float sizey = TerrainChunk::TERRAIN_MAX_HEIGHT;
	for(int x = 0; x < ACTIVE_CHUNKS_SIZE; x++)
	{
		for(int z = 0; z < ACTIVE_CHUNKS_SIZE; z++)
		{
			TerrainChunk* terrainChunk = new TerrainChunk(this);
			std::vector<Chunk*> chunks;
			for(int y = 0; y < TerrainChunk::TERRAIN_MAX_HEIGHT; y++)
			{
				
				float percent = float(x)*sizexz*sizey + float(z)*sizey + y;
				percent = percent*100/(sizexz*sizexz

				printf("Initializing chunks: %.2f %% \r", percent);
				Chunk* chunk = new Chunk(this, glm::vec3(x,y,z));
				chunk->load();
				chunk->setup();
				chunks.push_back(chunk);
				chunkList.push_back(chunk);
				rebuildList.push_back(chunk);
			}
			terrainChunk->setColumn(chunks);
			terrainChunk->generateTerrain(mGenerator);
		}
	}
	printf("Initializing chunks: 100 %%      ");
	printf("\n");
void ChunkManager::update(float dt, Camera* camera)
	loadChunks();
	setupChunks();
	rebuildChunks();
	unloadChunks();
	updateVisibleChunks(camera);
	if(camera->getPos() != lastCameraPos || camera->getDir() != lastCameraDir)
	{
		updateRenderList();
	}
	renderChunks();
	lastCameraPos = camera->getPos();
	lastCameraDir = camera->getDir();
void ChunkManager::loadChunks()
	int numLoaded = 0;
	std::vector<Chunk*>::iterator it;
	for(it = loadList.begin(); it != loadList.end() && numLoaded != CHUNK_LOAD_PER_FRAME; ++it)
	{	
		Chunk* chunk = (*it);
		if(!chunk->isLoaded())
		{
			chunk->load();
			num

		}
	}
	loadList.clear();
void ChunkManager::setupChunks()
	std::vector<Chunk*>::iterator it;
	for(it = setupList.begin(); it != setupList.end(); ++it)
	{
		Chunk* chunk = (*it);
		if(!chunk->isSetup())
		{
			chunk->setup();
		}
	}
	setupList.clear();
void ChunkManager::rebuildChunks()
	int numRebuilt = 0;
	std::vector<Chunk*>::iterator it;
	for(it = rebuildList.begin(); it != rebuildList.end() && numRebuilt != CHUNK_REBUILD_PER_FRAME; ++it)
	{
		Chunk* chunk = (*it);
		if(chunk->isSetup() && chunk->isLoaded())
		{
		chunk->createMesh(pRenderer);
			
		/*glm::vec3 pos = chunk->getPos();
		int x = (int)pos.x;
		int y = (int)pos.y;
		int z = (int)pos.z;
		Chunk* x0 = getChunk(x-1,y  ,z  );
		Chunk* x1 = getChunk(x+1,y  ,z  );
		Chunk* y0 = getChunk(x  ,y-1,z  );
		Chunk* y1 = getChunk(x  ,y+1,z  );
		Chunk* z0 = getChunk(x  ,y  ,z-1);
		Chunk* z1 = getChunk(x  ,y  ,z+1);
			
		if(x0 != NULL)
			renderFlagList.push_back(x0);
		if(x1 != NULL)
			renderFlagList.push_back(x1);
		if(y0 != N

			renderFlagList.push_back(y0);
		if(y1 != NULL)
			renderFlagList.push_back(y1);
		if(z0 != NULL)
			renderFlagList.push_back(z0);
		if(z1 != NULL)
			renderFlagList.push_back(z0);
		*/
		++numRebuilt;
		}
	}
	rebuildList.clear();	
	for(it = chunkList.begin(); it != chunkList.end(); ++it)
	{
		Chunk* chunk = (*it);
		if(!(chunk->isBuilt()) || chunk->hasChanged())
			rebuildList.push_back(chunk);
	}
void ChunkManager::unloadChunks()
	std::vector<Chunk*>::iterator it;	
	for(it = unloadList.begin(); it != unloadList.end(); ++it)
	{
		if((*it)->isLoaded())
			(*it)->unload();
	}
	unloadList.clear();
void ChunkManager::updateRenderList()
	std::vector<Chunk*>::iterator it;
	renderList.clear();
	for(it = visibilityList.begin(); it != visibilityList.end(); ++it)
	{
		Chunk* chunk = (*it);
		if(chunk->isFlaggedForRender())
		{
			if(pRenderer->chunkInFrustum(chunk))
				renderList.push_back(chunk);
		}
	}
void ChunkManager::updateVisibleChunks(Camera* camera)
	visibilityList.clear();
	std::v

	for(it = chunkList.begin(); it != chunkList.end(); ++it)
	{
		Chunk* chunk = (*it);
		/*glm::vec3 pos = camera->getPos();
		float camera_x = pos.x;
		float camera_y = pos.y;
		float camera_z = pos.z;
		int chunk_x, chunk_y, chunk_z;
		getChunkCoordinates(camera_x, camera_y, camera_z, &chunk_x, &chunk_y, &chunk_z);*/
		visibilityList.push_back(chunk);
	}
void ChunkManager::renderChunks()
	std::vector<Chunk*>::iterator it;
	for(it = renderList.begin(); it != renderList.end(); ++it)
	{
		(*it)->render(pRenderer);
	}
	renderFlagList.clear();
Chunk* ChunkManager::getChunk(int x, int y, int z)
	int size = ChunkManager::ACTIVE_CHUNKS_SIZE;
	int index = (x-low_x) + (y-low_y)*size + (z-low_z)*size*size;
	if(index >= chunkList.size() || index < 0 )
		return NULL;
	return chunkList[index];
Block* ChunkManager::getBlock(int x, int y, int z)
	int sx, sy, sz, bx, by, bz;
	sx = 0; sy = 0; sz = 0;
	getChunkCoordinates(x, y, z, &sx, &sy, &sz);
	Chunk* chunk = getChunk(sx, sy, sz);
	int size = Chunk::
/*
 * File automatically generated by
 * gengen 1.0 by Lorenzo Bettini 
 */
void
reset_group_gen_class::generate_reset_group(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  stream << "static void";
  stream << "\n";
  stream << indent_str;
  stream << "reset_group_";
  generate_string (name, stream, indent + indent_str.length ());
  stream << "(struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info);";
  stream << "\n";
  stream << indent_str;
  stream << "\n";
  stream << indent_str;
  stream << "static void";
  stream << "\n";
  stream << indent_str;
  stream << "reset_group_";
  generate_string (name, stream, indent + indent_str.length ());
  stream << "(struct ";
  generate_string (args_info, stream, indent + indent_str.length ());
  stream << " *args_info)";
  stream << "\n";
  stream << indent_str;
  stream << "{";
  stream << "\n";
  stream << indent_str;
  if (multiple_arg)
    {
      st
namespace e
	SampleBuffer::SampleBuffer(uint channels /* = 2 */)
	{
		assert(channels > 0);
		this->buffer[0] = 0;
		this->buffer[1] = 0;
		this->offset = 0;
		this->sizeInBytes = 0;
		this->sampleInBuffer = 0;
		this->channels = channels;
		Capacity(32);
	}
	SampleBuffer::~SampleBuffer()
	{
		if (buffer[1])
		{
			delete[] buffer[1];
		}
		buffer[0] = buffer[1] = 0;
	}
	void SampleBuffer::SetChannels(uint channels)
	{
		assert(channels > 0);
		this->channels = channels;
		this->sampleInBuffer = (channels * sampleInBuffer) / channels;
	}
	void SampleBuffer::PutSamples(uint samples)
	{
		Capacity(sampleInBuffer + samples);
		sampleInBuffer += samples;
	}
	void SampleBuffer::PutSamples(const sample_t* samples, uint count)
	{
		memcpy(End(count), samples, sizeof(sample_t) * channels * count);
		sampleInBuffer += count;
	}
	void SampleBuffer::Capacity(uint capacity)
	{
		assert(capacity >= 0);
		if (capacity > GetCapacity())
		{
			sizeInBytes = (capacity * channels * sizeof(sample_t) + 40

			assert(sizeInBytes % 2 == 0);
			sample_t* ptr = new sample_t[sizeInBytes / sizeof(sample_t) + 16 / sizeof(sample_t)];
			if (ptr == 0) E_THROW("SampleBuffer realloc failed!!!");
			sample_t* aptr = (sample_t*)ALIGN_POINTER_16(ptr);
			if (sampleInBuffer)
			{
				memcpy(aptr, Begin(), sampleInBuffer * channels * sizeof(sample_t));
			}
			if (buffer[1]) delete[] buffer[1];
			buffer[0] = aptr;
			buffer[1] = ptr;
			offset = 0;
		}
		else
		{
			Rewind();
		}
	}
	uint SampleBuffer::GetCapacity(void) const
	{
		return sizeInBytes / (channels * sizeof(sample_t));
	}
	uint SampleBuffer::GetChannels(void) const
	{
		return channels;
	}
	uint SampleBuffer::GetSampleCount(void) const
	{
		return sampleInBuffer;
	}
	uint SampleBuffer::FetchSamples(uint n)
	{
		if (n >= sampleInBuffer)
		{
			uint temp = sampleInBuffer;
			sampleInBuffer = 0;
			return temp;
		}
		sampleInBuffer -= n;
		offset += n;
		return n;
	}
	uint SampleBuffer::FetchSamples(sample_t* samples, uint count)
	{
		uint n
using namespace std;
unsigned lfsr;
unsigned int footprint_size=0;
unsigned int dump[100];
int main(int argc, char** argv)
	unsigned int* data_chunk;
	lfsr=11;
    int level = 5;
    bool infinite;
    if (argc >=2){
        sscanf(argv[1], "%d", &level);
    }else{
        cerr<<"warning: default level = 5"<<endl;
    }
    if (argc >=3){
        infinite = true;
    }
    footprint_size = 1024*256*level;
	unsigned long x;
	x = powl(2,32);
	data_chunk = (unsigned *)malloc(x*sizeof(unsigned int));
    assert(data_chunk);
    for (int i = 0; i<15000000 || infinite; i++){
		dump[0]+=data_chunk[r]++;
		dump[1]+=data_chunk[r]++;
		dump[2]+=data_chunk[r]++;
		dump[3]+=data_chunk[r]++;
		dump[4]+=data_chunk[r]++;
		dump[5]+=data_chunk[r]++;
		dump[6]+=data_chunk[r]++;
		dump[7]+=data_chunk[r]++;
		dump[8]+=data_chunk[r]++;
		dump[9]+=data_chunk[r]++;
		dump[10]+=data_chunk[r]++;
		dump[11]+=data_chunk[r]++;
		dump[12]+=data_chunk[r]++;
		dump[13]+=data_chunk[r]++;
		dump[14]+=data_chunk[r]++

		dump[15]+=data_chunk[r]++;
		dump[16]+=data_chunk[r]++;
		dump[17]+=data_chunk[r]++;
		dump[18]+=data_chunk[r]++;
		dump[19]+=data_chunk[r]++;
		dump[20]+=data_chunk[r]++;
		dump[21]+=data_chunk[r]++;
		dump[22]+=data_chunk[r]++;
		dump[23]+=data_chunk[r]++;
		dump[24]+=data_chunk[r]++;
		dump[25]+=data_chunk[r]++;
		dump[26]+=data_chunk[r]++;
		dump[27]+=data_chunk[r]++;
		dump[28]+=data_chunk[r]++;
		dump[29]+=data_chunk[r]++;
		dump[30]+=data_chunk[r]++;
		dump[31]+=data_chunk[r]++;
		dump[32]+=data_chunk[r]++;
		dump[33]+=data_chunk[r]++;
		dump[34]+=data_chunk[r]++;
		dump[35]+=data_chunk[r]++;
		dump[36]+=data_chunk[r]++;
		dump[37]+=data_chunk[r]++;
		dump[38]+=data_chunk[r]++;
		dump[39]+=data_chunk[r]++;
		dump[40]+=data_chunk[r]++;
		dump[41]+=data_chunk[r]++;
		dump[42]+=data_chunk[r]++;
		dump[43]+=data_chunk[r]++;
		dump[44]+=data_chunk[r]++;
		dump[45]+=data_chunk[r]++;
		dump[46]+=data_chunk[r]++;
		dump[47]+=data_chunk[r]++;
		dump[48]+=data_chunk[r]++;
		dump[49]+=d

		dump[50]+=data_chunk[r]++;
		dump[51]+=data_chunk[r]++;
		dump[52]+=data_chunk[r]++;
		dump[53]+=data_chunk[r]++;
		dump[54]+=data_chunk[r]++;
		dump[55]+=data_chunk[r]++;
		dump[56]+=data_chunk[r]++;
		dump[57]+=data_chunk[r]++;
		dump[58]+=data_chunk[r]++;
		dump[59]+=data_chunk[r]++;
		dump[60]+=data_chunk[r]++;
		dump[61]+=data_chunk[r]++;
		dump[62]+=data_chunk[r]++;
		dump[63]+=data_chunk[r]++;
		dump[64]+=data_chunk[r]++;
		dump[65]+=data_chunk[r]++;
		dump[66]+=data_chunk[r]++;
		dump[67]+=data_chunk[r]++;
		dump[68]+=data_chunk[r]++;
		dump[69]+=data_chunk[r]++;
		dump[70]+=data_chunk[r]++;
		dump[71]+=data_chunk[r]++;
		dump[72]+=data_chunk[r]++;
		dump[73]+=data_chunk[r]++;
		dump[74]+=data_chunk[r]++;
		dump[75]+=data_chunk[r]++;
		dump[76]+=data_chunk[r]++;
		dump[77]+=data_chunk[r]++;
		dump[78]+=data_chunk[r]++;
		dump[79]+=data_chunk[r]++;
		dump[80]+=data_chunk[r]++;
		dump[81]+=data_chunk[r]++;
		dump[82]+=data_chunk[r]++;
		dump[83]+=data_chunk[r]++;
		dump[84]+=d
struct SampleRecord;
class SampleBin
private:
	std::vector<SampleRecord *> sample;
	char path[64];
public:
	SampleBin(const char *path="");
	~SampleBin();
	void set_path(const char *path);
	bool preload_sample(const char *filename);
	ALLEGRO_SAMPLE *get_sample(const char *filename);
	bool destroy_sample(const char *filename);
	void clear_samples();
	size_t size();
};
using std::vector;
struct SampleRecord
	char basename[64];
	ALLEGRO_SAMPLE *sample;
};
/**********************/
static const int SAMPLE_NO_INDEX = -1;
static ALLEGRO_SAMPLE *default_sample = NULL;
SampleBin *primary_sample_bin;
static inline bool sample_sort_algorithm(const SampleRecord *r1, const SampleRecord *r2)
	return (strncmp(r1->basename, r2->basename, 64)<0);
static inline void sort_samples(vector<SampleRecord *> &bin)
	std::sort(bin.begin(), bin.end(), sample_sort_algorithm);
static inline int get_index(vector<SampleRecord *> *bin, const char *basename)
	int first, last, mid, comp;
	if (bin->empty()) return SAMPLE

	first = 0;
	last = bin->size()-1;
	while (first <= last)
	{
		comp = strcmp(bin->at(mid)->basename, basename);
	}
	return SAMPLE_NO_INDEX;
static inline ALLEGRO_SAMPLE *load_sample(vector<SampleRecord *> *bin, const char *path, const char *basename, const char *extension=".ogg")
	bin->push_back(new SampleRecord());
	char full_filename[64];
	strcpy(bin->back()->basename, basename);
	strncpy(full_filename, path, 64);
	strncat(full_filename, basename, 64);
	strncat(full_filename, extension, 64);
	bin->back()->sample = al_load_sample(full_filename);
	if (!bin->back()->sample)
	{
		bin->back()->sample = default_sample;
	}
	else
	{
	}
	ALLEGRO_SAMPLE *img = bin->back()->sample;
	sort_samples(*bin);
	return img;
static bool create_default_sample();
static bool first_bin_created = false;
/**********************/
SampleBin::SampleBin(const char path[64])
	clear_samples();
	strcpy(this->path, path);
	if (!first_bin_created)
	{
		create_default_sample();
	}
	primary_sample_bin = this;
SampleBin

	clear_samples();
bool SampleBin::preload_sample(const char *basename)
	if (load_sample(&sample, path, basename) != default_sample) return true;
	return false;
ALLEGRO_SAMPLE *SampleBin::get_sample(const char *basename)
	int index = get_index(&sample, basename);
	if (index == SAMPLE_NO_INDEX) return load_sample(&sample, path, basename);
	return sample[index]->sample;
bool SampleBin::destroy_sample(const char *basename)
	int index = get_index(&sample, basename);
	if (index == SAMPLE_NO_INDEX) return false;
	if (sample[index]->sample != default_sample)
		al_destroy_sample(sample[index]->sample);
	sample.erase(sample.begin()+index);
	return true;
void SampleBin::clear_samples()
	for (int i=0; i<(int)sample.size(); i++)
		if (sample[i]->sample != default_sample)
			al_destroy_sample(sample[i]->sample);
	sample.clear();
size_t SampleBin::size()
	return sample.size();
/**********************/
static bool create_default_sample()
	if (default_sample) return true;
	default_sample = al_load_sam
/*
 *     SocialLedge.com - Copyright (C) 2013
 *
 *     This file is part of free software framework for embedded processors.
 *     You can use it and/or distribute it as long as this copyright header
 *     remains unmodified.  The code is free for personal use and requires
 *     permission to use in a commercial product.
 *
 *      THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 *      OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 *      MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 *      I SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
 *      CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 *     You can reach the author of this software at :
 *          p r e e t . w i k i @ g m a i l . c o m
 */
/**
 * @file
 * @brief Contains the terminal handler function declarations.
 *
 * 12082013 : Added I2C handler
 */
CMD_HANDLER_FUNC(taskListHandler);
CMD_HANDLER_FUNC(memInf
using std::string;
using std::vector;
using std::map;
ModelManager& ModelManager::get()
	static ModelManager singleton;
	return singleton;
ModelManager::~ModelManager()
	modelMap::iterator it = models.begin();
	for (; it != models.end(); ++it)
		delete it->second;
Model* ModelManager::getModel(const std::string &modelName)
	modelMap::iterator keyExists = models.find(modelName);
	if (keyExists == models.end())
	{
		luapath::Table modelsTable = luapath::LuaState("config/settings.lua").getGlobalTable("models");
		Model *newModel = new Model(modelsTable.getTable(string(".") + modelName));
		models.insert(std::pair<std::string, Model*>(modelName, newModel));
		return newModel;
	}
	else
	{ 
		return keyExists->second;
	}
SkinnedModel* ModelManager::getSkinnedModel(const std::string &modelName)
	modelMap::iterator keyExists = models.find(modelName);
	if (keyExists == models.end())
	{
		luapath::Table modelsTable = luapath::LuaState("config/settings.lua").getGlobalTable("skinnedModels");
		Ski
void BaseBookmarkModelObserver::Loaded(BookmarkModel* model,
                                       bool ids_reassigned) {
void BaseBookmarkModelObserver::BookmarkModelBeingDeleted(
    BookmarkModel* model) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeMoved(
    BookmarkModel* model,
    const BookmarkNode* old_parent,
    int old_index,
    const BookmarkNode* new_parent,
    int new_index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeAdded(BookmarkModel* model,
                                                  const BookmarkNode* parent,
                                                  int index) {
  BookmarkModelChanged();
void BaseBookmarkModelObserver::BookmarkNodeRemoved(BookmarkModel* model,
                                                    const BookmarkNode* parent,
                                                    int old_index,
                                                    const BookmarkNode* node) {
  Bookmar
namespace sanguis
namespace model
class object
	FCPPT_NONCOPYABLE(
		object
	);
public:
	SANGUIS_MODEL_SYMBOL
	object(
		sanguis::model::cell_size,
		sanguis::model::optional_animation_delay,
		sanguis::model::part_map &&,
		sanguis::model::optional_image_name const &
	);
	SANGUIS_MODEL_SYMBOL
	object(
		object &&
	);
	SANGUIS_MODEL_SYMBOL
	object &
	operator=(
		object &&
	);
	SANGUIS_MODEL_SYMBOL
	~object();
	SANGUIS_MODEL_SYMBOL
	sanguis::model::optional_animation_delay
	animation_delay() const;
	SANGUIS_MODEL_SYMBOL
	void
	animation_delay(
		sanguis::model::optional_animation_delay
	);
	SANGUIS_MODEL_SYMBOL
	sanguis::model::part &
	part(
		sanguis::model::part_name const &
	);
	SANGUIS_MODEL_SYMBOL
	sanguis::model::part const &
	part(
		sanguis::model::part_name const &
	) const;
	SANGUIS_MODEL_SYMBOL
	sanguis::model::part &
	operator[](
		sanguis::model::part_name const &
	);
	SANGUIS_MODEL_SYMBOL
	sanguis::model::part_map &
	parts();
	SANGUIS_MODEL_SYMBOL
	sanguis::model::part_ma
/*!
 * @brief å¨æ³¢æ°é åã§ã®è¤ç´ ç©ç®ãç©ºéé åã§ã®ç³ã¿è¾¼ã¿ã«ç¸å½ 
 * @param [] 
 */
int fr_multi(double *dest_r, double *dest_i, const double *src_r,const double *src_i, const double *filter_r, const double *filter_i,
	int sampleSize)
	for(int i=0 ; i < sampleSize ; i++)
	{
		dest_r[i] = src_r[i] * filter_r[i] + (src_i[i]*filter_i[i])*-1;
		dest_i[i] = src_r[i] * filter_i[i] + (src_i[i]*filter_r[i]);
	}	
	return SUCCESS;
/*!
 * @brief ç©ºéé åã§ã®ç³ã¿è¾¼ã¿
 * @param [] 
 */
int conv(double *dest_r, const double *src_r, const double *filter_r,
	int sampleSize)
	for(int i=0; i< sampleSize; i++)
	{
		dest_r[i] = 0;
		for(int j = 0; j < sampleSize ; j++)
		{
			int _j_i = (j - i) % sampleSize;
			dest_r[i] += src_r[i] * filter_r[_j_i];
		}
	}
	return SUCCESS;
/*!
 * @brief DFT
 * @param [] 
 */
int dft(double *dest_r, double *dest_i,
	const double *src_r, const double *src_i, 
	int sampleSize, bool inverse)
	double sum_re, sum_im, pi, arg, freqSample;
	int sample;
	int freq;
	if(dest_r == NULL || dest_i == NULL ||
		src_r ==
/**
*  Copyright (C) 2015 3D Repo Ltd
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*  You should have received a copy of the GNU Affero General Public License
*/
namespace repo {
namespace worker {
class RepoWorkerRoles : public RepoAbstractWorker
    Q_OBJECT
public:
    enum class Command { DROP, INSERT, UPDATE };
    RepoWorkerRoles(
            const repo::RepoController::RepoToken *token,
            repo::RepoController *controller,
            const std::string &database,
            const repo::core::model::RepoRole &ro
using namespace std;
View::View()
    m = new MainWindow();
    this->setGeometry(10,30,1060,700);
    this->insertWidget(0, m);
    this->show();
    load = new LoadCSV();
    this->insertWidget(1, load);
    verify = new VerifyCSV();
    this->insertWidget(2, verify);
    analyze = new AnalyzeCSV();
    this->insertWidget(3, analyze);
    connect(m, SIGNAL(gotoLoad(std::string)), this, SLOT(mainToLoad(std::string)));
    connect(load, SIGNAL(gotoVerify(CSVType)), this, SLOT(gotoVerify(CSVType)));
    connect(load, SIGNAL(gotoAnalyze(CSVType)), this, SLOT(gotoAnalyze(CSVType)));
    connect(load, SIGNAL(gotoAnalyze()), this, SLOT(gotoAnalyze()));
    connect(verify, SIGNAL(gotoLoad(ErrorType,CSVType)), this, SLOT(verToLoad(ErrorType,CSVType)));
    connect(verify, SIGNAL(gotoAnalyze(CSVType)), this, SLOT(gotoAnalyze(CSVType)));
    connect(analyze, SIGNAL(gotoLoad()), this, SLOT(gotoLoad()));
View::~View(){
    if(m != 0) delete m;
    if(load != 0) delete load;
    if(analyze != 0) d
/*
 * File automatically generated by
 * gengen 1.4.2 by Lorenzo Bettini 
 */
void
required_option_gen_class::generate_required_option(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (checkrange)
    {
      stream << "if (";
      generate_string (mode_condition, stream, indent + indent_str.length ());
      stream << "check_multiple_option_occurrences(";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_given, args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_min, args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_max, \"";
      generate_string (option_descr, stream, indent + indent_str.length ());
      stream << "\"))";
      stream << "\n";
      stream << 

      stream << "   error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "\n";
      stream << indent_str;
    }
  else
    {
      stream << "if (";
      generate_string (mode_condition, stream, indent + indent_str.length ());
      stream << "! args_info->";
      generate_string (option_var_name, stream, indent + indent_str.length ());
      stream << "_given)";
      stream << "\n";
      stream << indent_str;
      stream << "  {";
      stream << "\n";
      stream << indent_str;
      stream << "    fprintf (stderr, \"%s: ";
      generate_string (option_descr, stream, indent + indent_str.length ());
      stream << " option required%s\\n\", ";
      generate_string (package_var_name, stream, indent + indent_str.length ());
      stream << ", (additional_error ? additional_error : \"\"));";
      stream << "\n";
      stream << indent_str;
      stream << "    error = 1;";
      stream << "\n";
      stream << indent_str;
      stream << "  }";
      
namespace glm
	namespace virtrev_glmext
	{
		namespace xstream
		{
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec2<T> const & vec)
			{
				stream << "<glm_vec2 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec3<T> const & vec)
			{
				stream << "<glm_vec3 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec4<T> const & vec)
			{
				stream << "<glm_vec4 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "w=\"" << vec.w << "\" ";
				stream << "/>";
				return stream;
			}
			

			std::ostream & operator << (std::ostream & stream, glm::detail::tmat2x2<T> const & mat)
			{
				stream << "<glm_mat2>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat2>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat3x3<T> const & mat)
			{
				stream << "<glm_mat3>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << g

				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 2)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 2)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 2)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat3>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat4x4<T> const & mat)
			{
				stream << "<glm_mat4>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "w=\"" << glm::row(mat, 0)[3] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "w=\"" <<
class VectorUseSample
public:
	VectorUseSample();
	~VectorUseSample();
	void vector_constructor_sample();
	void vector_destructor_sample();
	void vector_assign_sample();
	void vector_at_sample();
	void vector_back_sample();
	void vector_begin_sample();
	void vector_capacity_sample();
	void vector_cbegin_sample();
	void vector_cend_sample();
	void vector_clear_sample();
	void vector_crbegin_sample();
	void vector_crend_sample();
	void vector_data_sample();
	void vector_emplace_sample();
	void vector_emplace_back_sample();
	void vector_empty_sample();
	void vector_end_sample();
	void vector_erase_sample();
	void vector_front_sample();
	void vector_get_allocator_sample();
	void vector_insert_sample();
	void vector_max_size_sample();
	void vector_operator_equal_sample();
	void vector_operator_brackets_sample();
	void vector_pop_back_sample();
	void vector_push_back_sample();
	void vector_rbegin_sample();
	void vector_rend_sample();
	void vector_reserve_sample();
	void vector_resize_sample(
namespace dy
    class Sample
    {
        public:
            enum value_type
            {
                data,
                dyll,
                dytt,
                wjets,
                ttdil,
                ttslq,
                tthad,
                qcdmu15,
                ww2l2nu,
                wz2l2q,
                wz3lnu,
                zz2l2nu,
                zz2l2q,
                zz4l,
                static_size
            };
            struct Info
            {
            };
            static void SetPsetPath(const std::string& pset_path);
            static const std::string& GetPsetPath();
            static const std::vector<dy::Sample::Info>& GetInfos();
    };
    bool operator < (const Sample::Info& s1, const Sample::Info& s2);
    std::ostream& operator << (std::ostream& out, const Sample::Info& sample_info);
    void PrintSampleInfos(std::ostream& out = std::cout);
    Sample::value_type GetSampleFromName(const std::string& sample_name);
  
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
namespace VM {
class Repo : public RepoProxy {
 private:
  static SimpleMutex s_lock;
  static unsigned s_nRepos;
 public:
  static Repo& get

  static bool prefork();
  static void postfork(pid_t pid);
  Repo();
  ~Repo();
  const char* dbName(int repoId) const {
    ASSERT(repoId < RepoIdCount);
    return kDbs[repoId];
  }
  sqlite3* dbc() const { return m_dbc; }
  int repoIdForNewUnit(UnitOrigin unitOrigin) const {
    switch (unitOrigin) {
    case UnitOriginFile:
      return m_localWritable ? RepoIdLocal : RepoIdCentral;
    case UnitOriginEval:
      return m_evalRepoId;
    default:
      ASSERT(false);
      return RepoIdInvalid;
    }
  }
  std::string repoName(int repoId) const {
    switch (repoId) {
    case RepoIdLocal: return m_localRepo;
    case RepoIdCentral: return m_centralRepo;
    default: return "?";
    }
  }
  UnitRepoProxy& urp() { return m_urp; }
  PreClassRepoProxy& pcrp() { return m_pcrp; }
  FuncRepoProxy& frp() { return m_frp; }
  static void setCliFile(const std::string& cliFile);
  Unit* loadUnit(const std::string& name, const MD5& md5);
  bool findFile(const char* path, const std::string& r

  void commitMd5(UnitOrigin unitOrigin, UnitEmitter *ue);
  RP_IOP(FileHash) \
  RP_GOP(FileHash)
  class InsertFileHashStmt : public RepoProxy::Stmt {
    public:
      InsertFileHashStmt(Repo& repo, int repoId) : Stmt(repo, repoId) {}
      void insert(RepoTxn& txn, const StringData* path, const MD5& md5);
  };
  class GetFileHashStmt : public RepoProxy::Stmt {
    public:
      GetFileHashStmt(Repo& repo, int repoId) : Stmt(repo, repoId) {}
      bool get(const char* path, MD5& md5);
  };
 public: \
 private: \
  RP_OPS
 public:
  std::string table(int repoId, const char* tablePrefix);
  void exec(const std::string& sQuery);
  void begin();
 private:
  void txPop();
 public:
  void commit();
  static const char* kSchemaId;
 private:
  static const char* kMagicProduct;
  static const char* kSchemaPlaceholder;
  static const char* kDbs[RepoIdCount];
  void connect();
  void disconnect();
  void initCentral();
  std::string insertSchema(const char* path);
  bool openCentral(const char
int samplesAdded = 0;
int patchSamplesAdded = 0;
static unsigned short g_PatchIterationKey = 0;
bool SampleData_CompareFunc( SampleData_t const &src1, SampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int SampleData_KeyFunc( SampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<SampleData_t> g_SampleHashTable( SAMPLEHASH_NUM_BUCKETS, 
										  SAMPLEHASH_GROW_SIZE, 
										  SAMPLEHASH_INIT_SIZE, 
										  SampleData_CompareFunc, SampleData_KeyFunc );
UtlHashHandle_t SampleData_Find( sample_t *pSample )
	SampleData_t sampleData;	
	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	return g_SampleHashTable.Find( sampleData );
UtlHashHandle_t SampleData_InsertIntoHashTable( sample_t *pSample, SampleHandle_t sampleHandle )
	Samp

	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	UtlHashHandle_t handle = g_SampleHashTable.AllocEntryFromKey( sampleData );
	SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
	pSampleData->x = sampleData.x;
	pSampleData->y = sampleData.y;
	pSampleData->z = sampleData.z;
	pSampleData->m_Samples.AddToTail( sampleHandle );
	samplesAdded++;
	return handle;
UtlHashHandle_t SampleData_AddSample( sample_t *pSample, SampleHandle_t sampleHandle )
	UtlHashHandle_t handle = SampleData_Find( pSample );
	if( handle == g_SampleHashTable.InvalidHandle() )
	{
		handle = SampleData_InsertIntoHashTable( pSample, sampleHandle );
	}
	else
	{
		SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
		pSampleData->m_Samples.AddToTail( sampleHandle );
		samplesAdded++;
	}
	return handle;
void SampleData_Log( void )
	if

	{
		g_SampleHashTable.Log( "samplehash.txt" );
	}
bool PatchSampleData_CompareFunc( PatchSampleData_t const &src1, PatchSampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int PatchSampleData_KeyFunc( PatchSampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<PatchSampleData_t>	g_PatchSampleHashTable( SAMPLEHASH_NUM_BUCKETS,
												    SAMPLEHASH_GROW_SIZE,
													SAMPLEHASH_INIT_SIZE,
													PatchSampleData_CompareFunc, PatchSampleData_KeyFunc );
void GetPatchSampleHashXYZ( const Vector &vOrigin, int &x, int &y, int &z )
	x = ( int )( vOrigin.x / SAMPLEHASH_VOXEL_SIZE );
	y = ( int )( vOrigin.y / SAMPLEHASH_VOXEL_SIZE );
	z = ( int )( vOrigin.z / SAMPLEHASH_VOXEL_SIZE );
unsigned short IncrementPatchIterationKey()
	if ( g_PatchIterationKey == 0xFFFF )
	{
		g_PatchIterationKey = 1;
		for ( int i=0; i < patches.Count(); i++ )
			patches[i].m_IterationKey = 0;
	}
	else
	{
		g_P

	}
	return g_PatchIterationKey;
void PatchSampleData_AddSample( patch_t *pPatch, int ndxPatch )
	int patchSampleMins[3], patchSampleMaxs[3];
	GetPatchSampleHashXYZ( pPatch->mins, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	GetPatchSampleHashXYZ( pPatch->maxs, patchSampleMaxs[0], patchSampleMaxs[1], patchSampleMaxs[2] );
	GetPatchSampleHashXYZ( pPatch->origin, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	memcpy( patchSampleMaxs, patchSampleMins, sizeof( patchSampleMaxs ) );
	Assert( patchSampleMins[0] <= patchSampleMaxs[0] && patchSampleMins[1] <= patchSampleMaxs[1] && patchSampleMins[2] <= patchSampleMaxs[2] );
	patchSampleMins[0] = MIN( patchSampleMins[0], patchSampleMaxs[0] );
	patchSampleMins[1] = MIN( patchSampleMins[1], patchSampleMaxs[1] );
	patchSampleMins[2] = MIN( patchSampleMins[2], patchSampleMaxs[2] );
	int iterateCoords[3];
	for ( iterateCoords[0]=patchSampleMins[0]; iterateCoords[0] <= patchSampleMaxs[0]; iterateCoords[0]++ )
	{
		for
class ChunkListTest : public CppUnit::TestFixture {
  CPPUNIT_TEST_SUITE(ChunkListTest);
  CPPUNIT_TEST(test_basic);
  CPPUNIT_TEST(test_get_release);
  CPPUNIT_TEST(test_blocking);
  CPPUNIT_TEST_SUITE_END();
public:
  void setUp() {}
  void tearDown() {}
  void test_basic();
  void test_get_release();
  void test_blocking();
};
torrent::Chunk* func_create_chunk(uint32_t index, int prot_flags);
uint64_t        func_free_diskspace(torrent::ChunkList* chunk_list);
void            func_storage_error(torrent::ChunkList* chunk_list, const std::string& message);
  torrent::ChunkManager* chunk_manager = new torrent::ChunkManager;     \
  torrent::ChunkList* chunk_list = new torrent::ChunkList;              \
  chunk_list->set_manager(chunk_manager);                               \
  chunk_list->slot_create_chunk() = tr1::bind(&func_create_chunk, tr1::placeholders::_1, tr1::placeholders::_2); \
  chunk_list->slot_free_diskspace() = tr1::bind(&func_free_diskspace, chunk_list); \
  chunk_list->
namespace glm
	namespace virtrev_glmext
	{
		namespace xstream
		{
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec2<T> const & vec)
			{
				stream << "<glm_vec2 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec3<T> const & vec)
			{
				stream << "<glm_vec3 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec4<T> const & vec)
			{
				stream << "<glm_vec4 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "w=\"" << vec.w << "\" ";
				stream << "/>";
				return stream;
			}
			

			std::ostream & operator << (std::ostream & stream, glm::detail::tmat2x2<T> const & mat)
			{
				stream << "<glm_mat2>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat2>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat3x3<T> const & mat)
			{
				stream << "<glm_mat3>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << g

				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 2)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 2)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 2)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat3>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat4x4<T> const & mat)
			{
				stream << "<glm_mat4>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "w=\"" << glm::row(mat, 0)[3] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "w=\"" <<
ChunkID CMSConnection4::getMapChunk(int channels, int size, const char *name)
  int thisChunk = ++chunkID;
  dprintln("getFMC channels=%d size=%d name=%s -> chunkID %d", channels, size, name, thisChunk);
  assert(size==1);
  for (int i=0;i<numChannels;i++)
    if (channels&(1<<i))
      fpages[i]->add(new CMSChunk4(thisChunk, size, name, new CBEOpaqueType("idl4_fpage_t", globals.word_size*2, globals.word_size), new CBEOpaqueType("idl4_fpage_t", globals.word_size*2, globals.word_size), channels, 1, CHUNK_XFER_COPY));
  
  return thisChunk;  
CASTStatement *CMSConnection4::assignFMCFpageToBuffer(int channel, ChunkID chunkID, CASTExpression *rvalue)
  CMSChunk4 *chunk;
  chunk = findChunk(fpages[channel], chunkID);
  if (chunk)
    return chunk->type->buildAssignment(
      new CASTBinaryOp(".",
        buildSourceBufferRvalue(channel),
        new CASTIdentifier(chunk->name)),
      rvalue
    );
    
  panic("Cannot assign FMC fpage to buffer (chunk %d in channel %d)", chunkID, channel)

  return NULL;
CASTStatement *CMSConnection4::assignFMCFpageFromBuffer(int channel, ChunkID chunkID, CASTExpression *rvalue)
  CMSChunk4 *chunk;
  chunk = findChunk(fpages[channel], chunkID);
  if (chunk)
    return chunk->type->buildAssignment(
      rvalue,
      new CASTBinaryOp(".",
        buildTargetBufferRvalue(channel),
        new CASTIdentifier(chunk->name))
    );
    
  panic("Cannot assign FMC fpage from buffer (chunk %d in channel %d)", chunkID, channel);
  return NULL;
CASTExpression *CMSConnection4::buildFMCFpageTargetExpr(int channel, ChunkID chunkID)
  CMSChunk4 *chunk;
  chunk = findChunk(fpages[channel], chunkID);
  if (chunk)
    {
      return new CASTBinaryOp(".",
        buildTargetBufferRvalue(channel),
        new CASTIdentifier(chunk->name)
      );    
    }
  panic("Cannot build FMC fpage target expression (chunk %d in channel %d)", chunkID, channel);
  return NULL;
CASTExpression *CMSConnection4::buildFMCFpageSourceExpr(int channel, ChunkID chunkID)
  CMS
/**
 * @file ClrSample.cpp
 * @brief implements of ClrSample class
 *
 * @author S.Tanaka
 * @date 2008.01.07
 * 
 * Copyright(C) 2006-2014 Eisai Co., Ltd. All rights reserved.
 */
using namespace kome::clr;
ClrSample::ClrSample( SampleSetWrapper^ sampleSet )
		: kome::objects::Sample( sampleSet == nullptr ? NULL : &( sampleSet->getSampleSet() ) ) {
ClrSample::~ClrSample() {
	ClrObjectPool::getInstance().removeSample( *this );
	m_baseSample = nullptr;
void ClrSample::setBaseSample( ClrSampleBase^ baseSample ) {
	m_baseSample = baseSample;
ClrSampleBase^ ClrSample::getBaseSample() {
	ClrSampleBase^ baseSample = m_baseSample;
	return baseSample;
void ClrSample::onDetectPeaksByAPI( kome::objects::Spectrum* spec, kome::objects::Peaks* peaks ) {
	ClrSampleBase^ baseSample = m_baseSample;
	if( baseSample == nullptr ) {
		return;
	}
	SpectrumWrapper^ s = ClrObjectTool::createSpectrumWrapper( spec );
	PeaksWrapper^ p = ClrObjectTool::createPeaksWrapper( peaks );
	baseSample->onDetectPeaksByAPI
OpenDDS::DCPS::RepoIdSet::~RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","~RepoIdSet",6);
void
OpenDDS::DCPS::RepoIdSet::serialize(TAO::DCPS::Serializer & serializer)
  DBG_ENTRY_LVL("RepoIdSet","serialize",6);
  CORBA::ULong sz = this->size ();
  serializer << sz;
  for (MapType::iterator itr = map_.begin();
    itr != map_.end();
    ++itr)
  {
    serializer << itr->first;
  }
bool
OpenDDS::DCPS::RepoIdSet::is_subset (RepoIdSet& map)
  DBG_ENTRY_LVL("RepoIdSet","is_subset",6);
  if (this->size () <= map.size () && this->size () > 0)
  {
    for (MapType::iterator itr = map_.begin();
      itr != map_.end();
      ++itr)
    {
      MapType::mapped_type* ientry;
      if (find(map.map_, itr->first, ientry) != 0)
        return false;
    }
    return true;
  }
  return false;
bool
OpenDDS::DCPS::RepoIdSet::exist (const RepoId& local_id,
                             bool& last)
  DBG_ENTRY_LVL("RepoIdSet","exist",6);
  last = true;
  RepoId remote;
  if (find(map_, local_id, remote) == -1)

/****************************************************************************
**
** Copyright (C) VCreate Logic Private Limited, Bangalore
**
** Use of this file is limited according to the terms specified by
** VCreate Logic Private Limited, Bangalore. Details of those terms
** of this file. This file may not be distributed without including the
** licence.txt file.
**
** Contact info@vcreatelogic.com if any conditions of this licensing are
** not clear to you.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/
DEFINE_VTK_OBJECT(CVtkLocator, CVtkObject, vtkLocator)
    pDesc->setNodeClassCategory("Rendering");
    pDesc->setNodeClassName("vtkLocator");
    pDesc->setCreateFunction(0);
    pDesc->setPropertyInfo("MaxLevel", "SetMaxLevel", "GetMaxLevel", QStringList() << "int", QStringList(), "void", "int

    pDesc->setPropertyInfo("Automatic", "SetAutomatic", "GetAutomatic", QStringList() << "bool", QStringList(), "void", "bool");
    pDesc->setPropertyInfo("Tolerance", "SetTolerance", "GetTolerance", QStringList() << "double", QStringList(), "void", "double");
    
    pDesc->addConnectionPath(
        new CVtkObjectConnectionPath("DataSet", IVisSystemNodeConnectionPath::InputPath, "vtkDataSet", 0)
        );
    pDesc->addConnectionPath(
        new CVtkObjectConnectionPath("Locator", IVisSystemNodeConnectionPath::OutputPath, "vtkLocator", 0)
        );
CVtkLocator::CVtkLocator() : m_vtkLocator(0)
    CVtkLocator::InitializeObjectDesc();
CVtkLocator::~CVtkLocator()
void CVtkLocator::setMaxLevel(int level)
    m_vtkLocator->SetMaxLevel(level);
int CVtkLocator::maxLevel() const
    return m_vtkLocator->GetMaxLevel();
int CVtkLocator::level() const
    return m_vtkLocator->GetLevel();
void CVtkLocator::setAutomatic(bool val)
    m_vtkLocator->SetAutomatic(val);
bool CVtkLocator::isAuto

    return m_vtkLocator->GetAutomatic();
void CVtkLocator::setTolerance(double val)
    m_vtkLocator->SetTolerance(val);
double CVtkLocator::tolerance() const
    return m_vtkLocator->GetTolerance();
void CVtkLocator::buildLocator()
    if(m_vtkLocator->GetDataSet())
        m_vtkLocator->BuildLocator();
void CVtkLocator::command_BuildLocator()
    if(m_vtkLocator->GetDataSet())
        m_vtkLocator->BuildLocator();
bool CVtkLocator::hasInput(IVisSystemNodeConnectionPath* path)
    if(!path)
        return false;
    if(path->pathName() == "DataSet")
    {
        return m_vtkLocator->GetDataSet();
    }
    return false;
bool CVtkLocator::setInput(IVisSystemNodeConnectionPath* path, IVisSystemNodeIOData* inputData)
    if(!path || !inputData)
        return false;
    if(path->pathName() == "DataSet")
    {
        IVtkDataSetIOData* data = 0;
        bool success = inputData->queryInterface("IVtkDataSetIOData", (void**)&data);
        if(success && data)
        {
            m_vtkL

            return true;
        }
    }
    return false;
bool CVtkLocator::removeInput(IVisSystemNodeConnectionPath* path, IVisSystemNodeIOData* inputData)
    if(!path || !inputData)
        return false;
    if(path->pathName() == "DataSet")
    {
        IVtkDataSetIOData* data = 0;
        bool success = inputData->queryInterface("IVtkDataSetIOData", (void**)&data);
        if(success && data && data->getVtkDataSet() == m_vtkLocator->GetDataSet())
        {
            m_vtkLocator->SetDataSet(0);
            return true;
        }
    }
    return false;
bool CVtkLocator::fetchOutput(IVisSystemNodeConnectionPath* path, IVisSystemNodeIOData** outputData)
    if(!path || !outputData)
        return false;
    if(path->pathName() == "Locator")
    {
        m_locatorData.setLocator(m_vtkLocator);
        *outputData = &m_locatorData;
        return true;
    }
    return false;
bool CVtkLocator::outputDerefed(IVisSystemNodeConnectionPath* path, IVisSystemNodeIOData* outputData)
  
/* Copyright (c) 2010 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
namespace RAMCloud {
class ServiceLocatorTest : public ::testing::Test {
/**
 * Assert the service locator string parses with the right number of protocols
 * and options.
 */
    EXPECT_EQ(numOptions, ServiceLocator(string).o

/**
 * Make sure the service locator string doesn't parse.
 */
    EXPECT_THROW(ServiceLocator(string), \
                         ServiceLocator::BadServiceLocatorException)
  public:
    ServiceLocatorTest() {}
};
TEST_F(ServiceLocatorTest, usageExample) {
    ServiceLocator sl("fast+udp: host=example.org, port=8081");
    EXPECT_EQ("fast+udp", sl.getProtocol());
    EXPECT_EQ("example.org", sl.getOption("host"));
    EXPECT_EQ(8081, sl.getOption<uint16_t>("port"));
    EXPECT_EQ(0x8001, sl.getOption<uint16_t>("etherType", 0x8001));
TEST_F(ServiceLocatorTest, BadServiceLocatorException_constructor) {
    ServiceLocator::BadServiceLocatorException e(HERE, "o", "r");
    EXPECT_EQ("The ServiceLocator string 'o' could not be "
                            "parsed, starting at 'r'", e.message);
    EXPECT_EQ("o", e.original);
    EXPECT_EQ("r", e.remaining);
TEST_F(ServiceLocatorTest, NoSuchKeyException_constructor) {
    ServiceLocator::NoSuchKeyException e(HERE, "k");
    EXPECT_EQ("Th

                            "ServiceLocator.", e.message);
    EXPECT_EQ("k", e.key);
TEST_F(ServiceLocatorTest, parseServiceLocators_goodInput) {
    std::vector<ServiceLocator> locators =
        ServiceLocator::parseServiceLocators("fast: ; tcp: port=3;x:");
    EXPECT_EQ(3U, locators.size());
    EXPECT_EQ("fast:", locators.at(0).getOriginalString());
    EXPECT_EQ("tcp: port=3", locators.at(1).getOriginalString());
    EXPECT_EQ("x:", locators.at(2).getOriginalString());
TEST_F(ServiceLocatorTest, parseServiceLocators_badInput) {
    std::vector<ServiceLocator> locators;
    EXPECT_THROW(
        locators =
            ServiceLocator::parseServiceLocators("fast: ; tcp: port=3;!"),
        ServiceLocator::BadServiceLocatorException);
    EXPECT_EQ(0U, locators.size());
TEST_F(ServiceLocatorTest, constructor) {
    string s("fast+udp: host=example.org, port=8081, port=8082");
    ServiceLocator sl(s);
    EXPECT_EQ(s, sl.originalString);
    EXPECT_EQ("fast+udp", sl.getProtocol());

    EXPECT_EQ("example.org", sl.getOption("host"));
    EXPECT_EQ("8082", sl.getOption("port"));
    CONSTRUCTOR_OK(0U, "fast: ;");
    CONSTRUCTOR_BAD("fast: ; slow: ;");
TEST_F(ServiceLocatorTest, init_branches) {
    CONSTRUCTOR_BAD("!");
        ServiceLocator sl("foo:;");
        EXPECT_EQ("foo:", sl.getOriginalString());
    }
        ServiceLocator sl("foo:");
        EXPECT_EQ("foo:", sl.getOriginalString());
    }
    CONSTRUCTOR_BAD("foo:!");
        ServiceLocator sl("foo: x=y;");
        EXPECT_EQ("foo: x=y", sl.getOriginalString());
        EXPECT_EQ("y", sl.getOption("x"));
    }
        ServiceLocator sl("foo: x=y");
        EXPECT_EQ("foo: x=y", sl.getOriginalString());
        EXPECT_EQ("y", sl.getOption("x"));
    }
        ServiceLocator sl("foo: x=");
        EXPECT_EQ("", sl.getOption("x"));
    }
        ServiceLocator sl("foo: x=\",\\\";\"");
        EXPECT_EQ("foo: x=\",\\\";\"", sl.getOriginalString());
        EXPECT_EQ(",\";", sl.getOption("x"));
    }
     

        EXPECT_EQ("foo: x=\\,\\\"\\;", sl.getOriginalString());
        EXPECT_EQ(",\";", sl.getOption("x"));
    }
        ServiceLocator sl("  foo:x=y  ");
        EXPECT_EQ("foo:x=y", sl.getOriginalString());
    }
TEST_F(ServiceLocatorTest, init_goodInput) {
    CONSTRUCTOR_OK(0U, "fast:");
    CONSTRUCTOR_OK(2U, " fast : x = y , z = \"a\" , ");
    CONSTRUCTOR_OK(1U, "fast: x=\"=\\\",\"");
    CONSTRUCTOR_OK(0U, "fast+udp:");
    CONSTRUCTOR_OK(0U, "3fast+udp_V4:");
    CONSTRUCTOR_OK(1U, "fast: 3x_Y7=2");
    CONSTRUCTOR_OK(1U, "fast: port=");
TEST_F(ServiceLocatorTest, init_badInput) {
    CONSTRUCTOR_BAD("fast");
    CONSTRUCTOR_BAD("fast: x");
    CONSTRUCTOR_BAD("fast ,");
    CONSTRUCTOR_BAD("fast x,");
    CONSTRUCTOR_BAD("fast: x=y,y");
    CONSTRUCTOR_BAD("fast + udp: ");
TEST_F(ServiceLocatorTest, init_escapingControl) {
    ServiceLocator sl("fast: a=\\\"\\,\\\", b=\"\\\"\"");
    EXPECT_EQ("\",\"", sl.getOption("a"));
    EXPECT_EQ("\"", sl.getOption("b"));
TEST_F(Ser

    ServiceLocator sl("fast: a=\\x, b=\"\\x\"");
    EXPECT_EQ("\\x", sl.getOption("a"));
    EXPECT_EQ("\\x", sl.getOption("b"));
TEST_F(ServiceLocatorTest, getOptionCastNoDefault) {
    ServiceLocator sl("fast: host=example.org, port=8081");
    EXPECT_THROW(sl.getOption<uint8_t>("foo"),
                 ServiceLocator::NoSuchKeyException);
    EXPECT_EQ(8081, sl.getOption<uint16_t>("port"));
    EXPECT_THROW(sl.getOption<uint8_t>("port"),
                            boost::bad_lexical_cast);
TEST_F(ServiceLocatorTest, getOptionCastDefault) {
    ServiceLocator sl("fast: host=example.org, port=8081");
    EXPECT_EQ(7, sl.getOption<uint8_t>("foo", 7));
    EXPECT_EQ(8081, sl.getOption<uint16_t>("port", 0));
    EXPECT_THROW(sl.getOption<uint8_t>("port", 4),
                 boost::bad_lexical_cast);
TEST_F(ServiceLocatorTest, getOptionNoCastNoDefault) {
    ServiceLocator sl("fast: host=example.org, port=8081");
    EXPECT_THROW(sl.getOption("foo"),
                 ServiceLocator::N

    EXPECT_EQ("8081", sl.getOption("port"));
TEST_F(ServiceLocatorTest, getOptionNoCastDefault) {
    ServiceLocator sl("fast: host=example.org, port=8081");
    EXPECT_EQ("7", sl.getOption("foo", "7"));
    EXPECT_STREQ("8081", sl.getOption("port", "0"));
TEST_F(ServiceLocatorTest, getOptionCStrNoDefault) {
    ServiceLocator sl("fast: host=example.org, port=8081");
    EXPECT_THROW(sl.getOption<const char*>("foo"),
                 ServiceLocator::NoSuchKeyException);
    EXPECT_STREQ("8081", sl.getOption<const char*>("port"));
TEST_F(ServiceLocatorTest, getOptionCStrDefault) {
    ServiceLocator sl("fast: host=example.org, port=8081");
    EXPECT_EQ("7", sl.getOption<const char*>("foo", "7"));
    EXPECT_STREQ("8081", sl.getOption<const char*>("port", "0"));
TEST_F(ServiceLocatorTest, hasOption) {
    ServiceLocator sl("cat: meow=1");
    EXPECT_TRUE(sl.hasOption("meow"));
    EXPECT_FALSE(sl.hasOption("moo"));
TEST_F(ServiceLocatorTest, assignmentOperator) {
    ServiceLocator sl(
extern "C" {
class SoundVolumeModelTestSuite : public testing::Test {
	protected:
	virtual void SetUp() {
		SoundVolumeModel *model = (SoundVolumeModel *)malloc(sizeof(SoundVolumeModel));
		model->system = 9;
		model->notification = 9;
		model->alarm = 9;
		model->ringtone = 9;
		model->media = 9;
		model->voice = 9;
		sound_volume_model_set_current_volumes(model);
		free(model);
	}
	virtual void TearDown() {
	}
};
static void
check_volumes(SoundVolumeModel *model, int system, int notification, int alarm, int ringtone, int media, int voice) {
	ASSERT_EQ(model->system, system);
	ASSERT_EQ(model->notification, notification);
	ASSERT_EQ(model->alarm, alarm);
	ASSERT_EQ(model->ringtone, ringtone);
	ASSERT_EQ(model->media, media);
	ASSERT_EQ(model->voice, voice);
TEST_F(SoundVolumeModelTestSuite, test_sound_volume_model_get) {
	SoundVolumeModel *model = sound_volume_model_get_current_volumes_n();
	check_volumes(model, 9, 9, 9, 9, 9, 9);
	free(model);
TEST_F(SoundVolumeModelTestSuite, test_s
World::World(int p, int q)
    this->p = p;
    this->q = q;
    
    /*push_back(new Chunk(p, q));
    Chunk* chunk = (*this)[this->size()-1];
    
    genChunkBuffer(chunk);*/
Chunk* World::getChunk(int p, int q)
    return 0;
void World::dirtyChunk(Chunk *chunk)
    chunk->dirty = 1;
    if (hasLights(chunk))
    {
        for (int dp = -1; dp <= 1; dp++)
        {
            for (int dq = -1; dq <= 1; dq++)
            {
                Chunk *other = findChunk(chunk->p + dp, chunk->q + dq);
                if (other)
                    other->dirty = 1;
            }
        }
    }
void World::genChunkBuffer(Chunk *chunk)
    chunk->compute();
    chunk->generate();
    chunk->empty();
    chunk->dirty = 0;
int World::hasLights(Chunk *chunk)
    if (!SHOW_LIGHTS)
        return 0;
    for (int dp = -1; dp <= 1; dp++)
    {
        for (int dq = -1; dq <= 1; dq++)
        {
            Chunk *other = chunk;
            if (dp || dq)
                other = findChunk(chunk->p + d

            if (!other)
                continue;
            Map *map = other->lights;
            if (map->size)
                return 1;
        }
    }
    return 0;
Chunk *World::findChunk(int p, int q)
    for (int i = 0; i < size(); i++)
    {
        Chunk *chunk = (*this)[i];
        if (chunk->p == p && chunk->q == q)
            return chunk;
    }
    return 0;
Chunk *World::requestChunk(int &best_score, int &best_a, int &best_b)
    float planes[6][4];
    Chunk *chunk;
    Model* model = Engine::getInstance()->getModel();
    int r = model->create_radius;
    for (int dp = -r; dp <= r; dp++)
    {
        for (int dq = -r; dq <= r; dq++)
        {
            int a = p + dp;
            int b = q + dq;
            chunk = model->chunks->findChunk(a, b);
            if ( (chunk && !chunk->dirty) )
                continue;
            if( (chunk && chunk->busy) )
                continue;
            int distance = MAX(ABS(dp), ABS(dq));
            int invisible = !mode
/*
 Title: LoadCell.h
  Author/Date: gNSortino@yahoo.com / 2014-07-26
  Description: This library will take the input from an 
    FC22 MSI Load Cell (0.5V - 4.5V) and convert it into lbf
	configuration inputs:
		inV:
			the supply voltage (should be 5 volts)
		noLoadCalcV:
			the no load calculated voltage
		loadMassV:
			the full load mass voltage
		loadMassLBF:
			the full load mass in pounds force
	measurement input:
		loadCellAnalogIn:
	output:
		mass:
			outputs the calculated mass given the aforementioned
			inputs.
    Note that this library will not setup any pins. It
	is expected that these will be defined by the calling 
	program.
	Change Log:
		GNS 2014-07-26: initial version
*/
/*
	Calibration parameters for the load cell
*/
LoadCell::LoadCell(float inV, float noLoadCalcV, float loadMassV, float loadMassLBF)
	_ratiometricScaleFactor = (inV / 5.0);
	_calibratedSpan = (loadMassV / loadMassLBF) * _ratiometricScaleFactor;
	_noLoadCalcV = noLoadCalcV;
/*
	Load cell voltage is a
/***********************************************************************
LocatorToolAdapter - Adapter class to connect a generic locator tool to
application functionality.
Copyright (c) 2004-2010 Oliver Kreylos
This file is part of the Virtual Reality User Interface Library (Vrui).
The Virtual Reality User Interface Library is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
The Virtual Reality User Interface Library is distributed in the hope
that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along
with the Virtual Reality User Interface Library; if not, write to the
Free Software Foundation, Inc., 59 Temple

02111-1307 USA
***********************************************************************/
namespace Vrui {
/***********************************
Methods of class LocatorToolAdapter:
***********************************/
LocatorToolAdapter::LocatorToolAdapter(LocatorTool* sTool)
	:tool(sTool)
	{
	/* Register functions with the locator tool: */
	tool->setStoreStateFunction(Misc::createFunctionCall(this,&LocatorToolAdapter::storeState));
	tool->setGetNameFunction(Misc::createFunctionCall(this,&LocatorToolAdapter::getName));
	/* Register callbacks with the locator tool: */
	tool->getMotionCallbacks().add(this,&LocatorToolAdapter::motionCallback);
	tool->getButtonPressCallbacks().add(this,&LocatorToolAdapter::buttonPressCallback);
	tool->getButtonReleaseCallbacks().add(this,&LocatorToolAdapter::buttonReleaseCallback);
	}
LocatorToolAdapter::~LocatorToolAdapter(void)
	{
	/* Unregister functions from the locator tool: */
	tool->setStoreStateFunction(0);
	tool->setGetNameFunction(0);
	/* Unregist
struct InterfaceActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct InterfaceFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct InterfaceActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
	

		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R, typename T1>
struct InterfaceFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct InterfaceActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct InterfaceFuncInvoker2
	typede

	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3>
struct InterfaceActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct InterfaceFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface

	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct InterfaceActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct InterfaceFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvo

		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp::vm::Runtime::GetInterfaceInvokeData (slot, declaringInterface, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct InterfaceFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, Il2CppClass* declaringInterface, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5
namespace net {
namespace {
TEST(LoadLogTest, Nullable) {
  LoadLog::BeginEvent(NULL, LoadLog::TYPE_HOST_RESOLVER_IMPL);
  LoadLog::AddEvent(NULL, LoadLog::TYPE_HOST_RESOLVER_IMPL);
  LoadLog::EndEvent(NULL, LoadLog::TYPE_HOST_RESOLVER_IMPL);
TEST(LoadLogTest, Basic) {
  scoped_refptr<LoadLog> log(new LoadLog(10));
  EXPECT_EQ(0u, log->entries().size());
  EXPECT_EQ(0u, log->num_entries_truncated());
  log->Add(LoadLog::Entry(MakeTime(0),
                          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                         LoadLog::PHASE_BEGIN)));
  log->Add(LoadLog::Entry(MakeTime(2),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  log->Add(
      LoadLog::Entry(
          MakeTime(11),
          LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                         LoadLog::PHASE_END)));
  EXPECT_EQ(3u, log->entries().size());
  EXPECT_EQ(0u, log->num

  ExpectLogContains(log, 0, MakeTime(0), LoadLog::TYPE_HOST_RESOLVER_IMPL,
                    LoadLog::PHASE_BEGIN);
  ExpectLogContains(log, 1, MakeTime(2), LoadLog::TYPE_CANCELLED,
                    LoadLog::PHASE_NONE);
  ExpectLogContains(log, 2, MakeTime(11),
                    LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTART,
                    LoadLog::PHASE_END);
TEST(LoadLogTest, Truncation) {
  size_t kMaxNumEntries = 10;
  scoped_refptr<LoadLog> log(new LoadLog(kMaxNumEntries));
  for (size_t i = 0; i < kMaxNumEntries; ++i) {
    log->Add(LoadLog::Entry(MakeTime(i),
                            LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                           LoadLog::PHASE_NONE)));
  }
  EXPECT_EQ(kMaxNumEntries, log->entries().size());
  EXPECT_EQ(0u, log->num_entries_truncated());
  ExpectLogContains(log, 9, MakeTime(9),
                    LoadLog::TYPE_CANCELLED,
                    LoadLog::PHASE_NONE);
  log->Add(LoadLog::Entry(MakeTime(0),
    

                                         LoadLog::PHASE_NONE)));
  log->Add(LoadLog::Entry(MakeTime(1),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  log->Add(LoadLog::Entry(MakeTime(2),
                          LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                         LoadLog::PHASE_NONE)));
  EXPECT_EQ(kMaxNumEntries, log->entries().size());
  EXPECT_EQ(3u, log->num_entries_truncated());
  ExpectLogContains(log, 9, MakeTime(2),
                    LoadLog::TYPE_CANCELLED,
                    LoadLog::PHASE_NONE);
TEST(LoadLogTest, Append) {
  scoped_refptr<LoadLog> log1(new LoadLog(10));
  scoped_refptr<LoadLog> log2(new LoadLog(10));
  log1->Add(LoadLog::Entry(MakeTime(0),
                           LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                          LoadLog::PHASE_BEGIN)));
  log2->Add(LoadLog::Entry(MakeTime(3),
                    

                                          LoadLog::PHASE_NONE)));
  log2->Add(LoadLog::Entry(MakeTime(9),
                           LoadLog::Event(LoadLog::TYPE_HOST_RESOLVER_IMPL,
                                          LoadLog::PHASE_END)));
  log1->Append(log2);
  log2->Add(LoadLog::Entry(MakeTime(19),
                           LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                          LoadLog::PHASE_NONE)));
  EXPECT_EQ(3u, log1->entries().size());
  EXPECT_EQ(0u, log1->num_entries_truncated());
  ExpectLogContains(log1, 0, MakeTime(0), LoadLog::TYPE_HOST_RESOLVER_IMPL,
                    LoadLog::PHASE_BEGIN);
  ExpectLogContains(log1, 1, MakeTime(3), LoadLog::TYPE_CANCELLED,
                    LoadLog::PHASE_NONE);
  ExpectLogContains(log1, 2, MakeTime(9), LoadLog::TYPE_HOST_RESOLVER_IMPL,
                    LoadLog::PHASE_END);
TEST(LoadLogTest, AppendWithTruncation) {
  size_t kMaxNumEntries = 10;
  scoped_refptr<LoadLog> log1(new LoadLog(kMaxNumE

  scoped_refptr<LoadLog> log2(new LoadLog(kMaxNumEntries));
  for (size_t i = 0; i < 6; ++i) {
    log1->Add(LoadLog::Entry(MakeTime(i),
                             LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                            LoadLog::PHASE_NONE)));
    log2->Add(LoadLog::Entry(MakeTime(2 * i),
                             LoadLog::Event(LoadLog::TYPE_CANCELLED,
                                            LoadLog::PHASE_NONE)));
  }
  log1->Append(log2);
  EXPECT_EQ(10u, log1->entries().size());
  EXPECT_EQ(2u, log1->num_entries_truncated());
  ExpectLogContains(log1, 9, MakeTime(10), LoadLog::TYPE_CANCELLED,
                    LoadLog::PHASE_NONE);
TEST(LoadLogTest, EventTypeToString) {
  EXPECT_STREQ("HOST_RESOLVER_IMPL",
               LoadLog::EventTypeToString(LoadLog::TYPE_HOST_RESOLVER_IMPL));
  EXPECT_STREQ("HOST_RESOLVER_IMPL_OBSERVER_ONSTART",
               LoadLog::EventTypeToString(
                  LoadLog::TYPE_HOST_RESOLVER_IMPL_OBSERVER_ONSTA
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoBoundingBox::RepoBoundingBox(const aiMesh * mesh)
	if (mesh->mNumVertices)
	{
        min = RepoVertex(mesh->mVertices[0]);
        max = RepoVertex(mesh->mVertices[0]);
	}
	for (unsigned int i = 0; i < mesh->mNumVertices; ++i)
	{
        RepoVertex tmp = RepoVertex(mesh->mVertices[i]);
		min.x = std::min(min.x,tmp.x);
		min.y = std:

		min.z = std::min(min.z,tmp.z);
		max.x = std::max(max.x,tmp.x);
		max.y = std::max(max.y,tmp.y);
		max.z = std::max(max.z,tmp.z);
	}
repo::core::RepoBoundingBox::RepoBoundingBox(const std::vector<RepoVertex> &vertices)
    if (vertices.size())
    {
        min = vertices[0];
        max = vertices[0];
    }
    for (unsigned int i = 0; i < vertices.size(); ++i)
    {
        aiVector3D tmp = vertices[i];
        min.x = std::min(min.x,tmp.x);
        min.y = std::min(min.y,tmp.y);
        min.z = std::min(min.z,tmp.z);
        max.x = std::max(max.x,tmp.x);
        max.y = std::max(max.y,tmp.y);
        max.z = std::max(max.z,tmp.z);
    }
bool repo::core::RepoBoundingBox::operator==(const RepoBoundingBox& other) const
    return this->getMin() == other.getMin() &&
            this->getMax() == other.getMax();
std::vector<aiVector3D> repo::core::RepoBoundingBox::toVector() const
    std::vector<aiVector3D> vec;
	vec.push_back(min);
	vec.push_back(max);
	return vec;
void repo::core:

	std::vector<aiVector2t<float>> * vec) const
	vec->push_back(aiVector2t<float>(min.x, min.y));
	vec->push_back(aiVector2t<float>(max.x, min.y));
	vec->push_back(aiVector2t<float>(max.x, max.y));
	vec->push_back(aiVector2t<float>(min.x, max.y));
std::vector<double> repo::core::RepoBoundingBox::getTransformationMatrix() const
    std::vector<double> transformation(16);
    RepoVertex centroid = RepoVertex(max+min);
    transformation[0] = 1;
    transformation[1] = 0;
    transformation[2] = 0;
    transformation[3] = 0;
    transformation[4] = 0;
    transformation[5] = 1;
    transformation[6] = 0;
    transformation[7] = 0;
    transformation[8] = 0;
    transformation[9] = 0;
    transformation[10] = 1;
    transformation[11] = 0;
    transformation[12] = centroid.x/2;
    transformation[13] = centroid.y/2;
    transformation[14] = centroid.z/2;
    transformation[15] = 1;
    return transformation;
aiMatrix4x4 repo::core::RepoBoundingBox::getTranslationMatrix() const
    RepoVertex
namespace xtal{
void expand_simple_dynamic_pointer_array(void* abegin, void* aend, void* acurrent, int addsize){
	void*** begin = (void***)abegin;
	void*** end = (void***)aend;
	void*** current = (void***)acurrent;
	uint_t size = (uint_t)(*end-*begin);
	uint_t newsize = size+addsize;
	void** newbegin=(void**)xmalloc(sizeof(void*)*newsize);
	std::memcpy(newbegin, *begin, sizeof(void*)*size);
	*end = newbegin+newsize;
	*current = newbegin+(*current-*begin);
	xfree(*begin, sizeof(void*)*size);
	*begin = newbegin;	
void fit_simple_dynamic_pointer_array(void* abegin, void* aend, void* acurrent){
	void*** begin = (void***)abegin;
	void*** end = (void***)aend;
	void*** current = (void***)acurrent;
	uint_t size = (uint_t)(*end-*begin);
	uint_t newsize = (uint_t)(*current-*begin);
	if(newsize){
		void** newbegin=(void**)xmalloc(sizeof(void*)*newsize);
		std::memcpy(newbegin, *begin, sizeof(void*)*newsize);
		*end = newbegin+newsize;
		*current = newbegin+newsize;
		xfree(*begin, sizeof(void*)*s

		*begin = newbegin;	
	}
	else{
		xfree(*begin, sizeof(void*)*size);
		*begin = *end = *current = 0;
	}
MemoryPool::MemoryPool(){
	free_chunk_ = 0;
	full_chunk_ = 0;
void* MemoryPool::malloc(Chunk** out){
	Chunk* chunk = free_chunk_;
	if(chunk){
		void* ret = chunk->free_data;
		chunk->free_data = static_cast<data_t*>(*chunk->free_data);
		XTAL_ASSERT(chunk->count>0);
		chunk->count--;
		if(chunk->count==0){
			if(chunk->next){
				chunk->next->prev = 0;
			}
			free_chunk_ = chunk->next;
			chunk->prev = 0;
			chunk->next = full_chunk_;
			if(full_chunk_){
				full_chunk_->prev = chunk;
			}
			full_chunk_ = chunk;
		}
		*out = chunk;
		return ret;
	}
	add_chunk();
	return malloc(out);
void MemoryPool::free(void* mem, Chunk* chunk){
	*static_cast<data_t*>(mem) = chunk->free_data;
	chunk->free_data = static_cast<data_t*>(mem);
	if(chunk->count==0){
		if(chunk->next){
			chunk->next->prev = chunk->prev;
		}
		if(chunk->prev){
			chunk->prev->next = chunk->next;
		}
		else{
			full_chun

		}
		chunk->prev = 0;
		chunk->next = free_chunk_;
		if(free_chunk_){
			free_chunk_->prev = chunk;
		}
		free_chunk_ = chunk;
		chunk->count = 1;
	}
	else if(chunk->count==BLOCK_COUNT-1){
		if(chunk->next){
			chunk->next->prev = chunk->prev;
		}
		if(chunk->prev){
			chunk->prev->next = chunk->next;
		}
		else{
			free_chunk_ = chunk->next;
		}
		xfree_align(chunk->buf(), BLOCK_MEMORY_SIZE + sizeof(Chunk), BLOCK_SIZE);
	}
	else{
		chunk->count++;
	}
void MemoryPool::add_chunk(){
	u8* memory = (u8*)xmalloc_align(BLOCK_MEMORY_SIZE + sizeof(Chunk), BLOCK_SIZE);
	Chunk* chunk = (Chunk*)(memory + BLOCK_MEMORY_SIZE);
	chunk->next = 0;
	data_t* p = chunk->buf();
	for(uint_t i=0; i<BLOCK_COUNT-1; ++i){
		data_t* next_block = (data_t*)((u8*)p+BLOCK_SIZE);
		*p = next_block;
		p = next_block;
	}
	*p = 0;
	chunk->free_data = chunk->buf();
	chunk->count = BLOCK_COUNT;
	chunk->prev = 0;
	chunk->next = free_chunk_;
	if(free_chunk_){
		free_chunk_->prev = chunk;
	}
	free_chunk_ = chunk;
void Memo

	for(Chunk* p=free_chunk_; p; ){
		Chunk* next = p->next;
		xfree_align(p->buf(), BLOCK_MEMORY_SIZE + sizeof(Chunk), BLOCK_SIZE);
		p = next;
	}
	for(Chunk* p=full_chunk_; p; ){
		Chunk* next = p->next;
		xfree_align(p->buf(), BLOCK_MEMORY_SIZE + sizeof(Chunk), BLOCK_SIZE);
		p = next;
	}
	full_chunk_ = 0;
	free_chunk_ = 0;
FixedAllocator::FixedAllocator(){
	free_chunk_ = 0;
	full_chunk_ = 0;
void FixedAllocator::init(MemoryPool* pool, uint_t block_size, uint_t block_count){
	pool_ = pool;
	block_size_ = block_size;
	block_count_ = block_count;
	XTAL_ASSERT(block_count_>1);
void* FixedAllocator::malloc(){
	Chunk* chunk = free_chunk_;
	if(chunk){
		void* ret = chunk->free_data;
		chunk->free_data = static_cast<data_t*>(*chunk->free_data);
		XTAL_ASSERT(chunk->count>0);
		chunk->count--;
		if(chunk->count==0){
			if(chunk->next){
				chunk->next->prev = 0;
			}
			free_chunk_ = chunk->next;
			chunk->prev = 0;
			chunk->next = full_chunk_;
			if(full_chunk_){
				full_chunk_->prev = chu

			}
			full_chunk_ = chunk;
		}
		return ret;
	}
	add_chunk();
	return malloc();
void FixedAllocator::free(void* mem){
	Chunk* chunk = to_chunk(mem);
	*static_cast<data_t*>(mem) = chunk->free_data;
	chunk->free_data = static_cast<data_t*>(mem);
	if(chunk->count==0){
		if(chunk->next){
			chunk->next->prev = chunk->prev;
		}
		if(chunk->prev){
			chunk->prev->next = chunk->next;
		}
		else{
			full_chunk_ = chunk->next;
		}
		chunk->prev = 0;
		chunk->next = free_chunk_;
		if(free_chunk_){
			free_chunk_->prev = chunk;
		}
		free_chunk_ = chunk;
		chunk->count = 1;
	}
	else if(chunk->count==block_count_-1){
		if(chunk->next){
			chunk->next->prev = chunk->prev;
		}
		if(chunk->prev){
			chunk->prev->next = chunk->next;
		}
		else{
			free_chunk_ = chunk->next;
		}
		pool_->free(chunk, chunk->parent);
	}
	else{
		chunk->count++;
	}
void FixedAllocator::add_chunk(){
	uint_t block_count = block_count_;
	uint_t block_size = block_size_*ONE_SIZE;
	MemoryPool::Chunk* parent;
	Chunk* chunk =

	XTAL_ASSERT(chunk==align_p(chunk, MemoryPool::BLOCK_SIZE));
	chunk->parent = parent;
	chunk->next = 0;
	data_t* p = chunk->buf();
	for(uint_t i=0; i<block_count-1; ++i){
		data_t* next_block = (data_t*)((u8*)p+block_size);
		*p = next_block;
		p = next_block;
	}
	*p = 0;
	chunk->free_data = chunk->buf();
	chunk->count = block_count;
	chunk->prev = 0;
	chunk->next = free_chunk_;
	if(free_chunk_){
		free_chunk_->prev = chunk;
	}
	free_chunk_ = chunk;
void FixedAllocator::release(){
	for(Chunk* p=free_chunk_; p; ){
		Chunk* next = p->next;
		pool_->free(p, p->parent);
		p = next;
	}
	for(Chunk* p=full_chunk_; p; ){
		Chunk* next = p->next;
		pool_->free(p, p->parent);
		p = next;
	}
	full_chunk_ = 0;
	free_chunk_ = 0;
SmallObjectAllocator::SmallObjectAllocator(){
	for(int i=0; i<POOL_SIZE; ++i){
		pool_[i].init(&mpool_, i, (MemoryPool::BLOCK_SIZE-sizeof(FixedAllocator::Chunk))/((i==0 ? 1 : i)*ONE_SIZE));
	}
void SmallObjectAllocator::release(){
	for(int i=0; i<POOL_SIZE; ++i){
		pool_[i
/*
 *  url.h
 *  C Library
 *
 *  Created by hailong zhang on 10-7-30.
 *  Copyright 2010 hailongz. All rights reserved.
 *
 */
extern "C" {
	HANDLER(hurl_t)
	hurl_t url_alloc(hcchar *url,hint32 defaultPort, InvokeTickDeclare);
	void url_dealloc(hurl_t url, InvokeTickDeclare);
	hcchar * url_protocol(hurl_t url, InvokeTickDeclare);
	hcchar * url_domain(hurl_t url, InvokeTickDeclare);
	hint32 url_port(hurl_t url, InvokeTickDeclare);
	struct in_addr  url_domain_resolv(hurl_t url, InvokeTickDeclare);
	hcchar * url_path(hurl_t url, InvokeTickDeclare);
	hcchar * url_query(hurl_t url, InvokeTickDeclare);
	hcchar * url_token(hurl_t url, InvokeTickDeclare);
	hcchar * url_mask(hurl_t url,int mark, InvokeTickDeclare);
	hlist_t url_param_names(hurl_t url, InvokeTickDeclare);
	hcchar * url_param(hurl_t url,hcchar * name, InvokeTickDeclare);
	void url_encode(hcchar *url,hbuffer_t buffer, InvokeTickDeclare);
	void url_decode(hcchar *url,hbuffer_t buffer, InvokeTickDeclare);
    
    struct in_addr ur
/*
 * BaseLocator.cpp - Methods for BaseLocator class.
 * 
 * Author: Patrick O'Leary
 * Created: February 8, 2008
 * Copyright 2008. All rights reserved.
 */
/*
 * BaseLocator
 * 
 * parameter _locatorTool - Vrui::LocatorTool*
 * parameter _application - Toirt_Samhlaigh*
 */
BaseLocator::BaseLocator(Vrui::LocatorTool* _locatorTool, Toirt_Samhlaigh* _application) :
	Vrui::LocatorToolAdapter(_locatorTool) {
	application = _application;
/*
 * ~BaseLocator - Destructor
 */
BaseLocator::~BaseLocator(void) {
	application = 0;
/*
 * highlightLocator - Render actual locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::highlightLocator(GLContextData& glContextData) const {
/*
 * glRenderAction - Render opaque elements of locator
 * 
 * parameter glContextData - GLContextData&
 */
void BaseLocator::glRenderAction(GLContextData& glContextData) const {
/*
 * glRenderActionTransparent - Render transparent elements of locator
 * 
 * parameter glContextData - GLContextData&

namespace Arabica
namespace SAX
/**
 * Provide an optional convenience implementation of Locator.
 *
 * <p>This class is available mainly for application writers, who
 * can use it to make a persistent snapshot of a locator at any
 * point during a document parse:</p>
 *
 * <pre>
 * Locator locator;
 * LocatorImpl startloc;
 *
 * void setLocator(const Locator& locator)
 * {
 *   this.locator = &locator;
 * }
 *
 * void startDocument ()
 * {
 *   startloc = locator;
 * }
 *</pre>
 *
 * <p>Normally, parser writers will not use this class, since it
 * is more efficient to provide location information only when
 * requested, rather than constantly updating a Locator object.</p>
 *
 * @since SAX 1.0
 * @author Jez Higgins,
 *         <a href="mailto:jez@jezuk.co.uk">jez@jezuk.co.uk</a>
 * @version 2.0
 * @see Locator Locator
 */
template<class string_type, class string_adaptor>
class LocatorImpl : public Locator<string_type, string_adaptor>
public:
  typedef Locator<string_type, string_adap

  
  LocatorImpl() : 
    publicId_(), 
    systemId_(), 
    lineNumber_(-1), 
    columnNumber_(-1) 
  { 
  LocatorImpl(const LocatorT& rhs) : 
    publicId_(rhs.getPublicId()), 
    systemId_(rhs.getSystemId()), 
    lineNumber_(rhs.getLineNumber()), 
    columnNumber_(rhs.getColumnNumber()) 
  { 
  virtual ~LocatorImpl() { }
  LocatorImpl& operator=(const LocatorT& rhs)
  {
    publicId_ = rhs.getPublicId();
    systemId_ = rhs.getSystemId(); 
    lineNumber_ = rhs.getLineNumber();
    columnNumber_ = rhs.getColumnNumber();
  /**
   * Return the saved public identifier.
   *
   * @return The public identifier as a string, or an empty string if none
   *         is available.
   */
  virtual string_type getPublicId() const { return publicId_; }
  /**
   * Return the saved system identifier.
   *
   * @return The system identifier as a string, or an empty string if none
   *         is available.
   */
  virtual string_type getSystemId() const { return systemId_; }
  /**
   * Return

   *
   * @return The line number as an integer, or -1 if none is available.
   */
  virtual int getLineNumber() const { return lineNumber_; }
  /**
   * Return the saved column number (1-based).
   *
   * @return The column number as an integer, or -1 if none is available.
   */
  virtual int getColumnNumber() const { return columnNumber_; }
  /**
   * Set the public identifier for this locator.
   *
   * @param publicId The new public identifier, or an empty string 
   *        if none is available.
   */
  void setPublicId(const string_type& publicId) { publicId_ = publicId; }
  /**
   * Set the system identifier for this locator.
   *
   * @param systemId The new system identifier, or an empty string 
   *        if none is available.
   */
  void setSystemId(const string_type& systemId) { systemId_ = systemId; }
  /**
   * Set the line number for this locator (1-based).
   *
   * @param lineNumber The line number, or -1 if none is available.
   */
  void setLineNumber(int lineNum
/*
	Student T Test Implementation.
*/
using namespace std;
using namespace boost::math;
template<typename T>
T mean(std::vector<T> data)
	if(data.empty())
		return 0;
	T sum;
	for (typename std::vector<T>::const_iterator it = data.begin(); it != data.end(); ++it)
	{
		sum += *it;
	}
	return (sum/(int)data.size());
template<typename T>
T sample_variance(std::vector<T> data, T mean)
	T _sample_variance, _sample_square_dist;
	for (typename std::vector<T>::const_iterator it = data.begin(); it != data.end(); ++it)
	{
		_sample_square_dist += pow((*it - mean), 2);
	}
	_sample_variance = _sample_square_dist / ((int)data.size() - 1);
	return _sample_variance;
template<typename T>
std::pair<T, T> t_statistics(std::vector<T> sample1, std::vector<T> sample2)
	T _mean_diff, _t_statistic, _degrees_of_freedom, _sample_1_mean, _sample_2_mean, _sample_1_variance, 
		_sample_2_variance, _sample_1_avg_variance, _sample_2_avg_variance, _sample_avg_variance;
	int _sample_1_size, _sample_2_size;
	_sample_1

	_sample_2_size = (int)sample2.size();
	_sample_1_mean = mean<T>(sample1);
	_sample_2_mean = mean<T>(sample2);
	_sample_1_variance = sample_variance<T>(sample1, _sample_1_mean);
	_sample_2_variance = sample_variance<T>(sample2, _sample_2_mean);
	_mean_diff = abs(_sample_1_mean - _sample_2_mean);
	_sample_1_avg_variance = _sample_1_variance/_sample_1_size;
	_sample_2_avg_variance = _sample_2_variance/_sample_2_size;
	_sample_avg_variance   = (_sample_1_avg_variance + _sample_2_avg_variance);
	_t_statistic = _mean_diff/( sqrt(_sample_avg_variance) );
	_degrees_of_freedom = pow(_sample_avg_variance, 2) / ( (pow(_sample_1_avg_variance, 2)/(_sample_1_size - 1)) + (pow(_sample_2_avg_variance, 2)/(_sample_2_size - 1)) );
	return std::pair<T, T>(_t_statistic, _degrees_of_freedom);
template<typename T>
double similarity_probability(std::vector<T> sample1, std::vector<T> sample2)
	if(sample1.empty() || sample2.empty())
	{
		std::cout << "Empty sample(s) sent for calculating similarity." << endl
using std::cout;
using std::endl;
void ParseData::dump()
	cout << "machine name: " << sectionName << endl;
	for ( GraphDict::Iter g = graphDict; g.lte(); g++ )
		g->value->dump();
void VarDef::dump()
	cout << name << " = ";
	machineDef->dump();
	cout << endl;
void MachineDef::dump()
	switch ( type ) {
		case JoinType:
			join->dump();
			break;
		case LongestMatchType:
			longestMatch->dump();
			break;
		case LengthDefType:
			cout << "length def";
			break;
		case NfaUnionType:
			cout << "nfa union ";
			break;
	}
void LongestMatch::dump()
	cout << "|*";
	for ( LmPartList::Iter lmi = *longestMatchList; lmi.lte(); lmi++ ) {
		cout << " ";
		lmi->join->dump();
		cout << ";";
	}
	cout << " *|";
void Join::dump()
	for ( ExprList::Iter e = exprList; e.lte(); e++ )
		e->dump();
void Expression::dump()
	switch ( type ) {
		case OrType:
			expression->dump();
			cout << " | ";
			term->dump();
			break;
		case IntersectType:
			expression->dump();
			cout << " & ";
			term->dump();
			break

		case SubtractType:
			expression->dump();
			cout << " - ";
			term->dump();
			break;
		case StrongSubtractType:
			expression->dump();
			cout << " -- ";
			term->dump();
			break;
		case TermType:
			term->dump();
			break;
		case BuiltinType:
			cout << "builtin";
			break;
	}
void Term::dump()
	switch ( type ) {
		case ConcatType:
			term->dump();
			cout << " . ";
			factorWithAug->dump();
			break;
		case RightStartType:
			term->dump();
			cout << " :> ";
			factorWithAug->dump();
			break;
		case RightFinishType:
			term->dump();
			cout << " :>> ";
			factorWithAug->dump();
			break;
		case LeftType:
			term->dump();
			cout << " <: ";
			factorWithAug->dump();
			break;
		case FactorWithAugType:
			factorWithAug->dump();
			break;
	}
void FactorWithAug::dump()
	factorWithRep->dump();
void FactorWithRep::dump()
	switch ( type ) {
		case StarType:
			factorWithRep->dump();
			cout << "*";
			break;
		case StarStarType:
			factorWithRep->dump();
			cout << "**";
			break;
		

			factorWithRep->dump();
			cout << "?";
			break;
		case PlusType:
			factorWithRep->dump();
			cout << "+";
			break;
		case ExactType:
			factorWithRep->dump();
			cout << "{" << lowerRep << "}";
			break;
		case MaxType:
			factorWithRep->dump();
			cout << "{," << upperRep << "}";
			break;
		case MinType:
			factorWithRep->dump();
			cout << "{" << lowerRep << ",}";
			break;
		case RangeType:
			factorWithRep->dump();
			cout << "{" << lowerRep << "," << upperRep << "}";
			break;
		case FactorWithNegType:
			factorWithNeg->dump();
			break;
	}
void FactorWithNeg::dump()
	switch ( type ) {
		case NegateType:
			cout << "!";
			factorWithNeg->dump();
			break;
		case CharNegateType:
			cout << "^";
			factorWithNeg->dump();
			break;
		case FactorType:
			factor->dump();
			break;
	}
void Factor::dump()
	switch ( type ) {
		case LiteralType:
			cout << "lit";
			break;
		case RangeType:
			cout << "range";
			break;
		case OrExprType:
			cout << "or_expr";
			break;
		case RegE
/**
 * @file
 *
 *
 */
using std::string;
using std::vector;
/**
 * Model for implementing NWChem MD including theories energy, opt...
 */
class NWChemMDModel : public ITaskModel
   public:
      enum GUIPanel {INTERACTION, CONSTRAINT, DYNAMICS, THERMODYNAMICS, 
                     OPTIMIZE, CONTROL, FILES};
      /* Constructors */
      NWChemMDModel();
      NWChemMDModel(vector<NWChemMDModel::GUIPanel>);
      NWChemMDModel(const string& url, const string& name);
      NWChemMDModel(const ResourceDescriptor::CONTENTTYPE task);
      virtual ~NWChemMDModel();
      /* Task Model virtuals */
      virtual void generateInputFile() throw(InvalidException);
      virtual void run() throw(InvalidException);
      /* Set pointers for models */
      void setInteractionModel(InteractionModel *model);
      void setConstraintModel(ConstraintModel *model);
      void setOptimizeModel(OptimizeModel *model);
      void setControlModel(ControlModel *model);
      void setDynamicsModel(Dynamics
/*
Brian Curless
Computer Graphics Laboratory
Stanford University
---------------------------------------------------------------------
Copyright (1997) The Board of Trustees of the Leland Stanford Junior
University. Except for commercial resale, lease, license or other
commercial transactions, permission is hereby given to use, copy,
modify this software for academic purposes only.  No part of this
software or any derivatives thereof may be used in the production of
computer models for resale or for use in a commercial
product. STANFORD MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND
CONCERNING THIS SOFTWARE.  No support is implied or provided.
*/
ChunkAllocator::ChunkAllocator()
    this->chunkSize = 0;
    this->chunkList = NULL;
    this->currentChunk = NULL;
    this->currentAddr = NULL;
    this->countInChunk = 0;
ChunkAllocator::ChunkAllocator(int chunkSize)
    this->chunkSize = chunkSize;
    this->chunkList = new ChunkLink(chunkSize);
    this->currentChunk = this->chunkLi
std::ostream& operator<<(std::ostream& stream, Mappable ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Unit ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  stream << "owner: " << ob.owner  <<'\n';
  stream << "health: " << ob.health  <<'\n';
  stream << "strength: " << ob.strength  <<'\n';
  stream << "movesLeft: " << ob.movesLeft  <<'\n';
  stream << "attacksLeft: " << ob.attacksLeft  <<'\n';
  stream << "gold: " << ob.gold  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Pirate ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  stream << "owner: " << ob.owner  <<'\n';
  stream << "health: " << ob.health  <<'\n';
  stream << "strength: " << ob.strength  <<'\n';
  stream << "movesLeft: " << ob.movesLeft  <<'\n';

  stream << "attacksLeft: " << ob.attacksLeft  <<'\n';
  stream << "gold: " << ob.gold  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Player ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "playerName: " << ob.playerName  <<'\n';
  stream << "gold: " << ob.gold  <<'\n';
  stream << "time: " << ob.time  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Port ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  stream << "owner: " << ob.owner  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Ship ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  stream << "owner: " << ob.owner  <<'\n';
  stream << "health: " << ob.health  <<'\n';
  stream << "strength: " << ob.strength  <<'\n';
  stream << "movesLeft: " << ob.movesLeft  <<'\n';
  stream << "attacksLeft: " << ob.attacksLeft  <<'\n';
  stream <

  return stream;
std::ostream& operator<<(std::ostream& stream, Tile ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  stream << "type: " << ob.type  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Treasure ob)
  stream << "id: " << ob.id  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  stream << "gold: " << ob.gold  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Move ob)
  stream << "Move" << "\n";
  stream << "unit: " << ob.unit  <<'\n';
  stream << "x: " << ob.x  <<'\n';
  stream << "y: " << ob.y  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Pirateattack ob)
  stream << "Pirateattack" << "\n";
  stream << "attacker: " << ob.attacker  <<'\n';
  stream << "attackx: " << ob.attackx  <<'\n';
  stream << "attacky: " << ob.attacky  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Shipattack ob)
  

  stream << "attacker: " << ob.attacker  <<'\n';
  stream << "attackx: " << ob.attackx  <<'\n';
  stream << "attacky: " << ob.attacky  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, Talk ob)
  stream << "Talk" << "\n";
  stream << "speaker: " << ob.speaker  <<'\n';
  stream << "message: " << ob.message  <<'\n';
  return stream;
std::ostream& operator<<(std::ostream& stream, GameState ob)
  stream << "turnNumber: " << ob.turnNumber  <<'\n';
  stream << "playerID: " << ob.playerID  <<'\n';
  stream << "gameNumber: " << ob.gameNumber  <<'\n';
  stream << "pirateCost: " << ob.pirateCost  <<'\n';
  stream << "shipCost: " << ob.shipCost  <<'\n';
  stream << "portCost: " << ob.portCost  <<'\n';
  stream << "mapSize: " << ob.mapSize  <<'\n';
  stream << "\n\nMappables:\n";
  for(std::map<int,Mappable>::iterator i = ob.mappables.begin(); i != ob.mappables.end(); i++)
    stream << i->second << '\n';
  stream << "\n\nUnits:\n";
  for(std::map<int,Unit>::iterator i = ob.

    stream << i->second << '\n';
  stream << "\n\nPirates:\n";
  for(std::map<int,Pirate>::iterator i = ob.pirates.begin(); i != ob.pirates.end(); i++)
    stream << i->second << '\n';
  stream << "\n\nPlayers:\n";
  for(std::map<int,Player>::iterator i = ob.players.begin(); i != ob.players.end(); i++)
    stream << i->second << '\n';
  stream << "\n\nPorts:\n";
  for(std::map<int,Port>::iterator i = ob.ports.begin(); i != ob.ports.end(); i++)
    stream << i->second << '\n';
  stream << "\n\nShips:\n";
  for(std::map<int,Ship>::iterator i = ob.ships.begin(); i != ob.ships.end(); i++)
    stream << i->second << '\n';
  stream << "\n\nTiles:\n";
  for(std::map<int,Tile>::iterator i = ob.tiles.begin(); i != ob.tiles.end(); i++)
    stream << i->second << '\n';
  stream << "\n\nTreasures:\n";
  for(std::map<int,Treasure>::iterator i = ob.treasures.begin(); i != ob.treasures.end(); i++)
    stream << i->second << '\n';
  stream << "\nAnimation\n";
  for
    (
    std::map< int, std::vecto
namespace Olivia {
namespace AST {
void Node::dump() const {
    dump_output("Node - Base");
void NodeIdentifier::dump() const {
    dump_output("Identifier - " + name);
void NodeStatementVar::dump() const {
    dump_output("Statement - 'var'");
    if (list) {
        list->dump();
    }
void NodeDeclarationVar::dump() const {
    dump_output("Declaration - 'var'");
    if (name) {
        name->dump();
    }
    if (type) {
        type->dump();
    }
    if (initializer) {
        initializer->dump();
    }
void NodeTypeSpec::dump() const {
    dump_output(std::string("Node - Type - ") + convertValueTypeToString(base_type));
    if (concrete_type) {
        concrete_type->dump();
    }
void NodeDeclarationClassElement::dump() const {
    dump_output("Declaration - element of 'class'");
    if (name) {
        name->dump();
    }
    if (type) {
        type->dump();
    }
void NodeDeclarationClass::dump() const {
    dump_output("Decleartion - 'class'");
    if (name) {
        name

    }
    for (auto member : members) {
        member->dump();
    }
void MiscVarDeclarationList::dump() const {
    dump_output("Misc - 'var' declearation list");
    for (auto var : vars) {
        var->dump();
    }
void Node::dump_output(const std::string& msg) const {
    if (!this->parent()) {
        printf("%s\n", msg.c_str());
    } else {
        this->parent()->dump_output(' ' + msg);
    }
void NodeDeclarationClassElementState::dump() const {
    dump_output("Declaration - class element state");
    if (name) {
        name->dump();
    }
    if (type) {
        type->dump();
    }
void NodeDeclarationClassElementMethod::dump() const {
    dump_output("Declaration - class element method");
    if (name) {
        name->dump();
    }
    if (type) {
        type->dump();
    }
void NodeDeclarationParameter::dump() const {
    dump_output("Declaration - parameter");
    if (name) {
        name->dump();
    }
    if (ptype) {
        ptype->dump();
    }
void NodeDeclaratio

    dump_output("Declaration - signature");
    for (auto parameter : parameters) {
        parameter->dump();
    }
    if (return_type) {
        return_type->dump();
    }
void NodeDeclarationFunction::dump() const {
    dump_output("Declaration - 'function'");
    if (name) {
        name->dump();
    }
    if (signature) {
        signature->dump();
    }
    if (body) {
        body->dump();
    }
void NodeBlock::dump() const {
    dump_output("Statement - block");
    for (auto statement : statements) {
        statement->dump();
    }
void NodeDeclarationExternFunction::dump() const {
    dump_output("Declaration - 'extern function'");
    if (name) {
        name->dump();
    }
    if (signature) {
        signature->dump();
    }
void NodeBinaryExpression::dump() const {
    std::string ret = "Expression - Binary - <";
    ret += op;
    ret += ">";
    dump_output(ret);
    if (lhs) {
        lhs->dump(); }
    if (rhs) {
        rhs->dump(); }
void NodeParenthesisExpressio

    dump_output("Expression - Parenthesis");
    if (expression) {
        expression->dump(); }
void NodeCallExpression::dump() const {
    dump_output("Expression - Call");
    if (callee) {
        callee->dump(); }
    for (auto argument : arguments) {
        argument->dump(); }
void NodeMemberExpression::dump() const {
    dump_output("Expression - Member Access");
    if (expression) {
        expression->dump(); }
    if (name) {
        name->dump(); }
void NodeStatementExpression::dump() const {
    dump_output("Statement - Expression");
    if (expression) {
        expression->dump(); }
void NodeStatementReturn::dump() const {
    dump_output("Statement - 'return'");
    if (expression) {
        expression->dump(); }
void NodeStatementIf::dump() const {
    dump_output("Statement - If");
    if (cond_) {
        cond_->dump(); }
    if (then_) {
        then_->dump(); }
    if (else_) {
        else_->dump(); }
void NodeStatementWhile::dump() const {
    dump_output("Stat
/*
  Datatype representing a sample.
  All samples in 10goto20 are stereo; there are simply no mono
  sources. A stereo sample where the left and right channels are the
  same is the recommended replacement for a mono sample.
  Amplitudes normally range from -1 to 1, however, intermediate values
  may be arbitrarily (finitely) large; compare "high dynamic range"
  lighting values in computer graphics.
*/
struct Sample {
  double left;
  double right;
  double *samples() { return &left; }
  explicit Sample(double mono) : left(mono), right(mono) {}
  Sample(double l, double r) : left(l), right(r) {}
};
inline Sample operator +(const Sample &a, const Sample &b) {
  return Sample(a.left + b.left, a.right + b.right);
inline Sample operator -(const Sample &a, const Sample &b) {
  return Sample(a.left - b.left, a.right - b.right);
inline Sample operator /(const Sample &a, double b) {
  return Sample(a.left / b, a.right / b);
inline Sample operator *(const Sample &a, double b) {
  return Sampl
namespace xs{
	DataChunk::stChunk::stChunk(uint ui32Type) : m_ui32Type(ui32Type),
		m_ui32ChunkSize(0),
		m_ui32DataSize(0),
		m_pData(0),
		m_pChild(0),
		m_pSibling(0)
	{
	}
DataChunk::stChunk::stChunk(
				 uint ui32Type,
				 uint ui32ChunkSize,
				 uint ui32DataSize,
				 void *pData,
				 stChunk *pChild,
				 stChunk *pSibling)
		:	m_ui32Type(ui32Type),
			m_ui32ChunkSize(ui32ChunkSize),
			m_ui32DataSize(ui32DataSize),
			m_pData(pData),
			m_pChild(pChild),
			m_pSibling(pSibling)
DataChunk::stChunk::~stChunk()
	safeDelete(m_pData);
DataChunk::DataChunk() : m_pChunk(0),m_pCurrentChunk(0),m_ui32Offset(0)
DataChunk::~DataChunk()
	Close();
void DataChunk::Close_Helper(stChunk *pChunk,void *p)
	safeDelete(pChunk);
void DataChunk::Close()
	RecursiveFunc(&xs::DataChunk::Close_Helper,m_pChunk,0);
	m_pChunk = 0;
	m_pCurrentChunk = 0;
	m_ui32Offset = 0;
uint DataChunk::stChunk::GetSize()
	return sizeof(m_ui32Type) + sizeof(m_ui32DataSize) + m_ui32DataSize;
uint DataChunk::BuildChunkSi

	uint totalSize = 0;
	while(pChunk)
	{
		uint size = 0;
		stChunk *pSibling = pChunk->m_pSibling;
		stChunk *pChild = pChunk->m_pChild;
		size += pChunk->m_ui32DataSize + CHUNK_MIN_SIZE;
		if(pChild)
		{
			size += BuildChunkSize(pChild);
		}
		pChunk->m_ui32ChunkSize = size;
		totalSize += size;
		pChunk = pSibling;
	}
	return totalSize;
void DataChunk::RecursiveFunc(pRecursiveFunc pFunc,stChunk *pChunk,void *p)
	while(pChunk)
	{
		stChunk *pSibling = pChunk->m_pSibling;
		stChunk *pChild = pChunk->m_pChild;
		(this->*pFunc)(pChunk,p);
		if(pChild)
		{
			RecursiveFunc(pFunc,pChild,p);
		}
		pChunk = pSibling;
	}
DataChunk::stChunk *DataChunk::SerializeIn_Helper(FILE *fp,uint ui32FPBegin,uint ui32FPEnd,bool bLoadAll,stChunk *pParent,stChunk *pBrother)
	if(ui32FPBegin >= ui32FPEnd || !fp)return 0;
	fseek(fp,ui32FPBegin,SEEK_SET);
	if(ui32FPEnd - ui32FPBegin < CHUNK_MIN_SIZE)return 0;
	uint ui32Type;
	uint ui32ChunkSize,ui32DataSize;
	uint ui32FP = ui32FPBegin;
	stChunk *pChunk = 0;
	s

	while(ui32FP < ui32FPEnd)
	{
		fread(&ui32Type,sizeof(ui32Type),1,fp);
		ui32FP += sizeof(ui32Type);
		fread(&ui32DataSize,sizeof(ui32DataSize),1,fp);
		ui32FP += sizeof(ui32DataSize);
		ui32ChunkSize = sizeof(ui32Type) + sizeof(ui32DataSize) + ui32DataSize;
		char *pData = 0;
		if(bLoadAll)
		{
			pData = new char[ui32DataSize];
			fread(pData,ui32DataSize,1,fp);
		}
		else
		{
			fseek(fp,ui32DataSize,SEEK_CUR);
		}
		ui32FP += ui32DataSize;
		pChunk = new stChunk(ui32Type,ui32ChunkSize,ui32DataSize,pData,0,0);
		stChunk *pChild = 0;
		if(ui32FP < ui32FPEnd)
		{
			pChild = SerializeIn_Helper(fp,ui32FP,ui32FP + ui32ChunkSize - pChunk->GetSize(),bLoadAll,pChunk,0);
			ui32FP += ui32ChunkSize - pChunk->GetSize();
		}
		pChunk->m_pChild = pChild;
		if(pParent && !pParent->m_pChild)pParent->m_pChild = pChunk;
		if(pBrother)pBrother->m_pSibling = pChunk;
		pBrother = pChunk;
		if(!pRet)pRet = pChunk;
	}
	return pRet;
void DataChunk::SerializeIn(char szFileName[],bool bLoadAll)
	Close();

	FILE *fp = fopen(szFileName,"rb");
	if(!fp)return;
	uint ui32Begin = ftell(fp);
	fseek(fp,0,SEEK_END);
	uint ui32End = ftell(fp);
	m_pChunk = SerializeIn_Helper(fp,ui32Begin,ui32End,bLoadAll,0,0);
	fclose(fp);
DataChunk::stChunk *DataChunk::SerializeIn_Helper(Stream* data,uint ui32FPBegin,uint ui32FPEnd,stChunk *pParent,stChunk *pBrother)
	if(ui32FPBegin >= ui32FPEnd)return 0;
	if(ui32FPEnd - ui32FPBegin < CHUNK_MIN_SIZE)return 0;
	uint ui32Type;
	uint ui32ChunkSize,ui32DataSize;
	uint ui32FP = ui32FPBegin;
	stChunk *pChunk = 0;
	stChunk *pRet = 0;
	while(ui32FP < ui32FPEnd)
	{
		data->read(&ui32Type,sizeof(ui32Type));
		ui32FP += sizeof(ui32Type);
		data->read(&ui32DataSize,sizeof(ui32DataSize));
		ui32FP += sizeof(ui32DataSize);
		ui32ChunkSize = sizeof(ui32Type) + sizeof(ui32DataSize) + ui32DataSize;
		uint pos = data->getPosition();
		this->operateChunk(ui32Type,data,ui32DataSize);
		data->seek(pos + ui32DataSize);
		ui32FP += ui32DataSize;
		pChunk = new stChunk(ui32Type,ui32Chu

		pChunk->m_pChild = 0;
		if(pParent && !pParent->m_pChild)pParent->m_pChild = pChunk;
		if(pBrother)pBrother->m_pSibling = pChunk;
		pBrother = pChunk;
		if(!pRet)pRet = pChunk;
	}
	return pRet;
void DataChunk::SerializeIn(Stream* data,uint size)
	if(!data)return;
	Close();
	m_pChunk = SerializeIn_Helper(data,0,size,0,0);
void DataChunk::SerializeOut_Helper(FILE *fp,stChunk *p)
	if(!p)return;
	stChunk *pChunk = p;
	while(pChunk)
	{
		fwrite(&pChunk->m_ui32Type,sizeof(pChunk->m_ui32Type),1,fp);
		uint chunkSize = pChunk->m_ui32ChunkSize - CHUNK_MIN_SIZE;
		fwrite(&chunkSize,sizeof(chunkSize),1,fp);
		if(pChunk->m_pData)fwrite(pChunk->m_pData,pChunk->m_ui32DataSize,1,fp);
		SerializeOut_Helper(fp,pChunk->m_pChild);
		pChunk = pChunk->m_pSibling;
	}
void DataChunk::SerializeOut_Helper(Stream *pStream,stChunk *p)
	if(!p || !pStream)return;
	stChunk *pChunk = p;
	while(pChunk)
	{
		pStream->write(&pChunk->m_ui32Type,sizeof(pChunk->m_ui32Type));
		uint chunkSize = pChunk->m_ui32ChunkSize -

		pStream->write(&chunkSize,sizeof(chunkSize));
		if(pChunk->m_pData)pStream->write(pChunk->m_pData,pChunk->m_ui32DataSize);
		SerializeOut_Helper(pStream,pChunk->m_pChild);
		pChunk = pChunk->m_pSibling;
	}
void DataChunk::save(Stream* pStream)
	if(!m_pChunk)return;
	if(!pStream)return;
	BuildChunkSize(m_pChunk);
	SerializeOut_Helper(pStream,m_pChunk);
void DataChunk::save(const char* szFileName)
	if(!m_pChunk)return;
	BuildChunkSize(m_pChunk);
	FILE *fp = fopen(szFileName,"wb+");
	if(!fp)return;
	SerializeOut_Helper(fp,m_pChunk);
	fclose(fp);
void DataChunk::operateChunk(uint ui32ID,Stream* pData,uint size)
	return;
DataChunk::stChunk* DataChunk::readChunk(Stream* pData,bool bWowFormat)
	uint ui32Type;
	uint ui32ChunkSize,ui32DataSize;
	uchar *pChunkData;
	pData->read(&ui32Type,sizeof(ui32Type));
	pData->read(&ui32DataSize,sizeof(ui32DataSize));
	if(bWowFormat)
	{
		if(ui32Type == 'MCAL' && ui32DataSize == 0xfffff800)
		{
			ui32DataSize = 0;
		}
	}
	pData->read(pChunkData,ui32DataS

	ui32ChunkSize = sizeof(ui32Type) + sizeof(ui32DataSize) + ui32DataSize;
	if(bWowFormat)
	{
		if(ui32Type == 'MCNR')
		{
			pData->seek(0x1c0 - 0x1b3,SEEK_CUR);
		}
		if(ui32Type == 'MCLQ')
		{
		}
	}
	return new stChunk(ui32Type,ui32ChunkSize,ui32DataSize,pChunkData,0,0);
DataChunk::stChunk* DataChunk::beginChunk(Stream* pData,bool bWowFormat)
	if(pData->getLength() < CHUNK_MIN_SIZE)
	{
		return 0;
	}
	m_pCurrentChunk = m_pChunk = readChunk(pData,bWowFormat);
	return m_pCurrentChunk;
DataChunk::stChunk* DataChunk::nextChunk(Stream* pData,bool bWowFormat)
	if(pData->getLength() - pData->getPosition() < CHUNK_MIN_SIZE)
	{
		return 0;
	}
	m_pCurrentChunk->m_pSibling = readChunk(pData,bWowFormat);
	m_pCurrentChunk = m_pCurrentChunk->m_pSibling;
	return m_pCurrentChunk;
uchar* DataChunk::getAbsoluteDataPointer()
	return m_data.getBuffer() + m_data.getPosition();
DataChunk::stChunk* DataChunk::beginChunk(uchar* pData,uint size,bool bWowFormat)
	m_data.attach(pData,size);
	return beginChunk

DataChunk::stChunk* DataChunk::nextChunk(bool bWowFormat)
	return nextChunk(&m_data,bWowFormat);
DataChunk::stChunk* DataChunk::beginChunk(uint ui32Type,Stream** pDataStream)
	stChunk *pChunk = new stChunk(ui32Type);
	if(pDataStream)*pDataStream = &pChunk->m_data;
	if(!m_pChunk)m_pChunk = pChunk;
	stChunk *pParentChunk = 0;
	if(!m_vChunks.empty())
	{
		pParentChunk = m_vChunks.back();
		if(!pParentChunk->m_pChild)pParentChunk->m_pChild = pChunk;
	}
	if(m_pCurrentChunk != pParentChunk)m_pCurrentChunk->m_pSibling = pChunk;
	m_pCurrentChunk = pChunk;
	m_vChunks.push_back(pChunk);
	return pChunk;
void DataChunk::endChunk()
	m_pCurrentChunk = m_vChunks.back();
	m_pCurrentChunk->m_ui32DataSize = m_pCurrentChunk->m_data.getLength();
	m_pCurrentChunk->m_pData = new uchar[m_pCurrentChunk->m_ui32DataSize];
	memcpy(m_pCurrentChunk->m_pData,(void*)m_pCurrentChunk->m_data.getBuffer(),m_pCurrentChunk->m_ui32DataSize);
	m_vChunks.pop_back();
uint DataChunk::getOffset()
	return BuildChunkSize(m_pChun
typedef android::base::Stream BaseStream;
static BaseStream* asBaseStream(Stream* stream) {
    return reinterpret_cast<BaseStream*>(stream);
ssize_t stream_read(Stream* stream, void* buffer, size_t len) {
    return asBaseStream(stream)->read(buffer, len);
ssize_t stream_write(Stream* stream, const void* buffer, size_t len) {
    return asBaseStream(stream)->write(buffer, len);
void stream_put_byte(Stream* stream, int v) {
    asBaseStream(stream)->putByte(static_cast<uint8_t>(v));
void stream_put_be16(Stream* stream, uint16_t v) {
    asBaseStream(stream)->putBe16(v);
void stream_put_be32(Stream* stream, uint32_t v) {
    asBaseStream(stream)->putBe32(v);
void stream_put_be64(Stream* stream, uint64_t v) {
    asBaseStream(stream)->putBe64(v);
uint8_t stream_get_byte(Stream* stream) {
    return asBaseStream(stream)->getByte();
uint16_t stream_get_be16(Stream* stream) {
    return asBaseStream(stream)->getBe16();
uint32_t stream_get_be32(Stream* stream) {
    return asBaseStream(strea
OpenDDS::DCPS::RepoIdSet::~RepoIdSet()
  DBG_ENTRY_LVL("RepoIdSet","~RepoIdSet",5);
void
OpenDDS::DCPS::RepoIdSet::serialize(TAO::DCPS::Serializer & serializer)
  DBG_ENTRY_LVL("RepoIdSet","serialize",5);
  CORBA::ULong sz = this->size ();
  serializer << sz;
  for (MapType::iterator itr = map_.begin();
    itr != map_.end();
    ++itr)
  {
    serializer << itr->first;
  }
bool
OpenDDS::DCPS::RepoIdSet::is_subset (RepoIdSet& map)
  DBG_ENTRY_LVL("RepoIdSet","is_subset",5);
  if (this->size () <= map.size () && this->size () > 0)
  {
    for (MapType::iterator itr = map_.begin();
      itr != map_.end();
      ++itr)
    {
      MapType::mapped_type* ientry;
      if (find(map.map_, itr->first, ientry) != 0)
        return false;
    }
    return true;
  }
  return false;
bool
OpenDDS::DCPS::RepoIdSet::exist (const RepoId& local_id,
                             bool& last)
  DBG_ENTRY_LVL("RepoIdSet","exist",5);
  last = true;
  RepoId remote;
  if (find(map_, local_id, remote) == -1)

const chi::SdlSample *superCast(const chi::Sample &sample) {
	const chi::SdlSample *sdlSample = dynamic_cast<const chi::SdlSample *>(&sample);
	if (!sdlSample) {
		throw chi::Exception("You can only assign an SdlSample from another SdlSample.");
	}
	return sdlSample;
namespace chi {
Factory<SdlSample> *SdlSample::factory = new Factory<SdlSample>;
SdlSample::SdlSample()
	: sample(NULL)
SdlSample::SdlSample(const SdlSample &sample)
	: Sample(sample)
	copyFrom(sample);
SdlSample::SdlSample(const Sample &sample)
	: Sample(sample)
	copyFrom(*superCast(sample));
SdlSample::SdlSample(const std::string &uri)
	: sample(Mix_LoadWAV((this->m_uri = uri).c_str()))
	if (!sample) {
		throw Exception("Mix_LoadWAV failed! SDL says, \"" + std::string(SDL_GetError()) + "\".");
	}
SdlSample::~SdlSample() {
	if (!m_sampleCounter.release()) return;
	if (!sample) return;
	Mix_FreeChunk(sample);
Sample &SdlSample::operator =(const Sample &sample) {
	Sample::operator =(sample);
	return copyFrom(*superCast(samp
using namespace std;
class WebStream;
/* control the stream */
class StreamManager{
private:
    list<WebStream *> idleStream;
    list<WebStream *> readStream;
    list<WebStream *> taskStream;
    list<WebStream *> writeStream;
public:
    StreamManager();
    /* get an idle webstream from idleStream, if no idleStream
       new a WebStream */
    WebStream *GetIdleWebStream();
    /* add an idle webStream into idleStream */
    int AddIdleStream( WebStream *idleWebStream);
    /* Get idle Stream size */
    int GetIdleStreamSize();
    /* get the taskStream according to the fd */
    WebStream *GetReadWebStream( int fd );
    /* add an task webStream into taskStream */
    int AddReadWebStream( WebStream *readWebStream );
    /* is the taskWebStream in the taskStream */
    bool IsReadWebStreamExist( WebStream *readWebStream );
    /* is the readStream set has uninitlize stream */
    bool IsExistUninitilizeReadStream();
    /* is exit readStream set has read status */
    bool IsEx

    /* delete an webWrite Stream in the pool */
    int DeleteReadWebStream( WebStream *readWebStream );
    /* Get the readWebStream size */
    int GetReadWebStreamSize();
    /* Loop the readStream list, and return the already stream */
    int HttpParseHeader();
    /* clip the readStream has taskStream */
    int ClipReadToTaskStream();
    /* clip the readStream to idle stream */
    int ClipReadToIdleStream();
    /* delete an webWrite Stream in the pool */
    int DeleteWriteWebStream( WebStream *writeWebStream );
    /* add an webStream into taskStream */
    int AddTaskWebStream( WebStream *taskStream );
    /* Get the next undispatcher TaskStream */
    WebStream * GetNextUndispatherTaskStream();
    /* Get the taskWebStream size */
    int GetTaskWebStreamSize();
    /* clip the taskStream has writeStream */
    int ClipTaskToWriteStream();
    /* add an writeStream */
    int AddWriteWebStream(WebStream *webStream);
    /* delete from webStream from taskWebStream  */
    
/* Documentation:
	Abstract:
	History:
			Created	05-16-95 01:07pm Kevin T. Seghetti
	Class Hierarchy:
			none
	Dependancies:
	Restrictions:
	Example:
*/
QFile3ds::QFile3ds(SceneEnumProc* theScene)
   databasefile = OpenFile3ds(filename, "rw");
   PRINT_ERRORS_EXIT(stderr);
   assert(databasefile);
   db = NULL;
   InitDatabase3ds(&db);
   PRINT_ERRORS_EXIT(stderr);
   assert(db);
   CreateDatabase3ds(databasefile, db);
   PRINT_ERRORS_EXIT(stderr);
	_theScene = theScene;
QFile3ds::~QFile3ds()
   ReleaseDatabase3ds(&db);
   PRINT_ERRORS_EXIT(stderr);
   CloseFile3ds(databasefile);
   PRINT_ERRORS_EXIT(stderr);
void
QFile3ds::DumpMeshes(ostream& output)
    mesh3ds *mesh = NULL;
	AppDataChunk* meshChunk;
	ulong numElem = GetMeshCount3ds(db);
	PRINT_ERRORS_EXIT(stderr);
	DBSTREAM3( cstats << "There are " << numElem << " meshes" << endl; )
	for (ulong i = 0; i < numElem; i++)
	 {
		GetMeshByIndex3ds(GetDatabase(), i, &mesh);
		PRINT_ERRORS_EXIT(stderr);
		DBSTREAM3( cprogress << "processi

		if(mesh->procdata)
		 {
			DBSTREAM3( cstats << "Has Procdata at address " << mesh->procdata << " of size " << mesh->procsize << endl; )
			HDump(mesh->procdata,(uint32)mesh->procsize,0);
		 }
		meshChunk = FindMeshChunk(mesh->name);
		if(meshChunk)
		 {
			DumpChunk3DS(meshChunk,0,FALSE,mesh->name);
		 }
	 }
void
QFile3ds::LoadChunkData(AppDataChunk* chunk)
void
QFile3ds::DumpChunk3DS(AppDataChunk* chunk, int indent, short dumpSib, const char* name)
	cout << "chunktag3ds: $" << hex << setw(4) << setfill('0') << chunk->tag << endl;
	cout << "chunk size: $" << hex << setw(4) << setfill('0') << chunk->size << endl;
	cout << "Chunk data: " << endl;
	assert(chunk->size < CHUNKBUFFERSIZE);
	LoadChunkData(chunk);
	HDump(chunkBuffer.chunkData,chunk->size,indent);
	 if(chunk->children)
	  {
		cout << "Child of " << name << endl;
		DumpChunk3DS(chunk->children,indent+1,TRUE,name);
	  }
	if(dumpSib && chunk->sibling)
	 {
		cout << "Sibling of " << name << endl;
		DumpChunk3DS(chunk->sibling,i

	 }
	cout << dec;
AppDataChunk*
QFile3ds::FindMeshChunk(const char* name) const
	chunklistentry3ds* cle3ds;
	AppDataChunk* c3ds;
	for(int index=0;index<db->objlist->count;index++)
	 {
		cle3ds = &db->objlist->list[index];
		if(!strcmp(name,cle3ds->name))
		 {
			c3ds = cle3ds->chunk;
			DBSTREAM3( cstats << "QFile3ds::FindMeshChunk: Found " << cle3ds->name << endl; )
			return(c3ds);
		 }
	 }
	cerror << "Error: object " << name << " not found" << endl;
	assert(0);
	return(NULL);
AppDataChunk*
QFile3ds::FindXDataChunk(AppDataChunk* mesh) const
	AppDataChunk* chunk;
	assert(mesh);
	assert(mesh->tag == NAMED_OBJECT);
	chunk = ChunkFindChild(mesh,N_TRI_OBJECT);
	assert(chunk);
	chunk = ChunkFindChild(chunk,XDATA_SECTION);
	return(chunk);
AppDataChunk*
QFile3ds::FindNamedXDataChunk(AppDataChunk* xDataChunk,const char* name)
	AppDataChunk* dataChunk;
	AppDataChunk* nameChunk;
	assert(xDataChunk);
	assert(xDataChunk->tag == XDATA_SECTION);
	dataChunk = ChunkFindChild(xDataChunk,XDATA_ENTRY);

	DBSTREAM3( cdebug << "File3ds::FindNamedXDataChunk: looking in chunk <" << xDataChunk << "> for <" << name << ">" << endl; )
	while(dataChunk)
	 {
		assert(dataChunk->tag == XDATA_ENTRY);
		if(dataChunk->children)
		 {
			DBSTREAM3( cdebug << "  find child" << endl; )
			nameChunk = ChunkFindChild(dataChunk,XDATA_APPNAME);
			if(nameChunk)
			 {
				DBSTREAM3( cdebug << "  found child with tag of <" << hex << nameChunk->tag << ">, contains " << (const char*)&chunkBuffer.chunkData << endl; )
				LoadChunkData(nameChunk);
			 	if(!strncmp(name,(const char*)&chunkBuffer.chunkData,strlen(name)))
				 {
					DBSTREAM3( cdebug << "  desired chunk found! " << (const char*)&chunkBuffer.chunkData << endl; )
					return(dataChunk);
				 }
			 }
		 }
		DBSTREAM3( cdebug << "  find sibling" << endl; )
		dataChunk = ChunkFindSibling(dataChunk,XDATA_ENTRY);
		DBSTREAM3( if(dataChunk) )
			DBSTREAM3( cdebug << "  found sibling with tag of " << hex << dataChunk->tag << endl; )
	 }
	return(dataChunk)
using namespace Zeni;
using namespace Zeni::Collision;
using std::map;
using std::make_pair;
using std::pair;
using std::bad_exception;
Solid_Terrain::Model_Manager
Solid_Terrain::model_manager = Solid_Terrain::Model_Manager();
Solid_Terrain::Solid_Terrain(const String &model_,
                             const Point3f &corner_,
                             const Vector3f &scale_,
                             const Quaternion &rotation_)
: Terrain(corner_, scale_, rotation_),
  model(model_)
  if (!model_manager.find_model(model_)) model_manager.load_model(model_);
  else model_manager.increment_instance_count(model_);
  create_body();
Solid_Terrain::Solid_Terrain(const Solid_Terrain &rhs)
: Terrain(rhs.get_corner(),
          rhs.get_scale(),
          rhs.get_rotation())
  if (model != rhs.get_model()) throw new bad_exception;
  model_manager.increment_instance_count(model);
  create_body();
Solid_Terrain & Solid_Terrain::operator=(const Solid_Terrain &rhs) {
  if (model != rhs.get_

  set_corner(rhs.get_corner());
  set_scale(rhs.get_scale());
  set_rotation(rhs.get_rotation());
  create_body();
  return *this;
Solid_Terrain::~Solid_Terrain() {
  model_manager.decrement_instance_count(model);
void Solid_Terrain::render() {
  const std::pair<Vector3f, float> cur_rotation = get_rotation().get_rotation();
  Model* model_ptr = model_manager.get_model(model);
  model_ptr->set_translate(get_corner());
  model_ptr->set_scale(get_scale());
  model_ptr->set_rotate(cur_rotation.second, cur_rotation.first);
  model_ptr->render();
Solid_Terrain::Model_Manager::Model_Manager() {}
Solid_Terrain::Model_Manager::~Model_Manager() {
  for (auto it = model_map.begin(); it != model_map.end();) {
    if (it->second.first != nullptr) delete it->second.first;
    else ++it;
  }
bool Solid_Terrain::Model_Manager::find_model(const String &model_) const {
  return model_map.find(model_) != model_map.end();
Model * Solid_Terrain::Model_Manager::get_model(const String &model_) {
  map<Strin

  if ((it = model_map.find(model_)) == model_map.end()) throw new bad_exception;
  return it->second.first;
void Solid_Terrain::Model_Manager::load_model(const String &model_) {
  if (find_model(model_)) throw new bad_exception;
  model_map[model_] = make_pair(new Model(model_), 1lu);
const unsigned long & Solid_Terrain::Model_Manager::get_instance_count(const String &model_) const {
  map<String, pair<Model*, unsigned long> >::const_iterator it;
  if ((it = model_map.find(model_)) == model_map.end()) throw new bad_exception;
  return it->second.second;
void Solid_Terrain::Model_Manager::decrement_instance_count(const String &model_) {
  map<String, pair<Model*, unsigned long> >::iterator it;
  if ((it = model_map.find(model_)) == model_map.end()) throw new bad_exception;
  if (!--it->second.second) {
    delete it->second.first;
    model_map.erase(it);
  }
void Solid_Terrain::Model_Manager::increment_instance_count(const String &model_) {
  map<String, pair<Model*, unsigned long> >:
namespace IceProxy
namespace Ice
class Locator;
ICE_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Ice::Locator>&);
ICE_API ::IceProxy::Ice::Object* upCast(::IceProxy::Ice::Locator*);
class LocatorRegistry;
ICE_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Ice::LocatorRegistry>&);
ICE_API ::IceProxy::Ice::Object* upCast(::IceProxy::Ice::LocatorRegistry*);
namespace Ice
class Locator;
bool operator==(const Locator&, const Locator&);
bool operator<(const Locator&, const Locator&);
ICE_API ::Ice::Object* upCast(::Ice::Locator*);
typedef ::IceInternal::Handle< ::Ice::Locator> LocatorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Ice::Locator> LocatorPrx;
ICE_API void __patch(LocatorPtr&, const ::Ice::ObjectPtr&);
class LocatorRegistry;
bool operator==(const LocatorRegistry&, const LocatorRegistry&);
bool operator<(const LocatorRegistry&, const LocatorRegistry&);
ICE_API ::Ice::Object* upCast(::Ice::LocatorRe
/*
 * Copyright 2011, Haiku Inc. All rights reserved.
 * This file may be used under the terms of the MIT License.
 *
 * Authors:
 *		JÃ©rÃ´me Duval
 */
Chunk::Chunk(struct btrfs_chunk* chunk, fsblock_t offset)
	:
	fChunk(NULL),
	fInitStatus(B_OK)
	fChunkOffset = offset;
	fChunk = (struct btrfs_chunk*)malloc(sizeof(struct btrfs_chunk)
		+ chunk->StripeCount() * sizeof(struct btrfs_stripe));
	if (fChunk == NULL)
		fInitStatus = B_NO_MEMORY;
	memcpy(fChunk, chunk, sizeof(struct btrfs_chunk)
		+ chunk->StripeCount() * sizeof(struct btrfs_stripe));
	TRACE("chunk[0] length %llu owner %llu stripe_length %llu type %llu "
			"stripe_count %u sub_stripes %u sector_size %lu\n", chunk->Length(),
			chunk->Owner(), chunk->StripeLength(), chunk->Type(),
			chunk->StripeCount(), chunk->SubStripes(), chunk->SectorSize());
	for(int32 i = 0; i < chunk->StripeCount(); i++) {
		TRACE("chunk.stripe[%ld].physical %lld deviceid %lld\n", i,
			chunk->stripes[i].Offset(), chunk->stripes[i].DeviceID());
	}
Chunk
/*
 * Buffer.cpp
 *
 *  Created on: 03/10/2010
 *      Author: Nacho
 */
	Buffer::Buffer(){
		this->stream = NULL;
		this->longitudStream = 0;
	}
	Buffer::Buffer (char* stream, int longitudStream)
	{
		this->stream = NULL;
		this->longitudStream = 0;
		this->setStream(stream, longitudStream);
	}
	Buffer::~Buffer(){
		if (this->stream != NULL) delete []this->stream;
		this->stream = NULL;
		this->longitudStream = 0;
	}
	char* Buffer::getStream (int &longitudStream){
		longitudStream = this->longitudStream;
		return (this->clonarStream(this->stream, this->longitudStream));
	}
	void Buffer::setStream (char* stream, int longitudStream)
	{
		if ((stream != NULL) && (longitudStream > 0))
		{
			if (this->stream != NULL)
				delete[](this->stream);
			this->stream = this->clonarStream(stream, longitudStream);
			this->longitudStream = longitudStream;
		}
	}
/***********************************************************
 * Metodos privados de la clase
 *******************************************
IMPLEMENT_DYNCREATE(CLocatorDoc, CDocument)
BEGIN_MESSAGE_MAP(CLocatorDoc, CDocument)
	ON_COMMAND(ID_OutputLocatorStatusInfo, OnOutputlocatorstatusinfo)
END_MESSAGE_MAP()
CLocatorDoc::CLocatorDoc() : m_pLocator( 0 ) 
CLocatorDoc::~CLocatorDoc()
	ReleaseLocator();
BOOL CLocatorDoc::OnNewDocument()
	if (!CDocument::OnNewDocument())
		return FALSE;
	if( !CreateLocator() )
		return FALSE;
	return TRUE;
bool CLocatorDoc::CreateLocator()
	ASSERT( 0 == m_pLocator );
	if( 0 == m_pLocator )
	{
		m_pLocator = new MLocator;
		if( 0 == m_pLocator ) 
			return false;
	}
	else
		m_pLocator->Destroy();
	return m_pLocator->Create();
void CLocatorDoc::ReleaseLocator()
	m_pLocator->Destroy();
	delete m_pLocator;
	m_pLocator = 0;
void CLocatorDoc::Run()
	if( 0 != m_pLocator )
	{
		m_pLocator->Run();
	}
void CLocatorDoc::Serialize(CArchive& ar)
	if (ar.IsStoring())
	{
	}
	else
	{
	}
void CLocatorDoc::AssertValid() const
	CDocument::AssertValid();
void CLocatorDoc::Dump(CDumpContext& dc) const
	CDocument::
template<typename T>
class InputSample
    
public:
    
    InputSample()
    {};
    
    ~InputSample(){};
    
public:
    
    void setSampleID( const int sampleID_ )
    {
        sampleID    = sampleID_;
    };
    
    void setSample( const T & sample_ )
    {
        sample  = sample_;
    };
    
    const int & getSampleID() const
    {
        return sampleID;
    };
    
    const T & getSample() const
    {
        return sample;
    };
    
private:
    
    int     sampleID;
    T       sample;
};
typedef InputSample<ofPoint>  PointInputSampleT;
class Input
    
public:
    
    msa::controlfreak::ParameterGroup params;
    
    std::map< msa::controlfreak::Parameter*, std::pair<int, int> >  midiMappings;
    std::map< msa::controlfreak::Parameter*, std::string >          oscMappings;
    
    Input(){};
    virtual ~Input(){};
    
public:
    
    virtual void update(){};
    virtual const vector<PointInputSampleT> & getSamples() const {};
    virtual const vector<ofP
inline double random() {
    return (double)rand() / (double)RAND_MAX;
Sample::Sample(int num, SampleType sampleType, FilterType filterType) :
    _samples(nullptr), _num(num),
    _sampleType(sampleType), _filterType(filterType) {
    _samples = new Vector2[num];
    resample();
Sample::~Sample() {
    delete[] _samples;
Vector2& Sample::operator[](int index) {
    return _samples[index];
void Sample::resample() {
    switch (_sampleType) {
    case SampleType::RANDOM:
        randomSample();
        break;
    case SampleType::JITTERED:
        jitteredSample();
        break;
    }
    switch (_filterType) {
    case FilterType::BOX:
        boxFilter();
        break;
    case FilterType::TENT:
        tentFilter();
        break;
    }
void Sample::randomSample() {
    for (int i = 0; i < _num; ++i) {
        _samples[i].set(random(), random());
    }
void Sample::jitteredSample() {
    int index = 0;
    int sqrtNum = (int)sqrt(_num);
    for (int i = 0; i < sqrtNum; ++i) {
     
/*---------------------------------------------------------------------\
|                          ____ _   __ __ ___                          |
|                         |__  / \ / / . \ . \                         |
|                           / / \ V /|  _/  _/                         |
|                          / /__ | | | | | |                           |
|                         /_____||_| |_| |_|                           |
|                                                                      |
\---------------------------------------------------------------------*/
/** \file	zypp/parser/tagfile/RepoException.h
 *
*/
namespace zypp
  namespace repo
    /** \name Repository related exceptions.
    */
    /**
     * \short Exception for repository handling.
     */
    class RepoException : public Exception
    {
      public:
        RepoException();
        RepoException( const std::string & msg_r );
        RepoException( const RepoInfo & info );
        RepoException( cons

        virtual ~RepoException() throw();
        RepoInfo info()
        { return _info; }
        std::string alias()
        { return info().alias(); }
      protected:
        virtual std::ostream & dumpOn( std::ostream & str ) const;
      private:
        RepoInfo _info;
    };
    /**
     * The repository cache is not built yet
     * so you can't create the repostories from
     * the cache.
     */
    class RepoNotCachedException : public RepoException
    {
      public:
        RepoNotCachedException();
        RepoNotCachedException( const std::string & msg_r );
        RepoNotCachedException( const RepoInfo & info );
        RepoNotCachedException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * thrown when it was impossible to
     * determine one url for this repo.
     */
    class RepoNoUrlException : public RepoException
    {
      public:
        RepoNoUrlException();
        RepoNoUrlException( const std::string & msg_r );
        RepoN

        RepoNoUrlException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * thrown when it was impossible to
     * determine an alias for this repo.
     */
    class RepoNoAliasException : public RepoException
    {
      public:
        RepoNoAliasException();
        RepoNoAliasException( const std::string & msg_r );
        RepoNoAliasException( const RepoInfo & info );
        RepoNoAliasException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * Thrown when the repo alias is found to be invalid.
     */
    class RepoInvalidAliasException : public RepoException
    {
    public:
      RepoInvalidAliasException();
      RepoInvalidAliasException( const std::string & msg_r );
      RepoInvalidAliasException( const RepoInfo & info );
      RepoInvalidAliasException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * thrown when it was impossible to
     * match a repository
     */
    class RepoNotFoundExce

    {
      public:
        RepoNotFoundException();
        RepoNotFoundException( const std::string & msg_r );
        RepoNotFoundException( const RepoInfo & info );
        RepoNotFoundException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * Repository already exists and some unique
     * attribute can't be duplicated.
     */
    class RepoAlreadyExistsException : public RepoException
    {
      public:
        RepoAlreadyExistsException();
        RepoAlreadyExistsException( const std::string & msg_r );
        RepoAlreadyExistsException( const RepoInfo & info );
        RepoAlreadyExistsException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * thrown when it was impossible to
     * determine this repo type.
     */
    class RepoUnknownTypeException : public RepoException
    {
      public:
        RepoUnknownTypeException();
        RepoUnknownTypeException( const std::string & msg_r );
        RepoUnknownTypeException

        RepoUnknownTypeException( const RepoInfo & info, const std::string & msg_r );
    };
    /**
     * thrown when it was impossible to
     * use the raw metadata for this repo.
     */
    class RepoMetadataException : public RepoException
    {
      public:
        RepoMetadataException();
        RepoMetadataException( const std::string & msg_r );
        RepoMetadataException( const RepoInfo & info );
        RepoMetadataException( const RepoInfo & info, const std::string & msg_r );
    };
    /** \name Service related exceptions.
    */
    /** Base Exception for service handling.
     */
    class ServiceException : public Exception
    {
      public:
        ServiceException();
        ServiceException( const std::string & msg_r );
        ServiceException( const ServiceInfo & service_r );
        ServiceException( const ServiceInfo & service_r, const std::string & msg_r );
        virtual ~ServiceException() throw();
        ServiceInfo service()
        { return _serv

        std::string alias()
        { return service().alias(); }
     protected:
        virtual std::ostream & dumpOn( std::ostream & str ) const;
      private:
        ServiceInfo _service;
    };
    /** Service without alias was used in an operation.
     */
    class ServiceNoAliasException : public ServiceException
    {
      public:
        ServiceNoAliasException();
        ServiceNoAliasException( const std::string & msg_r );
        ServiceNoAliasException( const ServiceInfo & service_r );
        ServiceNoAliasException( const ServiceInfo & service_r, const std::string & msg_r );
    };
    /**
     * Thrown when the repo alias is found to be invalid.
     */
    class ServiceInvalidAliasException : public ServiceException
    {
    public:
      ServiceInvalidAliasException();
      ServiceInvalidAliasException( const std::string & msg_r );
      ServiceInvalidAliasException( const ServiceInfo & info );
      ServiceInvalidAliasException( const ServiceInfo & info, const

    };
    /** Service already exists and some unique attribute can't be duplicated.
     */
    class ServiceAlreadyExistsException : public ServiceException
    {
      public:
        ServiceAlreadyExistsException();
        ServiceAlreadyExistsException( const std::string & msg_r );
        ServiceAlreadyExistsException( const ServiceInfo & service_r );
        ServiceAlreadyExistsException( const ServiceInfo & service_r, const std::string & msg_r );
    };
    /** Service has no or invalid url defined.
     */
    class ServiceNoUrlException : public ServiceException
    {
      public:
        ServiceNoUrlException();
        ServiceNoUrlException( const std::string & msg_r );
        ServiceNoUrlException( const ServiceInfo & service_r );
        ServiceNoUrlException( const ServiceInfo & service_r, const std::string & msg_r );
    };
    /** \name PLUGIN Service related exceptions.
    */
    /** PLUGIN Service related exceptions
     */
    class ServicePluginException : publ

    {
      public:
        ServicePluginException();
        ServicePluginException( const std::string & msg_r );
        ServicePluginException( const ServiceInfo & service_r );
        ServicePluginException( const ServiceInfo & service_r, const std::string & msg_r );
    };
    /** Service plugin has trouble providing the metadata but this should not be treated as error.
     */
    class ServicePluginInformalException : public ServicePluginException
    {
      public:
        ServicePluginInformalException();
        ServicePluginInformalException( const std::string & msg_r );
        ServicePluginInformalException( const ServiceInfo & service_r );
        ServicePluginInformalException( const ServiceInfo & service_r, const std::string & msg_r );
    };
    /** Service plugin is immutable.
     */
    class ServicePluginImmutableException : public ServicePluginException
    {
      public:
        ServicePluginImmutableException();
        ServicePluginImmutableException( const 
/*
 * $Id$
 *
 *
 * Distributed under the OpenDDS License.
 */
ACE_INLINE
OpenDDS::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",6);
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find(RepoId key) const
  DBG_ENTRY_LVL("RepoIdSetMap","find",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0) {
    return 0;
  }
  return value._retn();
ACE_INLINE size_t
OpenDDS::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",6);
  return this->map_.size();
ACE_INLINE OpenDDS::DCPS::RepoIdSet*
OpenDDS::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",6);
  RepoIdSet_rch value;
  if (OpenDDS::DCPS::find(map_, key, value) != 0) {
    value = new RepoIdSet();
    if (OpenDDS::DCPS::bind(map_, key, value) != 0) {
      ACE_ERROR((LM_ERROR,
                 "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                 "the RepoIdSetMap.\n"));
      retur
namespace {
	using WONMsg::SmallMessage;
	using WONMsg::SMsgCommDumpStatistics;
};
SMsgCommDumpStatistics::SMsgCommDumpStatistics()
	SetServiceType(WONMsg::SmallCommonService);
	SetMessageType(WONMsg::SmallCommDumpStatistics);
SMsgCommDumpStatistics::~SMsgCommDumpStatistics(void)
{}
SMsgCommDumpStatistics::SMsgCommDumpStatistics(const SMsgCommDumpStatistics& theMsgR) :
    SmallMessage(theMsgR)
{}
SMsgCommDumpStatistics::SMsgCommDumpStatistics(const SmallMessage& theMsgR) : 
    SmallMessage(theMsgR)
	Unpack();
SMsgCommDumpStatistics& SMsgCommDumpStatistics::operator =(const SMsgCommDumpStatistics& theMsgR)
	if(this != &theMsgR)
		SmallMessage::operator=(theMsgR);
	return *this;
void* SMsgCommDumpStatistics::Pack(void)
	WTRACE("SMsgCommDumpStatistics::Pack");
	SetServiceType(WONMsg::SmallCommonService);
	SetMessageType(WONMsg::SmallCommDumpStatistics);
	SmallMessage::Pack();
	return GetDataPtr();
void SMsgCommDumpStatistics::Unpack(void)
	WTRACE("SMsgCommDumpStatistics::Unpack");
	Smal
ACE_INLINE
TAO::DCPS::RepoIdSetMap::RepoIdSetMap()
  DBG_ENTRY_LVL("RepoIdSetMap","RepoIdSetMap",5);
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find",5);
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      return 0;
    }
  return value._retn();
ACE_INLINE size_t
TAO::DCPS::RepoIdSetMap::size() const
  DBG_ENTRY_LVL("RepoIdSetMap","size",5);
  return this->map_.current_size();
ACE_INLINE TAO::DCPS::RepoIdSet*
TAO::DCPS::RepoIdSetMap::find_or_create(RepoId key)
  DBG_ENTRY_LVL("RepoIdSetMap","find_or_create",5);
  RepoIdSet_rch value;
  if (this->map_.find(key, value) != 0)
    {
      value = new RepoIdSet();
      if (this->map_.bind(key, value) != 0)
        {
           ACE_ERROR((LM_ERROR,
                      "(%P|%t) ERROR: Unable to insert new RepoIdSet into "
                      "the RepoIdSetMap.\n"));
           return 0;
        }
    }
  return value._retn();
ACE_INLINE TAO::DCPS::Repo
UpdateableServerInfo::UpdateableServerInfo (Locator_Repository* repo,
                                            const ACE_CString& name,
                                            int pid)
: repo_(repo),
  si_(repo->get_active_server (name,pid)),
  needs_update_(false)
UpdateableServerInfo::UpdateableServerInfo (Locator_Repository* repo,
                                            const Server_Info_Ptr& si,
                                            bool reset_start_count)
: repo_(repo),
  si_(si),
  needs_update_(false)
  if (reset_start_count)
    {
      needs_update_ = repo_ != 0;
      si_->active_info ()->start_count_ = 0;
    }
UpdateableServerInfo::UpdateableServerInfo (UpdateableServerInfo& other)
  :repo_ (other.repo_),
   si_ (other.si_),
   needs_update_(other.needs_update_)
  other.needs_update_ = false;
UpdateableServerInfo::~UpdateableServerInfo ()
  update_repo ();
void
UpdateableServerInfo::server_info (const Server_Info_Ptr& si)
  this->si_ = si;
void
UpdateableSe
/******************************************************************************
 * @file     main.h
 * 
 * @brief    
 * 
 * @date     01-12-2010
 * @author   Rafal Kukla
 ******************************************************************************
 *            Copyright (C) 2010 Rafal Kukla  ( rkdevel@gmail.com )
 *        This file is a part of rs232testng project and is released 
 *         under the terms of the license contained in the file LICENSE
 ******************************************************************************
 */
class QStreamManager: public QObject
    Q_OBJECT
private:
    StreamItem*             InStream;
    StreamItem*             InModStream;
    StreamItem*             SourceStream;
    StreamItem*             OutModStream;
    StreamItem*             OutStream;
private:
    void buildStream()
    {
        StreamItem* endStream = OutStream;
        if (OutModStream) { OutModStream->Connect(endStream); endStream = OutModStream; }
        if (SourceStrea
class LimitedV1_kNCN: public Classifier {
public:
	static LoggerPtr logger;
	Distance** distances;
	Distance** nndists;
	SampleSet centroids;
	float percentMaxRobustRank;
	LimitedV1_kNCN(const int k, const int nrTrainSamples, const int nrTestSamples, 
		const int nrClasses, const int nrDims, const float percentMRobust);
	~LimitedV1_kNCN();
	void preprocess(const SampleSet& trainSet, const SampleSet& testSet);
	void classify(const SampleSet& trainSet, const SampleSet& testSet);
	int classifySample(const SampleSet& trainSet, const Sample& testSample,
		Distance* testSampleDists, Distance* testSampleNNdists, const int k);
	int classifySample(const SampleSet& trainSet, const Sample& testSample);
private:
	LimitedV1_kNCN();
	const Distance find1NNLimited(const SampleSet& trainSet, const Sample& testSample,
		const Distance* testSampleDists, const int maximalRobustRank);
	void findkNCNLearn(const SampleSet& trainSet, const Sample& testSample,
		Distance* testSampleDists, Distance* testSample
void doDalitz3(Int_t seed = 9){
   gSystem->Load("libPhysics.so");
   gSystem->Load("libRooFit.so");
  gROOT->LoadMacro("twoDStyle.C");
  gROOT->LoadMacro("histoUtils.C");
  twoDStyle();
  gROOT->LoadMacro("AbsComplexBrackets.C+");
  gROOT->LoadMacro("AbsComplex.C+");
  gROOT->LoadMacro("AbsComplexPdf.C+");
  gROOT->LoadMacro("dataThrowerAway.C+");
  gROOT->LoadMacro("ComplexProxy.C+");
  gROOT->LoadMacro("ComplexBW.C+");
  gROOT->LoadMacro("DcyAmplitude.C+");
  gROOT->LoadMacro("DcyGSAmplitude.C+");
  gROOT->LoadMacro("DcyNonRes.C+");
  gROOT->LoadMacro("DbleAmplitude.C+");
  gROOT->LoadMacro("Resonance.C+");
  gROOT->LoadMacro("ComplexSum.C+");
  gROOT->LoadMacro("ComplexProd.C+");
  gROOT->LoadMacro("RooAbsPhaseSpace.C+");
  gROOT->LoadMacro("Roo3BodyPhaseSpace.C+");
  gROOT->LoadMacro("Calculate4BodyProps.h+");
  gROOT->LoadMacro("SpinFactorThreeBody.C+");
  gROOT->LoadMacro("SpinFactor.C+");
  gROOT->LoadMacro("SpinFactors.C+");
  gROOT->LoadMacro("BlattWeisskopf.C+");
  gROOT->Lo
using namespace interpreter::handlers;
using namespace ressource;
Loader::Loader()
{}
Loader& Loader::get_instance()
  static Loader instance;
  return instance;
void Loader::init_handlers_manager(interpreter::OpcodeManager& opm)
  opm.register_opcode_handler(OP_HALT, halt_handler);
  opm.register_opcode_handler(OP_PUSH, push_handler);
  opm.register_opcode_handler(OP_PUSHR, pushr_handler);
  opm.register_opcode_handler(OP_POP, pop_handler);
  opm.register_opcode_handler(OP_POPR, popr_handler);
  opm.register_opcode_handler(OP_ADD, add_handler);
  opm.register_opcode_handler(OP_SUB, sub_handler);
  opm.register_opcode_handler(OP_MUL, mul_handler);
  opm.register_opcode_handler(OP_DIV, div_handler);
  opm.register_opcode_handler(OP_MOD, mod_handler);
  opm.register_opcode_handler(OP_CALL, call_handler);
  opm.register_opcode_handler(OP_CALLR, callr_handler);
  opm.register_opcode_handler(OP_RET, ret_handler);
  opm.register_opcode_handler(OP_SAVE, save_handler);
  opm.register_opcode_ha
namespace glm
	namespace virtrev_glmext
	{
		namespace xstream
		{
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec2<T> const & vec)
			{
				stream << "<glm_vec2 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec3<T> const & vec)
			{
				stream << "<glm_vec3 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "/>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tvec4<T> const & vec)
			{
				stream << "<glm_vec4 ";
				stream << "x=\"" << vec.x << "\" ";
				stream << "y=\"" << vec.y << "\" ";
				stream << "z=\"" << vec.z << "\" ";
				stream << "w=\"" << vec.w << "\" ";
				stream << "/>";
				return stream;
			}
			

			std::ostream & operator << (std::ostream & stream, glm::detail::tmat2x2<T> const & mat)
			{
				stream << "<glm_mat2>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat2>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat3x3<T> const & mat)
			{
				stream << "<glm_mat3>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << g

				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 2)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 2)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 2)[2] << "\" ";
				stream << "/>" << std::endl;
				stream << "</glm_mat3>";
				return stream;
			}
			template<typename T>
			std::ostream & operator << (std::ostream & stream, glm::detail::tmat4x4<T> const & mat)
			{
				stream << "<glm_mat4>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 0)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 0)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 0)[2] << "\" ";
				stream << "w=\"" << glm::row(mat, 0)[3] << "\" ";
				stream << "/>" << std::endl;
				stream << "<row ";
				stream << "x=\"" << glm::row(mat, 1)[0] << "\" ";
				stream << "y=\"" << glm::row(mat, 1)[1] << "\" ";
				stream << "z=\"" << glm::row(mat, 1)[2] << "\" ";
				stream << "w=\"" <<
/***************************************************************************
                             SRC/mixmod/Kernel/IO/CompositeSample.h  description
    copyright            : (C) MIXMOD Team - 2001-2016
    email                : contact@mixmod.org
 ***************************************************************************/
/***************************************************************************
    This file is part of MIXMOD
    
    MIXMOD is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    MIXMOD is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General 

***************************************************************************/
/**@file XEMCompositeSample.h
 * @brief Composite sample class for heterogeneous data.
 * @author Parmeet Bhatia
 */
namespace XEM {
class BinarySample;
class GaussianSample;
class CompositeSample : public Sample {
public:
	CompositeSample();
	CompositeSample(Sample*, Sample*);
	/**type-cast overloading for Binary sample*/
	operator BinarySample*();
	/**type-cast overloading for Gaussian sample*/
	operator GaussianSample*();
	/** get gaussian sample*/
	virtual GaussianSample* getGaussianSample() const {
		return (GaussianSample*) _sampleComponent[1];
	}
	/** get Binary sample*/
	virtual BinarySample* getBinarySample() const {
		return (BinarySample*) _sampleComponent[0];
	}
	virtual ~CompositeSample();
protected:
	vector<Sample*> _sampleComponent;
};
inline CompositeSample::operator BinarySample *() {
	return _sampleComponent[0]->getBinarySample();
inline CompositeSample::operator GaussianSample *() {
	return
namespace {
  hsize_t g_chunkSize = 0;
namespace O2OTranslator {
hsize_t 
CvtOptions::chunkSize(const hdf5pp::Type& type) const
  return chunkSize(m_chunkSizeBytes, type, ::g_chunkSize);
void 
CvtOptions::setChunkSize(hsize_t chunkSize)
  ::g_chunkSize = chunkSize;
/**
 *  @brief Returns HDF5 chunk size counted in objects of given HDF5 type.
 *
 *  This method calculates chunk size like it is described above but
 *  instead of taking into account value set with the setChunkSize() method
 *  it uses additional parameter.
 */
hsize_t
CvtOptions::chunkSize(hsize_t chunkSizeBytes, const hdf5pp::Type& type, hsize_t chunkSize)
  size_t obj_size = type.size();
  hsize_t chunk = chunkSize > 0 ? chunkSize : chunkSizeBytes / obj_size;
  if (chunk > ::max_objects_per_chunk) {
    chunk = ::max_objects_per_chunk;
  } else if (chunk < ::min_objects_per_chunk) {
    chunk = ::min_objects_per_chunk;
    if (chunk*obj_size > ::abs_max_chunk_size) {
      chunk = ::abs_max_chunk_size / obj_size;
      
/*
 * factory.h
 *
 *  Created on: Oct 22, 2009
 *      Author: sturm
 */
namespace articulation_models {
typedef boost::shared_ptr< GenericModel > GenericModelPtr;
typedef std::vector< GenericModelPtr > GenericModelVector;
class GenericModelFactory {
public:
	virtual GenericModelPtr createModel(articulation_msgs::TrackMsgConstPtr trackMsg) = 0;
	virtual GenericModelPtr createModel(const articulation_msgs::TrackMsg& trackMsg) = 0;
	virtual GenericModelPtr createModel(articulation_msgs::ModelMsgConstPtr modelMsg) = 0;
	virtual GenericModelPtr createModel(const articulation_msgs::ModelMsg& modelMsg) = 0;
	virtual std::string getLongName() = 0;
	virtual std::string getClassName() = 0;
};
template<class T>
class SingleModelFactory: public GenericModelFactory {
public:
	std::string longname;
	std::string classname;
	SingleModelFactory(std::string longname): longname(longname),classname(typeid(T).name()) {}
	GenericModelPtr createModel(articulation_msgs::TrackMsgConstPtr trackMsg) {
		Generi

		model->setTrack( *trackMsg );
		return model;
	}
	GenericModelPtr createModel(const articulation_msgs::TrackMsg& trackMsg) {
		GenericModelPtr model(new T());
		model->setTrack( trackMsg );
		return model;
	}
	GenericModelPtr createModel(articulation_msgs::ModelMsgConstPtr modelMsg) {
		GenericModelPtr model(new T());
		model->setModel( *modelMsg );
		return model;
	}
	GenericModelPtr createModel(const articulation_msgs::ModelMsg& modelMsg) {
		GenericModelPtr model(new T());
		model->setModel( modelMsg );
		return model;
	}
	std::string getLongName() {
		return longname;
	}
	std::string getClassName() {
		return classname;
	}
};
class MultiModelFactory {
public:
	static MultiModelFactory instance;
	std::vector<GenericModelFactory*> all_factories;
	std::vector<GenericModelFactory*> factories;
	MultiModelFactory();
	GenericModelVector createModels(articulation_msgs::TrackMsgConstPtr trackMsg);
	GenericModelVector createModels(const articulation_msgs::TrackMsg& trackMsg);
	GenericMode
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
using namespace repo::gui;
using namespace repo::gui::widget;
const QString RolesManagerWidget::COLUMNS_SETTINGS = "RolesManagerWidgetColumnsSettings";
RolesManagerWidget::RolesManagerWidget(QWidget *parent)
    : EditableTreeWidget(parent)
    QList<QString> headers = {
        tr("Role"),
        tr("Database"),
        tr("Permissions"),
        

        tr("Inherited Roles"),
        tr("Modules")};
    FilterableTreeWidget *filterableTree = getFilterableTree();
    filterableTree->restoreHeaders(headers, COLUMNS_SETTINGS);
    filterableTree->setRootIsDecorated(false);
    clear();
RolesManagerWidget::~RolesManagerWidget()
     getFilterableTree()->storeHeaders(COLUMNS_SETTINGS);
void RolesManagerWidget::addRole(
        const repo::core::model::RepoRole &role,
        const repo::core::model::RepoRoleSettings &settings)
    QList<QStandardItem *> row;
    repo::gui::primitive::RepoStandardItem *item = nullptr;
    QVariant var;
    var.setValue(role);
    item = new repo::gui::primitive::RepoStandardItem(role.getName());
    item->setData(var);    
    QPixmap px(32,32);
    if (!settings.getColor().empty())
    {
        px.fill(repo::gui::primitive::RepoColor::fromHex(settings.getColor()));
    }
    else
    {
    }
    item->setIcon(QIcon(px));
    row.append(item);
    row.append(new repo::gui::primitive::RepoStandardI

    row.append(new repo::gui::primitive::RepoStandardItem(role.getProjectAccessRights().size()));
    row.append(new repo::gui::primitive::RepoStandardItem(role.getPrivileges().size()));
    row.append(new repo::gui::primitive::RepoStandardItem(role.getInheritedRoles().size()));
    QVariant qsetting;
    qsetting.setValue(settings);
    item = new repo::gui::primitive::RepoStandardItem(settings.getModules().size());
    item->setData(qsetting);
    row.append(item);
    getFilterableTree()->addTopLevelRow(row);
void RolesManagerWidget::edit()
    showEditDialog(
                getRole(),
                getRoleSettings(),
                EditableTreeWidget::Action::EDIT);
void RolesManagerWidget::edit(const QModelIndex &index)
    showEditDialog(
                getRole(index),
                getRoleSettings(index),
                EditableTreeWidget::Action::EDIT);
repo::core::model::RepoRole RolesManagerWidget::getRole() const
    return getRole(getFilterableTree()->getCurrentInd

repo::core::model::RepoRole RolesManagerWidget::getRole(
        const QModelIndex &index) const
    repo::core::model::RepoRole role;
    if (index.isValid())
    {
        QModelIndex roleIndex = index.sibling(index.row(), (int) Columns::ROLE);
        role = roleIndex.data(Qt::UserRole + 1).value<repo::core::model::RepoRole>();
    }
    return role;
repo::core::model::RepoRoleSettings RolesManagerWidget::getRoleSettings() const
    return getRoleSettings(getFilterableTree()->getCurrentIndex());
repo::core::model::RepoRoleSettings RolesManagerWidget::getRoleSettings(
        const QModelIndex &index) const
    repo::core::model::RepoRoleSettings settings;
    if (index.isValid())
    {
        QModelIndex roleSettingsIndex = index.sibling(index.row(), (int) Columns::MODULES);
        settings = roleSettingsIndex.data(Qt::UserRole + 1).value<repo::core::model::RepoRoleSettings>();
    }
    return settings;
void RolesManagerWidget::refresh(
        const repo::core::model::RepoRole 

        const repo::core::model::RepoRoleSettings &settings,
        repo::worker::RepoWorkerRoles::Command command)
    if (isReady())
    {
        clear();
        repo::worker::RepoWorkerRoles* worker =
                new repo::worker::RepoWorkerRoles(
                    token,
                    controller,
                    database,
                    role,
                    settings,
                    command);
        QObject::connect(
                    worker, &repo::worker::RepoWorkerRoles::roleFetched,
                    this, &RolesManagerWidget::addRole);
        connectAndStartWorker(worker, getFilterableTree()->getProgressBar());
    }
void RolesManagerWidget::setDBConnection(
        repo::RepoController *controller,
        const repo::RepoController::RepoToken* token,
        const std::string& database)
    this->controller = controller;
    this->token = token;
    this->database = database;
void RolesManagerWidget::removeItem()
    repo::core::model:

    repo::core::model::RepoRoleSettings settings = this->getRoleSettings();
    switch(QMessageBox::warning(this,
                                tr("Remove role?"),
                                tr("Are you sure you want to remove '") + QString::fromStdString(role.getName()) + "'?",
                                tr("&Yes"),
                                tr("&No"),
                                QString::null, 1, 1))
    {
        refresh(role, settings, repo::worker::RepoWorkerRoles::Command::DROP);
        break;
		repoLog("Remove role warning box cancelled by user.");
        break;
    }
void RolesManagerWidget::showEditDialog(
        const repo::core::model::RepoRole &role,
        const repo::core::model::RepoRoleSettings &settings,
        const EditableTreeWidget::Action action)
    dialog::RoleDialog roleDialog(
                role,
                settings,
                QString::fromStdString(database),
                databasesWithProjects,
                actio
ChunkManager::ChunkManager()
ChunkManager::~ChunkManager()
void ChunkManager::Update(const UpdateData & updateobject)
	Chunk * c = FirstChunk;
	bool GoingRight = true;
	while (c != NULL)
	{
		c->Update(updateobject);
		if (GoingRight && c->getRight() != NULL)
		{
			c = c->getRight();
		}
		else if (!GoingRight && c->getLeft() != NULL)
		{
			c = c->getLeft();
		}
		else
		{
			c = c->getBottom();
			GoingRight = !GoingRight;
		}
	}
	sf::Vector2f v = WindowManager::getInstance().getCameraPosition();
	while (v.x < ActiveChunk->getPurePosition().x
		|| v.y < ActiveChunk->getPurePosition().y
		|| v.x >= ActiveChunk->getPurePosition().x + ActiveChunk->getSize()
		|| v.y >= ActiveChunk->getPurePosition().y + ActiveChunk->getSize())
	{
		if (v.x < ActiveChunk->getPurePosition().x)
		{
			if (ActiveChunk->getLeft() != nullptr)
				ActiveChunk = ActiveChunk->getLeft();
			else
				WindowManager::getInstance().setCameraPosition(sf::Vector2f{ ActiveChunk->getPurePosition().x, WindowManager::getI

		}
		else if (v.y < ActiveChunk->getPurePosition().y)
		{
			if (ActiveChunk->getTop() != nullptr)
				ActiveChunk = ActiveChunk->getTop();
			else
				WindowManager::getInstance().setCameraPosition(sf::Vector2f{ WindowManager::getInstance().getCameraPosition().x, ActiveChunk->getPurePosition().y });
		}
		else if (v.x > ActiveChunk->getPurePosition().x + ActiveChunk->getSize())
		{
			if (ActiveChunk->getRight() != nullptr)
				ActiveChunk = ActiveChunk->getRight();
			else
				WindowManager::getInstance().setCameraPosition(sf::Vector2f{ ActiveChunk->getPurePosition().x + ActiveChunk->getSize(), WindowManager::getInstance().getCameraPosition().y });
		}
		else if (v.y > ActiveChunk->getPurePosition().y + ActiveChunk->getSize())
		{
			if (ActiveChunk->getBottom() != nullptr)
				ActiveChunk = ActiveChunk->getBottom();
			else
				WindowManager::getInstance().setCameraPosition(sf::Vector2f{ WindowManager::getInstance().getCameraPosition().x, ActiveChunk->getPurePosition().y + ActiveC
/*
 * chunk.c
 *  Created on: 2012-12-25
 *      Author: qianqians
 * chunk 
 */
struct chunk * _create_chunk(struct mempage_heap * _heap, size_t size){
	size = (size + 4095)/4096*4096;
	struct chunk * _chunk = (struct chunk*)VirtualAlloc(0, size, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	if (_chunk != 0){
		_chunk->count.store(0);
		_chunk->_heap = _heap;
		_chunk->size = size;
		_chunk->flag = _flag;
		_chunk->rec_flag = 0;
		_chunk->slide = sizeof(struct chunk);
	}
	return _chunk;
void * _brk(struct chunk * _chunk, size_t size){
	void * ret = 0;
	if ((_chunk->slide + size) <= _chunk->size){
		ret = (void*)((char*)_chunk + _chunk->slide);
		_chunk->slide += size;
	}
	return ret;
struct chunk * _merge_chunk(struct chunk * _c1, struct chunk * _c2){
	struct chunk * ret = 0;
	if ((char*)_c1 == ((char*)_c2 + _c2->size)){
		ret = _c2;
		ret->size += _c1->size;
	}
	else if (((char*)_c1 + _c1->size) == (char*)_c2){
		ret = _c1;
		ret->size += _c2->size;
	}
	return ret;
void * _malloc(struct 

	if (_chunk->count.load() == 0){
		_chunk->slide = sizeof(struct chunk);
	}
	void * ret = 0;
	_chunk->count++;
	size_t newsize = sizeof(struct chunk*) + sizeof(size_t) + size;
	if ((_chunk->slide + newsize) <= _chunk->size){
		struct chunk ** tmp = (struct chunk **)((char*)_chunk + _chunk->slide);
		_chunk->slide += newsize;
		*tmp = _chunk;
		size_t * _size = (size_t*)++tmp;
		*_size = size;
		ret = (void*)++_size;
	}
	if (ret == 0){
		_chunk->count--;
	}
	return ret;
void * _realloc(void * mem, size_t size){
	void * ret = 0;
	struct chunk * _chunk = *(struct chunk **)((char*)mem - sizeof(size_t) - sizeof(struct chunk*));
	if (_chunk->flag != _flag){
		abort();
	}
	size_t oldsize = *(size_t *)((char*)mem - sizeof(size_t));
	size_t slide = (char*)mem + oldsize - (char*)_chunk;
	if (oldsize >= size){
		if (slide == _chunk->slide){
			_chunk->slide -= (oldsize - size);
		}
		return mem;
	}
	if (slide == _chunk->slide){
		size_t increment = size - oldsize;
		if (increment < (_chunk->size
/* DO NOT EDIT THIS FILE!  It was generated by utils/apivergen.abc. */
namespace avmplus {
const char* const kApiVersionNames[kApiVersion_count] = {
    "VM_ALLVERSIONS", 
    "AIR_1_0", 
    "FP_10_0", 
    "AIR_1_5", 
    "AIR_1_5_1", 
    "FP_10_0_32", 
    "AIR_1_5_2", 
    "FP_10_1", 
    "AIR_2_0", 
    "AIR_2_5", 
    "FP_10_2", 
    "AIR_2_6", 
    "SWF_12", 
    "AIR_2_7", 
    "SWF_13", 
    "AIR_3_0", 
    "SWF_14", 
    "AIR_3_1", 
    "SWF_15", 
    "AIR_3_2", 
    "SWF_16", 
    "AIR_3_3", 
    "SWF_17", 
    "AIR_3_4", 
    "SWF_18", 
    "AIR_3_5", 
    "SWF_19", 
    "AIR_3_6", 
    "VM_INTERNAL"
};
uint32_t const kApiVersionSeriesMembership[kApiVersion_count] = {
    (1<<kApiVersionSeries_AIR)|(1<<kApiVersionSeries_FP),
    (1<<kApiVersionSeries_AIR),
    (1<<kApiVersionSeries_FP),
    (1<<kApiVersionSeries_AIR),
    (1<<kApiVersionSeries_AIR),
    (1<<kApiVersionSeries_FP),
    (1<<kApiVersionSeries_AIR),
    (1<<kApiVersionSeries_FP),
    (1<<kApiVersionSeries_AIR),
void Profiler::BeginSample(const std::string & sampleName)
	if (sampleName != "")
	{
		Sample sample(sampleName);
		m_sampleStack.push_back(sample);
	}
	else
	{
		std::cerr << "Profiler Error: Sample name cannot be an empty string!" << '\n';
	}
void Profiler::EndSample()
	if (m_sampleStack.size() != 0)
	{
		const Sample& sample = GetTopMostSample();
		m_sampleData[sample.GetName()] = sample.GetElapsedTime();
		
		const std::string currentString = GetAllSampleDataAsString();
		m_sampleDataStringStream.str(std::string());
		for (size_t tabs = 1; tabs < m_sampleStack.size(); ++tabs)
		{
			m_sampleDataStringStream << '\t';
		}
		m_sampleDataStringStream << sample.GetName() << ": " << sample.GetElapsedTime() << "s" << '\n';
		m_sampleDataStringStream << currentString;
		m_sampleStack.pop_back();
	}
void Profiler::Clear()
	m_sampleStack.clear();
	m_sampleData.clear();
	m_sampleDataStringStream.str(std::string());
float Profiler::GetSampleData(const std::string & sampleName)
	auto sampleData
namespace klib{
namespace pattern{
sync_invoke::sync_invoke(void)
sync_invoke::~sync_invoke(void)
    CloseHandle(m_hThread);
bool sync_invoke::start()
    m_hThread = (HANDLE) _beginthreadex(NULL,
        0,
        &sync_invoke::workthread,
        this,
        0,
        NULL);
    
    return true;
bool sync_invoke::stop()
    PostThreadMessage(m_dwThreadID, WM_QUIT, 0, 0);
    WaitForSingleObject(m_hThread, INFINITE);
    return true;
unsigned int WINAPI sync_invoke::workthread(void* param)
    sync_invoke* pBgWorker = (sync_invoke*) param;
    pBgWorker->m_dwThreadID = GetCurrentThreadId();
    MSG msg;
    BOOL bRet = FALSE;
    
    do {
        bRet = GetMessage(&msg, NULL, 0, 0);
        if (bRet) 
        {
            if (msg.message == UM_CALL) 
            {
                std::function<void()>* fun = (std::function<void()>*) msg.wParam;
                (*fun)();
            }
        }
        else
        {
            break;
        }
    } while (bRet);
    return 0
repoEdit::repoEdit(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::repoEdit) {
    qInfo() << "repoEdit::repoEdit: constructor";
    ui->setupUi(this);
    this->setWindowFlags(this->windowFlags().operator ^=(Qt::WindowContextHelpButtonHint));
repoEdit::~repoEdit()
    delete ui;
void repoEdit::recieveData(Repository repo, int currentRow, bool newRepo) {
    qInfo() << "repoEdit::recieveData: start";
    newR = newRepo;
    Row = currentRow;
    if(newRepo) {
        ui->repoName->setText(tr("ÐÐ¾Ð²ÑÐ¹ ÑÐµÐ¿Ð¾Ð·Ð¸ÑÐ¾ÑÐ¸Ð¹"));
        ui->repoType->setCurrentIndex(0);
        ui->repoUrl->clear();
    } else {
        ui->repoName->setText(repo.name);
        ui->repoType->setCurrentIndex(repo.type);
        ui->repoUrl->setText(repo.url);
    }
    this->open();
void repoEdit::on_repoType_currentIndexChanged(int index) {
    qInfo() << "repoEdit::on_repoType_currentIndexChanged: index " << index;
    if(index == 0)
    else
void repoEdit::on_saveButton_clicked() {
    qInfo() << "repoEdit::
namespace inferno{
namespace python{
namespace bp = boost::python;
template<class MODEL, class T, class TAG>
struct ModelMapVisitorNumpy1DApi : 
    public bp::def_visitor<ModelMapVisitorNumpy1DApi<MODEL, T, TAG> >
    friend class bp::def_visitor_access;
    typedef MODEL Model;
    typedef typename TAG:: template Map<T>::type MapType;
    template <class classT>
    void visit(classT& c) const
    {
        c
            .def(
                "view",
                vigra::registerConverters(&view), 
                RetValPol<CustWardPost<0,1,bp::return_by_value> >()
            )
        ;
    }
    static vigra::NumpyAnyArray
    view(MapType & map){
        T * dataPtr = &map[0];
        const auto numpyType = vigra::NumpyArrayValuetypeTraits<T>::typeCode;
        npy_intp strides[1] = {sizeof(T)};
        vigra::TinyVector<uint64_t, 1> shape( TAG::size(map.model()));
        auto  arrayPythonPtr = vigra::constructNumpyArrayFromData(shape, strides, numpyType, dataPtr);
       
   

        return array;
    } 
};
template<class MODEL, class T, class TAG>
struct ModelMapVisitorOptionalApi : 
    public bp::def_visitor<ModelMapVisitorOptionalApi<MODEL, T, TAG> >
    friend class bp::def_visitor_access;
    typedef MODEL Model;
    typedef typename TAG:: template Map<T>::type MapType;
    typedef ModelMapVisitorNumpy1DApi<MODEL, T, TAG> Numpy1dApi;
    template <class classT>
    void visit(classT& c) const
    {
        c
            .def(Numpy1dApi())
        ;
    }
};
template<class MODEL, class T, class TAG>
struct ModelMapVisitorRequiredApi : 
    public bp::def_visitor<ModelMapVisitorRequiredApi<MODEL, T, TAG> >
    friend class bp::def_visitor_access;
    typedef MODEL Model;
    typedef typename TAG:: template Map<T>::type MapType;
    typedef ModelMapVisitorOptionalApi<MODEL, T, TAG> OptionalApi;
    template <class classT>
    void visit(classT& c) const
    {
        c
            .def(bp::init<const Model &>())
            .def(bp::init<const Model &, 

            .def("assign",&assign)
            .def("assign",&assignWithVal)
            .def("model",&MapType::model, bp::return_internal_reference<>())
            .def(OptionalApi())
        ;
    }
    static void assign(MapType & map, const Model & model){
        map.assign(model);
    }
    static void assignWithVal(
        MapType & map, 
        const Model & model,
        const T  & val
    ){
        map.assign(model, val);
    }
};
template< class MODEL>
struct ModelMapExporter{
    typedef MODEL Model;
    typedef ModelMapExporter<Model> Self;
    typedef models::ModelFactorItems<Model> ModelFactors;
    typedef models::ModelUnaryItems<Model> ModelUnaries;
    typedef models::ModelVariableItems<Model> ModelVariables;
    template<class T, class TAG>
    static void exportModelMapT(
        const std::string & modelName,
        const std::string & dtypeName
    ){
        auto clsName = modelName + TAG::name() + std::string("Map_") + dtypeName;
        typedef typename 
namespace base {
namespace trace_event {
class MemoryAllocatorDump;
class ProcessMemoryDump;
namespace skia {
class SK_API SkiaTraceMemoryDumpImpl : public SkTraceMemoryDump {
 public:
  SkiaTraceMemoryDumpImpl(
      base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
      base::trace_event::ProcessMemoryDump* process_memory_dump);
  SkiaTraceMemoryDumpImpl(
      const std::string& dump_name_prefix,
      base::trace_event::MemoryDumpLevelOfDetail level_of_detail,
      base::trace_event::ProcessMemoryDump* process_memory_dump);
  ~SkiaTraceMemoryDumpImpl() override;
  void dumpNumericValue(const char* dumpName,
                        const char* valueName,
                        const char* units,
                        uint64_t value) override;
  void setMemoryBacking(const char* dumpName,
                        const char* backingType,
                        const char* backingObjectId) override;
  void setDiscardableMemoryBacking(
      const char* dumpName,
      c
namespace TAO
  namespace DCPS
  {
    class RepoIdSetMap;
    class TAO_DdsDcps_Export RepoIdSetMap
    {
      public:
        typedef ACE_Hash_Map_Manager_Ex<RepoId,
                                        RepoIdSet_rch,
                                        ACE_Hash<RepoId>,
                                        ACE_Equal_To<RepoId>,
                                        ACE_Null_Mutex>        MapType;
        RepoIdSetMap();
        virtual ~RepoIdSetMap();
        int        insert(RepoId key, RepoId value);
        RepoIdSet* find(RepoId key);
        int        remove(RepoId key, RepoId value);
        RepoIdSet* remove_set(RepoId key);
        int release_publisher(RepoId subscriber_id, RepoId publisher_id);
        size_t size() const;
        MapType& map();
        const MapType& map() const;
        size_t marshaled_size ();
        
        ACE_Message_Block* marshal (bool byte_order);
        bool equal (RepoIdSetMap& map, RepoId id);
        
        int demarshal
PEGASUS_USING_PEGASUS;
PEGASUS_USING_STD;
void testHostLocator()
    HostLocator locator("1.222.33.44:1234");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("1.222.33.44"));
    PEGASUS_TEST_ASSERT(locator.getPort() == 1234);
    PEGASUS_TEST_ASSERT(locator.getPortString() == String("1234"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV4);
    locator.setHostLocator("1.2.3.4");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("1.2.3.4"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV4);
    locator.setHostLocator("[fe00:ef::1]:1234");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("fe00:ef::1"));
    PEGASUS_TEST_ASSERT(locator.getAddres

    locator.setHostLocator("[fe00:1::]");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("fe00:1::"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV6);
    locator.setHostLocator("[fe00:1231:23fe:3456:acde:ebcd:12fe:ecd4]");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() ==
        String("fe00:1231:23fe:3456:acde:ebcd:12fe:ecd4"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_IPV6);
    locator.setHostLocator("[fe00:1231:23fe:3456::ebcd:12fe:ecd4]:2345");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getPort() == 2345);
    PEGASUS_TEST_ASSERT(locator.getHost() ==
        String("fe00:1231:23fe:3456::ebcd:12fe:ecd4"));
    PEGASUS_TEST_ASSERT(locator.getAddressType

    locator.setHostLocator("123.34.abcd.xyz.com:65535");
    PEGASUS_TEST_ASSERT(locator.isValid());
    PEGASUS_TEST_ASSERT(locator.isPortSpecified());
    PEGASUS_TEST_ASSERT(locator.getHost() == String("123.34.abcd.xyz.com"));
    PEGASUS_TEST_ASSERT(locator.getAddressType() == HostAddress::AT_HOSTNAME);
    locator.setHostLocator("[1.2.3.4]:");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isPortSpecified());
    locator.setHostLocator("[1.2.3.4]:1234");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[1.2.3.4]");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[ffff1:2:3:4]");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[123]:123345");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[]");
    PEGASUS_TEST_ASSERT(!locator.isValid());
    PEGASUS_TEST_ASSERT(!locator.isValid());
    locator.setHostLocator("[1::24]:");
    PEGASUS_TEST_ASSERT(!locat
/*************************************************************************
** File: sample_lib.h
**
** Purpose: 
**   Specification for the sample library functions.
**
*************************************************************************/
/************************************************************************
** Includes
*************************************************************************/
/************************************************************************
** Type Definitions
*************************************************************************/
/*************************************************************************
** Exported Functions
*************************************************************************/
/************************************************************************/
/** \brief Sample Lib Function 
**  
**  \par Description
**        This is a sample function
**
**  \par Assumptions, External Events, and Notes:
**        None
**       
**  \re
static void writeThreadFun(Output* output, BlockingQueue<OrderedOutput::Chunk*>& queue, unsigned int limit)
	unsigned int total = 0;
	while (OrderedOutput::Chunk* chunk = queue.pop())
	{
		std::string::size_type pos = 0;
		for (unsigned int i = total; i < limit && pos < chunk->result.length(); ++i)
		{
			const char* line = chunk->result.c_str() + pos;
			size_t length = strlen(line);
			output->rawprint(line, length);
			total++;
			pos += length + 1;
		}
		delete chunk;
	}
OrderedOutput::Chunk::Chunk(unsigned int id, unsigned int lines): id(id), lines(lines)
OrderedOutput::OrderedOutput(Output* output, size_t memoryLimit, size_t flushThreshold, unsigned int lineLimit):
	output(output), flushThreshold(flushThreshold), lineLimit(lineLimit), writeQueue(memoryLimit),
	writeThread(std::bind(writeThreadFun, output, std::ref(writeQueue), lineLimit)),
	currentChunk(0), currentLine(0)
OrderedOutput::~OrderedOutput()
	writeQueue.push(nullptr);
	writeThread.join();
	assert(chunks.empty());
    

OrderedOutput::Chunk* OrderedOutput::begin(unsigned int id)
	assert(id >= currentChunk);
	return new Chunk(id, 0);
void OrderedOutput::write(Chunk* chunk, const char* format, ...)
	va_list args;
	va_start(args, format);
	strprintf(chunk->result, format, args);
	va_end(args);
	write(chunk);
void OrderedOutput::write(Chunk* chunk)
	chunk->result.push_back(0);
	chunk->lines++;
	if (chunk->result.size() > flushThreshold && chunk->id == currentChunk)
	{
		Chunk* temp = new Chunk(chunk->id, chunk->lines);
		chunk->result.swap(temp->result);
		chunk->lines = 0;
		currentLine += temp->lines;
		writeQueue.push(temp, temp->result.size());
	}
void OrderedOutput::end(Chunk* chunk)
	std::lock_guard<std::mutex> lock(mutex);
	assert(chunks[chunk->id] == 0);
	chunks[chunk->id] = chunk;
	while (!chunks.empty() && chunks.begin()->first == currentChunk)
	{
		Chunk* chunk = chunks.begin()->second;
		chunks.erase(chunks.begin());
		if (chunk->result.empty())
		{
			delete chunk;
		}
		else
		{
			currentL
dump_manager_class :: dump_manager_class()
dump_manager_class :: ~dump_manager_class()
	for (int i=0; i<dumpN; i++) delete (dump_slaves[i]);
	free(dump_slaves);
dump_manager_class :: dump_manager_class(FILE* optfid)
	dumpN = load_namedint(optfid, "DUMPS_N", true, 0);
	dump_slaves = (dump_type_empty_class**)malloc_ch(sizeof(dump_type_empty_class*)*dumpN);
	for (int i=0; i<dumpN; i++)
	{
		char cbuf[100];
		load_namednumstringn(optfid, "DUMPTYPE", cbuf, i, 100, false);
		if      (strcmp(cbuf, "full")==0)            dump_slaves[i] = new dump_type_full_class               (optfid,i); 
		else if (strcmp(cbuf, "maxI")==0)            dump_slaves[i] = new dump_type_maxI_class               (optfid,i);  
		else if (strcmp(cbuf, "flux")==0)            dump_slaves[i] = new dump_type_flux_class               (optfid,i);  
		else if (strcmp(cbuf, "ysection")==0)        dump_slaves[i] = new dump_type_ysection_class           (optfid,i);
		else if (strcmp(cbuf, "ysection_maxI")==0)   dump_slaves[i] =

		else if (strcmp(cbuf, "ysection_flux")==0)   dump_slaves[i] = new dump_type_ysection_flux_class      (optfid,i);  
		else if (strcmp(cbuf, "plasma_full")==0)         dump_slaves[i] = new dump_type_full_plasma_class         (optfid,i);
		else if (strcmp(cbuf, "plasma_max")==0)          dump_slaves[i] = new dump_type_plasma_max_class          (optfid,i);
		else if (strcmp(cbuf, "plasma_ysection")==0)     dump_slaves[i] = new dump_type_ysection_plasma_class     (optfid,i);
		else if (strcmp(cbuf, "plasma_ysection_max")==0) dump_slaves[i] = new dump_type_ysection_plasma_max_class (optfid,i);
		else if (strcmp(cbuf, "youngy")==0)              dump_slaves[i] = new dump_type_youngy_class(optfid, i);
		else if (strcmp(cbuf, "fluxk") ==0)              dump_slaves[i] = new dump_type_fluxk_class(optfid, i);
		else if (strcmp(cbuf, "ysectionk")==0)           dump_slaves[i] = new dump_type_ysectionk_class(optfid,i);
		else if (strcmp(cbuf, "field_axis") ==0)         dump_slaves[i] = new dump_typ

		else if (strcmp(cbuf, "plasma_axis")==0)         dump_slaves[i] = new dump_type_plasma_axis_class(optfid,i);
		else if (strcmp(cbuf, "Z_axis")==0)              dump_slaves[i] = new dump_type_Z_axis_class(optfid,i);
		else if (strcmp(cbuf, "average_spectrum")==0)    dump_slaves[i] = new dump_type_average_spectrum_class(optfid,i);
		else if (strcmp(cbuf, "duration")==0)            dump_slaves[i] = new dump_type_duration_class(optfid, i); 
		else throw "dump_manager_class :: dump_manager_class(FILE* fid) >>> Error! Unknown dump type specified! Revise DUMPTYPE values";
	}
void dump_manager_class :: dump()
	if (ISMASTER) printf("\nDumping (n_Z=%d, Z=%f)...", n_Z, CURRENT_Z); 
	for (int i=0; i<dumpN; i++) dump_slaves[i]->dump_noflush();
	if (ISMASTER) printf("Done.");
void create_wfilter(f_complex* wfilter, const char* name)
	if        (strncmp(name, "longpass",8)==0)  {float_type lambda=(float_type)atof(name+8); create_longpass_filter(wfilter,lambda);}
	else if   (strncmp(name, "lp",2)==

	else if   (strncmp(name, "shortpass",9)==0) {float_type lambda=(float_type)atof(name+9); create_shortpass_filter(wfilter,lambda);}
	else if   (strncmp(name, "sp",2)==0)        {float_type lambda=(float_type)atof(name+2); create_shortpass_filter(wfilter,lambda);}
	else if   (strncmp(name, "NO",2)==0)        {for (int nw=0; nw<N_T; nw++) wfilter[nw]=1.0; }
	else if   (strncmp(name, "file_",5)==0)     {load_spectrum_fromfile(wfilter, OMEGA, N_T, name+5, "text_lambdanm");}
	else throw "create_wfilter: Unknown filter shape!";
void create_longpass_filter(f_complex* wfilter, float_type lambda)
	float_type omega = 2*M_PI*LIGHT_VELOCITY/lambda;
	for (int nw=0; nw<N_T; nw++) if (OMEGA[nw]<omega) wfilter[nw]=1.0; else wfilter[nw]=0.0;
void create_shortpass_filter(f_complex* wfilter, float_type lambda)
	float_type omega = 2*M_PI*LIGHT_VELOCITY/lambda;
	for (int nw=0; nw<N_T; nw++) if (OMEGA[nw]>omega) wfilter[nw]=1.0; else wfilter[nw]=0.0;
void create_filter_fromfile(f_complex* wfilter, char* fi
FDataStream & operator<<(FDataStream &, const PlayerColorTypes &);
FDataStream & operator>>(FDataStream &, PlayerColorTypes &);
FDataStream & operator<<(FDataStream &, const PlayerOptionTypes &);
FDataStream & operator>>(FDataStream &, PlayerOptionTypes &);
FDataStream & operator<<(FDataStream &, const ClimateTypes &);
FDataStream & operator>>(FDataStream &, ClimateTypes &);
FDataStream & operator<<(FDataStream &, const SeaLevelTypes &);
FDataStream & operator>>(FDataStream &, SeaLevelTypes &);
FDataStream & operator<<(FDataStream &, const WorldSizeTypes &);
FDataStream & operator>>(FDataStream &, WorldSizeTypes &);
FDataStream & operator<<(FDataStream &, const HandicapTypes &);
FDataStream & operator>>(FDataStream &, HandicapTypes &);
FDataStream & operator<<(FDataStream &, const GameSpeedTypes &);
FDataStream & operator>>(FDataStream &, GameSpeedTypes &);
FDataStream & operator<<(FDataStream &, const TurnTimerTypes &);
FDataStream & operator>>(FDataStream &, TurnTimerTypes &);
FDataS

FDataStream & operator>>(FDataStream &, EraTypes &);
FDataStream & operator<<(FDataStream &, const CivilizationTypes &);
FDataStream & operator>>(FDataStream &, CivilizationTypes &);
FDataStream & operator<<(FDataStream &, const LeaderHeadTypes &);
FDataStream & operator>>(FDataStream &, LeaderHeadTypes &);
FDataStream & operator<<(FDataStream &, const ChatTargetTypes &);
FDataStream & operator>>(FDataStream &, ChatTargetTypes &);
FDataStream & operator<<(FDataStream &, const TeamTypes &);
FDataStream & operator>>(FDataStream &, TeamTypes &);
FDataStream & operator<<(FDataStream &, const PlayerTypes &);
FDataStream & operator>>(FDataStream &, PlayerTypes &);
FDataStream & operator<<(FDataStream &, const ReligionTypes &);
FDataStream & operator>>(FDataStream &, ReligionTypes &);
FDataStream & operator<<(FDataStream &, const PlayerVoteTypes &);
FDataStream & operator>>(FDataStream &, PlayerVoteTypes &);
FDataStream & operator<<(FDataStream &, const OrderTypes &);
FDataStream & operator>

FDataStream & operator<<(FDataStream &, const TaskTypes &);
FDataStream & operator>>(FDataStream &, TaskTypes &);
FDataStream & operator<<(FDataStream &, const CalendarTypes &);
FDataStream & operator>>(FDataStream &, CalendarTypes &);
FDataStream & operator<<(FDataStream &, const MissionTypes &);
FDataStream & operator>>(FDataStream &, MissionTypes &);
FDataStream & operator<<(FDataStream &, const CommandTypes &);
FDataStream & operator>>(FDataStream &, CommandTypes &);
FDataStream & operator<<(FDataStream &, const TechTypes &);
FDataStream & operator>>(FDataStream &, TechTypes &);
FDataStream & operator<<(FDataStream &, const PolicyTypes &);
FDataStream & operator>>(FDataStream &, PolicyTypes &);
FDataStream & operator<<(FDataStream &, const NetContactTypes &);
FDataStream & operator>>(FDataStream &, NetContactTypes &);
FDataStream & operator<<(FDataStream &, const SaveGameTypes &);
FDataStream & operator>>(FDataStream &, SaveGameTypes &);
FDataStream & operator<<(FDataStream &, con

FDataStream & operator>>(FDataStream &, GameTypes &);
FDataStream & operator<<(FDataStream &, const GameMapTypes &);
FDataStream & operator>>(FDataStream &, GameMapTypes &);
FDataStream & operator<<(FDataStream &, const GameMode &);
FDataStream & operator>>(FDataStream &, GameMode &);
FDataStream & operator<<(FDataStream &, const SlotClaim &);
FDataStream & operator>>(FDataStream &, SlotClaim &);
FDataStream & operator<<(FDataStream &, const SlotStatus &);
FDataStream & operator>>(FDataStream &, SlotStatus &);
FDataStream & operator<<(FDataStream &, const CivLoginStates &);
FDataStream & operator>>(FDataStream &, CivLoginStates &);
FDataStream & operator<<(FDataStream &, const VersionTypes &);
FDataStream & operator>>(FDataStream &, VersionTypes &);
FDataStream & operator<<(FDataStream &, const BandwidthType &);
FDataStream & operator>>(FDataStream &, BandwidthType &);
FDataStream & operator<<(FDataStream &, const VictoryTypes &);
FDataStream & operator>>(FDataStream &, VictoryTypes &

FDataStream & operator<<(FDataStream &, const SmallAwardTypes &);
FDataStream & operator>>(FDataStream &, SmallAwardTypes &);
FDataStream & operator<<(FDataStream &, const AdvancedStartActionTypes &);
FDataStream & operator>>(FDataStream &, AdvancedStartActionTypes &);
FDataStream & operator<<(FDataStream &, const UnitAITypes &);
FDataStream & operator>>(FDataStream &, UnitAITypes &);
FDataStream & operator<<(FDataStream &, const VoteSourceTypes &);
FDataStream & operator>>(FDataStream &, VoteSourceTypes &);
FDataStream & operator<<(FDataStream &, const VoteTypes &);
FDataStream & operator>>(FDataStream &, VoteTypes &);
FDataStream & operator<<(FDataStream &, const BuildingClassTypes &);
FDataStream & operator>>(FDataStream &, BuildingClassTypes &);
FDataStream & operator<<(FDataStream &, const ColorTypes &);
FDataStream & operator>>(FDataStream &, ColorTypes &);
FDataStream & operator<<(FDataStream &, const InterfaceMessageTypes &);
FDataStream & operator>>(FDataStream &, InterfaceMe

FDataStream & operator<<(FDataStream &, const DirectionTypes &);
FDataStream & operator>>(FDataStream &, DirectionTypes &);
namespace FSerialization { std::string toString(const DirectionTypes &); }
FDataStream & operator<<(FDataStream &, const UnitTypes &);
FDataStream & operator>>(FDataStream &, UnitTypes &);
FDataStream & operator<<(FDataStream &, const BuildingTypes &);
FDataStream & operator>>(FDataStream &, BuildingTypes &);
FDataStream & operator<<(FDataStream &, const ReplayMessageTypes &);
FDataStream & operator>>(FDataStream &, ReplayMessageTypes &);
FDataStream & operator<<(FDataStream &, const ResourceTypes &);
FDataStream & operator>>(FDataStream &, ResourceTypes &);
FDataStream & operator<<(FDataStream &, const MissionAITypes &);
FDataStream & operator>>(FDataStream &, MissionAITypes &);
FDataStream & operator<<(FDataStream &, const ActivityTypes &);
FDataStream & operator>>(FDataStream &, ActivityTypes &);
namespace FSerialization { std::string toString(const ActivityTy

FDataStream & operator<<(FDataStream &, const AutomateTypes &);
FDataStream & operator>>(FDataStream &, AutomateTypes &);
FDataStream & operator<<(FDataStream &, const GameOptionTypes &);
FDataStream & operator>>(FDataStream &, GameOptionTypes &);
FDataStream & operator<<(FDataStream &, const ButtonPopupTypes &);
FDataStream & operator>>(FDataStream &, ButtonPopupTypes &);
FDataStream & operator<<(FDataStream &, const UnitClassTypes &);
FDataStream & operator>>(FDataStream &, UnitClassTypes &);
FDataStream & operator<<(FDataStream &, const MinorCivTypes &);
FDataStream & operator>>(FDataStream &, MinorCivTypes &);
FDataStream & operator<<(FDataStream &, const ArtStyleTypes &);
FDataStream & operator>>(FDataStream &, ArtStyleTypes &);
FDataStream & operator<<(FDataStream &, const DiploCommentTypes &);
FDataStream & operator>>(FDataStream &, DiploCommentTypes &);
FDataStream & operator<<(FDataStream &, const GameStateTypes &);
FDataStream & operator>>(FDataStream &, GameStateTypes &);
F

FDataStream & operator>>(FDataStream &, BuildTypes &);
FDataStream & operator<<(FDataStream &, const CultureLevelTypes &);
FDataStream & operator>>(FDataStream &, CultureLevelTypes &);
FDataStream & operator<<(FDataStream &, const TacticalAIMoveTypes &);
FDataStream & operator>>(FDataStream &, TacticalAIMoveTypes &);
FDataStream & operator<<(FDataStream &, const CitySpecializationTypes &);
FDataStream & operator>>(FDataStream &, CitySpecializationTypes &);
FDataStream & operator<<(FDataStream &, const InvisibleTypes &);
FDataStream & operator>>(FDataStream &, InvisibleTypes &);
FDataStream & operator<<(FDataStream &, const PolicyBranchTypes &);
FDataStream & operator>>(FDataStream &, PolicyBranchTypes &);
FDataStream & operator<<(FDataStream &, const EndTurnBlockingTypes &);
FDataStream & operator>>(FDataStream &, EndTurnBlockingTypes &);
FDataStream & operator<<(FDataStream &, const NotificationTypes &);
FDataStream & operator>>(FDataStream &, NotificationTypes &);
FDataStream & oper

FDataStream & operator>>(FDataStream &, FromUIDiploEventTypes &);
FDataStream & operator<<(FDataStream &, const RouteTypes &);
FDataStream & operator>>(FDataStream &, RouteTypes &);
FDataStream & operator<<(FDataStream &, const ImprovementTypes &);
FDataStream & operator>>(FDataStream &, ImprovementTypes &);
FDataStream & operator<<(FDataStream &, const CityAIFocusTypes &);
FDataStream & operator>>(FDataStream &, CityAIFocusTypes &);
FDataStream & operator<<(FDataStream &, const GreatPeopleDirectiveTypes &);
FDataStream & operator>>(FDataStream &, GreatPeopleDirectiveTypes &);
FDataStream & operator<<(FDataStream &, const DiploUIStateTypes &);
FDataStream & operator>>(FDataStream &, DiploUIStateTypes &);
FDataStream & operator<<(FDataStream &, const LeaderheadAnimationTypes &);
FDataStream & operator>>(FDataStream &, LeaderheadAnimationTypes &);
FDataStream & operator<<(FDataStream &, const GameExecutableTypes &);
FDataStream & operator>>(FDataStream &, GameExecutableTypes &);
FDataSt
namespace TAO
  namespace DCPS
  {
    ACE_INLINE
    DataSampleListElement::DataSampleListElement (
      PublicationId           publication_id,
      TransportSendListener*  send_listner,
      PublicationInstance*    handle)
      : sample_ (0),
        publication_id_ (publication_id), 
        group_id_ (0),
        previous_sample_ (0),
        next_sample_ (0),
        next_instance_sample_ (0),
        next_send_sample_ (0),
        send_listener_ (send_listner),
        space_available_ (false),
        handle_(handle)
    {
    }
    ACE_INLINE
    DataSampleListElement::~DataSampleListElement ()
    {
      if (sample_ != 0)
        {
          sample_->release ();
        }
    }
    ACE_INLINE
    DataSampleList::DataSampleList() 
      : head_( 0), 
        tail_( 0), 
        size_( 0) 
    { 
    }
    ACE_INLINE
    void DataSampleList::reset ()
    {
      head_ = tail_ = 0;
      size_ = 0;
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_sample (

    {
      sample->previous_sample_ = 0;
      sample->next_sample_ = 0;
      
      ++size_ ;
      if( head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          tail_->next_sample_ = sample ;
          sample->previous_sample_ = tail_;
          tail_ = sample;
        }    
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_sample_;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else 
            {
              head_->previous_sample_ = 0;
            }
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_send_sample (DataSampleListElement* sample)
    {
      sample->previous_sample_ = 0;
      sample->next_sample_ = 0;
      sampl

      ++ size_ ;
      if(head_ == 0) 
        {
          head_ = tail_ = sample ;
        } 
      else 
        {
          sample->previous_sample_ = tail_;
          tail_->next_sample_ = sample;
          tail_->next_send_sample_ = sample ;
          tail_ = sample ;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_send_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        {
          return false;
        }
      else
        {
          --size_ ;
          head_ = head_->next_send_sample_ ;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          else 
            {
              head_->previous_sample_ = 0;
            }
          return true;
        }
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_instance_sample (DataSampleListElement* sample)
    {
      sample->next_instance_sample_ = 0;
      ++ size_ ;
      if(head_ == 0) 
        {
          hea

        } 
      else 
        {
          tail_->next_instance_sample_ = sample ;
          tail_ = sample ;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_head_next_instance_sample (DataSampleListElement*& stale)
    {
      stale = head_;
      if (head_ == 0)
        { 
          return false;
        }
      else 
        {
          --size_ ;
          head_ = head_->next_instance_sample_ ;
          if (head_ == 0)
            {
              tail_ = 0;
            }
          return true;
        }
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_next_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_sample (stale);
        }
      bool found = false;
      for( DataSampleListElement* item = head_->next_sample_ ;
           item != 0 ;
           item = item->next_sample_ )
        {
          if (item == stale)
      

              found = true;
              break;
            }
        }
      if (found)
        {
          -- size_ ;
          
          if( stale->previous_sample_ != 0) 
            {
              stale->previous_sample_->next_sample_ = stale->next_sample_ ;
            } 
          else 
            {
              head_ = stale->next_sample_ ;
              if (head_ != 0)
                {
                  head_->previous_sample_ = 0;
                }
            }
          if( stale->next_sample_ != 0) 
            {
              stale->next_sample_->previous_sample_ = stale->previous_sample_ ;
            } 
          else 
            {
              tail_ = stale->previous_sample_ ;
            }
        }
      return found;
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_next_instance_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_h

        }
      bool found = false;
      DataSampleListElement* previous = head_;
      for( DataSampleListElement* item = head_->next_instance_sample_ ;
        item != 0 ;
        item = item->next_instance_sample_ )
        {
          if (item == stale)
            {
              found = true;  
              previous->next_instance_sample_ = stale->next_instance_sample_;
              -- size_ ;
              break;
            }
          previous = item;
        }
      
      return found;
    }
    ACE_INLINE
    bool
    DataSampleList::dequeue_next_send_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_send_sample (stale);
        }
      bool found = false;
      for( DataSampleListElement* item = head_->next_send_sample_ ;
        item != 0 ;
        item = item->next_send_sample_ )
        {
          if (item == stale)
            {
      

              break;
            }
        }
      
      if (found)
        {
          size_ --;
          stale->previous_sample_->next_sample_ = stale->next_sample_ ;
          stale->previous_sample_->next_send_sample_ = stale->next_send_sample_ ;
          if( stale->next_sample_ != 0) 
            {
              stale->next_sample_->previous_sample_ = stale->previous_sample_ ;
            } 
          else 
            {
              tail_ = stale->previous_sample_ ;
            }
        }
      return found;
    }
    ACE_INLINE
    void
    DataSampleList::enqueue_tail_next_send_sample (DataSampleList list)
     {
       DataSampleListElement* cur = list.head_;
       if (list.size_ > 1 && cur->next_send_sample_ == 0)
        {
          for (ssize_t i = 0; i < list.size_; i ++)
            {
              cur->next_send_sample_ = cur->next_sample_;
              cur = cur->next_sample_;
            }
        }
       if (head_ == 0)
        {
          head_ = list.head_;
/*
 * OGLConsumer.cpp
 *
 *  Created on: Feb 21, 2013
 *      Author: Andrew Zhabura
 */
OGL_Consumer::OGL_Consumer()
:	m_Sample(new Sample * [Sample_QTY])
,	m_SampleNum(0)
,	m_init(true)
	int i = -1;
	m_Sample[++i] = new Sample_01;
	m_Sample[++i] = new Sample_02;
	m_Sample[++i] = new Sample_03;
	m_Sample[++i] = new Sample_04;
	m_Sample[++i] = new Sample_05;
	m_Sample[++i] = new Sample_06;
	m_Sample[++i] = new Sample_07;
	m_Sample[++i] = new Sample_08;
	m_Sample[++i] = new Sample_09;
	m_Sample[++i] = new Sample_10;
	m_Sample[++i] = new Sample_11;
	m_Sample[++i] = new Sample_12;
	m_Sample[++i] = new Sample_13;
	m_Sample[++i] = new Sample_14;
	m_Sample[++i] = new Sample_14;
	m_Sample[++i] = new Sample_16;
	m_Sample[++i] = new Sample_17;
	m_Sample[++i] = new Sample_18;
	m_Sample[++i] = new Sample_19;
	m_Sample[++i] = new Sample_20;
	m_Sample[++i] = new Sample_21;
	m_Sample[++i] = new Sample_22;
	m_Sample[++i] = new Sample_23;
	m_Sample[++i] = new Sample_24;
	m_Sample[++i] = new Sample_25;

	if ( ++i != Sample_QTY )
		throw this;
OGL_Consumer::~OGL_Consumer()
	for (int i = 0; i < Sample_QTY; ++i)
	{
		if (m_Sample[i])
			delete m_Sample[i];
	}
bool OGL_Consumer::setSample(unsigned int SampleNum)
	if (SampleNum >= Sample_QTY)
		return false;
	if (m_SampleNum == SampleNum)
		return true;
	if (!m_init)
	{
		m_Sample[m_SampleNum]->restoreGL();
		m_init = true;
	}
	m_SampleNum = SampleNum;
	return true;
bool OGL_Consumer::sendMessage(unsigned int SampleNum, int message, int mode, int x, int y)
	return m_Sample[m_SampleNum]->sendMessage(message, mode, x, y);
void OGL_Consumer::sendIdleMessage()
	m_Sample[m_SampleNum]->sendIdleMessage();
void OGL_Consumer::reshape(unsigned int width, unsigned int height)
	m_Sample[m_SampleNum]->reshape(width, height);
void OGL_Consumer::drawGLScene()
	if (m_init)
	{
		m_Sample[m_SampleNum]->initGL();
		m_init = false;
	}
	m_Sample[m_SampleNum]->draw();
const char* OGL_Consumer::sampleName() const
	return m_Sample[m_SampleNum]->name();
int OGL_C
using namespace std;
int T, TC=1, C, D, N, i;
int li, lj, lk, ret;
char combine[37][4], oppose[29][3], invoke[101];
int attempt_combine(int i)
	if(i==0) return 0;
	for(li=0; li < C; li++)
	{
		if((combine[li][0] == invoke[i] && combine[li][1] == invoke[i-1])
			||(combine[li][1] == invoke[i] && combine[li][0] == invoke[i-1]))
		{
			invoke[i-1] = combine[li][2];
			for(lj=i; lj < N; lj++)
				invoke[lj] = invoke[lj+1];
			N--;
			return i-1;
		}
	}
	return i;
int attempt_oppose(int i)
	if(i==0) return 0;
	for(li=0; li < D; li++)
	{
		if(oppose[li][0] == invoke[i])
		{
			lj = i - 1;
			while(lj >= 0)
			{
				if(invoke[lj] == oppose[li][1])
				{
					int ii = i+1;
					for(lk = 0; ii <= N; lk++, ii++)
						invoke[lk] = invoke[ii];
					N = N - i - 1;
					return 0;
				}
				else
					lj--;
			}
		}
		else if(oppose[li][1] == invoke[i])
		{
			lj = i - 1;
			while(lj >= 0)
			{
				if(invoke[lj] == oppose[li][0])
				{
					int ii = i+1;
					for(lk = 0; ii <= N; lk++, ii++)
						in
using namespace std;
int T, TC=1, C, D, N, i;
int li, lj, lk, ret;
char combine[37][4], oppose[29][3], invoke[101];
int attempt_combine(int i)
	if(i==0) return 0;
	for(li=0; li < C; li++)
	{
		if((combine[li][0] == invoke[i] && combine[li][1] == invoke[i-1])
			||(combine[li][1] == invoke[i] && combine[li][0] == invoke[i-1]))
		{
			invoke[i-1] = combine[li][2];
			for(lj=i; lj < N; lj++)
				invoke[lj] = invoke[lj+1];
			N--;
			return i-1;
		}
	}
	return i;
int attempt_oppose(int i)
	if(i==0) return 0;
	for(li=0; li < D; li++)
	{
		if(oppose[li][0] == invoke[i])
		{
			lj = i - 1;
			while(lj >= 0)
			{
				if(invoke[lj] == oppose[li][1])
				{
					int ii = i+1;
					for(lk = 0; ii <= N; lk++, ii++)
						invoke[lk] = invoke[ii];
					N = N - i - 1;
					return 0;
				}
				else
					lj--;
			}
		}
		else if(oppose[li][1] == invoke[i])
		{
			lj = i - 1;
			while(lj >= 0)
			{
				if(invoke[lj] == oppose[li][0])
				{
					int ii = i+1;
					for(lk = 0; ii <= N; lk++, ii++)
						in
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoNodeCamera::RepoNodeCamera(
	const aiCamera * camera) : 
		RepoNodeAbstract (
			REPO_NODE_TYPE_CAMERA, 
			REPO_NODE_API_LEVEL_1,
            boost::uuids::random_generator()(),
			camera->mName.data)
	aspectRatio = camera->mAspect;
	farClippingPlane = camera->mClipPlaneFar;
	nearClippingPlane = camera->mClipPlaneNear;
	fieldOfView 

	lookAt = camera->mLookAt;
	position = camera->mPosition;
	up = camera->mUp;
		
repo::core::RepoNodeCamera::RepoNodeCamera(const mongo::BSONObj &obj) 
	: RepoNodeAbstract(obj)
	if (obj.hasField(REPO_NODE_LABEL_ASPECT_RATIO))
        aspectRatio = (float)
                obj.getField(REPO_NODE_LABEL_ASPECT_RATIO).numberDouble();
	if (obj.hasField(REPO_NODE_LABEL_FAR))
        farClippingPlane = (float)
                obj.getField(REPO_NODE_LABEL_FAR).numberDouble();
	if (obj.hasField(REPO_NODE_LABEL_NEAR))
        nearClippingPlane = (float)
                obj.getField(REPO_NODE_LABEL_NEAR).numberDouble();
	if (obj.hasField(REPO_NODE_LABEL_FOV))
        fieldOfView = (float)
                obj.getField(REPO_NODE_LABEL_FOV).numberDouble();
	if (obj.hasField(REPO_NODE_LABEL_LOOK_AT))
		lookAt = RepoTranscoderBSON::retrieveVector3D(
			obj.getField(REPO_NODE_LABEL_LOOK_AT));
	if (obj.hasField(REPO_NODE_LABEL_POSITION))
		position = RepoTranscoderBSON::retrieveVector3D(
			obj.getField(

	if (obj.hasField(REPO_NODE_LABEL_UP))
		up = RepoTranscoderBSON::retrieveVector3D(
			obj.getField(REPO_NODE_LABEL_UP));
bool repo::core::RepoNodeCamera::operator==(const RepoNodeAbstract& other) const
    const RepoNodeCamera *otherCamera = dynamic_cast<const RepoNodeCamera*>(&other);
    return otherCamera &&
            RepoNodeAbstract::operator==(other) &&
            (this->getAspectRatio() == otherCamera->getAspectRatio()) &&
            (this->getFarClippingPlane() == otherCamera->getFarClippingPlane()) &&
            (this->getNearClippingPlane() == otherCamera->getNearClippingPlane()) &&
            (this->getFieldOfView() == otherCamera->getFieldOfView()) &&
            (this->getLookAt() == otherCamera->getLookAt()) &&
            (this->getPosition() == otherCamera->getPosition()) &&
            (this->getUp() == otherCamera->getUp());
mongo::BSONObj repo::core::RepoNodeCamera::toBSONObj() const
	mongo::BSONObjBuilder builder;
	appendDefaultFields(builder);
    RepoTrans

                               builder);
	RepoTranscoderBSON::append(REPO_NODE_LABEL_FAR, farClippingPlane, builder);
    RepoTranscoderBSON::append(REPO_NODE_LABEL_NEAR, nearClippingPlane,builder);
	RepoTranscoderBSON::append(REPO_NODE_LABEL_FOV, fieldOfView, builder);
	RepoTranscoderBSON::append(REPO_NODE_LABEL_LOOK_AT, lookAt, builder);
	RepoTranscoderBSON::append(REPO_NODE_LABEL_POSITION, position, builder);
	RepoTranscoderBSON::append(REPO_NODE_LABEL_UP, up, builder);
	return builder.obj();
void repo::core::RepoNodeCamera::toAssimp(aiCamera *camera) const
	camera->mName = aiString(name);
	camera->mAspect = aspectRatio;
	camera->mClipPlaneFar = farClippingPlane;
	camera->mClipPlaneNear = nearClippingPlane;
	camera->mHorizontalFOV = fieldOfView;
	camera->mLookAt = lookAt;
	camera->mPosition = position;
	camera->mUp = up;
float repo::core::RepoNodeCamera::getAspectRatio() const
    return aspectRatio;
float repo::core::RepoNodeCamera::getFarClippingPlane() const
    return farClippi

float repo::core::RepoNodeCamera::getNearClippingPlane() const
    return nearClippingPlane;
float repo::core::RepoNodeCamera::getFieldOfView() const
    return fieldOfView;
aiVector3D repo::core::RepoNodeCamera::getLookAt() const
    return lookAt;
aiVector3D repo::core::RepoNodeCamera::getPosition() const
    return position;
aiVector3D repo::core::RepoNodeCamera::getUp() const
    return up;
aiMatrix4x4 repo::core::RepoNodeCamera::getCameraMatrix () const
    aiMatrix4x4 out;
    /** todo: test ... should work, but i'm not absolutely sure */
    /** We don't know whether these vectors are already normalized ...*/
    aiVector3D zaxis = lookAt;     zaxis.Normalize();
    aiVector3D yaxis = up;         yaxis.Normalize();
    aiVector3D xaxis = up^lookAt;  xaxis.Normalize();
    out.a4 = -(xaxis * position);
    out.b4 = -(yaxis * position);
    out.c4 = -(zaxis * position);
    out.a1 = xaxis.x;
    out.a2 = xaxis.y;
    out.a3 = xaxis.z;
    out.b1 = yaxis.x;
    out.b2 = yaxis.y;
 
/* GameClock.h
  version 0.0.2, August 1st, 2012
  Copyright (C) 2012 Philipp Geyer
  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.
  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:
  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
  Philipp Geyer
*/
/* Changelog
                        multiple clocks t

   0.0.1 - 12.02.2012 - First implementation of Game Clock for tutorial at
*/
class Timer;
extern ClockID CLOCK_MAIN;
class GameClock
public:
	GameClock();
	Timer*		CreateTimer(int id);
	void		DestroyTimer(Timer* timer);
	void		Invoke(func cb, clocktime t);
	void		CancelInvoke(func cb);
	template <typename T>
	void		Invoke(T* obj, void (T::*cb)(void), clocktime t);	
	template <typename T>
	void		CancelInvoke(T* obj, void (T::*cb)(void));
	clocktime	GetDeltaMs();
	void		SetScale(float s);
	float		GetScale() { return m_Scale; }
	static void	Update();
	static GameClock* GetClock(ClockID id);
	static void SetClock(GameClock* clock, ClockID id);
private:
	typedef std::vector<Timer*> timerVec;
	typedef timerVec::iterator	timerVecIter;
	typedef std::list<_Invoke*> invokeList;
	typedef invokeList::iterator invokeListIter;
	typedef std::map<ClockID, GameClock*> clockMap;
	typedef clockMap::iterator clockMapIter;
	void _update();
	timerVec	m_Timers;
	invokeList   m_Invokes;
	clocktime	m_StartTi
using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace Common;
namespace Fast_kNCN_Test
{	
	const SampleDim firstSampleDims[] = {-0.3490f, 0.6482f, 0.2710f, -0.3151f,
		1.1199f, 1.5135f, 0.1179f, 1.2082f,
		1.1918f, 1.1449f, 0.9726f, -0.2358f,
		1.2261f, -0.2806f, 0.4784f, -0.3126f,
		0.1192f, -0.3256f, 0.0434f, -0.3327f,
		0.0022f, -0.3364f, -0.0148f, -0.3418f,
		-0.0261f, -0.3483f, -0.0400f, -0.3543f,
		-0.0515f, -0.3602f};
	const SampleDim secondSampleDims[] = {-0.3490f, 0.6482f, 0.2710f, -0.3151f,
		1.1199f, 1.5135f, 0.1179f, 1.2082f,
		1.1918f, 1.1449f, 0.9726f, -0.2358f,
		1.2261f, -0.2806f, 0.4784f, -0.3126f,
		0.1192f, -0.3256f, 0.0434f, -0.3327f,
		0.0022f, -0.3364f, -0.0148f, -0.3418f,
		-0.0261f, -0.3483f, -0.0400f, -0.3543f,
		-0.0515f, -0.3601f};
	TEST_CLASS(SampleSetTest)	{
		static Sample testSample;
		static SampleSetFactory sf;
		public:
		TEST_METHOD_INITIALIZE(SampleTestSetUp) {	
			testSample = Sample();
			sf = SampleSetFactory();
			std::if

			Assert::IsTrue(trainfile.is_open());
			int nrClasses, nrDims, nrSamples;
			trainfile >> nrClasses;
			trainfile >> nrDims;
			trainfile >> nrSamples;
			nrDims = 8;
			Assert::AreEqual(8, nrClasses);
			Assert::AreEqual(8, nrDims);
			Assert::AreEqual(1400, nrSamples);
			testSample = sf.createSample(trainfile, 0, nrDims);
			Assert::AreEqual(1, testSample.label);
			Assert::AreEqual(nrDims, testSample.nrDims);
			Assert::IsNotNull(testSample.dims);
			Assert::AreEqual(firstSampleDims[testSample.nrDims - 1], testSample[testSample.nrDims - 1]);
			Assert::AreEqual(firstSampleDims[testSample.nrDims - 1], testSample[testSample.nrDims - 1]);
		}
		TEST_METHOD(ConstructorSample)
		{
			Sample testSample2(0, 1, 30, firstSampleDims);
			Assert::AreEqual(0, testSample2.index);
			Assert::AreEqual(1, testSample2.label);
			Assert::AreEqual(30, testSample2.nrDims);
			Assert::IsNotNull(&testSample2.dims);
			Assert::AreEqual(firstSampleDims[0], testSample2[0]);
			Assert::AreEqual(firstSam

		TEST_METHOD(CopyConstructorSample)
		{
			Assert::IsNotNull(&testSample);
			
			Sample copySample(testSample);
			Assert::IsNotNull(&copySample);
			Assert::AreNotSame(&testSample, &copySample);
			Assert::AreEqual(testSample.index, copySample.index);
			Assert::AreEqual(testSample.label, copySample.label);
			Assert::AreEqual(testSample.nrDims, copySample.nrDims);
			Assert::IsNotNull(&copySample2);
			Assert::AreNotSame(&testSample, &copySample2);
			Assert::AreEqual(testSample.index, copySample2.index);
			Assert::AreEqual(testSample.label, copySample2.label);
			Assert::AreEqual(testSample.nrDims, copySample2.nrDims);
		}
		TEST_METHOD(AssignmentOperatorSample)
		{
			Assert::IsNotNull(&testSample);
			assignSample = testSample;
			Assert::AreEqual(testSample, assignSample);
			Assert::AreNotSame(&testSample, &assignSample);
			Assert::AreEqual(testSample, assignSample);
			Assert::AreNotSame(&testSample, &assignSample);
		}
		TEST_METHOD(ExplicitEqualityOperatorSample)
		{
			
ChunkLoadTask::ChunkLoadTask(ChunkManager* manager, IntVector3 chunk_position, const ChunkManagerConfig& config)
	: m_manager(manager)
	, m_position(chunk_position)
	, m_chunk(NULL)
	, m_config(config)
IntVector3 ChunkLoadTask::Get_Chunk_Position()
	return m_position;
Chunk* ChunkLoadTask::Get_Chunk()
	return m_chunk;
	 
void ChunkLoadTask::Run()
	void* mem = NULL;
	while (true)
	{
		mem = m_manager->Get_Chunk_Memory_Pool().Allocate();
		if (mem != NULL)
		{
			break;
		}
		Thread::Get_Current()->Sleep(0.01f);
	}
				
	Chunk* chunk = new(mem) Chunk  (m_manager, m_position.X, m_position.Y, m_position.Z, 
									m_config.chunk_size.X, m_config.chunk_size.Y, m_config.chunk_size.Z,
									m_config.voxel_size.X, m_config.voxel_size.Y, m_config.voxel_size.Z);
	chunk->Set_Status(ChunkStatus::Loading);
		
	RegionFile* region = m_manager->Get_Region_File(chunk->Get_Region());
	if (region->Contains_Chunk(chunk))
	{
		region->Load_Chunk(chunk);
	}
	else
	{
		ChunkGenerator generator(m_manager
namespace eggs { namespace tupleware
    namespace meta
    {
        template <typename LambdaExpression, typename ...Args>
        struct invoke
          : detail::meta::invoke<LambdaExpression, pack<Args...>>
        {};
    }
    namespace result_of
    {
        template <typename F, typename ...Args>
        struct invoke
          : detail::_result_of_invoke<
                F, Args...
            >
        {};
        template <typename F, typename Args>
        struct invoke<F, expand_tuple_t, Args>
          : detail::_result_of_invoke<
                F, expand_tuple_t, Args
            >
        {};
        template <typename F, typename ...Args>
        using invoke_t =
            typename invoke<F, Args...>::type;
    }
    template <typename F, typename ...Args>
    constexpr result_of::invoke_t<F, Args...>
    invoke(F&& f, Args&&... args)
    EGGS_TUPLEWARE_RETURN(
        detail::invoke(
            std::forward<F>(f), std::forward<Args>(args)...)
    )
    template

    constexpr result_of::invoke_t<F, expand_tuple_t, Args>
    invoke(F&& f, expand_tuple_t, Args&& args)
    EGGS_TUPLEWARE_RETURN(
        detail::invoke(
            std::forward<F>(f)
          , expand_tuple_t{}, std::forward<Args>(args))
    )
    namespace functional
    {
        struct invoke
        {
            template <typename F, typename ...Args>
            constexpr result_of::invoke_t<F, Args...>
            operator()(F&& f, Args&&... args) const
            EGGS_TUPLEWARE_RETURN(
                detail::invoke(
                    std::forward<F>(f), std::forward<Args>(args)...)
            )
            template <typename F, typename Args>
            constexpr result_of::invoke_t<F, expand_tuple_t, Args>
            operator()(F&& f, expand_tuple_t, Args&& args) const
            EGGS_TUPLEWARE_RETURN(
                detail::invoke(
                    std::forward<F>(f)
                  , expand_tuple_t{}, std::forward<Args>(args))
            )
        };
  
namespace memorychunk{
    MemoryChunk::MemoryChunk(size_t sz){
        arg_ = new int8_t[sz];
        sz_ = sz;
    }
    MemoryChunk::~MemoryChunk(){
        delete arg_;
    }
    int8_t *MemoryChunk::MemoryAt(size_t offset) const{
        if (offset < sz_)
            return &arg_[offset];
        else
            return 0;
    }
    size_t MemoryChunk::ChunkSize() const{
        return sz_;
    }
    MemoryChunk::MemoryChunk(const MemoryChunk &memo){
        sz_ = memo.ChunkSize();
        arg_ = new int8_t[sz_];
        std::copy(memo.arg_, (memo.arg_ + sz_), arg_);
    }
    MemoryChunk::MemoryChunk(MemoryChunk &&memo){
        arg_ = nullptr;
        sz_ = 0;
        std::swap(arg_, memo.arg_);
        std::swap(sz_, memo.sz_);
    }
    MemoryChunk& MemoryChunk::operator=(const MemoryChunk &memo) {
        if (this == &memo)
            return *this;
        delete arg_;
        sz_ = memo.ChunkSize();
        this->arg_ = new int8_t[sz_];
        std::copy(memo.arg_, (memo.ar
/** 
 *
 * \author Tristan Vanderbruggen
 *
 */
namespace MFB {
  template <template <typename T> class Model> class Driver;
  template <typename Object> class Sage;
  struct api_t;
};
namespace MDCG {
namespace Tools {
class ModelBuilder {
  public:
    typedef size_t model_id_t;
  private:
    MFB::Driver<MFB::Sage> & p_driver;
    std::vector<Model::model_t> p_models;
  private:
    
    template <Model::model_elements_e kind>
    void toDotNode(std::ostream & out, Model::element_t<kind> * element) const;
    template <Model::model_elements_e kind>
    void setParentFromScope(Model::model_t & model, Model::element_t<kind> * element, SgSymbol * symbol);
  
    void add(Model::model_t & model, const MFB::api_t * api);
    void add(Model::model_t & model, SgNamespaceSymbol * namespace_symbol);
    void add(Model::model_t & model, SgVariableSymbol * variable_symbol);
    void add(Model::model_t & model, SgFunctionSymbol * function_symbol);
    void add(Model::model_t & model, SgClassSym
namespace net {
class LoadStateChangeCoalescerTest : public testing::Test {
 protected:
  void SetUp() override {
    coalescer_.reset(new LoadStateChangeCoalescer(
        base::Bind(&LoadStateChangeCoalescerTest::LoadStateChanged,
                   base::Unretained(this)),
        base::TimeDelta(), LOAD_STATE_IDLE));
  }
  void TearDown() override { coalescer_.reset(); }
  void LoadStateChanged(LoadState load_state) {
    load_state_changes_.push_back(load_state);
  }
  void WaitUntilIdle() { base::RunLoop().RunUntilIdle(); }
  scoped_ptr<LoadStateChangeCoalescer> coalescer_;
  std::vector<LoadState> load_state_changes_;
};
TEST_F(LoadStateChangeCoalescerTest, SingleChange) {
  coalescer_->LoadStateChanged(LOAD_STATE_RESOLVING_PROXY_FOR_URL);
  WaitUntilIdle();
  ASSERT_EQ(1u, load_state_changes_.size());
  EXPECT_EQ(LOAD_STATE_RESOLVING_PROXY_FOR_URL, load_state_changes_[0]);
TEST_F(LoadStateChangeCoalescerTest, TwoChangesCoalesce) {
  coalescer_->LoadStateChanged(LOAD_STATE_RESOL

  coalescer_->LoadStateChanged(LOAD_STATE_RESOLVING_HOST_IN_PROXY_SCRIPT);
  WaitUntilIdle();
  ASSERT_EQ(1u, load_state_changes_.size());
  EXPECT_EQ(LOAD_STATE_RESOLVING_HOST_IN_PROXY_SCRIPT, load_state_changes_[0]);
TEST_F(LoadStateChangeCoalescerTest, ThreeChangesCoalesce) {
  coalescer_->LoadStateChanged(LOAD_STATE_RESOLVING_PROXY_FOR_URL);
  coalescer_->LoadStateChanged(LOAD_STATE_RESOLVING_HOST_IN_PROXY_SCRIPT);
  coalescer_->LoadStateChanged(LOAD_STATE_DOWNLOADING_PROXY_SCRIPT);
  WaitUntilIdle();
  ASSERT_EQ(1u, load_state_changes_.size());
  EXPECT_EQ(LOAD_STATE_DOWNLOADING_PROXY_SCRIPT, load_state_changes_[0]);
TEST_F(LoadStateChangeCoalescerTest, CoalesceToOriginalLoadState) {
  coalescer_->LoadStateChanged(LOAD_STATE_RESOLVING_PROXY_FOR_URL);
  coalescer_->LoadStateChanged(LOAD_STATE_RESOLVING_HOST_IN_PROXY_SCRIPT);
  coalescer_->LoadStateChanged(LOAD_STATE_IDLE);
  WaitUntilIdle();
  EXPECT_TRUE(load_state_changes_.empty());
TEST_F(LoadStateChangeCoalescerTest, Alternate
/**
 *  Copyright (C) 2014 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
repo::core::RepoNodeReference::RepoNodeReference(
        const std::string &database,
        const std::string &project)
    : RepoNodeAbstract (
            REPO_NODE_TYPE_REFERENCE,
            REPO_NODE_API_LEVEL_1,
            boost::uuids::random_generator()(),
            database + "." + project)
    , database(database)
    , project(proje

    , revisionID(boost::uuids::uuid())
    , isUniqueID(false)
{}
repo::core::RepoNodeReference::RepoNodeReference(
        const std::string &database,
        const std::string &project,
        const boost::uuids::uuid &revisionID,
        bool isUniqueID,
        const std::string &name)
    : RepoNodeAbstract (
            REPO_NODE_TYPE_REFERENCE,
            REPO_NODE_API_LEVEL_1,
            boost::uuids::random_generator()(),
            name)
    , project(project)
    , database(database)
    , revisionID(revisionID)
    , isUniqueID(isUniqueID)
{}
repo::core::RepoNodeReference::RepoNodeReference(
        const mongo::BSONObj &obj)
    : RepoNodeAbstract(obj)
    , revisionID(boost::uuids::uuid())
    , isUniqueID(false)
    if (obj.hasField(REPO_NODE_LABEL_OWNER))
        database = obj.getField(REPO_NODE_LABEL_OWNER).String();
    if (obj.hasField(REPO_NODE_LABEL_PROJECT))
        project = obj.getField(REPO_NODE_LABEL_PROJECT).String();
    if (obj.hasField(REPO_NODE_LAB

    {
        revisionID = RepoTranscoderBSON::retrieve(
                    obj.getField(REPO_NODE_LABEL_REFERENCE_ID));
    }
    if (obj.hasField(REPO_NODE_LABEL_UNIQUE))
    {
        isUniqueID = obj.getField(REPO_NODE_LABEL_UNIQUE).Bool();
    }
bool repo::core::RepoNodeReference::operator==(const RepoNodeAbstract& other) const
    const RepoNodeReference *otherReference = dynamic_cast<const RepoNodeReference*>(&other);
    return otherReference &&
            RepoNodeAbstract::operator==(other) &&
            this->getProject() == otherReference->getProject() &&
            this->getOwner() == otherReference->getOwner() &&
            this->getRevisionID() == otherReference->getRevisionID() &&
            this->getIsUniqueID() == otherReference->getIsUniqueID();
mongo::BSONObj repo::core::RepoNodeReference::toBSONObj() const
    mongo::BSONObjBuilder builder;
    appendDefaultFields(builder);
    if (!database.empty())
        builder << REPO_NODE_LABEL_OWNER << database;
    i
/******************************************************************************
BigWorld Technology
Copyright BigWorld Pty, Ltd.
All Rights Reserved. Commercial in confidence.
WARNING: This computer program is protected by copyright law and international
treaties. Unauthorized use, reproduction or distribution of this program, or
any portion of this program, may result in the imposition of civil and
criminal penalties as provided by law.
******************************************************************************/
/**
 *	This class keeps the factory methods for all types of Tool Locators
 */
class ToolLocator;
typedef NamedObject<ToolLocator * (*)()> LocatorFactory;
class Tool;
	static LocatorFactory s_factory;										\
	virtual LocatorFactory & factory() { return s_factory; }				\
	static ToolLocator * s_create() { return new CONSTRUCT; }				\
/**
 *	The ToolLocator class positions a tool in the world.
 */
class ToolLocator : public PyObjectPlus 
	Py_Header( ToolLocator, PyObjectP

public:
	ToolLocator( PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool ) = 0;
	virtual bool positionValid() const { return true; }
	const Matrix& transform() const	{ return transform_; }
	void transform( const Matrix& m )	{ transform_ = m; }
	virtual Vector3 direction() const { return Vector3( 0.f, 1.f, 0.f ); };
protected:
	Matrix transform_;
};
typedef SmartPointer<ToolLocator>	ToolLocatorPtr;
PY_SCRIPT_CONVERTERS_DECLARE( ToolLocator )
/**
 *	This class implements a tool locator that sits at the origin.
 */
class OriginLocator : public ToolLocator
	Py_Header( OriginLocator, ToolLocator )
public:
	OriginLocator( PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool );
	PY_FACTORY_DECLARE()
private:
	LOCATOR_FACTORY_DECLARE( OriginLocator() )
};
/**
 *	This class implements a tool locator that sits on a plane.
 */
class PlaneToolLocator : public ToolLocator
	Py_Header( PlaneToolLocato

public:
	PlaneToolLocator( PlaneEq * pPlane = NULL, PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool );
	PY_FACTORY_DECLARE()
private:
	PlaneEq	planeEq_;
	LOCATOR_FACTORY_DECLARE( PlaneToolLocator() )
};
/**
 *	This class implements a tool locator that sits on the most orthogonal
 *	plane of the 3 major axes to the camera.
 */
class TriPlaneToolLocator : public ToolLocator
	Py_Header( TriPlaneToolLocator, ToolLocator )
public:
	TriPlaneToolLocator( const Vector3& pos = s_lastPos, PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool );
	PY_FACTORY_DECLARE()
private:
	PlaneEq planeEq_[3];
	Vector3 fulcrum_;
	static Vector3 s_lastPos;
};
/**
 *	This class implements a tool locator that sits on the most orthogonal
 *	plane to the camera, and takes a position for the planes' fulcra.
 */
class AdaptivePlaneToolLocator : public ToolLocator
	Py_Header( AdaptivePlaneToolLocator, ToolLocator )


	AdaptivePlaneToolLocator( const Vector3& pos, PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool );
	PY_FACTORY_DECLARE()
private:
	Vector3 fulcrum_;
};
/**
 *	This class implements a tool locator that sits on a line.
 */
class LineToolLocator : public ToolLocator
	Py_Header( LineToolLocator, ToolLocator )
public:
	LineToolLocator( const Vector3& origin = Vector3( 0, 0, 0), const Vector3& direction = Vector3( 0, 0, 1), PyTypePlus * pType = &s_type_ );
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool );
	virtual Vector3 direction() const { return direction_; }
	PY_FACTORY_DECLARE()
private:
	Vector3 origin_;
	Vector3 direction_;
	LOCATOR_FACTORY_DECLARE( LineToolLocator() )
};
class ChunkToolLocator : public ToolLocator
	Py_Header( ChunkToolLocator, ToolLocator )
public:
	ChunkToolLocator( PyTypePlus * pType = &s_type_ );
};
/**
 *	This class implements a tool locator that finds the chunk a tool is in.
 */
class Pl
using namespace std;
void calculabloque(int i,int j,double **image,int chunk_i,int chunk_j);
	int i, j, px=NPIXELX, py=NPIXELY;
	int chunk_i = 17;
	int chunk_j = 17;
	double sum, promedio;
	double **im;
	mare::task_ptr **task;	
	auto g = mare::create_group("filtro");
	int a = ((py-2)/chunk_j)+2;
	int b = ((px-2)/chunk_i)+2;	
	im = (double **)malloc(py*sizeof(double*));
	for (i=0;i<py;i++) 
		im[i] = (double*)malloc(px*sizeof(double));
	task = (mare::task_ptr **)malloc(a*sizeof(mare::task_ptr*));
	for (i=0;i<=a;i++) 
		task[i] = (mare::task_ptr *)malloc(b*sizeof(mare::task_ptr));
	for(i=0; i < px; i++)
	for(j=0; j < py; j++)
	    im[i][j] = (double) (i*NPIXELX)+j;
	sum = 0.0;
	for(i=0; i < px; i++)	
	for(j=0; j < py; j++)
	    sum += im[i][j];
	promedio = sum /(px*py);
	printf("El promedio inicial es %g\n", promedio);
	task[1][1] = mare::create_task([&im,i,j,chunk_i,chunk_j]{(calculabloque(1,1,im,chunk_i,chunk_j));} );
	mare::launch(g,task[1][1]);
	int modi = (px-2)%chunk_i;
	int modj =

	for(j=2; j<=((py-2)/chunk_j); j++){
		
		task[1][j] = mare::create_task([&im,i,j,chunk_i,chunk_j]{(
			calculabloque(1,((j-1)*chunk_j)+1,im,chunk_i,chunk_j));});
			mare::after(task[1][j-1],task[1][j]);
			mare::launch(g,task[1][j]);
			
	}
	if((modj != 0) && (j>=((py-2)/chunk_j))){
			
			task[1][j] = mare::create_task([&im,i,j,chunk_i,chunk_j,modj]{(
			calculabloque(1,((j-1)*chunk_j)+1,im,chunk_i,modj));});
			mare::after(task[1][j-1],task[1][j]);
			mare::launch(g,task[1][j]);
				
		}
		
		
	for(i=2; i<=((px-2)/chunk_i); i++){
			task[i][1] = mare::create_task([&im,i,j,chunk_i,chunk_j]
			{(calculabloque(((i-1)*chunk_i)+1,1,im,chunk_i,chunk_j));} );	
			mare::after(task[i-1][1],task[i][1]);
			mare::launch(g,task[i][1]);
			
			for(j=2; j<=((py-2)/chunk_j);j++){
					
					task[i][j] = mare::create_task([&im,i,j,chunk_i,chunk_j]
					{(calculabloque(((i-1)*chunk_i)+1,((j-1)*chunk_j)+1,im,chunk_i,chunk_j));} );	
					mare::after(task[i][j-1],task[i][j]);
					mare::after(task[i-1

					mare::launch(g,task[i][j]);
			}	
			
			if((modj != 0) && (j >= ((py-2)/chunk_j))){
					
				task[i][j] = mare::create_task([&im,i,j,modj,chunk_j,chunk_i]
				{(calculabloque(((i-1)*chunk_i)+1,((j-1)*chunk_j)+1,im,chunk_i,modj));} );	
				mare::after(task[i][j-1],task[i][j]);
				mare::after(task[i-1][j],task[i][j]);
				mare::launch(g,task[i][j]);
			}
	}
		if(modi != 0 ){
			
			task[i][1] = mare::create_task([&im,i,j,chunk_i,chunk_j,modi]
			{(calculabloque(((i-1)*chunk_i)+1,1,im,modi,chunk_j));} );	
			mare::after(task[i-1][1],task[i][1]);
			mare::launch(g,task[i][1]);
			for(j=2; j<=((py-2)/chunk_j);j++){
				
				task[i][j] = mare::create_task([&im,i,j,chunk_i,chunk_j,modi]
					{(calculabloque(((i-1)*chunk_i)+1,((j-1)*chunk_j)+1,im,modi,chunk_j));} );	
					mare::after(task[i][j-1],task[i][j]);
					mare::after(task[i-1][j],task[i][j]);
					mare::launch(g,task[i][j]);
			}
			if(modj != 0){
				task[i][j] = mare::create_task([&im,i,j,chunk_i,chunk_j,modi,modj]
				{(ca
Model::Model()
	m_model = 0;
Model::Model(const Model& other)
Model::~Model()
bool Model::Initialize(char* filename)
	bool result;
	result = LoadPlainModel(filename);
	if(!result)
	{
		return false;
	}
	return true;
int Model::GetIndexCount()
	return m_indexCount;
void Model::Shutdown()
	ReleaseModel();
	return;
bool Model::LoadPlainModel(char* filename)
	std::ifstream fin;
	char input;
	int i;
	fin.open(filename);
	if(fin.fail())
	{
		return false;
	}
	fin.get(input);
	while(input != ':')
	{
			fin.get(input);
	}
	fin >> m_vertexCount;
	m_indexCount = m_vertexCount;
	m_model = new ModelType[m_vertexCount];
	if(!m_model)
	{
		return false;
	}
	fin.get(input);
	while(input != ':')
	{
		fin.get(input);
	}
	fin.get(input);
	fin.get(input);
	for(i=0; i<m_vertexCount; i++)
	{		
			fin >> m_model[i].x >> m_model[i].y >> m_model[i].z;
			m_model[i].r = 1.0f, m_model[i].g = 0.0f, m_model[i].b = 0.0f, m_model[i].a = 1.0f;
	}
	fin.close();
	return true;
void Model::ReleaseModel()
	if(m_model)
	{
InvokeManager::InvokeManager()
InvokeManager::~InvokeManager()
void InvokeManager::addFor(QAbstractTransition *transition, QString targetType,
                           QString source)
  if (invokes.count(transition) == 0)
  {
    EventTransition *eventTransition =
        dynamic_cast<EventTransition *>(transition);
    if (eventTransition == nullptr)
      connect(transition, &QAbstractTransition::triggered,
              std::bind(&InvokeManager::invokeFor, this, transition));
    else
      connect(
          transition, &QAbstractTransition::triggered,
          std::bind(&InvokeManager::invokeForWithArg, this, eventTransition));
  }
  invokes[transition].push_back(Invoke(targetType, source));
void InvokeManager::invokeFor(QAbstractTransition *transition)
  for (auto &invoke : invokes[transition])
  {
    invokeMethod(invoke.targetType, invoke.source);
  }
void InvokeManager::invokeForWithArg(EventTransition *transition)
  for (auto &invoke : invokes[transition])
  {
    auto obj
namespace media {
namespace mp4 {
namespace {
const SampleToGroupEntry kCompactSampleToGroupTable[] =
    {{10, 8}, {9, 5}, {25, 7}, {48, 63}, {8, 2}};
class SampleToGroupIteratorTest : public testing::Test {
 public:
  SampleToGroupIteratorTest() {
    for (size_t i = 0; i < arraysize(kCompactSampleToGroupTable); ++i) {
      for (uint32_t j = 0; j < kCompactSampleToGroupTable[i].sample_count;
           ++j) {
        sample_to_group_table_.push_back(
            kCompactSampleToGroupTable[i].group_description_index);
      }
    }
    sample_to_group_.entries.assign(
        kCompactSampleToGroupTable,
        kCompactSampleToGroupTable + arraysize(kCompactSampleToGroupTable));
    sample_to_group_iterator_.reset(
        new SampleToGroupIterator(sample_to_group_));
  }
 protected:
  std::vector<uint32_t> sample_to_group_table_;
  SampleToGroup sample_to_group_;
  scoped_ptr<SampleToGroupIterator> sample_to_group_iterator_;
 private:
  DISALLOW_COPY_AND_ASSIGN(SampleToGroupIterator
LabInformation::LabInformation():sampleInformation(),sampleResults(),TNCalibrationCurve()
LabInformation::LabInformation(LabSample& sampleInformation):sampleInformation(sampleInformation.getVialPosition(),sampleInformation.getSampleName()),
	                                                                      sampleResults()
LabInformation::LabInformation(LabSample& sampleInformation,LabResults& sampleResults,CalibrationCurve& calibrationCurve):sampleInformation(sampleInformation),
	sampleResults(sampleResults),TNCalibrationCurve(calibrationCurve)
LabSample& LabInformation::getSampleInformation()
	return sampleInformation;
LabResults& LabInformation::getSampleResults()
	return sampleResults;
void LabInformation::setLabResults(LabResults& sampleResultsIn)
	sampleResults.setAreas(sampleResultsIn.getAreas());
	sampleResults.setConcentrations(sampleResultsIn.getConcentrations());
void LabInformation::setLabSample(LabSample& sampleInformationIn)
	sampleInformation.setSampleName(sampleInfor
/*
 *
 *  Created on: 07.07.2012
 *	Author: Tobias Kohlbau <tobias.kohlbau@gmail.com>
 *
 */
Load::Load() {
	setPath("");
	setName("");
Load::Load(std::string loadPath, std::string loadName) {
	setPath(loadPath);
	setName(loadName);
double Load::getAverage() {
	std::string loadOne = getContent(getPath() + "/" + getName());
	loadOne = loadOne.replace(loadOne.find("  "), loadOne.find("  ") + 1, " ");
	usleep(500000);
	std::string loadTwo = getContent(getPath() + "/" + getName());
	loadTwo = loadTwo.replace(loadTwo.find("  "), loadTwo.find("  ") + 1, " ");
	std::string one[5];
	std::string two[5];
	double oneComplete = 0;
	double twoComplete = 0;
	for (int i = 0; i < 5; i++) {
		one[i] = loadOne.substr(0, loadOne.find(" "));
		two[i] = loadTwo.substr(0, loadTwo.find(" "));
		loadOne = loadOne.replace(0, one[i].length() + 1, "");
		loadTwo = loadTwo.replace(0, two[i].length() + 1, "");
		if (i > 0) {
			oneComplete += stod(one[i]);
			twoComplete += stod(two[i]);
		}
	}
	return (1 - ((stod
namespace cards {
    AssetLocatorDatabaseImpl::AssetLocatorDatabaseImpl()
    {
      database = new AssetLocatorSQLLiteDatabase("AssetLocator.db");
    }
    AssetLocatorDatabaseImpl::~AssetLocatorDatabaseImpl()
    {
      delete database;
    }
    AssetLocator::Locations
    AssetLocatorDatabaseImpl::getFilepath( AssetTag* assetTag ) const
    {
      return database->query(assetTag->getName());
    }
    void
    AssetLocatorDatabaseImpl::removeAsset( AssetTag* assetTag )
    {
      database->remove(assetTag->getName());
    }
    void
    AssetLocatorDatabaseImpl::addLevelOfDetailLocation( AssetTag* assetTag, unsigned int lod, std::string location )
    {
      database->insert(assetTag->getName(), lod, location);
    }
    void
    AssetLocatorDatabaseImpl::removeLevelOfDetailLocation( AssetTag* assetTag, unsigned int lod )
    {
      database->remove(assetTag->getName(), lod);
    }
    void
    AssetLocatorDatabaseImpl::updateLevelOfDetailLocation( AssetTag* assetTag, unsig
/*
 * ClippingPlaneLocator.cpp - Methods for the ClippingPlaneLocator class
 *
 * Author: Patrick O'Leary
 * Created: May 27, 2008
 * Copyright: 2008. All rights reserved.
 */
/*
 * ClippingPlaneLocator - Constructor for ClippingPlaneLocator class.
 *
 * parameter locatorTool - Vrui::LocatorTool *
 * parameter toirt_Samhlaigh - Toirt_Samhlaigh *
 */
ClippingPlaneLocator::ClippingPlaneLocator(Vrui::LocatorTool * locatorTool,
		Toirt_Samhlaigh* toirt_Samhlaigh) :
	BaseLocator(locatorTool, toirt_Samhlaigh), clippingPlane(0) {
	/* Find a clipping plane index for this locator: */
	ClippingPlane * clippingPlanes = toirt_Samhlaigh->getClippingPlanes();
	for (int i=0; i<toirt_Samhlaigh->getNumberOfClippingPlanes(); ++i)
		if (!clippingPlanes[i].isAllocated()) {
			clippingPlane=&clippingPlanes[i];
			break;
		}
	/* Allocate the clipping plane: */
	if (clippingPlane!=0) {
		clippingPlane->setActive(false);
		clippingPlane->setAllocated(true);
	}
/*
 * ~ClippingPlaneLocator - Destructor for Clip

 */
ClippingPlaneLocator::~ClippingPlaneLocator(void) {
	if (clippingPlane!=0) {
		clippingPlane->setActive(false);
		clippingPlane->setAllocated(false);
	}
/*
 * motionCallback
 *
 * parameter callbackData - Vrui::LocatorTool::MotionCallbackData *
 */
void ClippingPlaneLocator::motionCallback(
		Vrui::LocatorTool::MotionCallbackData* callbackData) {
	if (clippingPlane!=0&&clippingPlane->isActive()) {
		Vrui::Vector planeNormal=
				callbackData->currentTransformation.transform(Vrui::Vector(0,
						1, 0));
		Vrui::Point planePoint=callbackData->currentTransformation.getOrigin();
		clippingPlane->setPlane(Vrui::Plane(planeNormal, planePoint));
	}
/*
 * buttonPressCallback
 *
 * parameter callbackData - Vrui::LocatorTool::ButtonPressCallbackData *
 */
void ClippingPlaneLocator::buttonPressCallback(
		Vrui::LocatorTool::ButtonPressCallbackData* callbackData) {
	if (clippingPlane!=0)
		clippingPlane->setActive(true);
/*
 * buttonReleaseCallback
 *
 * parameter callbackData - Vrui::Locato
namespace OpenDDS
  namespace DCPS
  {
    class RepoIdSetMap;
    class OpenDDS_Dcps_Export RepoIdSetMap
    {
      public:
        typedef std::map<RepoId, RepoIdSet_rch> MapType;
        RepoIdSetMap();
        virtual ~RepoIdSetMap();
        int        insert(RepoId key, RepoId value);
        RepoIdSet* find(RepoId key);
        int        remove(RepoId key, RepoId value);
        RepoIdSet* remove_set(RepoId key);
        int release_publisher(RepoId subscriber_id, RepoId publisher_id);
        size_t size() const;
        MapType& map();
        const MapType& map() const;
        size_t marshaled_size ();
        
        ACE_Message_Block* marshal (bool byte_order);
        bool is_subset (RepoIdSetMap& map, RepoId id);
        
        int demarshal (ACE_Message_Block* acks, bool byte_order);
        
        void get_keys (RepoIdSet& keys);
    private:
        RepoIdSet* find_or_create(RepoId key);
        MapType  map_;
    };
  }  /* namespace DCPS */
}  /* namespace Op
namespace Attr
    DefineFloat4(ModelPos, 'mpos', ReadWrite);
    DefineInt(ModelInt, 'mint', ReadWrite);
    DefineBool(ModelBool, 'mbol', ReadWrite);
    DefineString(ModelString, 'mstr', ReadWrite);
    DefineInt(ModelNodeInt, 'mnin', ReadWrite);
    DefineString(ModelNodeString, 'mnst', ReadWrite);
namespace Test
__ImplementClass(Test::ModelLoadSaveTest, 'MLST', Test::TestCase);
using namespace Models;
using namespace IO;
/**
*/
void
ModelLoadSaveTest::TestModel(const Ptr<Model>& model)
/*
    FIXME
    this->Verify(model.isvalid());
    this->Verify(model->Attributes().Contains(Attr::ModelPos));
    this->Verify(model->Attributes().Contains(Attr::ModelInt));
    this->Verify(model->Attributes().Contains(Attr::ModelBool));
    this->Verify(model->Attributes().Contains(Attr::ModelString));
    this->Verify(model->Attributes().GetVector3(Attr::ModelPos) == Math::vector3(1.0f, 2.0f, 3.0f));
    this->Verify(model->Attributes().GetInt(Attr::ModelInt) == 23);
    this->Verify(model->Att

    this->Verify(model->Attributes().GetString(Attr::ModelString) == "Bla Bla");
    this->Verify(model->GetNodes().Size() == 3);
    this->Verify(model->HasNode("Node0"));
    this->Verify(model->HasNode("Node1"));
    this->Verify(model->HasNode("Node2"));
    const Ptr<ModelNode>& node0 = model->LookupNode("Node0");
    const Ptr<ModelNode>& node1 = model->LookupNode("Node1");
    const Ptr<ModelNode>& node2 = model->LookupNode("Node2");
    this->Verify(node0->GetName() == "Node0");
    this->Verify(!node0->HasParent());
    this->Verify(node0->IsAttachedToModel());
    this->Verify(node0->GetModel() == model);
    this->Verify(node0->GetChildren().Size() == 1);
    this->Verify(node0->GetChildren()[0] == node1);
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node0->Attributes().GetInt(Attr::ModelNodeInt) == 24);
    this->Verify(node0->Attributes().GetString(Attr::ModelNod

    this->Verify(node1->GetName() == "Node1");
    this->Verify(node1->HasParent());
    this->Verify(node1->GetParent() == node0);
    this->Verify(node1->IsAttachedToModel());
    this->Verify(node1->GetModel() == model);
    this->Verify(node1->GetChildren().Size() == 0);
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node1->Attributes().GetInt(Attr::ModelNodeInt) == 25);
    this->Verify(node1->Attributes().GetString(Attr::ModelNodeString) == "Blob");
    this->Verify(node2->GetName() == "Node2");
    this->Verify(!node2->HasParent());
    this->Verify(node2->IsAttachedToModel());
    this->Verify(node2->GetModel() == model);
    this->Verify(node2->GetChildren().Size() == 0);
    this->Verify(node2->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node2->Attributes().GetString(Attr::ModelNodeString) == "Blah");
*/
/**
*/
void
ModelLoadSaveTest::TestPartialMo

/*
    FIXME
    this->Verify(model.isvalid());
    this->Verify(model->Attributes().Contains(Attr::ModelPos));
    this->Verify(model->Attributes().Contains(Attr::ModelInt));
    this->Verify(model->Attributes().Contains(Attr::ModelBool));
    this->Verify(model->Attributes().Contains(Attr::ModelString));
    this->Verify(model->Attributes().GetVector3(Attr::ModelPos) == Math::vector3(1.0f, 2.0f, 3.0f));
    this->Verify(model->Attributes().GetInt(Attr::ModelInt) == 23);
    this->Verify(model->Attributes().GetBool(Attr::ModelBool) == true);
    this->Verify(model->Attributes().GetString(Attr::ModelString) == "Bla Bla");
    this->Verify(model->GetNodes().Size() == 2);
    this->Verify(model->HasNode("Node0"));
    this->Verify(model->HasNode("Node1"));
    const Ptr<ModelNode>& node0 = model->LookupNode("Node0");
    const Ptr<ModelNode>& node1 = model->LookupNode("Node1");
    this->Verify(node0->GetName() == "Node0");
    this->Verify(!node0->HasParent());
    this->Verify(node0->

    this->Verify(node0->GetModel() == model);
    this->Verify(node0->GetChildren().Size() == 1);
    this->Verify(node0->GetChildren()[0] == node1);
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node0->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node0->Attributes().GetInt(Attr::ModelNodeInt) == 24);
    this->Verify(node0->Attributes().GetString(Attr::ModelNodeString) == "Blub Blub");
    this->Verify(node1->GetName() == "Node1");
    this->Verify(node1->HasParent());
    this->Verify(node1->GetParent() == node0);
    this->Verify(node1->IsAttachedToModel());
    this->Verify(node1->GetModel() == model);
    this->Verify(node1->GetChildren().Size() == 0);
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeInt));
    this->Verify(node1->Attributes().Contains(Attr::ModelNodeString));
    this->Verify(node1->Attributes().GetInt(Attr::ModelNodeInt) == 25);
    this->Verify(node1->Attributes().GetString(Attr::ModelNodeSt

*/
/**
*/
void
ModelLoadSaveTest::Run()
/*
    FIXME
    Ptr<IO::Server> ioServer = IO::Server::Create();
    ioServer->RegisterUriScheme("file", IO::FileStream::RTTI);
    Ptr<ModelServer> modelServer = ModelServer::Create();
    const URI srcFile = "home:work/testdata/modelloadsavetest.xml";
    const URI xmlDestFile = "home:intermediate/testdata/modelloadsavetest.xml";
    const URI binDestFile = "home:intermediate/testdata/modelloadsavetest.n3";
    if (ioServer->FileExists(xmlDestFile))
    {
        ioServer->DeleteFile(xmlDestFile);
        this->Verify(!ioServer->FileExists(xmlDestFile));
    }
    if (ioServer->FileExists(binDestFile))
    {
        ioServer->DeleteFile(binDestFile);
        this->Verify(!ioServer->FileExists(binDestFile));
    }
    
    bool modelLoaded = modelServer->LoadModels(srcFile);
    this->Verify(modelLoaded);
    if (modelLoaded)
    {
        this->Verify(modelServer->HasModel("ModelLoadSaveTest"));
        Ptr<Model> model = modelServer->LookupM

        this->Verify(model->GetName() == "ModelLoadSaveTest");
        this->TestModel(model);
        
        bool xmlModelSaved = modelServer->SaveModel(model, xmlDestFile, XmlModelWriter::RTTI);
        this->Verify(xmlModelSaved);
        this->Verify(ioServer->FileExists(xmlDestFile));
        bool binModelSaved = modelServer->SaveModel(model, binDestFile, BinaryModelWriter::RTTI);
        this->Verify(binModelSaved);
        this->Verify(ioServer->FileExists(binDestFile));
        modelServer->DiscardModel("ModelLoadSaveTest");
        this->Verify(!modelServer->HasModel("ModelLoadSaveTest"));
        model = 0;
        modelLoaded = modelServer->LoadModels(xmlDestFile);
        if (modelLoaded)
        {
            this->Verify(modelServer->HasModel("ModelLoadSaveTest"));
            model = modelServer->LookupModel("ModelLoadSaveTest");
            this->Verify(model->GetName() == "ModelLoadSaveTest");
            this->TestModel(model);
            modelServer->DiscardModel

            this->Verify(!modelServer->HasModel("ModelLoadSaveTest"));
            model = 0;
        }
        modelLoaded = modelServer->LoadModels(binDestFile);
        if (modelLoaded)
        {
            this->Verify(modelServer->HasModel("ModelLoadSaveTest"));
            model = modelServer->LookupModel("ModelLoadSaveTest");
            this->Verify(model->GetName() == "ModelLoadSaveTest");
            this->TestModel(model);
            modelServer->DiscardModel("ModelLoadSaveTest");
            this->Verify(!modelServer->HasModel("ModelLoadSaveTest"));
            model = 0;
        }
        modelLoaded = modelServer->LoadModels(srcFile);
        this->Verify(modelLoaded);
        model = modelServer->LookupModel("ModelLoadSaveTest");
        Ptr<Model> clone0 = modelServer->CloneModel(model, "Clone0");
        this->Verify(clone0->GetName() == "Clone0");
        this->TestModel(clone0);
        Ptr<Model> clone1 = modelServer->CloneModelFragment(model, "Node0", "Clone1");
                                                                                                                                                                                                                                
                                                                                                                                                                                                                                
                                                                                                                                                                                                                                struct Dump : std::ofstream
                                                                                                                                                                                                                                {
                                                                        

                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                        (*f) << text;
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                    Dump(Dump&& rhs) : f(std::move(rhs.f)) {}
                       

                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                Dump files[] = { Dump("main.cpp", R"delim(
int main()
    std::cout << sum(3, 4) << std::endl;
}    
                                                                                                                                                                                                                                                )delim"), Dump("a.h", R"delim(
int sum(int, int);
                                                                                                                                             

                                                                                
int sum(int a, int b) { return a + b; }
                                                                                                                                                                                                                                                )delim") };
                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                
                                                                                                                                                
/*
 * çæ§ç³»ç»å½åloadæåµçåºç±»
 * created by guangchao.tian@opi-corp.com
 * 2010-03-19
 */
namespace MyUtil {
using namespace std;
using namespace xce::sysinfo;
class LoadMonitor : public IceUtil::Thread 
public:
	/*
	 * æè¿°ï¼é»è®¤åå§åå½æ°ï¼ä¸å»ºè®®ä½¿ç¨ï¼
	 */
	LoadMonitor() : _sleepSeconds(60), _maxLoadPercent(0.6), _maxLoadNum(6), _loadType(LOAD_ONE)
	{
		start(65535).detach();
	}
	/*
	 * æè¿°ï¼å¸¦åæ°çåå§åå½æ°
	 * åæ°ï¼sleepSecondsæ¯æ¬¡æ«æç³»ç»loadç¶æçé´éæ¶é´
	 *		 maxLoadPercentä¸ºæ ¹æ®loadä¸cpuä¸ªæ°çæ¯å¼å¤æ­æ¯å¦highloadçéå¼
	 *		 maxLoadNumä¸ºæ ¹æ®loadçå¼å¤æ­æ¯å¦highloadçéå¼
	 *		 loadTypeä¸ºéæ ·ç³»ç»loadä¿¡æ¯çç±»åï¼åä¸º1åéï¼5åéå15åé
	 */
	LoadMonitor(int sleepSeconds, double maxLoadPercent, double maxLoadNum, LOAD_TYPE loadType): 
				_sleepSeconds(sleepSeconds), 
				_maxLoadPercent(maxLoadPercent), 
				_maxLoadNum(maxLoadNum),
				_loadType(loadType)
	{
		start(65535).detach();
	}
	/*
	 * çº¿ç¨è¿è¡çå½æ°
	 */
	virtual void run()
	{
		SysInfo& si = SysInfo::instance();
		
		while(true)
		{
			double loadNumNow = 0;
			double loadPercentNow = 0;
			int cpuNum = 0;
		
			si.get

			cpuNum = si.getCpuNum();
			loadPercentNow = loadNumNow/(double)cpuNum;
		
			if((si.isHighLoadByPercent(_loadType, _maxLoadPercent)) | (si.isHighLoadByNum(_loadType, _maxLoadNum)))
			{
				notifyHighLoad(loadNumNow, loadPercentNow);
			}else
			{
				notifyLoadNow(loadNumNow, loadPercentNow);
			}
			
			sleep(_sleepSeconds);
		}
	}
protected:
	/*
	 * æè¿°ï¼çº¯èå½æ°ï¼å­ç±»å¿é¡»å®ç°ï¼ç¨äºå¨æ¶å°highloadçéç¥æ¶è¿è¡ç¸åºçå¤ç
	 * åæ°ï¼loadNumNowå½åç³»ç»çloadï¼loadPercentNowå½åç³»ç»loadä¸cpuä¸ªæ°çæ¯å¼
	 */
	virtual void notifyHighLoad(double loadNumNow, double loadPercentNow) = 0;
	/*
	 * æè¿°ï¼çº¯èå½æ°ï¼å­ç±»å¿é¡»å®ç°ï¼ç¨äºå¨æ¶å°loadä¿¡æ¯æ¶è¿è¡ç¸åºçå¤ç
	 * åæ°ï¼loadNumNowå½åç³»ç»çloadï¼loadPercentNowå½åç³»ç»loadä¸cpuä¸ªæ°çæ¯å¼
	 */
	virtual void notifyLoadNow(double loadNumNow, double loadPercentNow) = 0;
protected:
	/*
	 * æè¿°ï¼è®¾ç½®å¤æ­highloadçä¿¡æ¯
	 * åæ°ï¼sleepSecondsæ¯æ¬¡æ«æç³»ç»loadç¶æçé´éæ¶é´
	 *		 maxLoadPercentä¸ºæ ¹æ®loadä¸cpuä¸ªæ°çæ¯å¼å¤æ­æ¯å¦highloadçéå¼
	 *		 maxLoadNumä¸ºæ ¹æ®loadçå¼å¤æ­æ¯å¦highloadçéå¼
	 *		 loadTypeä¸ºéæ ·ç³»ç»loadä¿¡æ¯çç±»åï¼åä¸º1åéï¼5åéå15åé
	 */
	void setConfig(double maxLoadNum, double maxLoadPercent, int
namespace Medit
namespace MeditBase
namespace DI
class ServiceLocator;
class ServiceLocatorAware
    /**
     * @brief stored service locator
     */
    ServiceLocator *serviceLocator;
public:
    typedef MeditBase::Allocator<ServiceLocatorAware> Allocator;
    /**
     * @brief create empty instance
     */
    ServiceLocatorAware();
    /**
     * @brief create instance with locator
     * @param locator service locator to set
     */
    ServiceLocatorAware(ServiceLocator *locator);
    /**
     * @brief copytor
     * @param original instance with original data
     */
    ServiceLocatorAware(const ServiceLocatorAware &original);
    /**
     * @brief destructor
     */
    virtual ~ServiceLocatorAware();
    /**
     * @brief return current service locator
     * @return current service locator
     */
    ServiceLocator *getServiceLocator() const;
    /**
     * @brief set new service locator
     * @param value locator to set
     */
    void setServiceLocator(ServiceLocator *v
/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2013 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */
namespace xe {
Arena::Arena(size_t chunk_size)
    : chunk_size_(chunk_size), head_chunk_(nullptr), active_chunk_(nullptr) {}
Arena::~Arena() {
  Reset();
  Chunk* chunk = head_chunk_;
  while (chunk) {
    Chunk* next = chunk->next;
    delete chunk;
    chunk = next;
  }
  head_chunk_ = nullptr;
void Arena::Reset() {
  active_chunk_ = head_chunk_;
  if (active_chunk_) {
    active_chunk_->offset = 0;
  }
void Arena::DebugFill() {
  auto chunk = head_chunk_;
  while (chunk) {
    std::memset(chunk->buffer,

    chunk = chunk->next;
  }
void* Arena::Alloc(size_t size) {
  if (active_chunk_) {
    if (active_chunk_->capacity - active_chunk_->offset < size + 4096) {
      Chunk* next = active_chunk_->next;
      if (!next) {
        assert_true(size < chunk_size_, "need to support larger chunks");
        next = new Chunk(chunk_size_);
        active_chunk_->next = next;
      }
      next->offset = 0;
      active_chunk_ = next;
    }
  } else {
    head_chunk_ = active_chunk_ = new Chunk(chunk_size_);
  }
  uint8_t* p = active_chunk_->buffer + active_chunk_->offset;
  active_chunk_->offset += size;
  return p;
void Arena::Rewind(size_t size) { active_chunk_->offset -= size; }
size_t Arena::CalculateSize() {
  size_t total_length = 0;
  Chunk* chunk = head_chunk_;
  while (chunk) {
    total_length += chunk->offset;
    if (chunk == active_chunk_) {
      break;
    }
    chunk = chunk->next;
  }
  return total_length;
void* Arena::CloneContents() {
  size_t total_length = CalculateSize();
using lz5::Prompt;
using lz5::Lz5_Interpreter;
using simulation::Parameters;
using simulation::Population;
using simulation::Population1;
using selection::RanSel;
using selection::IndSel;
using report::BaseReport; 
using report::ParRepo;
using report::IndSelRepo;
using report::TandemRepo;
using report::PopRepo;
using report::IndRepo;
using report::GenomeRepo;
using simulation::RepSim;
using simulation::RepSim1;
using selection::Tandem;
gsl_rng* prand = gsl_rng_alloc(gsl_rng_mt19937);
int main(){
  gsl_rng_set(prand,time(0));
  Prompt promptObject;
  Lz5_Interpreter interp;
  interp.readcomm("commands.lz5");
  lz5_Result_Struct lrs;
  string prompt;  
  Parameters par;
  par.setName("par");
  Population pop(par);
  pop.setName("pop");
  Population1 pop1(par);
  pop1.setName("pop1");
  
  RanSel rs;
  rs.setName("rs");
  IndSel indsel;
  indsel.setName("indsel");
  Tandem td;
  td.setName("td");
  ParRepo parRepo;
  parRepo.setName("parRepo");
  
  IndSelRepo iSelRepo;
  iSelRepo.setName
namespace dort {
  SampledFilter::SampledFilter(std::shared_ptr<Filter> filter,
      Vec2i sample_radius):
    sample_radius(sample_radius),
    filter_to_sample_radius(Vec2(sample_radius) * filter->inv_radius),
    samples(sample_radius.x * sample_radius.y),
    radius(filter->radius)
  {
    Vec2 inv_sample_radius = 1.f / Vec2(this->sample_radius);
    for(int32_t y = 0; y < this->sample_radius.y; ++y) {
      for(int32_t x = 0; x < this->sample_radius.x; ++x) {
        uint32_t idx = y * this->sample_radius.x + x;
        float filter_x = float(x) * inv_sample_radius.x * filter->radius.x;
        float filter_y = float(y) * inv_sample_radius.y * filter->radius.y;
        this->samples.at(idx) = filter->evaluate(Vec2(filter_x, filter_y));
      }
    }
  }
  float SampledFilter::evaluate(Vec2 p) const {
    Vec2i sample_p = floor_vec2i(abs(p) * this->filter_to_sample_radius);
    if(sample_p.x >= this->sample_radius.x) {
      return 0.f;
    }
    if(sample_p.y >= this->sample_radi
using namespace std;
RepoControl::RepoControl(const string &path)
    : path(path), uuid(""), udsClient(0), udsRepo(0), localRepo(0)
RepoControl::~RepoControl()
void
RepoControl::open()
    try {
        udsClient = new UDSClient(path);
        udsClient->connect();
        udsRepo = new UDSRepo(udsClient);
    } catch (SystemException e) {
        if (udsRepo)
            delete udsRepo;
        udsRepo = NULL;
    }
    localRepo = new LocalRepo();
    localRepo->open(path);
    if (udsRepo)
        uuid = udsRepo->getUUID();
    else
        uuid = localRepo->getUUID();
void
RepoControl::close()
    if (udsClient) {
        delete udsRepo;
        delete udsClient;
    }
    if (localRepo) {
        localRepo->close();
        delete localRepo;
    }
    udsClient = NULL;
    udsRepo = NULL;
    localRepo = NULL;
string
RepoControl::getPath()
    return path;
string
RepoControl::getUUID()
    ASSERT(uuid != "");
    return uuid;
string
RepoControl::getHead()
    if (udsRepo)
       

    return localRepo->getHead().hex();
bool
RepoControl::hasCommit(const string &objId)
    ObjectHash hash = ObjectHash::fromHex(objId);
    if (udsRepo)
        return udsRepo->hasObject(hash);
    return localRepo->hasObject(hash);
string
RepoControl::pull(const string &host, const string &path)
    if (udsRepo) {
        strwstream pullReq;
        ObjectHash newHead;
        pullReq.writePStr("pull");
        pullReq.writePStr(host + ":" + path);
        strstream pullResp = udsRepo->callExt("FUSE", pullReq.str());
        if (pullResp.ended()) {
            WARNING("Unknown failure trying to pull from %s:%s",
                    host.c_str(), path.c_str());
            return "";
        }
        if (pullResp.readUInt8() == 1) {
            string error;
            pullResp.readPStr(error);
            WARNING("Failed to pull from %s:%s: %s",
                    host.c_str(), path.c_str(), error.c_str());
            return "";
        }
        pullResp.readHash(newHead);
   

        checkoutReq.writePStr("checkout");
        checkoutReq.writeHash(newHead);
        checkoutReq.writeUInt8(/* force */0);
        strstream checkoutResp = udsRepo->callExt("FUSE", checkoutReq.str());
        if (checkoutResp.ended()) {
            WARNING("Unknown failure trying to checkout %s",
                    newHead.hex().c_str());
            return "";
        }
        if (checkoutResp.readUInt8() == 0) {
            string error;
            checkoutResp.readPStr(error);
            WARNING("Failed to checkout %s", error.c_str());
            return "";
        }
        LOG("RepoControl::pull: Update from %s:%s suceeded",
            host.c_str(), path.c_str());
        return "";
    }
    RemoteRepo::sp srcRepo(new RemoteRepo());
    if (!srcRepo->connect(host + ":" + path)) {
        LOG("RepoControl::pull: Failed to connect to source %s", host.c_str());
        return  "";
    }
    ObjectHash newHead = srcRepo->get()->getHead();
    localRepo->pull(srcRepo->get
/*=============================================================================
	MemStack.cpp: Unreal memory grabbing functions
=============================================================================*/
static struct FForceInitAtBootFMemStack : public TForceInitAtBoot<FMemStack>
{} FForceInitAtBootFMemStack;
template<> uint32 FThreadSingleton<FMemStack>::TlsSlot = 0;
DECLARE_MEMORY_STAT(TEXT("MemStack Allocated (all threads)"), STAT_MemStackAllocated,STATGROUP_Memory);
DECLARE_MEMORY_STAT(TEXT("MemStack Used (all threads)"), STAT_MemStackUsed,STATGROUP_Memory);
/*-----------------------------------------------------------------------------
	FMemStack implementation.
-----------------------------------------------------------------------------*/
FMemStack::FMemStack( int32 InDefaultChunkSize /*= DEFAULT_CHUNK_SIZE*/ )
:	Top(NULL)
,	End(NULL)
,	DefaultChunkSize(InDefaultChunkSize)
,	TopChunk(NULL)
,	TopMark(NULL)
,	UnusedChunks(NULL)
,	NumMarks(0)
FMemStack::~FMemStack()
	check(GIsC

	Tick();
	while( UnusedChunks )
	{
		FTaggedMemory* Old = UnusedChunks;
		UnusedChunks = UnusedChunks->Next;
		DEC_MEMORY_STAT_BY( STAT_MemStackAllocated, Old->DataSize + sizeof(FTaggedMemory) );
		FMemory::Free( Old );
	}
void FMemStack::Tick() const
	check(TopChunk==NULL);
int32 FMemStack::GetByteCount() const
	int32 Count = 0;
	for( FTaggedMemory* Chunk=TopChunk; Chunk; Chunk=Chunk->Next )
	{
		if( Chunk!=TopChunk )
		{
			Count += Chunk->DataSize;
		}
		else
		{
			Count += Top - Chunk->Data;
		}
	}
	return Count;
int32 FMemStack::GetUnusedByteCount() const
	int32 Count = 0;
	for( FTaggedMemory* Chunk=UnusedChunks; Chunk; Chunk=Chunk->Next )
	{
		Count += Chunk->DataSize;
	}
	return Count;
void FMemStack::AllocateNewChunk( int32 MinSize )
	FTaggedMemory* Chunk=NULL;
	for( FTaggedMemory** Link=&UnusedChunks; *Link; Link=&(*Link)->Next )
	{
		if( (*Link)->DataSize >= MinSize )
		{
			Chunk = *Link;
			*Link = (*Link)->Next;
			break;
		}
	}
	if( !Chunk )
	{
		const int32 DataSize   

		const uint32 AllocSize = DataSize + sizeof(FTaggedMemory);
		Chunk                  = (FTaggedMemory*)FMemory::Malloc( AllocSize );
		Chunk->DataSize        = DataSize;
		INC_MEMORY_STAT_BY( STAT_MemStackAllocated, AllocSize );	
	}
	if( Chunk != TopChunk )
	{
		INC_MEMORY_STAT_BY( STAT_MemStackUsed, Chunk->DataSize );
	}
	Chunk->Next = TopChunk;
	TopChunk    = Chunk;
	Top         = Chunk->Data;
	End         = Top + Chunk->DataSize;
void FMemStack::FreeChunks( FTaggedMemory* NewTopChunk )
	while( TopChunk!=NewTopChunk )
	{
		FTaggedMemory* RemoveChunk = TopChunk;
		TopChunk                   = TopChunk->Next;
		RemoveChunk->Next          = UnusedChunks;
		UnusedChunks               = RemoveChunk;
		DEC_MEMORY_STAT_BY( STAT_MemStackUsed, RemoveChunk->DataSize );
	}
	Top = NULL;
	End = NULL;
	if( TopChunk )
	{
		Top = TopChunk->Data;
		End = Top + TopChunk->DataSize;
	}
bool FMemStack::ContainsPointer( const void* Pointer ) const
	const uint8* Ptr = (const uint8*)Pointer;
	for (const F
namespace Stream
	class OV_API IInputStreamHelper : public Stream::IInputStream
	{
	public:
		virtual Stream::boolean setEndianness(const Stream::EEndianness& eEndianness)=0;
		virtual Stream::EEndianness getEndianness(void)=0;
		virtual Stream::uint8 receiveUInteger8(void)=0;
		virtual Stream::uint16 receiveUInteger16(void)=0;
		virtual Stream::uint32 receiveUInteger32(void)=0;
		virtual Stream::uint64 receiveUInteger64(void)=0;
		virtual Stream::int8 receiveSInteger8(void)=0;
		virtual Stream::int16 receiveSInteger16(void)=0;
		virtual Stream::int32 receiveSInteger32(void)=0;
		virtual Stream::int64 receiveSInteger64(void)=0;
		virtual Stream::float32 receiveFloat32(void)=0;
		virtual Stream::float64 receiveFloat64(void)=0;
/*
		virtual const char* receiveASCIIString(void)=0;
		virtual const Stream::uint8* receiveUTF8String(void)=0;
		virtual const Stream::uint16* receiveUTF16String(void)=0;
*/
	};
	extern OV_API Stream::IInputStreamHelper* createInputStreamHelper(Stream::IInputStrea
class Sample {
public:
    Sample(const std::string& aName) : name(aName) {}
    virtual ~Sample() {};
    virtual void run() = 0;
    std::string getName() { return name; }
};
typedef std::shared_ptr<Sample> SamplePtr;
class BitsSample : public Sample {
public:
    BitsSample();
    virtual void run();
};
class ForEachSample : public Sample {
public:
    ForEachSample();
    virtual void run();
};
class InitializerSample : public Sample {
public:
    InitializerSample();
    virtual void run();
};
class OutputSample : public Sample {
public:
    OutputSample();
    virtual void run();
};
class ShapeOperatorSample : public Sample {
public:
    ShapeOperatorSample();
    virtual void run();
};
class VTableSample : public Sample {
public:
    VTableSample();
    virtual void run();
};
class EnumSample : public Sample {
public:
    EnumSample();
    virtual void run();
};
class SizeofSample : public Sample {
public:
    SizeofSample();
    virtual void run();
};
class MapSample : public S
void doDalitzCP(Int_t seed = 9){
   gSystem->Load("libPhysics.so");
   gSystem->Load("libRooFit.so");
  gROOT->LoadMacro("twoDStyle.C");
  gROOT->LoadMacro("histoUtils.C");
  twoDStyle();
  gROOT->LoadMacro("AbsComplexBrackets.C+");
  gROOT->LoadMacro("AbsComplex.C+");
  gROOT->LoadMacro("AbsComplexPdf.C+");
  gROOT->LoadMacro("dataThrowerAway.C+");
  gROOT->LoadMacro("ComplexProxy.C+");
  gROOT->LoadMacro("ComplexBW.C+");
  gROOT->LoadMacro("DcyAmplitude.C+");
  gROOT->LoadMacro("DcyGSAmplitude.C+");
  gROOT->LoadMacro("DcyNonRes.C+");
  gROOT->LoadMacro("DbleAmplitude.C+");
  gROOT->LoadMacro("Resonance.C+");
  gROOT->LoadMacro("ComplexSum.C+");
  gROOT->LoadMacro("ComplexProd.C+");
  gROOT->LoadMacro("RooAbsPhaseSpace.C+");
  gROOT->LoadMacro("Roo3BodyPhaseSpace.C+");
  gROOT->LoadMacro("Calculate4BodyProps.h+");
  gROOT->LoadMacro("SpinFactorThreeBody.C+");
  gROOT->LoadMacro("SpinFactor.C+");
  gROOT->LoadMacro("SpinFactors.C+");
  gROOT->LoadMacro("BlattWeisskopf.C+");
  gROOT->L
/*
 * Copyright 2011, Haiku Inc. All rights reserved.
 * This file may be used under the terms of the MIT License.
 *
 * Authors:
 *		JÃ©rÃ´me Duval
 */
Chunk::Chunk(struct btrfs_chunk* chunk, fsblock_t offset)
	:
	fChunk(NULL),
	fInitStatus(B_OK)
	fChunkOffset = offset;
	fChunk = (struct btrfs_chunk*)malloc(sizeof(struct btrfs_chunk)
		+ chunk->StripeCount() * sizeof(struct btrfs_stripe));
	if (fChunk == NULL) {
		fInitStatus = B_NO_MEMORY;
		return;
	}
	memcpy(fChunk, chunk, sizeof(struct btrfs_chunk)
		+ chunk->StripeCount() * sizeof(struct btrfs_stripe));
	TRACE("chunk[0] length %" B_PRIu64 " owner %" B_PRIu64 " stripe_length %"
		B_PRIu64 " type %" B_PRIu64 " stripe_count %u sub_stripes %u "
		"sector_size %" B_PRIu32 "\n", chunk->Length(), chunk->Owner(), 
		chunk->StripeLength(), chunk->Type(), chunk->StripeCount(), 
		chunk->SubStripes(), chunk->SectorSize());
	for(int32 i = 0; i < chunk->StripeCount(); i++) {
		TRACE("chunk.stripe[%" B_PRId32 "].physical %" B_PRId64 " deviceid %
namespace Antumbra
	ChunkCache::ChunkCache(World &world, int minX, int minZ, int maxX, int maxZ)
	{
		m_minX = minX;
		m_minZ = minZ;
		m_maxX = maxX;
		m_maxZ = maxZ;
		m_xChunks = m_maxX - m_minX + 1;
		m_zChunks = m_maxZ - m_minZ + 1;
		m_allLoaded = true;
		for(int z = m_minZ; z <= m_maxZ; z++)
		{
			for(int x = m_minX; x <= m_maxX; x++)
			{
				auto chunk = world.GetChunk(x, z);
				if(!chunk)
				{
					m_allLoaded = false;
				}
				m_chunks.push_back(chunk);
			}
		}
	}
	void ChunkCache::SetBlock(int x, int y, int z, uint8_t id)
	{
		auto chunk = GetChunk(x, z);
		if(chunk)
		{
			int blockX, blockZ;
			GetBlockCoords(x, z, blockX, blockZ);
			chunk->SetBlock(blockX, y, blockZ, id);
		}
	}
	void ChunkCache::SetLight(int x, int y, int z, uint8_t level)
	{
		auto chunk = GetChunk(x, z);
		if(chunk)
		{
			int blockX, blockZ;
			GetBlockCoords(x, z, blockX, blockZ);
			chunk->SetLight(blockX, y, blockZ, level);
		}
	}
	void ChunkCache::SetSkyLight(int x, int y, int z, uint8_t le

	{
		auto chunk = GetChunk(x, z);
		if(chunk)
		{
			int blockX, blockZ;
			GetBlockCoords(x, z, blockX, blockZ);
			chunk->SetSkyLight(blockX, y, blockZ, level);
		}
	}
	uint8_t ChunkCache::GetBlock(int x, int y, int z) const
	{
		auto chunk = GetChunk(x, z);
		if(chunk && y >= 0 && y < Chunk::Height)
		{
			int blockX, blockZ;
			GetBlockCoords(x, z, blockX, blockZ);
			return chunk->GetBlock(blockX, y, blockZ);
		}
		return 0;
	}
	uint8_t ChunkCache::GetLight(int x, int y, int z) const
	{
		auto chunk = GetChunk(x, z);
		if(chunk && y >= 0 && y < Chunk::Height)
		{
			int blockX, blockZ;
			GetBlockCoords(x, z, blockX, blockZ);
			return chunk->GetLight(blockX, y, blockZ);
		}
		return 15;
	}
	uint8_t ChunkCache::GetSkyLight(int x, int y, int z) const
	{
		auto chunk = GetChunk(x, z);
		if(chunk && y >= 0 && y < Chunk::Height)
		{
			int blockX, blockZ;
			GetBlockCoords(x, z, blockX, blockZ);
			return chunk->GetSkyLight(blockX, y, blockZ);
		}
		return 15;
	}
	Chunk *ChunkCache::
/* 
 * Copyright (C) 2011 Department of Robotics Brain and Cognitive Sciences - Istituto Italiano di Tecnologia
 * Author: Ugo Pattacini
 * email:  ugo.pattacini@iit.it
 * Permission is granted to copy, distribute, and/or modify this program
 * under the terms of the GNU General Public License, version 2 or any
 * later version published by the Free Software Foundation.
 *
 * A copy of the license can be found at
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details
*/
using namespace yarp::sig;
genPredModel::genPredModel() {
    valid = true;
    type = "constVelocity";
    
genPredModel::genPredModel(const genPredModel &model) {
    valid = true;
    type = "constVelocity";
genPredModel &genPredModel::operator =(const genPredModel &model) {
    valid = model.valid;
    type  = model.valid;
    

    B = model.B;
    return *this;
bool genPredModel::operator ==(const genPredModel &model) {
    return ((valid==model.valid)&&(type==model.type)&&(A==model.A)&&(B==model.B)); 
void genPredModel::init(double param) {
    printf("genPredModel::init: start \n");
    Matrix _A(3,3);
    Matrix _B(3,3);
    A = _A;
    B = _B;   
    A.zero();
    B.zero();
linVelModel::linVelModel() {
    valid = true;
    type = "constVelocity";
    
linVelModel::linVelModel(const linVelModel &model) {
    valid = true;
    type = "constVelocity";
linVelModel &linVelModel::operator =(const linVelModel &model) {
    valid = model.valid;
    type  = model.valid;
    A = model.A;
    B = model.B;
    return *this;
bool linVelModel::operator ==(const linVelModel &model) {
    return ((valid==model.valid)&&(type==model.type)&&(A==model.A)&&(B==model.B)); 
void linVelModel::init(double param) {
    printf("linVelModel::init: start \n");
    Matrix _A(3,3);
    Matrix _B(3,3);
    A = _A;
    B = _B;
    
  

    B.zero();
    B(0,0) = param;
    printf("linVelModel::init : end \n");
linAccModel::linAccModel() {
    valid = true;
    type = "constAcceleration";
linAccModel::linAccModel(const linAccModel &model) {
    valid = true;
    type = "constAcceleration";
linAccModel &linAccModel::operator =(const linAccModel &model) {
    valid = model.valid;
    type  = model.valid;
    A = model.A;
    B = model.B;
    return *this;
bool linAccModel::operator ==(const linAccModel &model) {
    return ((valid == model.valid) && (type == model.type) && (A == model.A) && (B == model.B)); 
void linAccModel::init(double param) {
    printf("linAccModel::init: start \n");
    Matrix _A(3,3);
    Matrix _B(3,3);
    A = _A;
    B = _B;
    A.zero();
    B.zero();
    printf("linAccModel::init: stop \n");
minJerkModel::minJerkModel() {
    valid = true;
    type = "minimumJerk";
    
minJerkModel::minJerkModel(const minJerkModel &model) {
    valid = true;
    type = "minimumJerk";
    A = model.A;
    B
typedef OpenDDS::DCPS::DomainParticipantImpl::RepoIdSequence RepoIdSequence;
typedef OpenDDS::DCPS::RepoId RepoId;
namespace {
  namespace Factory {
    RepoId not_default_repo_id() {
      RepoId result;
      int i = 1;
      result.guidPrefix[ 0] =  i += 2;
      result.guidPrefix[ 1] =  i += 2;
      result.guidPrefix[ 2] =  i += 2;
      result.guidPrefix[ 3] =  i += 2;
      result.guidPrefix[ 4] =  i += 2;
      result.guidPrefix[ 5] =  i += 2;
      result.guidPrefix[ 6] =  i += 2;
      result.guidPrefix[ 7] =  i += 2;
      result.guidPrefix[ 8] =  i += 2;
      result.guidPrefix[ 9] =  i += 2;
      result.guidPrefix[10] =  i += 2;
      result.guidPrefix[11] =  i += 2;
      result.entityId.entityKey[0] = 0;
      result.entityId.entityKey[1] = 0;
      result.entityId.entityKey[2] = 0;
      result.entityId.entityKind = 123;
      return result;
    }
  };
  long entityKey(const RepoId& id) {
    long result = (((id.entityId.entityKey[0]  << 8) |
                     id.en

                     id.entityId.entityKey[2];
    return result;
  }
};
int
ACE_TMAIN(int, ACE_TCHAR*[])
    RepoId repoId;
    memset(&repoId, 0, sizeof(repoId));
    RepoIdSequence seq(repoId);
    TEST_ASSERT(entityKey(seq.next()) == 1);
    TEST_ASSERT(entityKey(seq.next()) == 2);
    TEST_ASSERT(entityKey(seq.next()) == 3);
    TEST_ASSERT(entityKey(seq.next()) == 4);
  }
    RepoId repoId = Factory::not_default_repo_id();
    RepoIdSequence seq(repoId);
    {
      RepoId result = seq.next();
      TEST_ASSERT(!memcmp(repoId.guidPrefix, 
                          result.guidPrefix, 
                          sizeof repoId.guidPrefix));
      TEST_ASSERT(entityKey(result) == 1);
      TEST_ASSERT(repoId.entityId.entityKind == result.entityId.entityKind);
    }
    {
      RepoId result = seq.next();
      TEST_ASSERT(!memcmp(repoId.guidPrefix, 
                          result.guidPrefix, 
                          sizeof repoId.guidPrefix));
      TEST_ASSERT(entityKey(result) 
enum {
    REPO_ITEM_TYPE = QStandardItem::UserType,
    REPO_CATEGORY_TYPE
};
/**
 * Represent a repo
 */
class RepoItem : public QStandardItem {
public:
    RepoItem(const ServerRepo& repo);
    void setRepo(const ServerRepo& repo);
    void setLocalRepo(const LocalRepo& repo);
    virtual int type() const { return REPO_ITEM_TYPE; }
    const ServerRepo& repo() const { return repo_; }
    const LocalRepo& localRepo() const { return local_repo_; }
    /**
     * Although we don't use this in our custom delegate, we need to
     * implemented it for our proxy filter model.
     */
    QVariant data(int role=Qt::UserRole + 1) const;
    /**
     * Every time the item is painted, we record the metrics of each part of
     * the item on the screen. So later we the mouse click/hover the item, we
     * can decide which part is hovered, and to do corresponding actions.
     */
    struct Metrics {
        QRect icon_rect;
        QRect name_rect;
        QRect subtitle_rect;
        QRect s

    };
    void setMetrics(const Metrics& metrics) const { metrics_ = metrics; }
    const Metrics& metrics() const { return metrics_; }
    void setCloneTask(const CloneTask& task=CloneTask()) { clone_task_ = task; }
    const CloneTask& cloneTask() const { return clone_task_; }
    bool repoDownloadable() const;
    void setSyncNowClicked(bool val) { sync_now_clicked_ = val; }
    bool syncNowClicked() const { return sync_now_clicked_; }
private:
    ServerRepo repo_;
    LocalRepo local_repo_;
    mutable Metrics metrics_;
    CloneTask clone_task_;
    bool sync_now_clicked_;
};
/**
 * Represent a repo category
 * E.g (My Repos, Shared repos, Group 1 repos, Group 2 repos ...)
 */
class RepoCategoryItem: public QStandardItem {
public:
    /**
     * Create a group category
     */
    RepoCategoryItem(int cat_index, const QString& name, int group_id=-1);
    virtual int type() const { return REPO_CATEGORY_TYPE; }
    const QString& name() const { return name_; }
    bool isGroup() 
namespace TAO
  namespace DCPS
  {
    bool
    DataSampleList::dequeue_next_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_sample (stale);
        }
      bool found = false;
      for( DataSampleListElement* item = head_->next_sample_ ;
           item != 0 ;
           item = item->next_sample_ )
        {
          if (item == stale)
            {
              found = true;
              break;
            }
        }
      if (found)
        {
          -- size_ ;
          
          if( stale->previous_sample_ != 0) 
            {
              stale->previous_sample_->next_sample_ = stale->next_sample_ ;
            } 
          else 
            {
              head_ = stale->next_sample_ ;
              if (head_ != 0)
                {
                  head_->previous_sample_ = 0;
                }
            }
          if( stale->next_sam

            {
              stale->next_sample_->previous_sample_ = stale->previous_sample_ ;
            } 
          else 
            {
              tail_ = stale->previous_sample_ ;
            }
          stale->next_sample_ = 0;
          stale->previous_sample_ = 0;
        }
      return found;
    }
    bool
    DataSampleList::dequeue_next_instance_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_instance_sample (stale);
        }
      bool found = false;
      DataSampleListElement* previous = head_;
      for( DataSampleListElement* item = head_->next_instance_sample_ ;
        item != 0 ;
        item = item->next_instance_sample_ )
        {
          if (item == stale)
            {
              found = true;  
              previous->next_instance_sample_ = stale->next_instance_sample_;
              -- size_ ;
              stale->next

              break;
            }
          previous = item;
        }
      
      return found;
    }
    bool
    DataSampleList::dequeue_next_send_sample (DataSampleListElement* stale)
    {
      if (head_ == 0)
        {
          return false;
        }
      if (stale == head_)
        {
          return dequeue_head_next_send_sample (stale);
        }
      bool found = false;
      for( DataSampleListElement* item = head_->next_send_sample_ ;
        item != 0 ;
        item = item->next_send_sample_ )
        {
          if (item == stale)
            {
              found = true;
              break;
            }
        }
      
      if (found)
        {
          size_ --;
          stale->previous_send_sample_->next_send_sample_ = stale->next_send_sample_ ;
          if( stale->next_send_sample_ != 0) 
            {
              stale->next_send_sample_->previous_send_sample_ = stale->previous_send_sample_ ;
            } 
          else 
            {
             
using namespace Helpers;
class VMBranchTestSuite : public CxxTest::TestSuite {
public:
	void testInt() {
		TS_ASSERT_EQUALS(invokeVM("branch/int_eq"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_eq2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_ne"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_ne2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_gt"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_gt2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_ge"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_ge2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_ge3"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_lt"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_lt2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_le"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_le2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/int_le3"), "1\n");
	}
	void testFloat() {
		TS_ASSERT_EQUALS(invokeVM("branch/float_eq"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_eq2"), "0\

		TS_ASSERT_EQUALS(invokeVM("branch/float_ne"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_ne2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_gt"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_gt2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_ge"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_ge2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_ge3"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_lt"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_lt2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_le"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_le2"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/float_le3"), "1\n");
	}
	void testRef() {
		TS_ASSERT_EQUALS(invokeVM("branch/ref_eq1"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/ref_eq2"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/ref_eq3"), "0\n");
		TS_ASSERT_EQUALS(invokeVM("branch/ref_ne1"), "1\n");
		TS_ASSERT_EQUALS(invokeVM("branch/ref_ne2"), "0\n");
		TS_ASSERT_EQUALS(invok
 *
 * @file l1.hpp
 *
namespace madlib {
namespace modules {
namespace convex {
using namespace madlib::dbal::eigen_integration;
template <class Model>
class L1 {
public:
    typedef Model model_type;
    static double lambda;
    static int n_tuples;
    static void gradient(
            const model_type &model,
            model_type &gradient);
    static void clipping(
            model_type &model,
            const double &stepsize);
    static double loss(
            const model_type &model);
};
template <class Model>
double
L1<Model>::lambda = 0.;
template <class Model>
int
L1<Model>::n_tuples = 1;
template <class Model>
void
L1<Model>::gradient(
        const model_type &model,
        model_type &gradient) {
    if (lambda != 0.) {
        for (Index i = 0; i < model.size(); i++) {
            if (model(i) > 0) {
                gradient(i) += lambda;
            } else if (model(i) < 0) {
                gradient(i) -= lambda;
            }
        }
    }
template <class M
/**
 *	This class is a locator that finds a chunk item under the cursor.
 *	Its matrix is determined by a supplemental locator set into the
 *	class.
 */
class ChunkItemLocator : public ToolLocator
	Py_Header( ChunkItemLocator, ToolLocator )
public:
	ChunkItemLocator( ToolLocatorPtr pSubLoc = NULL,
		PyTypePlus * pType = &s_type_ );
	~ChunkItemLocator();
	virtual void calculatePosition( const Vector3& worldRay, Tool& tool );
	virtual bool positionValid() const { return positionValid_; }
	ChunkItemPtr	chunkItem();
	PyObject *		pyGetAttribute( const char * attr );
	int				pySetAttribute( const char * attr, PyObject * value );
	PY_RW_ATTRIBUTE_DECLARE( subLocator_, subLocator )
	PyObject * pyGet_revealer();
	PY_RO_ATTRIBUTE_SET( revealer )
	PY_RW_ATTRIBUTE_DECLARE( enabled_, enabled )
	PY_FACTORY_DECLARE()
private:
	ChunkItemLocator( const ChunkItemLocator& );
	ChunkItemLocator& operator=( const ChunkItemLocator& );
	ToolLocatorPtr	subLocator_;
	ChunkItemPtr	chunkItem_;
	bool			enabled_;

/*
    This file is part of libbpk
    Copyright (C) 2012  Povilas Kanapickas
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
*/
namespace Bpk {
namespace Internal {
template<class T, class... Opts>
auto do_load_impl(LoadContext& ctx, T& t, int, int, int, Opts... opts) ->
    decltype(t.load(ctx, opts...), void())
    t.load(ctx, opts...);
template<class T, class... Opts>
auto do_load_impl(LoadContext& ctx, T& t, int, int, long, Opts... opts) ->
    decltype(t.load(ct

    t.load(ctx);
template<class T, class... Opts>
auto do_load_impl(LoadContext& ctx, T& t, int, long, long, Opts... opts) ->
    decltype(load(ctx, t, opts...), void())
    load(ctx, t, opts...);
template<class T, class... Opts>
auto do_load_impl(LoadContext& ctx, T& t, long, long, long, Opts... opts) ->
    decltype(load(ctx, t), void())
    load(ctx, t);
template<class T, class... Opts>
auto do_load_impl2(LoadContext& ctx, T& t, int, Opts... opts) ->
    decltype(do_load_impl(ctx, t, 0, 0, 0, opts...), void())
    do_load_impl(ctx, t, 0, 0, 0, opts...);
template<class T, class... Opts>
void do_load_impl2(LoadContext& ctx, T& t, long, Opts... opts)
    (void) ctx; (void) t;
    static_assert(!std::is_same<T,T>::value,
                  "Type T does not provide a usable implementation of load()");
/** @internal
    Launches appropriate load() function or invokes static assertion if none is
    available for the given type and options. The first of the following
    options is selecte
using namespace mccomposite::geometry;
void test1()
  Box box(1,2,3);
  Locator locator;
  locator.setPoint( Position(0,0,0) );
  assert (locator.locate( box ) == Locator::inside);
void test1a()
  Cylinder cylinder(1,2);
  assert (locate( Position(0,0,0), cylinder ) == Locator::inside);
  assert (locate( Position(0,0,1), cylinder ) == Locator::onborder);
  assert (locate( Position(0,0,1.01), cylinder ) == Locator::outside);
  assert (locate( Position(0,1,0), cylinder ) == Locator::onborder);
  assert (locate( Position(0,1.01,0), cylinder ) == Locator::outside);
  assert (locate( Position(1,0,0), cylinder ) == Locator::onborder);
  assert (locate( Position(1.01,0,0), cylinder ) == Locator::outside);
  assert (locate( Position(0.708,0.708,0), cylinder ) == Locator::outside);
  assert (locate( Position(1,0,1), cylinder ) == Locator::onborder);
  assert (locate( Position(-1,0,1), cylinder ) == Locator::onborder);
  assert (locate( Position(1,0,-1), cylinder ) == Locator::onborder);
  asser

void test1b()
  Sphere sphere(1);
  assert (locate( Position(0,0,0), sphere ) == Locator::inside);
  assert (locate( Position(1,0,0), sphere ) == Locator::onborder);
  assert (locate( Position(-1,0,0), sphere ) == Locator::onborder);
  assert (locate( Position(0,1,0), sphere ) == Locator::onborder);
  assert (locate( Position(0,-1,0), sphere ) == Locator::onborder);
  assert (locate( Position(0,0,1), sphere ) == Locator::onborder);
  assert (locate( Position(0,0,-1), sphere ) == Locator::onborder);
  assert (locate( Position(0.707,0.707,0), sphere ) == Locator::inside);
  assert (locate( Position(0.708,0.708,0), sphere ) == Locator::outside);
  assert (locate( Position(-0.707,0.707,0), sphere ) == Locator::inside);
  assert (locate( Position(-0.708,0.708,0), sphere ) == Locator::outside);
  assert (locate( Position(0.707,0,0.707), sphere ) == Locator::inside);
  assert (locate( Position(0.708,0,0.708), sphere ) == Locator::outside);
  assert (locate( Position(0.707,0,-0.707), sphere )

  assert (locate( Position(0.708,0,-0.708), sphere ) == Locator::outside);
void test2()
  Box box(1,1,1);
  assert (locate( Position(0,0,0), box ) == Locator::inside);
  assert (locate( Position(0,0,0.51), box ) == Locator::outside);
  assert (locate( Position(0,0,0.5), box ) == Locator::onborder);
void test3()
  Box box1(1,1,1);
  Box box2(2,2,2);
  Difference diff(box2, box1);
  assert (locate( Position(0,0,0), diff ) == Locator::outside);
  assert (locate( Position(0,0,0.51), diff ) == Locator::inside);
  assert (locate( Position(0,0,0.5), diff ) == Locator::onborder);
void test4()
  Box box(1,1,1);
  Translation translation(box, Vector(0,0,0.5));
  Intersection intersection(box, translation);
  assert (locate( Position(0,0,0), intersection ) == Locator::onborder);
  assert (locate( Position(0,0,0.51), intersection ) == Locator::outside);
  assert (locate( Position(0,0,0.2), intersection ) == Locator::inside);
  Box box1(2,2,2);
  Intersection intersection2(box1, translation);
  as

  assert (locate( Position(0,0,0), intersection2 ) == Locator::onborder);
  Cylinder cylinder(2,2);
  Sphere sphere(2);
  Intersection intersection3(cylinder, sphere);
  assert (locate( Position(0,0,1), intersection3 ) == Locator::onborder);
  assert (locate( Position(0,0,2), intersection3 ) == Locator::outside);
void test5()
  Box box(1,1,1);
  Translation translation(box, Vector(0,0,0.5));
  Union aunion(box, translation);
  assert (locate( Position(0,0,0), aunion ) == Locator::inside);
  assert (locate( Position(0,0,1.01), aunion ) == Locator::outside);
  assert (locate( Position(0,0,1.00), aunion ) == Locator::onborder);
void test6()
  Box box(1,1,1);
  Dilation dilation(box, 5);
  assert (locate( Position(0,0,0), dilation ) == Locator::inside);
  assert (locate( Position(0,0,2.51), dilation ) == Locator::outside);
  assert (locate( Position(0,0,2.50), dilation ) == Locator::onborder);
void test7()
  Box box(1,1,10);
  RotationMatrix m(1,0,0,
		   0,0,1,
		   0,-1,0);
  Rotation r
using dioptre::window::WindowInterface;
using dioptre::graphics::GraphicsInterface;
using dioptre::keyboard::KeyboardInterface;
using dioptre::mouse::MouseInterface;
using dioptre::time::TimeInterface;
using dioptre::physics::PhysicsInterface;
using dioptre::ai::AIInterface;
TEST(Locator, DefaultWindow) {
  dioptre::Locator::initialize();
  WindowInterface *window =
      dioptre::Locator::getInstance<WindowInterface>(dioptre::Module::M_WINDOW);
  EXPECT_EQ(window->initialize(), 0);
TEST(Locator, DefaultGraphics) {
  dioptre::Locator::initialize();
  GraphicsInterface *graphics =
      dioptre::Locator::getInstance<GraphicsInterface>(
          dioptre::Module::M_GRAPHICS);
  EXPECT_EQ(graphics->initialize(), 0);
TEST(Locator, DefaultKeyboard) {
  dioptre::Locator::initialize();
  KeyboardInterface *keyboard =
      dioptre::Locator::getInstance<KeyboardInterface>(
          dioptre::Module::M_KEYBOARD);
  EXPECT_EQ(keyboard->initialize(), 0);
TEST(Locator, DefaultMouse) {
  dioptre::L

  MouseInterface *mouse =
      dioptre::Locator::getInstance<MouseInterface>(dioptre::Module::M_MOUSE);
  EXPECT_EQ(mouse->initialize(), 0);
TEST(Locator, DefaultTime) {
  dioptre::Locator::initialize();
  TimeInterface *time =
      dioptre::Locator::getInstance<TimeInterface>(dioptre::Module::M_TIME);
  EXPECT_EQ(time->initialize(), 0);
TEST(Locator, DefaultPhysics) {
  dioptre::Locator::initialize();
  PhysicsInterface *physics = dioptre::Locator::getInstance<PhysicsInterface>(
      dioptre::Module::M_PHYSICS);
  EXPECT_EQ(physics->initialize(), 0);
TEST(Locator, DefaultAI) {
  dioptre::Locator::initialize();
  AIInterface *ai =
      dioptre::Locator::getInstance<AIInterface>(dioptre::Module::M_AI);
  EXPECT_EQ(ai->initialize(), 0);
class MockGraphics : public GraphicsInterface {
public:
  int initialize() { return 1337; }
  void resize(int width, int height) {}
  void render(const double alpha) {}
  void destroy() {}
  void destroyScene(dioptre::graphics::Scene *scene) {}
  voi
/*
** $Id: ldump.c,v 1.15 2006/02/16 15:53:49 lhf Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
static void DumpConstants(con

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 DumpString((f-
namespace io = boost::iostreams;
    
/**
 * Specify full dump file name to argv[1],
 *         corresponding digest file name to argv[2].
 * This program check dump with digest.
 */
int main(int argc, char *argv[])
    io::filtering_istream is1;
    is1.push(io::gzip_decompressor());
    is1.push(io::file_source(argv[1]));
    io::filtering_istream is2;
    is2.push(io::gzip_decompressor());
    is2.push(io::file_source(argv[2]));
    /* dumpH */
    VmdkDumpHeader dumpH;
    is1 >> dumpH;
    dumpH.print();
    typedef Generator1<VmdkDumpBlock, size_t> DumpBGen;
    typedef boost::shared_ptr<DumpBGen> DumpBGenP;
    DumpBGenP dumpBGenP = DumpBGenP(new DumpBGen(dumpH.getBlockSize()));
    DataReader<VmdkDumpBlock> dumpReader(is1, dumpBGenP);
    dumpReader.start();
    /* digestH */
    VmdkDigestHeader digestH;
    is2 >> digestH;
    digestH.print();
    typedef Generator0<VmdkDigestBlock> DigestBGen;
    typedef boost::shared_ptr<DigestBGen> DigestBGenP;
    DigestBGenP digestBGenP
struct YM3812interface
	void (*handler)(int linestate);
};
struct Y8950interface
	void (*handler)(int linestate);
	int rom_region; /* delta-T ADPCM ROM/RAM region */
	read8_handler keyboardread;
	write8_handler keyboardwrite;
	read8_handler portread;
	write8_handler portwrite;
};
/* YM3812 */
READ8_HANDLER ( YM3812_status_port_0_r );
WRITE8_HANDLER( YM3812_control_port_0_w );
READ8_HANDLER( YM3812_read_port_0_r );
WRITE8_HANDLER( YM3812_write_port_0_w );
READ8_HANDLER ( YM3812_status_port_1_r );
WRITE8_HANDLER( YM3812_control_port_1_w );
READ8_HANDLER( YM3812_read_port_1_r );
WRITE8_HANDLER( YM3812_write_port_1_w );
/* YM3526 */
READ8_HANDLER ( YM3526_status_port_0_r );
WRITE8_HANDLER( YM3526_control_port_0_w );
READ8_HANDLER( YM3526_read_port_0_r );
WRITE8_HANDLER( YM3526_write_port_0_w );
READ8_HANDLER ( YM3526_status_port_1_r );
WRITE8_HANDLER( YM3526_control_port_1_w );
READ8_HANDLER( YM3526_read_port_1_r );
WRITE8_HANDLER( YM3526_write_port_1_w );
/* Y8950 */
READ8_HANDLER ( Y8950
class BlockInfo;
class ChunkDrawer;
class World;
const int CHUNK_X_SIZE = 20;
const int CHUNK_Y_SIZE = 256;
const int CHUNK_Z_SIZE = 20;
const int CHUNK_HEIGHT = CHUNK_Y_SIZE;
typedef QPair<int, int> ChunkPosition;
/*! A chunk of a World containing all BlockInfo */
class Chunk : public EventReadyObject
	Q_OBJECT
public:
	explicit Chunk(World* parentWorld, ChunkPosition position);
	~Chunk();
	/*! This returns the mutex of the Chunk. Be sure to unlock it when needed!! */
	inline QReadWriteLock& rwLock() {return m_rwLock;}
	virtual bool worldEvent(WorldEvent* worldEvent);
	virtual bool chunkEvent(ChunkEvent* chunkEvent);
	virtual bool blockEvent(BlockEvent* blockEvent);
	enum ChunkState {
		ChunkState_Active,
		ChunkState_Idle,
		ChunkState_Void
	};
	inline ChunkPosition position() const {return m_position;}
	int altitude(const int x, const int z);
	/*! Access a block from a chunk
  \warning The coordinates to pass are relative to the chunk, and thus must be inside!
 */
	BlockInfo* block(
/********************************************************************
	Rhapsody	: 7.5 
	Login		: KBE
	Component	: TargetComponent 
	Configuration 	: Target
	Model Element	: SampleSet
	File Path	: C:/Ubuntu_share/sapien190/source/Sandbox/sapine_v1/rpy/SampleSet.cpp
*********************************************************************/
SampleSet::SampleSet() : num(2) {
SampleSet::~SampleSet() {
Sample* SampleSet::GetSample(int idx) {
    if (idx < num)
    	return &itsSample[idx];
    else
    	return 0;
int SampleSet::getItsSample() const {
    int iter = 0;
    return iter;
void SampleSet::SetSample(int idx, const Sample& sample) {
    if (idx < num)
    	itsSample[idx] = sample;
int SampleSet::getNum() const {
    return num;
void SampleSet::setNum(int p_num) {
    num = p_num;
WFDB_Annotation SampleSet::GetAnnotation() {
    return annotation;
     
void SampleSet::SetSample(int idx, WFDB_Sample value) {
    if (idx < num)
    {
    	itsSample[idx].setValue(value);
    }
void SampleS

    annotation = _annotation;
    
void SampleSet::SetSample(int idx, WFDB_Sample value, WFDB_Annotation ann) {
    if (idx < num)
    {
    	itsSample[idx].setValue(value);
       	SetAnnotation(ann);
    }
WFDB_Sample SampleSet::GetSampleValue(int idx) {
    if (idx < num)
    	return itsSample[idx].getValue();
    else
    	return 0;
WFDB_Time SampleSet::GetSampleID() {
    return sampleID;
    
void SampleSet::SetSampleID(WFDB_Time _sampleID) {
    sampleID = _sampleID;
    
WFDB_Annotation SampleSet::FactoryAnnotation(char anntyp) {
    WFDB_Annotation ann;
    ann.time = 0;
    ann.anntyp = anntyp;
    ann.subtyp = 0;
    ann.chan  = 0; 
    ann.num = 0;
    ann.aux = 0; 
    return ann;
WFDB_Annotation SampleSet::getAnnotation() const {
    return annotation;
void SampleSet::setAnnotation(WFDB_Annotation p_annotation) {
    annotation = p_annotation;
WFDB_Time SampleSet::getSampleID() const {
    return sampleID;
void SampleSet::setSampleID(WFDB_Time p_sampleID) {
    sampleID 
using namespace myfs;
ChunkServerAddr::ChunkServerAddr(string name, string ipAddr, int port)
 :  name_(name),
	ipAddr_(ipAddr),
	port_(port)
bool myfs::operator==(const ChunkServerAddr& ls, const ChunkServerAddr& rs) 
	return (ls.ipAddr() == rs.ipAddr()) && (ls.port() == rs.port());
string ChunkServerAddr::name() const
	return name_;
string ChunkServerAddr::ipAddr() const
	return ipAddr_;
int ChunkServerAddr::port() const
	return port_;
ChunkInfo::ChunkInfo(string chunkName, int ncopy)
 :  chunkName_(chunkName),
	chunkSize_(0),
	ncopy_(ncopy)
string ChunkInfo::chunkName()
	return chunkName_;
int ChunkInfo::chunkSize()
	return chunkSize_;
void ChunkInfo::setChunkSize(int chunkSize)
	chunkSize_ = chunkSize;
int ChunkInfo::ncopy()
	return ncopy_;
void ChunkInfo::setNcopy(int ncopy)
	ncopy_ = ncopy;
vector<ChunkServerAddr>& ChunkInfo::chunkAddrs()
	return chunkAddrs_;
void ChunkInfo::setChunkAddr(int index, const ChunkServerAddr& chunkAddr)
	assert((index >= 0) && (index <= chunkAddrs_.siz
ByteStream::ByteStream(size_t capacidad) :
		stream(NULL), capacidad(capacidad), tamanio(0) {
	if (capacidad > 0) {
		stream = new byte_t[capacidad];
	}
ByteStream::ByteStream(const byte_t* stream, size_t tamanio) :
		stream(NULL), capacidad(tamanio), tamanio(tamanio) {
	if (tamanio > 0) {
		this->stream = new byte_t[tamanio];
		memcpy(this->stream, stream, tamanio);
	}
ByteStream::ByteStream(const ByteStream& aCopiar) :
		stream(NULL) {
	copiar(aCopiar);
void ByteStream::asignarStream(const byte_t* stream, size_t tamanio) {
	if (tamanio > capacidad) {
		if (this->stream != NULL) {
			delete[] this->stream;
		}
		this->stream = new byte_t[tamanio];
		capacidad = tamanio;
	}
	this->tamanio = tamanio;
	if (tamanio > 0) {
		memcpy(this->stream, stream, tamanio);
	}
void ByteStream::redimensionar(size_t nuevaCapacidad) {
	capacidad = nuevaCapacidad;
	if (capacidad <= 0) {
		tamanio = 0;
		if (stream != NULL) {
			delete[] stream;
		}
		stream = NULL;
	}
	else {
		byte_t *nuevo = new byte_t

		/* Si la nueva capacidad es menor al tamanio ocupado actual, al
		 * achicarse el stream se pierden datos y este queda lleno */
		if (tamanio > capacidad) {
			tamanio = capacidad;
		}
		memcpy(nuevo, stream, tamanio);
		delete[] stream;
		stream = nuevo;
	}
void ByteStream::insertarDatos(const void* dato, size_t tamanioDato) {
	if ((tamanio + tamanioDato) > capacidad) {
		redimensionar(tamanio + tamanioDato);
	}
	memcpy(&stream[tamanio], dato, tamanioDato);
	tamanio += tamanioDato;
void ByteStream::vaciarStream() {
	tamanio = 0;
const byte_t* ByteStream::obtenerStream() const {
	return stream;
size_t ByteStream::getTamanioOcupado() const {
	return tamanio;
size_t ByteStream::getCapacidadTotal() const {
	return capacidad;
size_t ByteStream::getCapacidadRestante() const {
	return (capacidad - tamanio);
bool ByteStream::estaLleno() const {
	return (capacidad == tamanio);
ByteStream& ByteStream::operator=(const ByteStream& aCopiar) {
	copiar(aCopiar);
	return *this;
ByteStream::~ByteSt
namespace shaka {
namespace media {
namespace mp4 {
ChunkInfoIterator::ChunkInfoIterator(const SampleToChunk& sample_to_chunk)
    : chunk_sample_index_(0),
      current_chunk_(0),
      chunk_info_table_(sample_to_chunk.chunk_info),
      iterator_(chunk_info_table_.begin()) {
  if (iterator_ != chunk_info_table_.end())
    current_chunk_ = iterator_->first_chunk;
ChunkInfoIterator::~ChunkInfoIterator() {}
bool ChunkInfoIterator::AdvanceChunk() {
  ++current_chunk_;
  if (iterator_ + 1 != chunk_info_table_.end()) {
    if (current_chunk_ >= (iterator_ + 1)->first_chunk)
      ++iterator_;
  }
  chunk_sample_index_ = 0;
  return true;
bool ChunkInfoIterator::AdvanceSample() {
  ++chunk_sample_index_;
  if (chunk_sample_index_ >= iterator_->samples_per_chunk)
    AdvanceChunk();
  return true;
bool ChunkInfoIterator::IsValid() const {
  return iterator_ != chunk_info_table_.end() &&
         chunk_sample_index_ < iterator_->samples_per_chunk;
uint32_t ChunkInfoIterator::NumSamples(uint
/*
 *     SocialLedge.com - Copyright (C) 2013
 *
 *     This file is part of free software framework for embedded processors.
 *     You can use it and/or distribute it as long as this copyright header
 *     remains unmodified.  The code is free for personal use and requires
 *     permission to use in a commercial product.
 *
 *      THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 *      OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 *      MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 *      I SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
 *      CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 *     You can reach the author of this software at :
 *          p r e e t . w i k i @ g m a i l . c o m
 */
/**
 * @file
 * @brief Contains the terminal handler function declarations.
 */
CMD_HANDLER_FUNC(taskListHandler);
CMD_HANDLER_FUNC(memInfoHandler);
CMD_HANDLER_FUNC(healthH
/**
 * Implements a media sample sink that buffers the last sample.
 */
class FMediaSampleBuffer
	: public TQueue<TSharedPtr<TArray<uint8>, ESPMode::ThreadSafe>>
	, public IMediaSink
public:
	/** Default constructor. */
	FMediaSampleBuffer()
		: CurrentSampleTime(FTimespan::MinValue())
	{ }
	/** Virtual destructor. */
	virtual ~FMediaSampleBuffer() { }
public:
	/**
	 * Gets the sample data of the current media sample.
	 *
	 * @return The current sample.
	 * @see GetCurrentSampleTime
	 */
	TSharedPtr<TArray<uint8>, ESPMode::ThreadSafe> GetCurrentSample() const
	{
		return CurrentSample;
	}
	/**
	 * Gets the playback time of the currently available media sample.
	 *
	 * @return Sample playback time.
	 * @see GetCurrentSample
	 */
	FTimespan GetCurrentSampleTime() const
	{
		return CurrentSampleTime;
	}
public:
	void ProcessMediaSample( const void* Buffer, uint32 BufferSize, FTimespan Duration, FTimespan Time ) override
	{
		TArray<uint8>* Sample = new TArray<uint8>();
		Sample->AddUninit
using namespace std;
int const_i = 1 ;
class sample
    private :
        int i;
        float f;
    public:
        static int static_i;
    public:
        sample(int ii, float ff)
        {
            i = ii;
            f = ff;
            cout << "Constructor with ("<<i<<","<<f<<")"<<endl;
        }
        sample()
        {
            i = const_i;
            f = const_i++ + 1.5f;
            cout << "Constructor with ("<<i<<","<<f<<")"<<endl;
        }
        sample(int ii)
        {
            i = static_i;
            f = static_i++ + 1.5f;
            cout << "Constructor with ("<<i<<","<<f<<")"<<endl;
        }
    
        ~sample()
        {        
            cout << "Destructor with ("<<i<<","<<f<<")"<<endl;
        }
};
int sample :: static_i = 0;
int main()
    sample p[5] = {
        sample (1,2.5f),
        sample (2,3.5f),
        sample (3,4.5f),
        sample (4,5.5f),
        sample (5,6.5f)                    
    };
    sample *s  = new sample [10];
   
class LocalRepo;
class QTimer;
class InitVirtualDriveDialog : public QDialog,
                               public Ui::InitVirtualDriveDialog
    Q_OBJECT
public:
    InitVirtualDriveDialog(const Account& account, QWidget *parent=0);
private slots:
    void onGetDefaultRepoSuccess(bool exists, const QString& repo_id);
    void onGetDefaultRepoFailure(const ApiError& error);
    void onCreateDefaultRepoSuccess(const QString& repo_id);
    void onCreateDefaultRepoFailure(const ApiError& error);
    void onDownloadRepoSuccess(const RepoDownloadInfo& info);
    void onDownloadRepoFailure(const ApiError& error);
    void checkDownloadProgress();
    void start();
    void onCancel();
    void openVirtualDisk();
private:
    Q_DISABLE_COPY(InitVirtualDriveDialog)
    void getDefaultRepo();
    void startDownload(const QString& repo_id);
    void createLoadingView();
    void createDefaultRepo();
    void setStatusText(const QString& status);
    void setStatusIcon(const QString& path);
    
using namespace Renderer;
using namespace Geom;
using namespace std;
bool Renderer::MeshModelStage::have() {
        return ptr < model->faces.size();
Renderer::MeshModelStage::result Renderer::MeshModelStage::process ( bool&  ) {
	result res;
	FOR(j,3)
	{
		FOR(k,3)
		{
			get<0>(res)[j][k] = norm_v[model->faces[ptr][j]][k];
		}
		get<0>(res)[j][3] = 1;
		get<1>(res)[j] = model->normals[model->faces[ptr][j]];
	}
	ptr++;
	return res;
Renderer::MeshModelStage::MeshModelStage(const MeshModel& model)  : model(&model), norm_v(model.verts), ptr(0){}
void Renderer::MeshModelStage::start() {
        ptr = 0;
void Renderer::MeshModelStage::operator=(MeshModelStage &&mstage) {
         model = mstage.model;
         ptr = mstage.ptr;
         norm_v = move(mstage.norm_v);
bool Renderer::ModelStage::have() {
	return (size_t)ptr < mstage.size();
void Renderer::ModelStage::next(){
	ptr++;
	if((size_t)ptr < mstage.size())
		mstage[ptr].start();
	while((size_t)ptr < mstage.size() && !mstage[ptr].hav
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
namespace VM {
class Repo;
class BlobEncoder;
class BlobDecoder;
enum RepoId {
  RepoIdInvalid = -1,
  RepoIdCentral =  0,
  RepoIdLocal   = 

};
class RepoExc : public std::exception {
 public:
  RepoExc(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3) {
    va_list(ap);
    va_start(ap, fmt);
    char* msg;
    if (vasprintf(&msg, fmt, ap) == -1) {
      m_msg = "";
    } else {
      m_msg = msg;
      free(msg);
    }
    va_end(ap);
  }
  ~RepoExc() throw() {}
  const std::string& msg() const { return m_msg; }
  const char* what() const throw() { return m_msg.c_str(); }
 private:
  std::string m_msg;
};
class RepoStmt {
 public:
  RepoStmt(Repo& repo);
  ~RepoStmt();
 private:
  void finalize();
 public:
  bool prepared() const { return (m_stmt != NULL); }
  void prepare(const std::string& sql);
  void reset();
  Repo& repo() const { return m_repo; }
  sqlite3_stmt*& get() { return m_stmt; }
  const std::string& sql() const { return m_sql; }
 protected:
  Repo& m_repo;
  std::string m_sql;
  sqlite3_stmt* m_stmt;
};
class RepoQuery {
 public:
  RepoQuery(RepoStmt& stmt)
    : m_stmt(stmt), m_row(false), m_done(false) {
    

  }
  ~RepoQuery() { m_stmt.reset(); }
  void bindBlob(const char* paramName, const void* blob, size_t size,
                bool isStatic=false);
  void bindBlob(const char* paramName, const BlobEncoder& blob,
                bool isStatic=false);
  void bindMd5(const char* paramName, const MD5& md5);
  void bindTypedValue(const char* paramName, const TypedValue& tv);
  void bindText(const char* paramName, const char* text, size_t size,
                bool isStatic=false);
  void bindStaticString(const char* paramName, const StringData* sd);
  void bindDouble(const char* paramName, double val);
  void bindInt(const char* paramName, int val);
  void bindId(const char* paramName, Id id);
  void bindOffset(const char* paramName, Offset offset);
  void bindAttr(const char* paramName, Attr attrs);
  void bindBool(const char* paramName, bool b);
  void bindInt64(const char* paramName, int64 val);
  void bindNull(const char* paramName);
  void step();
  bool row() const { return m_row; }
 

  void reset();
  void exec();
  int64 getInsertedRowid();
  bool isBlob(int iCol);
  bool isText(int iCol);
  bool isDouble(int iCol);
  bool isInt(int iCol);
  bool isNull(int iCol);
  void getBlob(int iCol, const void*& blob, size_t& size);
  BlobDecoder getBlob(int iCol);
  void getMd5(int iCol, MD5& md5);
  void getTypedValue(int iCol, TypedValue& tv);
  void getText(int iCol, const char*& text);
  void getText(int iCol, const char*& text, size_t& size);
  void getStaticString(int iCol, StringData*& s);
  void getDouble(int iCol, double& val);
  void getInt(int iCol, int& val);
  void getId(int iCol, Id& id);
  void getOffset(int iCol, Offset& offset);
  void getAttr(int iCol, Attr& attrs);
  void getBool(int iCol, bool& b);
  void getInt64(int iCol, int64& val);
 protected:
  RepoStmt& m_stmt;
  bool m_row;
  bool m_done;
};
/*
 * Transaction guard object.
 *
 * Semantics: the guard object will rollback the transaction unless
 * you tell it not to.  Call .commit() when you want 

 */
class RepoTxn : boost::noncopyable {
 public:
  explicit RepoTxn(Repo& repo);
  ~RepoTxn();
  /*
   * All these routines may throw if there is an error accessing the
   * repo.  The RepoTxn object will rollback the entire transaction in
   * any of these cases (which technically means they only provide the
   * basic exception safety guarantee, even though the whole point is
   * to behave transactionally. ;)
   */
  void prepare(RepoStmt& stmt, const std::string& sql);
  void exec(const std::string& sQuery);
  void commit();
  bool error() const { return m_error; }
 private:
  friend class RepoTxnQuery;
  void step(RepoQuery& query);
  void exec(RepoQuery& query);
  Repo& m_repo;
  bool m_pending;
  bool m_error;
};
class RepoTxnQuery : public RepoQuery {
 public:
  RepoTxnQuery(RepoTxn& txn, RepoStmt& stmt)
    : RepoQuery(stmt), m_txn(txn) {
  }
  void step();
  void exec();
 private:
  RepoTxn& m_txn;
};
class RepoProxy {
 public:
  RepoProxy(Repo& repo) : m_repo(repo) {}
  ~R
void DescVertexFormatEntry::Serialize(Stream & stream) const
	STLSerializer<std::string> string_serializer(stream);
	string_serializer.Save(name);
	stream.Save(semantic_index);
	stream.Save(offset);
	stream.Save(byte_stride);
	stream.Save(stream_index);
	stream.Save(type);
	stream.Save(channels);
void DescVertexFormatEntry::Unserialize(Stream & stream)
	STLSerializer<std::string> string_serializer(stream);
	string_serializer.Load(name);
	stream.Load(semantic_index);
	stream.Load(offset);
	stream.Load(byte_stride);
	stream.Load(stream_index);
	stream.Load(type);
	stream.Load(channels);
void DescVertexFormatEntry::SerializeTypeId(Stream & stream) const
	stream.Save("DescVertexFormatEntry");
void DescVertexFormat::Serialize(Stream & stream) const
	STLSerializer<FixedArray<DescVertexFormatEntry> > entry_serializer(stream);
	entry_serializer.Save(format_entries);
void DescVertexFormat::Unserialize(Stream & stream)
	STLSerializer<FixedArray<DescVertexFormatEntry> > entry_serializer(stream);

SoftwareRepo::SoftwareRepo(){
	init();
SoftwareRepo::SoftwareRepo(long long software_repo_id)
	init();
	this->software_repo_id = software_repo_id;
void SoftwareRepo::init()
long long SoftwareRepo::getSoftwareRepoId() const
	return software_repo_id;
void SoftwareRepo::setSoftwareRepoId(long long value)
	software_repo_id = value;
long long SoftwareRepo::getSysUserid() const
	return sys_userid;
void SoftwareRepo::setSysUserid(long long value)
	sys_userid = value;
long long SoftwareRepo::getSysGroupid() const
	return sys_groupid;
void SoftwareRepo::setSysGroupid(long long value)
	sys_groupid = value;
std::string SoftwareRepo::getSysPermUser() const
	return sys_perm_user;
void SoftwareRepo::setSysPermUser(std::string value)
	sys_perm_user = value;
std::string SoftwareRepo::getSysPermGroup() const
	return sys_perm_group;
void SoftwareRepo::setSysPermGroup(std::string value)
	sys_perm_group = value;
std::string SoftwareRepo::getSysPermOther() const
	return sys_perm_other;
void SoftwareRepo::s
/*
 * G4SipmModelFactory.cc
 *
 * @created Apr 29, 2013
 * @author Tim Niggemann, III Phys. Inst. A, RWTH Aachen University
 * @copyright GNU General Public License v3.0
 */
G4SipmModelFactory::G4SipmModelFactory() {
G4SipmModelFactory* G4SipmModelFactory::getInstance() {
	static G4SipmModelFactory* instance = new G4SipmModelFactory;
	return instance;
G4SipmModel* G4SipmModelFactory::createConfigFileModel(std::string propertiesFileName) const {
	return new G4SipmConfigFileModel(propertiesFileName);
G4SipmModel* G4SipmModelFactory::createGenericSipmModel() const {
	return new G4SipmGenericSipmModel;
G4SipmModel* G4SipmModelFactory::createHamamatsuS1036211100() const {
	return new HamamatsuS1036211100;
G4SipmModel* G4SipmModelFactory::createHamamatsuS1036233100() const {
	return new HamamatsuS1036233100;
G4SipmModel* G4SipmModelFactory::createHamamatsuS1036233050() const {
	return new HamamatsuS1036233050;
G4SipmModel* G4SipmModelFactory::createHamamatsuS10985100() const {
	return new Ha
namespace ld3d
	OGL4Loader::OGL4Loader(void)
	{
		m_hLib = nullptr;
	}
	OGL4Loader::~OGL4Loader(void)
	{
	}
	bool OGL4Loader::load_module()
	{
		
		return true;
		
	}
	void* OGL4Loader::_load(const char* szName)
	{
		return nullptr;
	}
	bool OGL4Loader::Load()
	{
		if(load_module() == false)
		{
			return false;
		}
		if(load_wgl() == false)
		{
			return false;
		}
		if(false == load_version())
		{
			return false;
		}
		if(false == load_extension_info())
		{
			return false;
		}
		if(false == load_api())
		{
			return false;
		}
		return true;
	}
	bool OGL4Loader::load_wgl()
	{
		
		return true;
	}
	bool OGL4Loader::load_version()
	{
		LOAD_API(glGetString,										PFNGLGETSTRINGPROC);
		int major;
		int minor;
		GLubyte const * str = glGetString(GL_VERSION);
		if (str != NULL)
		{
			std::string const ver(reinterpret_cast<char const *>(str));
			std::string::size_type const pos(ver.find("."));
			major = ver[pos - 1] - '0';
			minor = ver[pos + 1] - '0';
		}
		else
		{
			major = m

		}
		m_ver = Version(major, minor, 0, 0);
		return true;
	}
	bool OGL4Loader::load_extension_info()
	{
		LOAD_API(glGetStringi, PFNGLGETSTRINGIPROC);
		LOAD_API(glGetIntegerv, PFNGLGETINTEGERVPROC);
		if(glGetStringi == nullptr)
		{
			return false;
		}
		GLint num_exts;
		glGetIntegerv(GL_NUM_EXTENSIONS, &num_exts);
		for (GLint i = 0; i < num_exts; ++ i)
		{
			const char* szExt = (const char*)glGetStringi(GL_EXTENSIONS, i);
			m_exts.push_back(szExt);
		}
		return true;
	}
	void OGL4Loader::Unload()
	{
		m_exts.clear();
		os_unload_module(m_hLib);
		m_hLib = nullptr;
	}
	bool OGL4Loader::IsExtSupported(const std::string& ext)
	{
		return m_exts.end() != std::find(m_exts.begin(), m_exts.end(), ext);
	}
	bool OGL4Loader::load_api()
	{
		
		LOAD_API(glGetStringi,											PFNGLGETSTRINGIPROC);
		LOAD_API(glGetString,											PFNGLGETSTRINGPROC);
		LOAD_API(glGetIntegerv,											PFNGLGETINTEGERVPROC);
		LOAD_API(glDeleteTextures,										PFNGLDELETETEXTURESPROC);
		LOAD_API(glG

		LOAD_API(glBindTexture,											PFNGLBINDTEXTUREPROC);
		LOAD_API(glTexParameteri,										PFNGLTEXPARAMETERIPROC);
		LOAD_API(glTexSubImage1D,										PFNGLTEXSUBIMAGE1DPROC);
		LOAD_API(glTexSubImage2D,										PFNGLTEXSUBIMAGE2DPROC);
		LOAD_API(glEnable,												PFNGLENABLEPROC);
		LOAD_API(glDisable,												PFNGLDISABLEPROC);
		LOAD_API(glColorMask,											PFNGLCOLORMASKPROC);
		LOAD_API(glPolygonMode,											PFNGLPOLYGONMODEPROC);
		LOAD_API(glCullFace,											PFNGLCULLFACEPROC);
		LOAD_API(glFrontFace,											PFNGLFRONTFACEPROC);
		LOAD_API(glPolygonOffset,										PFNGLPOLYGONOFFSETPROC);
		LOAD_API(glDepthMask,											PFNGLDEPTHMASKPROC);
		LOAD_API(glDepthFunc,											PFNGLDEPTHFUNCPROC);
		LOAD_API(glDrawArrays,											PFNGLDRAWARRAYSPROC);
		LOAD_API(glDrawElements,										PFNGLDRAWELEMENTSPROC);
		LOAD_API(glViewport,											PFNGLVIEWPORTPROC);
		LOAD_API(glGenBuffers,											PFNGLGENBUFFERSPROC);
		LOAD_API(glBindBuffer,							

		LOAD_API(glBufferData,											PFNGLBUFFERDATAPROC);
		LOAD_API(glEnableVertexAttribArray,								PFNGLENABLEVERTEXATTRIBARRAYPROC);
		LOAD_API(glDisableVertexAttribArray,							PFNGLDISABLEVERTEXATTRIBARRAYPROC);
		LOAD_API(glIsBuffer,											PFNGLISBUFFERPROC);
		LOAD_API(glBufferSubData,										PFNGLBUFFERSUBDATAPROC);
		LOAD_API(glMapBufferRange,										PFNGLMAPBUFFERRANGEPROC);
		LOAD_API(glUnmapBuffer,											PFNGLUNMAPBUFFERPROC);
		LOAD_API(glDeleteBuffers,										PFNGLDELETEBUFFERSPROC);
		LOAD_API(glBindVertexBuffer,									PFNGLBINDVERTEXBUFFERPROC);
		LOAD_API(glVertexAttribPointer,									PFNGLVERTEXATTRIBPOINTERPROC);
		LOAD_API(glClearBufferfv,										PFNGLCLEARBUFFERFVPROC);
		LOAD_API(glClearBufferfi,										PFNGLCLEARBUFFERFIPROC);
		LOAD_API(glClearBufferiv,										PFNGLCLEARBUFFERIVPROC);
		
		LOAD_API(glDebugMessageControl,									PFNGLDEBUGMESSAGECONTROLPROC);
		LOAD_API(glDebugMessageInsert,									PFNGLDEBUGMESSAGEINSERTPROC);
		LOAD_A

		LOAD_API(glGetDebugMessageLog,									PFNGLGETDEBUGMESSAGELOGPROC);
		LOAD_API(glTexImage3D,											PFNGLTEXIMAGE3DPROC);
		LOAD_API(glGenerateMipmap,										PFNGLGENERATEMIPMAPPROC);
		LOAD_API(glActiveTexture,										PFNGLACTIVETEXTUREPROC);
		LOAD_API(glGenVertexArrays,										PFNGLGENVERTEXARRAYSPROC);
		LOAD_API(glBindVertexArray,										PFNGLBINDVERTEXARRAYPROC);
		LOAD_API(glDeleteVertexArrays,									PFNGLDELETEVERTEXARRAYSPROC);
		LOAD_API(glCreateProgram,										PFNGLCREATEPROGRAMPROC);
		LOAD_API(glDeleteProgram,										PFNGLDELETEPROGRAMPROC);
		LOAD_API(glLinkProgram,											PFNGLLINKPROGRAMPROC);
		LOAD_API(glUseProgram,											PFNGLUSEPROGRAMPROC);
		LOAD_API(glCreateShader,										PFNGLCREATESHADERPROC);
		LOAD_API(glDeleteShader,										PFNGLDELETESHADERPROC);
		LOAD_API(glShaderSource,										PFNGLSHADERSOURCEPROC);
		LOAD_API(glCompileShader,										PFNGLCOMPILESHADERPROC);
		LOAD_API(glAttachShader,										PFNGLATTACHSHADERPROC);


		LOAD_API(glGetProgramiv,										PFNGLGETPROGRAMIVPROC);
		LOAD_API(glGetProgramInfoLog,									PFNGLGETPROGRAMINFOLOGPROC);
		LOAD_API(glValidateProgram,										PFNGLVALIDATEPROGRAMPROC);
		LOAD_API(glGetShaderiv,											PFNGLGETSHADERIVPROC);
		LOAD_API(glGetShaderInfoLog,									PFNGLGETSHADERINFOLOGPROC);
		LOAD_API(glBindBufferRange,										PFNGLBINDBUFFERRANGEPROC);
		LOAD_API(glBindBufferBase,										PFNGLBINDBUFFERBASEPROC);
		LOAD_API(glGetUniformBlockIndex,								PFNGLGETUNIFORMBLOCKINDEXPROC);
		LOAD_API(glUniformBlockBinding,									PFNGLUNIFORMBLOCKBINDINGPROC);
		LOAD_API(glGetActiveUniformBlockiv,								PFNGLGETACTIVEUNIFORMBLOCKIVPROC);
		LOAD_API(glGetActiveUniformBlockName,							PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC);
		LOAD_API(glGetActiveUniformsiv,									PFNGLGETACTIVEUNIFORMSIVPROC);
		LOAD_API(glGetUniformLocation,									PFNGLGETUNIFORMLOCATIONPROC);
		LOAD_API(glProgramUniform1f,									PFNGLPROGRAMUNIFORM1FPROC);
		LOAD_API(glProgramUniform

		LOAD_API(glProgramUniform1ui,									PFNGLPROGRAMUNIFORM1UIPROC);
		LOAD_API(glProgramUniform2fv,									PFNGLPROGRAMUNIFORM2FVPROC);
		LOAD_API(glProgramUniform3fv,									PFNGLPROGRAMUNIFORM3FVPROC);
		LOAD_API(glProgramUniform4fv,									PFNGLPROGRAMUNIFORM4FVPROC);
		LOAD_API(glProgramUniform2iv,									PFNGLPROGRAMUNIFORM2IVPROC);
		LOAD_API(glProgramUniform3iv,									PFNGLPROGRAMUNIFORM3IVPROC);
		LOAD_API(glProgramUniform4iv,									PFNGLPROGRAMUNIFORM4IVPROC);
		LOAD_API(glProgramUniform2uiv,									PFNGLPROGRAMUNIFORM2UIVPROC);
		LOAD_API(glProgramUniform3uiv,									PFNGLPROGRAMUNIFORM3UIVPROC);
		LOAD_API(glProgramUniform4uiv,									PFNGLPROGRAMUNIFORM4UIVPROC);
		LOAD_API(glProgramUniformMatrix4fv,								PFNGLPROGRAMUNIFORMMATRIX4FVPROC);
		LOAD_API(glTexStorage1D,										PFNGLTEXSTORAGE1DPROC);
		LOAD_API(glTexStorage2D,										PFNGLTEXSTORAGE2DPROC);
		LOAD_API(glTexStorage2DMultisample,								PFNGLTEXSTORAGE2DMULTISAMPLEPROC);
		LOAD_API(glTexStorage

		LOAD_API(glTexSubImage3D,										PFNGLTEXSUBIMAGE3DPROC);
		LOAD_API(glGenSamplers,											PFNGLGENSAMPLERSPROC);
		LOAD_API(glDeleteSamplers,										PFNGLDELETESAMPLERSPROC);
		LOAD_API(glSamplerParameteri,									PFNGLSAMPLERPARAMETERIPROC);
		LOAD_API(glSamplerParameterf,									PFNGLSAMPLERPARAMETERFPROC);
		LOAD_API(glSamplerParameteriv,									PFNGLSAMPLERPARAMETERIVPROC);
		LOAD_API(glSamplerParameterfv,									PFNGLSAMPLERPARAMETERFVPROC);
		LOAD_API(glBindSampler,											PFNGLBINDSAMPLERPROC);
		LOAD_API(glGetSamplerParameteriv,								PFNGLGETSAMPLERPARAMETERIVPROC);
		LOAD_API(glGenRenderbuffers,									PFNGLGENRENDERBUFFERSPROC);
		LOAD_API(glDeleteRenderbuffers,									PFNGLDELETERENDERBUFFERSPROC);
		LOAD_API(glRenderbufferStorage,									PFNGLRENDERBUFFERSTORAGEPROC);
		LOAD_API(glRenderbufferStorageMultisample,									PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC);
		
		LOAD_API(glBindRenderbuffer,									PFNGLBINDRENDERBUFFERPROC);
		LOAD_API(glGenFrame

		LOAD_API(glDeleteFramebuffers,									PFNGLDELETEFRAMEBUFFERSPROC);
		LOAD_API(glBindFramebuffer,										PFNGLBINDFRAMEBUFFERPROC);
		LOAD_API(glCheckFramebufferStatus,								PFNGLCHECKFRAMEBUFFERSTATUSPROC);
		LOAD_API(glFramebufferTexture,									PFNGLFRAMEBUFFERTEXTUREPROC);
		LOAD_API(glFramebufferRenderbuffer,								PFNGLFRAMEBUFFERRENDERBUFFERPROC);
		LOAD_API(glBlendColor,											PFNGLBLENDCOLORPROC);
		LOAD_API(glStencilOpSeparate,									PFNGLSTENCILOPSEPARATEPROC);
		LOAD_API(glBlendEquationSeparate,								PFNGLBLENDEQUATIONSEPARATEPROC);
		LOAD_API(glBlendFuncSeparate,									PFNGLBLENDFUNCSEPARATEPROC);
		LOAD_API(glStencilMaskSeparate,									PFNGLSTENCILMASKSEPARATEPROC);
		LOAD_API(glStencilFuncSeparate,									PFNGLSTENCILFUNCSEPARATEPROC);
		LOAD_API(glDrawBuffers,											PFNGLDRAWBUFFERSPROC);
		LOAD_API(glCompressedTexSubImage2D,								PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC);
		LOAD_API(glCompressedTexSubImage3D,								PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC
using namespace AST;
using namespace std;
void Program::dump(std::ostream &o) {
    for(NamespaceIterator it = nsl->begin(); it != nsl->end(); it++)
        (*it)->dump(o);
void Block::dump(std::ostream &o) {
    for(StatementIterator it = sl->begin(); it != sl->end(); it++) {
        (*it)->dump(o);
        o << ";" << std::endl;
    }
void Namespace::dump(std::ostream &o) {
    o << "namespace " << id << std::endl << "{" << std::endl;
    for(ClassIterator it = csl->begin(); it != csl->end(); it++)
        (*it)->dump(o);
    o << "}" << std::endl;
void Class::dump(std::ostream &o) {
    o << "class " << id << std::endl << "{" << std::endl;
    for(FeatureIterator it = fl->begin(); it != fl->end(); it++)
        (*it)->dump(o);
    o << "}" << std::endl;
void FieldFeature::dump(std::ostream &o) {
    o << decl_type << " " << id;
    if(expr != NULL) {
        o << " = ";
        expr->dump(o);
    }
    o << ";" << std::endl;
void MethodFeature::dump(std::ostream &o) {
    o << ret_t
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
    return TRUE;
DESKTOPEARLABDLL_API void *CreateModel(void)
	return new Model();
DESKTOPEARLABDLL_API int SetModuleDirectory(void *ModelPtr, char *ModuleDirectoryPath)
	Model *newModel = (Model *)ModelPtr;
	return newModel->SetModuleDirectory(ModuleDirectoryPath);
DESKTOPEARLABDLL_API void SetLogCallback(void *ModelPtr, LogCallback theCallback)
	Model *newModel = (Model *)ModelPtr;
	gLogger.SetLogCallback(theCallback);
	newModel->SetLogger(&gLogger);
DESKTOPEARLABDLL_API int LoadModelConfigFile(void *ModelPtr, char *ModelConfigFileName, float FrameSize_uS)
	Model *newModel = (Model *)ModelPtr;
	try
	{
		return newModel->Load(ModelConfigFileName, FrameSize_uS);
	}
	catch (EarlabException e)
	{
		gLogger.

	}
	return 0;
DESKTOPEARLABDLL_API int LoadModuleParameters(void *ModelPtr, char *ModuleParameterFileName)
	Model *newModel = (Model *)ModelPtr;
	try
	{
		return newModel->LoadModuleParameters(ModuleParameterFileName);
	}
	catch (EarlabException e)
	{
		gLogger.Log("Model threw exception during LoadModuleParameters: %s", e.GetExceptionString());
	}
	return 0;
DESKTOPEARLABDLL_API int StartModules(void *ModelPtr)
	Model *newModel = (Model *)ModelPtr;
	try
	{
		return newModel->StartModules();
	}
	catch (EarlabException e)
	{
		gLogger.Log("Model threw exception during StartModules: %s", e.GetExceptionString());
	}
	return 0;
DESKTOPEARLABDLL_API int RunModel(void *ModelPtr, int NumFrames)
	Model *newModel = (Model *)ModelPtr;
	try
	{
		return newModel->Run(NumFrames);
	}
	catch (EarlabException e)
	{
		gLogger.Log("Model threw exception during RunModel: %s", e.GetExceptionString());
	}
	return 0;
DESKTOPEARLABDLL_API int AdvanceModules(void *ModelPtr)
	Model *newModel = (Model *)ModelP
namespace opennlp
    namespace tools
    {
        namespace chunker
        {
            using opennlp::model::AbstractModel;
            using opennlp::model::BinaryFileDataReader;
            using opennlp::model::GenericModelReader;
            using opennlp::tools::util::InvalidFormatException;
            using opennlp::tools::util::model::BaseModel;
const std::string ChunkerModel::COMPONENT_NAME = "ChunkerME";
const std::string ChunkerModel::CHUNKER_MODEL_ENTRY_NAME = "chunker.model";
            ChunkerModel::ChunkerModel(const std::string &languageCode, AbstractModel *chunkerModel, Map<std::string, std::string> *manifestInfoEntries) : opennlp.tools.util.model.BaseModel(COMPONENT_NAME, languageCode, manifestInfoEntries)
            {
              artifactMap->put(CHUNKER_MODEL_ENTRY_NAME, chunkerModel);
              checkArtifactMap();
            }
            ChunkerModel::ChunkerModel(const std::string &languageCode, AbstractModel *chunkerModel)
            {
           

            ChunkerModel::ChunkerModel(InputStream *in_Renamed) throw(IOException, InvalidFormatException) : opennlp.tools.util.model.BaseModel(COMPONENT_NAME, in)
            {
            }
            void ChunkerModel::validateArtifactMap() throw(InvalidFormatException)
            {
              BaseModel::validateArtifactMap();
              if (!(dynamic_cast<AbstractModel*>(artifactMap->get(CHUNKER_MODEL_ENTRY_NAME)) != 0))
              {
                throw InvalidFormatException("Chunker model is incomplete!");
              }
            }
            opennlp::model::AbstractModel *ChunkerModel::getChunkerModel()
            {
              return static_cast<AbstractModel*>(artifactMap->get(CHUNKER_MODEL_ENTRY_NAME));
            }
            void ChunkerModel::main(std::string args[]) throw(FileNotFoundException, IOException)
            {
              if (sizeof(args) / sizeof(args[0]) != 4)
              {
                System::err::println("ChunkerModel -lang c
class RepoMonitor : public Thread
public:
    RepoMonitor() : Thread() {
    }
    /*
     * Update repository information and return thre repoId, otherwise empty 
     * string.
     */
    void updateRepo(const std::string &path) {
        RepoControl repo = RepoControl(path);
        RepoInfo info;
        try {
            repo.open();
        } catch (SystemException &e) {
            WARNING("Failed to open repository %s: %s", path.c_str(), e.what());
            return;
        }
        RWKey::sp key = infoLock.writeLock();
        if (MDS::instance()->myInfo.hasRepo(repo.getUUID())) {
            info = MDS::instance()->myInfo.getRepo(repo.getUUID());
        } else {
            info = RepoInfo(repo.getUUID(), repo.getPath());
        }
        info.updateHead(repo.getHead());
        MDS::instance()->myInfo.updateRepo(repo.getUUID(), info);
        LOG("Checked %s: %s %s", path.c_str(), repo.getHead().c_str(), repo.getUUID().c_str());
        
        repo.close();
        r
class IOContextXfer : public IOContextControlled,public Sendfile
  typedef IOContextControlled super;
  
  XferLimit* _limit;
  void
  free()
  {
    if(_limit){
      delete _limit;
      _limit=0;
    }
    if(stream_out() && stream_out()->consumer() == this)
      stream_out()->release_consumer();
    if(stream_in() && stream_in()->consumer() == this)
      stream_in()->release_consumer();
  }
  void
  do_io()
  {
    if(!stream_in() && data_buffered()){
      Sendfile::write_out();
      if(!data_buffered()){
	completed();
	return;
      }
      return;
    }
    if(!stream_in()||!stream_out())
      return;
    bool result = Sendfile::io();
    if(result){
      completed();
      return;
    }
  }
 protected:
  void
  limit_xfer(off_t bytes)
  {
    _limit->xfer(bytes);
    if(bytes)
      made_progress();
  }
  
public:
  IOContextXfer(IOController*ioc,Stream*in=0,Stream*out=0):
    IOContextControlled(ioc),
    Sendfile(in,out),
    _limit(0)
  {
  }
  void
  limit(XferLimit*xl

  {
    _limit = xl;
  }
  bool
  stream_hungup(Stream&stream)
  {
    if(stream_in() && stream_in()->consumer() == this)
      stream_in()->release_consumer();
    if (stream_out() &&
	&stream==stream_in() && &stream != stream_out()) {
      if(data_buffered()){
	stream_in(0);
	return false;
      }
    }
    if(stream_out() && stream_out()->consumer() == this)
      stream_out()->release_consumer();
    stream_out(0);
    stream_in(0);
    return true;
  }
  std::string
  desc()const
  {
    return "sendfile " + super::desc();
  }
  
  ~IOContextXfer()
  {
    free();
  }
  bool want_write(Stream&stream)
  {
    if(!stream_out()){
      if(stream_in()!=&stream)
	stream_out(&stream);
    }
    if(has_buf() && !data_buffered())
      return false;
    return &stream==stream_out();
  }
  bool want_read(Stream&stream)
  {
    if(!stream_in()){
      if(stream_out()!=&stream)
	stream_in(&stream);
    }
    if(data_buffered())
      return false;
    if(&stream!=stream_in())
      return 
class SampleBuffer {
  public:
    SampleBuffer(short number_of_normalized_samples);
    ~SampleBuffer();
    
    Sample replaced_by(Sample new_sample);
    
    void fill_with(Sample sample);
    boolean is_valid();
    
    short size();
    
  private:
    short number_of_samples;
    short current_sample_index;
    Sample *samples;
  protected:
    boolean valid;
  
};
class AveragingSampleBuffer : SampleBuffer {
  public:
    AveragingSampleBuffer(short number_of_normalized_samples);
    
    Sample replaced_by(Sample new_sample);
    
    long sum();
    Sample average();
    
    Sample normalize(Sample sample);
    
  protected:
    long sum_of_all_samples;
  
};
double half_life_sample_to_multiplier(double half_life);
class ExponentialAverage {
  public: 
    ExponentialAverage(double multiplier, double start = 0);
    
    void add_sample(Sample sample);
    
    const Sample average();
    
    const Sample normalize(Sample sample);
    
  private:
    double multiplier;
  
/* Generated file.  Do not edit */
VTE_SEQUENCE_HANDLER(vte_sequence_handler_application_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_backspace)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_bell)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_carriage_return)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_background_color_bel)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_background_color_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_color_bel)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_color_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_cursor_color_bel)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_cursor_color_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_foreground_color_bel)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_foreground_color_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_highlight_background_color_bel)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_highlight_background_color_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_change

VTE_SEQUENCE_HANDLER(vte_sequence_handler_change_highlight_foreground_color_st)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_character_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_back_tab)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_backward)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_character_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_down)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_forward)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_forward_tabulation)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_position)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_position_top_row)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_preceding_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_cursor_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_dec_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_d

VTE_SEQUENCE_HANDLER(vte_sequence_handler_decset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_delete_characters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_delete_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_designate_g0_british)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_designate_g0_line_drawing)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_designate_g0_plain)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_designate_g1_british)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_designate_g1_line_drawing)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_designate_g1_plain)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_device_status_report)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_characters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_display)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_erase_in_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_form_feed)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_full_reset)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_index)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_ins

VTE_SEQUENCE_HANDLER(vte_sequence_handler_insert_lines)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_line_feed)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_line_position_absolute)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_linux_console_cursor_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_next_line)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_nop)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_normal_keypad)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_request_terminal_parameters)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_background_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_cursor_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_foreground_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_highlight_background_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_highlight_foreground_color)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reset_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_restore_cursor)
VTE_SEQU

VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_id)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_return_terminal_status)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_reverse_index)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_save_cursor)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_save_mode)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_screen_alignment_test)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_down)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_scroll_up)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_primary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_send_secondary_device_attributes)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_current_directory_uri)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_current_file_uri)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_cursor_style)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_and_window_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_icon_title)
VTE_SEQUENCE_HANDLER(vte_sequence_handler_set_mode)
VTE_SEQUENC
/**
 *  Copyright (C) 2015 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 */
namespace repo {
namespace core {
/*!
 */
class REPO_CORE_EXPORT RepoImage : public RepoBinary
public:
    RepoImage() : RepoBinary() {}
    RepoImage(const mongo::BSONObj &obj) : RepoBinary(obj) {}
    RepoImage(const unsigned char* bytes,
              unsigned int bytesLength,
              unsigned int width,
              unsigned int height,
 
/*
 * Copyright (c) 2012 Qualcomm Atheros, Inc. All rights reserved.
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all copies.
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
extern "C" {
    SW_API_DEF(SW_API_PT_DUPLEX_GET, athena_port_duplex_get), \
    SW_API_DEF(SW_API_PT_DUPLEX_SET, athena_port_duplex_set), \
    SW_API_DEF(SW_API_PT_SPEED_GET, athena_port_speed_get), 

    SW_API_DEF(SW_API_PT_SPEED_SET, athena_port_speed_set), \
    SW_API_DEF(SW_API_PT_AN_GET, athena_port_autoneg_status_get), \
    SW_API_DEF(SW_API_PT_AN_ENABLE, athena_port_autoneg_enable), \
    SW_API_DEF(SW_API_PT_AN_RESTART, athena_port_autoneg_restart), \
    SW_API_DEF(SW_API_PT_AN_ADV_GET, athena_port_autoneg_adv_get), \
    SW_API_DEF(SW_API_PT_AN_ADV_SET, athena_port_autoneg_adv_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_SET, athena_port_igmps_status_set), \
    SW_API_DEF(SW_API_PT_IGMPS_MODE_GET, athena_port_igmps_status_get), \
    SW_API_DEF(SW_API_PT_POWERSAVE_SET, athena_port_powersave_set), \
    SW_API_DEF(SW_API_PT_POWERSAVE_GET, athena_port_powersave_get), \
    SW_API_DEF(SW_API_PT_HIBERNATE_SET, athena_port_hibernate_set), \
    SW_API_DEF(SW_API_PT_HIBERNATE_GET, athena_port_hibernate_get),
    SW_API_DESC(SW_API_PT_DUPLEX_GET)  \
    SW_API_DESC(SW_API_PT_DUPLEX_SET)  \
    SW_API_DESC(SW_API_PT_SPEED_GET)  \
    SW_API_DESC(SW_API_PT_SPEED_SET)  \
    SW_

    SW_API_DESC(SW_API_PT_AN_ENABLE)  \
    SW_API_DESC(SW_API_PT_AN_RESTART) \
    SW_API_DESC(SW_API_PT_AN_ADV_GET) \
    SW_API_DESC(SW_API_PT_AN_ADV_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_SET) \
    SW_API_DESC(SW_API_PT_IGMPS_MODE_GET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_SET) \
    SW_API_DESC(SW_API_PT_POWERSAVE_GET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_SET) \
    SW_API_DESC(SW_API_PT_HIBERNATE_GET)
    SW_API_DEF(SW_API_VLAN_ADD, athena_vlan_create), \
    SW_API_DEF(SW_API_VLAN_DEL, athena_vlan_delete), \
    SW_API_DEF(SW_API_VLAN_MEM_UPDATE, athena_vlan_member_update), \
    SW_API_DEF(SW_API_VLAN_FIND, athena_vlan_find), \
    SW_API_DEF(SW_API_VLAN_NEXT, athena_vlan_next), \
    SW_API_DEF(SW_API_VLAN_APPEND, athena_vlan_entry_append),
    SW_API_DESC(SW_API_VLAN_ADD)  \
    SW_API_DESC(SW_API_VLAN_DEL)  \
    SW_API_DESC(SW_API_VLAN_MEM_UPDATE) \
    SW_API_DESC(SW_API_VLAN_FIND) \
    SW_API_DESC(SW_API_VLAN_NEXT) \
    SW_API_DESC(SW_API_VLAN_APPEND)
    SW_API

    SW_API_DEF(SW_API_PT_ING_MODE_SET, athena_port_1qmode_set), \
    SW_API_DEF(SW_API_PT_EG_MODE_GET, athena_port_egvlanmode_get), \
    SW_API_DEF(SW_API_PT_EG_MODE_SET, athena_port_egvlanmode_set), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_ADD, athena_portvlan_member_add), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_DEL, athena_portvlan_member_del), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_UPDATE, athena_portvlan_member_update), \
    SW_API_DEF(SW_API_PT_VLAN_MEM_GET, athena_portvlan_member_get), \
    SW_API_DESC(SW_API_PT_ING_MODE_GET)  \
    SW_API_DESC(SW_API_PT_ING_MODE_SET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_GET)  \
    SW_API_DESC(SW_API_PT_EG_MODE_SET)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_ADD) \
    SW_API_DESC(SW_API_PT_VLAN_MEM_DEL) \
    SW_API_DESC(SW_API_PT_VLAN_MEM_UPDATE)  \
    SW_API_DESC(SW_API_PT_VLAN_MEM_GET)
    SW_API_DEF(SW_API_FDB_ADD, athena_fdb_add), \
    SW_API_DEF(SW_API_FDB_DELALL, athena_fdb_del_all), \
    SW_API_DEF(SW_API_FDB_DELPORT,athena_fdb_del_by_port), \
 

    SW_API_DEF(SW_API_FDB_FIRST,  athena_fdb_first), \
    SW_API_DEF(SW_API_FDB_NEXT,   athena_fdb_next),
    SW_API_DESC(SW_API_FDB_ADD)  \
    SW_API_DESC(SW_API_FDB_DELALL)  \
    SW_API_DESC(SW_API_FDB_DELPORT) \
    SW_API_DESC(SW_API_FDB_DELMAC)  \
    SW_API_DESC(SW_API_FDB_FIRST)   \
    SW_API_DESC(SW_API_FDB_NEXT)
    SW_API_DEF(SW_API_PT_MIB_GET, athena_get_mib_info),
    SW_API_DESC(SW_API_PT_MIB_GET)
    SW_API_DEF(SW_API_PHY_GET, athena_phy_get), \
    SW_API_DEF(SW_API_PHY_SET, athena_phy_set), \
    SW_API_DEF(SW_API_REG_GET, athena_reg_get), \
    SW_API_DEF(SW_API_REG_SET, athena_reg_set), \
    SW_API_DEF(SW_API_REG_FIELD_GET, athena_reg_field_get), \
    SW_API_DEF(SW_API_REG_FIELD_SET, athena_reg_field_set),
    SW_API_DESC(SW_API_PHY_GET)  \
    SW_API_DESC(SW_API_PHY_SET)  \
    SW_API_DESC(SW_API_REG_GET)  \
    SW_API_DESC(SW_API_REG_SET)  \
    SW_API_DESC(SW_API_REG_FIELD_GET) \
    SW_API_DESC(SW_API_REG_FIELD_SET)
    SW_API_DEF(SW_API_SWITCH_RESET, athen
VBitStream::VBitStream(int bitCount)
	this->setBitCount(bitCount);
VBitStream::VBitStream(){
	Type(BitStreamInfo::VERTICAL_STREAM_FORMAT);
BitStreamInfo * VBitStream::Clone()
	VBitStream * bit_stream = new VBitStream();	
	bit_stream->convert(getProcessedBitStream());
	bit_stream->Type(this->Type());
	BitStreamInfo::Clone(bit_stream);
	return bit_stream;
size_t VBitStream::SpaceUtilisation()
	size_t space = sizeof(this);
	space += Decompress().size()/ 8;
	return space;
VBitStream::~VBitStream(void)
dynamic_bitset<> VBitStream::Decompress(){
	return this->getProcessedBitStream();
void VBitStream::CompressWords(boost::dynamic_bitset<>& bitMap){
	this->convert(bitMap);
BitStreamInfo* VBitStream::operator ~(){
	BitStreamInfo * v_bit_stream = new VBitStream();
	dynamic_bitset<> temp_stream = this->getProcessedBitStream();
	temp_stream.flip();
	v_bit_stream->convert(temp_stream);
	return v_bit_stream;
BitStreamInfo* VBitStream::operator &(BitStreamInfo & _structure){
	VBitStream * v_bit_strea
namespace Gfx {
	struct GraphicState {
	};
	template<typename DrawOpApi>
	struct DrawOperationInterface {
		GraphicState<DrawOpApi::graphics_state_api_type> gfx_state;
		GfxGeometryBuffers<DrawOpApi::geom_api_type> geom;
	};
	template<typename VertexBufferApi, typename IndexBufferApi>
	struct CachedGeometry {
		VertexBufferApi position;
		VertexBufferApi normal;
		VertexBufferApi uv;
		IndexBufferApi indices;
	};
	template<typename DrawTargetApi>
	struct DrawTargetInterface {
		DrawTargetInterface(DrawTargetApi api) : target(api) { }
		DrawTargetApi::draw_target_type target;
	};
	template<typename TextureApi>
	struct TextureInterface {
		TextureInterface(const TextureApi& api) : api_(api) {
		}
		void clear(vec3 value) {
			api_.clear(value);
		}
		void clear(float value) {
			api_.clear(value);
		}
		TextureApi api_;
	};
	template<typename ShaderApi>
	class ShaderProgramInterface {
	public:
		ShaderProgramInterface(ShaderApi api) : api_(api) { }
		ShaderApi api_;
	};
	template<typenam
CoreClrFuncInvokeContext::CoreClrFuncInvokeContext(v8::Local<v8::Value> callback, void* task) : task(task), uv_edge_async(NULL), resultData(NULL), resultType(0)
    DBG("CoreClrFuncInvokeContext::CoreClrFuncInvokeContext");
    this->callback = new Nan::Callback(v8::Local<v8::Function>::Cast(callback));
CoreClrFuncInvokeContext::~CoreClrFuncInvokeContext()
	DBG("CoreClrFuncInvokeContext::~CoreClrFuncInvokeContext");
    if (this->callback)
    {
        this->callback->Reset();
        delete this->callback;
        this->callback = NULL;
    }
    if (this->task)
    {
    	CoreClrEmbedding::FreeHandle(this->task);
    	this->task = NULL;
    }
    if (this->resultData)
    {
    	CoreClrEmbedding::FreeMarshalData(this->resultData, this->resultType);
    	this->resultData = NULL;
    }
void CoreClrFuncInvokeContext::InitializeAsyncOperation()
	DBG("CoreClrFuncInvokeContext::InitializeAsyncOperation");
    this->uv_edge_async = V8SynchronizationContext::RegisterAction(CoreClrFuncInvoke

void CoreClrFuncInvokeContext::TaskComplete(void* result, int resultType, int taskState, CoreClrFuncInvokeContext* context)
	DBG("CoreClrFuncInvokeContext::TaskComplete");
	context->resultData = result;
	context->resultType = resultType;
	context->taskState = taskState;
	V8SynchronizationContext::ExecuteAction(context->uv_edge_async);
void CoreClrFuncInvokeContext::TaskCompleteSynchronous(void* result, int resultType, int taskState, v8::Local<v8::Value> callback)
	DBG("CoreClrFuncInvokeContext::TaskCompleteSynchronous");
	CoreClrFuncInvokeContext* context = new CoreClrFuncInvokeContext(callback, NULL);
	context->resultData = result;
	context->resultType = resultType;
	context->taskState = taskState;
	InvokeCallback(context);
void CoreClrFuncInvokeContext::InvokeCallback(void* data)
	DBG("CoreClrFuncInvokeContext::InvokeCallback");
	CoreClrFuncInvokeContext* context = (CoreClrFuncInvokeContext*)data;
	v8::Local<v8::Value> callbackData = Nan::Null();
	v8::Local<v8::Value> errors = Nan::
/*
** $Id: ldump.c,v 2.17.1.1 2013/04/12 18:48:47 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/
typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;
static void DumpBlock(const void* b, size_t size, DumpState* D)
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
static void DumpChar(int y, DumpState* D)
 char x=(char)y;
 DumpVar(x,D);
static void DumpInt(int x, DumpState* D)
 DumpVar(x,D);
static void DumpNumber(lua_Number x, DumpState* D)
 DumpVar(x,D);
static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 DumpInt(n,D);
 DumpMem(b,n,size,D);
static void DumpString(const TString* s, DumpState* D)
 if (s==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  DumpVar(size,D);
  DumpBlock(getstr(s),size*sizeof(char),D);
 }
static void DumpFunction(const Proto* f, DumpState* D);
static void DumpConstants(const Proto* f, Dum

 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttypenv(o),D);
  switch (ttypenv(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
    default: lua_assert(0);
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],D);
static void DumpUpvalues(const Proto* f, DumpState* D)
 int i,n=f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpChar(f->upvalues[i].instack,D);
  DumpChar(f->upvalues[i].idx,D);
 }
static void DumpDebug(const Proto* f, DumpState* D)
 int i,n;
 DumpString((D->strip) ? NULL : f->source,D);
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].
/*-----------------------------------------------------------------------------
Author: BÃ®rzu George
Email:	b.gxg7@yahoo.com
Date:	08-11-2015
-----------------------------------------------------------------------------*/
using namespace managers;
using namespace rendering;
ModelManager::ModelManager() { 
ModelManager::~ModelManager()
	/*for (auto model : modelList)
	{
		delete model.second;
	}
	modelList.clear();*/
void managers::ModelManager::createModel(rendering::interfaces::IModel* model, std::string modelName, GLuint program)
	model->setProgram(program);
	model->create();
	modelList[modelName] = model;
void ModelManager::deleteModel(const std::string& gameModelName)
	rendering::interfaces::IModel* model = modelList[gameModelName];
	model->destroy();
	modelList.erase(gameModelName);
const rendering::interfaces::IModel& ModelManager::getModel(const std::string& gameModelName) const
	return (*modelList.at(gameModelName));
void ModelManager::update()
	for (auto model : modelList)
	{


	}
void ModelManager::draw()
	for (auto model : modelList)
	{
		model.second->draw();
	}
void ModelManager::drawMini()
	for (auto model : modelList)
	{
		model.second->drawMini();
	}
glm::mat4 ModelManager::translate(float tx, float ty, float tz)
	return glm::transpose(glm::mat4(
		1, 0, 0, tx,
		0, 1, 0, ty,
		0, 0, 1, tz,
		0, 0, 0, 1
		));
glm::mat4 ModelManager::translateX(float t)
	return ModelManager::translate(t, 0, 0);
glm::mat4 ModelManager::translateY(float t)
	return ModelManager::translate(0, t, 0);
glm::mat4 ModelManager::translateZ(float t)
	return ModelManager::translate(0, 0, t);
glm::mat4 ModelManager::rotateX(float r)
	return glm::transpose(glm::mat4(
		1, 0, 0, 0,
		0, cos(r), -sin(r), 0,
		0, sin(r), cos(r), 0,
		0, 0, 0, 1
		));
glm::mat4 ModelManager::rotateY(float r)
	return glm::transpose(glm::mat4(
		cos(r), 0, -sin(r), 0,
		0, 1, 0, 0,
		sin(r), 0, cos(r), 0,
		0, 0, 0, 1
		));
glm::mat4 ModelManager::rotateZ(float r)
	return glm::transpose(glm::mat4(
		cos(r
TEST_F(CodeChunkTest, ChunkIsEmptyBeginAndEndAreEqual)
  CodeChunk chunk;
  EXPECT_EQ( chunk.begin(), chunk.end() );
TEST_F(CodeChunkTest, BeginChunkIsNotEmptyReturnsIteratorToTheBeginningOfChunk)
  AsmCode disasm;
  disasm.VirtualAddr = _baseVa;
  EXPECT_EQ( disasm, *_chunk.begin() );
TEST_F(CodeChunkTest, EndChunkIsNotEmptyReturnsIteratorToTheEndOfChunk)
  AsmCode disasm;
  disasm.VirtualAddr = _lastVa;
  EXPECT_EQ( disasm, *(_chunk.end() - 1) );
TEST_F(CodeChunkTest, FrontAlwaysReturnsFirstElement)
  AsmCode disasm;
  disasm.VirtualAddr = _baseVa;
  EXPECT_EQ( disasm, _chunk.front() );
TEST_F(CodeChunkTest, BackAlwaysReturnsLastElement)
  AsmCode disasm;
  disasm.VirtualAddr = _lastVa;
  EXPECT_EQ( disasm, _chunk.back() );
TEST_F(CodeChunkTest, FirstVaChunkIsEmptyReturnsMinusOne)
  CodeChunk chunk;
  EXPECT_EQ( -1, chunk.first_va() );
TEST_F(CodeChunkTest, LastVaChunkIsEmptyReturnsMinusOne)
  CodeChunk chunk;
  EXPECT_EQ( -1, chunk.last_va() );
TEST_F(CodeChunkTest, FirstVaChunkIsNo

  EXPECT_EQ( _baseVa, _chunk.first_va() );
TEST_F(CodeChunkTest, LastVaChunkIsNotEmptyReturnsVaOfLastDisasm)
  EXPECT_EQ ( _lastVa, _chunk.last_va() );
TEST_F(CodeChunkTest, IsAddressIncludedChunkIsEmptyReturnsFalse)
  CodeChunk chunk;
TEST_F(CodeChunkTest, IsAddressIncludedAddressIsLessThanZeroReturnsFalse)
  CodeChunk chunk;
TEST_F(CodeChunkTest, IsAddressIncludedBoundaryVasReturnsTrue)
TEST_F(CodeChunkTest, IsAddressIncludedAddressIsBetweenFirstVaAndLastVaReturnsTrue)
TEST_F(CodeChunkTest, IsAddressIncludedAddressIsNotBetweenFirstVaAndLastVaReturnsFalse)
TEST_F(CodeChunkTest, IntersectsWithPassedChunkBoundaryVasOverlapWithInnerChunkReturnsTrue)
  CodeChunk passedChunk1 = CodeChunkHelper::GenerateCodeChunk( _baseVa - 10, _baseVa );
  CodeChunk passedChunk2 = CodeChunkHelper::GenerateCodeChunk( _lastVa, _lastVa + 10 );
  EXPECT_TRUE( _chunk.intersects_with( passedChunk1 ) );
  EXPECT_TRUE( _chunk.intersects_with( passedChunk2 ) );
TEST_F(CodeChunkTest, IntersectsWithPassedCodeChunkIn

  CodeChunk passedChunk1 = CodeChunkHelper::GenerateCodeChunk( _baseVa - 10, _baseVa + 10 );
  CodeChunk passedChunk2 = CodeChunkHelper::GenerateCodeChunk( _baseVa + 10, _lastVa + 10 );
  EXPECT_TRUE( _chunk.intersects_with( passedChunk1 ) );
  EXPECT_TRUE( _chunk.intersects_with( passedChunk2 ) );
TEST_F(CodeChunkTest, IntersectsWithPassedCodeChunkDoesntIntersectReturnsFalse)
  CodeChunk passedChunk1 = CodeChunkHelper::GenerateCodeChunk( _baseVa - 10, _baseVa - 1 );
  CodeChunk passedChunk2 = CodeChunkHelper::GenerateCodeChunk( _lastVa + 1, _lastVa + 10 );
  EXPECT_FALSE( _chunk.intersects_with( passedChunk1 ) );
  EXPECT_FALSE( _chunk.intersects_with( passedChunk2 ) );
TEST_F(CodeChunkTest, IncludesCodeChunkIsEmptyReturnsFalse)
  CodeChunk chunk;
TEST_F(CodeChunkTest, IncludesPassedChunkBoundaryVasOverlapWithOnesFromInnerChunksReturnsTrue)
  CodeChunk passedChunk1 = CodeChunkHelper::GenerateCodeChunk( _baseVa, _lastVa - 10 );
  CodeChunk passedChunk2 = CodeChunkHelper::GenerateCodeC

TEST_F(CodeChunkTest, IncludesPassedChunkMatchesInnerChunkReturnsTrue)
  CodeChunk passedChunk = CodeChunkHelper::GenerateCodeChunk( _baseVa, _lastVa );
TEST_F(CodeChunkTest, IncludesPassedChunkIsInnerChunksSubsetReturnsTrue)
  CodeChunk passedChunk = CodeChunkHelper::GenerateCodeChunk( _baseVa + 10, _lastVa - 10 );
TEST_F(CodeChunkTest, IncludesPassedChunkPartiallyInetsectsWithInnerChunkReturnsFalse)
  CodeChunk passedChunk1 = CodeChunkHelper::GenerateCodeChunk( _baseVa - 10, _lastVa - 10 );
  CodeChunk passedChunk2 = CodeChunkHelper::GenerateCodeChunk( _baseVa + 10, _lastVa + 10 );
TEST_F(CodeChunkTest, IncludesPassedChunkNeverInetsectsWithInnerChunkReturnsFalse)
  CodeChunk passedChunk1 = CodeChunkHelper::GenerateCodeChunk( _baseVa - 10, _baseVa - 1 );
  CodeChunk passedChunk2 = CodeChunkHelper::GenerateCodeChunk( _lastVa + 1, _lastVa + 10 );
TEST_F(CodeChunkTest, AddToChunkAlwaysAddsSingleDisasm)
  AsmCode disasm;
  disasm.VirtualAddr = 1000;
  CodeChunk chunk;
  chunk.add_to_chun
namespace Stream
	class CInputStreamHelper : public Stream::IInputStreamHelper
	{
	public:
		CInputStreamHelper(Stream::IInputStream& rInputStream);
		virtual ~CInputStreamHelper(void);
		virtual Stream::boolean setBufferSize(Stream::uint64 ui64BufferSize);
		virtual Stream::uint64 getBufferSize(void);
		virtual Stream::uint64 getBufferFill(void);
		virtual Stream::boolean open(void);
		virtual Stream::boolean isOpened(void);
		virtual Stream::boolean isFinished(void);
		virtual Stream::boolean close(void);
		virtual Stream::uint64 receiveBuffer(Stream::uint8* pBuffer, const Stream::uint64 ui64BufferSize);
		virtual Stream::boolean setEndianness(const Stream::EEndianness& eEndianness);
		virtual Stream::EEndianness getEndianness(void);
		virtual Stream::uint8 receiveUInteger8(void);
		virtual Stream::uint16 receiveUInteger16(void);
		virtual Stream::uint32 receiveUInteger32(void);
		virtual Stream::uint64 receiveUInteger64(void);
		virtual Stream::int8 receiveSInteger8(void);
		virtual
/*=========================================================================
  Program:   Insight Segmentation & Registration Toolkit
  Module:    $RCSfile: itkFEMLoadImplementationsRegister.cxx,v $
  Language:  C++
  Date:      $Date: 2008/10/18 00:22:50 $
  Version:   $Revision: 1.1.1.1 $
  Copyright (c) Insight Software Consortium. All rights reserved.
     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
=========================================================================*/
namespace itk {
namespace fem {
/* This macro makes registering Load implementations easier. */
  { ElementClass::LoadImplementationFunctionPointer fp=&FunctionName; \
    /* NOTE: Borland compiler (bcc 5.5.1) crashes if the pointer to templated function is not stored in a variable, before it is used in a function call below. */ \
    VisitorDispatcher

    ::RegisterVisitor((LoadClass*)0, fp); }
/* Use this macro to also automatically declare load implementation function. */
  extern void FunctionName(ElementClass::ConstPointer, ElementClass::LoadPointer, ElementClass::VectorType& ); \
  REGISTER_LOAD_EX(ElementClass,LoadClass,FunctionName)
/**
 * Registers all Load classes in the FEM library with VisitorDispatcher.
 * This function must be called before the FEM library is functional!.
 */
void LoadImplementationsRegister(void)
  REGISTER_LOAD_EX(Element2DC0LinearLineStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC1Beam,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStress,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStrain,LoadGravConst

  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralLinearElasticity,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearQuadrilateralLinearElasticity,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStress,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularStrain,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2D

  REGISTER_LOAD_EX(Element2DC0LinearTriangularMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DC0LinearTriangularMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearHexahedronStrain,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearHexahedronStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearHexahedronMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearHexahedronMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearHexahedronLinearElasticity,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearHexahedronLinearElasticity,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearTet

  REGISTER_LOAD_EX(Element3DC0LinearTetrahedronStrain,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearTetrahedronMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element3DC0LinearTetrahedronMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DBSplinePatchLinearElasticity,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DBSplinePatchLinearElasticity,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DBSplinePatchMembrane,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DBSplinePatchMembrane,LoadLandmark,LoadImplementationGenericLandmarkLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DBSplinePatchStress,LoadGravConst,LoadImplementationGenericBodyLoad::HandleLoad);
  REGISTER_LOAD_EX(Element2DBSplinePatchStress,LoadLandmark,LoadIm
/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=99 ft=cpp:
 */
namespace ejsllvm {
    typedef struct {
        /* object header */
        EJSObject obj;
        /* call specific data */
        llvm::CallInst *llvm_call;
    } Call;
    static EJSSpecOps _ejs_Call_specops;
    static ejsval _ejs_Call_prototype EJSVAL_ALIGNMENT;
    static ejsval _ejs_Call EJSVAL_ALIGNMENT;
    static EJSObject* Call_allocate()
    {
        return (EJSObject*)_ejs_gc_new(Call);
    }
    static EJS_NATIVE_FUNC(Call_impl) {
        EJS_NOT_IMPLEMENTED();
    }
    ejsval
    Call_new(llvm::CallInst* llvm_call)
    {
        ejsval result = _ejs_object_new (_ejs_Call_prototype, &_ejs_Call_specops);
        ((Call*)EJSVAL_TO_OBJECT(result))->llvm_call = llvm_call;
        return result;
    }
    static EJS_NATIVE_FUNC(Call_prototype_toString) {
        std::string str;
        llvm::raw_string_ostream str_ostream(str);
        ((Call*)EJSVAL_TO_O

        return _ejs_string_new_utf8(trim(str_ostream.str()).c_str());
    }
    static EJS_NATIVE_FUNC(Call_prototype_dump) {
        ((Call*)EJSVAL_TO_OBJECT(*_this))->llvm_call->dump();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Call_prototype_setOnlyReadsMemory) {
        Call* call = ((Call*)EJSVAL_TO_OBJECT(*_this));
        call->llvm_call->setOnlyReadsMemory();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Call_prototype_setDoesNotAccessMemory) {
        Call* call = ((Call*)EJSVAL_TO_OBJECT(*_this));
        call->llvm_call->setDoesNotAccessMemory();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Call_prototype_setDoesNotThrow) {
        Call* call = ((Call*)EJSVAL_TO_OBJECT(*_this));
        call->llvm_call->setDoesNotThrow();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Call_prototype_setStructRet) {
        Call* call = ((Call*)EJSVAL_TO_OBJECT(*_this));
        call->llvm_call->addAttribute(1 /* fir

                                      llvm::Attribute::StructRet);
        return _ejs_undefined;
    }
    llvm::CallInst*
    Call_GetLLVMObj(ejsval val)
    {
        if (EJSVAL_IS_NULL(val)) return NULL;
        return ((Call*)EJSVAL_TO_OBJECT(val))->llvm_call;
    }
    void
    Call_init (ejsval exports)
    {
        _ejs_Call_specops = _ejs_Object_specops;
        _ejs_Call_specops.class_name = "LLVMCall";
        _ejs_Call_specops.Allocate = Call_allocate;
        _ejs_gc_add_root (&_ejs_Call_prototype);
        _ejs_Call_prototype = _ejs_object_new(_ejs_Object_prototype, &_ejs_Call_specops);
        ejsval tmpobj = _ejs_function_new_utf8 (_ejs_null, "LLVMCall", (EJSClosureFunc)Call_impl);
        _ejs_Call = tmpobj;
        _ejs_object_setprop (_ejs_Call,       _ejs_atom_prototype,  _ejs_Call_prototype);
        PROTO_METHOD(setOnlyReadsMemory);
        PROTO_METHOD(setDoesNotAccessMemory);
        PROTO_METHOD(setDoesNotThrow);
        PROTO_METHOD(setStructRet);
        PR

        PROTO_METHOD(toString);
        _ejs_object_setprop_utf8 (exports,              "Call", _ejs_Call);
    }
    typedef struct {
        /* object header */
        EJSObject obj;
        /* invoke specific data */
        llvm::InvokeInst *llvm_invoke;
    } Invoke;
    static EJSSpecOps _ejs_Invoke_specops;
    static ejsval _ejs_Invoke_prototype EJSVAL_ALIGNMENT;
    static ejsval _ejs_Invoke EJSVAL_ALIGNMENT;
    static EJSObject* Invoke_allocate()
    {
        return (EJSObject*)_ejs_gc_new(Invoke);
    }
    static EJS_NATIVE_FUNC(Invoke_impl) {
        EJS_NOT_IMPLEMENTED();
    }
    ejsval
    Invoke_new(llvm::InvokeInst* llvm_invoke)
    {
        ejsval result = _ejs_object_new (_ejs_Invoke_prototype, &_ejs_Invoke_specops);
        ((Invoke*)EJSVAL_TO_OBJECT(result))->llvm_invoke = llvm_invoke;
        return result;
    }
    static EJS_NATIVE_FUNC(Invoke_prototype_toString) {
        std::string str;
        llvm::raw_string_ostream str_ostream(str);
        ((Invo

        return _ejs_string_new_utf8(trim(str_ostream.str()).c_str());
    }
    static EJS_NATIVE_FUNC(Invoke_prototype_dump) {
        ((Invoke*)EJSVAL_TO_OBJECT(*_this))->llvm_invoke->dump();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Invoke_prototype_setOnlyReadsMemory) {
        Invoke* invoke = ((Invoke*)EJSVAL_TO_OBJECT(*_this));
        invoke->llvm_invoke->setOnlyReadsMemory();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Invoke_prototype_setDoesNotAccessMemory) {
        Invoke* invoke = ((Invoke*)EJSVAL_TO_OBJECT(*_this));
        invoke->llvm_invoke->setDoesNotAccessMemory();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Invoke_prototype_setDoesNotThrow) {
        Invoke* invoke = ((Invoke*)EJSVAL_TO_OBJECT(*_this));
        invoke->llvm_invoke->setDoesNotThrow();
        return _ejs_undefined;
    }
    static EJS_NATIVE_FUNC(Invoke_prototype_setStructRet) {
        Invoke* invoke = ((Invoke*)EJSVAL_TO_OBJECT(*_this

        invoke->llvm_invoke->addAttribute(1 /* first arg */,
                                          llvm::Attribute::StructRet);
        return _ejs_undefined;
    }
    llvm::InvokeInst*
    Invoke_GetLLVMObj(ejsval val)
    {
        if (EJSVAL_IS_NULL(val)) return NULL;
        return ((Invoke*)EJSVAL_TO_OBJECT(val))->llvm_invoke;
    }
    void
    Invoke_init (ejsval exports)
    {
        _ejs_Invoke_specops = _ejs_Object_specops;
        _ejs_Invoke_specops.class_name = "LLVMInvoke";
        _ejs_Invoke_specops.Allocate = Invoke_allocate;
        _ejs_gc_add_root (&_ejs_Invoke_prototype);
        _ejs_Invoke_prototype = _ejs_object_new(_ejs_Object_prototype, &_ejs_Invoke_specops);
        _ejs_Invoke = _ejs_function_new_utf8_with_proto (_ejs_null, "LLVMInvoke", (EJSClosureFunc)Invoke_impl, _ejs_Invoke_prototype);
        _ejs_object_setprop_utf8 (exports,              "Invoke", _ejs_Invoke);
        PROTO_METHOD(setOnlyReadsMemory);
        PROTO_METHOD(setDoesNotAccessMemor
/*-----------------------------------------------------------------------
 * File: bioapi_typecast.htp
 *
 *-----------------------------------------------------------------------
 */
/* API Functions */
extern "C" {
/*************************************************************************/
/*** This file is automatically generated. Do not hand edit **************/
/*************************************************************************/
/*************************************************************************/
/*** BioAPI Core Functions ***********************************************/
/*************************************************************************/
typedef BioAPI_RETURN (BioAPI *BioAPI_Init_ptr)(
						const BioAPI_VERSION *Version,
						uint32 Reserved1,
						const void *Reserved2,
						uint32 Reserved3,
						const void *Reserved4 );
typedef BioAPI_RETURN (BioAPI *BioAPI_Terminate_ptr)(
						void );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleLoad_ptr)(
						cons

						uint32 Reserved,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleUnload_ptr)(
						const BioAPI_UUID *ModuleGuid,
						BioAPI_ModuleEventHandler AppNotifyCallback,
						void *AppNotifyCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleAttach_ptr)(
						const BioAPI_UUID *ModuleGuid,
						const BioAPI_VERSION *Version,
						const BioAPI_MEMORY_FUNCS *MemoryFuncs,
						uint32 DeviceID,
						uint32 Reserved1,
						uint32 Reserved2,
						uint32 Reserved3,
						BioAPI_FUNC_NAME_ADDR *FunctionTable,
						uint32 NumFunctionTable,
						const void *Reserved4,
						BioAPI_HANDLE_PTR NewModuleHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_ModuleDetach_ptr)(
						BioAPI_HANDLE ModuleHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_QueryDevice_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_SERVICE_UID_PTR ServiceUID );
/**************************************************************

/*** BioAPI Service Provider APIs ***************************************/
/************************************************************************/
typedef BioAPI_RETURN (BioAPI *BioAPI_FreeBIRHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_GetBIRFromHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_PTR *BIR );
typedef BioAPI_RETURN (BioAPI *BioAPI_GetHeaderFromHandle_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_HANDLE BIRHandle,
						BioAPI_BIR_HEADER_PTR Header );
typedef BioAPI_RETURN (BioAPI *BioAPI_EnableEvents_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_MODULE_EVENT_MASK *Events );
typedef BioAPI_RETURN (BioAPI *BioAPI_SetGUICallbacks_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_GUI_STREAMING_CALLBACK GuiStreamingCallback,
						void *GuiStreamingCallbackCtx,
						BioAPI_GUI_STATE_CALLBACK GuiStateCallback,
						void *GuiSta

typedef BioAPI_RETURN (BioAPI *BioAPI_SetStreamCallback_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_STREAM_CALLBACK StreamCallback,
						void *StreamCallbackCtx );
typedef BioAPI_RETURN (BioAPI *BioAPI_StreamInputOutput_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DATA_PTR InMessage,
						BioAPI_DATA_PTR OutMessage );
typedef BioAPI_RETURN (BioAPI *BioAPI_Capture_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR CapturedBIR,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_CreateTemplate_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload );
typedef BioAPI_RETURN (BioAPI *BioAPI_Process_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *CapturedBIR,
						BioAPI_BIR_HANDLE_PTR ProcessedBIR );
type

						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE *AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload );
typedef BioAPI_RETURN (BioAPI *BioAPI_IdentifyMatch_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,
						uint32 MaxNumberOfResults,
						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout );
typedef BioAPI_RETURN (BioAPI *BioAPI_Enroll_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_BIR_PURPOSE Purpos

						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR NewTemplate,
						const BioAPI_DATA *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Verify_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *StoredTemplate,
						BioAPI_BIR_HANDLE_PTR AdaptedBIR,
						BioAPI_BOOL *Result,
						BioAPI_FAR_PTR FARAchieved,
						BioAPI_FRR_PTR FRRAchieved,
						BioAPI_DATA_PTR *Payload,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Identify_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_FAR *MaxFARRequested,
						const BioAPI_FRR *MaxFRRRequested,
						const BioAPI_BOOL *FARPrecedence,
						const BioAPI_INPUT_BIR *ProcessedBIR,
						const BioAPI_IDENTIFY_POPULATION *Population,
						BioAPI_BOOL Binning,


						uint32 *NumberOfResults,
						BioAPI_CANDIDATE_ARRAY_PTR *Candidates,
						sint32 Timeout,
						BioAPI_BIR_HANDLE_PTR AuditData );
typedef BioAPI_RETURN (BioAPI *BioAPI_Import_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_DATA *InputData,
						BioAPI_BIR_BIOMETRIC_DATA_FORMAT InputFormat,
						BioAPI_BIR_PURPOSE Purpose,
						BioAPI_BIR_HANDLE_PTR ConstructedBIR );
typedef BioAPI_RETURN (BioAPI *BioAPI_SetPowerMode_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_POWER_MODE PowerMode );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbOpen_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_DB_ACCESS_TYPE AccessRequest,
						BioAPI_DB_HANDLE_PTR DbHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbClose_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbCreate_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName,
						BioAPI_D

						BioAPI_DB_HANDLE_PTR DbHandle );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbDelete_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const uint8 *DbName );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbSetCursor_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbFreeCursor_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbStoreBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						const BioAPI_INPUT_BIR *BIRToStore,
						BioAPI_DB_HANDLE DbHandle,
						BioAPI_UUID_PTR Uuid );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbGetBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
						BioAPI_DB_HANDLE DbHandle,
						const BioAPI_UUID *KeyValue,
						BioAPI_BIR_HANDLE_PTR RetrievedBIR,
						BioAPI_DB_CURSOR_PTR Cursor );
typedef BioAPI_RETURN (BioAPI *BioAPI_DbGetNextBIR_ptr)(
						BioAPI_HANDLE ModuleHandle,
		
/**
 *	The creation and deletion of chunks is handled with a pair of functions
 *	in the WorldEditor module, rather than with a functor.
 *	There are also utility methods to back these functions up.
 *
 *	@see ChunkItemPlacer
 */
class ChunkPlacer
	typedef ChunkPlacer This;
public:
	PY_MODULE_STATIC_METHOD_DECLARE( py_createChunk )
	PY_MODULE_STATIC_METHOD_DECLARE( py_recreateChunks )
	PY_MODULE_STATIC_METHOD_DECLARE( py_cloneAndAutoSnap )
	PY_MODULE_STATIC_METHOD_DECLARE( py_createInsideChunkName )
	PY_MODULE_STATIC_METHOD_DECLARE( py_chunkDataSection )
	PY_MODULE_STATIC_METHOD_DECLARE( py_createInsideChunkDataSection )
	PY_MODULE_STATIC_METHOD_DECLARE( py_cloneChunkDataSection )
	PY_MODULE_STATIC_METHOD_DECLARE( py_saveChunkTemplate )
	PY_MODULE_STATIC_METHOD_DECLARE( py_saveChunkPrefab )
	PY_MODULE_STATIC_METHOD_DECLARE( py_loadChunkPrefab )
	static DataSectionPtr utilCreateInsideChunkDataSection( Chunk * pNearbyChunk, std::string& retNewChunkName );
	static std::string utilCreateIn
CPPTEST_CONTEXT("core.message.test.cpptest.TA_Message_CppTest/core.message.test.cpptest/generic_common/ConnectionThread.cpp");
CPPTEST_TEST_SUITE_INCLUDED_TO("core.message.test.cpptest.TA_Message_CppTest/core.message.test.cpptest/generic_common/ConnectionThread.cpp");
class TestSuite_x7eChannelLocatorConnection_b993fb4a : public CppTest_TestSuite
    public:
        CPPTEST_TEST_SUITE(TestSuite_x7eChannelLocatorConnection_b993fb4a);
        CPPTEST_TEST(test_x7eChannelLocatorConnection_1);
        CPPTEST_TEST_SUITE_END();
        void setUp();
        void tearDown();
        void test_x7eChannelLocatorConnection_1();
};
CPPTEST_TEST_SUITE_REGISTRATION(TestSuite_x7eChannelLocatorConnection_b993fb4a);
void TestSuite_x7eChannelLocatorConnection_b993fb4a::setUp()
    FUNCTION_ENTRY( "setUp" );
    FUNCTION_EXIT;
void TestSuite_x7eChannelLocatorConnection_b993fb4a::tearDown()
    FUNCTION_ENTRY( "tearDown" );
    FUNCTION_EXIT;
/* CPPTEST_TEST_CASE_BEGIN test_x7eChannelLocatorConnection_1
extern const ::CORBA::TypeCode_ptr _tc_ServantLocator;
class ServantLocator : public virtual PortableServer::ServantManager
	public:
		typedef ServantLocator_ptr _ptr_type;
		typedef ServantLocator_var _var_type;
	protected:
		ServantLocator() {};
		virtual ~ServantLocator() {};
	private:		
		void operator= (ServantLocator_ptr obj) {};
		static PortableServer::ServantLocator_ptr _narrow(const ::CORBA::Object_ptr obj) ;
		static PortableServer::ServantLocator_ptr _unchecked_narrow(const ::CORBA::Object_ptr obj) ;
		static PortableServer::ServantLocator_ptr _duplicate(PortableServer::ServantLocator_ptr val);
		static PortableServer::ServantLocator_ptr _nil();
		
                typedef void* Cookie;
		virtual PortableServer::Servant preinvoke(const PortableServer::ObjectId& oid,
		                                          PortableServer::POA_ptr adapter,
		                                          const char* operation,
		                                          PortableServer::ServantL
int samplesAdded = 0;
int patchSamplesAdded = 0;
static unsigned short g_PatchIterationKey = 0;
bool SampleData_CompareFunc( SampleData_t const &src1, SampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int SampleData_KeyFunc( SampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<SampleData_t> g_SampleHashTable( SAMPLEHASH_NUM_BUCKETS, 
										  SAMPLEHASH_GROW_SIZE, 
										  SAMPLEHASH_INIT_SIZE, 
										  SampleData_CompareFunc, SampleData_KeyFunc );
UtlHashHandle_t SampleData_Find( sample_t *pSample )
	SampleData_t sampleData;	
	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	return g_SampleHashTable.Find( sampleData );
UtlHashHandle_t SampleData_InsertIntoHashTable( sample_t *pSample, SampleHandle_t sampleHandle )
	Samp

	sampleData.x = ( int )( pSample->pos.x / SAMPLEHASH_VOXEL_SIZE ) * 100;
	sampleData.y = ( int )( pSample->pos.y / SAMPLEHASH_VOXEL_SIZE ) * 10;
	sampleData.z = ( int )( pSample->pos.z / SAMPLEHASH_VOXEL_SIZE );
	UtlHashHandle_t handle = g_SampleHashTable.AllocEntryFromKey( sampleData );
	SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
	pSampleData->x = sampleData.x;
	pSampleData->y = sampleData.y;
	pSampleData->z = sampleData.z;
	pSampleData->m_Samples.AddToTail( sampleHandle );
	samplesAdded++;
	return handle;
UtlHashHandle_t SampleData_AddSample( sample_t *pSample, SampleHandle_t sampleHandle )
	UtlHashHandle_t handle = SampleData_Find( pSample );
	if( handle == g_SampleHashTable.InvalidHandle() )
	{
		handle = SampleData_InsertIntoHashTable( pSample, sampleHandle );
	}
	else
	{
		SampleData_t *pSampleData = &g_SampleHashTable.Element( handle );
		pSampleData->m_Samples.AddToTail( sampleHandle );
		samplesAdded++;
	}
	return handle;
void SampleData_Log( void )
	if

	{
		g_SampleHashTable.Log( "samplehash.txt" );
	}
bool PatchSampleData_CompareFunc( PatchSampleData_t const &src1, PatchSampleData_t const &src2 )
	return ( ( src1.x == src2.x ) &&
		     ( src1.y == src2.y ) &&
			 ( src1.z == src2.z ) );
unsigned int PatchSampleData_KeyFunc( PatchSampleData_t const &src )
	return ( src.x + src.y + src.z );
CUtlHash<PatchSampleData_t>	g_PatchSampleHashTable( SAMPLEHASH_NUM_BUCKETS,
												    SAMPLEHASH_GROW_SIZE,
													SAMPLEHASH_INIT_SIZE,
													PatchSampleData_CompareFunc, PatchSampleData_KeyFunc );
void GetPatchSampleHashXYZ( const Vector &vOrigin, int &x, int &y, int &z )
	x = ( int )( vOrigin.x / SAMPLEHASH_VOXEL_SIZE );
	y = ( int )( vOrigin.y / SAMPLEHASH_VOXEL_SIZE );
	z = ( int )( vOrigin.z / SAMPLEHASH_VOXEL_SIZE );
unsigned short IncrementPatchIterationKey()
	if ( g_PatchIterationKey == 0xFFFF )
	{
		g_PatchIterationKey = 1;
		for ( int i=0; i < g_Patches.Count(); i++ )
			g_Patches[i].m_IterationKey = 0;
	}
	else
	{
	

	}
	return g_PatchIterationKey;
void PatchSampleData_AddSample( CPatch *pPatch, int ndxPatch )
	int patchSampleMins[3], patchSampleMaxs[3];
	GetPatchSampleHashXYZ( pPatch->mins, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	GetPatchSampleHashXYZ( pPatch->maxs, patchSampleMaxs[0], patchSampleMaxs[1], patchSampleMaxs[2] );
	GetPatchSampleHashXYZ( pPatch->origin, patchSampleMins[0], patchSampleMins[1], patchSampleMins[2] );
	memcpy( patchSampleMaxs, patchSampleMins, sizeof( patchSampleMaxs ) );
	Assert( patchSampleMins[0] <= patchSampleMaxs[0] && patchSampleMins[1] <= patchSampleMaxs[1] && patchSampleMins[2] <= patchSampleMaxs[2] );
	patchSampleMins[0] = min( patchSampleMins[0], patchSampleMaxs[0] );
	patchSampleMins[1] = min( patchSampleMins[1], patchSampleMaxs[1] );
	patchSampleMins[2] = min( patchSampleMins[2], patchSampleMaxs[2] );
	int iterateCoords[3];
	for ( iterateCoords[0]=patchSampleMins[0]; iterateCoords[0] <= patchSampleMaxs[0]; iterateCoords[0]++ )
	{
		for 
Map::Map() :
	Height(18), Width(32) {
Map::~Map() {
void Map::SetUp(int seed) {
	Chunk* tempChunk = new Chunk(0,32,18,true);
	tempChunk->GenerateData(seed);
	Chunks.push_back(tempChunk);
	CurrentChunk = tempChunk;
	Chunk* tempChunk2 = new Chunk(-1, 32, 18, true);
	tempChunk2->GenerateData(seed);
	Chunks.push_back(tempChunk2);
	FirstChunk = tempChunk2;
	Chunk* tempChunk3 = new Chunk(1, 32, 18, true);
	tempChunk3->GenerateData(seed);
	Chunks.push_back(tempChunk3);
	LastChunk = tempChunk3;
void Map::CheckPosition(int position, Player* player, int seed) {
	if ((player->xPos + player->Position*15.5f) >= (15.5f*(player->Position+1))) {
		player->Position += 1;
		Chunk* temp = CurrentChunk;
		CurrentChunk = LastChunk;
		FirstChunk = temp;
		LastChunk = new Chunk(1, 32, 18, true);
		LastChunk->GenerateData(seed);
		Chunks.push_back(LastChunk);
	}
	else if ((player->xPos + player->Position*15.5f) <= (15.5f*(player->Position))) {
		player->Position -= 1;
		
		Chunk* temp = CurrentChunk;
		Curren
HttpConnectionHandlerPool::HttpConnectionHandlerPool(QSettings* settings, HttpRequestHandler* requestHandler)
    : QObject()
    Q_ASSERT(settings!=0);
    this->settings=settings;
    this->requestHandler=requestHandler;
    cleanupTimer.start(settings->value("cleanupInterval",10000).toInt());
    connect(&cleanupTimer, SIGNAL(timeout()), SLOT(cleanup()));
HttpConnectionHandlerPool::~HttpConnectionHandlerPool() {    
    foreach(HttpConnectionHandler* handler, pool) {
        connect(handler,SIGNAL(finished()),handler,SLOT(deleteLater()));
        handler->quit();
    }
HttpConnectionHandler* HttpConnectionHandlerPool::getConnectionHandler() {   
    HttpConnectionHandler* freeHandler=0;
    mutex.lock();
    foreach(HttpConnectionHandler* handler, pool) {
        if (!handler->isBusy()) {
            freeHandler=handler;
            freeHandler->setBusy();
            break;
        }
    }
    if (!freeHandler) {
        int maxConnectionHandlers=settings->value("maxThreads",1000).
struct VirtActionInvoker0
	typedef void (*Action)(void*, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename R>
struct VirtFuncInvoker0
	typedef R (*Func)(void*, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, invokeData.method);
	}
};
template <typename T1>
struct VirtActionInvoker1
	typedef void (*Action)(void*, T1, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename R, typename

struct VirtFuncInvoker1
	typedef R (*Func)(void*, T1, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);
	}
};
template <typename T1, typename T2>
struct VirtActionInvoker2
	typedef void (*Action)(void*, T1, T2, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, invokeData.method);
	}
};
template <typename R, typename T1, typename T2>
struct VirtFuncInvoker2
	typedef R (*Func)(void*, T1, T2, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((F

	}
};
template <typename T1, typename T2, typename T3>
struct VirtActionInvoker3
	typedef void (*Action)(void*, T1, T2, T3, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3>
struct VirtFuncInvoker3
	typedef R (*Func)(void*, T1, T2, T3, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4>
struct VirtActionInvoker4
	typedef void (*Action)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline void Invoke (Il2Cp

	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct VirtFuncInvoker4
	typedef R (*Func)(void*, T1, T2, T3, T4, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtActionInvoker5
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)i

	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct VirtFuncInvoker5
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct VirtActionInvoker6
	typedef void (*Action)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline void Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		((Action)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, 

struct VirtFuncInvoker6
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct VirtFuncInvoker7
	typedef R (*Func)(void*, T1, T2, T3, T4, T5, T6, T7, const MethodInfo*);
	static inline R Invoke (Il2CppMethodSlot slot, void* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)
	{
		VirtualInvokeData invokeData;
		il2cpp_codegen_get_virtual_invoke_data (slot, obj, &invokeData);
		return ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, p6, p7, invokeData.method);
	}
};
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, type
namespace xscript {
class FileBlock;
typedef XmlDocSharedHelper (FileBlock::*Method)(const std::string&,
        boost::shared_ptr<Context>, boost::shared_ptr<InvokeContext>) const;
/**
 * x:file block. Loading local files with <s>jackpot and hookers</s> with
 *
 * Support two methods:
 *    1. load - loading file
 *
 * Both methods support tagging based on file modification time.
 */
class FileBlock : public ThreadedBlock, public TaggedBlock {
public:
    FileBlock(const Extension *ext, Xml *owner, xmlNodePtr node);
    virtual ~FileBlock();
    std::string createTagKey(const Context *ctx, const InvokeContext *invoke_ctx) const;
    virtual bool allowDistributed() const;
private:
    virtual void postParse();
    virtual void call(boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) const throw (std::exception);
    XmlDocSharedHelper loadFile(const std::string &file_name,
            boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) 

    XmlDocSharedHelper loadJson(const std::string &file_name,
            boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) const;
    XmlDocSharedHelper loadText(const std::string &file_name,
            boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) const;
    XmlDocSharedHelper loadBinary(const std::string &file_name,
            boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) const;
    
    XmlDocSharedHelper invokeFile(const std::string &file_name,
            boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) const;
    
    XmlDocSharedHelper invokeMethod(const std::string &file_name,
            boost::shared_ptr<Context> ctx, boost::shared_ptr<InvokeContext> invoke_ctx) const;
    
    std::string fileName(InvokeContext *invoke_ctx) const;
    
    virtual void property(const char *name, const char *value);
    
    bool isTest() const;
    bool isInvoke() const;
p
namespace frozenbyte {
namespace filesystem {
class IOutputStreamBuffer
public:
	virtual ~IOutputStreamBuffer() {}
	virtual void putByte(unsigned char byte) = 0;
};
class OutputStream
	boost::shared_ptr<IOutputStreamBuffer> streamBuffer;
	bool textStrings;
public:
	OutputStream();
	~OutputStream();
	void setBuffer(boost::shared_ptr<IOutputStreamBuffer> streamBuffer);
private:
	OutputStream &write(const std::string &value);
	OutputStream &write(bool value);
	OutputStream &write(unsigned char value);
	OutputStream &write(signed char value);
	OutputStream &write(unsigned short value);
	OutputStream &write(signed short value);
	OutputStream &write(unsigned int value);
	OutputStream &write(signed int value);
	OutputStream &write(float value);
	OutputStream &write(double value);
	friend OutputStream &operator << (OutputStream &, const std::string &);
	friend OutputStream &operator << (OutputStream &, bool);
	friend OutputStream &operator << (OutputStream &, unsigned char);
	friend OutputStre

	friend OutputStream &operator << (OutputStream &, unsigned short);
	friend OutputStream &operator << (OutputStream &, signed short);
	friend OutputStream &operator << (OutputStream &, unsigned int);
	friend OutputStream &operator << (OutputStream &, signed int);
	friend OutputStream &operator << (OutputStream &, float);
	friend OutputStream &operator << (OutputStream &, double);
};
inline OutputStream &operator << (OutputStream &stream, const std::string &value) { return stream.write(value); }
inline OutputStream &operator << (OutputStream &stream, bool value) { return stream.write(value);  }
inline OutputStream &operator << (OutputStream &stream, unsigned char value) { return stream.write(value); }
inline OutputStream &operator << (OutputStream &stream, signed char value) { return stream.write(value); }
inline OutputStream &operator << (OutputStream &stream, unsigned short value) { return stream.write(value); }
inline OutputStream &operator << (OutputStream &stream, signed short val
namespace GAME
namespace XME
template <typename T>
GAME_INLINE
Auto_Model_T <T>::Auto_Model_T (void)
template <typename T>
GAME_INLINE
Auto_Model_T <T>::Auto_Model_T (T model)
: model_ (model)
  this->model_.children (this->purge_set_);
template <typename T>
GAME_INLINE
Auto_Model_T <T>::
Auto_Model_T (T model, const collection_type & purge_set)
: model_ (model),
  purge_set_ (purge_set)
template <typename T>
GAME_INLINE
Auto_Model_T <T>::
Auto_Model_T (T model, iterator begin, iterator end)
: model_ (model),
  purge_set_ (begin, end)
template <typename T>
GAME_INLINE
Auto_Model_T <T>::~Auto_Model_T (void)
  this->purge_models ();
template <typename T>
GAME_INLINE
T & Auto_Model_T <T>::get (void)
  return this->model_;
template <typename T>
GAME_INLINE
T * Auto_Model_T <T>::operator -> (void)
  return &this->model_;
template <typename T>
GAME_INLINE
const typename Auto_Model_T <T>::collection_type &
Auto_Model_T <T>::children (void) const
  return this->children_;
template <typename T>
/*
 * File automatically generated by
 * gengen 1.4.2 by Lorenzo Bettini 
 */
void
generic_option_gen_class::generate_generic_option(ostream &stream, unsigned int indent)
  string indent_str (indent, ' ');
  indent = 0;
  if (has_short_option)
    {
      stream << "case '";
      generate_string (short_option, stream, indent + indent_str.length ());
      stream << "':	/* ";
      generate_string (option_comment, stream, indent + indent_str.length ());
      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      if (( short_option == "?" ))
        {
          stream << "\n";
          stream << indent_str;
          stream << "  if (optopt) /* '?' represents an unrecognized option */";
          stream << "\n";
          stream << indent_str;
          stream << "    goto failure;";
          stream << "\n";
          stream << indent_str;
        }
    }
  else
    {
      stream << "/* ";
      generate_string (option_comment, stream, indent + indent_str.length 

      stream << ".  */";
      stream << "\n";
      stream << indent_str;
      generate_string (gen_else, stream, indent + indent_str.length ());
      stream << "if (strcmp (long_options[option_index].name, \"";
      generate_string (long_option, stream, indent + indent_str.length ());
      stream << "\") == 0)";
      stream << "\n";
      stream << indent_str;
      stream << "{";
      stream << "\n";
      stream << indent_str;
    }
  if (option_has_mode)
    {
      stream << "  args_info->";
      generate_string (group_var_name, stream, indent + indent_str.length ());
      stream << "_mode_counter += 1;";
      stream << "\n";
      stream << indent_str;
    }
  stream << "\n";
  stream << indent_str;
  if (multiple)
    {
      if (option_has_type)
        {
          stream << "  if (update_multiple_arg_temp(&";
          generate_string (structure, stream, indent + indent_str.length ());
          stream << ", ";
          stream << "\n";
          stream << indent_st

          stream << "      &(local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given), optarg, ";
          generate_string (possible_values, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (arg_type, stream, indent + indent_str.length ());
          stream << ",";
          stream << "\n";
          stream << indent_str;
          stream << "      \"";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << "\", '";
          generate_string (short_option, stream, indent + indent_str.length ());
          stream << "',";
          stream << "\n";
          stream << indent_str;
          stream << "      additional_error))";
          stream << "\n";
          stream << indent_str;
          stream << "    goto failur

          stream << "\n";
          stream << indent_str;
        }
      else
        {
          stream << "  local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given++;";
          stream << "\n";
          stream << indent_str;
        }
      if (option_has_group)
        {
          stream << "  if (!args_info->";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_group)";
          stream << "\n";
          stream << indent_str;
          stream << "    {";
          stream << "\n";
          stream << indent_str;
          stream << "      args_info->";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_group = 1;";
          stream << "\n";
          stream << indent_str;
          stream << "      args_info->";
          generate_string (group_var_name, stream, indent + indent_str.length ());
 

          stream << "\n";
          stream << indent_str;
          stream << "    }";
          stream << "\n";
          stream << indent_str;
        }
    }
  else
    {
      if (option_has_group)
        {
          stream << "  if (args_info->";
          generate_string (group_var_name, stream, indent + indent_str.length ());
          stream << "_group_counter && override)";
          stream << "\n";
          stream << indent_str;
          stream << "    reset_group_";
          generate_string (group_var_name, stream, indent + indent_str.length ());
          stream << " (args_info);";
          stream << "\n";
          stream << indent_str;
          stream << "  args_info->";
          generate_string (group_var_name, stream, indent + indent_str.length ());
          stream << "_group_counter += 1;";
          stream << "\n";
          stream << indent_str;
        }
      stream << "\n";
      stream << indent_str;
      if (( arg_type == "ARG_FLAG" ))
        {
      

          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_flag), 0, &(args_info->";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given),";
          stream << "\n";
          stream << indent_str;
          stream << "      &(local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given), optarg, 0, 0, ";
          generate_string (arg_type, stream, indent + indent_str.length ());
          stream << ",";
          stream << "\n";
          stream << indent_str;
          stream << "      check_ambiguity, override, 1, 0, \"";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << "\", '";
          generate_string (short_option, stream, indent + indent_str.length ());
          stream << "',";
          stream << "\n";
          stream << indent_str;
          strea

          stream << "\n";
          stream << indent_str;
          stream << "    goto failure;";
          stream << "\n";
          stream << indent_str;
        }
      else
        {
          stream << "  if (update_arg(";
          if (( arg_type == "ARG_NO" ))
            {
              stream << " 0 ";
            }
          else
            {
              stream << " (void *)&(args_info->";
              generate_string (option_var_name, stream, indent + indent_str.length ());
              stream << "_arg)";
            }
          stream << ", ";
          stream << "\n";
          stream << indent_str;
          indent = 6;
          stream << "      ";
          if (( arg_type == "ARG_NO" ))
            {
              stream << " 0 ";
            }
          else
            {
              stream << " &(args_info->";
              generate_string (option_var_name, stream, indent + indent_str.length ());
              stream << "_orig)";
            }
          strea

          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given),";
          indent = 0;
          stream << "\n";
          stream << indent_str;
          stream << "      &(local_args_info.";
          generate_string (option_var_name, stream, indent + indent_str.length ());
          stream << "_given), optarg, ";
          generate_string (possible_values, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (default_value, stream, indent + indent_str.length ());
          stream << ", ";
          generate_string (arg_type, stream, indent + indent_str.length ());
          stream << ",";
          stream << "\n";
          stream << indent_str;
          stream << "      check_ambiguity, override, 0, 0,";
          stream << "\n";
          stream << indent_str;
          stream << "      \"";
          generate_string (long_option, stream, indent + indent_str.length ());
          stream << 
core::core()
    mcu=new memory_controller;
    pc=0;
    sp=0;
core::~core()
    delete mcu;
void core::execute_opcode()
    opcode=mcu->load(pc);
    switch(opcode){
            registers[0]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[1]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[2]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[3]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[4]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[5]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[6]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[7]=mcu->load(pc+1);
            pc+=2;
            break;
            registers[0]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
            registers[1]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
          

            pc+=2;
            break;
            registers[3]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
            registers[4]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
            registers[0]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
            registers[0]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
            registers[0]=mcu->load(mcu->load(pc+1));
            pc+=2;
            break;
            registers[mcu->load(pc+1)]+=mcu->load(mcu->load(pc+2));
            pc+=3;
            break;
            registers[mcu->load(pc+1)]-=mcu->load(mcu->load(pc+2));
            pc+=3;
            break;
            registers[mcu->load(pc+1)]/=mcu->load(mcu->load(pc+2));
            pc+=3;
            break;
            registers[mcu->load(pc+1)]*=mcu->load(mcu->load(pc+2));
            pc+=3;
            break;
            registers[mcu->load(pc+1)]=mcu->load(mcu->load(pc+2));
            pc+
namespace PeripheralLayer
	class Peripherals;
namespace ApplicationLayer
	class ModelCollection
	{
	public:
		ModelCollection(PeripheralLayer::Peripherals& peripherals);
		const Models::RepresentableModel& GetSpeedModel() const;
		const Models::RepresentableModel& GetRPMModel() const;
		const Models::RepresentableModel& GetGearModel() const;
		const Models::TripComputerModel& GetTripComputerModel() const;
		const Models::RepresentableModel& GetParkDistanceModel() const;
		const Models::TirePressureModel& GetTirePressureModel() const;
		const Models::RepresentableModel& GetBatteryVoltageModel() const;
		const Models::Model& GetXAccelerationModel() const;
		const Models::Model& GetYAccelerationModel() const;
		const Models::Model& GetZAccelerationModel() const;
		const Models::RepresentableModel& GetPitchModel() const;
		const Models::RepresentableModel& GetRollModel() const;
		Common::List<Models::Model>& GetModels();
	private:
		Models::WheelTickModel m_WheelTickModel;
		Models::Inject
/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
**
** This file is part of Qt Creator.
**
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
**
****************

namespace Debugger {
namespace Internal {
QDataStream &operator<<(QDataStream &stream, const ThreadData &d)
    stream << (qint64)d.id;
    stream << d.address;
    stream << d.function;
    stream << d.fileName;
    stream << d.state;
    stream << d.lineNumber;
    stream << d.name;
    return stream;
QDataStream &operator>>(QDataStream &stream, ThreadData &d)
    qint64 id;
    stream >> id;
    d.id = id;
    stream >> d.address;
    stream >> d.function;
    stream >> d.fileName;
    stream >> d.state;
    stream >> d.lineNumber;
    stream >> d.name;
    return stream;
QDataStream &operator<<(QDataStream &stream, const Threads &threads)
    stream << (quint64)threads.count();
    for (int i = 0; i < threads.count(); i++)
    {
        const ThreadData &d = threads.at(i);
        stream << d;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, Threads &threads)
    quint64 count;
    stream >> count;
    threads.clear();
    for (quint64 i = 0; i < count; ++i)
 

        ThreadData d;
        stream >> d;
        threads.append(d);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrame &s)
    stream << (quint64)s.level;
    stream << s.function;
    stream << s.file;
    stream << s.from;
    stream << s.to;
    stream << s.line;
    stream << s.address;
    stream << s.usable;
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrame &s)
    quint64 level;
    stream >> level;
    s.level = level;
    stream >> s.function;
    stream >> s.file;
    stream >> s.from;
    stream >> s.to;
    stream >> s.line;
    stream >> s.address;
    stream >> s.usable;
    return stream;
QDataStream &operator<<(QDataStream &stream, const StackFrames &frames)
    stream << (quint64)frames.count();
    for (int i = 0; i < frames.count(); i++)
    {
        const StackFrame &s = frames.at(i);
        stream << s;
    }
    return stream;
QDataStream &operator>>(QDataStream &stream, StackFrames &frames)
    qui

    stream >> count;
    frames.clear();
    for (quint64 i = 0; i < count; ++i)
    {
        StackFrame s;
        stream >> s;
        frames.append(s);
    }
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointResponse &s)
    stream << s.id.majorPart();
    stream << s.condition;
    stream << s.ignoreCount;
    stream << s.fileName;
    stream << s.lineNumber;
    stream << s.threadSpec;
    stream << s.functionName;
    stream << s.address;
    stream << s.hitCount;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointResponse &s)
    int majorPart;
    stream >> majorPart;
    s.id = BreakpointResponseId(majorPart);
    stream >> s.condition;
    stream >> s.ignoreCount;
    stream >> s.fileName;
    stream >> s.lineNumber;
    stream >> s.threadSpec;
    stream >> s.functionName;
    stream >> s.address;
    stream >> s.hitCount;
    return stream;
QDataStream &operator<<(QDataStream &stream, const BreakpointParameters &s)
    

    stream << s.condition;
    stream << quint64(s.ignoreCount);
    stream << quint64(s.lineNumber);
    stream << quint64(s.address);
    stream << s.functionName;
    stream << int(s.pathUsage);
    stream << s.tracepoint;
    stream << s.module;
    stream << s.command;
    stream << s.message;
    return stream;
QDataStream &operator>>(QDataStream &stream, BreakpointParameters &s)
    quint64 t;
    QString str;
    QByteArray ba;
    bool b;
    stream >> str; s.fileName = str;
    stream >> ba; s.condition = ba;
    stream >> t; s.ignoreCount = t;
    stream >> t; s.lineNumber = t;
    stream >> t; s.address = t;
    stream >> str; s.functionName = str;
    stream >> t; s.pathUsage = static_cast<BreakpointPathUsage>(t);
    stream >> b; s.tracepoint = b;
    stream >> str ; s.module = str;
    stream >> str ; s.command = str;
    stream >> str ; s.message = str;
    return stream;
QDataStream &operator<<(QDataStream &stream, const WatchData &wd)
    stream << wd.id;
    stream 

    stream << wd.exp;
    stream << wd.name;
    stream << wd.value;
    stream << wd.editvalue;
    stream << wd.editformat;
    stream << wd.valuetooltip;
    stream << wd.typeFormats;
    stream << wd.type;
    stream << wd.displayedType;
    stream << wd.variable;
    stream << wd.address;
    stream << wd.size;
    stream << wd.hasChildren;
    stream << wd.valueEnabled;
    stream << wd.valueEditable;
    stream << wd.error;
    stream << wd.state;
    return stream;
QDataStream &operator>>(QDataStream &stream, WatchData &wd)
    stream >> wd.id;
    stream >> wd.iname;
    stream >> wd.exp;
    stream >> wd.name;
    stream >> wd.value;
    stream >> wd.editvalue;
    stream >> wd.editformat;
    stream >> wd.valuetooltip;
    stream >> wd.typeFormats;
    stream >> wd.type;
    stream >> wd.displayedType;
    stream >> wd.variable;
    stream >> wd.address;
    stream >> wd.size;
    stream >> wd.hasChildren;
    stream >> wd.valueEnabled;
    stream >> wd.valueEditable;
    s
/*=========================================================================
  Library   : Image Registration Toolkit (IRTK)
  Module    : $Id$
  Copyright : Imperial College, Department of Computing
              Visual Information Processing (VIP), 2008 onwards
  Date      : $Date$
  Version   : $Revision$
  Changes   : $Author$
Copyright (c) IXICO LIMITED
All rights reserved.
See COPYRIGHT for details
=========================================================================*/
class irtkLocator : public irtkObject
protected:
  vtkCellLocator *cell_locator;
  vtkPointLocator *point_locator;
  vtkKDTreePointLocator *kd_locator;
  vtkKDTreePointLocator *kd_locator;
  vtkGenericCell *cell;
  int cellId;
  int subId;
  double dist2;
  double closestPoint[3];
  int loc_type;
  vtkPolyData *_dataset;
  int temp_id;
public:
  irtkLocator(void);
  void SetElementsPerBucket(int);
  void SelectLocatorType(int type);
  int GetLocatorType();
  void SetDataSet(vtkPolyData *);
  int FindClosestPoint
namespace model {
NullModelNode::NullModelNode() :
	_nullModel(new NullModel)
{}
NullModelNode::NullModelNode(const NullModelPtr& nullModel) :
	_nullModel(nullModel)
{}
std::string NullModelNode::name() const
	return "nullmodel";
scene::INode::Type NullModelNode::getNodeType() const
	return Type::Model;
NullModelNodePtr NullModelNode::InstancePtr()
	static NullModelNodePtr _nullModelNode;
	if (_nullModelNode == NULL) {
		_nullModelNode = NullModelNodePtr(new NullModelNode);
	}
	return _nullModelNode;
const IModel& NullModelNode::getIModel() const
	return *_nullModel;
IModel& NullModelNode::getIModel()
	return *_nullModel;
void NullModelNode::testSelect(Selector& selector, SelectionTest& test) {
	_nullModel->testSelect(selector, test, localToWorld());
void NullModelNode::renderSolid(RenderableCollector& collector, const VolumeTest& volume) const {
	_nullModel->renderSolid(collector, volume, localToWorld());
void NullModelNode::renderWireframe(RenderableCollector& collector, const Volume
namespace terrain {
	/**
	 * This class will load data related to a particular chunk, or serve it from
	 * memory if it has been cached. It will also invoke the terrain generator if
	 * the chunk hasn't be generated yet. This class will most likely run on
	 * the server-side.
	 */
	class ChunkLoader {
	public:
		using ChunkCache = std::unordered_map<ChunkOffsetVector, ChunkDataPtr>;
	private:
		ChunkCache LoadedChunkCache;
		TerrainGeneratorParameters TerrainGenParams;
		BiomeRegionLoaderPtr BRLoader;
		bool IsChunkGenerated(const ChunkOffsetVector & offset) const;
		
		/**
		 * @return Null pointer if the chunk has not yet been generated, otherwise
		 *         retrieve the chunk from cache, or load the chunk from disk if it
		 *         hasn't been cached yet.
		 */
		ChunkDataPtr GetGeneratedChunk(const ChunkOffsetVector & offset);
		ChunkDataPtr LoadChunkFromDisk(const ChunkOffsetVector & offset);
		ChunkDataPtr GenerateMissingChunk(const ChunkOffsetVector & offset);
		void SetDefa
audioSample::audioSample(){
	vol = 0;
	looping = true;
audioSample::~audioSample(){
void audioSample::setup(vector<float> _buf, int _nChannels){
    sample.load(_buf);
    
    outputChannels = _nChannels;
    amp.setup(outputChannels);
void audioSample::play(){
    sample.play();
void audioSample::stop(){
    sample.stop();
void audioSample::setVolume(float _vol){
	vol = _vol;
void audioSample::setLooping(bool _l){
	looping = _l;
    sample.setLooping(looping);
void audioSample::setPaused(bool _p){
	sample.setPaused(_p);
void audioSample::setPosition(float _p){
	sample.setPosition(_p);
void audioSample::setSpeed(float _s){
	sample.setSpeed(_s);
float audioSample::getPosition(){
	return sample.getPosition();
float audioSample::getSpeed(){
	return sample.getSpeed();
bool audioSample::getIsPlaying(){
	return sample.getIsPlaying();
void audioSample::drawWaveform(int x, int y, int w, int h){
    sample.drawWaveForm(x,y,w,h);
void audioSample::drawHead(int x, int y, int w, int h){
    sampl
/* This file is part of Zanshin Todo.
   Copyright 2008-2010 Kevin Ottens <ervin@kde.org>
   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License or (at your option) version 3 or any later version
   accepted by the membership of KDE e.V. (or its successor approved
   by the membership of KDE e.V.), which shall act as a proxy
   defined in Section 14 of version 3 of the license.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
   USA.


class QItemSelectionModel;
class QAbstractItemModel;
class ModelStack : public QObject
    Q_OBJECT
public:
    explicit ModelStack(QObject *parent = 0);
    QAbstractItemModel *pimitemModel();
    QAbstractItemModel *baseModel();
    QAbstractItemModel *collectionsModel();
    QAbstractItemModel *treeModel();
    QAbstractItemModel *treeSideBarModel();
    QItemSelectionModel *treeSelection();
    QAbstractItemModel *treeSelectionModel();
    QAbstractItemModel *treeComboModel();
    QAbstractItemModel *contextsModel();
    QAbstractItemModel *contextsSideBarModel();
    QItemSelectionModel *contextsSelection();
    QAbstractItemModel *contextsSelectionModel();
    QAbstractItemModel *contextsComboModel();
    
    QAbstractItemModel *knowledgeBaseModel();
    QAbstractItemModel *topicsTreeModel();
    QAbstractItemModel *knowledgeSideBarModel();
    QItemSelectionModel *knowledgeSelection();
    QAbstractItemModel *knowledgeCollectionsModel();
    
private:
    QAbstractItemModel *m
/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
namespace HPHP {
LitstrRepoProxy::LitstrRepoProxy(Repo& repo)
    : RepoProxy(repo)
    , m_insertLitstrLocal(repo, RepoIdLocal)
    , m_insertLitstrCentral(r

    , m_getLitstrsLocal(repo, RepoIdLocal)
    , m_getLitstrsCentral(repo, RepoIdCentral) {
  m_insertLitstr[RepoIdLocal] = &m_insertLitstrLocal;
  m_insertLitstr[RepoIdCentral] = &m_insertLitstrCentral;
  m_getLitstrs[RepoIdLocal] = &m_getLitstrsLocal;
  m_getLitstrs[RepoIdCentral] = &m_getLitstrsCentral;
void LitstrRepoProxy::createSchema(int repoId, RepoTxn& txn) {
  std::stringstream ssCreate;
  ssCreate << "CREATE TABLE " << m_repo.table(repoId, "Litstr")
           << "(litstrId INTEGER, litstr TEXT,"
              " PRIMARY KEY (litstrId));";
  txn.exec(ssCreate.str());
void LitstrRepoProxy::load() {
  for (int repoId = RepoIdCount - 1; repoId >= 0; --repoId) {
    if (!getLitstrs(repoId).get()) {
      break;
    }
  }
void LitstrRepoProxy::InsertLitstrStmt::insert(RepoTxn& txn,
                                               Id litstrId,
                                               const StringData* litstr) {
  if (!prepared()) {
    std::stringstream ssInsert;
    ssInsert 

