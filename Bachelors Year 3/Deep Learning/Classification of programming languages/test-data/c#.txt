namespace ECommon.Storage
    public class ChunkReader
    {
        private readonly ChunkManager _chunkManager;
        private readonly ChunkWriter _chunkWriter;
        public ChunkReader(ChunkManager chunkManager, ChunkWriter chunkWriter)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            Ensure.NotNull(chunkWriter, "chunkWriter");
            _chunkManager = chunkManager;
            _chunkWriter = chunkWriter;
        }
        public T TryReadAt<T>(long position, Func<byte[], T> readRecordFunc, bool autoCache = true) where T : class, ILogRecord
        {
            var lastChunk = _chunkWriter.CurrentChunk;
            var maxPosition = lastChunk.GlobalDataPosition;
            if (position >= maxPosition)
            {
                return null;
            }
            var chunkNum = _chunkManager.GetChunkNum(position);
            var chunk = _chunkManager.GetChunk(chunkNum);
            if (chunk == null)
            {
                throw 
namespace DENTALMIS.BLL.Manager.ClinicSectionManager
  public  class ClinicInstrumentManager :IClinicInstrumentManager
  {
      private IClinicInstrumentRepository _clinicInstrumentRepository= null;
      public ClinicInstrumentManager(DENTALERPDbContext context)
      {
         _clinicInstrumentRepository=new ClinicInstrumentRepository(context);
      }
      public List<ClinicalInstrument> GetAllInstrumentByPaging(out int totalrecords, ClinicalInstrument model)
      {
          List<ClinicalInstrument> clinicalInstruments;
          try
          {
              clinicalInstruments = _clinicInstrumentRepository.GetAllInstrumentByPaging(out totalrecords, model);
          }
          catch (Exception exception)
          {
              throw new Exception(exception.Message);
          }
          return clinicalInstruments;
      }
      public ClinicalInstrument GetInstrumentById(int id)
      {
          ClinicalInstrument clinicalInstrument;
          try
          {
          

          }
          catch (Exception exception)
          {
              throw new Exception(exception.Message);
          }
         return clinicalInstrument;
      }
      public int Save(ClinicalInstrument clinicalInstrument)
      {
          int saveIndex = 0;
          try
          {
              clinicalInstrument.IsActive = true;
              saveIndex = _clinicInstrumentRepository.Save(clinicalInstrument);
          }
          catch (Exception exception)
          {
              throw new Exception(exception.Message);
          }
          return saveIndex;
      }
      public int Edit(ClinicalInstrument clinicalInstrument)
      {
          int editIndex = 0;
          try
          {
              ClinicalInstrument _clinicalInstrument = GetInstrumentById(clinicalInstrument.InstrumentId);
              _clinicalInstrument.InstrumentId = clinicalInstrument.InstrumentId;
              _clinicalInstrument.Name = clinicalInstrument.Name;
              _clinicalInstrum
namespace DataAccess.Repository
    public class UnitOfWork : IUnitOfWork
    {
        public DbContext Context{get;private set;}
        private IRepository<Authorization> authorizationRepository;
        private IUserRepository userRepository;
        private ITaskRepository taskRepository;
        private ITagRepository tagRepository;
        private IAnswerRepository answerRepository;
        private IPhotoRepository photoRepository;
        private IUserAnswerRepository userAnswerRepository;
        private ICommentRepository commentRepository;
        private IAchievementRepository achievementRepository;
        public UnitOfWork(DbContext context)
        {
            Context = context;
        }
        public IRepository<Authorization> AuthorizationRepository
        {
            get
            {
                if (authorizationRepository == null)
                    authorizationRepository = new AuthorizationRepository(Context);
                return authorizationReposi

            }
        }
        public ITaskRepository TaskRepository
        {
            get
            {
                if (taskRepository == null)
                    taskRepository = new TaskRepository(Context);
                return taskRepository;
            }
        }
        public IUserAnswerRepository UserAnswerRepository
        {
            get
            {
                if (userAnswerRepository == null)
                    userAnswerRepository = new UserAnswerRepository(Context);
                return userAnswerRepository;
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                if (userRepository == null)
                    userRepository = new UserRepository(Context);
                return userRepository;
            }
        }
        public IAchievementRepository AchievementRepository
        {
            get
            {
                if (achievementRepository == null)
           

                return achievementRepository;
            }
        }
        public ITagRepository TagRepository
        {
            get
            {
                if (tagRepository == null)
                    tagRepository = new TagRepository(Context);
                return tagRepository;
            }
        }
        public IAnswerRepository AnswerRepository
        {
            get
            {
                if (answerRepository == null)
                    answerRepository = new AnswerRepository(Context);
                return answerRepository;
            }
        }
        public IPhotoRepository PhotoRepository
        {
            get
            {
                if (photoRepository == null)
                    photoRepository = new PhotoRepository(Context);
                return photoRepository;
            }
        }
        public ICommentRepository CommentRepository 
        {
            get
            {
                if (commentRepository == null)

namespace MiNET.Utils
	public struct ChunkCoordinates : IEquatable<ChunkCoordinates>
	{
		public int X, Z;
		public ChunkCoordinates(int value)
		{
			X = Z = value;
		}
		public ChunkCoordinates(int x, int z)
		{
			X = x;
			Z = z;
		}
		public ChunkCoordinates(ChunkCoordinates v)
		{
			X = v.X;
			Z = v.Z;
		}
		public ChunkCoordinates(BlockCoordinates coordinates)
		{
			X = coordinates.X >> 4;
			Z = coordinates.Z >> 4;
		}
		public ChunkCoordinates(PlayerLocation location)
		{
			X = ((int) Math.Floor(location.X)) >> 4;
			Z = ((int) Math.Floor(location.Z)) >> 4;
		}
		public override string ToString()
		{
			return $"X: {X}, Z: {Z}";
		}
		#region Math
		public double DistanceTo(ChunkCoordinates other)
		{
			return Math.Sqrt(Square(other.X - X) +
			                 Square(other.Z - Z));
		}
		private int Square(int num)
		{
			return num*num;
		}
		public double Distance
		{
			get { return DistanceTo(Zero); }
		}
		public static ChunkCoordinates Min(ChunkCoordinates value1, 

		{
			return new ChunkCoordinates(
				Math.Min(value1.X, value2.X),
				Math.Min(value1.Z, value2.Z)
				);
		}
		public static ChunkCoordinates Max(ChunkCoordinates value1, ChunkCoordinates value2)
		{
			return new ChunkCoordinates(
				Math.Max(value1.X, value2.X),
				Math.Max(value1.Z, value2.Z)
				);
		}
		#endregion
		#region Operators
		public static bool operator !=(ChunkCoordinates a, ChunkCoordinates b)
		{
			return !a.Equals(b);
		}
		public static bool operator ==(ChunkCoordinates a, ChunkCoordinates b)
		{
			return a.Equals(b);
		}
		public static ChunkCoordinates operator +(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X + b.X, a.Z + b.Z);
		}
		public static ChunkCoordinates operator -(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X - b.X, a.Z - b.Z);
		}
		public static ChunkCoordinates operator -(ChunkCoordinates a)
		{
			return new ChunkCoordinates(
				-a.X,
				-a.Z);
		}
		public static ChunkCoor

		{
			return new ChunkCoordinates(a.X*b.X, a.Z*b.Z);
		}
		public static ChunkCoordinates operator /(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X/b.X, a.Z/b.Z);
		}
		public static ChunkCoordinates operator %(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X%b.X, a.Z%b.Z);
		}
		public static ChunkCoordinates operator +(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X + b, a.Z + b);
		}
		public static ChunkCoordinates operator -(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X - b, a.Z - b);
		}
		public static ChunkCoordinates operator *(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X*b, a.Z*b);
		}
		public static ChunkCoordinates operator /(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X/b, a.Z/b);
		}
		public static ChunkCoordinates operator %(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X%b, a.Z%b);
		}
		public static ChunkCoo
namespace Bussiness
    public class DispatchData
    {
        DBDispatch dbDispatch = new DBDispatch();
        public DataSet GetAllOrdersDetails()
        {
            return dbDispatch.GetAllOrdersDetails();
        }
        public DataSet GetDispatchSearch(Dispatch dispatch)
        {
            return dbDispatch.GetDispatchSearch(dispatch);
        }
        public DataSet GetDispatchByAgentID(Dispatch dispatch)
        {
            return dbDispatch.GetDispatchByAgentID(dispatch);
        }
        public DataSet CashierGetDetails(Dispatch dispatch)
        {
            return dbDispatch.CashierGetDetails(dispatch);
        }
        public DataSet GetDetailsForSettlement(Dispatch dispatch)
        {
            return dbDispatch.GetDetailsForSettlement(dispatch);
        }
        public DataSet GetStockFromDispatch(Dispatch dispatch)
        {
            return dbDispatch.GetStockFromDispatch(dispatch);
        }
        
        public DataSet GenerateDispatchSummary(i

        {
            return dbDispatch.GenerateDispatchSummary(id);
        }
      
        public DataSet GetSalesManWiseReturnedTraysReport(string startdate, string enddate, int salesmanid,int flag)
        {
            return dbDispatch.GetSalesManWiseReturnedTraysReport(startdate, enddate, salesmanid,flag);
        }
        public DataSet GetRoutewiseReturnTraysReport(string startdate, string enddate, int routeid,int flag)
        {
            return dbDispatch.GetRoutewiseReturnTraysReport(startdate,enddate,routeid,flag);
        }
        public DataSet GetDispatchLists(Dispatch disp)
        {
            return dbDispatch.GetDispatchLists(disp);
        }
        public DataSet GetDispatchListsUser(Dispatch disp)
        {
            return dbDispatch.GetDispatchListsUser(disp);
        }
        public DataSet GetCashier(string date, int salesmanid, int routeid, int brandid)
        {
            return dbDispatch.GetCashier(date,salesmanid, routeid, brandid);
        }

        public DataSet getStock(int id)
        {
            return dbDispatch.getStock(id);
        }
        public DataSet getDetailsbyDDid(int id)
        {
            return dbDispatch.getDetailsbyDDid(id);
        }
        public DataSet CashierGetDetailsId(int id)
        {
            return dbDispatch.CashierGetDetailsId(id);
        }
        
        public DataSet GetDispatchByID(int id , string flag ="None")
        {
            return dbDispatch.GetDispatchByID(id, flag);
        }
        
        public int AddDispatchInfo(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispatch();
            int Result = 0;
            try
            {
                Result = dbdispatch.AddDispatchInfo(dispatch);
                return Result;
            }
            catch (Exception)
            {
                throw;
            }
        }
        public int UpdateDispatch(Dispatch dispatch)
        {
            DBDispatch dbdispatch = new DBDispa
public class World : MonoBehaviour {
    public string worldName = "world";
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    
    public GameObject chunkPrefab;
    
    
    void UpdateIfEqual(int value1, int value2, WorldPos pos) {
        if (value1 == value2) {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z);
            if (chunk != null)
                chunk.update = true;
        }
    }
    public void CreateChunk(int x, int y, int z) {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newC

        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z) {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk)) {
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z) {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z) {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null) {
     
namespace ThreeBytes.Email.Dispatch.List.Frontend.Installers
    public class RegisterRoutes : IRegisterRoutes
    {
        public void Register(RouteCollection routes)
        {
            routes.MapRoute(
                "DispatchList",
                "Dispatch/List",
                new { controller = "EmailDispatchList", action = "List" }
            );
            routes.MapRoute(
                "DispatchListGetPageParams",
                "Dispatch/GetPage",
                new { controller = "EmailDispatchList", action = "GetPage" }
            );
            routes.MapRoute(
                "DispatchListGetPage",
                "Dispatch/GetPage/{page}/{datetime}",
                new { controller = "EmailDispatchList", action = "GetPage", page = "", datetime = "" }
            );
            routes.MapRoute(
                "DispatchListGet",
                "Dispatch/List/Get/{id}",
                new { controller = "EmailDispatchList", action = "Get", id = "" }
       
namespace MidiGremlin.Tests
    [TestFixture]
    public class OrchestraTests
    {
        [Test]
        [TestCase(InstrumentType.Violin, 5)]
        public void AddInstrumentTest(InstrumentType instrumentType, int octave = 3)
        {
            Orchestra orc = new Orchestra(Substitute.For<IMidiOut>(), 8);
            orc.AddInstrument(instrumentType, octave);
            bool test = orc.Instruments.ToList().Exists(item => (item.InstrumentType == instrumentType) && (item.Octave == octave));
            Assert.IsTrue(test);
        }
        [Test]
        public void AddInstrumentTest1()
        {
            Scale scale = new Scale(Tone.A, Tone.B, Tone.C);
            Orchestra orc = new Orchestra(Substitute.For<IMidiOut>(), 8);
            orc.AddInstrument(InstrumentType.Violin, scale, 5);
            bool test = orc.Instruments.ToList().Exists(item => (item.InstrumentType == InstrumentType.Violin) && (item.Octave == 5) && (item.Scale == scale));
            Assert.IsTrue(test)
namespace ProcessMonitorConsole
    public class ProcessMonitorEventHandler
    {
        private PollingProcessMonitor _processMonitor;
        public ProcessMonitorEventHandler(PollingProcessMonitor processMonitor)
        {
            _processMonitor = processMonitor;
            _processMonitor.ProcessListChanged += OnProcessListChanged;
            _processMonitor.ForegroundProcessChanged += OnForegroundProcessChanged;
        }
        private string ProcessNameAndIdAsString(Process process)
        {
            return process.ProcessName + " (" + process.Id + ")";
        }
        private void OnForegroundProcessChanged(object sender, ForegroundProcessChangedEventArgs e)
        {
            if (e.NewForegroundProcess != null && e.PreviousForegroundProcess != null)
            {
                Logger.Log("Foreground process changed from "
                    + ProcessNameAndIdAsString(e.PreviousForegroundProcess)
                    + " to " + ProcessNameAndIdAsString(e.New

            }
            else if (e.NewForegroundProcess == null && e.PreviousForegroundProcess != null)
            {
                Logger.Log("No processes on foreground, previous was "
                    + ProcessNameAndIdAsString(e.PreviousForegroundProcess));
            }
            else if (e.NewForegroundProcess != null && e.PreviousForegroundProcess == null)
            {
                Logger.Log("New foreground process: "
                    + ProcessNameAndIdAsString(e.NewForegroundProcess));
            }
        }
        private void OnProcessListChanged(object sender, ProcessListChangedEventArgs e)
        {
            if (e.PreviousProcessCount != 0)
            {
                Logger.Log("Process count changed from " + e.PreviousProcessCount + " to " + e.NewProcessCount);
                if (e.AddedProcesses.Count > 0)
                {
                    Logger.Log("Added processes:");
                    for (int i = 0; i < e.AddedProcesses.Count; ++i)
  
namespace DRMFSS.BLL.Services
    public class DispatchService : IDispatchService
    {
        private readonly IUnitOfWork _unitOfWork;
        public DispatchService(IUnitOfWork unitOfWork)
        {
            this._unitOfWork = unitOfWork;
        }
        #region Default Service Implementation
        public bool AddDispatch(Dispatch dispatch)
        {
            _unitOfWork.DispatchRepository.Add(dispatch);
            _unitOfWork.Save();
            return true;
        }
        public bool EditDispatch(Dispatch dispatch)
        {
            _unitOfWork.DispatchRepository.Edit(dispatch);
            _unitOfWork.Save();
            return true;
        }
        public bool DeleteDispatch(Dispatch dispatch)
        {
            if (dispatch == null) return false;
            _unitOfWork.DispatchRepository.Delete(dispatch);
            _unitOfWork.Save();
            return true;
        }
        public bool DeleteById(int id)
        {
            var entity = _unitOfWo

            if (entity == null) return false;
            _unitOfWork.DispatchRepository.Delete(entity);
            _unitOfWork.Save();
            return true;
        }
        public List<Dispatch> GetAllDispatch()
        {
            return _unitOfWork.DispatchRepository.GetAll();
        }
        public Dispatch FindById(int id)
        {
            return _unitOfWork.DispatchRepository.FindById(id);
        }
        public Dispatch FindById(System.Guid id)
        {
            return _unitOfWork.DispatchRepository.GetAll().FirstOrDefault(t => t.DispatchID == id);
        }
        public List<Dispatch> FindBy(Expression<Func<Dispatch, bool>> predicate)
        {
            return _unitOfWork.DispatchRepository.FindBy(predicate);
        }
        #endregion
        public Dispatch GetDispatchByGIN(string ginNo)
        {
            return _unitOfWork.DispatchRepository.Get(t => t.GIN == ginNo).FirstOrDefault();
        }
        public Transaction GetDispatchTransaction

        {
            var transactionGroup =
                _unitOfWork.DispatchDetailRepository.Get(t => t.DispatchID == dispatchId).Select(t => t.TransactionGroup)
                    .FirstOrDefault();
            if (transactionGroup != null && transactionGroup.Transactions.Count > 0)
            {
                return transactionGroup.Transactions.First();
            }
            return null;
        }
        public FDPBalance GetFDPBalance(int FDPID, string RequisitionNo)
        {
            var query =
                _unitOfWork.DispatchAllocationRepository.Get(t => t.FDPID == FDPID && t.RequisitionNo == RequisitionNo);
                        
            FDPBalance balance = new FDPBalance();
            if (query.Count() > 0)
            {
                var total = query.Select(t => t.Amount);
                if (total.Count() > 0)
                {
                    balance.TotalAllocation = total.Sum();
                }
                var commited = query.Wh
namespace SERVICE.Service
    public class DispatchOrderService : IDispatchOrderService
    {
        private HSSNInventoryEntities _context = null;
        private readonly ICommonService _commonService;
        public DispatchOrderService()
        {
            _commonService = new CommonService();
        }
        public bool SaveDispatchOrder(DispatchOrderModel dispatchOrderModel)
        {
            try
            {
                if (dispatchOrderModel.DispatchOrderId == 0)
                {
                    {
                        dispatchOrderModel.DispatchOrderId =
                            SaveDispatchOrderSumamry(dispatchOrderModel).DispatchOrderId;
                        if (dispatchOrderModel.DispatchOrderId != 0)
                        {
                            SaveDispatchOrderDetails(dispatchOrderModel.DispatchOrderDetailModels,
                                dispatchOrderModel.DispatchOrderId);
                            _commonService.UpdateSerial

                        }
                        scope.Complete();
                    }
                }
                else
                {
                    {
                        if (EditDispatchOrderSumamry(dispatchOrderModel) == true)
                        {
                            if (DeleteDispatchOrderDetail(dispatchOrderModel.DispatchOrderId))
                            {
                                SaveDispatchOrderDetails(dispatchOrderModel.DispatchOrderDetailModels,
                                    dispatchOrderModel.DispatchOrderId);
                            }
                            scope.Complete();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            return true;
        }
        public DispatchOrderModel GetDispatchOrderDetailByDispatchOrderId(int dispatchOrderNumber)
        {
            {
         

                try
                {
                    var dispatchOrderSummaryModel =
                        _context.DispatchOrders.Where(a => a.DispatchOrderNumber == dispatchOrderNumber)
                            .Select(b => new DispatchOrderModel()
                            {
                                DispatchOrderId = b.DispatchOrderId,
                                DispatchOrderDate = b.DispatchOrderDate,
                                DispatchOrderNumber = b.DispatchOrderNumber,
                                BankGuaranteeAmount = b.BankGuaranteeAmount,
                                OrderRequestedBy = b.OrderRequestedBy,
                                OverDueAmount = b.OverDueAmount,
                                NetDueAmount = b.NetDueAmount,
                                DealerId = b.DealerId
                            }).FirstOrDefault();
                    var dispatchOrderDetailModel = (from b in _context.DispatchOrderDetails
                  
namespace Pixel.Aruba.Web.DataLayer
    public interface IUnitOfWork : IDisposable
    {
        IAgentRepository AgentRepository { get; }
        ITemplateMetadataRepository TemplateMetadataRepository { get; }
        ITemplateContentRepository TemplateContentRepository { get; }
        IPageThumbnailRepository PageThumbnailRepository { get; }
        IPagePdfRepository PagePdfRepository { get; }
        IPrintPdfRepository PrintPdfRepository { get; }
        IVitecObjectRepository VitecObjectRepository { get; }
        IVitecValueMappingsRepository VitecValueMappingsRepository { get; }
        IPrintRepository PrintRepository { get; }
        IPageRepository PageRepository { get; }
        IFieldValueRepository FieldValueRepository { get; }
        void Save();
    }
    public class UnitOfWork : IUnitOfWork
    {
        private readonly ApplicationDb _db = new ApplicationDb();
        private IAgentRepository _agentRepository;
        private ITemplateMetadataRepository _templateMe

        private ITemplateContentRepository _templateContentRepository;
        private IPageThumbnailRepository _pageThumbnailRepository;
        private IPagePdfRepository _pagePdfRepository;
        private IPrintPdfRepository _printPdfRepository;
        private IVitecObjectRepository _vitecObjectRepository;
        private IVitecValueMappingsRepository _vitecValueMappingsRepository;
        private IPrintRepository _printRepository;
        private IPageRepository _pageRepository;
        private IFieldValueRepository _fieldValueRepository;
        public IAgentRepository AgentRepository { get { return _agentRepository ?? (_agentRepository = new AgentRepository(_db)); } }
        public ITemplateMetadataRepository TemplateMetadataRepository { get { return _templateMetadataRepository ?? (_templateMetadataRepository = new TemplateMetadataRepository()); } }
        public ITemplateContentRepository TemplateContentRepository { get { return _templateContentRepository ?? (_templateConte

        public IPageThumbnailRepository PageThumbnailRepository { get { return _pageThumbnailRepository ?? (_pageThumbnailRepository = new PageThumbnailRepository()); } }
        public IPagePdfRepository PagePdfRepository { get { return _pagePdfRepository ?? (_pagePdfRepository = new PagePdfRepository()); } }
        public IPrintPdfRepository PrintPdfRepository { get { return _printPdfRepository ?? (_printPdfRepository = new PrintPdfRepository()); } }
        public IVitecObjectRepository VitecObjectRepository { get { return _vitecObjectRepository ?? (_vitecObjectRepository = new VitecObjectRepository()); } }
        public IVitecValueMappingsRepository VitecValueMappingsRepository { get { return _vitecValueMappingsRepository ?? (_vitecValueMappingsRepository = new VitecValueMappingsRepository(_db)); } }
        public IPrintRepository PrintRepository { get { return _printRepository ?? (_printRepository = new PrintRepository(_db)); } }
        public IPageRepository PageRepository {
namespace Global.DataAccess
    public class InstrumentAttachmentDaoImpl
    {
        public void Add(InstrumentAttachmentModel model)
        {
            DBProvider.dbMapper.Insert("BaseData_InstrumentAttachment.Insert", model);
        }
        public void Update(InstrumentAttachmentModel model)
        {
            DBProvider.dbMapper.Update("BaseData_InstrumentAttachment.Update", model);
        }
        public void DeleteByPk(InstrumentAttachmentModel model)
        {
            DBProvider.dbMapper.Delete("BaseData_InstrumentAttachment.DeleteByPk", model);
        }
        public InstrumentAttachmentModel GetByPk(InstrumentAttachmentModel model)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentAttachmentModel>("BaseData_InstrumentAttachment.GetByPk", model);
        }
        public IList<InstrumentAttachmentModel> GetAll()
        {
            return DBProvider.dbMapper.SelectList<InstrumentAttachmentModel>("BaseData_InstrumentAttachment.GetAll");

namespace EFCache.Redis.Tests
    public abstract class StorageEmulatorManager : IStorageEmulatorManager
    {
        private readonly string _processName;
        private readonly ProcessStartInfo _processStartInfo;
        protected StorageEmulatorManager(string processName, ProcessStartInfo processStartInfo)
        {
            _processStartInfo = processStartInfo;
            _processName = processName;
        }
        public Process GetProcess() => Process.GetProcessesByName(_processName).FirstOrDefault();
        public bool IsProcessStarted() => GetProcess() != null;
        public void StartProcess(bool waitForExit)
        {
            if (IsProcessStarted()) return;
            {
                if (process != null && waitForExit) process.WaitForExit();
            }
        }
        public void StopProcess()
        {
            var process = GetProcess();
            process?.Kill();
        }
        public static string AssemblyDirectory
        {
            get

namespace LogistiX.Controllers
    [Authorize(Roles = "Admin, Administrator")]
    public class DispatchDetailsManagementController : Controller
    {
        
        private LogistiXEntities db = new LogistiXEntities();
        [Audit(AuditingLevel = 3)]
        public async Task<ActionResult> Index()
        {
            var tblDispatch = db.tbl_Dispatch_Details.OrderBy(t => t.Dispatch_Details);
            return View(await tblDispatch.ToListAsync());
        }
        [Audit(AuditingLevel = 3)]
        public async Task<ActionResult> Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            tbl_Dispatch_Details tbl_Dispatch_Details = await db.tbl_Dispatch_Details.FindAsync(id);
            if (tbl_Dispatch_Details == null)
            {
                return HttpNotFound();
            }
            return View(tbl_Dispatch_Details);
        }
        public ActionRes

        {
            return View();
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Audit(AuditingLevel = 3)]
        public async Task<ActionResult> Create([Bind(Include = "Dispatch_Details_ID,Dispatch_Details")] tbl_Dispatch_Details tbl_Dispatch_Details)
        {
            if (ModelState.IsValid)
            {
                db.tbl_Dispatch_Details.Add(tbl_Dispatch_Details);
                await db.SaveChangesAsync();
                return RedirectToAction("Details", new { id = tbl_Dispatch_Details.Dispatch_Details_ID});
            }
            return View(tbl_Dispatch_Details);
        }
        public async Task<ActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            tbl_Dispatch_Details tbl_Dispatch_Details = await db.tbl_Dispatch_Details.FindAsync(id);
            if (tbl_Dispatch_Details == null)
            {
          

            }
            return View(tbl_Dispatch_Details);
        }
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Audit(AuditingLevel = 3)]
        public async Task<ActionResult> Edit([Bind(Include = "Dispatch_Details_ID,Dispatch_Details")] tbl_Dispatch_Details tbl_Dispatch_Details)
        {
            if (ModelState.IsValid)
            {
                db.Entry(tbl_Dispatch_Details).State = EntityState.Modified;
                await db.SaveChangesAsync();
                return RedirectToAction("Details", new { id = tbl_Dispatch_Details.Dispatch_Details_ID });
            }
            return View(tbl_Dispatch_Details);
        }
        public async Task<ActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            tbl_Dispatch_Details tbl_Dispatch_Details = await db.tbl_Dispatch_Details.FindAsync(id);
            if (tbl_Dispatch_Detail
namespace ProcessModuleList
    class Program
    {
        static void Main(string[] args)
        {
            Process process = GetTargetProcess("notepad");
            if (process != null)
            {
                int processId = process.Id;
                string processName = process.ProcessName;
                string programFilename;
                try
                {
                    programFilename = process.MainModule.FileName;
                }
                catch (Exception)
                {
                    programFilename = "unknown";
                }
                Console.WriteLine("{0}: {1} - {2}", processId, processName, programFilename);
                foreach (ProcessModule processModule in process.Modules)
                {
                    Console.WriteLine(processModule.FileName);
                }
            }
        }
        static Process GetTargetProcess(string processName)
        {
            Process[] processes = Process.GetPro
namespace SmartQuant
	public class SubscriptionManager
	{
		private Framework framework;
		private Dictionary<int, Dictionary<Instrument, int>> subscriptions;
		public SubscriptionManager(Framework framework)
		{
			this.framework = framework;
			this.subscriptions = new Dictionary<int, Dictionary<Instrument, int>>();
		}
		public void Subscribe(int providerId, Instrument instrument)
		{
			IDataProvider provider = this.framework.ProviderManager.GetProvider(providerId) as IDataProvider;
			this.Subscribe(provider, instrument);
		}
		public void Subscribe(IDataProvider provider, Instrument instrument)
		{
			if (provider.Status != ProviderStatus.Connected)
			{
				provider.Connect();
			}
			Dictionary<Instrument, int> dictionary = null;
			if (!this.subscriptions.TryGetValue((int)provider.Id, out dictionary))
			{
				dictionary = new Dictionary<Instrument, int>();
				this.subscriptions[(int)provider.Id] = dictionary;
			}
			int num = 0;
			bool flag = false;
			if (!dictionary.TryG

			{
				flag = true;
				num = 1;
			}
			else
			{
				if (num == 0)
				{
					flag = true;
				}
				num++;
			}
			dictionary[instrument] = num;
			if (flag)
			{
				provider.Subscribe(instrument);
			}
		}
		public void Unsubscribe(int providerId, Instrument instrument)
		{
			IDataProvider provider = this.framework.ProviderManager.GetProvider(providerId) as IDataProvider;
			this.Unsubscribe(provider, instrument);
		}
		public void Unsubscribe(IDataProvider provider, Instrument instrument)
		{
			Dictionary<Instrument, int> dictionary;
			(dictionary = this.subscriptions[(int)provider.Id])[instrument] = dictionary[instrument] - 1;
			if (this.subscriptions[(int)provider.Id][instrument] == 0)
			{
				provider.Unsubscribe(instrument);
			}
		}
		public void Subscribe(IDataProvider provider, InstrumentList instruments)
		{
			if (provider.Status != ProviderStatus.Connected)
			{
				provider.Connect();
			}
			InstrumentList instrumentList = new InstrumentList();
			for (int i =

			{
				Instrument byIndex = instruments.GetByIndex(i);
				if (!this.subscriptions.ContainsKey((int)provider.Id))
				{
					this.subscriptions[(int)provider.Id] = new Dictionary<Instrument, int>();
				}
				if (!this.subscriptions[(int)provider.Id].ContainsKey(byIndex) || this.subscriptions[(int)provider.Id][byIndex] == 0)
				{
					this.subscriptions[(int)provider.Id][byIndex] = 0;
					instrumentList.Add(byIndex);
				}
				Dictionary<Instrument, int> dictionary;
				Instrument key;
				(dictionary = this.subscriptions[(int)provider.Id])[key = byIndex] = dictionary[key] + 1;
			}
			if (instrumentList.Count > 0)
			{
				provider.Subscribe(instrumentList);
			}
		}
		public void Unsubscribe(IDataProvider provider, InstrumentList instruments)
		{
			InstrumentList instrumentList = new InstrumentList();
			for (int i = 0; i < instruments.Count; i++)
			{
				Instrument byIndex = instruments.GetByIndex(i);
				Dictionary<Instrument, int> dictionary;
				Instrument key;
				(dictio
﻿namespace DrBeshoyClinic.DAL.Repositories.Infrastructure
    public class UnitOfWork : IUnitOfWork
    {
        #region IUnitOfWork Members
        private ChronicDiseaseRepository _chronicDiseaseRepository;
        private DrugHxRepository _drugHxRepository;
        private EmgNcvRepository _emgNcvRepository;
        private ExaminationChronicDiseaseRepository _examinationChronicDiseaseRepository;
        private ExaminationRepository _examinationRepository;
        private FamilyHxRepository _familyHxRepository;
        private LabTestRepository _labTestRepository;
        private MedicineDetailsRepository _medicineDetailsRepository;
        private MedicineRepository _medicineRepository;
        private OperationRepository _operationRepository;
        private PatientRepository _patientRepository;
        private PhotoRepository _photoRepository;
        private RadiologyRepository _radiologyRepository;
        private SurgicalHxRepository _surgicalHxRepository;
        private Tr

        private TreatmentPeriodRepository _treatmentPeriodRepository;
        private TreatmentRepository _treatmentRepository;
        private DiagnosisRepository _diagnosisRepository;
        private ComplaintRepository _complaintRepository;
        private PostOperativeTreatmentRepository _postOperativeTreatmentRepository;
        private PostOperativeInstructionRepository _postOperativeInstructionRepository;
        #endregion
        #region Repositries Properties
        public ChronicDiseaseRepository ChronicDiseaseRepository
            => _chronicDiseaseRepository ?? (_chronicDiseaseRepository = new ChronicDiseaseRepository());
        public DrugHxRepository DrugHxRepository => _drugHxRepository ?? (_drugHxRepository = new DrugHxRepository());
        public EmgNcvRepository EmgNcvRepository => _emgNcvRepository ?? (_emgNcvRepository = new EmgNcvRepository());
        public ExaminationChronicDiseaseRepository ExaminationChronicDiseaseRepository =>
            _examinationCh

                new ExaminationChronicDiseaseRepository());
        public ExaminationRepository ExaminationRepository
            => _examinationRepository ?? (_examinationRepository = new ExaminationRepository());
        public FamilyHxRepository FamilyHxRepository
            => _familyHxRepository ?? (_familyHxRepository = new FamilyHxRepository());
        public LabTestRepository LabTestRepository
            => _labTestRepository ?? (_labTestRepository = new LabTestRepository());
        public MedicineDetailsRepository MedicineDetailsRepository
            => _medicineDetailsRepository ?? (_medicineDetailsRepository = new MedicineDetailsRepository());
        public MedicineRepository MedicineRepository
            => _medicineRepository ?? (_medicineRepository = new MedicineRepository());
        public OperationRepository OperationRepository
            => _operationRepository ?? (_operationRepository = new OperationRepository());
        public PatientRepository PatientRep
namespace App.Repository.Impl
    public class Bootstrap : App.Common.Tasks.BaseTask<IBaseContainer>, IBootstrapper
    {
        public Bootstrap():base(App.Common.ApplicationType.All)
        {
        }
        public void Execute(IBaseContainer context)
        {
            context.RegisterTransient<IUserRepository, UserRepository>();
            context.RegisterTransient<Repository.Common.ILanguageRepository, App.Repository.Impl.Common.LanguageRepository>();
            context.RegisterTransient<Repository.Secutiry.IRoleRepository, App.Repository.Impl.Security.RoleRepository>();
            context.RegisterTransient<Repository.Secutiry.IPermissionRepository, App.Repository.Impl.Security.PermissionRepository>();
            context.RegisterTransient<Repository.Secutiry.IUserGroupRepository, App.Repository.Impl.Security.UserGroupRepository>();
            context.RegisterTransient<Repository.Common.IFileRepository, App.Repository.Impl.Common.FileRepository>();
            context.R
﻿namespace OO_PickNDrive.DAL
    public class Repository
    {
        public DjelatnikRepository djelatnikRepository;
        public KlijentRepository klijentRepository;
        public MjestoRepository mjestoRepository;
        public RacunRepository racunRepository;
        public RacunStatusRepository racunStatusRepository;
        public VoziloRepository voziloRepository;
        public VoziloKategorijaRepository voziloKategorijaRepository;
        public VoziloStatusRepository voziloStatusRepository;
        public Repository()
        {
            djelatnikRepository = new DjelatnikRepository();
            klijentRepository = new KlijentRepository();
            mjestoRepository = new MjestoRepository();
            racunRepository = new RacunRepository();
            racunStatusRepository = new RacunStatusRepository();
            voziloRepository = new VoziloRepository();
            voziloKategorijaRepository = new VoziloKategorijaRepository();
            voziloStatusReposi
namespace zohobooks.service
    public class ZohoBooks
    {
        string authToken;
        string organisationId;
        public void initialize(string auth_token,string organization_id)
        {
            this.authToken = auth_token;
            this.organisationId = organization_id;
        }
        public InvoicesApi GetInvoicesApi()
        {
            var invoicesApi = new InvoicesApi(authToken,organisationId);
            return invoicesApi;
        }
        public BankAccountsApi GetBankAccountsApi()
        {
            var bankAccountsApi = new BankAccountsApi(authToken, organisationId);
            return bankAccountsApi;
        }
        public BankRulesApi GetBankRulesApi()
        {
            var bankrulesApi = new BankRulesApi(authToken, organisationId);
            return bankrulesApi;
        }
        public BankTransactionsApi GetBankTransactionsApi()
        {
            var bankTransactionsApi = new BankTransactionsApi(authToken, organisationId);
   

        }
        public BaseCurrencyAdjustmentsApi GetBaseCurrencyAdjustmentsApi()
        {
            var baseCurrencyAdjustmentApi = new BaseCurrencyAdjustmentsApi(authToken, organisationId);
            return baseCurrencyAdjustmentApi;
        }
        public BillsApi GetBillsApi()
        {
            var billsApi = new BillsApi(authToken, organisationId);
            return billsApi;
        }
        public ChartOfAccountsApi GetChartOfAccountsApi()
        {
            var chartOfAccountsApi = new ChartOfAccountsApi(authToken, organisationId);
            return chartOfAccountsApi;
        }
        public ContactsApi GetContactsApi()
        {
            var contactsApi = new ContactsApi(authToken, organisationId);
            return contactsApi;
        }
        public CreditNotesApi GetCreditNoteApi()
        {
            var creditNotesApi = new CreditNotesApi(authToken, organisationId);
            return creditNotesApi;
        }
        public CustomerPaymentsA

        {
            var customerPaymentsApi = new CustomerPaymentsApi(authToken, organisationId);
            return customerPaymentsApi;
        }
        public EstimatesApi GetEstimatesApi()
        {
            var estimatesApi = new EstimatesApi(authToken, organisationId);
            return estimatesApi;
        }
        public ExpensesApi GetExpensesApi()
        {
            var expensesApi = new ExpensesApi(authToken, organisationId);
            return expensesApi;
        }
        public ItemsApi GetItemsApi()
        {
            var itemsApi = new ItemsApi(authToken, organisationId);
            return itemsApi;
        }
        public JournalsApi GetJournalsApi()
        {
            var journalsApi = new JournalsApi(authToken, organisationId);
            return journalsApi;
        }
        public OrganizationsApi GetOrganizationsApi()
        {
            var organizationsApi = new OrganizationsApi(authToken, organisationId);
            return organization
namespace Photocom.DataLayer
    public class UnitOfWork : IUnitOfWork
    {
        protected PhotocomContext PhotocomContext;
        private ICategoryRepository _categoryRepository;
        private ICommentRepository _commentRepository;
        private IPermissionRepository _permissionRepository;
        private IPhotoRepository _photoRepository;
        private IPrivilegeRepository _privilegeRepository;
        private IUserRepository _userRepository;
        private ISessionRepository _sessionRepository;
        private ILikeRepository _likeRepository;
        public UnitOfWork()
        {
            _categoryRepository = null;
            _commentRepository = null;
            _permissionRepository = null;
            _photoRepository = null;
            _privilegeRepository = null;
            _userRepository = null;
            PhotocomContext = new PhotocomContext();
        }
        public void SaveChanges()
        {
            PhotocomContext.SaveChanges();
        }
   

        {
            get
            {
                if (_categoryRepository == null)
                {
                    _categoryRepository = new CategoryRepository(PhotocomContext);
                }
                return _categoryRepository;
            }
        }
        public ICommentRepository CommentRepository
        {
            get
            {
                if (_commentRepository == null)
                {
                    _commentRepository = new CommentRepository(PhotocomContext);
                }
                return _commentRepository;
            }
        }
        public IPermissionRepository PermissionRepository
        {
            get
            {
                if (_commentRepository == null)
                {
                    _commentRepository = new CommentRepository(PhotocomContext);
                }
                return _permissionRepository;
            }
        }
        public IPhotoRepository PhotoRepository
        {
        

            {
                if (_photoRepository == null)
                {
                    _photoRepository = new PhotoRepository(PhotocomContext);
                }
                return _photoRepository;
            }
        }
        public IPrivilegeRepository PrivilegeRepository
        {
            get
            {
                if (_privilegeRepository == null)
                {
                    _privilegeRepository = new PrivilegeRepository(PhotocomContext);
                }
                return _privilegeRepository;
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                if (_userRepository == null)
                {
                    _userRepository = new UserRepository(PhotocomContext);
                }
                return _userRepository;
            }
        }
        public ISessionRepository SessionRepository
        {
            get
            {
                if (_sessio
namespace Repository.UnitOfWork.Implementations
    public class UnitOfWork : IUnitOfWork
    {
        private ApplicationDbContext context;
        #region Repository variables
        private IContoRepository contoRepository;
        private IBusinessPartnerBankAccountRepository businessPartnerBankAccountRepository;
        private IBusinessPartnerLocationRepository businessPartnerLocationRepository;
        private IBusinessPartnerPhoneRepository businessPartnerPhoneRepository;
        private IBusinessPartnerRepository businessPartnerRepository;
        private ICalculationsRepository inputCalculationsRepository;
        private IPriceLevelingRepository priceLevelingRepository;
        private IPricingRepository pricingRepository;
        private ICashierRepository cashierRepository;
        private IClawbackFromBuyerRepository clawbackFromBuyerRepository;
        private IClawbackFromSupplierRepository clawbackFromSupplierRepository;
        private ILoanRepository loanRepository

        private IWritingOffRepository writingOffRepository;
        private ICompanyBankAccountRepository companyBankAccountRepository;
        private ICompanyPhoneRepository companyPhoneRepository;
        private ICompanyRepository companyRepository;
        private IDeliveryNoteRepository deliveryNoteRepository;
        private IInternalDeliveryNoteRepository internalDeliveryNoteRepository;
        private IInputNoteRepository inputNoteRepository;
        private IPassportRepository passportRepository;
        private IExchangeRateRepository exchangeRateRepository;
        private IAuthenticationRepository authenticationRepository;
        private IUserRepository userRepository;
        private IAccountStatementRepository accountStatementRepository;
        private IBookOfOutputInvoicesRepository bookOfOutputInvoicesRepository;
        private ICreditNoteRepository creditNoteRepository;
        private IOutputInvoiceRepository outputInvoiceRepository;
        private IOutputProInv

        private IInputInvoiceRepository inputInvoiceRepository;
        private IAdvanceOutputInvoiceRepository advanceOutputInvoiceRepository;
        private ICountryRepository countryRepository;
        private ICityRepository cityRepository;
        private IExpenseLocationRepository expenseLocationRepository;
        private IMunicipalityRepository municipalityRepository;
        private IOrganizationUnitRepository organizationUnitRepository;
        private ISectionRepository sectionRepository;
        private IProductCardRepository productCardRepository;
        private IProductGroupRepository productGroupRepository;
        private IProductSubGroupRepository productSubGroupRepository;
        private IProductRepository productRepository;
        private IProductSubItemRepository productSubItemRepository;
        private IAnimalTypeRepository animalTypeRepository;
        private IAnimalSubTypeRepository animalSubTypeRepository;
        private IUnitOfMeasurementRepository unit
namespace Voxels.Universe.Chunks {
    public class ChunkProvider : MonoBehaviour {
        public GameObject chunkPrefab;
        public Dictionary<Position, Chunk> Chunks = new Dictionary<Position, Chunk>();
        private World world;
        private Player player;
        private WorkerQueue renderQueue;
        private WorkerQueue generateQueue;
        public void Awake() {
            player = FindObjectOfType<Player>();
            world = GetComponentInParent<World>();            
        }
	    public void Start() {
            renderQueue = new WorkerQueue();
            renderQueue.Start();
            generateQueue = new WorkerQueue();
            generateQueue.Start();
		}
		public void OnApplicationQuit() {
            renderQueue.Stop();
            generateQueue.Stop();
		}
        public void LateUpdate() {
            foreach (var chunk in Chunks.Values) {
                if (chunk.Working)
                    continue;
                switch (chunk.ChunkState) {
  

                        generateChunk(chunk);                        
                        break;
                    case ChunkState.ATTACHED:
                        rasterizeChunk(chunk);
                        break;
                    case ChunkState.TESSELATED:
                        renderChunk(chunk);
                        break;
                }
            }
        }
        private void generateChunk(Chunk chunk) {
            float distance = player.GetDistance(chunk.Position);
            generateQueue.Enqueue(distance, new GenerateWorker(chunk, world));
        }
        private void rasterizeChunk(Chunk chunk) {
            float distance = player.GetDistance(chunk.Position);
            renderQueue.Enqueue(distance, new RasterizeWorker(chunk));
        }
        private void renderChunk(Chunk chunk) {
            chunk.Render();
        }
        public void Load(Position position) {
            GameObject chunkObject = Instantiate(chunkPrefab, Vector3.zero, 
namespace Sparrow.Map {
  public class World : MonoBehaviour {
    public int mapSize;
    public int chunkSize;
    public int tileSize;
    public int seed;
    public float amplitude;
    public float scale;
    public float floor;
    public Chunk chunkPrefab;
    public MultiKeyDictionary<int, int, Chunk> chunks;
    void Awake() {
      chunks = new MultiKeyDictionary<int, int, Chunk>();
      for (int i = 0; i < mapSize; i++) {
        for (int j = 0; j < mapSize; j++) {
          GetChunk(i, j);
        }
      }
    }
    public void Clear() {
      transform.SafeDestroyAllChildren();
      chunks.Clear();
    }
    public float Height(float x, float z) {
      float baseHeight = floor * amplitude;
      float height = NormalizedHeight(x, z);
      if (height < floor) {
        return floor * amplitude - baseHeight;
      }
      return (height * amplitude) - baseHeight;
    }
    public float NormalizedHeight(float x, float z) {
      float perlinX = (seed * 1000 + x) / scale
public class ChunkHandler
    private List<Chunk> chunks = new List<Chunk>();
    private bool autoDestroyLeft;
    private bool autoDestroyRight;
    private bool autoDestroyUp;
    private bool autoDestroyDown;
    private int chunkSize;
    public ChunkHandler(int size)
    {
        chunkSize = size;
    }
    Chunk createNewChunk(Vector2 target)
    {
        Rect rect = new Rect(Mathf.FloorToInt(target.x / chunkSize) * chunkSize, (Mathf.FloorToInt(target.y / chunkSize)) * chunkSize, chunkSize, chunkSize);
        Chunk newChunk = new Chunk(rect);
        Chunks.Add(newChunk);
        return newChunk;
    }
    public void destoryChunksDirection(string direction, Vector2 position)
    {
        if (direction == "left")
        {
            int maxX = (Mathf.FloorToInt(position.x / chunkSize) * chunkSize) - (chunkSize * 2);
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.x < maxX)
                    dest

            }
        }
        if (direction == "right")
        {
            int minX = (Mathf.FloorToInt(position.x / chunkSize) * chunkSize) + (chunkSize * 2);
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.x > minX)
                    destroyChunk(chunk);
            }
        }
        if (direction == "up")
        {
            int minY = (Mathf.FloorToInt(position.y / chunkSize) * chunkSize) + (chunkSize * 2);
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.y > minY)
                    destroyChunk(chunk);
            }
        }
        if (direction == "down")
        {
            int minY = (Mathf.FloorToInt(position.y / chunkSize) - (chunkSize * 2));
            foreach (Chunk chunk in getNonRenderChunks(position))
            {
                if (chunk.ChunkRect.position.y < minY)
                    destroyChunk(

            }
        }
    }
    public void destroyChunk(Chunk destory)
    {
        foreach (GameObject obj in destory.Objects)
        {
            GameObject.Destroy(obj);
        }
        Chunks.Remove(destory);
    }
    List<Chunk> getNonRenderChunks(Vector2 position)
    {
        List<Chunk> nonRenderChunks = new List<Chunk>(Chunks);
        foreach (Chunk chunk in getRenderChunks(position))
        {
            nonRenderChunks.Remove(chunk);
        }
        return nonRenderChunks;
    }
    public List<Chunk> getEmptyChunks()
    {
        List<Chunk> emptyChunks = new List<Chunk>();
        foreach (Chunk chunk in Chunks)
        {
            if (chunk.Objects.Count == 0)
                emptyChunks.Add(chunk);
        }
        return emptyChunks;
    }
    public List<Chunk> getRenderChunks(Vector2 position)
    {
        List<Chunk> renderChunks = new List<Chunk>();
        renderChunks.Add(getChunk(new Vector2(position.x - chunkSize, position.y)));
        rende
namespace EstudioCapra.Backend
    public interface IUnitOfWork
    {
        ServicioRepository ServicioRepository
        {
            get;
        }
        ClienteRepository ClienteRepository
        {
            get;
        }
        ContratoRepository ContratoRepository
        {
            get;
        }
        TipoServicioRepository TipoServicioRepository
        {
            get;
        }
        TareaEmpleadoRepository TareaEmpleadoRepository
        {
            get;
        }
        ObjetoMultimediaRepository ObjetoMultimediaRepository
        {
            get;
        }
        TareaRepository TareaRespository
        {
            get;
        }
        TipoTareaRepository TipoTareaReposiory
        {
            get;
        }
        EmpleadoRepository EmpleadoRepository
        {
            get;
        }
        UsuarioRepository UsuarioRepository
        {
            get;
        }
        UsuarioRolRepository UsuarioRolRepository
        {
            ge
namespace CMP.Operation.Models
    public class RepositoryContainer : IDisposable
    {
        private EmployeeRepository _EmployeeRepository;
        public IEmployeeRepository EmployeeRepository
        {
            get
            {
                if (_EmployeeRepository == null)
                    _EmployeeRepository = new EmployeeRepository();
                return _EmployeeRepository;
            }
        }
        private JobRepository _JobRepository;
        public IJobRepository JobRepository
        {
            get
            {
                if (_JobRepository == null)
                    _JobRepository = new JobRepository();
                return _JobRepository;
            }
        }
        private CustomerRepository _CustomerRepository;
        public ICustomerRepository CustomerRepository
        {
            get
            {
                if (_CustomerRepository == null)
                    _CustomerRepository = new CustomerRepository();
               

            }
        }
        private DepartmentRepository _DepartmentRepository;
        public IDepartmentRepository DepartmentRepository
        {
            get
            {
                if (_DepartmentRepository == null)
                    _DepartmentRepository = new DepartmentRepository();
                return _DepartmentRepository;
            }
        }
        private FocalPointRepository _FocalPointRepository;
        public IFocalPointRepository FocalPointRepository
        {
            get
            {
                if (_FocalPointRepository == null)
                    _FocalPointRepository = new FocalPointRepository();
                return _FocalPointRepository;
            }
        }
        private ProjectTypeRepository _ProjectTypeRepository;
        public IProjectTypeRepository ProjectTypeRepository
        {
            get
            {
                if (_ProjectTypeRepository == null)
                    _ProjectTypeRepository = new ProjectTyp

                return _ProjectTypeRepository;
            }
        }
        private TechnologyRepository _TechnologyRepository;
        public ITechnologyRepository TechnologyRepository
        {
            get
            {
                if (_TechnologyRepository == null)
                    _TechnologyRepository = new TechnologyRepository();
                return _TechnologyRepository;
            }
        }
        private ProjectRepository _ProjectRepository;
        public IProjectRepository ProjectRepository
        {
            get
            {
                if (_ProjectRepository == null)
                    _ProjectRepository = new ProjectRepository();
                return _ProjectRepository;
            }
        }
        private ProjectTechnologyRepository _ProjectTechnologyRepository;
        public IProjectTechnologyRepository ProjectTechnologyRepository
        {
            get
            {
                if (_ProjectTechnologyRepository == null)
      
namespace tests
	[TestFixture()]
	public class Test
	{
		[Test()]
		public void BadArgCountsThrow ()
		{
			Assert.Throws<ArgumentException>(
				delegate 
				{ 
					MTangle.Main(new String[] {});
				});
			Assert.Throws<ArgumentException>(
				delegate 
				{ 
				MTangle.Main(new String[] {"justOne"});
			});
			Assert.Throws<ArgumentException>(
				delegate 
				{ 
				MTangle.Main(new String[] {"too", "many", "args"});
			});
		}
		[Test()]
		public void FixesHTMLEscapes()
		{
			string bad = "Some text &lt;element&gt;";
			string good = MTangle.FixHTMLCode(bad);
			Assert.AreEqual("Some text <element>", good);
		}
		[Test()]
		public void FindsChunk()
		{
			string enchunked = "<p>OK, here's my first chunk, which is the \"chunk\" section</p>" +
				"<pre id=\"chunk\">" +
				"chunk" + 
				"</pre>";
			string chunk = MTangle.GetChunk(enchunked, "chunk");
			Assert.AreEqual("chunk", chunk);
		}
		[Test()]
		public void ReturnsEmptyIfNoChunk()
		{
			string noChunk = "<p>adfadfad
namespace Distributr.WPF.UI.Views.DispatchPendingOrdersToPhone
{ public partial class DispatchOptions : Window
    {
        public ListSalesmanOrdersViewModel.EnumSelectedDispatchMode SelectedDispatchOption;
        private IMessageSourceAccessor _messageResolver = ObjectFactory.GetInstance<IMessageSourceAccessor>();
        public DispatchOptions()
        {
            InitializeComponent();
            LabelControls();
        }
        void LabelControls()
        {
            Title = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.title");
            lblSummary.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.summarytitle");
            lblOptions.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.options.title");
            rbDispatchFulfilled.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.options.dispatchfulfilled");
            rbDispatchWithPartial.Content = _messageResolver.GetText("sl.dispatchOrde

            rbProcessAndDispatchFulfilled.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.options.processfulfillableanddispatchall");
            rbProcessDispatchWithPartial.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.options.processanddispatchall");
            OKButton.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.ok");
            CancelButton.Content = _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.cancel");
        }
        private void OKButton_Click(object sender, RoutedEventArgs e)
        {
            if (rbDispatchFulfilled.IsChecked == true || rbDispatchWithPartial.IsChecked == true || rbProcessAndDispatchFulfilled.IsChecked == true || rbProcessDispatchWithPartial.IsChecked == true)
                this.DialogResult = true;
            else
                MessageBox.Show(_messageResolver.GetText("sl.dispatchOrders.dispatchoptions.selectoption")/*"Please select an option to proceed with 

                    , _messageResolver.GetText("sl.dispatchOrders.dispatch.messagebox.caption") /*"Distributr: Dispatch Orders"*/
                    , MessageBoxButton.OK);
        }
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }
        private void btnDispatchInfo_Click(object sender, RoutedEventArgs e)
        {
            var btn = sender as Button;
            string msg = "";
            switch (btn.Name)
            {
                case "btnDispatchFulfilled":
                    msg = /*"Dispatches only those orders which have been fulfilled.";*/
                        _messageResolver.GetText("sl.dispatchOrders.dispatchoptions.options.option1.info");
                    break;
                case "btnDispatchWithPartial":
                    msg = /*"Dispatches the fulfilled orders and dispatches unfulfilled orders partially without processing them.";*/
                        _message
namespace Overrustlelogs.ViewModels.Factories {
    public class ApiFactory : IApiFactory {
        private readonly IApiChannels _apiChannels;
        private readonly IApiDays _apiDays;
        private readonly IApiLogs _apiLogs;
        private readonly IApiMentions _apiMentions;
        private readonly IApiMonths _apiMonths;
        private readonly IApiUserlogs _apiUserlogs;
        public ApiFactory(IApiChannels apiChannels, IApiMonths apiMonths, IApiDays apiDays,
            IApiLogs apiLogs, IApiUserlogs apiUserlogs, IApiMentions apiMentions) {
            _apiChannels = apiChannels;
            _apiMonths = apiMonths;
            _apiDays = apiDays;
            _apiLogs = apiLogs;
            _apiUserlogs = apiUserlogs;
            _apiMentions = apiMentions;
        }
        public IApiChannels GetApiChannels() {
            return _apiChannels;
        }
        public IApiMonths GetApiMonths() {
            return _apiMonths;
        }
        public IApiDays GetApiDayss(
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public Dictionary<WorldPos, Dynamic_Object> ground_objects = new Dictionary<WorldPos, Dynamic_Object>();
	public GameObject chunk_prefab;
	public void Create_Chunk(int x, int y, int z) {
		WorldPos world_pos = new WorldPos(x, y, z);
		
		GameObject new_chunk_object = Instantiate(chunk_prefab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
		Chunk new_chunk = new_chunk_object.GetComponent<Chunk>();
		
		new_chunk.pos = world_pos;
		new_chunk.world = this;
		
		chunks.Add(world_pos, new_chunk);
		
		var terrain_gen = new TerrainGen();
		new_chunk = terrain_gen.Chunk_Gen(new_chunk);
	}
	public void Destroy_Chunk(int x, int y, int z) {
		Chunk chunk = null;
		if(chunks.TryGetValue(new WorldPos(x, y, z), out chunk)) {
			Object.Destroy(chunk.gameObject);
			chunks.Remove(new WorldPos(x, y, z));
		}
	}
	public Chunk Get_Chunk(int x, int y, int z) {
		Wor
namespace com.wer.sc.plugin.cnfutures.market
    public class Plugin_MarketUtils_CnFutures : IPlugin_MarketUtils
    {
        public string TransferLocalInstrumentIdToRemote(string localInstrumentId)
        {
            /*
             * 期货合约规则
             * 期货合约的交割日一般是每个月第三个周五
             * 
             * 算法简化了，没超过合约月份就按本年合约算
             * TODO 最好还是优化算法
             */
            if (IsFullInstrument(localInstrumentId))
                return localInstrumentId;
            DateTime date = DateTime.Now;
            int month = date.Month;
            int splitIndex = localInstrumentId.Length - 2;
            int instrumentMonth = int.Parse(localInstrumentId.Substring(splitIndex));
            String instrumentPrefix = localInstrumentId.Substring(0, splitIndex);
            if (month > instrumentMonth)
            {
                string nextyear_suffix = (date.Year + 1).ToString().Substring(2, 2);
                return instrumentPrefix + nextyear_suffix + instrumentMonth.ToSt
namespace Magicolo.AudioTools {
	[System.Serializable]
	public class SamplerItemManager : AudioItemManager {
		public Sampler sampler;
		
		Dictionary<string, SamplerInstrument> instrumentDict;
		
		public SamplerItemManager(Sampler sampler)
			: base(sampler.listener, sampler.infoManager, sampler) {
			
			this.sampler = sampler;
			BuildInstrumentDict();
		}
		public AudioItem Play(string instrumentName, int note, float velocity, object source, params AudioOption[] audioOptions) {
			SamplerInstrument instrument = GetInstrument(instrumentName);
			
			SingleAudioItem audioItem = GetSingleAudioItem(instrument, note, velocity, source);
			if (audioItem == null) {
				return instrument;
			}
			audioItem.Play(audioOptions);
			return audioItem;
		}
		public AudioItem Play(string moduleName, string instrumentName, int note, float velocity, object source, params AudioOption[] audioOptions) {
			PDModule module = player.generalSettings.PdPlayer.itemManager.GetModule(moduleName, source);
		

			SingleAudioItem audioItem = GetPDSingleAudioItem(instrument, note, velocity, source);
			
			if (audioItem == null) {
				return instrument;
			}
			
			if (module.State != AudioStates.Playing) {
				module.Initialize();
				module.Play();
			}
			
			audioItem.Play(audioOptions);
			module.AddAudioItem(audioItem);
			
			return audioItem;
		}
		public virtual SamplerInstrument GetInstrument(string instrumentName) {
			SamplerInstrument instrument = null;
			try {
				instrument = instrumentDict[instrumentName];
			}
			catch {
				Debug.LogError(string.Format("Instrument named {0} was not found.", instrumentName));
			}
			return instrument;
		}
		public virtual SingleAudioItem GetSingleAudioItem(SamplerInstrument instrument, int note, float velocity, object source) {
			if (velocity > 0) {
				SamplerInstrumentLayer layer = instrument.GetLayer(note, velocity);
				SingleAudioItem audioItem = GetSingleAudioItem(layer.Name, source);
				audioItem.audioSource.clip = layer.GetClip();
namespace Rp3.AgendaComercial.Models
    public class ContextService : DbContextManagerService<Context>
    {
        public ContextService()
            : base("Context", true)
        {                     
        }
        private Repository<Frecuencia> frecuenciaRepository;
        private Repository<Cargo> cargoRepository;
        private CanalRepository canalRepository;
        private Repository<Region> regionRepository;
        private TipoClienteRepository tipoClienteRepository;
        private Repository<TipoCartera> tipoCarteraRepository;
        private Repository<TipoActividad> tipoActividadRepository;
        private Repository<TipoActividadOpcion> tipoActividadOpcionRepository;
        private ZonaRepository zonaRepository;
        private Repository<ZonaDetalle> zonaDetalleRepository;
        private Repository<ZonaGeocerca> zonaGeocercaRepository;
        private Repository<ZonaClienteGeocerca> zonaClienteGeocercaRepository;
        
        private AgenteRepository a

        private AgenteUbicacionRepository agenteUbicacionRepository;
        private Repository<AgenteUltimaUbicacion> agenteUltimaUbicacionRepository;
        private Repository<InformeTrazabilidad> informeTrazabilidadRepository;
        private ClienteRepository clienteRepository;
        private Repository<ClienteDato> clienteDatoRepository;
        private Repository<ClienteDireccion> clienteDireccionRepository;
        private Repository<ClienteContacto> clienteContactoRepository;
        private Repository<ClienteView> clienteviewRepository;
        private Repository<TareaResumenView> tarearesumenviewRepository;
        private LoteRepository loteRepository;
        private Repository<LoteDetalle> loteDetalleRepository;
        private Repository<LoteTipoCliente> loteTipoClienteRepository;
        private Repository<LoteCanal> loteCanalRepository;
        private Repository<LoteZona> loteZonaRepository;
        
        private RutaRepository rutaRepository;
        private Rep

        private Repository<RutaIncluir> rutaIncluirRepository;
        private Repository<RutaExcluir> rutaExcluirRepository;
        private Repository<RutaLote> rutaLoteRepository;
        private TareaRepository tareaDetalleRepository;
                
        private Repository<Reunion> reunionRepository;
        private Repository<ReunionAsistente> reunionAsistenteRepository;
        private Repository<Memo> memoRepository;
        private Repository<MemoDestinatario> memoDestinatarioRepository;
        private TareaRepository tareaRepository;
        private Repository<TareaActividad> tareaActividadRepository;
        private Repository<TareaRutaAplica> tareaRutaRepository;
        private Repository<ProgramacionRuta> programacionRutaRepository;
        private Repository<ProgramacionRutaDetalle> programacionRutaDetalleRepository;
        private Repository<ProgramacionRutaTarea> programacionRutaTareaRepository;
        private AgendaRepository agendaRepository;
        private 
namespace Rs.Dnevnik.Ris.Interfaces.Repositories
    public interface IRepositoryFactory : IDisposable
    {
        INovinskeKuceRepository NovinskeKuceRepository { get; } 
        ISektoriRepository SektoriRepository { get; }
        IOdeljenjaRepository OdeljenjaRepository { get; }
        IRadniciRepository RadniciRepository { get; }
        IPublikacijeRepository PublikacijeRepository { get; }
        IRubrikeRepository RubrikeRepository { get; }
        ITipoviTekstovaRepository TipoviTekstovaRepository { get; }
        IOceneRepository OceneRepository { get; }
        IRadniNaloziRepository RadniNaloziRepository { get; }
        IAgencijskeVestiRepository AgencijskeVestiRepository { get; }
        IAgencijeRepository AgencijeRepository { get; }
        IKonfiguracijaRepository KonfiguracijaRepository { get; }
        IKonverzijaRepository KonverzijaRepository { get; }
        IMaterijalRepository MaterijalRepository { get; }
        ITekstoviRepository TekstoviRepository { get; 
namespace TShanTC.Business.QiXiu.Service
    public class WorkShopDispatchService
    {
        private IWorkShopDispatchProcesser _iWorkShopDispatchProcess;
        public WorkShopDispatchService(IWorkShopDispatchProcesser iWorkShopDispatchProcess)
        {
            _iWorkShopDispatchProcess = iWorkShopDispatchProcess;
        }
        public int AddWorkShopDispatch(ClientWorkShopDispatchModel clientWorkShopDispatch)
        {
            if (clientWorkShopDispatch == null)
            {
                return 0;
            }
            var WorkShopDispatchInfo = new WorkShopDispatchEntity()
            {
                ServiceShopId = clientWorkShopDispatch.ServiceShopId,
                ConstructionUnitId = clientWorkShopDispatch.ConstructionUnitId,
                CreateTime = clientWorkShopDispatch.CreateTime,
                Dispatcher = clientWorkShopDispatch.Dispatcher,
                Price = clientWorkShopDispatch.Price,
                ProjectName = clientWorkShopDis

                RepaireCategoryId = clientWorkShopDispatch.RepaireCategoryId,
                ServiceReceptionId = clientWorkShopDispatch.ServiceReceptionId,
                ServiceReceptionTime = clientWorkShopDispatch.ServiceReceptionTime,
                TroubleDesc = clientWorkShopDispatch.TroubleDesc,
                StartTime = clientWorkShopDispatch.StartTime,
                WorkId = clientWorkShopDispatch.WorkId,
                WorkShopDispatchId = clientWorkShopDispatch.WorkShopDispatchId,
                WorkTime = clientWorkShopDispatch.WorkTime,
                Remark = clientWorkShopDispatch.Remark,
            };
            return _iWorkShopDispatchProcess.AddWorkShopDispatch(WorkShopDispatchInfo);
        }
        public QiXiuListResponse<WorkShopDispatchEntity> GetWorkShopDispatchList(ClientWorkShopDispatchListRequest clientWorkShopDispatchListRequest)
        {
            QiXiuListResponse<WorkShopDispatchEntity> WorkShopDispatchList;
            if (clientWorkSh

            {
                WorkShopDispatchList = new QiXiuListResponse<WorkShopDispatchEntity>();
            }
            var WorkShopDispatchListRequest = new WorkShopDispatchListRequest()
            {
                StartRowID = clientWorkShopDispatchListRequest.StartRowID,
                EndRowID = clientWorkShopDispatchListRequest.EndRowID,
                ServiceShopId = clientWorkShopDispatchListRequest.ServiceShopId,
                WorkShopDispatchIds = clientWorkShopDispatchListRequest.WorkShopDispatchIds
            };
            return _iWorkShopDispatchProcess.GetWorkShopDispatchList(WorkShopDispatchListRequest);
        }
        public QiXiuOperateResponse WorkShopDispatchOperate(ClientQiXiuOperateRequest clientOperateRequest)
        {
            QiXiuOperateResponse WorkShopDispatchOperate;
            if (clientOperateRequest == null)
            {
                WorkShopDispatchOperate = new QiXiuOperateResponse();
            }
            var operateReq
namespace OpenQuant.Shared.Data.Import.CSV
  internal class OtherOptions
  {
    private bool createInstrument;
    private bool clearSeries;
    private InstrumentType instrumentType;
    public bool ImportOnlyRange { get; set; }
    public DateTime ImportRangeBegin { get; set; }
    public DateTime ImportRangeEnd { get; set; }
    public bool SkipDataInsideExistingRange { get; set; }
    public bool CreateInstrument
    {
      get
      {
        return this.createInstrument;
      }
      set
      {
        this.createInstrument = value;
      }
    }
    public bool ClearSeries
    {
      get
      {
        return this.clearSeries;
      }
      set
      {
        this.clearSeries = value;
      }
    }
    public InstrumentType InstrumentType
    {
      get
      {
        return this.instrumentType;
      }
      set
      {
        this.instrumentType = value;
      }
    }
    public OtherOptions()
    {
      this.createInstrument = true;
      this.clearSeries = false;

namespace Redux.Database
    public class ConquerDataContext
    {
        private AccountRepository _accountRepository;
        private CharacterRepository _characterRepository;
        private ItemInfoRepository _itemsRepository;
        private ItemAdditionRepository _itemAdditionRepository;
        private ItemRepository _itemRepository;
        private ProficiencyRepository _proficiencyRepository;
        private SkillRepository _skillRepository;
        private MagicTypeRepository _magicTypeRepository;
        private PortalRepository _portalRepository;
        private PassageRepository _passageRepository;
        private MapRepository _mapRepository;
        private NpcRepository _npcRepository;
        private ItemLogRepository _itemLogRepository;
        private ChatLogRepository _chatLogRepository;
        private MonstertypeRepository _monstertypeRepository;
        private SpawnRepository _spawnRepository;
        private StatRepository _statRepository;
        private Drop

        private ShopItemRepository _shopItemRepository;
        private AssociateRepository _associateRepository;
        private GuildRepository _guildRepository;
        private GuildAttrRepository _guildAttrRepository;
        private SobRepository _SOBRepository;
        private EventsRepository _EventsRepository;
        private NobilityRepository _NobilityRepository;
        private RebornRepository _RebornRepository;
        private MineDropRepository _MineDropRepository;
        private LevExpRepository _LevExpRepository;
        private BugReportRepository _bugReportRepository;
        private TaskRepository _taskRepository;
        public MineDropRepository MineDrop
        {
            get { return _MineDropRepository ?? (_MineDropRepository = new MineDropRepository()); }
        }
        public NobilityRepository Nobility
        {
            get { return _NobilityRepository ?? (_NobilityRepository = new NobilityRepository()); }
        }
        public EventsRepository

        {
            get { return _EventsRepository ?? (_EventsRepository = new EventsRepository()); }
        }
        public SobRepository SOB
        {
            get { return _SOBRepository ?? (_SOBRepository = new SobRepository()); }
        }
        public GuildRepository Guilds
        {
            get { return _guildRepository ?? (_guildRepository = new GuildRepository()); }
        }
        public GuildAttrRepository GuildAttributes
        {
            get { return _guildAttrRepository ?? (_guildAttrRepository = new GuildAttrRepository()); }
        }
        public AccountRepository Accounts
        {
            get { return _accountRepository ?? (_accountRepository = new AccountRepository()); }
        }
        public CharacterRepository Characters
        {
            get { return _characterRepository ?? (_characterRepository = new CharacterRepository()); }
        }
        public AssociateRepository Associates
        {
            get { return _associateRepos
public class Map : MonoBehaviour {
    public Dictionary<VoxelPosition, Chunk> loadedChunks = new Dictionary<VoxelPosition, Chunk>();
    public GameObject chunkPrefab;
	public MaterialList mapMaterials;
    float scaleFactor = 1;
    int chunkSize = 16;
    public void SpawnChunk(int x, int y, int z)
    {
        VoxelPosition worldPos = new VoxelPosition(x, y, z);
        if (loadedChunks.ContainsKey(worldPos)) { return; }
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x * scaleFactor, y * scaleFactor, z * scaleFactor),
                        Quaternion.Euler(Vector3.zero),
                        this.transform
                    ) as GameObject;
        newChunkObject.name = "Chunk at (" + x + ", " + y + ", " + z + ")";
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.position = worldPos;
        newChunk.map = this;
        newChunk.MoveIntoPlace();
        newChunk.scaleFactor = scaleFactor;
    

        loadedChunks.Add(worldPos, newChunk);
    }
    public VoxelData GetVoxel(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            VoxelData voxel = containerChunk[
                x - containerChunk.position.x,
                y - containerChunk.position.y,
                z - containerChunk.position.z];
            return voxel;
        }
        else
        {
            return new VoxelData(0);
        }
    }
    public void SetVoxel(int x, int y, int z, VoxelData voxel)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk == null) { return; }
        chunk[x - chunk.position.x, y - chunk.position.y, z - chunk.position.z] = voxel;
        UpdateIfEqual(x - chunk.position.x, 0, new VoxelPosition(x - 1, y, z));
        UpdateIfEqual(x - chunk.position.x, chunkSize - 1, new VoxelPosition(x + 1, y, z));
        UpdateIfEqual(y - chunk.position.y, 0, new VoxelPosition(x, y - 1, z));
    

        UpdateIfEqual(z - chunk.position.z, 0, new VoxelPosition(x, y, z - 1));
        UpdateIfEqual(z - chunk.position.z, chunkSize - 1, new VoxelPosition(x, y, z + 1));
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        VoxelPosition pos = new VoxelPosition();
        float multiple = chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * chunkSize;
        Chunk containerChunk = null;
        loadedChunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    private void UpdateIfEqual(int value1, int value2, VoxelPosition pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z);
            if (chunk != null) chunk.ForceUpdate();
        }
    }
    private void Start()
    {
        for (int x = -4; x < 4; x++)
        {
            for (int y = 0; y < 1; y++)
       
namespace DB_Talk.DAL
    public partial class v_DispatchLogEx
    {
        public v_DispatchLogEx()
        { }
        #region  Method
        public DataSet GetList(string strWhere)
        {
            StringBuilder strSql = new StringBuilder();
            strSql.Append("select *,");
            strSql.Append("(case  when  DispatchTypeID=0 then '' " +
                                 "when  DispatchTypeID=1 then '打电话' " +
                                 "when  DispatchTypeID=2 then '创建会议'" +
                                 "when  DispatchTypeID=3 then '挂断'" +
                                 "when  DispatchTypeID=4 then '强插' " +
                                 "when  DispatchTypeID=5 then '代答' " +
                                 "when  DispatchTypeID=6 then '保持'" +
                                 "when  DispatchTypeID=7 then '应答'" +
                                 "when  DispatchTypeID=8 then '转接' " +
                                 "when  DispatchTypeID=9 then '强拆' " +
 

                                 "when  DispatchTypeID=11 then '增加会议成员'" +
                                 "when  DispatchTypeID=12 then '会议禁言' " +
                                 "when  DispatchTypeID=13 then '解除会议禁言' " +
                                 "when  DispatchTypeID=14 then '隔离会议成员'" +
                                 "when  DispatchTypeID=15 then '解除隔离会议成员'" +
                                 "when  DispatchTypeID=16 then '踢出会议成员' " +
                                 "when  DispatchTypeID=17 then '结束会议' " +
                                 "when  DispatchTypeID=18 then '录音'" +
                                 "when  DispatchTypeID=19 then '结束录音'" +
                                 "when  DispatchTypeID=20 then '会议分组操作,开始结束操作' " +
                                 "else '' end) as ActionType");
            strSql.Append(" FROM  v_DispatchLog ");
            if (strWhere.Trim() != "")
            {
                strSql.Append(" where " + strWhere);
            }
         
public class TerrainGenerator
		public static void generate (World world, Chunk chunk)
		{
				for (int x = 0; x < world.ChunkX; x++) {
						for (int z = 0; z < world.ChunkZ; z++) {
								
								float seed = 0.035f;
								float terrain = 0.01f;
								float waterlevel = world.ChunkY / 4;
								int height = (int)(SimplexNoise.noise ((chunk.WorldX + x) * terrain, (chunk.WorldZ + z) * terrain) * world.ChunkY / 12) + (world.ChunkY / 3);								
								for (int y = 0; y < height; y++) {
										chunk.SetBlock (new Grass (), x, y, z);
								}
								if (height < waterlevel) {
										for (int y = height; y < waterlevel; y++) {
												chunk.SetBlock (new Water (), x, y, z);				
										}
								}
								/*
								for (int y = 0; y < height; y++) {										
										if (y < bottom) {
												chunk.SetBlock (new Element (), x, y, z);
										} else if (y < top && SimplexNoise.noise ((chunk.WorldX + x) * seed, y * seed, (chunk.WorldZ + z) * seed) > 0) {
						
namespace JobProcessor.Implementation
    class QueueJobChunkDispatcher : IJobChunkDispatcher
    {
        #region Data Members
        private CloudQueue _queue;
        private IJobChunkRegistrator _jobChunkRegistrator;
        #endregion Data Members
        #region Ctor
        public QueueJobChunkDispatcher(IJobChunkRegistrator jobChunkRegistrator)
        {
            _jobChunkRegistrator = jobChunkRegistrator;
            _queue = AzureClient.Instance.QueueClient.GetQueueReference(RoleSettings.JobsChunksQueueName);
            _queue.CreateIfNotExist();
        }
        #endregion Ctor
        #region Public Methods
        public void Dispatch(JobChunk chunk)
        {
            var jsonChunk = chunk.ToJson();
            Logger.Log.Instance.Info(string.Format("QueueJobChunkDispatcher. Dispatch chunk. JobId '{0}', ChunkId '{1}', JSON:\n{2}",
                chunk.ChunkUid.JobId,
                chunk.ChunkUid.ChunkId,
                jsonChunk));
            _queue.AddMess
namespace StoneCastle.Domain
    public interface IUnitOfWork
    {
        int SaveChanges();
        ICountryRepository CountryRepository { get; }
        ITimezoneRepository TimezoneRepository { get; }
        IProfileRepository ProfileRepository { get; }
        IAccountRepository AccountRepository  { get; }
        ITeacherRepository TeacherRepository { get; }
        IClassGroupRepository ClassGroupRepository { get; }
        IClassRoomRepository ClassRoomRepository { get; }
        IClassCourseRepository ClassCourseRepository { get; }
        IDivisionRepository DivisionRepository { get; }
        IOrganizationRepository OrganizationRepository { get; }
        ISemesterRepository SemesterRepository { get; }
        ISubjectGroupRepository SubjectGroupRepository { get; }
        ISubjectRepository SubjectRepository { get; }
        IBuildingRepository BuildingRepository { get; }
        IRoomRepository RoomRepository { get; }
        ITeacherDivisionRepository TeacherDivisionRepo
namespace ViniSandboxTools
    public static class ProcessExtensions
    {
        private static string FindIndexedProcessName(int pid)
        {
            var processName = Process.GetProcessById(pid).ProcessName;
            var processesByName = Process.GetProcessesByName(processName);
            string processIndexdName = null;
            for (var index = 0; index < processesByName.Length; index++)
            {
                processIndexdName = index == 0 ? processName : processName + "#" + index;
                var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
                if ((int)processId.NextValue() == pid)
                {
                    return processIndexdName;
                }
            }
            return processIndexdName;
        }
        private static Process FindPidFromIndexedProcessName(string indexedProcessName)
        {
            var parentId = new PerformanceCounter("Process", "Creating Process ID", inde
namespace WorkoutDemo.Core
	public static class ApiConstants
	{
		public const int MaxRetryTime = 2;
	}
	public static class ApiUrls
	{
		public const string ApiV1 = Root + "/v1";
		public const string Api = Root + "/api";
		public const string ApiToken = Root + "/token";
		public const string Register = Api + "/Account/Register";
		public const string User = Root + "/v1/user/api/user";
		public const string GetActivites = ApiV1 + "/activity/api/feed/list";
		public const string OwnerEvent = ApiV1 + "/event/api/owner/eventlist/";
		public const string OwnerEventDetails = ApiV1 + "/event/api/owner/event/";
		public const string EventSender = ApiV1 + "/event/api/sender/event";
		public const string DeleteActivity = ApiV1 + "/activity/api/feed/";
		public const string DeleteEvent = ApiV1 + "/activity/api/activity/";
		public const string Message = ApiV1 + "/message/api/message/list";
		public const string MySplash = ApiV1 + "/splash/api/tile/top";
		public const string GetComment = ApiV1 

		public const string DeleteMessage = ApiV1 + "/message/api/message/";
		public const string PostComment = ApiV1 + "/comment/api/post/tile";
		public const string GetHomeStatus = ApiV1 + "/construction/api/home/status";
		public const string DeleteComment = ApiV1 + "/comment/api/comment/";
		public const string GetPersonList = ApiV1 + "/home/api/sites/builder/user/correspondents";
		public const string PostSplash = ApiV1 + "/splash/api/tile/post";
		public const string PostDeviceId = ApiV1 + "/user/api/device/set";
		public const string GetHomeTimeline = ApiV1 + "/construction/api/home/status/timeline";
		public const string UpdateProfile = ApiV1 + "/user/api/user/set/profile";
		public const string PostNewEvent = ApiV1 + "/event/api/sender/event/post";
		public const string PostMessage = ApiV1 + "/message/api/message/post";
		public const string ConfirmAccept = ApiV1 + "/event/api/event/acceptances";
		public const string GetHomeOwnerId = ApiV1 + "/home/api/sites/homeowner/correspond
#if __UNIFIED__
#else
#endif
namespace DateTimeNumberPickerForms.iOS.SourceCode.ModalPicker
    internal static class ModalPickerExtensions
    {
        #region Methods
        public static void PresentUsingRootViewController(this UIViewController controller)
        {
            if (controller == null)
                throw new ArgumentNullException(nameof(controller));
            var visibleViewController = GetVisibleViewController(null);
            visibleViewController?.PresentViewController(controller, true, () => { });
        }
        private static UIViewController GetVisibleViewController(UIViewController controller)
        {
            if (controller == null)
            {
                controller = UIApplication.SharedApplication.KeyWindow.RootViewController;
            }
            if (controller?.NavigationController?.VisibleViewController != null)
            {
                return controller.NavigationController.VisibleViewController;
            }
        
namespace Proyecto.controladores
    public class MasterController
    {
        public MasterController(MasterViewController masterViewController)
        {
            NotificationMessagess notificationMessages = new NotificationMessagess();
            MySQLContection SQLService = new MySQLContection();
            SQLService.setNotificationMessages(notificationMessages);
            ModeloController modeloBusinessController = new ModeloController();
            ModeloViewController modeloViewController = new ModeloViewController();
            modeloBusinessController.setSQLService(SQLService);
            modeloBusinessController.setPresenter(modeloViewController);
            modeloViewController.setBusinessController(modeloBusinessController);
            TipoController tipoBusinessController = new TipoController();
            TipoViewController tipoViewController = new TipoViewController();
            tipoBusinessController.setSQLService(SQLService);
            tipoBusinessC

            tipoViewController.setBusinessController(tipoBusinessController);
            ProductoController productoBusinessController = new ProductoController();
            ProductoViewController productoViewController = new ProductoViewController();
            productoBusinessController.setSQLService(SQLService);
            productoBusinessController.setPresenter(productoViewController);
            productoViewController.setBusinessController(productoBusinessController);
            productoViewController.setBusinessController(tipoBusinessController);
            productoViewController.setBusinessController(modeloBusinessController);
            VentaController ventaBusinessController = new VentaController();
            VentaViewController ventaViewController = new VentaViewController();
            ventaBusinessController.setSQLService(SQLService);
            ventaBusinessController.setPresenter(ventaViewController);
            ventaViewController.setBusinessController(vent

            ventaViewController.setBusinessController(productoBusinessController);
            LoginViewController loginViewController = new LoginViewController();
            loginViewController.setMasterViewController(masterViewController);
            InventoryViewController inventoryViewController = new InventoryViewController();
            inventoryViewController.setBusinessController(productoBusinessController);
            CorteDiaViewController corteDiaViewController = new CorteDiaViewController();
            corteDiaViewController.setBusinessController(ventaBusinessController);
            CorteMensualViewController corteMensualViewController = new CorteMensualViewController();
            corteMensualViewController.setBusinessController(ventaBusinessController);
            
            masterViewController.setViewController(modeloViewController);
            masterViewController.setViewController(inventoryViewController);
            masterViewController.setViewController
namespace RepositoryPattern.Areas.Admin.Controllers
    public class HomeController : BaseController
    {
        public HomeController(ICategoryRepository categoryRepository
            , IProductRepository productRepository, IPictureRepository pictureRepository,
            IOrderRepository orderRepository, IOrderItemsRepository orderItemRepository,
            IUserRepository userRepository, IProductVariationRepository prdVariationRepo, ICustomerInfoRepository customerRepository)
        {
            this._categoryRepository = categoryRepository;
            this._productRepository = productRepository;
            this._pictureRepository = pictureRepository;
            this._orderRepository = orderRepository;
            this._orderItemRepository = orderItemRepository;
            this._userRepository = userRepository;
            this._prdVariationRepo = prdVariationRepo;
            this._customerRepository = customerRepository;
        }
        private readonly ICategoryRepos

        private readonly IProductRepository _productRepository;
        private readonly IPictureRepository _pictureRepository;
        private readonly IOrderRepository _orderRepository;
        private readonly IOrderItemsRepository _orderItemRepository;
        private readonly IUserRepository _userRepository;
        private readonly IProductVariationRepository _prdVariationRepo;
        private readonly ICustomerInfoRepository _customerRepository;
        
        [Authorize(Roles = "Admin")]
        public ActionResult Index()
        {
            var product = _productRepository.GetAllProduct().Count();
            var customer = _customerRepository.GetAllCustomersInfo().Count();
            var orderItem = _orderItemRepository.GetAllOrderItems().Count();
            var homeDisplay = new HomeDisplay
                                {
                                    CustomerCount = customer,
                                    WishListCount = orderItem,
                    
namespace COSC4210.MusicalIntruments.Web.Instruments
    public class MusicalInstrumentPortal : IMusicalInstrumentPortal
    {
        public void SaveInstrumentType(InstrumentType instrumentType)
        {
            DanielsEntities context = new DanielsEntities();
            COSC4210.MusicalIntruments.Web.Models.Type instrumentItemType = new COSC4210.MusicalIntruments.Web.Models.Type();
            if (instrumentType.ID != 0)
            {
                var etItemType = from t in context.Types
                                 where t.ID == instrumentType.ID
                                 select t;
                instrumentItemType = etItemType.FirstOrDefault();
                instrumentItemType.TypeName = instrumentType.TypeName;
            }
            else
            {
                instrumentItemType.TypeName = instrumentType.TypeName;
                context.Types.Add(instrumentItemType);
            }
            instrumentItemType.LastModified = DateTime.Now;
     

            context.SaveChanges();
        }
        public InstrumentType GetInstrumentType(int ID)
        {
            DanielsEntities context = new DanielsEntities();
            InstrumentType instrumentType = null;
            var queryType = from t in context.Types
                            where t.ID == ID
                            select new InstrumentType
                            {
                                ID = t.ID,
                                TypeName = t.TypeName
                            };
            instrumentType = queryType.FirstOrDefault();
            return instrumentType;
        }
        public IList<InstrumentType> GetInstrumentTypes()
        {
            DanielsEntities context = new DanielsEntities();
            IQueryable<InstrumentType> queryTypes = from t in context.Types
                                                    orderby t.TypeName
                                                    select new Data_Contracts.InstrumentTy

                                                    {
                                                        ID = t.ID,
                                                        TypeName = t.TypeName
                                                    };
            return queryTypes.ToList();
        }
        public void SaveInstrumentCategory(InstrumentCategory instrumentCategory)
        {
            DanielsEntities context = new DanielsEntities();
            COSC4210.MusicalIntruments.Web.Models.Category instrumentItemCategory = new COSC4210.MusicalIntruments.Web.Models.Category();
            if (instrumentCategory.ID != 0)
            {
                var etItemCategory = from t in context.Categories
                                     where t.ID == instrumentCategory.ID
                                     select t;
                instrumentItemCategory = etItemCategory.FirstOrDefault();
                instrumentItemCategory.CategoryName = instrumentCategory.InstrumentCat
namespace ContainerViews
    public partial class TransitionSegue : UIStoryboardSegue
    {
        public TransitionSegue (IntPtr handle) : base (handle)
        {
        }
        public override void Perform()
        {
            if (SourceViewController.ChildViewControllers.Length > 0)
            {
                SwapFromViewController(SourceViewController.ChildViewControllers[0], DestinationViewController);
            }
            else
            {
                AddInitialViewController(DestinationViewController);
            }
        }
        private void AddInitialViewController(UIViewController viewController)
        {
            SourceViewController.AddChildViewController(viewController);
            viewController.View.Frame = SourceViewController.View.Bounds;
            SourceViewController.Add(viewController.View);
            viewController.DidMoveToParentViewController(SourceViewController);
            var containerViewController = SourceViewController as 

            if(containerViewController != null)
                containerViewController.ViewChanging.TrySetResult(true);
        }
        private void SwapFromViewController(UIViewController fromViewController,
                                            UIViewController toViewController)
        {
            fromViewController.WillMoveToParentViewController(null);
            toViewController.View.Frame = SourceViewController.View.Bounds;
            SourceViewController.AddChildViewController(toViewController);
            SourceViewController.Transition(fromViewController,
                       toViewController,
                       0.3,
                       UIViewAnimationOptions.TransitionCrossDissolve,
                       () => { },
                       (bool finished) =>
                        {
                            fromViewController.RemoveFromParentViewController();
                            toViewController.DidMoveToParentViewController(SourceViewContro
public class TerrainGen {
    private float peakDistance = .01f;
    private static Perlin perlin = new Perlin();
    public TerrainGen(int seed) {
    }
    private void shuffle(byte[] perm) {
        for (int t = 0; t < perm.Length / 2; t++) {
            byte tmp = perm[t];
            int r = Random.Range(t, perm.Length / 2);
            perm[t] = perm[r];
            perm[t + 256] = perm[r + 256];
            perm[r] = tmp;
            perm[r + 256] = tmp;
        }
    }
    public virtual Chunk ChunkGen(Chunk chunk) {
        for (int x = chunk.pos.x; x < chunk.pos.x + Chunk.chunkSize; x++) {
            for (int z = chunk.pos.z; z < chunk.pos.z + Chunk.chunkSize; z++) {
                ChunkColumnGen(chunk, x, z);
            }
        }
        return chunk;
    }
    int print = 0;
    public virtual void ChunkColumnGen(Chunk chunk, int x, int z) {
        for (int y = chunk.pos.y; y < chunk.pos.y + Chunk.chunkSize; y++) {
            double height = GetNoise(x, y, z, peakDis
namespace training.tests
    [TestFixture]
    public class InstrumentRepositoryTests
    {
        private IInstrumentRepository _repository;
        [SetUp]
        public void SetUp()
        {
            _repository = new MyInstrumentRepository();
        }
        [Test]
        public void TestThatItsNotPossibleToAddTwiceTheSameInstrument()
        {
            var instrument = new Instrument("Instrument1", InstrumentType.Bond);
            _repository.AddInstrument(instrument);
            Assert.Throws<InvalidOperationException>(() => _repository.AddInstrument(instrument));
        }
        [TestCase("Instrument1")]
        [TestCase("Instrument2")]
        public void TestGetInstrument(string instrumentName)
        {
            var instrument = new Instrument(instrumentName, InstrumentType.Bond);
            _repository.AddInstrument(instrument);
            Assert.AreEqual(instrument, _repository.GetInstrument(instrumentName));
        }
        
        [Test]
        p

        {
            Assert.Throws<InvalidOperationException>(() => _repository.GetInstrument("InstrumentA"));
        }
        [Test]
        public void TestGetInstruments()
        {
            _repository.AddInstrument(new Instrument("Instrument1", InstrumentType.Bond));
            _repository.AddInstrument(new Instrument("Instrument2", InstrumentType.Forex));
            Assert.AreEqual(2, _repository.GetInstruments().Count());
        }
        [Test]
        public void TestInit()
        {
            _repository.Init(5000);
            Assert.AreEqual(5000, _repository.GetInstruments().Count(instrument => instrument.Type == InstrumentType.Bond));
            Assert.AreEqual(5000, _repository.GetInstruments().Count(instrument => instrument.Type == InstrumentType.Forex));
        }
        [TestCase("bond_1", 100.0)]
        public void TestPriceUpdate(string key, double price)
        {
            _repository.Init(5000);
            _repository.PriceUpdate(key, price);
  
public class World : MonoBehaviour
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        bool loaded = Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out ch

        {
            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        els

        {
            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
        }
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z)
namespace GameWorld.Voxel
	public class World : MonoBehaviour
	{
		public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
		public GameObject chunkPrefab;
		public void CreateChunk(int x, int y, int z)
		{
			WorldPos worldPos = new WorldPos(x, y, z);
			GameObject newChunkObject = Instantiate(chunkPrefab, new Vector3(x, y, z), Quaternion.Euler(Vector3.zero)) as GameObject;
			Chunk newChunk = newChunkObject.GetComponent<Chunk>();
			newChunk.pos = worldPos;
			newChunk.world = this;
			chunks.Add(worldPos, newChunk);
			WorldGenerator worldGen = new WorldGenerator();
			newChunk = worldGen.ChunkGen(newChunk);
		}
		public Chunk GetChunk(int x, int y, int z)
		{
			WorldPos pos = new WorldPos();
			float multiple = Chunk.ChunkSize;
			pos.X = Mathf.FloorToInt(x / multiple) * Chunk.ChunkSize;
			pos.Y = Mathf.FloorToInt(y / multiple) * Chunk.ChunkSize;
			pos.Z = Mathf.FloorToInt(z / multiple) * Chunk.ChunkSize;
			Chunk containerChunk = null;
			chunks.TryGetVal
namespace TMS.Service.UnitTest
    
    
    [TestClass()]
    public class IPreDispatchBLLTest
    {
        private TestContext testContextInstance;
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }
        #region 附加测试特性
        #endregion
        internal virtual IPreDispatchBLL CreateIPreDispatchBLL()
        {
            IPreDispatchBLL target = ServiceFactory.GetService<IPreDispatchBLL>("PreDispatchBLL"); ;
            return target;
        }
        [TestMethod()]
        public void GetPreDispatchBoxListTest()
        {
            List<ViewDispatchBoxModel> actual;
            actual = target.GetPreDispatchBoxList(LPID);
            Assert.AreEqual(expected, actual);
            Assert.Inconclusive("验证此测试方法的正确性。");
        }
        [TestMethod()]
        public void PreDispatchTest()
      
public abstract class ChunkController : MonoBehaviour {
    internal Voxelmetric vm;
    [SerializeField]
    private int _chunkPower = 4;
    [HideInInspector]
    public int chunkSize;
    [HideInInspector]
    public int chunkPower;
    [SerializeField]
    private float _blockSize = 1;
    [HideInInspector]
    public float blockSize;
    public virtual void Initialize(Voxelmetric vm)
    {
        this.vm = vm;
        chunkPower = _chunkPower;
        chunkSize = 1 << chunkPower;
        blockSize = _blockSize;
    }
    public virtual void Destroy(Pos chunkPos)
    {
        Chunk chunk = GetChunk(chunkPos);
        if (chunk != null) Destroy(chunk);
    }
    public abstract void Destroy(Chunk chunk);
    public abstract Chunk GetChunk(Pos chunkPos);
    public abstract Block GetBlock(Pos blockPos);
    public virtual void SetBlock(Pos blockPos, Block block)
    {
        Chunk chunk = GetChunk(blockPos);
        if (chunk != null)
        {
            chunk.SetBlock(block, bl

        }
    }
    public virtual Chunk CreateChunk(Pos pos)
    {
        pos = GetChunkPos(pos);
        Chunk chunk;
        GameObject chunkGO = new GameObject("Chunk at " + pos, new Type[] {
            vm.components.chunkType.GetType()
        });
        chunk = chunkGO.GetComponent<Chunk>();
        chunk.VmStart(pos, this);
        return chunk;
    }
    public virtual Pos GetBlockPos(Vector3 point)
    {
        point -= transform.position;
        point = Quaternion.Inverse(transform.rotation) * point;
        point /= vm.components.chunks.blockSize;
        return new Pos(Mathf.RoundToInt(point.x), Mathf.RoundToInt(point.y), Mathf.RoundToInt(point.z));
    }
    public virtual Vector3 GetWorldPos(Pos blockPos)
    {
        return (transform.rotation * blockPos) + transform.position;
    }
    public virtual Pos GetChunkPos(Pos blockPos)
    {
        return new Pos((blockPos.x >> chunkPower) << chunkPower,
                               (blockPos.y >> chunkPower) << chu
public class GameModelView : MonoBehaviour, IGame {
    private CameraController cameraControllerValue;
    public CameraController CameraController
    {
        get
        {
            return cameraControllerValue;
        }
        set
        {
            cameraControllerValue = value;
        }
    }
    private CharacterController characterControllerValue;
    public CharacterController CharacterController
    {
        get
        {
            return characterControllerValue;
        }
        set
        {
            characterControllerValue = value;
        }
    }
    private SceneController sceneControllerValue;
    public SceneController SceneController
    {
        get
        {
            return sceneControllerValue;
        }
        set
        {
            sceneControllerValue = value;
        }
    }
    public void InitCharacter(GameController gameController)
    {
        CharacterController = new CharacterController(gameController);
        CharacterControl
﻿namespace SDK.Lib
    /**
     * @brief 非引用计数资源加载结果通知
     */
    public class ResLoadResultNotify
    {
        public ResLoadResultNotify()
        {
            this.mResLoadState = new ResLoadState();
            this.mLoadResEventDispatch = new ResEventDispatch();
        }
        public ResLoadState resLoadState
        {
            get
            {
                return this.mResLoadState;
            }
            set
            {
                this.mResLoadState = value;
            }
        }
        public ResEventDispatch loadResEventDispatch
        {
            get
            {
                return this.mLoadResEventDispatch;
            }
            set
            {
                this.mLoadResEventDispatch = value;
            }
        }
        public void onLoadEventHandle(IDispatchObject dispObj)
        {
            this.mLoadResEventDispatch.dispatchEvent(dispObj);
            this.mLoadResEventDispatch.clearEventHandle();
        }
        virtua
namespace OpenQuant.API
    public class Instrument
    {
        private const string CATEGORY_APPEARANCE = "Appearance";
        private const string CATEGORY_APPEARANCE_ALTERNATIVE = "Appearance (alternative)";
        private const string CATEGORY_DERIVATIVE = "Derivative";
        private const string CATEGORY_MARGIN = "Margin";
        private const string CATEGORY_INDUSTRY = "Industry";
        private const string CATEGORY_DISPLAY = "Display";
        private const string CATEGORY_TICK_SIZE = "TickSize";
        internal FreeQuant.Instruments.Instrument instrument;
        private OrderBook book;
        [Description("Instrument symbol")]
        [Category("Appearance")]
        public string Symbol
        {
            get
            {
                return this.instrument.Symbol;
            }
        }
        [Description("Instrument Type (Stock, Futures, Option, Bond, ETF, Index, etc.)")]
        [Category("Appearance")]
        public InstrumentType Type
        {
    

            {
                return EnumConverter.Convert(this.instrument.SecurityType);
            }
        }
        [Description("Instrument description")]
        [Category("Appearance")]
        public string Description
        {
            get
            {
                return this.instrument.SecurityDesc;
            }
            set
            {
                this.instrument.SecurityDesc = value;
                this.instrument.Save();
            }
        }
        [Category("Appearance")]
        [Description("Instrument exchange")]
        public string Exchange
        {
            get
            {
                return this.instrument.SecurityExchange;
            }
            set
            {
                this.instrument.SecurityExchange = value;
                this.instrument.Save();
            }
        }
        [Category("Appearance")]
        [Description("Instrument currency code (USD, EUR, RUR, CAD, etc.)")]
        public string Currency
  

            get
            {
                return this.instrument.Currency;
            }
            set
            {
                this.instrument.Currency = value;
                this.instrument.Save();
            }
        }
        [Category("Appearance (alternative)")]
        [Editor(typeof(AltIDGroupListEditor), typeof(UITypeEditor))]
        [Description("Instrument alternative symbol")]
        [TypeConverter(typeof(AltIDGroupListTypeConverter))]
        [RefreshProperties(RefreshProperties.All)]
        public AltIDGroupList AltIDGroups { get; private set; }
        [Obsolete("Use Instrument.AltIDGroups property instead")]
        [Category("Appearance (alternative)")]
        [Description("Instrument alternative symbol")]
        [Browsable(false)]
        public string AltSymbol
        {
            get
            {
                if (this.instrument.SecurityAltIDGroup.Count == 0)
                    return string.Empty;
                else
                   
namespace InstrumentApp
    class Instrument
    {
        #region Properties
        internal string serialNumber { get; }
        internal double price { get; set; }
        internal InstrumentSpec spec { get; }
        internal InstrumentType instrumentType { get; }
        #endregion
        private InstrumentType getInstrumentType(InstrumentSpec spec)
        {
            object instrumentType = spec.getProperty("instrumentType");
            if (instrumentType is InstrumentType)
            {
                return (InstrumentType)instrumentType;
            }
            return InstrumentType.Unspecified;
        }
        #region Initialization
        public Instrument(string serialNumber,
                          double price,
                          InstrumentSpec spec)
        {
            this.serialNumber = serialNumber;
            this.price = price;
            this.spec = spec;
            this.instrumentType = getInstrumentType(spec);
        }
        #endregio
namespace IronAHK.Scripting
    partial class Parser
    {
        bool IsOptimisableExpression(CodeExpression expr)
        {
            if (!(expr is CodeMethodInvokeExpression))
                return false;
            var invoke = (CodeMethodInvokeExpression)expr;
            return invoke.Method.MethodName == InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3;
        }
        CodeExpression OptimiseExpression(CodeExpression expr)
        {
            if (!IsOptimisableExpression(expr))
                return expr;
            var invoke = (CodeMethodInvokeExpression)expr;
            for (int i = 1; i < 3; i++)
                invoke.Parameters[i] = OptimiseExpression(invoke.Parameters[i]);
            if (invoke.Parameters[1] is CodePrimitiveExpression && invoke.Parameters[2] is CodePrimitiveExpression)
            {
                object result = null;
                try
                {
                    result = Script.Operate((Script.Operator)invoke.

                        ((CodePrimitiveExpression)invoke.Parameters[1]).Value,
                        ((CodePrimitiveExpression)invoke.Parameters[2]).Value);
                }
                catch (Exception) { }
                return new CodePrimitiveExpression(result);
            }
            return invoke;
        }
        CodeExpression OptimiseLoneExpression(CodeExpression expr)
        {
            if (IsVarAssignment(expr))
            {
                var assign = (CodeBinaryOperatorExpression)expr;
                assign.Right = OptimiseExpression(assign.Right);
                return assign;
            }
            if (!IsOptimisableExpression(expr))
                return expr;
            var invoke = (CodeMethodInvokeExpression)expr;
            for (int i = 1; i < 3; i++)
                invoke.Parameters[i] = OptimiseExpression(invoke.Parameters[i]);
            bool left = invoke.Parameters[1] is CodePrimitiveExpression, right = invoke.Parameters[2] is CodeEx
namespace RevolutionEntities.Process
    public class SystemProcess : Process, ISystemProcess
    {
        public SystemProcess(IProcess process, IMachineInfo machineInfo) : base(process.Id,process.ParentProcessId,process.Name,process.Description, process.Symbol, process.User)
        {
            MachineInfo = machineInfo;
        }
        public SystemProcess(IProcessInfo processInfo, IUser user, IMachineInfo machineInfo) : base(processInfo.Id, processInfo.ParentProcessId, processInfo.Name, processInfo.Description, processInfo.Symbol, user)
        {
            MachineInfo = machineInfo;
        }
        public IMachineInfo MachineInfo { get; }
   
    }
    public class ProcessState : IProcessState
    {
        public ProcessState(ISystemProcess process, IProcessStateInfo stateInfo)
        {
            StateInfo = stateInfo;
            Process = process;
            ProcessId = process.Id;
        }
        public int ProcessId { get; }
        public IProcessStateInfo Stat
namespace UnityMesh
    public class ColorsChunk : Chunk
    {
        const int COLOR_SIZE = sizeof(int);
        protected override void ReadChunk(byte[] chunkData, ref Mesh mesh)
        {
            var chunkLength = chunkData.Length;
            var colors = new Color32[chunkLength / COLOR_SIZE];
            for (var i = 0; i < colors.Length; i ++)
            {
                colors[i] = new Color32(chunkData[i * 4], chunkData[i * 4 + 1], chunkData[i * 4 + 2], chunkData[i * 4 + 3]);
            }
            mesh.colors32 = colors;
        }
        protected override void WriteChunk(out byte[] chunkData, Mesh mesh)
        {
            var colors = mesh.colors32;
            var chunkLength = colors.Length * COLOR_SIZE;
            chunkData = new byte[chunkLength];
            for (var i = 0; i < colors.Length; i++)
            {
                var color = colors[i];
                chunkData[i*4] = color.r;
                chunkData[i*4 + 1] = color.g;
                chun
namespace Assets.Code.World
    public class World : MonoBehaviour
    {
        public Dictionary<Position, Chunk> Chunks = new Dictionary<Position, Chunk>();
        public static World Instance;
        public GameObject ChunkPrefab;
        public GameObject ColliderCube;
        public static Generator Generator;
        
        public void CreateNewChunkCallback(Position position, Chunk chunk)
        {
            Chunks[position] = chunk;
        }
        
        void Awake()
        {
            Instance = this;
            Generator = new Generator();
        }
        void Start()
        {
            Generator.Start();
        }
        
        void OnDestroy()
        {
            Generator.Abort();
        }
        
        public Chunk GetChunk(Position position)
        {
            Position snappedPosition = new Position
            {
                x = Mathf.FloorToInt(position.x/(float) WorldSettings.ChunkSize)*WorldSettings.ChunkSize,
                y = M

                z = Mathf.FloorToInt(position.z/(float) WorldSettings.ChunkSize)*WorldSettings.ChunkSize
            };
            Chunk containerChunk;
            Chunks.TryGetValue(snappedPosition, out containerChunk);
            return containerChunk;
        }
        public WorldObject GetObject(Position position)
        {
            Chunk containerChunk = GetChunk(position);
            if (containerChunk != null)
            {
                WorldObject block = containerChunk.GetObject(position - containerChunk.Position);
                return block;
            }
            
            return new Air();
        }
        public void SetObject(Position position, WorldObject worldObject, bool replace = false)
        {
            Chunk chunk = GetChunk(position);
            
            if (chunk != null)
            {
                chunk.SetObject(position, worldObject, replace);
                UpdateIfNeighbour(position.x - chunk.Position.x, 0, new Position(posit

                UpdateIfNeighbour(position.x - chunk.Position.x, WorldSettings.ChunkSize - 1, new Position(position.x + 1, position.y, position.z));
                UpdateIfNeighbour(position.y - chunk.Position.y, 0, new Position(position.x, position.y - 1, position.z));
                UpdateIfNeighbour(position.y - chunk.Position.y, WorldSettings.ChunkSize - 1, new Position(position.x, position.y + 1, position.z));
                UpdateIfNeighbour(position.z - chunk.Position.z, 0, new Position(position.x, position.y, position.z - 1));
                UpdateIfNeighbour(position.z - chunk.Position.z, WorldSettings.ChunkSize - 1, new Position(position.x, position.y, position.z + 1));
            }
        }
        void UpdateIfNeighbour(int value1, int value2, Position position)
        {
            if (value1 == value2)
            {
                Chunk chunk = GetChunk(position);
                if (chunk != null)
                    chunk.DoRebuild();
            }
        }
  
namespace ECmmerce.Data.Infrasctructure
    public interface IUnitOfWork : IDisposable
    { 
        void Commit();
     
        
   
IAddressRepository AddressRepository { get; }
ICategoryRepository CategoryRepository { get; }
ICommisionRepository   CommisionRepository    { get; } 
ICreditCardRepository CreditCardRepository{ get; }
IGouvernoratRepository GouvernoratRepository { get; }
IOrderItemRepository OrderItemRepository{ get; }
IOrderRepository OrderRepository{ get; }
IPictureRepository PictureRepository{ get; }
IProductItemRepository ProductItemRepository { get; }
IProductItemSupplierRepository ProductItemSupplierRepository { get; }
IProductRepository ProductRepository { get; }
IPromotionRepository PromotionRepository{ get; }
IReclamationRepository ReclamationRepository{ get; }
IRecommendationRepository  RecommendationRepository     { get; }
IReviewRepository ReviewRepository { get; }
IShoppingCartRepository ShoppingCartRepository{ get; }
IUserRepository UserRepository { get; 
namespace Instrument.DataAccess
    public class InstrumentUsingPlanDaoImpl
    {
        public void Add(InstrumentUsingPlanModel model)
        {
            DBProvider.dbMapper.Insert("BaseData_InstrumentUsingPlan.Insert", model);
        }
        public void Update(InstrumentUsingPlanModel model)
        {
            DBProvider.dbMapper.Update("BaseData_InstrumentUsingPlan.Update", model);
        }
        public void DeleteById(int PlanId)
        {
            DBProvider.dbMapper.Delete("BaseData_InstrumentUsingPlan.DeleteById", PlanId);
        }
        public InstrumentUsingPlanModel GetById(int PlanId)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentUsingPlanModel>("BaseData_InstrumentUsingPlan.GetByID", PlanId);
        }
        public IList<InstrumentUsingPlanModel> GetAll()
        {
            return DBProvider.dbMapper.SelectList<InstrumentUsingPlanModel>("BaseData_InstrumentUsingPlan.GetAll");
        }
        public IList<InstrumentUsingPl
namespace Instrument.DataAccess
    public class InstrumentCheckLogDaoImpl
    {
        public void DeleteByInstrumentId(int InstrumentId)
        {
            DBProvider.dbMapper.Delete("Instrument_CheckLog.DeleteByInstrumentId", InstrumentId);
        }
        public void Add(InstrumentCheckLogModel model)
        {
            DBProvider.dbMapper.Insert("Instrument_CheckLog.Insert", model);
        }
        public void Update(InstrumentCheckLogModel model)
        {
            DBProvider.dbMapper.Update("Instrument_CheckLog.Update", model);
        }
        public void DeleteById(int LogId)
        {
            DBProvider.dbMapper.Delete("Instrument_CheckLog.DeleteById", LogId);
        }
        public InstrumentCheckLogModel GetById(int LogId)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentCheckLogModel>("Instrument_CheckLog.GetByID", LogId);
        }
        public IList<InstrumentCheckLogModel> GetAll()
        {
            return DBProvider.dbM
public static class LVoxel
    public static bool VoxelExists(World world, ChunkGenerator detectionChunk, Voxel detectionVoxel, int x, int y, int z)
    {
        if (detectionChunk.numID.x * world.chunkSize.x + detectionVoxel.numID.x + x >= 0 &&
            detectionChunk.numID.x * world.chunkSize.x + detectionVoxel.numID.x + x < world.chunkNumber.x * world.chunkSize.x &&
            detectionChunk.numID.y * world.chunkSize.y + detectionVoxel.numID.y + y >= 0 &&
            detectionChunk.numID.y * world.chunkSize.y + detectionVoxel.numID.y + y < world.chunkNumber.y * world.chunkSize.y &&
            detectionChunk.numID.z * world.chunkSize.z + detectionVoxel.numID.z + z >= 0 &&
            detectionChunk.numID.z * world.chunkSize.z + detectionVoxel.numID.z + z < world.chunkNumber.z * world.chunkSize.z)
            return true;
        else
            return false;
    }
    public static void GetVoxel(World world, ref ChunkGenerator detectionChunk, ref Voxel detectionVoxel, int x, i
namespace Umbra.Structures
    public class ChunkQueue
    {
        List<Chunk> ChunkList;
        public int Count
        {
            get { return ChunkList.Count; }
        }
        public ChunkQueue()
        {
            ChunkList = new List<Chunk>();
        }
        public Chunk this[int i]
        {
            get
            {
                if (i >= 0 || i < Count)
                {
                    return ChunkList.ElementAt(i);
                }
                else
                {
                    throw new Exception("Index was out of bounds!");
                }
            }
            set
            {
                if (i >= 0 && i < Count)
                {
                    Chunk chunk = ChunkList.ElementAt(i);
                    ChunkList.Remove(chunk);
                    ChunkList.Insert(i, chunk);
                }
                else
                {
                    throw new Exception("Index was out of bounds!");
                }
   

        }
        public void AddSorted(Chunk chunk)
        {
            if (Contains(chunk))
            {
                return;
            }
            if (Count == 0 || chunk == null)
            {
                Enqueue(chunk);
                return;
            }
            for (int i = 0; i < Count; i++)
            {
                Chunk tempChunk;
                try
                {
                    tempChunk = this[i];
                }
                catch (Exception e)
				{
					try
					{
						tempChunk = this[i];
					}
					catch (Exception e2)
					{
						Popup.Post("EXCEPTION222222222!!!!! " + e2.Message);
						Enqueue(chunk);
						return;
					}
                    Popup.Post("EXCEPTION!!!!! " + e.Message);
                    Enqueue(chunk);
                    return;
                }
                ChunkIndex modified = chunk.Index * new ChunkIndex(1, 1, 1);
                if (tempChunk != null)
                {
                    int val 

                    if (val > 0)
                    {
                        ChunkList.Insert(i, chunk);
                        return;
                    }
                    else if (val <= 0)
                    {
                        continue;
                    }
                }
            }
            Enqueue(chunk);
        }
        public void Enqueue(Chunk chunk)
        {
            ChunkList.Add(chunk);
        }
        public Chunk Dequeue()
        {
            Chunk chunk = ChunkList.Last();
            ChunkList.RemoveAt(ChunkList.Count - 1);
            return chunk;
        }
        public bool Contains(Chunk chunk)
        {
            return ChunkList.Contains(chunk);
        }
        public void Remove(Chunk chunk)
        {
            if (ChunkList.Contains(chunk))
            {
                ChunkList.Remove(chunk);
            }
        }
        public Chunk RemoveAt(int index)
        {
            Chunk chunk = ChunkList.ElementAt(index
namespace CalcFarm.AnalyticUtil.Entity
    public enum AssetClass
    {
        EquityPx,
        Fx,
        Rates,
        ForwardFuture,
        Warrant
    }
    [Serializable]
    public abstract class Price
    {
        public long PublishId { get; set; }
        protected Instrument _Instrument = new Instrument();
        public Instrument Instrument
        {
            get { return _Instrument; }
            set { _Instrument = value; }
        }
        public string InstIdentifier
        {
            get { return Instrument.InstIdentifier; }
            set { Instrument.InstIdentifier = value; }
        }
        public AssetClass InstAssetClass
        {
            get { return Instrument.InstAssetClass; }
            set { Instrument.InstAssetClass = value; }
        }
        public string InstCcy
        {
            get { return Instrument.InstCcy; }
            set { Instrument.InstCcy = value; }
        }
        public override string ToString()
        {
     
﻿namespace VRTK.UnityEventHelper
    public sealed class VRTK_HeadsetControllerAware_UnityEvents : VRTK_UnityEvents<VRTK_HeadsetControllerAware>
    {
        [Serializable]
        public sealed class HeadsetControllerAwareEvent : UnityEvent<object, HeadsetControllerAwareEventArgs> { }
        public HeadsetControllerAwareEvent OnControllerObscured = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerUnobscured = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerGlanceEnter = new HeadsetControllerAwareEvent();
        public HeadsetControllerAwareEvent OnControllerGlanceExit = new HeadsetControllerAwareEvent();
        protected override void AddListeners(VRTK_HeadsetControllerAware component)
        {
            component.ControllerObscured += ControllerObscured;
            component.ControllerUnobscured += ControllerUnobscured;
            component.ControllerGlanceEnter += ControllerGlanceEnter;
     

        }
        protected override void RemoveListeners(VRTK_HeadsetControllerAware component)
        {
            component.ControllerObscured -= ControllerObscured;
            component.ControllerUnobscured -= ControllerUnobscured;
            component.ControllerGlanceEnter -= ControllerGlanceEnter;
            component.ControllerGlanceExit -= ControllerGlanceExit;
        }
        private void ControllerObscured(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerObscured.Invoke(o, e);
        }
        private void ControllerUnobscured(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerUnobscured.Invoke(o, e);
        }
        private void ControllerGlanceEnter(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerGlanceEnter.Invoke(o, e);
        }
        private void ControllerGlanceExit(object o, HeadsetControllerAwareEventArgs e)
        {
            OnControllerGlanceExit.Invoke(o, e);

namespace Podcatcher.Manager
    public class FileDownload
    {
        public delegate void ChunkSavedEventHandler(FileDownload sender, IChunk chunk);
        public event ChunkSavedEventHandler ChunkSaved;
        public string SourceLink { get; private set; }
        public string Destination { get; private set; }
        public int ChunkLength { get; set; } = 1024 * 512;
        public int ContentLength { get; set; }
        public IChunkedDownloader ChunkDownloader { get; set; }
        public ChunkSaver ChunkSaver { get; set; }
        public bool Complete { get; private set; }
        public FileDownload(string sourceLink, string destination)
        {
            SourceLink = sourceLink;
            Destination = CleanFilename(destination);
            
            ChunkDownloader = new HttpChunkedDownloader() { Url = sourceLink };
            ChunkSaver = new ChunkSaver();
            Complete = false;
        }
        private string CleanFilename(string filename)
        {


            {
                filename = filename.Replace(c, '-');
            }
            return filename;
        }
        public async Task<IChunk> DownloadChunk()
        {
            var chunkInfo = await ChunkSaver.GetNextEmptyChunk(Destination);
            var checkedChunkInfo = new ChunkInfo(
                chunkInfo.Start,
                Math.Min(ChunkLength, chunkInfo.Length)
            );
            var chunk = await ChunkDownloader.DownloadChunk(checkedChunkInfo);
            return chunk;
        }
        public async Task SaveChunk(IChunk chunk)
        {
            await ChunkSaver.SaveFile(Destination, chunk.Start, chunk.Data);
            if (ChunkSaved != null)
            {
                ChunkSaved.Invoke(this, chunk);
            }
        }
        public async Task DownloadAndSaveChunk()
        {
            var chunk = await DownloadChunk();
            if (chunk == null)
            {
                Complete = true;
            }
            else
namespace CallfireApiClient
    public class CallfireClient
    {
        public RestApiClient RestApiClient { get; set; }
        readonly Lazy<MeApi> _MeApi;
        readonly Lazy<OrdersApi> _OrdersApi;
        readonly Lazy<BatchesApi> _BatchesApi;
        readonly Lazy<CampaignSoundsApi> _CampaignSoundsApi;
        readonly Lazy<ContactsApi> _ContactsApi;
        readonly Lazy<ContactListsApi> _ContactListsApi;
        readonly Lazy<NumbersApi> _NumbersApi;
        readonly Lazy<NumberLeasesApi> _NumberLeasesApi;
        readonly Lazy<KeywordsApi> _KeywordsApi;
        readonly Lazy<KeywordLeasesApi> _KeywordLeasesApi;
        readonly Lazy<DncApi> _DncApi;
        readonly Lazy<DncListsApi> _DncListsApi;
        readonly Lazy<CallsApi> _CallsApi;
        readonly Lazy<TextsApi> _TextsApi;
        readonly Lazy<TextAutoRepliesApi> _TextAutoRepliesApi;
        readonly Lazy<TextBroadcastsApi> _TextBroadcastsApi;
        readonly Lazy<CallBroadcastsApi> _CallBroadcastsApi;
        re

        readonly Lazy<SubscriptionsApi> _SubscriptionsApi;
        readonly Lazy<WebhooksApi> _WebhooksApi;
        public MeApi MeApi { get { return _MeApi.Value; } }
        public OrdersApi OrdersApi { get { return _OrdersApi.Value; } }
        public BatchesApi BatchesApi { get { return _BatchesApi.Value; } }
        public CampaignSoundsApi CampaignSoundsApi { get { return _CampaignSoundsApi.Value; } }
        public ContactsApi ContactsApi { get { return _ContactsApi.Value; } }
        public ContactListsApi ContactListsApi { get { return _ContactListsApi.Value; } }
        public NumbersApi NumbersApi { get { return _NumbersApi.Value; } }
        public NumberLeasesApi NumberLeasesApi { get { return _NumberLeasesApi.Value; } }
        public SubscriptionsApi SubscriptionsApi { get { return _SubscriptionsApi.Value; } }
        public WebhooksApi WebhooksApi { get { return _WebhooksApi.Value; } }
        public KeywordsApi KeywordsApi { get { return _KeywordsApi.Value; } }
      

        public DncApi DncApi { get { return _DncApi.Value; } }
        public DncListsApi DncListsApi { get { return _DncListsApi.Value; } }
        public CallsApi CallsApi { get { return _CallsApi.Value; } }
        public TextsApi TextsApi { get { return _TextsApi.Value; } }
        public TextAutoRepliesApi TextAutoRepliesApi { get { return _TextAutoRepliesApi.Value; } }
        public TextBroadcastsApi TextBroadcastsApi { get { return _TextBroadcastsApi.Value; } }
        public CallBroadcastsApi CallBroadcastsApi { get { return _CallBroadcastsApi.Value; } }
        public MediaApi MediaApi { get { return _MediaApi.Value; } }
        public CallfireClient(string username, string password)
        {
            RestApiClient = new RestApiClient(new HttpBasicAuthenticator(username, password));
            _MeApi = new Lazy<MeApi>(() => new MeApi(RestApiClient));
            _OrdersApi = new Lazy<OrdersApi>(() => new OrdersApi(RestApiClient));
            _BatchesApi = new Lazy<Batc
namespace Core.TransactionServer.Agent.Reset
    internal sealed class InstrumentResetter
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(InstrumentResetter));
        internal static readonly InstrumentResetter Default = new InstrumentResetter();
        static InstrumentResetter() { }
        private InstrumentResetter() { }
        internal DateTime TradeDay { get; private set; }
        internal void DoReset(Guid instrumentId, DateTime tradeDay)
        {
            ResetManager.Default.LoadHistorySetting(tradeDay);
            Parallel.ForEach(TradingSetting.Default.Accounts.Values, account =>
            {
                var instrument = account.GetInstrument(instrumentId);
                if (instrument != null && instrument.Quotation != null)
                {
                    account.DoInstrumentReset(instrumentId, tradeDay, instrument.Quotation.BuyOnCustomerSide, instrument.Quotation.SellOnCustomerSide);
                }
            });
 
namespace GrupoADyD.Infrastructure.UnitOfWork
    public class UnitOfWork
    {
        private AccessRepository _accessRepository;
        private CustomerRepository _customerRepository;
        private ProductRepository _productRepository;
        private SaleRepository _saleRepository;
        private ApplicationDbContext _db;
        public UnitOfWork()
        {
            _db = new ApplicationDbContext();
        }
        public AccessRepository AccessRepository
        {
            get
            {
                if (_accessRepository == null)
                {
                    _accessRepository = new AccessRepository(_db);
                }
                return _accessRepository;
            }
        }
        public CustomerRepository CustomerRepository
        {
            get
            {
                if (_customerRepository == null)
                {
                    _customerRepository = new CustomerRepository(_db);
                }
                retu
namespace BusinessLogic
    public class DataManager
    {
        private IDictionaryRepository dictionaryRepository;
        private IWordRepository wordRepository;
        private IUserRepository userRepository;
        private IMessageRepository messageRepository;
        private ILanguageRepository languageRepository;
       
        public DataManager(ILanguageRepository languageRepository, IDictionaryRepository dictionaryRepository, IWordRepository wordRepository, IUserRepository userRepository, IMessageRepository messageRepository)
        {
            this.dictionaryRepository = dictionaryRepository;
            this.wordRepository = wordRepository;
            this.userRepository = userRepository;
            this.messageRepository = messageRepository;
            this.languageRepository = languageRepository;
        }
        public ILanguageRepository LanguageRepository
        {
            get { return languageRepository; }
        }
        public IDictionaryRepository 
namespace Base.Game {
    public class LevelGenerator : MonoBehaviour {
        public int currentLevel;
        public GameObject spawnChunkPrefab;
        public GameObject endChunkPrefab;
        public List<GameObject> chunkPrefabs;
        private ChunkData spawnChunk;
        private List<ChunkData> endChunk = new List<ChunkData>();
        private List<ChunkData> availableChunks = new List<ChunkData>();
        private List<ChunkData> usedChunks = new List<ChunkData>();
        private GameObject chunkHolder;
        private int generatedLength;
        private int lengthToGenerate;
        private ChunkData lastSpawnedChunk;
        private int lastEndPoint = 0;
        void Awake () {
            chunkHolder = new GameObject("Chunk Holder");
            chunkHolder.transform.parent = this.transform;
            spawnChunk = CreateChunk(spawnChunkPrefab);
            endChunk.Add(CreateChunk(endChunkPrefab));
            endChunk.Add(CreateChunk(endChunkPrefab));
           
  

                ChunkData chunk = CreateChunk(chunkPrefabs[i]);
                availableChunks.Add(chunk);
            }
            
        }
        public GameObject GetLastChunk () {
            return endChunk[lastEndPoint].gameObject;
        }
        public void Unload () {
            for (int i = 0; i < usedChunks.Count; i++) {
                ChunkData chunk = usedChunks[i];
                chunk.DisableChunk();
                availableChunks.Add(chunk);
            }
            spawnChunk.DisableChunk();
            usedChunks.Clear();
            for (int i = 0; i < endChunk.Count; i++) {
                endChunk[i].GetComponent<EndLevelChunk>().projectileManager.Unload();
                endChunk[i].GetComponent<EndLevelChunk>().DisableChunk();
            }
        }
        public ChunkData CreateChunk(GameObject _prefab) {
            GameObject instantiatedObject = Instantiate(_prefab,new Vector3(0,0,0),Quaternion.identity) as GameObject;
            instantiated

            instantiatedObject.name = _prefab.name;
            instantiatedObject.SetActive(false);
      
            return instantiatedObject.GetComponent<ChunkData>();      
        }
        public void SetSpawnChunk () {
            currentLevel = 1;
            spawnChunk.SetChunkPosition(new Vector3(-11f, 0, 0));
            spawnChunk.EnableChunk();
            generatedLength = spawnChunk.GetChunkLength();
            lengthToGenerate = 60;
            GenerateLevel(spawnChunk);
            
        }
        public void GenerateNewLevel () {
            for (int i = 0; i < usedChunks.Count; i++) {
                ChunkData chunk = usedChunks[i];
                chunk.DisableChunk();
                availableChunks.Add(chunk);
            }
            endChunk[lastEndPoint].GetComponent<EndLevelChunk>().projectileManager.StopSpawning();
            currentLevel++;
            spawnChunk.DisableChunk();
            usedChunks.Clear();
            generatedLength = spawnChun
namespace AppTeste.Backend.Repository
    public partial class UnitOfWork : UnitOfWorkBase
    {
        private BaseRepository<Talento> talentoRepository;
        public BaseRepository<Talento> TalentoRepository
        {
            get
            {
                if (this.talentoRepository == null)
                {
                    this.talentoRepository = new BaseRepository<Talento>(context);
                }
                return talentoRepository;
            }
        }
        private BaseRepository<Conhecimento> conhecimentoRepository;
        public BaseRepository<Conhecimento> ConhecimentoRepository
        {
            get
            {
                if (this.conhecimentoRepository == null)
                {
                    this.conhecimentoRepository = new BaseRepository<Conhecimento>(context);
                }
                return conhecimentoRepository;
            }
        }
        private BaseRepository<TalentoConhecimento> talentoConhecimentoReposi

        public BaseRepository<TalentoConhecimento> TalentoConhecimentoRepository
        {
            get
            {
                if (this.talentoConhecimentoRepository == null)
                {
                    this.talentoConhecimentoRepository = new BaseRepository<TalentoConhecimento>(context);
                }
                return talentoConhecimentoRepository;
            }
        }
        private BaseRepository<TalentoInformacaoBancaria> talentoInformacaoBancariaRepository;
        public BaseRepository<TalentoInformacaoBancaria> TalentoInformacaoBancariaRepository
        {
            get
            {
                if (this.talentoInformacaoBancariaRepository == null)
                {
                    this.talentoInformacaoBancariaRepository = new BaseRepository<TalentoInformacaoBancaria>(context);
                }
                return talentoInformacaoBancariaRepository;
            }
        }
        private BaseRepository<Horario> horarioRepositor

        public BaseRepository<Horario> HorarioRepository
        {
            get
            {
                if (this.horarioRepository == null)
                {
                    this.horarioRepository = new BaseRepository<Horario>(context);
                }
                return horarioRepository;
            }
        }
        private BaseRepository<TalentoHorario> talentoHorarioRepository;
        public BaseRepository<TalentoHorario> TalentoHorarioRepository
        {
            get
            {
                if (this.talentoHorarioRepository == null)
                {
                    this.talentoHorarioRepository = new BaseRepository<TalentoHorario>(context);
                }
                return talentoHorarioRepository;
            }
        }
        private BaseRepository<Disponibilidade> disponibilidadeRepository;
        public BaseRepository<Disponibilidade> DisponibilidadeRepository
        {
            get
            {
                if (this.dis
namespace Zombus.Infrastructure.Dispatching
    internal class DispatchContextManager : IDispatchContextManager
    {
        private static readonly string _currentDispatchIdDataSlotName = typeof(SubsequentDispatchContext).FullName;
        private readonly ThreadSafeDictionary<string, SubsequentDispatchContext> _store = new ThreadSafeDictionary<string, SubsequentDispatchContext>();
        public IDispatchContext GetCurrentDispatchContext()
        {
            var currentDispatchContextId = GetCurrentDispatchContextId();
            if (currentDispatchContextId == null) return new InitialDispatchContext();
            SubsequentDispatchContext dispatchContext;
            return (_store.TryGetValue(currentDispatchContextId, out dispatchContext))
                ? (IDispatchContext) dispatchContext
                : new InitialDispatchContext();
        }
        public IDisposable StartNewDispatchContext(IDispatchContext dispatchContext)
        {
            AssertCanStartDispatch

            
            if (!_store.TryAdd(dispatchContext.DispatchId, (SubsequentDispatchContext) dispatchContext))
                throw new InvalidOperationException("Cannot add duplicate {0} {1} to the {0} store."
                                                        .FormatWith(typeof(SubsequentDispatchContext).Name, dispatchContext.DispatchId));
            SetCurrentDispatchId(dispatchContext.DispatchId);
            return new DispatchContextWrapper(this, dispatchContext.DispatchId);
        }
        private void CompleteDispatchContext(string dispatchContextId)
        {
            var currentDispatchId = GetCurrentDispatchContextId();
            if (dispatchContextId != currentDispatchId)
                throw new InvalidOperationException("You are trying to stop the Dispatch {0} when the current Dispatch is {1}"
                                                        .FormatWith(dispatchContextId, currentDispatchId));
            ClearCurrentDispatchId();
            

            _store.TryRemove(dispatchContextId, out removed);
        }
        private static void AssertCanStartDispatch(IDispatchContext dispatchContext)
        {
            var currentDispatchId = GetCurrentDispatchContextId();
            if (currentDispatchId != null)
                throw new InvalidOperationException("Dispatch {0} is already in progress in this Logical CallContext. Did you forget to Dispose it?"
                                                        .FormatWith(currentDispatchId));
            
            if (dispatchContext is InitialDispatchContext)
                throw new InvalidOperationException("Don't start a Dispatch with a {0}, use a new {1} instead."
                                                        .FormatWith(typeof(InitialDispatchContext).Name, typeof(SubsequentDispatchContext).Name));
        }
        private static void ClearCurrentDispatchId()
        {
            CallContext.LogicalSetData(_currentDispatchIdDataSlotName, null);
  
public class MWorld : ScriptableObject {
	public GameObject[] tilesToUse;
	private MWorld_Chunk[,] chunks;
	private int chunkSize;
	private int numChunkX, numChunkY;
	public int[,] tileIDArray;
	public void initMWorld(int dimX, int dimY, int _chunkSize) {
		Debug.Log ("Initiailizing MWorld...");
		chunks = new MWorld_Chunk[dimX, dimY];
		chunkSize = _chunkSize;
		Debug.Log ("Mworld Initialized!");
		numChunkX = dimX;
		numChunkY = dimY;
	}
	public int initChunks(int startX, int startY, int endX, int endY) {
		Debug.Log ("Initialzing starting MWorld Chunk from"+startX+","+startY+" to "+endX+","+endY);
		if (chunks==null) {return 0;}
		for (int i = startX; i <= endX; i++) {
			for (int j = startY; j <= endY; j++) {
				Debug.Log ("");
				Debug.Log ("");
				Debug.Log ("CURXY: " + i + "," + j);
				Debug.Log ("");
				Debug.Log ("");
				initChunk (i,j);
			}
		}
		Debug.Log ("Initialized chunks!");
		return 1;
	}
	public void initChunk(int x, int y) {
		Debug.Log("Initializing chunk "+x

		MWorld_Chunk tmpChunk = (MWorld_Chunk)MWorld_Chunk.CreateInstance ("MWorld_Chunk");
		tmpChunk.tilesToUse = tilesToUse;
		tmpChunk.totChunksX = numChunkX;
		tmpChunk.totChunksY = numChunkY;
		tmpChunk.initMWorld_Chunk (chunkSize, chunkSize,x,y);
		tmpChunk.initTiles ();
		int terrainType = tileIDArray [x, y];
		Debug.Log ("Setting terrain type at " + x + "," + y + " to " + terrainType);
		tmpChunk.setTerrainType (terrainType);
		Debug.Log ("Just ran setTerrain method...");
		chunks [x, y] = tmpChunk;
	}
	public void spawnCornucopia() {
		for (int i = numChunkX / 2 - 1; i < numChunkX / 2 + 2; i++) {
			for (int j = numChunkY / 2 - 1; j < numChunkY / 2 + 2; j++) {
				spawnChunk (i, j);
			}
		}
	}
	public void spawnChunk(int x, int y) {
		Debug.Log ("Spawning chunk of " + x + "," + y);
		MWorld_Chunk tmpChunk = chunks [x, y];
		tmpChunk.spawnChunk ();
	}
	public void spawnAllChunks() {
		for (int i = 0; i < numChunkX; i++) {
			for (int j = 0; j < numChunkY; j++) {
				spawnChunk (i,
namespace CoreLogic
    public abstract class IProcessFinder : IDisposable
    {
        public delegate void ProcessEventDelegate(Process process);
        public event ProcessEventDelegate ProcessStarted;
        public delegate void ProcessIDEventDelegate(int pid);
        public event ProcessIDEventDelegate ProcessStopped;
        public abstract void Dispose();
        protected void RunProcessStarted(Process process)
        {
            if (ProcessStarted != null)
            {
                ProcessStarted(process);
            }
        }
        protected void RunProcessStopped(int process)
        {
            if (ProcessStopped != null)
            {
                ProcessStopped(process);
            }
        }
        public virtual void FindAll()
        {
            if (ProcessStarted != null)
            {
                foreach (Process p in Process.GetProcesses())
                {
                    ProcessStarted(p);
                }
            }
        
namespace MCO.Services.WebDispatchPerformance
    public class PerformLookup : IPerformLookup
    {
        #region Initialization
        private readonly IRepository oracleRepository;
        private IEnumerable<DispatchDetails> dispatchDetails;
        private IEnumerable<ReturnDetails> returnDetails;
        public PerformLookup(IRepository oracleRepository, IEnumerable<DispatchDetails> dispatchDetails, IEnumerable<ReturnDetails> returnDetails)
        {
            this.dispatchDetails = dispatchDetails;
            this.returnDetails = returnDetails;
            this.oracleRepository = oracleRepository;
        }
        #endregion
        #region Main Classes
        public IEnumerable<DispatchDetails> GetLastWeeksDispatchDetail()
        {
            dispatchDetails = oracleRepository.GetLastWeekWebDispatchDetails();
            return dispatchDetails;
        }
        public IEnumerable<ReturnDetails> GetLastWeeksReturnsDetail()
        {
            returnDetails = oracleRe
namespace ProWrite.UI.Controls.Actions
    public interface IRequestAction
    {
        void Perform();
    }
    public abstract class RequestActionBase:IRequestAction,ISynchronizeInvoke
    {
        protected static ILog log = LogManager.GetLogger("RequestAction");
        public abstract void Perform();
        private  ISynchronizeInvoke HWND
        {
            get
            {
                return FormHelper.ActiveForm;
            }
        }
        #region ISynchronizeInvoke Members
        IAsyncResult ISynchronizeInvoke.BeginInvoke(Delegate method, object[] args)
        {
            if (HWND != null)
                return HWND.BeginInvoke(method, args);
            return null;
        }
        object ISynchronizeInvoke.EndInvoke(IAsyncResult result)
        {
            if (HWND != null)
                return HWND.EndInvoke(result);
            return null;
        }
        object ISynchronizeInvoke.Invoke(Delegate method, object[] args)
        {
            
namespace Sitecore.Reflection
  public static class Nexus
  {
    private static readonly object _lock = new object();
    private static INexusDataApi _dataApi;
    private static INexusLicenseApi _licenseApi;
    private static INexusPlaceholderApi _placeholderApi;
    private static INexusPipelineApi _pipelineApi;
    public static INexusDataApi DataApi
    {
      get
      {
        return Nexus.GetApi<INexusDataApi>("Sitecore.Nexus.Data.NexusDataApi, Sitecore.Nexus", ref Nexus._dataApi);
      }
    }
    public static INexusLicenseApi LicenseApi
    {
      get
      {
        return Nexus.GetApi<INexusLicenseApi>("Sitecore.Nexus.Licensing.NexusLicenseApi, Sitecore.Nexus", ref Nexus._licenseApi);
      }
    }
    public static INexusPlaceholderApi PlaceholderApi
    {
      get
      {
        return Nexus.GetApi<INexusPlaceholderApi>("Sitecore.Nexus.Web.NexusPlaceholderApi, Sitecore.Nexus", ref Nexus._placeholderApi);
      }
    }
    public static INexusPipelineApi PipelineA
namespace BorderlessGaming.Logic.Extensions
    internal static class ProcessExtensions
    {
        private static string FindIndexedProcessName(int pid)
        {
            var processName = Process.GetProcessById(pid).ProcessName;
            var processesByName = Process.GetProcessesByName(processName);
            string processIndexdName = null;
            for (var index = 0; index < processesByName.Length; index++)
            {
                processIndexdName = index == 0 ? processName : processName + "#" + index;
                var processId = new PerformanceCounter("Process", "ID Process", processIndexdName);
                if ((int) processId.NextValue() == pid)
                {
                    return processIndexdName;
                }
            }
            return processIndexdName;
        }
  
        private static Process FindPidFromIndexedProcessName(string indexedProcessName)
        {
            var parentId = new PerformanceCounter("Process", "Cre
namespace Controller.Processes
    class ProcessWatcher
    {
        private static readonly TimeSpan _defaultInterval = TimeSpan.FromMilliseconds(1000);
        private readonly string _processName;
        private Timer _processTimer;
        private List<Process> _processList;
        public delegate void NewProcessDelegate(Process process);
        public delegate void ClosedProcessDelegate(Process process);
        public event NewProcessDelegate NewProcess;
        public event ClosedProcessDelegate ClosedProcess;
        public ProcessWatcher(string processName, TimeSpan interval)
        {
            this._processName = processName;
            this._processList = new List<Process>();
            this._processTimer = new Timer();
            this._processTimer.Interval = (int)interval.TotalMilliseconds;
            this._processTimer.Tick += _processTimer_Tick;
        }
        public ProcessWatcher(string processName) :
            this(processName, _defaultInterval)
      

        }
        public void Start()
        {
            this.ScanProcesses();
            this._processTimer.Start();
        }
        public void Stop()
        {
            this._processTimer.Stop();
        }
        public TimeSpan Interval
        {
            get { return TimeSpan.FromMilliseconds(this._processTimer.Interval); }
            set { this._processTimer.Interval = (int)value.TotalMilliseconds; }
        }
        private void _processTimer_Tick(object sender, EventArgs e)
        {
            this.ScanProcesses();
        }
        private void ScanProcesses()
        {
            Process[] processes = Process.GetProcessesByName(this._processName);
            foreach (Process process in processes)
            {
                if (!this.ProcessExists(process))
                {
                    this.NewProcess?.Invoke(process);
                    this._processList.Add(process);
                }
            }
            for (int i = 0; i < this._proces
namespace QuickRep.WeatherV3
    public class WeatherStationV3
    {
        #region Instance fields
        private string _location;
        private List<IWeatherInstrument> _instruments;
        #endregion
        #region Constructor
        public WeatherStationV3(string location, List<IWeatherInstrument> instruments = null)
        {
            _location = location;
            _instruments = instruments ?? new List<IWeatherInstrument>();
        }
        #endregion
        #region Properties
        public string Location
        {
            get { return _location; }
        }
        #endregion
        #region Metoder
        public void Reset()
        {
            foreach (IWeatherInstrument instrument in _instruments)
            {
                instrument.Reset();
            }
        }
        public void AddInstrument(IWeatherInstrument instrument)
        {
            _instruments.Add(instrument);
        }
        public override string ToString()
        {
    
namespace IdentityServer4.MongoDBDriver.Mappers
    public static class ApiResourceMappers
    {
        static ApiResourceMappers()
        {
            Mapper = new MapperConfiguration(cfg => {
                cfg.AddProfile<ApiResourceProfile>();
                cfg.AddProfile<ScopeMapperProfile>();
                cfg.AddProfile<SecretMapperProfile>();
            }).CreateMapper();
        }
        internal static IMapper Mapper { get; }
        public static Models.ApiResource ToModel(this ApiResource apiResource)
        {
            return apiResource == null ? null : Mapper.Map<Models.ApiResource>(apiResource);
        }
        public static List<Models.ApiResource> ToModel(this IEnumerable<ApiResource> apiResources)
        {
            return apiResources == null ? null : Mapper.Map<List<Models.ApiResource>>(apiResources);
        }
        public static ApiResource ToEntity(this Models.ApiResource apiResource)
        {
            return apiResource == null ? null : M
namespace Cats.ViewModelBinder
    public class DispatchViewModelBinder
    {
        public static DispatchViewModel BindDispatchViewModelBinder(Dispatch dispatch)
        {
            var dispatchViewModel = new DispatchViewModel();
            var dispatchDetail = dispatch.DispatchDetails.FirstOrDefault();
            dispatchViewModel.BidNumber = dispatch.BidNumber;
            dispatchViewModel.DispatchDate = dispatch.DispatchDate;
            dispatchViewModel.DispatchID = dispatch.DispatchID;
            dispatchViewModel.DispatchedByStoreMan = dispatch.DispatchedByStoreMan;
            dispatchViewModel.DriverName = dispatch.DriverName;
            dispatchViewModel.FDP = dispatch.FDP.Name;
            dispatchViewModel.GIN = dispatch.GIN;
            dispatchViewModel.Month = dispatch.PeriodMonth;
            dispatchViewModel.PlateNo_Prime = dispatch.PlateNo_Prime;
            dispatchViewModel.PlateNo_Trailer = dispatch.PlateNo_Trailer;
          
            dispatchViewMo
namespace Domain2
    public class DataManager
    {
        private IVhodnyeDvRepository vhodnDvRepository;
        private ISliderRepository sliderRepository;
        private IContactRepository contactRepository;
        private IKlientRepository klientRepository;
        private IOplataDostavkaRepository opldostRepository;
        private IUserRepository userRepository;
        private ISeoMainRepository seoMainRepository;
        private ICommentRepository commentRepository;
        private IYstanovkaRepository ystanovkaRepository;
        private IArticlesRepository articlesRepository;
        private IMegkomnatnyeDvRepository megkomDvRepository;
        private IColorsRepository colorsRepository;
        private IAboutUsRepository aboutusRepository;
        private IOurWorksRepository ourworksRepository;
        public DataManager(IOurWorksRepository ourworksRepository,IAboutUsRepository aboutusRepository, IColorsRepository colorsRepository, IMegkomnatnyeDvRepository megkomDvRepo

        {
            this.ourworksRepository = ourworksRepository;
            this.aboutusRepository = aboutusRepository;
            this.colorsRepository = colorsRepository;
            this.megkomDvRepository = megkomDvRepository;
            this.articlesRepository = articlesRepository;
            this.klientRepository = klientRepository;
            this.vhodnDvRepository = vhodnDvRepository;
            this.sliderRepository = sliderRepository;
            this.contactRepository = contactRepository;
            this.opldostRepository = opldostRepository;
            this.userRepository = userRepository;
            this.seoMainRepository = seoMainRepository;
            this.commentRepository = commentRepository;
            this.ystanovkaRepository = ystanovkaRepository;
        }
        public IOurWorksRepository OurWorksRepository
        {
            get { return ourworksRepository; }
        }
        public IAboutUsRepository AboutUsRepository
        {
            ge

        }
        public IColorsRepository ColorsRepository
        {
            get { return colorsRepository; }
        }
        public IMegkomnatnyeDvRepository MegkomDvRepository
        {
            get { return megkomDvRepository; }
        }
        public IArticlesRepository ArticlesRepository
        {
            get { return articlesRepository; }
        }
        public IYstanovkaRepository YstanovkaRepository
        {
            get { return ystanovkaRepository; }
        }
        public ICommentRepository CommentRepository
        {
            get { return commentRepository; }
        }
        public ISeoMainRepository SeoMainRepository
        {
            get { return seoMainRepository; }
        }
        public IUserRepository UserRepository
        {
            get { return userRepository; }
        }
        public IOplataDostavkaRepository OplDostRepository
        {
            get { return opldostRepository; }
        }
        public IKlientRepository
namespace NinjaTrader_Client.Trader.TradingAPIs
    public class NTLiveTradingAPI : ITradingAPI
    {
        private NinjaTraderAPI api;
        private int positionSize;
        private static NTLiveTradingAPI theInstace;
        public static void createInstace(NinjaTraderAPI api, int positionSize)
        {
            if (theInstace == null)
                theInstace = new NTLiveTradingAPI(api, positionSize);
            else
                throw new Exception("NTLiveTradingAPI Constructor: There is allready an instance");
        }
        public static NTLiveTradingAPI getTheInstace()
        {
            return theInstace;
        }
        private NTLiveTradingAPI(NinjaTraderAPI api, int positionSize)
        {
            this.api = api;
            this.positionSize = positionSize;
            api.tickdataArrived += api_tickdataArrived;
        }
        public NinjaTraderAPI getAPI()
        {
            return api;
        }
        public int getPositionSize()
       

            return this.positionSize;
        }
        public void setPositionSize(int newPositionSize)
        {
            this.positionSize = newPositionSize;
        }
        private Dictionary<string, PairData> pairData = new Dictionary<string,PairData>();
        void api_tickdataArrived(Tickdata data, string instrument)
        {
            if (pairData.ContainsKey(instrument) == false)
                pairData.Add(instrument, new PairData());
            int pos = api.getMarketPosition(instrument);
            if (pos != 0)
            {
                if (pos < 0 && pairData[instrument].lastShortPosition == null)
                    pairData[instrument].lastShortPosition = new TradePosition(0, data.bid, TradePosition.PositionType.shortPosition, instrument);
                if (pos > 0 && pairData[instrument].lastLongPosition == null)
                    pairData[instrument].lastLongPosition = new TradePosition(0, data.ask, TradePosition.PositionType.longPosition, instrum

            }
            {
                pairData[instrument].lastShortPosition = null;
                pairData[instrument].lastLongPosition = null;
            }
            pairData[instrument].lastTickData = data;
        }
        public double getProfit()
        {
            return api.getProfit();
        }
        public double getBuyingPower()
        {
            return api.getBuyingPower();
        }
        public double getCashValue()
        {
            return api.getCashValue();
        }
        public override bool openLong(string instrument)
        {
            if (api.submitOrder(instrument, TradePosition.PositionType.longPosition, positionSize, pairData[instrument].lastTickData.ask))
            {
                pairData[instrument].lastLongPosition = new TradePosition(getNow(), pairData[instrument].lastTickData.ask, Model.TradePosition.PositionType.longPosition, instrument);
                return true;
            }
            return false;
        }

namespace AccountingOfOverworks.UI
    class Program
    {
        static void Main(string[] args)
        {
            var repositoryManagerApi = new RepositoryManagerApi();
            var emloyeesListAction = new ShowEmployeesAction(repositoryManagerApi.GetEmployeeApi(), repositoryManagerApi.GetPositionApi(), repositoryManagerApi.GetRuleApi(),
                repositoryManagerApi.GetOwerworkApi(), repositoryManagerApi.GetPaymentApi(), repositoryManagerApi.GetHolidayApi());
            var addAction = new AddAction(repositoryManagerApi.GetEmployeeApi(), repositoryManagerApi.GetPositionApi(), repositoryManagerApi.GetRuleApi(),
                repositoryManagerApi.GetOwerworkApi(), repositoryManagerApi.GetPaymentApi(), repositoryManagerApi.GetHolidayApi());
            var removeAction = new RemoveAction(repositoryManagerApi.GetEmployeeApi(), repositoryManagerApi.GetPositionApi(), repositoryManagerApi.GetRuleApi());
            var calculateAction = new CalculateAction(repositoryManag
﻿namespace Intel.UPNP
    public sealed class SyncInvokeAdapter
    {
        public UPnPArgument[] Arguments = new UPnPArgument[0];
        public UPnPService.UPnPServiceInvokeErrorHandler InvokeErrorHandler = null;
        public UPnPInvokeException InvokeException = null;
        public UPnPService.UPnPServiceInvokeHandler InvokeHandler = null;
        public ManualResetEvent Result = new ManualResetEvent(false);
        public object ReturnValue = null;
        public SyncInvokeAdapter()
        {
            this.InvokeHandler = new UPnPService.UPnPServiceInvokeHandler(this.InvokeSink);
            this.InvokeErrorHandler = new UPnPService.UPnPServiceInvokeErrorHandler(this.InvokeFailedSink);
        }
        private void InvokeFailedSink(UPnPService sender, string MethodName, UPnPArgument[] Args, UPnPInvokeException e, object Tag)
        {
            this.Arguments = Args;
            this.InvokeException = e;
            this.Result.Set();
        }
        private void Invok
namespace MistRidge
    public class StandardChunkFeaturePickingStrategy : IChunkFeaturePickingStrategy
    {
        private readonly Generator generator;
        private HashSet<ChunkFeature> pickedUniqueChunkFeatures;
        private ChunkFeature chunkChain;
        public StandardChunkFeaturePickingStrategy(Generator generator)
        {
            this.generator = generator;
        }
        public void Initialize()
        {
            pickedUniqueChunkFeatures = new HashSet<ChunkFeature>();
            chunkChain = null;
        }
        public ChunkFeature Pick(ChunkRequest chunkRequest)
        {
            if (chunkChain != null)
            {
                ChunkFeature chunkChainedFeature = chunkChain;
                chunkChain = chunkChain.ChunkChainNext;
                return chunkChainedFeature;
            }
            IBiome biome = chunkRequest.biome;
            List<ChunkFeature> chunkFeatures = biome.ChunkFeatures();
            chunkFeatures = chunkFeatur

                .Where(chunkFeature => !chunkFeature.IsUnique || (chunkFeature.IsUnique && !pickedUniqueChunkFeatures.Contains(chunkFeature)))
                .ToList();
            List<ChunkFeature> unfittedChunkIndices = GetUnfittedChunkIndices(chunkRequest, chunkFeatures);
            foreach (ChunkFeature chunkFeature in unfittedChunkIndices)
            {
                chunkFeatures.Remove(chunkFeature);
            }
            List<int> cdf = CreateCDF(chunkFeatures);
            int randomIndex = GetRandomIndex(cdf, chunkFeatures);
            ChunkFeature pickedChunkFeature = chunkFeatures[randomIndex];
            if (pickedChunkFeature.IsUnique)
            {
                pickedUniqueChunkFeatures.Add(pickedChunkFeature);
            }
            chunkChain = pickedChunkFeature.ChunkChainNext;
            return pickedChunkFeature;
        }
        private List<int> CreateCDF(List<ChunkFeature> chunkFeatures)
        {
            List<int> featuresCDF = new List<i

            int sum = 0;
            foreach (ChunkFeature chunkFeature in chunkFeatures)
            {
                sum += chunkFeature.Rarity;
                featuresCDF.Add(sum);
            }
            return featuresCDF;
        }
        private int GetRandomIndex(List<int> cdf, List<ChunkFeature> chunkFeatures)
        {
            if (cdf.Count == 0)
            {
                Debug.LogError("Failed to pick chunk feature because chunk feature container ran out of features");
                return 0;
            }
            int random = generator.Random.Next(cdf[cdf.Count - 1]);
            int randomIndex = 0;
            foreach (int probability in cdf)
            {
                if (probability > random)
                {
                    break;
                }
                randomIndex++;
            }
            if (randomIndex > chunkFeatures.Count - 1)
            {
                randomIndex = chunkFeatures.Count - 1;
            }
            r
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    void Start()
    {
        for (int x = -2; x < 2; x++)
        {
            for (int y = -1; y < 1; y++)
            {
                for (int z = -1; z < 1; z++)
                {
                    CreateChunk(x * 16, y * 16, z * 16);
                }
            }
        }
    }
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        for (int xi = 0; xi < 16; xi++)
        {
            for (int yi = 0; 

            {
                for (int zi = 0; zi < 16; zi++)
                {
                    if (yi <= 7)
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockGrass());
                    }
                    else
                    {
                        SetBlock(x + xi, y + yi, z + zi, new BlockAir());
                    }
                }
            }
        }
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        {
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / 
namespace Spire
	class DocumentChunkCollection
	{
		private int updatedToChunkIndex;
		
		public DocumentChunkCollection()
		{
			Initialize();
		}
		
		public int Length
		{
			get 
			{
				UpdateAllChunks();
				return chunks.Last().End + 1;
			}
		}
		
		public char this[int cindex]
		{
			get
			{
				int chunkIndex = GetChunkIndexByCindex(cindex);
				DocumentChunk chunk = chunks[chunkIndex];
				return chunk[cindex];
			}
		}
		
		public void Initialize()
		{
			if(chunks == null)
			{
				chunks = new List<DocumentChunk>();
			}
			else
			{
				chunks.Clear();
			}
			chunks.Add(new DocumentChunk());
			updatedToChunkIndex = -1;
		}
		
		public void AddAt(string text, Cindex cindex)
		{
			int chunkIndex = GetChunkIndexByCindex(cindex);
			DocumentChunk chunk = chunks[chunkIndex];
			chunk.InsertText(text, cindex);
			updatedToChunkIndex = Math.Min(updatedToChunkIndex, chunkIndex);
			CheckChunkLength(chunkIndex, chunk);
		}
		
		public void RemoveAt(Cindex cindex, int length)

		{
			while(length > 0)
			{
				length = RemoveAtPartial(cindex, length);
				UpdateChunksToCindex(cindex + length);
			}
		}
		
		private int RemoveAtPartial(Cindex cindex, int length)
		{
			int chunkIndex = GetChunkIndexByCindex(cindex);
			DocumentChunk chunk = chunks[chunkIndex];
			int availableLength = Math.Min(length, chunk.End + 1 - cindex);
			if(availableLength == 0)
				return 0;
			chunk.RemoveText(cindex, availableLength);
			updatedToChunkIndex = chunkIndex;
			CheckChunkLength(chunkIndex, chunk);
			return length - availableLength;
		}
		
/*		private void Display()
		{
			Console.WriteLine("==========================");
			foreach(DocumentChunk chunk in chunks)
			{
				Console.WriteLine(chunk);
			}
		} */
		
		public string SubString(Cindex from, Cindex to)
		{
			if(to < from) throw new Exception(String.Format("Document 'to' ({0}) is less than 'from' ({1}).", to, from));
			int startChunkIndex = GetChunkIndexByCindex(from);
			int endChunkIndex = GetChunkIndexByCi

			if(startChunkIndex == endChunkIndex)
			{
				return chunks[startChunkIndex].SubStringByCharIndex(from, to);
			}			
			if(endChunkIndex - startChunkIndex < 3)
			{
				return SubStringWithConcat(startChunkIndex, endChunkIndex, from, to);
			}
			else
			{
				return SubStringWithStringBuilder(startChunkIndex, endChunkIndex, from, to);
			}
		}
		private string SubStringWithConcat(int startChunkIndex, int endChunkIndex, Cindex from, Cindex to)
		{
			string subString = chunks[startChunkIndex].SubStringFromCharIndex(from);
			for(int i=startChunkIndex+1; i<endChunkIndex; i++)
			{
				subString += chunks[i].Text;
			}
			subString += chunks[endChunkIndex].SubStringToCharIndex(to);
			return subString;
		}
		
		private string SubStringWithStringBuilder(int startChunkIndex, int endChunkIndex, Cindex from, Cindex to)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(chunks[startChunkIndex].SubStringFromCharIndex(from));
			for(int i=startChunkIndex+1; i<
internal class VoxelSelector
	private static Dictionary<Vector3, Chunk> _loadedChunks;
	public static void SetLoadedChunks(Dictionary<Vector3, Chunk> loadedChunks)
	{
		_loadedChunks = loadedChunks;
	}
	public static Voxel SelectVoxel(Vector3 chunkCoord, int x, int y, int z)
	{
		if(x < 0) { chunkCoord.x--; x += (int)Chunk.ChunkSize.x; }
		if(y < 0) { chunkCoord.y--; y += (int)Chunk.ChunkSize.y; }
		if(z < 0) { chunkCoord.z--; z += (int)Chunk.ChunkSize.z; }
		if(x >= Chunk.ChunkSize.x) { chunkCoord.x++; x -= (int)Chunk.ChunkSize.x; }
		if(y >= Chunk.ChunkSize.y) { chunkCoord.y++; y -= (int)Chunk.ChunkSize.y; }
		if(z >= Chunk.ChunkSize.z) { chunkCoord.z++; z -= (int)Chunk.ChunkSize.z; }
		Chunk chunk = null;
		Voxel voxel = new Voxel();
		if(_loadedChunks.TryGetValue(chunkCoord, out chunk))
		{
			voxel = chunk.VoxelAt(x, y, z);
		}
		else
		{
			voxel.on = false;
		}
		return voxel;
	}
	public static bool SelectVoxelValue(Vector3 chunkCoord, int x, int y, int z)
	{
		return SelectVoxe
namespace CollectionViewTransition {
	[Register ("AppDelegate")]
	public partial class AppDelegate : UIApplicationDelegate {
		public override UIWindow Window {
			get;
			set;
		}
		public override void FinishedLaunching (UIApplication application)
		{
			Window = new UIWindow (UIScreen.MainScreen.Bounds);
			APLStackLayout stackLayout = new APLStackLayout ();
			var cvc = new APLStackCollectionViewController (stackLayout) {
				Title = "Stack Layout"
			};
			var navigationController = new UINavigationController (cvc);
			navigationController.NavigationBar.Translucent = false;
			var transitionController = new APLTransitionController (cvc.CollectionView, navigationController);
			navigationController.Delegate = new NavigationControllerDelegate (transitionController);
			Window.RootViewController = navigationController;
			Window.MakeKeyAndVisible ();
		}
		public class NavigationControllerDelegate : UINavigationControllerDelegate
		{
			APLTransitionController transitionController;
	

			{
				transitionController = controller;
			}
			public override IUIViewControllerInteractiveTransitioning GetInteractionControllerForAnimationController (UINavigationController navigationController, IUIViewControllerAnimatedTransitioning animationController)
			{
				if (animationController == transitionController)
					return transitionController;
				return null;
			}
			public override IUIViewControllerAnimatedTransitioning GetAnimationControllerForOperation (UINavigationController navigationController, UINavigationControllerOperation operation, UIViewController fromViewController, UIViewController toViewController)
			{
				if (!fromViewController.GetType ().IsSubclassOf (typeof(UICollectionViewController)))
				    return null;
				if (!toViewController.GetType ().IsSubclassOf (typeof (UICollectionViewController)))
					return null;
				if (!transitionController.HasActiveInteraction)
					return null;
				transitionController.NavigationOperation = operation;
				return transi
public class World : MonoBehaviour
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
        

            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        

            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
        }
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z);
        
namespace Process.NET.Extensions
    public static class ProcessExtensions
    {
        public static IList<ProcessThread> GetThreads(this System.Diagnostics.Process process)
        {
            return process.Threads.Cast<ProcessThread>().ToList();
        }
        public static IList<ProcessModule> GetModules(this System.Diagnostics.Process process)
        {
            return process.Modules.Cast<ProcessModule>().ToList();
        }
        public static SafeMemoryHandle Open(this System.Diagnostics.Process process, ProcessAccessFlags processAccessFlags = ProcessAccessFlags.AllAccess)
        {
            return MemoryHelper.OpenProcess(processAccessFlags, process.Id);
        }
        public static string GetVersionInfo(this System.Diagnostics.Process process)
        {
            return
                $"{process.MainModule.FileVersionInfo.FileDescription} {process.MainModule.FileVersionInfo.FileMajorPart}.{process.MainModule.FileVersionInfo.FileMinorPart}.{process.MainMod
namespace Instrument.Ui.ViewControllers
    public sealed class InstrumentGridViewController : IDisposable
    {
        private readonly IInstrumentPriceService _instrumentPriceService;
        private InstrumentGridViewModel _viewModel;
        private readonly CompositeDisposable _disposable;
        private readonly TimeSpan _conflateTimeSpan;
        private readonly Action<string> _viewHistoricalPrices;
        private readonly IScheduler _uiScheduler;
        private readonly IScheduler _backgroundScheduler;
        public InstrumentGridViewController(IInstrumentPriceService instrumentPriceService, 
                                            TimeSpan conflateTimeSpan, 
                                            Action<string> viewHistoricalPrices,
                                            IScheduler uiScheduler, 
                                            IScheduler backgroundScheduler)
        {
            _instrumentPriceService = instrumentPriceService;
            _con

            _viewHistoricalPrices = viewHistoricalPrices;
            _uiScheduler = uiScheduler;
            _backgroundScheduler = backgroundScheduler;
            _disposable = new CompositeDisposable();
        }
        public InstrumentGridViewModel ViewModel
        {
            get { return _viewModel; }
        }
        public void Initialize()
        {
            _viewModel = new InstrumentGridViewModel
            {
                InstrumentPrices = new ObservableKeyedCollection<string, InstrumentPriceViewModel>(ip => ip.Instrument),
                ShowHistoricalPrices = new DelegateCommand<InstrumentPriceViewModel>(vm => _viewHistoricalPrices(vm.Instrument))
            };
            _instrumentPriceService.ObserveInstrumentPrices()
                                   .GroupBy(p => p.Instrument)
                                   .Select(gp => gp.Scan(Enumerable.Empty<InstrumentPrice>(), (acum, price) => acum.StartWith(price).Take(5))
                                

                                   .Select(prices => prices.ToAggregatedInstrumentPrice())
                                   .SubscribeOn(_backgroundScheduler)
                                   .ObserveOn(_uiScheduler)
                                   .Subscribe(p =>
                                   {
                                       if (_viewModel.InstrumentPrices.Contains(p.Instrument))
                                       {
                                           _viewModel.InstrumentPrices[p.Instrument].Update(p);
                                       }
                                       else
                                       {
                                           _viewModel.InstrumentPrices.Add(p.ToViewModel());
                                       }
                                   })
                                   .AddToDisposable(_disposable);
        }
        public void Dispose()
        {
            _disposable.Dispose();
        }
namespace SipperFile
  public class Instrument
  {
    public Instrument (string  _shortName,
                       string  _description
                      )
    {
      shortName   = _shortName;
      description = _description;
    }
    public  string  ShortName   () {return shortName;}
    public  string  Description () {return description;}
    virtual  public  InstrumentDataReport  CreateInstrumentDataReport (InstrumentDataManager manager,
                                                                       byte                  deviceId
                                                                      )
    {
      InstrumentDataReport dr = null;
      switch (deviceId)
      {
        case  6: dr = new InstrumentDataReportText (manager, deviceId);
                 break;
        case  7: dr = new InstrumentDataReportIllumination (manager, deviceId);
                 break;
                
        case  8: dr = new InstrumentDataReportCTD (manager, deviceId, Instrumen

                 break;
        case  9: dr = new InstrumentDataReportGPS (manager, deviceId);
                 break;
        case 10: dr = new InstrumentDataReportFlowMeter (manager, deviceId);
                 break;
                
        default: dr = new InstrumentDataReport (manager, deviceId);
                 break;
      }
    
      return dr;
    }  /* CreateInstrumentDataReport */
    
    private static  void  BuildInstrumentList ()
    {
      instruments = new Instrument[] {new InstrumentCTD (), 
                                      new InstrumentGPS (),
                                      new InstrumentInclinationMeter (),
                                      new InstrumentBatteryMeters (),
                                      new InstrumentOther ()
                                     };
    }  /* BuildInstrumentList */
    public  static  Instrument  LookUpByShortName (string _shortName)
    {
      string  shortNameLower = _shortName.ToLower ();
      if  (i

        BuildInstrumentList ();
      for  (int x = 0;  x < instruments.Length;  x++)
      {
        if  (instruments[x] != null)
        {
          if  (instruments[x].ShortName ().ToLower () == shortNameLower)
            return instruments[x];
        }
      }
      return null;
    }  /* LookUpByShortName */
    public  static  Instrument  OtherInstrument ()
    {
      return LookUpByShortName ("OTH");
    }
    public  static  void  PopulateComboBox (System.Windows.Forms.ComboBox  comboBox)
    {
      int x = 0;
      if  (instruments == null)
        BuildInstrumentList ();
     
      ArrayList choices = new ArrayList ();
      choices.Add ("None");
      for  (x = 0;  x < instruments.Length;  x++)
      {
        choices.Add (instruments[x].ShortName ());
      }
      comboBox.DataSource = choices;
    }  /* PopulateComboBox */
    private static  Instrument[] instruments = null;
    private string  shortName;
    private string  description;
  }  /* Instrument */
  publ
namespace TShanTC.Service.QiXiu.Controllers.WorkShopDispatch
   
        [RoutePrefix("api/QiXiu/WorkShopDispatch")]
        public class WorkShopDispatchController : ApiController
        {
            [HttpPost]
            [Route("AddWorkShopDispatch")]
            public SOAResponseFormat<int> AddWorkShopDispatch([FromBody]SOAData soaData)
            {
                return ApiSOAPerformer.Runing<int, WorkShopDispatchEntity>(soaData, QiXiuProviderLayerIoc<WorkShopDispatchProvider, IWorkShopDispatchLogic, WorkShopDispatchLogic>.ProviderIoc.AddWorkShopDispatch);
            }
            [HttpPost]
            [Route("GetWorkShopDispatchList")]
            public SOAResponseFormat<QiXiuListResponse<WorkShopDispatchEntity>> GetWorkShopDispatchList([FromBody]SOAData soaData)
            {
                return ApiSOAPerformer.Runing<QiXiuListResponse<WorkShopDispatchEntity>, WorkShopDispatchListRequest>(soaData, QiXiuProviderLayerIoc<WorkShopDispatchProvider, IWorkShopDispatchLogic,
namespace MyLeoRetailerRepo
    public class ProductDispatchRepo
    {
        SQL_Repo sqlHelper = null;
        public ProductDispatchRepo()
        {
            sqlHelper = new SQL_Repo();
        }
        public DataTable Get_Product_To_Dispatch(Filter filter)
        {
            DataTable dt = new DataTable();
            List<SqlParameter> sqlParam = new List<SqlParameter>();
            sqlParam.Add(new SqlParameter("@branch_Name", filter.Branch_Name));
            if (filter.From_Request_Date != DateTime.MinValue)
            {
                sqlParam.Add(new SqlParameter("@from_Request_Date", filter.From_Request_Date.ToString()));
            }
            else
            {
                sqlParam.Add(new SqlParameter("@from_Request_Date", null));
            }
            if (filter.To_Request_Date != DateTime.MinValue)
            {
                sqlParam.Add(new SqlParameter("@to_Request_Date", filter.To_Request_Date.ToString()));
            }
            else
   

                sqlParam.Add(new SqlParameter("@to_Request_Date", null));
            }
           
            sqlParam.Add(new SqlParameter("@status", filter.Status));
            dt = sqlHelper.ExecuteDataTable(sqlParam, Storeprocedures.sp_Get_Product_To_Dispatch.ToString(), CommandType.StoredProcedure);
            return dt;
        }
        public ProductDispatchInfo Get_Product_To_Dispatch_By_Id(int request_Id, string sku)
        {
            ProductDispatchInfo product = new ProductDispatchInfo();
            List<SqlParameter> sqlparam = new List<SqlParameter>();
            sqlparam.Add(new SqlParameter("@request_Id", request_Id));
            sqlparam.Add(new SqlParameter("@SKU", sku));
            DataSet ds = sqlHelper.ExecuteDataSet(sqlparam, Storeprocedures.sp_Get_Product_To_Dispatch_By_Id.ToString(), CommandType.StoredProcedure);
            foreach (DataRow dr in ds.Tables[0].Rows)
            {
                product.Request_Id = Convert.ToInt32(dr["Purchase_Orde

                product.SKU = Convert.ToString(dr["SKU_Code"]);
               
                product.Balance_Quantitya = Convert.ToInt32(dr["Balance_Quantity"]);
                product.Branch_Id = Convert.ToInt32(dr["Branch_Id"]);
                product.Quantity = Convert.ToInt32(dr["Quantity"]);
            }
            ProductDispatchInfo dispatch_Products;
            List<ProductDispatchInfo> list_dispatch_Products = new List<ProductDispatchInfo>();
            {
                dispatch_Products = new ProductDispatchInfo();
                dispatch_Products.Dispatch_Id = Convert.ToInt32(dr["Dispatch_Id"]);
                dispatch_Products.Dispatch_Item_Id = Convert.ToInt32(dr["Dispatch_Item_Id"]);
                dispatch_Products.Barcode = Convert.ToString(dr["Barcode"]);
                dispatch_Products.Quantity = Convert.ToInt32(dr["Dispatch_Quantity"]);
                dispatch_Products.Dispatch_Date = Convert.ToDateTime(dr["Dispatch_Date"]);
                dispatch_
namespace FpmlSerializedCSharp
    public class Root : ISerialized
    {
        public Root() { }
        public Root(XmlNode xmlNode)
        : base(xmlNode)
        {
            XmlNode instrumentNode = xmlNode.SelectSingleNode("instrument");
            
            if (instrumentNode != null)
            {
                if (instrumentNode.Attributes["href"] != null || instrumentNode.Attributes["id"] != null) 
                {
                    if (instrumentNode.Attributes["id"] != null) 
                    {
                        instrumentIDRef_ = instrumentNode.Attributes["id"].Value;
                        Instrument ob = new Instrument(instrumentNode);
                        IDManager.SetID(instrumentIDRef_, ob);
                    }
                    else if (instrumentNode.Attributes["href"] != null)
                    {
                        instrumentIDRef_ = instrumentNode.Attributes["href"].Value;
                    }
                    else
         

                        instrument_ = new Instrument(instrumentNode);
                    }
                }
                else
                {
                    instrument_ = new Instrument(instrumentNode);
                }
            }
            
        
        }
        
    
        #region Instrument_
        private Instrument instrument_;
        public Instrument Instrument_
        {
            get
            {
                if (this.instrument_ != null)
                {
                    return this.instrument_; 
                }
                else if (this.instrumentIDRef_ != null)
                {
                    instrument_ = IDManager.getID(instrumentIDRef_) as Instrument;
                    return this.instrument_; 
                }
                else
                {
                    throw new Exception( "instrument_Node no exist!");
                }
            }
            set
            {
                if (this.instrument_ !=
namespace Curan.Common.FormalizedData.File.Riff.Avi
	public class RiffChunkListHdrl : RiffChunkList
	{
		public const string TYPE = "hdrl";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public RiffChunkAvih chunkAvih;
		public RiffChunkStrf chunkStrf;
		public RiffChunkStrh chunkStrh;
		static RiffChunkListHdrl()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkAvih.ID, typeof( RiffChunkAvih ) );
			chunkTypeDictionary.Add( RiffChunkStrh.ID, typeof( RiffChunkStrh ) );
			chunkTypeDictionary.Add( RiffChunkStrf.ID, typeof( RiffChunkStrf ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
			bodyTypeDictionary.Add( RiffChunkListStrl.TYPE, typeof( RiffChunkListStrl ) );
			bodyTypeDictionary.Add( RiffChunkListInfo.TYPE, typeof( RiffChunkListInfo ) );
		}
		public RiffChunkListHdrl( string aId, UInt32 aSize, ByteArray aByteArray, RiffChunkL
public class TerrainGen : MonoBehaviour {
	float stoneBaseHeight = -24;
	float stoneBaseNoise = 0.05f;
	float stoneBaseNoiseHeight = 4;
	float stoneMountainHeight = 48;
	float stoneMountainFrequency = 0.008f;
	float stoneMinHeight = -12;
	float dirtBaseHeight = 1;
	float dirtNoise = 0.04f;
	float dirtNoiseHeight = 3;
	public Chunk ChunkGen(Chunk chunk)
	{
		for(int x = chunk.pos.x; x < chunk.pos.x + Chunk.chunkSize; x++)
		{
			for(int z = chunk.pos.z; z < chunk.pos.z + Chunk.chunkSize; z++)
			{
				chunk = ChunkColumnGen(chunk, x, z);
			}
		}
		return chunk;
	}
	public Chunk ChunkColumnGen(Chunk chunk, int x, int z)
	{
		int stoneHeight = Mathf.FloorToInt (stoneBaseHeight);
		stoneHeight += GetNoise (x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
		if(stoneHeight < stoneMinHeight)
			stoneHeight = Mathf.FloorToInt(stoneMinHeight);
		stoneHeight += GetNoise(x, 0, z, stoneBaseNoise, Mathf.FloorToInt(stoneBaseNoise));
		int dirtHeight = stoneHeight + Mathf.Flo
namespace FastQuant
    public class FileInstrumentServer : InstrumentServer
    {
        private bool opened;
        private DataFile dataFile;
        public FileInstrumentServer(Framework framework, string fileName, string host = null, int port = -1): base(framework)
        {
            this.dataFile = new DataFile(fileName, framework.StreamerManager);
        }
        public override void Close()
        {
            if (this.opened)
            {
                this.dataFile.Close();
                this.opened = false;
            }
        }
        public override void Delete(Instrument instrument) => this.dataFile.Delete(instrument.Symbol);
        public override void Flush() => this.dataFile.Flush();
        public override InstrumentList Load()
        {
            this.instruments.Clear();
            foreach (var key in this.dataFile.Keys.Values)
            {
                if (key.TypeId == ObjectType.Instrument)
                {
                    var instru
namespace QuanLyBanHang.Data.MongoDb
    public class UnitOfWork
    {
        private AgencyRepository _agencyRepository;
        private UserRepository _userRepository;
        private UserGroupRepository _userGroupRepository;
        private PermissionRepository _permissionRepository;
        private UserGroupPermissionRepository _userGroupPermissionRepository;
        private UserUserGroupRepository _userUserGroupRepository;
        private PassengerRepository _passengerRepository;
        private ProductRepository _productRepository;
        private OrderRepository _orderRepository;
        private ShipmentRepository _shipmentRepository;
        private CostTypeRepository _costTypeRepository;
        private CostRepository _costRepository;
        private PackageRepository _packageRepository;
        private CompanyRepository _companyRepository;
        private ExchangeRateRepository _exchangeRateRepository;
        public UnitOfWork(MongoHelper helper)
        {
            DataH

        }
        public MongoHelper DataHelper { get; set; }
        public AgencyRepository AgencyRepository => _agencyRepository ?? (_agencyRepository = new AgencyRepository(DataHelper,
                                                                                                                 Agency.COLLECTIONNAME));
        public ExchangeRateRepository ExchangeRateRepository => _exchangeRateRepository ?? (_exchangeRateRepository = new ExchangeRateRepository(DataHelper,
                                                                                                                                                 ExchangeRate.COLLECTIONNAME));
        public UserRepository UserRepository => _userRepository ?? (_userRepository = new UserRepository(DataHelper,
                                                                                                         User.COLLECTIONNAME));
        public UserGroupRepository UserGroupRepository => _userGroupRepository ?? (_userGroupR

                                                                                                                                  UserGroup.COLLECTIONNAME));
        public PermissionRepository PermissionRepository => _permissionRepository ?? (_permissionRepository = new PermissionRepository(DataHelper,
                                                                                                                                  Permission.COLLECTIONNAME));
        public UserGroupPermissionRepository UserGroupPermissionRepository => _userGroupPermissionRepository ?? (_userGroupPermissionRepository = new UserGroupPermissionRepository(DataHelper,
                                                                                                                                                                                    UserGroupPermission.COLLECTIONNAME));
        public UserUserGroupRepository UserUserGroupRepository => _userUserGroupRepository ?? (_userUserGroupRepository = new
﻿@model MMApp.Domain.Models.Instrument
@Scripts.Render("~/bundles/jquery")
@Scripts.Render("~/bundles/modernizr")
@Scripts.Render("~/bundles/jqueryval")
    @Html.ValidationSummary(true)
    @(Html.HiddenFor(model => model.Id))
    
    <table>
        <tr>
            <td colspan="3">&nbsp;</td>
        </tr>
        <tr>
            <td class="labelWidth150">@Html.LabelFor(instrument => instrument.InstrumentName)</td>
            <td>@Html.TextBoxFor(instrument => instrument.InstrumentName)</td>
            <td>@Html.ValidationMessageFor(instrument => instrument.InstrumentName)</td>
        </tr>
        <tr>
            <td class="labelWidth150 labelPadding">@Html.LabelFor(instrument => instrument.Website)</td>
            <td colspan="2">@Html.TextBoxFor(instrument => instrument.Website, new { style = "width:100%;" })</td>
        </tr>
        <tr>
            <td colspan="3">&nbsp;</td>
        </tr>
        <tr>
            <td colspan="2" style="text-align: right">
            
namespace IW.Controller
    public class InstrumentWatchController
    {
        public IObservable<InstrumentMarketData> InstrumentMarketDataObservable
        {
            get
            {
                return Observable.Create<InstrumentMarketData>(o =>
                {
                    Observable.Range(0, 100).Subscribe(r => o.OnNext(GetInstrumentMarketData()));
                    return Disposable.Empty;
                });
            }
        }
        public IObservable<InstrumentMarketData> GetInstrumentMarketDataObservable(IEnumerable<string> instrumentIds)
        {
            return Observable.Create<InstrumentMarketData>(o =>
            {
                foreach (var instrumentId in instrumentIds)
                {
                    o.OnNext(GetInstrumentMarketData(instrumentId));
                }
                o.OnCompleted();
                return Disposable.Empty;
            });
        }
        private static InstrumentMarketData GetInstrumentMarket
namespace CraftyServer.Core
    public class ChunkProviderServer
        : IChunkProvider
    {
        private readonly Chunk field_724_b;
        private readonly Set field_725_a;
        private readonly List field_727_f;
        private readonly IChunkLoader field_729_d;
        private readonly IChunkProvider field_730_c;
        private readonly Map id2ChunkMap;
        private readonly WorldServer world;
        public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, IChunkProvider ichunkprovider)
        {
            field_725_a = new HashSet();
            id2ChunkMap = new HashMap();
            field_727_f = new ArrayList();
            field_724_b = new EmptyChunk(worldserver, new byte[32768], 0, 0);
            world = worldserver;
            field_729_d = ichunkloader;
            field_730_c = ichunkprovider;
        }
        #region IChunkProvider Members
        public bool chunkExists(int i, int j)
        {
            return id2ChunkMap.con

        }
        public Chunk provideChunk(int i, int j)
        {
            var chunk = (Chunk) id2ChunkMap.get(Integer.valueOf(ChunkCoordIntPair.chunkXZ2Int(i, j)));
            if (chunk == null)
            {
                if (world.field_9209_x)
                {
                    return loadChunk(i, j);
                }
                else
                {
                    return field_724_b;
                }
            }
            else
            {
                return chunk;
            }
        }
        public void populate(IChunkProvider ichunkprovider, int i, int j)
        {
            Chunk chunk = provideChunk(i, j);
            if (!chunk.isTerrainPopulated)
            {
                chunk.isTerrainPopulated = true;
                if (field_730_c != null)
                {
                    field_730_c.populate(ichunkprovider, i, j);
                    chunk.setChunkModified();
                }
            }
        }
        public bool 
public class WeaponControllerP : MonoBehaviour {
    PlayerController playerController;
    void Start()
    {
        playerController = transform.root.GetComponentInParent<PlayerController>();
    }
    public void OnTriggerEnter(Collider col)
    {
        
        SkeletonController skelController = col.GetComponent<SkeletonController>();
        if (skelController != null)
        {
            skelController.CurrentHealth -= playerController.Attack / 5;
        }
        ZombieController zombController = col.GetComponent<ZombieController>();
        if (zombController != null)
        {
            zombController.CurrentHealth -= playerController.Attack / 5;
        }
        MonsterControllerV2 monstController = col.GetComponent<MonsterControllerV2>();
        if (monstController != null)
        {
            monstController.CurrentHealth -= playerController.Attack / 5;
        }
        GolemControllerV2 golemController = col.GetComponent<GolemControllerV2>();
        if (gole
namespace AspectCore.Core
    [NonAspect]
    public sealed class AspectBuilder : IAspectBuilder
    {
        private readonly IList<Func<AspectDelegate, AspectDelegate>> _delegates;
        public AspectBuilder()
        {
            _delegates = new List<Func<AspectDelegate, AspectDelegate>>();
        }
        public void AddAspectDelegate(Func<AspectContext, AspectDelegate, Task> interceptorInvoke)
        {
            if (interceptorInvoke == null)
            {
                throw new ArgumentNullException(nameof(interceptorInvoke));
            }
            _delegates.Add(next => context => interceptorInvoke(context, next));
        }
        public Func<Func<object>, AspectDelegate> Build()
        {
            return targetInvoke => Build(targetInvoke);
        }
        public AspectDelegate Build(Func<object> targetInvoke)
        {
            if (targetInvoke == null)
            {
                throw new ArgumentNullException(nameof(targetInvoke));
            }
namespace System.Web.Services.Protocols {
    internal class ScatterGatherStream : Stream {
        private const int MemStreamMaxLength = Int32.MaxValue;        
        private MemoryChunk headChunk = null;
        private MemoryChunk currentChunk = null;  
        private long chunkSize = 0;
        private int currentOffset = 0;
        private int endOffset = 0;
        private long currentChunkStartPos = 0;
        internal ScatterGatherStream(int chunkSize) {
            this.chunkSize = chunkSize;
            currentChunk = headChunk = AllocateMemoryChunk(this.chunkSize);
            currentOffset = endOffset = 0;
            currentChunkStartPos = 0;
        }
        internal ScatterGatherStream() : this(1024) { }
        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return true; } }
        public override bool CanWrite { get { return true; } }
        
        public override void Close() {            
            headChu

            currentChunk = null;
            endOffset = currentOffset = 0;
            currentChunkStartPos = 0;
        }
        public override void Flush() { }
        public override long Length { 
            get {
                MemoryChunk endChunk;
                return GetLengthInternal(out endChunk);
            }
        }
        private long GetLengthInternal(out MemoryChunk endChunk){
            long length = currentChunkStartPos;
            MemoryChunk chunk = currentChunk;
            while (chunk.Next != null) {
                length += chunk.Buffer.Length;
                chunk = chunk.Next;
            }
            length += endOffset;
            endChunk = chunk;
            return length;
        }
        public override long Position {
            get {
                return Seek(0, SeekOrigin.Current);
            }
             
            set {
                Seek(value, SeekOrigin.Begin);
            }
        }
        
        public override l

            MemoryChunk chunk  = null;;
            long relativeOffset = 0;
            long absoluteOffset = 0;
            
            if(loc == SeekOrigin.Begin){
                absoluteOffset = offset;
                if(offset >= currentChunkStartPos){
                    chunk = currentChunk;
                    relativeOffset = offset - currentChunkStartPos;
                }
                else{
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else if( loc == SeekOrigin.Current){
                absoluteOffset = offset + currentOffset + currentChunkStartPos;
                if( (offset + currentOffset) > 0){
                    chunk = currentChunk;
                    relativeOffset = offset + currentOffset;
                }
                else {
                    chunk = headChunk;
                    relativeOffset = absoluteOffset;
                }
            }
            else
public class World1Controller : World
    private static GroundController groundController;
    private static CeilingController ceilingController;
    private static LeftWallController leftWallController;
    private static RightWallController rightWallController;
    private static FrontWallController frontWallController;
    private static BackWallController backWallController;
    void Start()
    {
        groundController = GetComponentInChildren<GroundController>();
        ceilingController = GetComponentInChildren<CeilingController>();
        leftWallController = GetComponentInChildren<LeftWallController>();
        rightWallController = GetComponentInChildren<RightWallController>();
        frontWallController = GetComponentInChildren<FrontWallController>();
        backWallController = GetComponentInChildren<BackWallController>();
    }
    public override Vector3 GetWorldCenter()
    {
        float x = (leftWallController.transform.position.x + rightWallController.transfo
namespace MFDExtractor
    public interface IInstrumentFormDataChangedHandler
    {
        void HandleDataChangedEvent(object sender, EventArgs e);
    }
    internal class InstrumentFormDataChangedHandler : IInstrumentFormDataChangedHandler
    {
	    private readonly InstrumentType _instrumentType;
        private readonly  InstrumentForm _instrumentForm;
	    private readonly IInstrumentFormSettingsWriter _instrumentFormSettingsWriter;
        public InstrumentFormDataChangedHandler(
            InstrumentType instrumentTYpe,
            InstrumentForm instrumentForm, 
			IInstrumentFormSettingsWriter instrumentFormSettingsWriter = null
            )
        {
	        _instrumentType = instrumentTYpe;
            _instrumentForm = instrumentForm;
	        _instrumentFormSettingsWriter = instrumentFormSettingsWriter ?? new InstrumentFormSettingsWriter();
        }
        public void HandleDataChangedEvent(object sender, EventArgs e)
        {
            var location = _instrument
namespace Shinetech.PointEstimation.Services.Impl
    public class EstimationService : IEstimationService
    {
        private readonly IRepository<EstimationProcess> _processRepository;
        public EstimationService(IRepository<EstimationProcess> processRepository)
        {
            _processRepository = processRepository;
        }
        public EstimationProcess GetCurrentEstimationProcess() {
            return EstimationProcess.GetInstance();
        }
        [Transaction]
        public long StartNewEstimationProcess()
        {
            var currentEstimationProcess = GetCurrentEstimationProcess();
            if (currentEstimationProcess != null)
                return currentEstimationProcess.Id;
            var process = EstimationProcess.StartNew();
            _processRepository.Create(process);
            return process.Id;
        }
        [Transaction]
        public EstimationPoint Estimate(string voter, int point)
        {
            var currentEstimatio

            if (currentEstimationProcess == null)
                throw new NotEstimationProcessRunningException();
            var estimationPoint = currentEstimationProcess.Estimate(voter, point);
            _processRepository.Update(currentEstimationProcess);
            return estimationPoint;
        }
        [Transaction]
        public long Finish()
        {
            var currentEstimationProcess = GetCurrentEstimationProcess();
            if (currentEstimationProcess == null)
                throw new NotEstimationProcessRunningException();
            currentEstimationProcess.Finish();
            _processRepository.Update(currentEstimationProcess);
            return currentEstimationProcess.Id;
        }
        [Transaction]
        public void Cancel()
        {
            var currentEstimationProcess = GetCurrentEstimationProcess();
            if (currentEstimationProcess == null)
                return;
            _processRepository.Delete(currentEstimationProc
namespace prayerapplication
	partial class MenuController : BaseController
	{
		public MenuController (IntPtr handle) : base (handle)
		{
		}
		public override void ViewDidLoad ()
		{					
			base.ViewDidLoad ();
			var activityController = (ActivityController)Storyboard.InstantiateViewController("ActivityController");
			var prayerRequestController = (PrayerRequestController)Storyboard.InstantiateViewController("PrayerRequestController");
			var praiseReportController = (PraiseReportController)Storyboard.InstantiateViewController("PraiseReportController");
			var groupsController = (GroupsController)Storyboard.InstantiateViewController("GroupsController");
			var friendsController = (FriendsController)Storyboard.InstantiateViewController("FriendsController");
			var settingsController = (SettingsController)Storyboard.InstantiateViewController("SettingsController");
			ActivityButton.TouchUpInside += (o, e) => {
				if (NavController.TopViewController as ActivityController == null){
		

					if (ex != null)
					{
						NavController.PopToViewController(ex,true);
					} else {
					NavController.PushViewController (activityController, false);
					}
				}
				SidebarController.CloseMenu ();
			};
			PrayerRequestsButton.TouchUpInside += (o, e) => {
				if (NavController.TopViewController as PrayerRequestController == null){
					var ex = NavController.ViewControllers.OfType<PrayerRequestController>().FirstOrDefault();
					if (ex != null)
					{
						NavController.PopToViewController(ex,true);
					} else {
						NavController.PushViewController (prayerRequestController, false);
					}
				}
				SidebarController.CloseMenu ();
			};
			PraiseReportsButton.TouchUpInside += (o, e) => {
					if (NavController.TopViewController as PraiseReportController == null){
					var ex = NavController.ViewControllers.OfType<PraiseReportController>().FirstOrDefault();
						if (ex != null)
						{
							NavController.PopToViewController(ex,true);
						} else {
					NavController.

						}
				}
				SidebarController.CloseMenu ();
			};
			GroupsButton.TouchUpInside += (o, e) => {
				if (NavController.TopViewController as GroupsController == null){
					var ex = NavController.ViewControllers.OfType<GroupsController>().FirstOrDefault();
					if (ex != null)
					{
						NavController.PopToViewController(ex,true);
					} else {
					NavController.PushViewController (groupsController, false);
					}
				}
				SidebarController.CloseMenu ();
			};
			FriendsButton.TouchUpInside += (o, e) => {
				if (NavController.TopViewController as FriendsController == null){
					var ex = NavController.ViewControllers.OfType<FriendsController>().FirstOrDefault();
					if (ex != null)
					{
						NavController.PopToViewController(ex,true);
					} else {
					NavController.PushViewController (friendsController, false);
					}
				}
				SidebarController.CloseMenu ();
			};
			SettingsButton.TouchUpInside += (o, e) => {
				if (NavController.TopViewController as SettingsControlle
namespace WebInstruments.Controllers
    [AuthorizationFilter]
    public class InstrumentController : Controller
    {
        private ApplicationDbContext _context;
        public InstrumentController()
        {
            _context = new ApplicationDbContext();
        }
        public ActionResult InstrumentList()
        {
            var viewModel = new NewInstrumentViewModel()
            {
                InstrumentTypes = _context.InstrumentTypes.ToList(),
                MeasurementUnits = _context.MeasurementUnits.ToList(),
                Suppliers = _context.Suppliers.ToList(),
                Instruments = _context.Instruments.ToList()
            };
            return View(viewModel);
        }
        [HttpPost]
        public ActionResult Save(NewInstrumentViewModel viemModel)
        {
            var instrument = viemModel.Instrument;
            if (instrument.Id == 0)
            {
                instrument.RegisterDate = DateTime.Now;
                instrument.

                _context.Instruments.Add(instrument);
            }
            else
            {
                var instrumentToModify = _context
                    .Instruments
                    .SingleOrDefault(i => i.Id == instrument.Id);
                if (instrumentToModify == null)
                    return HttpNotFound();
                instrumentToModify.Code = instrument.Code;
                instrumentToModify.IdMeasurementUnit = instrument.IdMeasurementUnit;
                instrumentToModify.MinimumValue = instrument.MinimumValue;
                instrumentToModify.MaximumValue = instrument.MaximumValue;
                instrumentToModify.IdSupplier = instrument.IdSupplier;
                instrumentToModify.IdInstrumentType = instrument.IdInstrumentType;
            }
            _context.SaveChanges();
            return RedirectToAction("InstrumentList", "Instrument");
        }
        
        [HttpPost]
        public ActionResult Remove(int id)
        {
  
public class World : MonoBehaviour
	public float size = 2f;
	public int blockResolution = 8;
	public int chunkResolution = 2;
	[SerializeField] private GameObject _chunkPrefab;
	private Chunk[] _chunks;
	private float _chunkSize;
	private float _blockSize;
	private float _halfSize;
	private void Awake ()
	{
		_chunkSize = size / chunkResolution;
		_blockSize = _chunkSize / blockResolution;
		_chunks = new Chunk[chunkResolution * chunkResolution];
		for (int i = 0, y = 0; y < chunkResolution; y++)
		{
			for (int x = 0; x < chunkResolution; x++, i++)
			{
				CreateChunk(i, x, y);
			}
		}
	}
	private void CreateChunk(int i, int x, int y)
	{
		GameObject chunk = (GameObject)Instantiate(_chunkPrefab, this.transform);
		chunk.name = string.Format("Chunk[{0},{1}]", x, y);
		chunk.transform.localPosition = new Vector3(x * _chunkSize, y * _chunkSize);
		Chunk c = chunk.GetComponent<Chunk>();
		if (c != null)
		{
			c.Init(blockResolution, _chunkSize);
		}
		else
		{
			Debug.LogErrorFormat("
public class BasicChunkGenerator : TileMapChunkGenerator
	[System.Serializable]
	public class ChunkMap : Map<IPair, TileChunk>
	{ }
	public ChunkMap chunks;
	public void OnEnable()
	{
		chunks = new ChunkMap();
	}
	public override TileChunk GetChunk(TileMap tile_map, int pos_x, int pos_y)
	{
		IPair index = new IPair(pos_x, pos_y);
		if (!chunks.ContainsKey(index))
		{
			TileChunk chunk = ScriptableObject.CreateInstance<TileChunk>();
			chunk.index_x = pos_x;
			chunk.index_y = pos_y;
			chunk.pos_x = pos_x * tile_map.chunk_size_x;
			chunk.pos_y = pos_y * tile_map.chunk_size_y;
			chunk.size_x = tile_map.chunk_size_x;
			chunk.size_y = tile_map.chunk_size_y;
			TileChunkDataLayer data_layer = new TileChunkDataLayer(chunk.size_x, chunk.size_y);
			for (int i = 0; i < chunk.size_x * chunk.size_y; ++i)
				data_layer.ids[i] = (Random.value >= 0.5f ? 1 : 0);
			chunk.data_layers = new List<TileChunkDataLayer>();
			chunk.user_data = new List<ScriptableObject>();
			chunk.data_layers.Add(
namespace FluentSharp.WinForms
    public static class Thread_Invoke_ExtensionMethods
    {        
        private static T    invokeThread<T>(Func<T> codeToInvoke)
        { 
            try
            {
                return codeToInvoke();
            }
            catch (Exception ex)
            {
                ex.log("[in invokeThread<T>]");
                return default(T);
            }                                                 
        }
		public static T     invokeOnThread<T>(this Control control, Func<T> codeToInvoke)
		{
			return control.invokeOnThread(-1, codeToInvoke);
		}
		public static T     invokeOnThread<T>(this Control control,int maxInvokeWait, Func<T> codeToInvoke)
        {            
            try
            {
                if (control.isNull() || control.IsDisposed)
                    return default(T);
                if (control.InvokeRequired)
                {
                    T returnData = default(T);
                    var sync = 

                    if (control.IsDisposed)
                        return default(T);                    
                    control.Invoke(new EventHandler((sender, e) =>
                        {                            
                            if (control.IsDisposed.isFalse())
                                returnData = invokeThread(codeToInvoke);
                            sync.Set();
                        }));
					if (maxInvokeWait == -1)
						sync.WaitOne();
					else
						if (sync.WaitOne(maxInvokeWait).isFalse())
						{
							"[in invokeOnThread] Func<T> codeToInvoke took more than {0}s to execute".error(maxInvokeWait);
							return default(T);
						}                                        
                    return returnData;
                }
                return codeToInvoke();
            }
            catch (System.ComponentModel.InvalidAsynchronousStateException)
            { 
            }
            catch (Exception ex)
            {
         

            }
            return default(T);
        }        
        private static void invokeThread(Action codeToInvoke)
        {
            try
            {
                codeToInvoke();
            }
            catch (Exception ex)
            {
                ex.log("[invokeThread]");                
            }
        }
        public static void  invokeOnThread(this Control control, Action codeToInvoke)
        {
            if (control.isNull() || control.IsDisposed)
            {
                return;
            }
            try
            {
                if (control.InvokeRequired)
                {                    
                    control.Invoke(new EventHandler((sender, e)=>
                        {
                            if (control.IsDisposed)
                                return;
                            invokeThread(codeToInvoke);
                        }));
                }
                else
                    codeToInvoke();
namespace Rental.Repository
    public class UnitOfWork
    {
        private RentalEntities _edm = null;
        private SliderRepository _sliderRepository = null;
        private RoomRepository _roomRepository = null;
        private AreaRepository _areaRepository = null;
        private ServiceRepository _serviceRepository = null;
        private FoodRepository _foodRepository = null;
        private PreferenceRepository _preferenceRepository = null;
        private AboutRepository _aboutRepository = null;
        public UnitOfWork()
        {
            _edm = new RentalEntities();
        }
        public AboutRepository AboutRepository
        {
        }
        public PreferenceRepository PreferenceRepository
        {
            get
            {
                if (_preferenceRepository == null)
                {
                    _preferenceRepository = new PreferenceRepository(_edm);
                }
                return _preferenceRepository;
            }
        }

        public ServiceRepository ServiceRepository
        {
            get
            {
                if (_serviceRepository == null)
                {
                    _serviceRepository = new ServiceRepository(_edm);
                }
                return _serviceRepository;
            }
        }
        public FoodRepository FoodRepository
        {
            get
            {
                if (_foodRepository == null)
                {
                    _foodRepository = new FoodRepository(_edm);
                }
                return _foodRepository;
            }
        }
        public RoomRepository RoomRepository
        {
            get
            {
                if (_roomRepository == null)
                {
                    _roomRepository = new RoomRepository(_edm);
                }
                return _roomRepository;
            }
        }
        public AreaRepository AreaRepository
        {
            get
            {
              
namespace Cats.Services.Hub
    public class DispatchAllocationService : IDispatchAllocationService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IShippingInstructionService _shippingInstructionService;
        public DispatchAllocationService(IUnitOfWork unitOfWork, IShippingInstructionService shippingInstructionService)
        {
            this._unitOfWork = unitOfWork;
            this._shippingInstructionService = shippingInstructionService;
        }
        #region Default Service Implementation
        public bool AddDispatchAllocation(DispatchAllocation dispatchAllocation)
        {
            _unitOfWork.DispatchAllocationRepository.Add(dispatchAllocation);
            _unitOfWork.Save();
            return true;
        }
        public bool EditDispatchAllocation(DispatchAllocation dispatchAllocation)
        {
            _unitOfWork.DispatchAllocationRepository.Edit(dispatchAllocation);
            _unitOfWork.Save();
            retur

        }
        public bool DeleteDispatchAllocation(DispatchAllocation dispatchAllocation)
        {
            if (dispatchAllocation == null) return false;
            _unitOfWork.DispatchAllocationRepository.Delete(dispatchAllocation);
            _unitOfWork.Save();
            return true;
        }
        public bool DeleteById(int id)
        {
            var entity = _unitOfWork.DispatchAllocationRepository.FindById(id);
            if (entity == null) return false;
            _unitOfWork.DispatchAllocationRepository.Delete(entity);
            _unitOfWork.Save();
            return true;
        }
        public List<DispatchAllocation> GetAllDispatchAllocation()
        {
            return _unitOfWork.DispatchAllocationRepository.GetAll();
        }
        public DispatchAllocation FindById(int id)
        {
            return _unitOfWork.DispatchAllocationRepository.FindById(id);
        }
        public DispatchAllocation FindById(System.Guid id)
        {
       

        }
        public List<DispatchAllocation> FindBy(Expression<Func<DispatchAllocation, bool>> predicate)
        {
            return _unitOfWork.DispatchAllocationRepository.FindBy(predicate);
        }
        #endregion
        public decimal GetUncommitedBalance(int siNumber, int commodityId, int hubId)
        {
            var total = (from tr in _unitOfWork.TransactionRepository.GetAll()
                         where tr.LedgerID == Cats.Models.Ledger.Constants.GOODS_ON_HAND_UNCOMMITED
                               && tr.ShippingInstructionID == siNumber &&
                               (tr.CommodityID == commodityId || tr.ParentCommodityID == commodityId) &&
                               tr.HubID == hubId
                         select tr.QuantityInMT);
            if (total.Any())
            {
                return total.Sum();
            }
            return 0;
        }
        public List<DispatchAllocation> GetUncommitedAllocationsByHub(int hubId)
        {
 
namespace ScripturePublishingService.Services
    public class ProcessService : IProcessService
    {
        private readonly IProcessRepository _processRepository;
        public ProcessService(IProcessRepository processRepository)
        {
            _processRepository = processRepository;
        }
        public Process GetProcessById(int id)
        {
            return _processRepository.GetById(id);
        }
        public List<Process> GetProcesses()
        {
            return _processRepository.Get().ToList();
        }
        public Process Create(string name, int version)
        {
            var process = new Process {
                Name = name,
                Version = version
            };
            return _processRepository.Add(process);
        }
        public Process Update(Process process)
        {
            return _processRepository.Update(process);
        }
        public void Delete(Process process)
        {
            _processRepository.Delete
namespace CleanArchitecture.Application.Sales.Commands.CreateSale.Repository
    public class SaleRepositoryFacade : ISaleRepositoryFacade
    {
        private readonly ICustomerRepository _customerRepository;
        private readonly IEmployeeRepository _employeeRepository;
        private readonly IProductRepository _productRepository;
        private readonly ISaleRepository _saleRepository;
        public SaleRepositoryFacade(
            ICustomerRepository customerRepository,
            IEmployeeRepository employeeRepository,
            IProductRepository productRepository,
            ISaleRepository saleRepository)
        {
            _customerRepository = customerRepository;
            _employeeRepository = employeeRepository;
            _productRepository = productRepository;
            _saleRepository = saleRepository;
        }
        public Customer GetCustomer(int customerId)
        {
            return _customerRepository.Get(customerId);
        }
        publ
namespace Zamin.Repositories
    public class UnitOfWork : UnitOfWorkBase<DataContext>
    {
        private IUsersRepository _usersRepository;
        public IUsersRepository UsersRepository
        {
            get { return _usersRepository ?? (_usersRepository = new UsersRepository(DataContext)); }
        }
        private ICourseRepository _courseRepository;
        public ICourseRepository CourseRepository
        {
            get { return _courseRepository ?? (_courseRepository = new CourseRepository(DataContext)); }
        }
        private ILessonRepository _lessonRepository;
        public ILessonRepository LessonRepository
        {
            get { return _lessonRepository ?? (_lessonRepository = new LessonRepository(DataContext)); }
        }
        private ILessonPlanRepository _lessonPlanRepository;
        public ILessonPlanRepository LessonPlanRepository
        {
            get { return _lessonPlanRepository ?? (_lessonPlanRepository = new LessonPlanRepository(D

        }
        private ICategoryRepository _categoryRepository;
        public ICategoryRepository CategoryRepository
        {
            get { return _categoryRepository ?? (_categoryRepository = new CategoryRepository(DataContext)); }
        }
        private ITagRepository _tagRepository;
        public ITagRepository TagRepository
        {
            get { return _tagRepository ?? (_tagRepository = new TagRepository(DataContext)); }
        }
        private IPosterRepository _posterRepository;
        public IPosterRepository PosterRepository
        {
            get { return _posterRepository ?? (_posterRepository = new PosterRepository(DataContext)); }
        }
        private IGalleryImageRepository _galleryImageRepository;
        public IGalleryImageRepository GalleryImageRepository
        {
            get { return _galleryImageRepository ?? (_galleryImageRepository = new GalleryImageRepository(DataContext)); }
        }
        private IArticleRepository _articl
namespace Sic.Apollo.Models
    public class ContextService : Sic.Data.Entity.DbContextService<Context>, IDisposable        
    {
        public ContextService()
            :base("Context",true)
        {
        }
        private Repository<Contact> contactRepository;
        private SpecializationRepository specializationRepository;
        private Repository<Institution> institutionRepository;
        private Repository<Country> countryRepository;
        private Repository<State> stateRepository;
        private Repository<City> cityRepository;
        private Repository<ContactLocation> contactLocationRepository;
        private Repository<ContactLocationPicture> contactLocationPictureRepository;
        private ProfessionalOfficeRepository professionalOfficeRepository;
        private Repository<ProfessionalSchool> professionalSchoolRepository;
        private Repository<ProfessionalCommunity> professionalCommunityRepository;
        private Repository<ProfessionalExperience> p

        private Repository<ProfessionalInsuranceInstitutionPlan> professionalInsuranceInstitutionPlanRepository;
        private Repository<InsuranceInstitutionPlan> insuranceInstitutionPlanRepository;
        private Repository<CustomerProfessional> customerProfessionalRepository;
        private Repository<ProfessionalOfficeSchedule> professionalOfficeScheduleRepository;
        private Repository<ProfessionalSpecialization> professionalSpecializationRepository;
        private Repository<ProfessionalTeam> professionalTeamRepository;
        
        private UserRepository userRepository;
        private ProfessionalRepository professionalRepository;
        private CustomerRepository customerRepository;
        private InsuranceInstitutionRepository insuranceInstitutionRepository;
        private AppointmentRepository appointmentRepository;
        private AppointmentTransactionRepository appointmentTransactionRepository;
        private SpecializationAppointmentReasonRepository sp

        private PatientRepository patientRepository;
        private Repository<ProfessionalPatient> professionalPatientRepository;
        private Repository<PatientInsuranceInstitution> patientInsuranceInstitutionRepository;
        private Repository<MedicalCare> medicalCareRepository;
        private Repository<PatientVitalSign> patientVitalSignRepository;
        private Repository<VitalSign> vitalSignRepository;
        private Repository<MedicalProblem> medicalProblemRepository;
        private Repository<MedicalHistory> medicalHistoryRepository;
        private Repository<ProfessionalVademecum> professionalVademecumRepository;
        private Repository<MedicalCareMedication> medicalCareMedicationRepository;
        private Repository<PhysicalExamination> physicalExaminationRepository;
        private Repository<PatientPhysicalExamination> patientPhysicalExaminationRepository;
        private Repository<PatientFile> patientFileRepository;
        #region Security Repositories

namespace ProcessScheduler
    public static class ProcessManager
    {
        public static void SuspendProcess(Process process)
        {
            if ((process == null) || (process.HasExited)) return;
            ProcessThreadCollection collection = process.Threads;
            foreach (ProcessThread thread in collection)
                ThreadManager.SuspendThread(thread);
        }
        public static void ResumeProcess(Process process)
        {
            if ((process == null) || (process.HasExited)) return;
            ProcessThreadCollection collection = process.Threads;
            foreach (ProcessThread thread in collection)
                ThreadManager.ResumeThread(thread);
        }
        public static void TerminateProcess(Process process)
        {
            if ((process == null) || (process.HasExited)) return;
            ProcessThreadCollection collection = process.Threads;
            foreach (ProcessThread thread in collection)
                ThreadManage
public interface ILoadingStep
	DefineBase.LOAD_STEP Load_Step	{ get; set; }
	void Update();
	void LoadStep();
	void LoadStep1();
	void LoadStep2();
	void LoadStep3();
	void LoadStep4();
	void LoadStep5();
	void LoadStep1_End();
	void LoadStep2_End();
	void LoadStep3_End();
	void LoadStep4_End();
	void LoadStep5_End();
	void LoadStepLoading_End();
	void EndLoadStep();
/*
#region ILoadingStep
	private LOAD_STEP	m_vLoadStep;
	public void Update()
	{
		if(Load_Step != LOAD_STEP._NULL)
		{
			LoadStep();
		}
	}
	public DefineBase.LOAD_STEP Load_Step
	{
		get { return m_vLoadStep; }
		set { m_vLoadStep = value; }
	}
	public void LoadStep()
	{
		switch(Load_Step)
		{
		case LOAD_STEP._STEP1:		LoadStep1();		break;
		case LOAD_STEP._STEP1_END:	LoadStep1_End();	break;
		case LOAD_STEP._STEP2:		LoadStep2();		break;
		case LOAD_STEP._STEP2_END:	LoadStep2_End();	break;
		case LOAD_STEP._STEP3:		LoadStep3();		break;
		case LOAD_STEP._STEP3_END:	LoadStep3_End();	break;
		case LOAD_STEP._STEP4:		LoadS

		case LOAD_STEP._STEP4_END:	LoadStep4_End();	break;
		case LOAD_STEP._STEP5:		LoadStep5();		break;
		case LOAD_STEP._STEP5_END:	LoadStep5_End();	break;
		}
	}
	public virtual void LoadStep1()		{}
	public virtual void LoadStep2()		{}
	public virtual void LoadStep3()		{}
	public virtual void LoadStep4()		{}
	public virtual void LoadStep5()		{}
	public virtual void LoadStep1_End()	{}
	public virtual void LoadStep2_End()	{}
	public virtual void LoadStep3_End()	{}
	public virtual void LoadStep4_End()	{}
	public virtual void LoadStep5_End()	{}
	public void LoadStepLoading_End()
	{
		switch(Load_Step)
		{
		case LOAD_STEP._STEP1_LOADING:	Load_Step	= LOAD_STEP._STEP1_END;		break;
		case LOAD_STEP._STEP2_LOADING:	Load_Step	= LOAD_STEP._STEP2_END;		break;
		case LOAD_STEP._STEP3_LOADING:	Load_Step	= LOAD_STEP._STEP3_END;		break;
		case LOAD_STEP._STEP4_LOADING:	Load_Step	= LOAD_STEP._STEP4_END;		break;
		case LOAD_STEP._STEP5_LOADING:	Load_Step	= LOAD_STEP._STEP5_END;		break;
		}
	}
	public vo
namespace Curan.Common.FormalizedData.File.Riff.Dls
	public class RiffChunkListInfo : RiffChunkList
	{
		public const string TYPE = "INFO";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public readonly RiffChunkIfil ifilBody;
		public readonly RiffChunkInam inamBody;
		public readonly RiffChunkIsng isngBody;
		public readonly RiffChunkIprd iprdBody;
		public readonly RiffChunkIeng iengBody;
		public readonly RiffChunkIsbj isbjBody;
		public readonly RiffChunkIsft isftBody;
		public readonly RiffChunkIcrd icrdBody;
		public readonly RiffChunkIcmt icmtBody;
		public readonly RiffChunkIcop icopBody;
		static RiffChunkListInfo()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkIfil.ID, typeof( RiffChunkIfil ) );
			chunkTypeDictionary.Add( RiffChunkInam.ID, typeof( RiffChunkInam ) );
			chunkTypeDictionary.Add( RiffChunkIsng.ID, typeof( RiffChunkIs

			chunkTypeDictionary.Add( RiffChunkIprd.ID, typeof( RiffChunkIprd ) );
			chunkTypeDictionary.Add( RiffChunkIeng.ID, typeof( RiffChunkIeng ) );
			chunkTypeDictionary.Add( RiffChunkIsbj.ID, typeof( RiffChunkIsbj ) );
			chunkTypeDictionary.Add( RiffChunkIsft.ID, typeof( RiffChunkIsft ) );
			chunkTypeDictionary.Add( RiffChunkIcrd.ID, typeof( RiffChunkIcrd ) );
			chunkTypeDictionary.Add( RiffChunkIcmt.ID, typeof( RiffChunkIcmt ) );
			chunkTypeDictionary.Add( RiffChunkIcop.ID, typeof( RiffChunkIcop ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
		}
		public RiffChunkListInfo( string aId, UInt32 aSize, ByteArray aByteArray, RiffChunkList aParent )
			: base( chunkTypeDictionary, bodyTypeDictionary, aId, aSize, aByteArray, aParent )
		{
			type = TYPE;
			ifilBody = ( RiffChunkIfil )GetChunk( RiffChunkIfil.ID );
			inamBody = ( RiffChunkInam )GetChunk( RiffChunkInam.ID );
			isngBody = ( RiffChunkIsng )GetChunk( RiffChunkIsng.ID );
			iprdBody = ( RiffChunkIprd )GetChunk
namespace TPP_MainProject.Models.repository
    public class UnitOfWork : IDisposable
    {
        private ApplicationDbContext context = new ApplicationDbContext();
        private GenericRepository<Order> orderRepository;
        private GenericRepository<ApplicationUser> applicationRepository;
        private GenericRepository<Accountant> accountantRepository;
        private GenericRepository<WorkItem> workItemRepository;
        private GenericRepository<Resourse> resourceRepository;
        private GenericRepository<ProductItem> productItemRepository;
        private GenericRepository<OrderDetail> orderDetailsRepository;
        private GenericRepository<Project> projectRepository;
        private GenericRepository<Cart> cartRepository;
        private GenericRepository<Manager> managerRepository;
        private GenericRepository<Catagorie> catagorieRepository;
        private GenericRepository<Customer> customerRepository;
        public GenericRepository<Customer> CustomerRep

        {
            get
            {
                if (this.customerRepository == null)
                {
                    this.customerRepository = new GenericRepository<Customer>(context);
                }
                return customerRepository;
            }
        }
        public GenericRepository<Catagorie> CatagorieRepositpry
        {
            get
            {
                if (this.catagorieRepository == null)
                {
                    this.catagorieRepository = new GenericRepository<Catagorie>(context);
                }
                return catagorieRepository;
            }
        }
        public GenericRepository<OrderDetail> OrderDetailRepository
        {
            get
            {
                if (this.orderDetailsRepository == null)
                {
                    this.orderDetailsRepository = new GenericRepository<OrderDetail>(context);
                }
                return orderDetailsRepository;
            }
      

        public GenericRepository<Cart> CartRepository
        {
            get
            {
                if (this.cartRepository == null)
                {
                    this.cartRepository = new GenericRepository<Cart>(context);
                }
                return cartRepository;
            }
        }
        public GenericRepository<ProductItem> ProductItemRepository
        {
            get
            {
                if (this.productItemRepository == null)
                {
                    this.productItemRepository = new GenericRepository<ProductItem>(context);
                }
                return productItemRepository;
            }
        }
        public GenericRepository<Project> ProjectRepository
        {
            get
            {
                if (this.projectRepository == null)
                {
                    this.projectRepository = new GenericRepository<Project>(context);
                }
                return projectRepositor
namespace Experior.Dematic.Base.Devices
    public class LoadWaitingStatus
    {
        public event EventHandler<LoadWaitingChangedEventArgs> OnLoadWaitingChanged;
        public void SetLoadWaiting(bool loadWaiting, bool loadDeleted)
        {
            LoadWaiting = loadWaiting;
            WaitingLoad = null;
            if (OnLoadWaitingChanged != null)
                OnLoadWaitingChanged(this, new LoadWaitingChangedEventArgs(loadWaiting, loadDeleted, null));
        }
        public void SetLoadWaiting(bool loadWaiting, bool loadDeleted, Load waitingLoad)
        {
            LoadWaiting = loadWaiting;
            WaitingLoad = waitingLoad;
            if (OnLoadWaitingChanged != null)
                OnLoadWaitingChanged(this, new LoadWaitingChangedEventArgs(loadWaiting, loadDeleted, waitingLoad));
        }
        private bool _LoadWaiting = false;
        public bool LoadWaiting
        {
            get { return _LoadWaiting; }
            set { _LoadWaiting = value; }

namespace AutoGestDAL.Implementation
    public interface IRepositoryAggregator
    {
        ICategoryServiceRepository CategoryService { get; }
        IClientRepository Client { get; }
        IClosetRepository ClosetRepository { get; }
        ICompanyRepository CompanyRepository { get; }
        IDetailsOrderRepairRepository DetailsOrderRepairRepository { get; }
        IEmployeeRepository EmployeeRepository { get; }
        IHallRepository HallRepository { get; }
        IMarkRepository MarkRepository { get; }
        IModelRepository ModelRepository { get; }
        IOrderRepairRepository OrderRepair { get; }
        IProductRepository ProductRepository { get; }
        IProductVersionRepository ProductVersionRepository { get; }
        IServiceCatalogRepository ServiceCatalogRepository { get; }
        IServiceCatalogVersionRepository ServiceCatalogVersionRepository { get; }
        IServiceInstRepository ServiceInstRepository { get; }
        IServiceInstVersionRepository Serv
namespace trading.Controllers
    [Route("/api/instrumentnames")]
    public class InstrumentNameController : Controller
    {
        private readonly IUnitOfWork uow;
        private readonly IMapper mapper;
        public InstrumentNameController(IUnitOfWork uow, IMapper mapper)
        {
            this.mapper = mapper;
            this.uow = uow;
        }
        [HttpGet]
        public IEnumerable<InstrumentNameResource> GetInstrumentNames()
        {
            var instrumentnames = uow.InstrumentNames.GetFull();
            return mapper.Map<IEnumerable<InstrumentName>, IEnumerable<InstrumentNameResource>>(instrumentnames);
        }
        
         [HttpGet("find/{name}")]
          public IActionResult FindInstrumentNames(string name){
           var instrumentName = uow.InstrumentNames.GetFull().FirstOrDefault(x => x.Name == name);
            if(instrumentName == null) return NotFound();
            return Ok(mapper.Map<InstrumentName,InstrumentNameResource>(instrumen

          }
         [HttpPost]
         public IActionResult CreateInstrumentName([FromBody] InstrumentName instrumentName){
             if(!ModelState.IsValid)
                return BadRequest(ModelState);
             uow.InstrumentNames.Add(instrumentName);
             uow.Complete();
             var result = mapper.Map<InstrumentName,InstrumentNameResource>(instrumentName);
             return Ok(result);
         }
         [HttpPut("{id}")]
         public IActionResult UpdateInstrumentName(int id,[FromBody] InstrumentName instrumentName){
             if(!ModelState.IsValid)
                return BadRequest(ModelState);
             var existingInstrumentName = uow.InstrumentNames.GetFull().FirstOrDefault(x => x.Id == id);
            if(existingInstrumentName == null){
                return NotFound();
            }
            existingInstrumentName.Name = instrumentName.Name;
             uow.Complete();
            var result = mapper.Map<InstrumentName,InstrumentNam
namespace Assets.Scripts.EngineLayer.Voxels.Containers.Chunks
    public class ChunkBorder
    {
        public bool IsSolid;
        public bool[,] VoxelAtPositionSolid;
        public ChunkData MyChunk;
        public ChunkData NeighbourChunk;
        public int Side;
        public ChunkBorder(ChunkData myChunk, int side)
        {
            MyChunk = myChunk;
            Side = side;
            UpdateBorder();
        }
        public void UpdateBorder()
        {
            VoxelAtPositionSolid = new bool[Chunk.ChunkSize, Chunk.ChunkSize];
            for (var a = 0; a < Chunk.ChunkSize; a++)
            {
                for (var b = 0; b < Chunk.ChunkSize; b++)
                {
                    VoxelAtPositionSolid[a, b] = MyChunk.GetVoxelActive(SideToOuterPlane(Side, a, b));
                    IsSolid = VoxelAtPositionSolid[a, b] && IsSolid;
                }
            }
            UpdateNeighbour();
        }
        public bool[,] GetNeighbourBorder()
        {
  

                return new bool[Chunk.ChunkSize,Chunk.ChunkSize];
            return NeighbourChunk.ChunkBorders[Side % 2 == 0 ? Side + 1 : Side - 1].VoxelAtPositionSolid;
        }
        public bool IsNeighbourSolid()
        {
            if (GetNeighbourChunk() == null)
                return false;
            return NeighbourChunk.ChunkBorders[Side % 2 == 0 ? Side + 1 : Side - 1].IsSolid;
        }
        private void UpdateNeighbour()
        {
            var neighbour = GetNeighbourChunk();
            if (neighbour != null)
                neighbour.BorderUpdate(Side % 2 == 0 ? Side + 1 : Side - 1);
        }
        private ChunkData GetNeighbourChunk()
        {
            return NeighbourChunk ?? (NeighbourChunk = World.At(MyChunk.Position + SideToDirection(Side) * Chunk.ChunkSize).GetChunkData());
        }
        private static Vector3 SideToOuterPlane(int side, float a, float b)
        {
            switch (side)
            {
                case 0: return new Ve
namespace VoxelEngine.Util {
    public class CachedChunk3x3 {
        private static CachedChunk3x3 region;
        private Chunk[] chunks;
        private CachedChunk3x3() {
            this.chunks = new Chunk[27];
        }
        public static CachedChunk3x3 getNewRegion(World world, Chunk chunk) {
            if(region == null) {
                region = new CachedChunk3x3();
            }
            Chunk c;
            int x1 = chunk.chunkPos.x;
            int y1 = chunk.chunkPos.y;
            int z1 = chunk.chunkPos.z; 
            for(int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    for (int z = -1; z <= 1; z++) {
                            c = world.getChunk(new ChunkPos(x + x1, y + y1, z + z1));
                            region.chunks[((y + 1) * 3 * 3) + ((z + 1) * 3) + (x + 1)] = c;
                    }
                }
            }
            return region;
        }
        public bool allChunksLoaded() {
          

                    if(chunks[i] == null) {
                        return false;
                    }
            }
            return true;
        }
        
        public Block getBlock(int x, int y, int z) {
            int localX = x + (x < 0 ? Chunk.SIZE : x >= Chunk.SIZE ? -Chunk.SIZE : 0);
            int localY = y + (y < 0 ? Chunk.SIZE : y >= Chunk.SIZE ? -Chunk.SIZE : 0);
            int localZ = z + (z < 0 ? Chunk.SIZE : z >= Chunk.SIZE ? -Chunk.SIZE : 0);
            return this.getChunk(x, y, z).getBlock(localX, localY, localZ);
        }
        private Chunk c;
        public void setBlock(int x, int y, int z, Block block, int meta = -1) {
            int localX = x + (x < 0 ? Chunk.SIZE : x >= Chunk.SIZE ? -Chunk.SIZE : 0);
            int localY = y + (y < 0 ? Chunk.SIZE : y >= Chunk.SIZE ? -Chunk.SIZE : 0);
            int localZ = z + (z < 0 ? Chunk.SIZE : z >= Chunk.SIZE ? -Chunk.SIZE : 0);
            c = this.getChunk(x, y, z);
            c.setBlock(localX, 
namespace Host.PL
    public class InstrumentListViewModel : BindableBase
    {
        private InstrumentListViewModel() { }
        private static readonly InstrumentListViewModel instance = new InstrumentListViewModel();
        public static InstrumentListViewModel Instance { get { return instance; } }
        private Instrument[] instruments;
        public Instrument[] Instruments
        {
            get
            {
                return this.instruments;
            }
            set
            {
                this.instruments = value;
                this.NotifyPropertyChanged("Instruments");
            }
        }
        public Command ChooseQuotationCommand
        {
            get
            {
                return new Command(this.DoChooseQuotation);
            }
        }
        private void DoChooseQuotation(object obj)
        {
            if (obj != null)
            {
                QuotationListViewModel.Instance.TryAdd(((Instrument)obj).InstrumentID)
namespace Peto.OCR.Chunks {
    public class NonSpecificChunk : Chunk {
        public NonSpecificChunk(string content) : base(content) { }
        private ChunkModel ChunkModel { get; set; }
        public List<ChunkIdentifierModel> PossibleIdentities { get; private set; }
       
        public Chunk SpecifyChunk() {
            List<ChunkIdentifierModel> _identifiers = IdentifyChunk();
            ChunkIdentifierModel _chunkIdentity = null;
            Chunk chunk = this;
            if(_identifiers.Count == 1) {
                _chunkIdentity = _identifiers.First();
                switch (_chunkIdentity.Type) {
                    case ChunkType.Email:
                        chunk = new EmailChunk(this.Content, _chunkIdentity.Type);
                        break;
                    case ChunkType.Name:
                        chunk = new NameChunk(this.Content, _chunkIdentity.Type);
                        break;
                    case ChunkType.Phone:
                        
namespace StoryboardSample
	public partial class RootViewController : UIViewController
	{
		private UIStoryboard _storyboard;
		public SidebarNavigation.SidebarController SidebarController { get; private set; }
		public NavController NavController { get; private set; }
		public override UIStoryboard Storyboard {
			get {
				if (_storyboard == null)
					_storyboard = UIStoryboard.FromName("Phone", null);
				return _storyboard;
			}
		}
		public RootViewController() : base(null, null)
		{
		}
		public override void ViewDidLoad()
		{
			base.ViewDidLoad();
			var introController = (IntroController)Storyboard.InstantiateViewController("IntroController");
			var menuController = (MenuController)Storyboard.InstantiateViewController("MenuController");
			NavController = new NavController();
			NavController.PushViewController(introController, false);
			SidebarController = new SidebarNavigation.SidebarController(this, NavController, menuController);
			SidebarController.MenuWidth = 220;
		
namespace Typer.DAL.Infrastructure
    public class RepositoryFactory
    {
        private static readonly IUsersRepository UsersRepository;
        private static readonly IQuestionsRepository QuestionsRepository;
        private static readonly ILanguageRepository LanguageRepository;
        private static readonly IWordsRepository WordsRepository;
        private static readonly ICategoryRepository CategoryRepository;
        private static readonly IGrammarRepository GrammarRepository;
        static RepositoryFactory()
        {
            UsersRepository = new EFUsersRepository();
            QuestionsRepository = new EFQuestionsRepository();
            LanguageRepository = new EFLanguageRepository();
            WordsRepository = new EfWordsRepository();
            CategoryRepository = new EfCategoriesRepository();
            GrammarRepository = new EfGrammarRepository();
        }
        public static IUsersRepository GetUsersRepository()
        {
            return User
namespace Umbra.Utilities.Threading
	public class SetupThread
	{
		ChunkQueue LoadQueue;
		ChunkQueue GenerationQueue;
		ChunkQueue VegetationQueue;
		ChunkQueue UnloadQueue;
		public SetupThread()
		{
			LoadQueue = new ChunkQueue();
			GenerationQueue = new ChunkQueue();
			VegetationQueue = new ChunkQueue();
			UnloadQueue = new ChunkQueue();
		}
		public void AddToLoad(Chunk chunk)
		{
			LoadQueue.Enqueue(chunk);
		}
		public void AddToGeneration(Chunk chunk)
		{
			GenerationQueue.Enqueue(chunk);
		}
		public void AddToVegetation(Chunk chunk)
		{
			VegetationQueue.Enqueue(chunk);
		}
		public void AddToUnload(Chunk chunk)
		{
			if (!LoadQueue.Contains(chunk))
			{
				UnloadQueue.Enqueue(chunk);
			}
			LoadQueue.Remove(chunk);
			GenerationQueue.Remove(chunk);
			VegetationQueue.Remove(chunk);
		}
		public void Run()
		{
			Chunk currentChunk;
			while (true)
			{
				if (!Variables.Game.IsInitialized)
				{
					continue;
				}
				if (UnloadQueue.Count > 0)
				{
					curren

					if (currentChunk == null)
					{
						continue;
					}
					if (Constants.World.SaveDynamicWorld)
					{
						ChunkManager.SaveChunk(currentChunk);
					}
					else
					{
						currentChunk = null;
					}
					Console.Write("UnloadQueue: " + UnloadQueue.Count);
					LoadQueue.Remove(currentChunk);
					GenerationQueue.Remove(currentChunk);
				}
				else if (LoadQueue.Count > 0)
				{
					currentChunk = LoadQueue.Dequeue();
					if (currentChunk == null)
					{
						continue;
					}
					ChunkManager.LoadChunkImmediate(currentChunk);
					Console.Write("LoadQueue: " + LoadQueue.Count);
				}
				else if (GenerationQueue.Count > 0)
				{
					currentChunk = GenerationQueue.Dequeue();
					if (currentChunk == null)
					{
						continue;
					}
					TerrainGenerator.SetChunkTerrain(currentChunk);
					Console.Write("GenerationQueue: " + GenerationQueue.Count);
					if (VegetationQueue.Contains(currentChunk))
					{
						VegetationQueue.Remove(currentChunk);
						VegetationQu
namespace CourseServer.Views
    public class DispatchView : View<Dispatch>
    {
        public override string Show(List<Dispatch> recordSet)
        {
            if (Empty(recordSet)) return Success();
            JObject obj;
            JArray jArray = new JArray();
            foreach (Dispatch dispatch in recordSet)
            {
                obj = new JObject();
                obj.Add(new JProperty("Id", dispatch.Id));
                obj.Add(new JProperty("Name", dispatch.Course.Name));
                obj.Add(new JProperty("TeacherName", dispatch.Teacher.Name));
                obj.Add(new JProperty("Weekday", dispatch.Weekday));
                obj.Add(new JProperty("At", dispatch.At));
                obj.Add(new JProperty("Location", dispatch.Classroom.Location));
                obj.Add(new JProperty("Limit", dispatch.Limit));
                obj.Add(new JProperty("Current", dispatch.Current));
                jArray.Add(obj);
            }
            return Success

        }
        public string ShowAvailableCourse(Dictionary<string, List<Dispatch>> recordList)
        {
            if (recordList == null || recordList.Count == 0)
                return Success();
            JObject jDispatch, jMajors = new JObject();
            JArray jDispatches;
            foreach (var pair in recordList)
            {
                jDispatches = new JArray();
                foreach (var dispatch in pair.Value)
                {
                    jDispatch = new JObject();
                    jDispatch.Add(new JProperty("Id", dispatch.Id));
                    jDispatch.Add(new JProperty("Name", dispatch.Course.Name));
                    jDispatch.Add(new JProperty("Description", dispatch.Course.Description));
                    jDispatch.Add(new JProperty("Weekday", dispatch.Weekday));
                    jDispatch.Add(new JProperty("At", dispatch.At));
                    jDispatch.Add(new JProperty("Limit", dispatch.Limit));
                    
﻿namespace PVT.Q1._2017.Shop.Tests.Moq
    public class RepositoryFactoryMoq : IRepositoryFactory
    {
        private readonly AlbumRepositoryMoq _albumRepositoryMoq = new AlbumRepositoryMoq();
        private readonly ArtistRepositoryMoq _artistRepositoryMoq = new ArtistRepositoryMoq();
        private readonly TrackRepositoryMoq _trackRepositoryMoq = new TrackRepositoryMoq();
        private readonly CurrencyRepositoryMoq _currencyRepositoryMoq = new CurrencyRepositoryMoq();
        private readonly AlbumPriceRepositoryMoq _albumPriceRepositoryMoq = new AlbumPriceRepositoryMoq();
        private readonly CurrencyRateRepositorMoq _currencyRateRepositorMoq = new CurrencyRateRepositorMoq();
        private readonly FeedbackRepositoryMoq _feedbackRepositoryMoq = new FeedbackRepositoryMoq();
        private readonly GenreRepositoryMoq _genreRepositoryMoq = new GenreRepositoryMoq();
        private readonly PriceLevelRepositoryMoq _priceLevelRepositoryMoq = new PriceLevelRepositoryMoq();

        private readonly TrackPriceRepositoryMoq _trackPriceRepositoryMoq = new TrackPriceRepositoryMoq();
        private readonly UserDataRepositoryMoq _userDataRepositoryMoq = new UserDataRepositoryMoq();
        private readonly VoteRepositoryMoq _voteRepositoryMoq = new VoteRepositoryMoq();
        private readonly AlbumTrackRelationRepositoryMoq _albumTrackRelationRepositoryMoq = new AlbumTrackRelationRepositoryMoq();
        private readonly UserRepositoryMoq _userRepositoryMoq = new UserRepositoryMoq();
        private readonly SettingRepositoryMoq _settingRepositoryMoq = new SettingRepositoryMoq();
        private readonly OrderTrackRepositoryMoq _orderTrackRepositoryMoq = new OrderTrackRepositoryMoq();
        private readonly OrderAlbumRepositoryMoq _orderAlbumRepositoryMoq = new OrderAlbumRepositoryMoq();
        private readonly PurchasedTrackRepositoryMoq _purchasedTrackRepositoryMoq = new PurchasedTrackRepositoryMoq();
        private readonly PurchasedAlbumRepositoryMo

        private readonly PaymentTransactionRepositoryMoq _paymentTransactionRepositoryMoq = new PaymentTransactionRepositoryMoq();
        private readonly UserPaymentMethodRepositoryMoq _userPaymentMethodRepositoryMoq = new UserPaymentMethodRepositoryMoq();
        public IAlbumRepository GetAlbumRepository()
        {
            return _albumRepositoryMoq.Repository;
        }
        public IArtistRepository GetArtistRepository()
        {
            return _artistRepositoryMoq.Repository;
        }
        public ITrackRepository GetTrackRepository()
        {
            return _trackRepositoryMoq.Repository;
        }
        public ICurrencyRepository GetCurrencyRepository()
        {
            return _currencyRepositoryMoq.Repository;
        }
        public IAlbumPriceRepository GetAlbumPriceRepository()
        {
            return _albumPriceRepositoryMoq.Repository;
        }
        public ICurrencyRateRepository GetCurrencyRateRepository()
        {
            retu
namespace Tests.Unit.Entities
    [TestFixture]
    public class PayPalPaymentInstrumentUnitTests
    {
        [Test]
        public void TestConstructIsInstanceOfEntity()
        {
            var PaymentInstrument = new PayPalPaymentInstrument();
            Assert.IsInstanceOf<PayPalPaymentInstrument>(PaymentInstrument);
        }
        [Test]
        public void TestMethodIsEqualTo()
        {
            var PaymentInstrument = new PayPalPaymentInstrument();
            Assert.AreEqual("pay-pal", PaymentInstrument.Method);
        }
        [Test]
        public void TestPayPalAccountIdDefaultIsEqualTo()
        {
            var PaymentInstrument = new PayPalPaymentInstrument();
            Assert.IsNull(PaymentInstrument.PayPalAccountId);
        }
        [Test]
        public void TestPayPalAccountIdIsEqualTo()
        {
            var PaymentInstrument = new PayPalPaymentInstrument();
            PaymentInstrument.PayPalAccountId = "test2";
            Assert.AreEqual("te
public class TerrainGenerator : MonoBehaviour {
    public int MapWidth, MapHeight;
    private ChunkGenerator ChunkGen = new ChunkGenerator();
    public Transform TileTemplate;
    private GameObject Map;
    private GameObject[] Detectors;
    private bool _performChunkLoad;
    private int _currentChunkPosX, _currentChunkPosY;
    private List<string> _chunkNames;
    void Start()
    {
        _chunkNames = new List<string>();
        Map = new GameObject();
        Detectors = GameObject.FindGameObjectsWithTag("Detector");
        var player = GameObject.FindGameObjectWithTag("Player").transform;
        InitializeChunk(ChunkGen.GenerateChunk(), (int)(player.position.x / ChunkGen.ChunkWidth), (int)(player.position.y / ChunkGen.ChunkHeight));
        ClearSpawn();
        
    }
    void Update()
    {
        RenderChunks();
    }
    void ClearSpawn()
    {
        var player = GameObject.FindGameObjectWithTag("Player").transform;
        for (int i = -2; i < 2; i++)
        {
 

            {
                DeleteTile(player.position + new Vector3(i, j));
            }
        }
    }
    void RenderChunks()
    {
        foreach (GameObject Detector in Detectors)
        {
            var detectorXPosition = Detector.transform.position.x;
            var detectorYPosition = Detector.transform.position.y;
            if (detectorXPosition < 0)
            {
                detectorXPosition -= ChunkGen.ChunkWidth;
            }
            if (detectorYPosition < 0)
            {
                detectorYPosition -= ChunkGen.ChunkHeight;
            }
            var tempPositionX = (int)detectorXPosition / ChunkGen.ChunkWidth;
            var tempPositionY = (int)detectorYPosition / ChunkGen.ChunkHeight;
            if (tempPositionX != _currentChunkPosX || tempPositionY != _currentChunkPosY)
            {
                InitializeChunk(ChunkGen.GenerateChunk(), tempPositionX, tempPositionY);
                _currentChunkPosX = tempPositionX;
             

            }
        }
    }
    public void DeleteMap()
    {
        DestroyImmediate(Map);
    }
    public void InitializeChunk(int[,] chunk, int x, int y)
    {
        if (_chunkNames.Contains(("Chunk_" + x.ToString() + "_" + y.ToString())))
        {
            return;
        }
        var parent = new GameObject();
        parent.transform.SetParent(Map.transform);
        parent.transform.position = new Vector2(x * ChunkGen.ChunkWidth, y * ChunkGen.ChunkHeight);
        parent.name = "Chunk_" +x +"_" +y;
        _chunkNames.Add(parent.name);
        for (int i = 0; i < ChunkGen.ChunkWidth; i++)
        {
            for (int j = 0; j < ChunkGen.ChunkHeight; j++)
            {
                var pos = new Vector2(i, j);
                var tile = (Transform)(Instantiate(TileTemplate, pos, Quaternion.identity));
                tile.SetParent(parent.transform, false);
                tile.name = "Tile_" + i + "_" + j;
                Tile tileScript = tile.GetComponent<Tile
namespace OutpostLibrary.Navigation
    public class BlockAddress
    {
        public IntVector3 chunk, block;
        public int x
        {
            get
            {
                return chunk.X * Sizes.ChunkSize + block.X;
            }
        }
        public int y
        {
            get
            {
                return chunk.Y * Sizes.ChunkSize + block.Y;
            }
        }
        public int z
        {
            get
            {
                return chunk.Z * Sizes.ChunkSize + block.Z;
            }
        }
        public override string ToString()
        {
            return chunk.X + ":" + block.X + ", " + chunk.Y + ":" + block.Y + ", " + chunk.Z + ":" + block.Z;
        }
        public BlockAddress(IntVector3 chunkBase, IntVector3 blockBase)
        {
            chunk = new IntVector3(chunkBase);
            block = new IntVector3(blockBase);
            while (block.X >= 16)
            {
                block.X -= 16;
                chunk.X +=
namespace vincontrol.StockingGuide.Repository.Interfaces {
    public interface IVincontrolUnitOfWork {
        IWeeklyTurnOverRepository WeeklyTurnOverRepository { get; }
        IInventoryRepository InventoryRepository { get; }
        ISoldInventoryRepository SoldInventoryRepository { get; }
        IAppraisalRepository AppraisalRepository { get; }
        IVehicleRepository VehicleRepository { get; }
        IModelRepository ModelRepository { get; }
        IDealerBrandRepository DealerBrandRepository { get; }
        IDealerBrandSelectionRepository DealerBrandSelectionRepository { get; }
        ISegmentRepository SegmentRepository { get; }
        IInventorySegmentDetailRepository InventorySegmentDetailRepository { get; }
        IDealerSegmentRepository DealerSegmentRepository { get; }
        IMarketSegmentDetailRepository MarketSegmentDetailRepository { get; }
        IDealerRepository DealerRepository { get; }
        ISettingRepository SettingRepository { get; }
        ITri
namespace Peaf.Core.Repository
    public static class RepositoryFactory
    {
        public static IEnvironmentVariableRepository EnvironmentVariableRepository
        {
            get
            {
                IEnvironmentVariableRepository repository = CallContext.GetData("Peaf.Core.Repository.EnvironmentVariableRepository") as EnvironmentVariableRepository;
                if (repository == null)
                {
                    repository = new EnvironmentVariableRepository();
                    CallContext.SetData("Peaf.Core.Repository.EnvironmentVariableRepository", repository);
                }
                return repository;
            }
        }
        public static ICategoryRepository CategoryRepository
        {
            get
            {
                ICategoryRepository repository = CallContext.GetData("Peaf.Core.Repository.CategoryRepository") as CategoryRepository;
                if (repository == null)
                {
                    repo

                    CallContext.SetData("Peaf.Core.Repository.CategoryRepository", repository);
                }
                return repository;
            }
        }
        public static ISimpageRepository SimpageRepository
        {
            get
            {
                ISimpageRepository repository = CallContext.GetData("Peaf.Core.Repository.SimpageRepository") as SimpageRepository;
                if (repository == null)
                {
                    repository = new SimpageRepository();
                    CallContext.SetData("Peaf.Core.Repository.SimpageRepository", repository);
                }
                return repository;
            }
        }
        public static IAttachmentRepository AttachmentRepository
        {
            get
            {
                IAttachmentRepository repository = CallContext.GetData("Peaf.Core.Repository.AttachmentRepository") as AttachmentRepository;
                if (repository == null)
                {
   

                    CallContext.SetData("Peaf.Core.Repository.AttachmentRepository", repository);
                }
                return repository;
            }
        }
        public static IUserRepository UserRepository
        {
            get
            {
                IUserRepository repository = CallContext.GetData("Peaf.Core.Repository.UserRepository") as UserRepository;
                if (repository == null)
                {
                    repository = new UserRepository();
                    CallContext.SetData("Peaf.Core.Repository.UserRepository", repository);
                }
                return repository;
            }
        }
        public static IRoleRepository RoleRepository
        {
            get
            {
                IRoleRepository repository = CallContext.GetData("Peaf.Core.Repository.RoleRepository") as RoleRepository;
                if (repository == null)
                {
                    repository = new RoleRepository(
[ExecuteInEditMode]
public class VoxelTerrain : MonoBehaviour
    public List<BlockType> BlockTypes = new List<BlockType>();
    public Dictionary<Vector3, Chunk> Chunks = new Dictionary<Vector3, Chunk>();
    public string LevelName;
	void Start ()
    {
    }
    public void SetVoxel(int x, int y, int z, Voxel voxel)
    {
        var chunk = GetChunk(x, y, z);
        var localX = (byte)(x - chunk.ChunkPosition.x);
        var localY = (byte)(y - chunk.ChunkPosition.y);
        var localZ = (byte)(z - chunk.ChunkPosition.z);
        chunk.SetVoxel(localX, localY, localZ, voxel);
    }
    public Voxel GetVoxel(int x, int y, int z)
    {
        var chunk = GetChunk(x, y, z);
        var localX = (byte)(x - chunk.ChunkPosition.x);
        var localY = (byte)(y - chunk.ChunkPosition.y);
        var localZ = (byte)(z - chunk.ChunkPosition.z);
        Voxel result = Voxel.Empty;
        chunk.GetVoxel(localX, localY, localZ, ref result);
        return result;
    }
    public void Clea

    {
        var foundChunks = GetComponentsInChildren<Chunk>();
        foreach (var chunk in foundChunks)
        {
            var chunkRender = chunk.GetComponent<ChunkRender>();
            chunkRender.Clear();
            DestroyImmediate(chunk.gameObject);
        }
        Chunks.Clear();
    }
    public void RenderAll(bool onlyDirty = false)
    {
        var foundChunks = GetComponentsInChildren<Chunk>();
        foreach (var chunk in foundChunks)
        {
            var chunkRender = chunk.GetComponent<ChunkRender>();
            if (chunkRender == null)
            {
                chunkRender = chunk.gameObject.AddComponent<ChunkRender>();
            }
            chunkRender.RenderChunk(onlyDirty);
            Chunks[chunk.ChunkPosition] = chunk;
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        var worldX = Mathf.Floor(x / 8f);
        var worldY = Mathf.Floor(y / 8f);
        var worldZ = Mathf.Floor(z / 8f);
        var pos = new Vecto

        Chunk chunk;
        if (!Chunks.TryGetValue(pos, out chunk))
        {
            var chunkObj = new GameObject();
            chunkObj.transform.parent = transform;
            chunkObj.name = "chunk_" + worldX + "_" + worldY + "_" + worldZ;
            Chunks[pos] = chunk = chunkObj.AddComponent<Chunk>();
            chunk.ChunkPosition = pos;
            chunk.Parent = this;
            chunk.transform.position = pos;
            var chunkRender = chunkObj.AddComponent<ChunkRender>();
        }
        if (!chunk.Loaded)
        {
            chunk.ChunkPosition = pos;
            chunk.Parent = this;
            chunk.transform.position = pos;
            chunk.Loaded = true;
            var filename = string.Format("{0}.{1}.{2}.chunk",  pos.x, pos.y, pos.z);
            var filepath = Path.Combine(VoxelLoader.LevelPath(LevelName), filename);
            if (File.Exists(filepath))
            {
                Debug.Log("Chunk not loaded, pulling from: " + filepath);
   
namespace Curan.Common.FormalizedData.File.Form.Aiff
	public class FormChunkListAiff : FormChunkList
	{
		public const string TYPE = "AIFF";
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public FormChunkChan chunkChan;
		public FormChunkComm chunkComm;
		public FormChunkComt chunkComt;
		public FormChunkMark chunkMark;
		public FormChunkSsnd chunkSsnd;
		static FormChunkListAiff()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( FormChunkChan.ID, typeof( FormChunkChan ) );
			chunkTypeDictionary.Add( FormChunkComm.ID, typeof( FormChunkComm ) );
			chunkTypeDictionary.Add( FormChunkComt.ID, typeof( FormChunkComt ) );
			chunkTypeDictionary.Add( FormChunkMark.ID, typeof( FormChunkMark ) );
			chunkTypeDictionary.Add( FormChunkSsnd.ID, typeof( FormChunkSsnd ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
		}
		public FormChunkListAiff( string 
namespace CXS.Mpos.POS.iOS
	public partial class NavigationViewController : UINavigationController
	{
		public const string STORYBOARD_ID = "NavigationController";
		public ContainerViewController ContainerController { get; set; }
		public NavigationViewController () : base ("NavigationViewController", null)
		{
		}
		public NavigationViewController (IntPtr handle) : base (handle)
		{
		}
		[Export ("popViewController")]
		public void PopViewController ()
		{
			PopViewController (true);
		}
		public void PushSettingsViewController ()
		{
			SettingsViewController settingsController = (SettingsViewController)Storyboard.InstantiateViewController (SettingsViewController.STORYBOARD_ID);
			PushViewController (settingsController, true);
		}
		public void PushLandingViewController ()
		{
			LandingViewController landingController = (LandingViewController)Storyboard.InstantiateViewController (LandingViewController.STORYBOARD_ID);
			PushViewController (landingController, true);
		}
		public 

		{
			SaleViewController saleController = (SaleViewController)Storyboard.InstantiateViewController (SaleViewController.STORYBOARD_ID);
			PushViewController (saleController, true);
		}
		
		public void PushCustomersViewController ()
		{
			CustomersViewController customersController = (CustomersViewController)Storyboard.InstantiateViewController (CustomersViewController.STORYBOARD_ID);
			PushViewController (customersController, true);
		}
		public void PushCustomerDetailViewController (string customer) 
		{
			CustomerDetailViewController detailController = (CustomerDetailViewController)Storyboard.InstantiateViewController (CustomerDetailViewController.STORYBOARD_ID);
			detailController.Customer = customer;
			PushViewController (detailController, true);
		}
		public void PushProductDetailViewController (string product) 
		{
			ProductDetailViewController detailController = (ProductDetailViewController)Storyboard.InstantiateViewController (ProductDetailViewController.STORYBOARD_ID)
﻿/*
 * Created by SharpDevelop.
 * User: Alexander Petrovskiy
 * Date: 01/12/2011
 * Time: 12:36 a.m.
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace UIAutomation.Commands
    
    public class InvokeUiaWindowPatternCommand : PatternCmdletBase
    { public InvokeUiaWindowPatternCommand() { WhatToDo = "Window"; } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaCustomWindowState")]
    
    public class InvokeUiaCustomWindowStateCommand : InvokeUiaWindowPatternCommand
    { public InvokeUiaCustomWindowStateCommand() { } }
    [Cmdlet(VerbsLifecycle.Invoke, "UiaPaneWindowState")]
    
    public class InvokeUiaPaneWindowStateCommand : InvokeUiaWindowPatternCommand
    { public InvokeUiaPaneWindowStateCommand() { } }
    [Cmdlet(VerbsLifecycle.Invoke, "UiaToolTipWindowState")]
    
    public class InvokeUiaToolTipWindowStateCommand : InvokeUiaWindowPatternCommand
    { public InvokeUiaToolTipWindowStateCommand() { } }
    [Cmdlet(VerbsLifec
public class IslandGenerator : Generator {
	public int _islandSizeX = 100;
	public int _islandSizeY = 100;
  public int _maxHeight = 100;
	public override ChunkData Generate(WorldPos chunkPos) {
		ChunkData chunkData;
		if (!chunkDatas.TryGetValue(chunkPos, out chunkData))
		{
			chunkData = new ChunkData(_chunkSize);
			for (int xi = 0; xi < _chunkSize; xi++)
			{
				for (int zi = 0; zi < _chunkSize; zi++)
				{
          Vector2 pos = new Vector2(_chunkSize * chunkPos.x + xi, _chunkSize * chunkPos.z + zi);
          float multiplier = 1-(Vector2.Distance(pos, new Vector2(_islandSizeX/2 * _chunkSize, _islandSizeY/2 * _chunkSize)) /
                            Vector2.Distance(new Vector2(0, _islandSizeY/2 * _chunkSize), new Vector2(_islandSizeX/2 * _chunkSize, _islandSizeY/2 * _chunkSize)));
          float height = Mathf.PerlinNoise(pos.x/(float)(_islandSizeX), pos.y/(float)(_islandSizeY)) * multiplier * _maxHeight;
          chunkData._heightMap[xi, zi] = height;
				}
			}
      

namespace PricePublisher.ViewModels
{ 
    public class PriceBlotterViewModel: ModelBase, IDisposable,IObservable<KeyValuePair<string, InstrumentPriceUpdate[]>>
    {
        private ObservableCollection<InstrumentPrice> _instrumentPrices;
        private readonly TaskFactory _instrumentUpdaterTaskFactory;
        public ICommand DoubleClickPriceCommand {  get; private set; }
        public event EventHandler<PriceHistoryEventArgs> DisplayPriceHistory;
        private readonly CompositeDisposable _compositeDisposable;
        private readonly IPriceAggregatorService _priceAggregatorService;
        private readonly Subject<KeyValuePair<string,InstrumentPriceUpdate[]>> _instrumentPriceUpdateSubject;
        public PriceBlotterViewModel():this(new DependencyContainer())
        {
        }
        public PriceBlotterViewModel(IDependencyContainer container)
        {
            _instrumentPriceUpdateSubject = new Subject<KeyValuePair<string, InstrumentPriceUpdate[]>>();
            Doub

            {
                var evt = DisplayPriceHistory;
                if (evt != null)
                {
                    string selectedPriceInstrument = ((InstrumentPrice)o).InstrumentName;
                    evt(this, new PriceHistoryEventArgs(selectedPriceInstrument));
                }
            });
            _instrumentUpdaterTaskFactory = new TaskFactory(TaskScheduler.FromCurrentSynchronizationContext());
            _priceAggregatorService = container.Resolve<IPriceAggregatorService>();
            IDisposable aggregatedPriceChangeSubscription = _priceAggregatorService.Subscribe(new System.Reactive.AnonymousObserver<AggregatedPriceChangeNotification>(item =>
            {
                _instrumentUpdaterTaskFactory.StartNew(() =>
                {
                    AggregatedPriceChangeNotification tmpNotification = item;
                    UpdateDataSource(tmpNotification);
                    if (!_compositeDisposable.IsDisposed)
                    {
   

                    }
                });
            }));
            _priceAggregatorService.SubScribeToNotifications();
            _compositeDisposable = new CompositeDisposable(aggregatedPriceChangeSubscription, _instrumentPriceUpdateSubject, (IDisposable)container);
        }
        public ObservableCollection<InstrumentPrice> InstrumentPrices
        {
            get
            {
                if (_instrumentPrices == null)
                {
                    _instrumentPrices = new ObservableCollection<InstrumentPrice>();
                    OnPropertyChanged("InstrumentPrices");
                }
                return _instrumentPrices;
            }
            set
            {
                _instrumentPrices = value;
                OnPropertyChanged("InstrumentPrices");
            }
        }
        public void UpdateDataSource(AggregatedPriceChangeNotification value)
        {
            AggregatedPriceChangeNotification tmpValue = value;
            Instrum
public class World : MonoBehaviour
		public int sightRadius;
		public Vector3 chunkSize;
		public GameObject mainCamera;
		public Material[] materials;
		public IRenderer renderer = new MarchRenderer ();
		private Grid<Chunk> grid = new Grid<Chunk> ();
		private Profiler profiler = new Profiler ();
		private int levelY = 50;
		void OnGUI ()
		{
				GUILayout.Label ("Memory used: " + (System.GC.GetTotalMemory (false) / (1024 * 1024)) + "\n" +
				"Grid size: x " + grid.GetMinX () + "/" + grid.GetMaxX () + " z " + grid.GetMinZ () + "/" + grid.GetMaxZ () + "\n" +
				"current Z level: " + levelY);
		}
		void Awake ()
		{
				renderer.Initialize ();
		}
		void Update ()
		{
				if (Input.GetKey (KeyCode.E)) {
						levelY++;
				}
				if (Input.GetKey (KeyCode.Q)) {
						levelY--;
				}
				Chunk nearestEmptyChunk = NearestEmptyChunk ();
				if (nearestEmptyChunk != null) {
						GenerateChunk (nearestEmptyChunk);						
						nearestEmptyChunk.Object.MakeDirty ();
				}
		}
		private Chun

		{
				Vector3 centre = mainCamera.transform.position;
				Vector3? near = null;
				for (int x = (int)centre.x - sightRadius; x < (int)centre.x + sightRadius; x++) {
						for (int z = (int)centre.z - sightRadius; z < (int)centre.z + sightRadius; z++) {
								if (GetChunkWorldPos (x, z).generated)
										continue;
								Vector3 current = new Vector3 (x, 0, z);
								float distance = Vector3.Distance (centre, current);
								if (distance > sightRadius * sightRadius)
										continue;
								if (!near.HasValue) {
										near = current;
								} else {
										float _distance = Vector3.Distance (centre, near.Value);
										if (distance < _distance)
												near = current;
								}
						}
				}
				if (near.HasValue) {
						return GetChunkWorldPos ((int)near.Value.x, (int)near.Value.z);
				}
				return null;
		}
		public Block GetBlock (int x, int y, int z)
		{
				Chunk chunk = GetChunkWorldPos (x, z);
				if (chunk.generated) {
						return chunk.GetBloc

				}
				return null;
		}
		public void SetBlock (Block block, int x, int y, int z)
		{
				Chunk chunk = GetChunkWorldPos (x, z);
				if (chunk.generated) {
						chunk.SetBlockWorldPos (block, x, y, z);
				}
		}
		public void DelBlock (int x, int y, int z)
		{
				Chunk chunk = GetChunkWorldPos (x, z);
				if (chunk.generated) {
						chunk.DelBlockWorldPos (x, y, z);
				}
		}
		public Chunk GetChunkWorldPos (int x, int z)
		{
				if (x < 0)
						x = (0 - ((ChunkX - x - 1) / ChunkX));
				else
						x = x / ChunkX;
				if (z < 0)
						z = (0 - ((ChunkZ - z - 1) / ChunkZ));
				else
						z = z / ChunkZ;
				return GetChunk (x, z);
		}
		public Chunk GetChunk (int x, int z)
		{
				Chunk chunk = grid.SafeGet (x, z);
				if (chunk == null) {
						chunk = new Chunk (this, x, z);
						grid.AddOrReplace (chunk, x, z);
				}
				return chunk;
		}
		public void UpdateBlockWorldPos (int x, int y, int z)
		{
				if (GetBlock (x + 1, y, z) != null) {
						GetBlock (x + 1, y, z).Update
namespace MonsterAdventure
    public class ChunkManager : MonoBehaviour
    {
        public uint chunkSize = 100;
        public bool drawGrid = true;
        public bool drawDistance = false;
        public bool drawColor = true;
        public Chunk chunkPrefab;
        public Tile tilePrefab;
        public BiomeManager biomeManger;
        private List<List<Chunk>> _chunks;
        public void Construct(int size)
        {
            Vector2 mapSize;
            mapSize.x = size;
            mapSize.y = size;
            Chunk.size = chunkSize;
            Chunk.tilePrefab = tilePrefab;
            _chunks = new List<List<Chunk>>();
            Vector2 offset = (mapSize * chunkSize - new Vector2(chunkSize, chunkSize)) / 2;
            for (int i = 0; i < mapSize.x; i++)
            {
                _chunks.Add(new List<Chunk>());
                for (int j = 0; j < mapSize.y; j++)
                {
                    _chunks[i].Add(InstantiateChunk(chunkPrefab, i, j));
       

                    chunkPosition.x = i * chunkSize - offset.x;
                    chunkPosition.y = j * chunkSize - offset.y;
                    _chunks[i][j].transform.position = chunkPosition;
                }
            }
        }
        public Chunk Get(int x, int y)
        {
            if (0 <= x && x < _chunks.Count
                && 0 <= y && y < _chunks[0].Count)
            {
                return _chunks[(int)x][(int)y];
            }
            return null;
        }
        public uint GetLength(uint index)
        {
            if (index == 0)
                return (uint) _chunks.Count;
            return (uint) _chunks[0].Count;
        }
        private Chunk InstantiateChunk(Chunk prefab, int x, int y)
        {
            Chunk chunk = Instantiate<Chunk>(prefab);
            chunk.transform.parent = gameObject.transform;
            chunk.name = prefab.name + " (" + x + ", " + y + ")";
            chunk.SetPositionInGrid(x, y);
            return chunk;

namespace MiNET.Worlds
	public class FlatlandWorldProvider : IWorldProvider, ICachingWorldProvider
	{
		private static readonly ILog Log = LogManager.GetLogger(typeof (FlatlandWorldProvider));
		public readonly ConcurrentDictionary<ChunkCoordinates, ChunkColumn> _chunkCache = new ConcurrentDictionary<ChunkCoordinates, ChunkColumn>();
		public bool IsCaching { get; private set; }
		public FlatlandWorldProvider()
		{
			IsCaching = true;
			_spawnPoint = new Vector3(0, 4, 0);
		}
		public void Initialize()
		{
		}
		Random rand = new Random();
		private Vector3 _spawnPoint;
		public ChunkColumn GenerateChunkColumn(ChunkCoordinates chunkCoordinates)
		{
			lock (_chunkCache)
			{
				ChunkColumn cachedChunk;
				if (_chunkCache.TryGetValue(chunkCoordinates, out cachedChunk))
				{
					return cachedChunk;
				}
				ChunkColumn chunk = new ChunkColumn();
				chunk.x = chunkCoordinates.X;
				chunk.z = chunkCoordinates.Z;
				int h = PopulateChunk(chunk);
				chunk.RecalcHeight();
				_spaw

				chunk.GetBatch();
				_chunkCache[chunkCoordinates] = chunk;
				return chunk;
			}
		}
		private void BuildStructures(ChunkColumn chunk)
		{
			if (chunk.x == 0 && chunk.z == 1)
			{
				for (int x = 3; x < 6; x++)
				{
					for (int y = 4; y < 7; y++)
					{
						if (x == 4 && y < 6) continue;
						for (int z = 1; z < 15; z++)
						{
							chunk.SetBlock(x, y, z, 3);
						}
					}
				}
				chunk.SetBlock(4, 4, 14, 3);
				chunk.SetBlock(4, 5, 14, 3);
			}
			if (chunk.x == -1 && chunk.z == 0)
			{
				for (int x = 1; x < 15; x++)
				{
					for (int z = 1; z < 15; z++)
					{
						chunk.SetBlock(x, 8, z, 3);
					}
				}
			}
		}
		public Vector3 GetSpawnPoint()
		{
			return _spawnPoint;
		}
		public long GetTime()
		{
			return 6000;
		}
		public string GetName()
		{
			return "Flatland";
		}
		public int PopulateChunk(ChunkColumn chunk)
		{
			int h = 0;
			for (int x = 0; x < 16; x++)
			{
				for (int z = 0; z < 16; z++)
				{
					h = 0;
				}
			}
			return h;
		}
namespace InstrumentMonitor
    public class PricingService
    {
        #region Private Members
        private Subject<Quote> _quoteSubject = new Subject<Quote>();
        private List<Instrument> _intruments { get; set; }
        private Timer _quoteTimerReuters;
        private Timer _quoteTimerBloomberg;
        private Random _random = new Random();
        #endregion
        #region Public Members
        public IObservable<Quote> Quotes { get; private set; }  
        #endregion
        #region Public Methods
        public List<Instrument> GetInstuments()
        {
            return _intruments;
        }
        public void StartReutersFeed()
        {
            _quoteTimerReuters = new Timer(100);
            _quoteTimerReuters.Elapsed += new ElapsedEventHandler(_quoteTimerReuters_Elapsed);
            _quoteTimerReuters.Start();
        }
        public void StopReutersFeed()
        {
            _quoteTimerReuters.Stop();
        }
        public void StartBloombergFe

        {
            _quoteTimerBloomberg = new Timer(100);
            _quoteTimerBloomberg.Elapsed += new ElapsedEventHandler(_quoteTimerBloomberg_Elapsed);
            _quoteTimerBloomberg.Start();
        }
        public void StopBloommbergFeed()
        {
            _quoteTimerBloomberg.Stop();
        }
        #endregion
        #region Private Methods
        private void _quoteTimerReuters_Elapsed(object sender, ElapsedEventArgs e)
        {
            Quote quote = new Quote();
            quote.Bid = GetPrice();
            quote.Ask = Math.Round(quote.Bid * 1.02, 2);
            quote.Price = (quote.Ask + quote.Bid) / 2;
            quote.PriceSource = "Reuters";
            quote.InstrumentID = _random.Next(1, 12);
            _quoteSubject.OnNext(quote);
        }
        private void _quoteTimerBloomberg_Elapsed(object sender, ElapsedEventArgs e)
        {
            Quote quote = new Quote();
            quote.Bid = GetPrice();
            quote.Ask = Math.Round(q

            quote.Price = (quote.Ask + quote.Bid) / 2;
            quote.PriceSource = "Bloomberg";
            quote.InstrumentID = _random.Next(1, 12);
            _quoteSubject.OnNext(quote);
        }
        private double GetPrice()
        {
            double factor = 100 * 0.1 * _random.NextDouble();
            factor = _random.NextDouble() > 0.5 ? factor : -factor;
            double price = 100 + factor;
            return Math.Round(price, 2);
        }
        private void PopulateSymbols()
        {
            _intruments = new List<Instrument>();
            _intruments.Add(new Instrument() { InstrumentID = 1, InstrumentName = "ICE" });
            _intruments.Add(new Instrument() { InstrumentID = 2, InstrumentName = "XOM" });
            _intruments.Add(new Instrument() { InstrumentID = 3, InstrumentName = "CVX" });
            _intruments.Add(new Instrument() { InstrumentID = 4, InstrumentName = "PG" });
            _intruments.Add(new Instrument() { InstrumentID = 
namespace Assets.Scripts.Game.Component.Terrain
    public class TerrainComponent : AbstractGameComponent
    {
        public Dictionary<IntVector3, ChunkEntity> Chunks { get; set; }
        public TerrainComponent()
        {
            Chunks = new Dictionary<IntVector3, ChunkEntity>();
        }
        public void Initialise()
        {
            for (int x = 0; x < 2; x++)
            {
                for (int y = 0; y < 2; y++)
                {
                    for (int z = 0; z < 2; z++)
                    {
                        AddChunk(new IntVector3(x * ChunkEntity.ChunkSize, y * ChunkEntity.ChunkSize, z * ChunkEntity.ChunkSize));
                    }
                }
            }
            new Thread(() => Chunks.Values.ToList().ForEach(ch => ch.UpdateChunk())).Start();
        }
        public void AddChunk(IntVector3 position)
        {
            Chunks[position] = ChunkFactory.CreateFlatGrassChunk(position);
        }
        public void DestroyChunk(I
namespace OptimaJet.Workflow.Core.Persistence
    public interface IPersistenceProvider
    {
        void InitializeProcess (ProcessInstance processInstance);
        void FillProcessParameters(ProcessInstance processInstance);
        void FillPersistedProcessParameters(ProcessInstance processInstance);
        void FillSystemProcessParameters(ProcessInstance processInstance);
        void SavePersistenceParameters(ProcessInstance processInstance);
        void SetWorkflowIniialized(ProcessInstance processInstance);
        void SetWorkflowIdled(ProcessInstance processInstance);
        void SetWorkflowRunning(ProcessInstance processInstance);
        void SetWorkflowFinalized(ProcessInstance processInstance);
        void SetWorkflowTerminated(ProcessInstance processInstance, ErrorLevel level, string errorMessage);
        void ResetWorkflowRunning();
        void UpdatePersistenceState(ProcessInstance processInstance, TransitionDefinition transition);
        bool IsProcessExists(G
namespace Curan.Common.FormalizedData.File.Riff.Sfbk
	public class RiffChunkListSfbk : RiffChunkList
	{
		public const string TYPE = "sfbk";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public readonly List<RiffChunkList> sdtaListList;
		public readonly List<RiffChunkList> pdtaListList;
		public readonly RiffChunkListSdta sdtaBodyList;
		static RiffChunkListSfbk()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkIbag.ID, typeof( RiffChunkIbag ) );
			chunkTypeDictionary.Add( RiffChunkIgen.ID, typeof( RiffChunkIgen ) );
			chunkTypeDictionary.Add( RiffChunkImod.ID, typeof( RiffChunkImod ) );
			chunkTypeDictionary.Add( RiffChunkInst.ID, typeof( RiffChunkInst ) );
			chunkTypeDictionary.Add( RiffChunkPbag.ID, typeof( RiffChunkPbag ) );
			chunkTypeDictionary.Add( RiffChunkPgen.ID, typeof( RiffChunkPgen ) );
			chunkTypeDictionary.Add( RiffChunkP
namespace Instrument.Business
    public class InstrumentCertificationServiceImpl
    {
        public void DeleteByInstrumentId(int InstrumentId)
        {
            DBProvider.InstrumentCertificationDAO.DeleteByInstrumentId(InstrumentId);
        }
        public string DeleteById(int LogId, int InstrumentId)
        {
            string msg = "OK";
            DBProvider.InstrumentCertificationDAO.DeleteById(LogId);
            UpdateCertificationAndState(InstrumentId);
            Instrument.Common.Models.InstrumentModel model = new Instrument.Common.Models.InstrumentModel();
            model.InstrumentId = InstrumentId;
            model.LastUpdateUser = LoginHelper.LoginUser.UserName;
            ServiceProvider.InstrumentService.UpdateLastUpdateInfo(model);
            if (LoginHelper.LoginUserAuthorize.Contains("/Instrument/SynInstrument".ToLower()))
            {
                ServiceProvider.InstrumentService.BeginSynInstrument(InstrumentId);
            }
            re

        }
        public void UpdateCertificationAndState(int instrumentId)
        {
            Instrument.Common.Models.InstrumentModel instrument = new Instrument.Common.Models.InstrumentModel();
            instrument.InstrumentId = instrumentId;
            InstrumentCertificationModel certModel = DBProvider.InstrumentCertificationDAO.GetMaxEndDateByInstrumentId(instrumentId,DateTime.Now.ToString("yyyy-MM-dd"));
            if (certModel == null)
            {                
                instrument = ServiceProvider.InstrumentService.GetById(instrumentId);
                instrument.CertificateNo = null;
                instrument.DueStartDate = null;
                instrument.DueEndDate = null;
                instrument.InspectOrg = null;
                if (instrument.ManageLevel != "C") instrument.RecordState = UtilConstants.InstrumentState.过期禁用.GetHashCode();
            }
            else
            {
                instrument.CertificateNo = certModel.Certification

                instrument.DueStartDate = certModel.CheckDate;
                instrument.DueEndDate = certModel.EndDate;
                instrument.InspectOrg = certModel.MeasureOrg;
                if (certModel.EndDate < DateTime.Now)
                {
                    instrument.RecordState = UtilConstants.InstrumentState.过期禁用.GetHashCode();
                    certModel.IsUseding = false;
                }
                else
                {
                    instrument.RecordState = UtilConstants.InstrumentState.合格.GetHashCode();
                    certModel.IsUseding = true;
                }
            }
            ServiceProvider.InstrumentService.UpdateCertificationInfo(instrument);
            UpdateIsUseding(certModel);
        }
        public void Insert(InstrumentCertificationModel model)
        {            
            DBProvider.InstrumentCertificationDAO.Add(model);
            UpdateCertificationAndState(model.InstrumentId);
        }
        public voi
namespace SIEM_Project.Classes
    public delegate void Event_NewProcess1(ProcessInfo tempProcess);
    public delegate void Event_UpdateProcess1(ProcessInfo tempProcess);
    public delegate void Event_CloseProcess1(ProcessInfo tempProcess);
    
    public class ProcessList
    {
        public static DataManager dm = new DataManager();
        public static event Event_NewProcess1 Call_NewProcess;
        public static event Event_UpdateProcess1 Call_UpdateProcess;
        public static event Event_CloseProcess1 Call_CloseProcess;
        public static ProcessInfo[] processList;
        public static int processIndex;
        public static void Init()
        {
        }
        public static void UpdateProcessList()
        {
            Process[] newProcessList = Process.GetProcesses();
            UpdateExistingProcesses(newProcessList);
            AddNewProcesses(newProcessList);            
        }
        public static void UpdateExistingProcesses(Process[] newProcessList)


            ProcessInfo[] tempProcessList = new ProcessInfo[newProcessList.Length];
            processIndex = 0;
            if (processList == null)
            {
                processList = new ProcessInfo[newProcessList.Length];
                return;
            }
            foreach (ProcessInfo tempProcess in processList)
            {
                Process currentProcess = ProcessExists(newProcessList, processIndex);
                if (currentProcess == null)
                {
                    Call_CloseProcess(tempProcess);
                }
                else
                {
                    tempProcessList[processIndex] = GetProcessInfo(tempProcess, currentProcess);
                    Call_UpdateProcess(tempProcess);
                }
            }
            processList = tempProcessList;
        }
        private static Process ProcessExists(Process[] newProcessList, int pID)
        {
            foreach (Process tempProcess in newProcessList)
         

                if (tempProcess.Id == pID)
                {
                    return tempProcess;
                }
            }
            return null;
        }
        public static ProcessHistory GetProcessHistory(int pID)
        {
            foreach (ProcessInfo tempProcess in processList)
            {
                if (tempProcess.ID == pID)
                {
                    return tempProcess.processHistory;
                }
            }
            return null;
        }
        private static ProcessInfo GetProcessInfo(ProcessInfo tempProcess, Process currentProcess)
        {
            if (currentProcess.Id == 0)
            {
                
            }
            else
            {
            }
            return tempProcess;
        }
        private static void AddNewProcesses(Process[] newProcessList)
        {
            foreach (Process newProcess in newProcessList)
            {
                if (!ProcessInfoExists(newProcess))
             
namespace Adborroto.FlowJs
    public class FlowManager:IFlowManager
    {
        private readonly IChunkBinder _chunkBinder;
        private readonly IChunkNameGenerator _chunkNameGenerator;
        private readonly IFileManager _fileManager;
        public FlowManager(
            IChunkBinder chunkBinder,
            IChunkNameGenerator chunkNameGenerator,
            IFileManager fileManager)
        {
            _chunkBinder = chunkBinder;
            _chunkNameGenerator = chunkNameGenerator;
            _fileManager = fileManager;
        }
        public virtual ValueResult<ChunkStatus> Post(HttpRequest request)
        {
            var chunkResult = _chunkBinder.Parse(request.Form);
            if (!chunkResult.Sucess)
                return ValueResult<ChunkStatus>.Failed(chunkResult.Errors);
            if (request.Files.Count != 0)
                return ValueResult < ChunkStatus > .Failed(new InvalidFileApplicationError("No file in the http request"));
            var fi

            var chunkUniqueNameTemp = _chunkNameGenerator.Generate(chunkResult.Result);
            _fileManager.Copy(file.InputStream, chunkUniqueNameTemp);
            var chunkUniqueName = _chunkNameGenerator.Generate(chunkResult.Result);
            _fileManager.Rename(chunkUniqueNameTemp, chunkUniqueName);
            if (IsFileUploadComplete(chunkResult.Result))
            {
                MergeFile(chunkResult.Result);
                return ValueResult<ChunkStatus>.Successed(ChunkStatus.Last);
            }
            return ValueResult<ChunkStatus>.Successed(ChunkStatus.Chunk);
        }
        #region Helpers
        private bool IsFileUploadComplete(Chunk.Chunk chunk)
        {
            for (var chunkNumber = 1; chunkNumber <= chunk.TotalChunks; chunkNumber++)
            {
                var chunkUniqueName = _chunkNameGenerator.Generate(chunk.FileName, chunk.Identifier, chunkNumber);
                if (!_fileManager.Exits(chunkUniqueName))
                    ret
namespace TheGapFillers.Portrack.Repositories.Application.EF.Contexts
    public class ApplicationDbContext : DbContext, IApplicationDbContext
    {
        public ApplicationDbContext()
            : base("ApplicationConnection")
        {
        }
        public DbSet<Portfolio> Portfolios { get; set; }
        public DbSet<Holding> Holdings { get; set; }
        public DbSet<Transaction> Transactions { get; set; }
        public DbSet<Instrument> Instruments { get; set; }
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            modelBuilder.Properties<DateTime>().Configure(c => c.HasColumnType("datetime2"));
            modelBuilder.Configurations.Add(new PortfolioMap());
            modelBuilder.Configurations.Add(new HoldingMap());
            modelBuilder.Configurations.Add(new TransactionMap());
            modelBuilder.Configurations.Add(new InstrumentMap());
        }
    }
    public cl

    {
        protected override void Seed(ApplicationDbContext context)
        {
            var instruments = new List<Instrument>
            {
                new Instrument { Type = InstrumentType.Fx, Ticker = "USD"     , Name = "US Dollar"        , Currency = "USD" },
                new Instrument { Type = InstrumentType.Fx, Ticker = "EUR"     , Name = "Euro"             , Currency = "EUR" },
                new Instrument { Type = InstrumentType.Fx, Ticker = "CNY"     , Name = "Chinese Yuan"     , Currency = "CNY" },
                new Instrument { Type = InstrumentType.Fx, Ticker = "HKD"     , Name = "Hong Kong Dollar" , Currency = "HKD" },
                new Instrument { Type = InstrumentType.Exchange, Ticker = ""        , Name = "US Exchange"          , Currency = "USD" },
                new Instrument { Type = InstrumentType.Exchange, Ticker = ".PA"     , Name = "Paris Exchange"       , Currency = "EUR" },
                new Instrument { Type = InstrumentType.Exchange

                new Instrument { Type = InstrumentType.Exchange, Ticker = ".SH"     , Name = "Shanghai Exchange"    , Currency = "CNY" },
                new Instrument { Type = InstrumentType.Exchange, Ticker = ".HK"     , Name = "Hong Kong Exchange"   , Currency = "HKD" },
                new Instrument { Type = InstrumentType.Stock, Ticker = "GOOG"    , Name = "Google"           , Currency = "USD" },
                new Instrument { Type = InstrumentType.Stock, Ticker = "YHOO"    , Name = "Yahoo"            , Currency = "USD" },
                new Instrument { Type = InstrumentType.Stock, Ticker = "MSFT"    , Name = "Microsoft"        , Currency = "USD" },
                new Instrument { Type = InstrumentType.Stock, Ticker = "AAPL"    , Name = "Apple"            , Currency = "USD" },
                new Instrument { Type = InstrumentType.Stock, Ticker = "MC.PA"   , Name = "LVMH"             , Currency = "EUR" },
                new Instrument { Type = InstrumentType.Stock, Ticker
namespace Windows_Ad_Plugin
    public static class Dispatcher
    {
        public static Action<Action> InvokeOnAppThread
        {
            get 
            { 
                if(_invokeOnAppThread == null && Helper.Instance.Messenger != null)
                    Helper.Instance.Messenger("Dispatcher Error: InvokeOnAppThread not set up");
                return _invokeOnAppThread;
            } 
            set
            {
                _invokeOnAppThread = value;
            } 
        }
        private static Action<Action> _invokeOnAppThread;
        public static Action<Action> InvokeOnUIThread
        {
            get
            {
                if (_invokeOnUIThread == null && Helper.Instance.Messenger != null)
                    Helper.Instance.Messenger("Dispatcher Error: InvokeOnUIThread not set up");
                return _invokeOnUIThread;
            }
            set
            {
                _invokeOnUIThread = value;
            }
        }
        pri
[ExecuteInEditMode]
public class VoxelTerrain : MonoBehaviour
    public List<BlockType> BlockTypes = new List<BlockType>();
    public Dictionary<Vector3, Chunk> Chunks = new Dictionary<Vector3, Chunk>();
	void Start ()
    {
    }
    public void SetVoxel(int x, int y, int z, Voxel voxel)
    {
        var chunk = GetChunk(x, y, z);
        var localX = (byte)(x - chunk.ChunkPosition.x);
        var localY = (byte)(y - chunk.ChunkPosition.y);
        var localZ = (byte)(z - chunk.ChunkPosition.z);
        chunk.SetVoxel(localX, localY, localZ, voxel);
    }
    public Voxel GetVoxel(int x, int y, int z)
    {
        var chunk = GetChunk(x, y, z);
        var localX = (byte)(x - chunk.ChunkPosition.x);
        var localY = (byte)(y - chunk.ChunkPosition.y);
        var localZ = (byte)(z - chunk.ChunkPosition.z);
        Voxel result = Voxel.Empty;
        chunk.GetVoxel(localX, localY, localZ, ref result);
        return result;
    }
	void Update ()
    {
        if (!Application.is

        {
            BlockTypes = GetComponentsInChildren<BlockType>().ToList<BlockType>();
        }
	}
    public void Clear()
    {
        var foundChunks = GetComponentsInChildren<Chunk>();
        foreach (var chunk in foundChunks)
        {
            var chunkRender = chunk.GetComponent<ChunkRender>();
            chunkRender.Clear();
            DestroyImmediate(chunk.gameObject);
        }
        Chunks.Clear();
    }
    public void RenderAll(bool onlyDirty = false)
    {
        var foundChunks = GetComponentsInChildren<Chunk>();
        foreach (var chunk in foundChunks)
        {
            var chunkRender = chunk.GetComponent<ChunkRender>();
            if (chunkRender == null)
            {
                chunkRender = chunk.gameObject.AddComponent<ChunkRender>();
            }
            chunkRender.RenderChunk(onlyDirty);
            Chunks[chunk.ChunkPosition] = chunk;
        }
    }
    Chunk GetChunk(int x, int y, int z)
    {
        var worldX = Mathf.Flo
namespace Juixel.Tools
    public class DispatchQueue
    {
        #region Static Regions
        public static DispatchQueue Main = new DispatchQueue();
        public static DispatchQueue IO;
        public static void DispatchMain(Action Block)
        {
            Main.Dispatch(Block);
        }
        public static void DispatchIO(Action Block)
        {
            if (IO == null)
            {
                IO = new DispatchQueue();
                StartIOQueue();
            }
            IO.Dispatch(Block);
        }
        private static async void StartIOQueue()
        {
            while (true)
            {
                await Task.Delay(100);
                if (IO != null)
                    IO.Step();
                else
                    return;
            }
        }
        public static void DispatchBackground(Action Action)
        {
            var Thread = new Thread(() => { Action(); });
            Thread.IsBackground = true;
            Thread.St
namespace MusicalTracker.DAL.Concretes
    public class MusicInstrument : IMusicInstrument
    {
        private MusicInstrumentSalesForce _sfInstrumentData;
        private Borrower _Borrower;
        public MusicInstrument(MusicInstrumentSalesForce instrument, MusicInstrumentBorrowerSalesForce borrower)
        {
            _sfInstrumentData = instrument;
            _Borrower =  new Borrower(borrower);
        }
        public string Description
        {
            get
            {
                return _sfInstrumentData.DESCRIPTION__C;
            }
        }
        public string Name
        {
            get
            {
                return _sfInstrumentData.NAME;
            }
        }
        public InstrumentType Type
        {
            get
            {
                return Converters.ConvertInstrTypeStrToEnum(_sfInstrumentData.TYPE__C);
            }
        }
        public IBorrower Borrower
        {
            get
            {
                return _Bo
﻿namespace Survive.World {
    class ChunkManager {
        
        private static float[,,] noisecache = new float[WorldChunk.Size, WorldChunk.Size + 1, WorldChunk.Size];
        public static WorldChunk GetChunk(int x, int y, int z, FastNoise fn) {
            WorldChunk chunk = new WorldChunk();
            
            for(int bx = 0; bx < WorldChunk.Size; bx++) {
                for(int by = 0; by < WorldChunk.Size + 1; by++) {
                    for(int bz = 0; bz < WorldChunk.Size; bz++) {
                        noisecache[bx, by, bz] = 0.5f - ((float)(y * WorldChunk.Size + by) / 40) + fn.GetSimplexFractal(x * WorldChunk.Size + bx, y * WorldChunk.Size + by, z * WorldChunk.Size + bz);
                    }
                }
            }
            for(int bx = 0; bx < WorldChunk.Size; bx++) {
                for(int by = 0; by < WorldChunk.Size; by++) {
                    for(int bz = 0; bz < WorldChunk.Size; bz++) {
                        chunk.SetBlockDirect(bx, by, bz, 
namespace Curan.Common.FormalizedData.File.Riff.Dls
	public class RiffChunkListIns_ : RiffChunkList
	{
		public const string TYPE = "ins ";
		public static readonly Dictionary<string,Type> chunkTypeDictionary;
		public static readonly Dictionary<string,Type> bodyTypeDictionary;
		public readonly RiffChunkDlid dlidChunk;
		public readonly RiffChunkInsh inshChunk;
		public readonly List<RiffChunkList> lrgnListList;
		public readonly List<RiffChunkList> lartListList;
		public readonly List<RiffChunkList> infoListList;
		static RiffChunkListIns_()
		{
			chunkTypeDictionary = new Dictionary<string, Type>();
			chunkTypeDictionary.Add( RiffChunkDlid.ID, typeof( RiffChunkDlid ) );
			chunkTypeDictionary.Add( RiffChunkInsh.ID, typeof( RiffChunkInsh ) );
			bodyTypeDictionary = new Dictionary<string, Type>();
			bodyTypeDictionary.Add( RiffChunkListLrgn.TYPE, typeof( RiffChunkListLrgn ) );
			bodyTypeDictionary.Add( RiffChunkListLart.TYPE, typeof( RiffChunkListLart ) );
			bodyTypeDictionary.A
namespace Cats.Services.Hub
    public interface IOtherDispatchAllocationService : IDisposable
    {
        bool AddOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteById(int id);
        bool EditOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        OtherDispatchAllocation FindById(int id);
        OtherDispatchAllocation FindById(Guid id);
        List<OtherDispatchAllocation> GetAllOtherDispatchAllocation();
        List<OtherDispatchAllocation> FindBy(Expression<Func<OtherDispatchAllocation, bool>> predicate);
        void Save(OtherDispatchAllocationViewModel model);
        OtherDispatchAllocationViewModel GetViewModelByID(Guid otherDispatchAllocationId);
        List<OtherDispatchAllocation> GetAllToCurrentOwnerHubs(UserProfile user);
        List<OtherDispatchAllocation> GetAllToOtherOwnerHubs(UserProfile user);
   
﻿/*
 * Created by SharpDevelop.
 * User: Alexander Petrovskiy
 * Date: 6/19/2012
 * Time: 10:14 PM
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace UIAutomation.Commands
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaScrollPattern")]
    
    public class InvokeUiaScrollPatternCommand : PatternCmdletBase
    { public InvokeUiaScrollPatternCommand() 
      { 
            WhatToDo = "Scroll"; 
            Vertical = false;
            Horizontal = false;
            PassThru = true;
            Child = this;
      }
        
        #region Parameters
        [UiaParameter][Parameter(Mandatory = true,
                   ParameterSetName = "Percent")]
        [ValidateRange(-1, 100)]
        public int HorizontalPercent { get; set; }
        [UiaParameter][Parameter(Mandatory = true,
                   ParameterSetName = "Percent")]
        [ValidateRange(-1, 100)]
        public int VerticalPercent { get; set; }
                [UiaParameter

                   ParameterSetName = "Amount")]
        public int HorizontalAmount { get; set; }
        [UiaParameter][Parameter(Mandatory = true,
                   ParameterSetName = "Amount")]
        public int VerticalAmount { get; set; }
        [UiaParameter][Parameter(Mandatory = false)]
        public SwitchParameter Horizontal { get; set; }
        [UiaParameter][Parameter(Mandatory = false)]
        public SwitchParameter Vertical { get; set; }
        #endregion Parameters
    [Cmdlet(VerbsLifecycle.Invoke, "UiaCalendarScroll")]
    
    public class InvokeUiaCalendarScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaCalendarScrollCommand() { } }
        
    [Cmdlet(VerbsLifecycle.Invoke, "UiaComboBoxScroll")]
    
    public class InvokeUiaComboBoxScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaComboBoxScrollCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaCustomScroll")]
    
    public class InvokeUiaCustomScrollComman

    { public InvokeUiaCustomScrollCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaDataGridScroll")]
    
    public class InvokeUiaDataGridScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaDataGridScrollCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaDocumentScroll")]
    
    public class InvokeUiaDocumentScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaDocumentScrollCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaListScroll")]
    
    public class InvokeUiaListScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaListScrollCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaPaneScroll")]
    
    public class InvokeUiaPaneScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaPaneScrollCommand() { } }
    
    [Cmdlet(VerbsLifecycle.Invoke, "UiaScrollBarScroll")]
    
    public class InvokeUiaScrollBarScrollCommand : InvokeUiaScrollPatternCommand
    { public InvokeUiaScroll
namespace Lab.EMC.DataAccess
    public class OrderProjectDispatchDetailDaoImpl
    {
		public void Add(OrderProjectDispatchDetailModel model)
		{
			DBProvider.dbMapper.Insert("Order_ProjectDispatchDetail.Insert", model);
		}
		public void Update(OrderProjectDispatchDetailModel model)
		{
			DBProvider.dbMapper.Update("Order_ProjectDispatchDetail.Update", model);
		}
        public void DeleteById(int DetailId)
		{
            DBProvider.dbMapper.Delete("Order_ProjectDispatchDetail.DeleteById", DetailId);
		}
        public OrderProjectDispatchDetailModel GetById(int DetailId)
		{
            return DBProvider.dbMapper.SelectObject<OrderProjectDispatchDetailModel>("Order_ProjectDispatchDetail.GetByID", DetailId);
		}
		public IList<OrderProjectDispatchDetailModel> GetAll()
		{
			return DBProvider.dbMapper.SelectList<OrderProjectDispatchDetailModel>("Order_ProjectDispatchDetail.GetAll");
		}
        public IList<OrderProjectDispatchDetailModel> GetByDispatchId(int DispatchId)
        
namespace CollegeBuffer.BLL
    public class DbUnitOfWork : BaseUnitOfWork
    {
        public static DbUnitOfWork NewInstance()
        {
            return new DbUnitOfWork();
        }
        #region Fields
        private UsersRepository _usersRepository;
        private GroupsRepository _groupsRepository;
        private SessionsRepository _sessionsRepository;
        private GroupRequestsRepository _groupRequestsRepository;
        private SubjectsRepository _subjectsRepository;
        private CommentsRepository _commentsRepository;
        private AnnouncementsRepository _announcementsRepository;
        private AnnouncementNotificationsRepository _announcementNotificationsRepository;
        private EventNotificationsRepository _eventNotificationsRepository;
        private CalendarsRepository _calendarsRepository;
        private CalendarEntriesRespository _calendarEntriesRespository;
        private EventsRepository _eventsRepository;
        #endregion
        #region pro

        public UsersRepository UsersRepository
        {
            get
            {
                return _usersRepository ?? (_usersRepository = new UsersRepository(DbContext));
            }
        }
        public GroupsRepository GroupsRepository
        {
            get
            {
                return _groupsRepository ?? (_groupsRepository = new GroupsRepository(DbContext));
            }
        }
        public SessionsRepository SessionsRepository
        {
            get
            {
                return _sessionsRepository ?? (_sessionsRepository = new SessionsRepository(DbContext));
            }
        }
        public GroupRequestsRepository GroupRequestsRepository
        {
            get
            {
                return _groupRequestsRepository ?? (_groupRequestsRepository = new GroupRequestsRepository(DbContext));
            }
        }
        public SubjectsRepository SubjectsRepository
        {
            get
            {
                re

            }
        }
        public CommentsRepository CommentsRepository
        {
            get
            {
                return _commentsRepository ?? (_commentsRepository = new CommentsRepository(DbContext));
            }
        }
        public AnnouncementsRepository AnnouncementsRepository
        {
            get
            {
                return _announcementsRepository ?? (_announcementsRepository = new AnnouncementsRepository(DbContext));
            }
        }
        public AnnouncementNotificationsRepository AnnouncementNotificationsRepository
        {
            get
            {
                return _announcementNotificationsRepository ??
                       (_announcementNotificationsRepository = new AnnouncementNotificationsRepository(DbContext));
            }
        }
        public EventNotificationsRepository EventNotificationsRepository
        {
            get
            {
                return _eventNotificationsRepository ??
       
namespace DynaStudios.Blocks {
    class IntHolder
    {
        public int value = 0;
    }
    public class AsyncChunkLoader {
        public delegate void ChunkLoadedDelegate(Chunk chunk);
        public event ChunkLoadedDelegate ChunkLoaded;
        private LinkedList<Chunk> _queriedChunks = new LinkedList<Chunk>();
        private string _dataPath;
        private bool _keepAlive = true;
        private IntHolder _regions = new IntHolder();
        public AsyncChunkLoader(string dataPath) {
            _dataPath = dataPath;
            new Thread(loadChunks).Start();
        }
        public bool chunkIsQueried(int x, int y) {
            lock (_queriedChunks) {
                LinkedListNode<Chunk> chunk = _queriedChunks.First;
                while (chunk != null) {
                    if (chunk.Value.X == x && chunk.Value.Z == y) {
                        return true;
                    }
                    chunk = chunk.Next;
                }
            }
            retur

        }
        public void request(int x, int y, bool urgent = false) {
            if (!chunkIsQueried(x, y)) {
                registerChunkForLoad(x, y, urgent);
            }
        }
        private void registerChunkForLoad(int x, int y, bool urgent) {
            Chunk chunk = new Chunk(x, y);
            lock (_queriedChunks) {
                if (urgent) {
                    _queriedChunks.AddFirst(chunk);
                } else {
                    _queriedChunks.AddLast(chunk);
                }
                Monitor.Pulse(_queriedChunks);
            }
        }
        private string getStringForFilesystem(int nummber) {
            if (nummber < 0) {
                return "m" + (-nummber).ToString();
            }
            return nummber.ToString();
        }
        private LinkedListNode<Chunk> getNextChunkNode() {
            LinkedListNode<Chunk> chunkNode;
            do {
                lock (_queriedChunks) {
                    chunkNode = _queriedCh

                    if (chunkNode != null) {
                        break;
                    }
                    Monitor.Wait(_queriedChunks);
                }
            } while (_keepAlive);
            return chunkNode;
        }
        private void loadChunks() {
            while (_keepAlive) {
                LinkedListNode<Chunk> chunkNode = getNextChunkNode();
                if (!_keepAlive) {
                    return;
                }
                Chunk chunk = chunkNode.Value;
                string chunkFileName = string.Format(
                    "{0}_{1}.dscf",
                    getStringForFilesystem(chunk.X),
                    getStringForFilesystem(chunk.Z));
                string chunkFullPath = Path.Combine(_dataPath, chunkFileName);
                chunk.load(chunkFullPath);
                lock (_queriedChunks) {
                    _queriedChunks.Remove(chunkNode);
                }
                ChunkLoaded(chunk);
            }
        }
 
[Serializable]
public class World : MonoBehaviour {
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
	public GameObject chunkPrefab;
	public string worldName = "world";
	public void createChunk (int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos (x, y, z);
		GameObject newChunkObject = Instantiate (chunkPrefab, new Vector3 (x, y, z), 
		                                         Quaternion.Euler (Vector3.zero)) as GameObject;
		Chunk newChunk = newChunkObject.GetComponent<Chunk> ();
		newChunk.pos = worldPos;
		newChunk.world = this;
		chunks.Add (worldPos, newChunk);
		TerrainGen terrainGen = new TerrainGen ();
		newChunk = terrainGen.ChunkGen (newChunk);
		newChunk.setBlocksUnmodified ();
		Serialization.loadChunk (newChunk);
	}
	public void destroyChunk (int x, int y, int z)
	{
		Chunk chunk = null;
		if (chunks.TryGetValue (new WorldPos (x, y, z), out chunk))
		{
			Serialization.saveChunk(chunk);
			UnityEngine.Object.Destroy (chunk.gameObject)

			chunks.Remove (new WorldPos (x, y, z));
		}
	}
	public Chunk getChunk (int x, int y, int z)
	{
		WorldPos pos = new WorldPos ();
		float multiple = Chunk.chunkSize;
		pos.x = Mathf.FloorToInt (x / multiple) * Chunk.chunkSize;
		pos.y = Mathf.FloorToInt	 (y / multiple) * Chunk.chunkSize;
		pos.z = Mathf.FloorToInt (z / multiple) * Chunk.chunkSize;
		Chunk containerChunk = null;
		chunks.TryGetValue (pos, out containerChunk);
		return containerChunk;
	}
	public Block getBlock (int x, int y, int z)
	{
		Chunk containerChunk = getChunk (x, y, z);
		if (containerChunk != null)
		{
			Block block = containerChunk.getBlock (x - containerChunk.pos.x,
			                                       y - containerChunk.pos.y,
			                                       z - containerChunk.pos.z);
			return block;
		}
		else
		{
			return new BlockAir();
		}
	}
	public void setBlock (int x, int y, int z, Block block)
	{
		Chunk chunk = getChunk (x, y, z);
		if (chunk != null)
		{
			chunk.setBlock (x -
namespace TechnoloCity.Base
    class World
    {
        public World()
        {
            this.chunks = new Dictionary<Vector3i, Chunk>();
        }
        public Block GetBlock(int x, int y, int z)
        {
            Block block = null;
            var chunkPosition = ChunkInWorld(x, y, z);
            var blockPosition = BlockInChunk(x, y, z);
            Chunk chunk;
            if (chunks.TryGetValue(chunkPosition, out chunk))
            {
                block = chunk.GetBlock(blockPosition.X, blockPosition.Y, blockPosition.Z);
            }
            return block;
        }
        public void SetBlock(int x, int y, int z, Block block)
        {
            var chunkPosition = ChunkInWorld(x, y, z);
            var blockPosition = BlockInChunk(x, y, z);
            Chunk chunk;
            if (!chunks.TryGetValue(chunkPosition, out chunk))
            {
                chunk = new Chunk();
                chunks[chunkPosition] = chunk;
            }
            chunk.
namespace CI.DAL
    public class UnitOfWork : IUnitOfWork
    {
        private readonly CIContext _context = new CIContext();
        private AuthorRepository _authorRepository;
        private GenreRepository _genreRepository;
        private AudiofileRepository _audiofileRepository;
        private RatingRepository _ratingRepository;
        private UserRepository _userRepository;
        public AuthorRepository AuthorRepository
        {
            get { return _authorRepository ?? (_authorRepository = new AuthorRepository(_context)); }
        }
        public GenreRepository GenreRepository
        {
            get { return _genreRepository ?? (_genreRepository = new GenreRepository(_context)); }
        }
        public AudiofileRepository AudiofileRepository
        {
            get { return _audiofileRepository ?? (_audiofileRepository = new AudiofileRepository(_context)); }
        }
        public RatingRepository RatingRepository
        {
            get { return _rati
namespace THOK.Wms.Repository.Migrations
    
    public partial class SortWorkDispatch : DbMigration
    {
        public override void Up()
        {
            CreateTable(
                "dbo.wms_sort_work_dispatch",
                c => new
                    {
                        id = c.Guid(nullable: false),
                        order_date = c.String(nullable: false, maxLength: 14),
                        sorting_line_code = c.String(nullable: false, maxLength: 20),
                        dispatch_batch = c.String(nullable: false, maxLength: 2),
                        out_bill_no = c.String(nullable: false, maxLength: 20),
                        move_bill_no = c.String(nullable: false, maxLength: 20),
                        dispatch_status = c.String(nullable: false, maxLength: 1, fixedLength: true),
                        is_active = c.String(nullable: false, maxLength: 1, fixedLength: true),
                        update_time = c.DateTime(nullable: false),
   
namespace TeamleaderDotNet
    public class TeamleaderApi
    {
        private const string Version = "1.0.0";
        private const int DefaultTimeout = 30;
        private readonly ITeamleaderClient _teamleaderClient;
        private TeamleaderContactsApi _contactsApi;
        private TeamleaderCompaniesApi _companiesApi;
        private TeamleaderDealsApi _dealsApi;
        private TeamleaderCustomFieldsApi _customFieldsApi;
        private TeamleaderInvoicesApi _invoicesApi;
        private TeamleaderGeneralApi _generalApi;
        public TeamleaderApi(string apiGroup, string apiSecret)
        {
            _teamleaderClient = new TeamleaderClient(ApiUrl, apiGroup, apiSecret, GetUserAgent(), DefaultTimeout);
        }
        public TeamleaderApi(ITeamleaderClient teamleaderClient)
        {
            _teamleaderClient = teamleaderClient;
        }
        public TeamleaderGeneralApi General
        {
            get
            {
                if (_generalApi == null)
      

                    _generalApi = new TeamleaderGeneralApi(_teamleaderClient);
                }
                return _generalApi;
            }
        }
        public TeamleaderInvoicesApi Invoices
        {
            get
            {
                if (_invoicesApi == null)
                {
                    _invoicesApi = new TeamleaderInvoicesApi(_teamleaderClient);
                }
                return _invoicesApi;
            }
        }
        public TeamleaderContactsApi Contacts
        {
            get
            {
                if (_contactsApi == null)
                {
                    _contactsApi = new TeamleaderContactsApi(_teamleaderClient);
                }
                return _contactsApi;
            }
        }
        public TeamleaderCompaniesApi Companies
        {
            get
            {
                if (_companiesApi == null)
                {
                    _companiesApi = new TeamleaderCompaniesApi(_teamleaderClient)
namespace System.Activities
    [Fx.Tag.XamlVisible(false)]
    public sealed class WorkflowInvoker
    {
        static AsyncCallback cancelCallback;
        static AsyncCallback invokeCallback;
        WorkflowInstanceExtensionManager extensions;
        Dictionary<object, AsyncInvokeContext> pendingInvokes;
        SendOrPostCallback raiseInvokeCompletedCallback;
        object thisLock;
        Activity workflow;
        public WorkflowInvoker(Activity workflow)
        {
            if (workflow == null)
            {
                throw FxTrace.Exception.ArgumentNull("workflow");
            }
            this.workflow = workflow;
            this.thisLock = new object();
        }
        public event EventHandler<InvokeCompletedEventArgs> InvokeCompleted;
        public WorkflowInstanceExtensionManager Extensions
        {
            get
            {
                if (this.extensions == null)
                {
                    this.extensions = new WorkflowInstanceExte

                }
                return this.extensions;
            }
        }
        Dictionary<object, AsyncInvokeContext> PendingInvokes
        {
            get
            {
                if (this.pendingInvokes == null)
                {
                    this.pendingInvokes = new Dictionary<object, AsyncInvokeContext>();
                }
                return this.pendingInvokes;
            }
        }
        SendOrPostCallback RaiseInvokeCompletedCallback
        {
            get
            {
                if (this.raiseInvokeCompletedCallback == null)
                {
                    this.raiseInvokeCompletedCallback =
                        Fx.ThunkCallback(new SendOrPostCallback(this.RaiseInvokeCompleted));
                }
                return this.raiseInvokeCompletedCallback;
            }
        }
        object ThisLock
        {
            get
            {
                return this.thisLock;
            }
        }
        [Fx.Tag.Throws

        public static IDictionary<string, object> Invoke(Activity workflow)
        {
            return Invoke(workflow, ActivityDefaults.InvokeTimeout);
        }
        [Fx.Tag.InheritThrows(From = "Invoke")]
        public static IDictionary<string, object> Invoke(Activity workflow, TimeSpan timeout)
        {
            return Invoke(workflow, timeout, null);
        }
        [Fx.Tag.InheritThrows(From = "Invoke")]
        public static IDictionary<string, object> Invoke(Activity workflow, IDictionary<string, object> inputs)
        {
            return Invoke(workflow, inputs, ActivityDefaults.InvokeTimeout, null);
        }
        [Fx.Tag.InheritThrows(From = "Invoke")]
        public static IDictionary<string, object> Invoke(Activity workflow, IDictionary<string, object> inputs, TimeSpan timeout)
        {
            return Invoke(workflow, inputs, timeout, null);
        }
        [Fx.Tag.InheritThrows(From = "Invoke")]
        [SuppressMessage(FxCop.Category.Design, FxC
namespace LeatherApp.WebServices
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [System.ComponentModel.ToolboxItem(false)]
    [System.Web.Script.Services.ScriptService]
    public class ServiceDispatch_Location : System.Web.Services.WebService
    {
        [WebMethod]
        public void Filter_Get_Dispatch_Location(int iDisplayLength, int iDisplayStart, int iSortCol_0, string sSortDir_0, string sSearch)
        {
            int filteredCount = 0;
            List<Dispatch_Location> Dispatch_Location_List = new List<Dispatch_Location>();
            DataTable dt = Dispatch_Location_DA.Filter_Get_Dispatch_Location(iDisplayLength, iDisplayStart, iSortCol_0, sSortDir_0, sSearch);
            foreach (DataRow row in dt.Rows)
            {
                filteredCount = int.Parse(row["TotalCount"].ToString());
                Dispatch_Location_List.Add(new Dispatch_Location
                {
                    ID = int.Parse(row["ID"].ToString()),
               

                    Supplier_Code = row["Code"].ToString(),
                    Supplier_Name = row["Supplier_Name"].ToString(),
                    Address = row["Address"].ToString(),
                    ZP = row["Zip/Postal"].ToString(),
                    SP = row["State/Province"].ToString(),
                    City = row["City"].ToString(),
                    Country = row["Country"].ToString(),
                    ForEdit = row["ID"].ToString(),
                    ForDelete = row["ID"].ToString()
                });
            }
            var result = new
            {
                iTotalRecords = GetTotal_Dispatch_Location_Count(),
                iTotalDisplayRecords = filteredCount,
                aaData = Dispatch_Location_List
            };
            JavaScriptSerializer js = new JavaScriptSerializer();
            Context.Response.Write(js.Serialize(result));
        }
        private int GetTotal_Dispatch_Location_Count()
        {
            int totalDisp

            string cs = ConfigurationManager.ConnectionStrings["DefaultConnection"].ConnectionString;
            {
                SqlCommand cmd =
                    new SqlCommand("select Count(*) from Dispatch_Location where IsDeleted=0", con);
                con.Open();
                totalDispatch_Location_Count = (int)cmd.ExecuteScalar();
            }
            return totalDispatch_Location_Count;
        }
        [WebMethod]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public Dispatch_Location Get_Dispatch_Location_By_Id(int ID)
        {
            Dispatch_Location _Dispatch_Location = new Dispatch_Location();
            DataTable dt = Dispatch_Location_DA.Get_Dispatch_Location_By_Id(ID);
            foreach (DataRow row in dt.Rows)
            {
                ID = int.Parse(row["ID"].ToString());
                _Dispatch_Location.Supplier_ID = int.Parse(row["Supplier_ID"].ToString());
                _Dispatch_Location.Address = row["Addr
namespace MFDExtractor.FlightDataAdapters
	namespace MFDExtractor.FlightDataAdapters
	{
		internal interface IMFDFlightDataAdapter
		{
			void Adapt(IInstrument instrument, F4TexSharedMem.IReader texSharedMemReader, Rectangle sourceRectangle, InstrumentType instrumentType);
		}
		class MFDFlightDataAdapter : IMFDFlightDataAdapter
		{
			public void Adapt(IInstrument instrument, F4TexSharedMem.IReader texSharedMemReader, Rectangle sourceRectangle, InstrumentType instrumentType)
			{
                if (instrument == null || instrument.Renderer as IMfdRenderer == null) return;
                
                var mfd = instrument.Renderer as IMfdRenderer;
                try
                {
                    mfd.InstrumentState.TestMode = Extractor.State.OptionsFormIsShowing;
                    if ((NetworkMode)Settings.Default.NetworkingMode == NetworkMode.Client && instrument.Form != null && instrument.Form.Visible)
                    {
                        mfd.InstrumentState

                    }
                    else if (!mfd.InstrumentState.TestMode)
                    {
                        mfd.InstrumentState.SourceImage = sourceRectangle.IsEmpty
                            ? null
                            : texSharedMemReader != null ? texSharedMemReader.GetImage(sourceRectangle) : null;
                    }
                    mfd.InstrumentState.SourceRectangle = mfd.InstrumentState.SourceImage != null ? new Rectangle(0, 0, mfd.InstrumentState.SourceImage.Width, mfd.InstrumentState.SourceImage.Height) : Rectangle.Empty;
                    mfd.InstrumentState.Blank = !Extractor.State.SimRunning;
                    if (!Extractor.State.Running || !Extractor.State.KeepRunning)
                    {
                        mfd.InstrumentState.SourceImage = null;
                    }
                    if ((NetworkMode)Settings.Default.NetworkingMode == NetworkMode.Server)
                    {
                        ExtractorServer.SetIn
namespace SlimShader.Chunks
	public abstract class BytecodeChunk
	{
		private static readonly Dictionary<uint, ChunkType> KnownChunkTypes = new Dictionary<uint, ChunkType>
		{
			{ "IFCE".ToFourCc(), ChunkType.Ifce },
			{ "ISGN".ToFourCc(), ChunkType.Isgn },
			{ "OSGN".ToFourCc(), ChunkType.Osgn },
			{ "OSG5".ToFourCc(), ChunkType.Osg5 },
			{ "PCSG".ToFourCc(), ChunkType.Pcsg },
			{ "RDEF".ToFourCc(), ChunkType.Rdef },
			{ "SDBG".ToFourCc(), ChunkType.Sdbg },
			{ "SFI0".ToFourCc(), ChunkType.Sfi0 },
			{ "SHDR".ToFourCc(), ChunkType.Shdr },
			{ "SHEX".ToFourCc(), ChunkType.Shex },
			{ "SPDB".ToFourCc(), ChunkType.Spdb },
			{ "STAT".ToFourCc(), ChunkType.Stat }
		};
		public BytecodeContainer Container { get; private set; }
		public uint FourCc { get; private set; }
		public ChunkType ChunkType { get; private set; }
		public uint ChunkSize { get; private set; }
		public static BytecodeChunk ParseChunk(BytecodeReader chunkReader, BytecodeContainer container)
		{
			uint fourCc 

			uint chunkSize = chunkReader.ReadUInt32();
			ChunkType chunkType;
		    if (KnownChunkTypes.ContainsKey(fourCc))
		    {
		        chunkType = KnownChunkTypes[fourCc];
		    }
		    else
		    {
		        System.Diagnostics.Debug.WriteLine("Chunk type '" + fourCc.ToFourCcString() + "' is not yet supported.");
		        return null;
		    }
		    var chunkContentReader = chunkReader.CopyAtCurrentPosition((int) chunkSize);
			BytecodeChunk chunk;
			switch (chunkType)
			{
				case ChunkType.Ifce :
					chunk = InterfacesChunk.Parse(chunkContentReader, chunkSize);
					break;
				case ChunkType.Isgn :
				case ChunkType.Osgn:
				case ChunkType.Osg5:
				case ChunkType.Pcsg:
					chunk = InputOutputSignatureChunk.Parse(chunkContentReader, chunkType,
						container.ResourceDefinition.Target.ProgramType);
					break;
				case ChunkType.Rdef:
					chunk = ResourceDefinitionChunk.Parse(chunkContentReader);
					break;
				case ChunkType.Sdbg :
				case ChunkType.Spdb :
					chunk = Deb
namespace Intact.ParallelLib
{    
    internal class Invoke : ParallelConstruct
    {
        private WaitHandle[] waitHandles;
        #region public InvokeExecution()
        public Invoke()
        {
            ThreadPool.SetMaxThreads(processorCount, processorCount);
            waitHandles = new WaitHandle[processorCount];
        }
        #endregion
        public void InvokeExecution(params InvokeAction[] actions)
        {
            chunk = (actions.Length) / processorCount;
            int start = 0;
            int end = chunk;
            for (int i = 1; i <= processorCount; i++)
            {
                int x = i - 1;
                waitHandles[x] = new ManualResetEvent(false);
                InvokePart invokePart = new InvokePart();
                for(int j = start; j <= end; j++)
                    invokePart.InvokationParts.Add(actions[j]);
                ConstantInvokeSynchronisationContainer invokeSynchronisationContainer =
                    new Consta

                ThreadPool.QueueUserWorkItem(
                    delegate(object state)
                    {
                        ConstantInvokeSynchronisationContainer localinvokeSynchronisationContainer = (ConstantInvokeSynchronisationContainer)state;
                        InvokePart localInvokePart = localinvokeSynchronisationContainer.InvokePart_;
                        try
                        {
                            foreach (InvokeAction invokeAction in localInvokePart.InvokationParts)
                            {
                                invokeAction.Invoke();
                            }                                               
                        }
                        finally
                        {
                            localinvokeSynchronisationContainer.ManualResetEvent_.Set();
                        }
                    }, invokeSynchronisationContainer);
                start = end + 1;
                end = end + chunk;


            WaitHandle.WaitAll(waitHandles);
        }
        public void InvokeExecution(ExecutionConstancyEnum executionConstancy, InvokeAction[] actions)
        {
            if (executionConstancy == ExecutionConstancyEnum.Constant)
            {
                InvokeExecution(actions);
            }
            else
            {
                ParallelQueue<InvokePart>[] parallelQueues = new ParallelQueue<InvokePart>[processorCount];
                chunk = (actions.Length) / processorCount;
                int start = 0;
                int end = chunk;
                for (int i = 1; i <= processorCount; i++)
                {
                    int x = i - 1;
                    waitHandles[x] = new ManualResetEvent(false);
                    ParallelQueueFiller parallelQueueFiller = new ParallelQueueFiller();
                    List<InvokeAction> perProcessorInvokeActions = new List<InvokeAction>();
                    for (int j = start; j <= end; j++)
              
namespace uGaMa.Observer
    public class DispatchManager
    {
        GameManager _gameManager;
        public Dictionary<object, Dictionary<Action<ObserverParam>, IObserver>> DispatchList;
        public DispatchManager()
        {
            _gameManager = GameManager.Instance;
            DispatchList = new Dictionary<object, Dictionary<Action<ObserverParam>, IObserver>>();
        }
        public void AddListener(IObserver obj, object dispatchKey, Action<ObserverParam> callBack)
        {
            if(obj.DispatchKeys.Find(s=> s == dispatchKey) == null)
            {
                obj.DispatchKeys.Add(dispatchKey);
            }
            if(!DispatchList.ContainsKey(dispatchKey))
            {
                DispatchList.Add(dispatchKey, new Dictionary<Action<ObserverParam>, IObserver> { { callBack, obj } });
            }
            else
            {
                DispatchList[dispatchKey].Add(callBack, obj);
            }
        }
        public void RemoveListen

        {
            var actions = DispatchList[dispatchKey];
            if (actions == null) return;
            for (int i = 0; i < actions.Count; i++)
            {
                if(actions.Keys.ElementAt(i) == callback && actions.Values.ElementAt(i) == obj)
                {
                    actions.Remove(actions.Keys.ElementAt(i));
                }
            }
            if (actions.Count == 0)
            {
                DispatchList.Remove(dispatchKey);
            }
            obj.DispatchKeys.Remove(obj.DispatchKeys.Find(s => s == dispatchKey));
        }
        public void RemoveAllListeners(IObserver obj)
        {
            foreach (var dispatchKey in obj.DispatchKeys)
            {
                var actions = DispatchList[dispatchKey];
                if (!actions.ContainsValue(obj)) continue;
                for (int i = 0; i < actions.Count; i++)
                {
                    if (actions.Values.ElementAt(i) == obj)
                    {
     

                    }
                }
                if(actions.Count == 0)
                {
                    DispatchList.Remove(dispatchKey);
                }
            }
            obj.DispatchKeys.Clear();
        }
        public void Dispatch(object dispatchKey, object dispatchParam, object dispatchMsg)
        {
            var notify = new ObserverParam(dispatchKey, dispatchParam, dispatchMsg);
            _gameManager.CommandMap.ExecuteCommand(notify);
            SendNotifyToObject(notify);
        }
        public void Dispatch(object dispatchKey, object dispatchParam)
        {
            var notify = new ObserverParam(dispatchKey, dispatchParam, null);
            _gameManager.CommandMap.ExecuteCommand(notify);
            SendNotifyToObject(notify);
        }
        public void Dispatch(object dispatchKey)
        {
            var notify = new ObserverParam(dispatchKey, null, null);
            _gameManager.CommandMap.ExecuteCommand(notify);
            Sen
namespace KataInstrumentProcessor
    public class InstrumentProcessor : IInstrumentProcessor
    {
        #region 
        private IInstrument instrument;
        private ITaskDispatcher taskDispatcher;
        private Queue<string> currentTasks = new Queue<string>();
        private IConsole console;
        #endregion
        public InstrumentProcessor(IInstrument instrument, ITaskDispatcher taskDispatcher, IConsole console)
        {
            this.instrument = instrument;
            this.taskDispatcher = taskDispatcher;
            this.console = console;
            this.instrument.Finished += (sender, args) =>
                {
                    this.taskDispatcher.FinishedTask(currentTasks.Dequeue());
                };
            this.instrument.Error += (sender, args) =>
                { this.console.WriteLine(currentTasks.Dequeue()); };
        }
        public void Process()
        {
            var task = this.taskDispatcher.GetTask();
            this.currentTask
@{
    ViewBag.Title = "Dispatch";
    Layout = "~/Views/Shared/_Layout.cshtml";
<div class="main">
    <div class="main-inner">
        <div class="container">
            <div class="row">
                        <div class="widget-header">
    @Html.DevExpress().PageControl(pcDispatchSettings =>
    pcDispatchSettings.Name = "pcDispatch";
    pcDispatchSettings.Width = System.Web.UI.WebControls.Unit.Percentage(100);
    pcDispatchSettings.EnableClientSideAPI = true;
    pcDispatchSettings.TabAlign = TabAlign.Justify;
    pcDispatchSettings.ActiveTabIndex = 0;
    pcDispatchSettings.TabPages.Add("Progress").SetContent(
        Html.Partial("_DispatchProgressPartial").ToHtmlString()
    );
    pcDispatchSettings.TabPages.Add("New").SetContent(
        Html.Partial("_DispatchNewPartial").ToHtmlString()
    );
    pcDispatchSettings.TabPages.Add("Scheduling").SetContent(
        Html.Partial("_DispatchNewPartial").ToHtmlString()
    );
    pcDispatchSettings.TabPages.Add("Driver Request
namespace nModule.Utilities
    public class ProcessUtility
    {
        public static Process LaunchExternalProcess(string processPath, string processArguments)
        {
            return LaunchExternalProcess(processPath, processArguments, false, false, null);
        }
        public static Process LaunchExternalProcess(string processPath, string processArguments, bool startProcess, bool waitForExit, IProcessDataCapturer processDataCapturer)
        {
            var externalProcess = new Process();
            var externalProcessStartInfo = new ProcessStartInfo
            {
                Arguments = processArguments,
                FileName = processPath,
                RedirectStandardInput = true,
                RedirectStandardError = true,
                RedirectStandardOutput = true,
                CreateNoWindow = true,
                UseShellExecute = false
            };
            externalProcess.StartInfo = externalProcessStartInfo;
            if (processDat
namespace Economic.DAL
    public class UnitOfWork : IDisposable
    {
        private readonly Entities _context;
        private IClientgroupsRepository _clientgroupRepository;
        private IGoodtypesRepository _goodTypesRepository;
        private IGoodsRepository _goodsRepository;
        private IPricehierarhyRepository _pricehierarhyRepository;
        private ISimplepricelistRepository _simplePriceListsRepository;
        private IEnteranceRepository _enteranceRepository;
        private IEnteranceItemsRepository _enteranceItemsRepository;
        private IUsersRepository _usersRepository;
        private IMarketingChangesRepository _marketingchangesRepository;
        public UnitOfWork()
        {
            _context = new Entities();
        }
        public UnitOfWork(Entities context)
        {
            _context = context; 
        }
        virtual public IClientgroupsRepository ClientgroupRepository => _clientgroupRepository ?? (_clientgroupRepository = new Clientgr

        virtual public IGoodtypesRepository GoodTypesRepository => _goodTypesRepository ?? (_goodTypesRepository = new GoodtypesRepository(_context));
        virtual public IGoodsRepository GoodsRepository => _goodsRepository ?? (_goodsRepository = new GoodsRepository(_context));
        virtual public IPricehierarhyRepository PricehierarhyRepository => _pricehierarhyRepository ?? (_pricehierarhyRepository = new PricehierarhyRepository(_context));
        virtual public ISimplepricelistRepository SimplePriceListsRepository => _simplePriceListsRepository ?? (_simplePriceListsRepository = new SimplepricelistRepository(_context));
        virtual public IEnteranceRepository EnteranceRepository => _enteranceRepository ?? (_enteranceRepository = new EnteranceRepository(_context));
        virtual public IEnteranceItemsRepository EnteranceItemsRepository => _enteranceItemsRepository ?? (_enteranceItemsRepository = new EnteranceItemsRepository(_context));
        virtual public IUsersReposi
﻿namespace Stock.DAL.Repositories
    public class RepositoryFactory
    {
        private static readonly IMarketRepository marketRepository;
        private static readonly ICurrencyRepository currencyRepository;
        private static readonly IAssetRepository assetRepository;
        private static readonly ITimeframeRepository timeframeRepository;
        private static readonly IQuotationRepository quotationRepository;
        private static readonly IPriceRepository priceRepository;
        private static readonly ISimulationRepository simulationRepository;
        private static readonly IAnalysisRepository analysisRepository;
        private static readonly ITrendlineRepository trendlineRepository;
        static RepositoryFactory()
        {
            marketRepository = new EFMarketRepository();
            currencyRepository = new EFCurrencyRepository();
            assetRepository = new EFAssetRepository();
            timeframeRepository = new EFTimeframeRepository();
  

            priceRepository = new EFPriceRepository();
            simulationRepository = new EFSimulationRepository();
            analysisRepository = new EFAnalysisRepository();
            trendlineRepository = new EFTrendlineRepository();
        }
        public static IMarketRepository GetMarketRepository()
        {
            return marketRepository;
        }
        public static ICurrencyRepository GetCurrencyRepository()
        {
            return currencyRepository;
        }
        public static IAssetRepository GetAssetRepository()
        {
            return assetRepository;
        }
        public static ITimeframeRepository GetTimeframeRepository()
        {
            return timeframeRepository;
        }
        public static IQuotationRepository GetQuotationRepository()
        {
            return quotationRepository;
        }
        public static IPriceRepository GetPriceRepository()
        {
            return priceRepository;
        }
        publi
namespace Gtc.AssemblyApiTests
    [TestFixture]
    public class ComparisonTests
    {
        private readonly BinaryApiComparer m_BinaryApiComparer = new BinaryApiComparer();
        [Test]
        public void IdenticalAssembliesAreEqual()
        {
            var oldApi = ApiBuilder.CreateApi("1");
            var newApi = ApiBuilder.CreateApi("1");
            var comparison = Compare(oldApi, newApi);
            Assert.That(comparison.GetDifferences(),
                Has.All.Matches<IApiNodeComparison>(n => !n.IsDifferent));
        }
        [Test]
        public void TotallyDifferentAssembliesAreNotEqual()
        {
            var oldApi = ApiBuilder.CreateApi("1");
            var newApi = ApiBuilder.CreateApi("2");
            var comparison = Compare(oldApi, newApi);
            Assert.That(comparison.GetDifferences(),
                Has.All.Matches<IApiNodeComparison>(n => n.IsDifferent));
        }
        [Test]
        public void BinaryIncompatible()
        {
     

            var newApi = ApiBuilder.CreateApi("2");
            var comparison = Compare(oldApi, newApi);
            Assert.That(m_BinaryApiComparer.GetApiChangeType(comparison), Is.EqualTo(BinaryApiCompatibility.Incompatible));
        }
        [Test]
        public void GivenCompatibleApiThenBuildVersionIncreases()
        {
            var oldApi = ApiBuilder.CreateApi("1");
            var newApi = ApiBuilder.CreateApi("1");
            var comparison = Compare(oldApi, newApi);
            Assert.That(comparison.GetNewSemanticVersion(new Version(1, 0, 0, 0)).AssemblyFileVersion, Is.EqualTo(new Version(1, 0, 1, 0)));
        }
        [Test]
        public void GivenAddititveApiChangeThenMinorVersionIncreases()
        {
            var oldApi = ApiBuilder.CreateApi("1");
            var comparison = ApiNodeComparison.Compare(new[] { oldApi }, new[] { oldApi, ApiBuilder.CreateApi("") });
            Assert.That(comparison.GetNewSemanticVersion(new Version(1, 0, 0, 0)).AssemblyFil
public class Architect : MonoBehaviour {
	public World world;
		
	public T CreateChunk<T> (float x, float y, float z, Chunk chunk) where T : Chunk {
		Vector3 position = new Vector3(x,y,z);
		T newChunkObject = (T)chunk.GetPooledInstance<T> ();
		newChunkObject.transform.position = position;
		newChunkObject.position = position;
		newChunkObject.transform.rotation = Quaternion.Euler (Vector3.zero);
		newChunkObject.world = world;
		newChunkObject.transform.parent = world.transform;
		newChunkObject.chunkWidth = world.chunkWidth;
		newChunkObject.chunkHeight = world.chunkHeight;
		newChunkObject.chunkDepth = world.chunkDepth;
		newChunkObject.poolStart();
		
		world.AddChunk(position,newChunkObject);
		return newChunkObject;
	}
	public T CreateSubChunk<T> (float x, float y, float z, SubChunk sub, Chunk chunk) where T : SubChunk {
		Vector3 position = new Vector3(x,y,z);
		T newSubChunk = (T)sub.GetPooledInstance<T> ();
		newSubChunk.transform.position = position;
		newSubChunk.transform
namespace IwVoxelGame.Blocks.World {
    public class World {
        private readonly Dictionary<Vector3i, Chunk> _chunks;
        private readonly Dictionary<Vector3i, Chunk> _loadedChunks;
        private readonly Dictionary<Vector3i, Chunk> _unloadedChunks;
        private readonly Queue<Chunk> m_chunksToBeLoaded;
        private readonly Queue<Chunk> m_chunksToBeUnloaded;
        private readonly Queue<Chunk> m_chunksToBeGenerated;
        private readonly double _chunkTimeout = 10000;
        public Dictionary<Vector3i, Chunk> LoadedChunks => _loadedChunks;
        public World() {
            _chunks = new Dictionary<Vector3i, Chunk>();
            _loadedChunks = new Dictionary<Vector3i, Chunk>();
            _unloadedChunks = new Dictionary<Vector3i, Chunk>();
            m_chunksToBeLoaded = new Queue<Chunk>();
            m_chunksToBeUnloaded = new Queue<Chunk>();
            m_chunksToBeGenerated = new Queue<Chunk>();
        }
        public void LoadChunk(Vector3i positio

            if(_unloadedChunks.ContainsKey(position)) {
                SetLoadChunk(_unloadedChunks[position]);
                return;
            }
            if (!_loadedChunks.TryGetValue(position, out Chunk chunk)) {
                chunk = new Chunk(this, position);
                SetLoadChunk(chunk);
                if (!chunk.HasBeenGenerated) {
                    Task.Factory.StartNew(() => { GenerateChunk(chunk); });
                }
            }
        }
        public void SetLoadChunk(Chunk chunk) {
            chunk.LoadTime = Time.GameTime;
            _loadedChunks.Add(chunk.Position, chunk);
            _unloadedChunks.Remove(chunk.Position);
        }
        public void UnloadChunk(Chunk chunk) {
            _loadedChunks.Remove(chunk.Position);
            _unloadedChunks.Add(chunk.Position, chunk);
        }
        private void GenerateChunk(Chunk chunk) {
            chunk.Generate();
            m_chunksToBeLoaded.Enqueue(chunk);
        }
        public

            lock (_loadedChunks) {
                foreach (Chunk chunk in _loadedChunks.Values) {
                    if (Time.GameTime - chunk.LoadTime > _chunkTimeout) {
                        m_chunksToBeUnloaded.Enqueue(chunk);
                    }
                }
            }
            lock(m_chunksToBeUnloaded) {
                while(m_chunksToBeUnloaded.Count > 0) {
                    UnloadChunk(m_chunksToBeUnloaded.Dequeue());
                    Logger.Debug($"Loaded chunks: {_loadedChunks.Count}   Unloaded chunks: {_unloadedChunks.Count}");
                }
            }
            lock (m_chunksToBeLoaded) {
                while (m_chunksToBeLoaded.Count > 0) {
                    m_chunksToBeLoaded.Dequeue()?.Update();
                    Logger.Debug($"Loaded chunks: {_loadedChunks.Count}   Unloaded chunks: {_unloadedChunks.Count}");
                }
            }
            LoadWorldAroundPlayer(camera.transform.GetChunk(), 4);
        }
        public vo
namespace Global.DataAccess
    public class InstrumentCertificationDaoImpl
    {
        public void Add(InstrumentCertificationModel model)
        {
            DBProvider.dbMapper.Insert("BaseData_InstrumentCertification.Insert", model);
        }
        public void Update(InstrumentCertificationModel model)
        {
            DBProvider.dbMapper.Update("BaseData_InstrumentCertification.Update", model);
        }
        public void DeleteById(int LogId)
        {
            DBProvider.dbMapper.Delete("BaseData_InstrumentCertification.DeleteById", LogId);
        }
        public InstrumentCertificationModel GetById(int LogId)
        {
            return DBProvider.dbMapper.SelectObject<InstrumentCertificationModel>("BaseData_InstrumentCertification.GetByID", LogId);
        }
        public IList<InstrumentCertificationModel> GetAll()
        {
            return DBProvider.dbMapper.SelectList<InstrumentCertificationModel>("BaseData_InstrumentCertification.GetAll");
        
public class World : MonoBehaviour {
    public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk>();
    public GameObject chunkPrefab;
    public string worldName = "world";
    public void CreateChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newChunkObject = Instantiate(
                        chunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        Chunk newChunk = newChunkObject.GetComponent<Chunk>();
        newChunk.pos = worldPos;
        newChunk.world = this;
        chunks.Add(worldPos, newChunk);
        var terrainGen = new TerrainGen();
        newChunk = terrainGen.ChunkGen(newChunk);
        newChunk.SetBlocksUnmodified();
        Serialization.Load(newChunk);
    }
    public void DestroyChunk(int x, int y, int z)
    {
        Chunk chunk = null;
        if (chunks.TryGetValue(new WorldPos(x, y, z), out chunk))
      

            Serialization.SaveChunk(chunk);
            Object.Destroy(chunk.gameObject);
            chunks.Remove(new WorldPos(x, y, z));
        }
    }
    public Chunk GetChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = Chunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * Chunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * Chunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * Chunk.chunkSize;
        Chunk containerChunk = null;
        chunks.TryGetValue(pos, out containerChunk);
        return containerChunk;
    }
    public Block GetBlock(int x, int y, int z)
    {
        Chunk containerChunk = GetChunk(x, y, z);
        if (containerChunk != null)
        {
            Block block = containerChunk.GetBlock(
                x - containerChunk.pos.x,
                y - containerChunk.pos.y,
                z - containerChunk.pos.z);
            return block;
        }
        else
        

            return new BlockAir();
        }
    }
    public void SetBlock(int x, int y, int z, Block block)
    {
        Chunk chunk = GetChunk(x, y, z);
        if (chunk != null)
        {
            chunk.SetBlock(x - chunk.pos.x, y - chunk.pos.y, z - chunk.pos.z, block);
            chunk.update = true;
            UpdateIfEqual(x - chunk.pos.x, 0, new WorldPos(x - 1, y, z));
            UpdateIfEqual(x - chunk.pos.x, Chunk.chunkSize - 1, new WorldPos(x + 1, y, z));
            UpdateIfEqual(y - chunk.pos.y, 0, new WorldPos(x, y - 1, z));
            UpdateIfEqual(y - chunk.pos.y, Chunk.chunkSize - 1, new WorldPos(x, y + 1, z));
            UpdateIfEqual(z - chunk.pos.z, 0, new WorldPos(x, y, z - 1));
            UpdateIfEqual(z - chunk.pos.z, Chunk.chunkSize - 1, new WorldPos(x, y, z + 1));
        
        }
    }
    void UpdateIfEqual(int value1, int value2, WorldPos pos)
    {
        if (value1 == value2)
        {
            Chunk chunk = GetChunk(pos.x, pos.y, pos.z);
namespace MVC5Course.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static ClientRepository GetClientRepository()
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ClientRepository GetClientRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ClientRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OccupationRepository GetOccupationRepository()
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OccupationRepository GetOccupationRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OccupationRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderRepository GetOrderRepository()
		{
			var repository = new OrderRepo

			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderRepository GetOrderRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static OrderLineRepository GetOrderLineRepository()
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static OrderLineRepository GetOrderLineRepository(IUnitOfWork unitOfWork)
		{
			var repository = new OrderLineRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static ProductRepository GetProductRepository()
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static ProductRepository GetProductRepository(IUnitOfWork unitOfWork)
		{
			var repository = new ProductRepository();
			repository.UnitOfWork = unitOfWork;
			return repo
namespace Aurayu.VoxelWorld.Voxel
    public class World
    {
        public Dictionary<Point3D, Chunk> Chunks;
        public World()
        {
            Chunks = new Dictionary<Point3D, Chunk>();
        }
        [CanBeNull]
        public Chunk GetChunk(Point3D chunkPositionInWorld)
        {
            Chunk chunk;
            Chunks.TryGetValue(chunkPositionInWorld, out chunk); 
            return chunk;
        }
        public IBlock GetBlock(Point3D worldPosition)
        {
            var chunkPositionInWorld = GetChunkPositionInWorld(worldPosition);
            var chunk = GetChunk(chunkPositionInWorld);
            if (chunk == null)
                return new AirBlock();
            var blockPositionInChunk = GetBlockPositionInChunk(worldPosition, chunk.Position);
            var block = chunk.GetBlock(blockPositionInChunk);
            return block;
        }
        public bool SetBlock(Point3D worldPosition, IBlock block, bool updateAdjacentChunks = false)
        {

            var chunkPositionInWorld = GetChunkPositionInWorld(worldPosition);
            var chunk = GetChunk(chunkPositionInWorld);
            if (chunk == null)
                return false;
            var x = worldPosition.X - chunk.Position.X;
            var y = worldPosition.Y - chunk.Position.Y;
            var z = worldPosition.Z - chunk.Position.Z;
            var updatedBlockPositionInChunk = new Point3D(x, y, z);
            var didSetBlock = chunk.SetBlock(updatedBlockPositionInChunk, block);
            if (didSetBlock && updateAdjacentChunks)
            {
                SetAdjacentChunksToUpdate(chunkPositionInWorld, updatedBlockPositionInChunk);
            }
            return didSetBlock;
        }
        private void SetAdjacentChunksToUpdate(Point3D chunkPositionInWorld, Point3D updatedBlockPositionInChunk)
        {
            if (updatedBlockPositionInChunk.X == 0)
            {
                var adjacentChunkPosition = new Point3D(chunkPositionInWorld.X

                UpdateChunk(adjacentChunkPosition);
            }
            if (updatedBlockPositionInChunk.X == Chunk.Width - 1)
            {
                var adjacentChunkPosition = new Point3D(chunkPositionInWorld.X + Chunk.Width, chunkPositionInWorld.Y, chunkPositionInWorld.Z);
                UpdateChunk(adjacentChunkPosition);
            }
            if (updatedBlockPositionInChunk.Y == 0)
            {
                var adjacentChunkPosition = new Point3D(chunkPositionInWorld.X, chunkPositionInWorld.Y - Chunk.Height, chunkPositionInWorld.Z);
                UpdateChunk(adjacentChunkPosition);
            }
            if (updatedBlockPositionInChunk.Y == Chunk.Height - 1)
            {
                var adjacentChunkPosition = new Point3D(chunkPositionInWorld.X, chunkPositionInWorld.Y + Chunk.Height, chunkPositionInWorld.Z);
                UpdateChunk(adjacentChunkPosition);
            }
            if (updatedBlockPositionInChunk.Z == 0)
            {
           
namespace System.ServiceModel.Dispatcher
    class WorkflowDispatchContext : IDisposable
    {
        [ThreadStatic]
        static WorkflowDispatchContext workflowDispatchContext = null;
        bool isWorkflowStarting;
        bool synchronous;
        public WorkflowDispatchContext(bool synchronous)
            : this(synchronous, false)
        {
        }
        public WorkflowDispatchContext(bool synchronous, bool isWorkflowStarting)
        {
            this.synchronous = synchronous;
            this.isWorkflowStarting = isWorkflowStarting;
            workflowDispatchContext = this;
        }
        public static WorkflowDispatchContext Current
        {
            get
            {
                return workflowDispatchContext;
            }
        }
        public bool IsSynchronous
        {
            get
            {
                return this.synchronous;
            }
        }
        public bool IsWorkflowStarting
        {
            get
            {
    
namespace SDK.Lib
    /**
     * @breif Tree Node 状态变化通知
     */
    public class MTreeNodeStateNotify : IDispatchObject
    {
        public MTerrainQuadTreeNode mNode;
        protected AddOnceEventDispatch mShowDispatch;
        protected AddOnceEventDispatch mHideDispatch;
        public MTreeNodeStateNotify(MTerrainQuadTreeNode node)
        {
            mNode = node;
            mShowDispatch = new AddOnceEventDispatch();
            mHideDispatch = new AddOnceEventDispatch();
        }
        public void init()
        {
        }
        public void onInit()
        {
        }
        public void onShow()
        {
            mShowDispatch.dispatchEvent(this);
        }
        public void onHide()
        {
            mHideDispatch.dispatchEvent(this);
        }
        public void onExit()
        {
        }
        public void addShowEventHandle(MAction<IDispatchObject> handle)
        {
            mShowDispatch.addEventHandle(null, handle);
        }
        public v
namespace Microsoft.AspNetCore.Razor.Chunks
    public class ChunkTreeBuilder
    {
        private readonly Stack<ParentChunk> _parentStack;
        private Chunk _lastChunk;
        public ChunkTreeBuilder()
        {
            Root = new ChunkTree();
            _parentStack = new Stack<ParentChunk>();
            _parentStack.Push(Root);
        }
        public ParentChunk Current => _parentStack.Peek();
        public ChunkTree Root { get; }
        public void AddChunk(Chunk chunk, SyntaxTreeNode association, bool topLevel = false)
        {
            _lastChunk = chunk;
            chunk.Start = association.Start;
            chunk.Association = association;
            if (topLevel)
            {
                Root.Children.Add(chunk);
            }
            else
            {
                Current.Children.Add(chunk);
            }
        }
        public void AddTagHelperPrefixDirectiveChunk(string prefix, SyntaxTreeNode association)
        {
            AddChun

                new TagHelperPrefixDirectiveChunk
                {
                    Prefix = prefix
                },
                association,
                topLevel: true);
        }
        public void AddAddTagHelperChunk(string lookupText, SyntaxTreeNode association)
        {
            AddChunk(new AddTagHelperChunk
            {
                LookupText = lookupText
            }, association, topLevel: true);
        }
        public void AddRemoveTagHelperChunk(string lookupText, SyntaxTreeNode association)
        {
            AddChunk(new RemoveTagHelperChunk
            {
                LookupText = lookupText
            }, association, topLevel: true);
        }
        public void AddLiteralChunk(string literal, SyntaxTreeNode association)
        {
            ParentLiteralChunk parentLiteralChunk;
            if (_lastChunk is LiteralChunk)
            {
                parentLiteralChunk = new ParentLiteralChunk()
                {
                   

                };
                parentLiteralChunk.Children.Add(_lastChunk);
                parentLiteralChunk.Children.Add(new LiteralChunk
                {
                    Association = association,
                    Start = association.Start,
                    Text = literal,
                });
                Debug.Assert(Current.Children[Current.Children.Count - 1] == _lastChunk);
                Current.Children.RemoveAt(Current.Children.Count - 1);
                Current.Children.Add(parentLiteralChunk);
                _lastChunk = parentLiteralChunk;
            }
            else if ((parentLiteralChunk = _lastChunk as ParentLiteralChunk) != null)
            {
                parentLiteralChunk.Children.Add(new LiteralChunk
                {
                    Association = association,
                    Start = association.Start,
                    Text = literal,
                });
                _lastChunk = parentLiteralChunk;
            }
        
namespace DAL
    public class Facade
    {
        private IGenericRepository<ProductDTO> _productRepository;
        private IOrderRepository _orderRepository;
        private ICityRepository _cityRepository;
        private IGenericRepository<OrderLineDTO> _orderLineRepository;
        private IGenericRepository<CategoryDTO> _categoryRepository;
        private IGenericRepository<CustomerDTO> _customerRepository;
        private IAddressRepository _addressRepository;
        public Facade()
        {
            var instance = System.Data.Entity.SqlServer.SqlProviderServices.Instance;
        }
        public IGenericRepository<ProductDTO> GetProductRepository()
        {
            return _productRepository != null ? _productRepository : _productRepository = new ProductRepository();
        }
        public IOrderRepository GetOrderRepository()
        {
            return _orderRepository != null ? _orderRepository : _orderRepository = new OrderRepository();
        }
        pub
namespace COREBASE.COMMAND.MyProcess
    public class MyProcess
    {
        public MyProcess()
        {
        }
        public static bool FindAndKillOneProcess(string name)
        {
            foreach (Process clsProcess in Process.GetProcesses())
            {
                if (clsProcess.ProcessName.StartsWith(name))
                {
                    clsProcess.Kill();
                    return true;
                }
            }
            return false;
        }
        public static bool FindAndKillAllProcess(string name)
        {
            bool hasProcess = false;
            foreach (Process clsProcess in Process.GetProcesses())
            {
                if (clsProcess.ProcessName.StartsWith(name))
                {
                    clsProcess.Kill();
                    hasProcess = true;
                }
            }
            return hasProcess;
        }
        public static Process PriorProcess()
        {
            Process curr = Process.G
namespace BusinessLogic
    public class DataManager
    {
        private IUsersRepository usersRepository;
        private IFriendsRepository friendsRepository;
        private IFriendRequestsRepository friendRequestsRepository;
        private IMessagesRepository messagesRepository;
        private PrimaryMembershipProvider provider;
        public DataManager(IUsersRepository usersRepository, IFriendsRepository friendsRepository, IFriendRequestsRepository friendRequestsRepository, IMessagesRepository messagesRepository, PrimaryMembershipProvider provider)
        {
            this.usersRepository = usersRepository;
            this.friendsRepository = friendsRepository;
            this.friendRequestsRepository = friendRequestsRepository;
            this.messagesRepository = messagesRepository;
            this.provider = provider;
        }
        public IUsersRepository Users { get { return usersRepository; } }
        public IFriendsRepository Friends { get { return friendsRe
public class HexGenerator : MonoBehaviour 
	[Tooltip("For Square Chunks X Should = Y/4")]
	public int chunkScale;
	public int viewDistance;
	public float heightScale;
	void Start () 
	{
		int localView = viewDistance / 2;
		for(int ChunkX = -localView; ChunkX < localView; ++ChunkX)
			for(int ChunkZ = -localView; ChunkZ < localView; ++ChunkZ)
				GenerateChunk(ChunkX,ChunkZ);		
	}
	void GenerateChunk(int ChunkX, int ChunkZ)
	{
		GameParameters ins = GameParameters.Instance;
		int chunkScaleX = chunkScale / 2;
		int chunkScaleZ = chunkScale * 2;
		GameObject Chunk = new GameObject();
		Chunk.name = "Chunk :" + ChunkX + ":" + ChunkZ;
		Chunk.transform.position = new Vector3(ChunkX * chunkScaleX * 3.0f,0,(ChunkZ * chunkScaleZ * 0.87f));
		Chunk.transform.parent = transform;
		BoxCollider bc = Chunk.AddComponent<BoxCollider>();
		bc.size = new Vector3(chunkScaleX * 3.0f,128,chunkScaleZ * 0.87f);
		bc.center += new Vector3(0,0,chunkScaleZ * 0.435f);
		bc.isTrigger = true;
		for(int x = 0; x
namespace BandAide.web.Models.ViewModels
    public class InstrumentSkillsViewModel
    {
        public List<InstrumentSkill> UserInstrumentSkills { get; set; } 
        public List<Instrument> AllInstruments { get; set; }
        public List<Instrument> PlayedInstruments { get; set; }
        public List<Instrument> UnplayedInstruments { get; set; }
         
        public SelectList InstrumentsSelectList { get; set; }
       
        public Guid UserId { get; set; }
        public Instrument SelectedInstrument { get; set; }
        public Guid SelectedInstrumentId { get; set; }
        public int SelectedProficiency { get; set; }
        public string About { get; set; }
        public InstrumentSkillsViewModel() { }
        public InstrumentSkillsViewModel(ApplicationDbContext context, User user)
        {
            UserInstrumentSkills = user.InstrumentSkills;
            AllInstruments = context.Instruments.ToList();
            PlayedInstruments = UserInstrumentSkills.Select(
namespace TrouveUnBand.Classes
    public static class CreateProfile
    {
        private static TrouveUnBandEntities db = new TrouveUnBandEntities();
        public static MusicianProfileViewModel CreateMusicianProfileView(User user)
        {
            
            var musicianList = new List<User>();
            musicianList.Add(user);
            var instrumentInfos = SetMusician_Instrument(musicianList);
            var musicianView = new MusicianProfileViewModel
            {
                InstrumentInfo = instrumentInfos[0],
                Description = user.Description,
                Name = user.FirstName + " " + user.LastName,
                Location = user.Location,
                Photo = user.Photo,
                Id = user.User_ID
            };
            return musicianView;
        }
        public static BandProfileViewModel CreateBandProfileView(Band band)
        {
            var bandView = new BandProfileViewModel
            {
                Instrument

                Name = band.Name,
                Description = band.Description,
                Location = band.Location,
                Photo = "/Photos/_StockPhotos/_stock_band.jpg",
                id = band.Band_ID,
                Sc_Name = band.SC_Name,
                Genres = band.Genres,
                Events = band.Events
            };
            return bandView;
        }
        private static List<Musician_Instrument> SetMusician_Instrument(List<User> musicians)
        {
            var instrumentInfoList = new List<Musician_Instrument>();
            ICollection<Users_Instruments> listOfInstruments;
            var skillList = new List<string> { "Aucun", "Débutant", "Initié", "Intermédiaire", "Avancé", "Professionnel" };
            foreach (var musician in musicians)
            {
                listOfInstruments = musician
                                    .Users_Instruments
                                    .OrderByDescending(x => (x.Skills))
             
namespace Rental.Repository
    public class UnitOfWork
    {
        private RentalEntities _edm = null;
        private SliderRepository _sliderRepository = null;
        private RoomRepository _roomRepository = null;
        private AreaRepository _areaRepository = null;
        private ServiceRepository _serviceRepository = null;
        private FoodRepository _foodRepository = null;
        private PreferenceRepository _preferenceRepository = null;
        private AboutRepository _aboutRepository = null;
        public UnitOfWork()
        {
            _edm = new RentalEntities();
        }
        public AboutRepository AboutRepository
        {
            get
            {
                if (_preferenceRepository == null)
                {
                    _preferenceRepository = new PreferenceRepository(_edm);
                }
                return _preferenceRepository;
            }
        }
        public PreferenceRepository PreferenceRepository
        {
         

            {
                if (_preferenceRepository == null)
                {
                    _preferenceRepository = new PreferenceRepository(_edm);
                }
                return _preferenceRepository;
            }
        }
        public ServiceRepository ServiceRepository
        {
            get
            {
                if (_serviceRepository == null)
                {
                    _serviceRepository = new ServiceRepository(_edm);
                }
                return _serviceRepository;
            }
        }
        public FoodRepository FoodRepository
        {
            get
            {
                if (_foodRepository == null)
                {
                    _foodRepository = new FoodRepository(_edm);
                }
                return _foodRepository;
            }
        }
        public RoomRepository RoomRepository
        {
            get
            {
                if (_roomRepository == null)
                
namespace ShipwayBusiness.Repository.UnitOfWork
    public class ShipwayUnitOfWork : IDisposable
    {
        private readonly ShipwayContext _context = new ShipwayContext();
        private AgencyRepository _agencyRepository;
        private DistrictRepository _districtRepository;
        private ExhibitionRepositoty _exhibitionRepositoty;
        private ExhibitionStatusRepository _exhibitionStatusRepository;
        private KindServiceRepository _kindServiceRepository;
        private KindTimeReceivedRepository _kindTimeReceivedRepository;
        private NoteRequiredRepository _noteRequiredRepository;
        private ProvinceRepository _provinceRepository;
        private ServiceChargeRepository _serviceChargeRepository;
        private ShipperRepository _shipperRepository;
        private UserRepository _userRepository;
        private WardRepository _wardRepository;
        private RouterRepository _routerRepository;
        private HistoryTripRepository _historyTripRepository;


        {
            get { return _agencyRepository ?? (_agencyRepository = new AgencyRepository(_context)); }
        }
        public DistrictRepository DistrictRepository
        {
            get { return _districtRepository ?? (_districtRepository = new DistrictRepository(_context)); }
        }
        public ExhibitionRepositoty ExhibitionRepositoty
        {
            get { return _exhibitionRepositoty ?? (_exhibitionRepositoty = new ExhibitionRepositoty(_context)); }
        }
        public ExhibitionStatusRepository ExhibitionStatusRepository
        {
            get { return _exhibitionStatusRepository ?? (_exhibitionStatusRepository = new ExhibitionStatusRepository(_context)); }
        }
        public KindServiceRepository KindServiceRepository
        {
            get { return _kindServiceRepository ?? (_kindServiceRepository = new KindServiceRepository(_context)); }
        }
        public KindTimeReceivedRepository KindTimeReceivedRepository
        {
         

        }
        public NoteRequiredRepository NoteRequiredRepository
        {
            get { return _noteRequiredRepository ?? (_noteRequiredRepository = new NoteRequiredRepository(_context)); }
        }
        public ProvinceRepository ProvinceRepository
        {
            get { return _provinceRepository ?? (_provinceRepository = new ProvinceRepository(_context)); }
        }
        public ServiceChargeRepository ServiceChargeRepository
        {
            get { return _serviceChargeRepository ?? (_serviceChargeRepository = new ServiceChargeRepository(_context)); }
        }
        public ShipperRepository ShipperRepository
        {
            get { return _shipperRepository ?? (_shipperRepository = new ShipperRepository(_context)); }
        }
        public UserRepository UserRepository
        {
            get { return _userRepository ?? (_userRepository = new UserRepository(_context)); }
        }
        public WardRepository WardRepository
        {
         
namespace Assets.Scripts
    public class World : MonoBehaviour
    {
        public GameObject chunkPrefab;
        public List<Chunk> Chunks = new List<Chunk>();
        private void Start()
        {
            GenerateChunks();
        }
        private void GenerateChunks()
        {
            for (var x = 0; x < 4; x++)
            {
                for (var z = 0; z < 4; z++)
                {
                    var chunkPos = new Vector3(x * Chunk.Width, 0, z * Chunk.Width);
                    var chunkObj = Instantiate(chunkPrefab, chunkPos, Quaternion.identity, transform);
                    chunkObj.name = string.Format("Chunk ({0}, {1})", x, z);
                    var chunk = chunkObj.GetComponent<Chunk>();
                    chunk.World = this;
                    chunk.Position = chunkPos;
                    chunk.GenerateBlocks();
                    Chunks.Add(chunk);
                }
            }
        }
        #region Block manipulation
        public Bl

        {
            var chunk = GetChunk(x, y, z);
            if (chunk == null) return new BlockAir();
            var block = chunk.GetBlock(
                x - (int)chunk.Position.x,
                y - (int)chunk.Position.y,
                z - (int)chunk.Position.z);
            return block;
        }
        public Block GetBlock(RaycastHit hit, bool adjacent = false)
        {
            var chunk = hit.collider.GetComponent<Chunk>();
            if (chunk == null)
                return null;
            var position = BlockManipulation.GetBlockPosition(hit, adjacent);
            var block = chunk.World.GetBlock((int) position.x, (int) position.y, (int) position.z);
            return block;
        }
        public void SetBlock(Block block, int x, int y, int z)
        {
            var chunk = GetChunk(x, y, z);
            if (chunk != null)
            {
                chunk.SetBlock(
                    block, 
                    x - (int)chunk.Position.x, 
    
namespace Game.Package
    public class ActionInvoker : MonoBehaviour
    {
        public UnityEvent todo;
        public float invokeDelay = 0;
        public bool invokeOnce = false;
        public bool invokeNOW = false;
        private bool wasDone = false;
        protected virtual void Awake()
        {
            ValidateUtils.Validate(gameObject, todo);
        }
        void Update()
        {
            if (invokeNOW)
            {
                Invoke();
            }
        }
        public void Invoke()
        {
            invokeNOW = false;
            if (invokeOnce && wasDone) return;
            wasDone = true;
            if (invokeDelay > 0) StartCoroutine(EnumeratorAction(invokeDelay));
            else ExecuteAction();
        }
        private IEnumerator EnumeratorAction(float waitTime)
        {
            yield return new WaitForSeconds(waitTime);
            ExecuteAction();
        }
        protected virtual void ExecuteAction()
        {
          
namespace Assets.Scripts.EngineLayer.Voxels.Containers.Chunks
    public class Chunk : VoxelContainer
    {
        public const int ChunkSize = 16;
        
        public static Chunk CreateChunk(int x, int y, int z, Map map)
        {
            var chunk = new GameObject(string.Format("Chunk [{0}, {1}, {2}]", x, y, z));
            var chunkC = chunk.gameObject.AddComponent<Chunk>();
            chunkC.CanBeHighlighted = false;
            chunkC.tag = "Chunk";
            chunk.transform.parent = map.transform;
            chunkC.InitializeContainer(new Vector3(x * ChunkSize, y * ChunkSize, z * ChunkSize), map.MapData.Chunks[x, y, z], MaterialRegistry.Instance.Materials);
            return chunkC;
        }
        
        protected override List<Vector3> UpdateMesh()
        {
            var up = base.UpdateMesh();
            var cd = (ChunkData) ContainerData;
            cd.LocalAStar.RefreshNetwork(cd, up);
            return up;
        }
        public override void Upd
namespace SystemController.InstrumentBLL
    internal static class TradingTimeParser
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(TradingTimeParser));
        internal static List<InstrumentDayOpenCloseParams> ParseInstrumentTradingTimes(DataSet ds)
        {
            Logger.Info("ParseInstrumentTradingTimes");
            if (ds.Tables.Count == 0)
            {
                Logger.Error("LoadAndGenerateInstrumentTradingTime,  db result = 0");
                return null;
            }
            var result = new List<Protocal.TradingInstrument.InstrumentDayOpenCloseParams>();
            foreach (DataRow eachDataRow in ds.Tables["InstrumentDayOpenCloseTime"].Rows)
            {
                Guid instrumentId = (Guid)eachDataRow["InstrumentID"];
                DateTime day = (DateTime)eachDataRow["TradeDay"];
                var openCloseParam = new Protocal.TradingInstrument.InstrumentDayOpenCloseParams()
                {
                

                    TradeDay = day,
                    DayOpenTime = eachDataRow.GetColumn<DateTime?>("DayOpenTime"),
                    DayCloseTime = eachDataRow.GetColumn<DateTime?>("DayCloseTime"),
                    RealValueDate = eachDataRow.GetColumn<DateTime?>("RealValueDate"),
                    TradingSessions = new List<Protocal.TradingInstrument.TradingSession>(),
                    IsTrading = true
                };
                result.Add(openCloseParam);
            }
            foreach (DataRow eachDataRow in ds.Tables["TradingTime"].Rows)
            {
                Guid instrumentId = (Guid)eachDataRow["InstrumentID"];
                DateTime beginTime = (DateTime)eachDataRow["BeginTime"];
                DateTime endTime = (DateTime)eachDataRow["EndTime"];
                var openCloseParam = result.Find(m => m.Id == instrumentId);
                if (openCloseParam == null)
                {
                    Logger.WarnFormat("instrumentId = {0}, B

                }
                else
                {
                    openCloseParam.AddSession(new Protocal.TradingInstrument.TradingSession() { BeginTime = beginTime, EndTime = endTime });
                }
            }
            return result;
        }
    }
    internal sealed class TradingTimeManager
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(TradingTimeManager));
        internal static readonly TradingTimeManager Default = new TradingTimeManager();
        private TradingTimeManager() { }
        internal void Process(Dictionary<InstrumentStatus, List<Guid>> status)
        {
            this.BroadcastInstrumentTradingStatus(status);
            this.HandleInstrumentsDayClose(status);
        }
        private void BroadcastInstrumentTradingStatus(Dictionary<InstrumentStatus, List<Guid>> status)
        {
            var command = MarketCommandFactory.CreateUpdateInstrumentTradingStatusCommand(status);
            Logger.InfoForma
namespace ShopManager.DAL.Concrete.UnitOfWork
    public class UnitOfWork:IUnitOfWork
    {
        protected readonly string _connection;
        protected IEmployeeRepository _employeeRepository;
        protected IProductRepository _productRepository;
        protected IRealizationRepozitory _realizationRepository;
        private ISaleRepository _saleRepository;
        private IStringRepository _stringRepository;
        public UnitOfWork(string connection)
        {
            _connection = connection;
        }
        public IEmployeeRepository EmployeeRepository
        {
            get { return _employeeRepository ?? (_employeeRepository = new EmployeeRepository(_connection)); }
        }
        public IProductRepository ProductRepository
        {
            get { return _productRepository ?? (_productRepository = new ProductRepository(_connection)); }
        }
        public IRealizationRepozitory RealizationRepository
        {
            get { return _realizationRep
namespace GarboDev
    partial class FastArmCore
    {
        #region Delegate Dispatcher
        private void DispatchFunc0()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterLslImmed();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc1()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterLslReg();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc2()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & Bar

            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc3()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterLsrReg();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc4()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterAsrImmed();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc5()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] =

            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc6()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterRorImmed();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc7()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterRorReg();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc8()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] =
namespace Debugger
	public partial class NDebugger
	{
		List<Process> processCollection = new List<Process>();
		
		public event EventHandler<ProcessEventArgs> ProcessStarted;
		public event EventHandler<ProcessEventArgs> ProcessExited;
		
		public IList<Process> Processes {
			get {
				return processCollection.AsReadOnly();
			}
		}
		internal Process GetProcess(ICorDebugProcess corProcess)
		{
			foreach (Process process in Processes) {
				if (process.CorProcess == corProcess) {
					return process;
				}
			}
			return null;
		}
		internal void AddProcess(Process process)
		{
			processCollection.Add(process);
			OnProcessStarted(process);
		}
		internal void RemoveProcess(Process process)
		{
			processCollection.Remove(process);
			OnProcessExited(process);
			if (processCollection.Count == 0) {
				this.MTA2STA.AsyncCall( delegate { this.TerminateDebugger(); } );
			}
		}
		protected virtual void OnProcessStarted(Process process)
		{
			if (ProcessStarted != null) {
				Process
namespace MME
    public partial class AddInstrumentWindow
    {
        private InstrumentData _instrumentData = new InstrumentData();
        public AddInstrumentWindow()
        {
            InitializeComponent();
        }
        private void OkButton_OnClick(object sender, RoutedEventArgs e)
        {
            switch (SelectedItem.Text)
            {
                case "SineWave":
                    _instrumentData.InstrumentFunction = new SineWave();
                    break;
                case "SquareWave":
                    _instrumentData.InstrumentFunction = new SquareWave();
                    break;
                case "TriangleWave":
                    _instrumentData.InstrumentFunction = new TriangleWave();
                    break;
                case "SawtoothWave":
                    _instrumentData.InstrumentFunction = new SawtoothWave();
                    break;
                default:
                    _instrumentData = null;
                
namespace DatabaseLayer.UoW
    public sealed class UnitOfWork : IUnitOfWork
    {
        private readonly DatabaseContext context;
        public static DbContextOptionsBuilder<DatabaseContext> DbContextOptions;
        #region Repositories
        private IGenericRepository<User> userRepository;
        public IGenericRepository<User> UserRepository => userRepository ?? (userRepository = new GenericRepository<User>(context));
        public IGenericRepository<Book> bookRepository;
        public IGenericRepository<Book> BookRepository => bookRepository ?? (bookRepository = new GenericRepository<Book>(context));
        public IGenericRepository<BookProviderClicksLog> bookProviderClicksLogRepository;
        public IGenericRepository<BookProviderClicksLog> BookProviderClicksLogRepository => bookProviderClicksLogRepository ?? (bookProviderClicksLogRepository = new GenericRepository<BookProviderClicksLog>(context));
        public IGenericRepository<Comment> commentRepository;
        

        public IGenericRepository<DegreeProgram> degreeProgramRepository;
        public IGenericRepository<DegreeProgram> DegreeProgramRepository => degreeProgramRepository ?? (degreeProgramRepository = new GenericRepository<DegreeProgram>(context));
        public IGenericRepository<EducationDegree> educationDegreeRepository;
        public IGenericRepository<EducationDegree> EducationDegreeRepository => educationDegreeRepository ?? (educationDegreeRepository = new GenericRepository<EducationDegree>(context));
        public IGenericRepository<Notification> notificationRepository;
        public IGenericRepository<Notification> NotificationRepository => notificationRepository ?? (notificationRepository = new GenericRepository<Notification>(context));
        public IGenericRepository<Rating> ratingRepository;
        public IGenericRepository<Rating> RatingRepository => ratingRepository ?? (ratingRepository = new GenericRepository<Rating>(context));
                
        public I

        public IGenericRepository<School> SchoolRepository => schoolRepository ?? (schoolRepository = new GenericRepository<School>(context));
        public IGenericRepository<SellingBook> sellingBookRepository;
        public IGenericRepository<SellingBook> SellingBookRepository => sellingBookRepository ?? (sellingBookRepository = new GenericRepository<SellingBook>(context));
        public IGenericRepository<Student> studentRepository;
        public IGenericRepository<Student> StudentRepository => studentRepository ?? (studentRepository = new GenericRepository<Student>(context));
        public IGenericRepository<StudyCourse> studyCourseRepository;
        public IGenericRepository<StudyCourse> StudyCourseRepository => studyCourseRepository ?? (studyCourseRepository = new GenericRepository<StudyCourse>(context));
        public IGenericRepository<StudyCourseBook> studyCourseBookRepository;
        public IGenericRepository<StudyCourseBook> StudyCourseBookRepository => studyCourseB
﻿namespace Sean.World
	public struct ChunkCoords
	{
		public ChunkCoords(int x, int z)
		{
			X = x;
			Z = z;
			WorldCoordsX = X * Chunk.CHUNK_SIZE;
			WorldCoordsZ = Z * Chunk.CHUNK_SIZE;
		}
            
		public ChunkCoords(ref Coords coords)
		{
			X = coords.Xblock / Chunk.CHUNK_SIZE;
			Z = coords.Zblock / Chunk.CHUNK_SIZE;
			WorldCoordsX = X * Chunk.CHUNK_SIZE;
			WorldCoordsZ = Z * Chunk.CHUNK_SIZE;
		}
		public readonly int X;
		public readonly int Z;
		public int WorldCoordsX;
		public int WorldCoordsZ;
		public static bool operator ==(ChunkCoords c1, ChunkCoords c2)
		{
			return c1.X == c2.X && c1.Z == c2.Z;
		}
		public static bool operator !=(ChunkCoords c1, ChunkCoords c2)
		{
			return c1.X != c2.X || c1.Z != c2.Z;
		}
		public override bool Equals(object obj)
		{
			return X == ((ChunkCoords)obj).X && Z == ((ChunkCoords)obj).Z;
		}
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
		public override string ToString()
		{
			return string.Forma
namespace TheBall.CORE
    public class DeleteProcessImplementation
    {
        public static Process GetTarget_Process(string processId)
        {
            return Process.RetrieveFromOwnerContent(InformationContext.CurrentOwner, processId);
        }
        public static ProcessContainer GetTarget_OwnerProcessContainer()
        {
            return ProcessContainer.RetrieveFromOwnerContent(InformationContext.CurrentOwner, "default");
        }
        public static void ExecuteMethod_ObtainLockRemoveFromContainerAndDeleteProcess(string processID, Process process, ProcessContainer ownerProcessContainer)
        {
            if (process == null)
            {
                if (ownerProcessContainer != null && ownerProcessContainer.ProcessIDs != null)
                {
                    ownerProcessContainer.ProcessIDs.Remove(processID);
                    ownerProcessContainer.StoreInformation();
                }
            }
            else
            {
               
namespace RiskAnalysisTool.MobileApp.ViewModels
    public class MarketDataListViewModel : ViewModel
    {
        private readonly AsyncCommand<string> _addInstrumentCommand;
        private readonly AsyncCommand<Instrument> _editInstrumentCommand;
        private readonly RelayCommand<Instrument> _removeInstrumentCommand;
        private ObservableCollection<Instrument> _instruments;
        public MarketDataListViewModel()
        {
            _instruments = new ObservableCollection<Instrument>();
            _addInstrumentCommand = new AsyncCommand<string>(AddInstrument);
            _editInstrumentCommand = new AsyncCommand<Instrument>(EditInstrument);
            _removeInstrumentCommand = new RelayCommand<Instrument>(RemoveInstrument);
        }
        public AsyncCommand<string> AddInstrumentCommand
        {
            get { return _addInstrumentCommand; }
        }
        public AsyncCommand<Instrument> EditInstrumentCommand
        {
            get { return _editInstrum

        }
        public ObservableCollection<Instrument> Instruments
        {
            get { return _instruments; }
            set { SetProperty(ref _instruments, value); }
        }
        public RelayCommand<Instrument> RemoveInstrumentCommand
        {
            get { return _removeInstrumentCommand; }
        }
        public async Task AddInstrument(string instrumentType)
        {
            Instrument instrument;
            switch (instrumentType)
            {
                case "Volatility":
                    instrument = await ShowInstrumentDetailPage<ImpliedVolatility, VolatilityDetailViewModel>();
                    break;
                case "Bond":
                    instrument = await ShowInstrumentDetailPage<Bond, BondDetailViewModel>();
                    break;
                case "CDS":
                    instrument = await ShowInstrumentDetailPage<CreditDefaultSwap, CreditDefaultSwapDetailViewModel>();
                    break;
               

                    instrument = await ShowInstrumentDetailPage<Correlation, CorrelationDetailViewModel>();
                    break;
                default:
                    throw new ArgumentException("Invalid instrument type: " + instrumentType, "instrumentType");
            }
            if (instrument != null)
            {
                _instruments.Add(instrument);
            }
        }
        public async Task EditInstrument(Instrument instrument)
        {
            Instrument updated;
            if (instrument.GetType() == typeof(ImpliedVolatility))
            {
                updated = await ShowInstrumentDetailPage<ImpliedVolatility, VolatilityDetailViewModel>((ImpliedVolatility)instrument);
            }
            else if (instrument.GetType() == typeof(Bond))
            {
                updated = await ShowInstrumentDetailPage<Bond, BondDetailViewModel>((Bond)instrument);
            }
            else if (instrument.GetType() == typeof(CreditDefaultS
namespace DAL.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        public ServiceDB context { get; }
        private RoleRepository roleRepository;
        private UserRepository userRepository;
        private CertificateRepository certificateRepository;
        private EmployeeRepository employeeRepository;
        private CustomerRepository customerRepository;
        private TemplateRepository templateRepository;
        private ComponentRepository componentRepository;
        private IndustrialObjectRepository industrialObjectRepository;
        private MaterialRepository materialRepository;
        private EquipmentRepository equipmentRepository;
        private ControlMethodDocumentationRepository controlMethodDocumentationRepository;
        private RequirementDocumentationRepository requirementDocumentationRepository;
        private CertificateLibRepository certificateLibRepository;
        private ControlMethodsLibRepository controlMethodsLibRepository;
     

        private ControlNameRepository controlNameRepository;
        private ControlRepository controlRepository;
        private ImageRepository imageRepository;
        private ImageLibRepository imageLibRepository;
        private JournalRepository journalRepository;
        private ResultRepository resultRepository;
        private WeldJointRepository weldJointRepository;
        private ComponentLibRepository componentLibRepository;
        private SelectedCertificateRepository selectedCertificateRepository;
        private SelectedComponentRepository selectedComponentRepository;
        private SelectedControlNameRepository selectedControlNameRepository;
        private ResultLibRepository resultLibRepository;
        private EquipmentLibRepository equipmentLibRepository;
        private SelectedEquipmentRepository selectedEquipmentRepository;
        private ControlMethodDocumentationLibRepository controlMethodDocumentationLibRepository;
        private SelectedControlMethodDoc

        private RequirementDocumentationLibRepository requirementDocumentationLibRepository;
        private SelectedRequirementDocumentationRepository selectedRequirementDocumentationRepository;
        private EmployeeLibRepository employeeLibRepository;
        private SelectedEmployeeRepository selectedEmployeeRepository;
        public IRoleRepository Roles 
            => roleRepository ?? (roleRepository = new RoleRepository(context));
        public IUserRepository Users
            => userRepository ?? (userRepository = new UserRepository(context));
        public ICertificateRepository Certificates
            => certificateRepository ?? (certificateRepository = new CertificateRepository(context));
        public IEmployeeRepository Employees
            => employeeRepository ?? (employeeRepository = new EmployeeRepository(context));
        public ICustomerRepository Customers
            => customerRepository ?? (customerRepository = new CustomerRepository(context));
     
﻿/*
 * Original author: Vagisha Sharma <vsharma .at. u.washington.edu>,
 *                  MacCoss Lab, Department of Genome Sciences, UW
 *
 * Copyright 2012 University of Washington - Seattle, WA
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace pwiz.SkylineTestA
    [TestClass]
    public class InstrumentInfoUtilTest : AbstractUnitTest
    {
        [TestMethod]
        public void TestParse()
        {
            var instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(null).ToList();
            Assert.AreEq

            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo("").ToList();
            Assert.AreEqual(0, instrumentConfigList.Count());
            var str = "\n\n";
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(str).ToList();
            Assert.AreEqual(0, instrumentConfigList.Count(), str);
            str = "\n" + InstrumentInfoUtil.MODEL;
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(str).ToList();
            Assert.AreEqual(0, instrumentConfigList.Count(), str);
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO1).ToList();
            Assert.AreEqual(0, instrumentConfigList.Count(), INFO1);
            
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO2).ToList();
            Assert.AreEqual(1, instrumentConfigList.Count(), INFO2);
            Assert.AreEqual("MS_TSQ_Vantage", instrumentConfigList[0].Model);
            Assert.AreEqual("", instrumentConfigList[0]

            Assert.AreEqual("", instrumentConfigList[0].Analyzer);
            Assert.AreEqual("", instrumentConfigList[0].Detector);
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO3).ToList();
            Assert.AreEqual(1, instrumentConfigList.Count(), INFO3);
            instrumentConfigList = InstrumentInfoUtil.GetInstrumentInfo(INFO4).ToList();
            Assert.AreEqual(2, instrumentConfigList.Count(), INFO4);
            Assert.AreEqual("MS_TSQ_Vantage", instrumentConfigList[0].Model);
            Assert.AreEqual("MS_LTQ_FT", instrumentConfigList[1].Model);
            Assert.AreEqual("", instrumentConfigList[0].Ionization);
            Assert.AreEqual("MS_ionization_type", instrumentConfigList[1].Ionization);
            Assert.AreEqual("", instrumentConfigList[0].Analyzer);
            Assert.AreEqual("", instrumentConfigList[1].Analyzer);
            Assert.AreEqual("", instrumentConfigList[0].Detector);
            Assert.AreEqual("", instrumen
namespace CreativeSpore.RpgMapEditor
	public class TileChunkPool : MonoBehaviour 
	{
		public const int k_TileChunkWidth = 32;
		public const int k_TileChunkHeight = 32;
		[System.Serializable]
		public class TileChunkLayer
		{
			public GameObject ObjNode;
			public TileChunk[] TileChunks;
		}
		public List<TileChunkLayer> TileChunkLayers = new List<TileChunkLayer>();
		private List<TileChunk> m_tileChunkToBeUpdated = new List<TileChunk>();
		[SerializeField]
		private AutoTileMap m_autoTileMap;
		public void Initialize (AutoTileMap autoTileMap)
		{
			hideFlags = HideFlags.NotEditable;
			m_autoTileMap = autoTileMap;
			foreach( TileChunkLayer tileChunkLayer in TileChunkLayers )
			{
				if( tileChunkLayer.ObjNode != null )
				{
				#if UNITY_EDITOR
					DestroyImmediate(tileChunkLayer.ObjNode);
				#else
					Destroy(tileChunkLayer.ObjNode);
				#endif
				}
			}
			TileChunkLayers.Clear();
			m_tileChunkToBeUpdated.Clear();
		}
		public void MarkUpdatedTile( int tileX, int tileY, 

		{
			TileChunk tileChunk = _GetTileChunk( tileX, tileY, layer );
			if( !m_tileChunkToBeUpdated.Contains(tileChunk) )
			{
				m_tileChunkToBeUpdated.Add( tileChunk );
			}
		}
		public void UpdateChunks()
		{
			while( m_tileChunkToBeUpdated.Count > 0 )
			{
				m_tileChunkToBeUpdated[0].ApplyData();
				m_tileChunkToBeUpdated.RemoveAt(0);
			}
		}
		public void UpdateLayerPositions ()
		{
			for( int i = 0; i < TileChunkLayers.Count; ++i )
			{
				TileChunkLayers[i].ObjNode.transform.position = m_autoTileMap.TileLayerPosition[i];
			}
		}
		private TileChunk _GetTileChunk( int tileX, int tileY, int layer )
		{
			TileChunkLayer chunkLayer = _GetTileChunkLayer( layer );
			int rowTotalChunks = 1 + ((m_autoTileMap.MapTileWidth - 1) / k_TileChunkWidth);
			int chunkIdx = (tileY / k_TileChunkHeight) * rowTotalChunks + (tileX / k_TileChunkWidth);
			TileChunk tileChunk = chunkLayer.TileChunks[chunkIdx];
			if( tileChunk == null )
			{
				int startTileX = tileX - tileX % k_TileChunkWi

				int startTileY = tileY - tileY % k_TileChunkHeight;
				GameObject chunkObj = new GameObject();
				chunkObj.name = "TileChunk"+startTileX+"_"+startTileY;
				chunkObj.transform.parent = chunkLayer.ObjNode.transform;
				chunkObj.hideFlags = HideFlags.NotEditable;
				tileChunk = chunkObj.AddComponent<TileChunk>();
				chunkLayer.TileChunks[chunkIdx] = tileChunk;
				tileChunk.Configure( m_autoTileMap, layer, startTileX, startTileY, k_TileChunkWidth, k_TileChunkHeight );
			}
			return tileChunk;
		}
		private TileChunkLayer _GetTileChunkLayer( int layer )
		{
			return TileChunkLayers.Count > layer? TileChunkLayers[layer] : _CreateTileChunkLayer( layer );
		}
		private TileChunkLayer _CreateTileChunkLayer( int layer )
		{
			int rowTotalChunks = 1 + ((m_autoTileMap.MapTileWidth - 1) / k_TileChunkWidth);
			int colTotalChunks = 1 + ((m_autoTileMap.MapTileHeight - 1) / k_TileChunkHeight);
			int totalChunks = rowTotalChunks * colTotalChunks;
			TileChunkLayer chunkLayer = null;
			
namespace ProjectManagement.Repository.UnitOfWork
    public class UnitOfWork : IUnitOfWork, IDisposable
    {
        private readonly DataContext _context;
        private ICompanyRepository _companyRepository;
        private IProjectRepository _projectRepository;
        private ISprintRepository _sprintRepository;
        private IUserRepository _userRepository;
        private IRoleRepository _roleRepository;
        private IUserRoleRepository _userRoleRepository;
        private IPermissionRepository _permissionRepository;
        private IRolePermissionRepository _rolePermissionRepository;
        private ITaskRepository _taskRepository;
        private ICountryRepository _countryRepository;
        private IStateRepository _stateRepository;
        private IIndustryRepository _industryRepository;
        private ISkilRepository _skilRepository;
        private IDesignationRespository _designationRespository;
        private IDepartmentRepository _departmentRepository;
       

        public UnitOfWork(DataContext context)
        {
            _context = context;
        }
        public ICompanyRepository CompanyRepository
        {
            get { return _companyRepository ?? (_companyRepository = new CompanyRepository(_context)); }
        }
        public IProjectRepository ProjectRepository
        {
            get
            {
                return _projectRepository ?? (_projectRepository = new ProjectRepository(_context));
            }
        }
        public ISprintRepository SprintRepository
        {
            get
            {
                return _sprintRepository ?? (_sprintRepository = new SprintRepository(_context));
            }
        }
        public IUserRepository UserRepository
        {
            get
            {
                return _userRepository ?? (_userRepository = new UserRepository(_context));
            }
        }
        public IRoleRepository RoleRepository
        {
            get
            {
      

            }
        }
        public IUserRoleRepository UserRoleRepository
        {
            get
            {
                return _userRoleRepository ?? (_userRoleRepository = new UserRoleRepository(_context));
            }
        }
        public IPermissionRepository PermissionRepository
        {
            get
            {
                return _permissionRepository ?? (_permissionRepository = new PermissionRepository(_context));
            }
        }
        public IRolePermissionRepository RolePermissionRepository
        {
            get
            {
                return _rolePermissionRepository ?? (_rolePermissionRepository = new RolePermissionRepository(_context));
            }
        }
        public ITaskRepository TaskRepository
        {
            get
            {
                return _taskRepository ?? (_taskRepository = new TaskRepository(_context));
            }
        }
        #region Shailesh
        public ICountryRepository CountryR
namespace DRMFSS.BLL.Services
    public interface IOtherDispatchAllocationService
    {
        bool AddOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        bool DeleteById(int id);
        bool EditOtherDispatchAllocation(OtherDispatchAllocation otherDispatchAllocation);
        OtherDispatchAllocation FindById(int id);
        List<OtherDispatchAllocation> GetAllOtherDispatchAllocation();
        List<OtherDispatchAllocation> FindBy(Expression<Func<OtherDispatchAllocation, bool>> predicate);
        void Save(ViewModels.Dispatch.OtherDispatchAllocationViewModel model);
        OtherDispatchAllocationViewModel GetViewModelByID(Guid otherDispatchAllocationId);
        List<OtherDispatchAllocation> GetAllToCurrentOwnerHubs(UserProfile user);
        List<OtherDispatchAllocation> GetAllToOtherOwnerHubs(UserProfile user);
        List<OtherDispatchAllocationDto> GetCo
namespace Zamin.Repositories
    public class UnitOfWork : UnitOfWorkBase<DataContext>
    {
        private IUsersRepository _usersRepository;
        public IUsersRepository UsersRepository
        {
            get { return _usersRepository ?? (_usersRepository = new UsersRepository(DataContext)); }
        }
        private ICourseRepository _courseRepository;
        public ICourseRepository CourseRepository
        {
            get { return _courseRepository ?? (_courseRepository = new CourseRepository(DataContext)); }
        }
        private ICategoryRepository _categoryRepository;
        public ICategoryRepository CategoryRepository
        {
            get { return _categoryRepository ?? (_categoryRepository = new CategoryRepository(DataContext)); }
        }
        private ITagRepository _tagRepository;
        public ITagRepository TagRepository
        {
            get { return _tagRepository ?? (_tagRepository = new TagRepository(DataContext)); }
        }
        p
namespace LendingLibrary_Library_Tests.MusicSelectionTests
    [TestClass]
    public class ChoralInstrumentPartTests
    {
        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException), "In class ChoralInstrumentPart, constructor.  String argument instrumentName cannot be null.")]
        public void ChoralInstrumentPart_Constructor_StringArgumentInstrumentNameIsNull_ThrowsArgumentNullException()
        {
            ChoralInstrumentPart myChoralInstrumentPart;
            myChoralInstrumentPart = new ChoralInstrumentPart(null, 1, true);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In class ChoralInstrumentPart, constructor.  String argument instrumentName cannot be empty.")]
        public void ChoralInstrumentPart_Constructor_StringArgumentInstrumentNameIsEmpty_ThrowsArgumentException()
        {
            ChoralInstrumentPart myChoralInstrumentPart;
            myChoralInstrumentPart = new ChoralInstrumentPart("", 1, true)

        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In class ChoralInstrumentPart, constructor.  String argument instrumentName cannot be white space.")]
        public void ChoralInstrumentPart_Constructor_StringArgumentInstrumentNameIsWhiteSpace_ThrowsArgumentException()
        {
            ChoralInstrumentPart myChoralInstrumentPart;
            myChoralInstrumentPart = new ChoralInstrumentPart("  ", 1, true);
        }
        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "In class ChoralInstrumentPart, constructor.  Int argument numberOfCopies cannot be less than zero.")]
        public void ChoralInstrumentPart_Constructor_IntArgumentNumberOfCopiesLessThanZero_ThrowsArgumentException()
        {
            ChoralInstrumentPart myChoralInstrumentPart;
            myChoralInstrumentPart = new ChoralInstrumentPart("Flute", -1, true);
        }
        [TestMethod]
        public void ChoralInstrumentPart_Constructor_ClassFie

        {
            ChoralInstrumentPart myChoralInstrumentPart;
            myChoralInstrumentPart = new ChoralInstrumentPart("Flute", 8, true);
            Assert.AreEqual(true, myChoralInstrumentPart.IsInChoralScore);
        }
        [TestMethod]
        public void ChoralInstrumentPart_Equals_ArgumentIsEqual()
        {
            ChoralInstrumentPart myChoralInstrumentPart;
            ChoralInstrumentPart myChoralInstrumentPart2;
            myChoralInstrumentPart = new ChoralInstrumentPart("Flute", 8, true);
            myChoralInstrumentPart2 = new ChoralInstrumentPart("Flute", 8, true);
            Assert.AreEqual(true, myChoralInstrumentPart.Equals(myChoralInstrumentPart2));
        }
        [TestMethod]
        public void ChoralInstrumentPart_Equals_ArgumentIsNotEqual()
        {
            ChoralInstrumentPart myChoralInstrumentPart;
            ChoralInstrumentPart myChoralInstrumentPart2;
            myChoralInstrumentPart = new ChoralInstrumentPart("Flute", 8, t
namespace LQT.Core.Domain
    public class SiteInstrument
    {
        #region Member Variables
        private int _id;
        private Instrument _instrument;
        private ForlabSite _site;
        private int _quantity;
        private decimal _testRunPercentage;
        #endregion
        #region Constructors
        public SiteInstrument() 
        {
            this._id = -1;
        }
        #endregion
        #region Public Properties
        public int Id
        {
            get { return _id; }
            set { _id = value; }
        }
        public Instrument Instrument
        {
            get { return _instrument; }
            set { _instrument = value; }
        }
        public ForlabSite Site
        {
            get { return _site; }
            set { _site = value; }
        }
        public int Quantity
        {
            get { return _quantity; }
            set { _quantity = value; }
        }
        public decimal TestRunPercentage
        {
       
namespace Data.Infrastructure
    public interface IUnitOfWork
    {
        void Commit();
         ILocalitéRepository LocalitéRepository { get; }
        IBureauRepository BureauRepository { get; }
        IRegionRepository RegionRepository { get; }
     
        IContratRepository ContratRepository { get; }
        IContratBienRepository ContratBienRepository { get; }
        IAchatRepository AchatRepository { get; }
        IFournisseurRepository FournisseurRepository { get; }
        IBatimentRepository BatimentRepository { get; }
        IInventaireRepository InventaireRepository { get; }
        
        IServiceRepository ServiceRepository { get; }
        IParc_autoRepository Parc_autoRepository { get; }
        IGouvernoratRepository GouvernoratRepository { get; }
       
        IVehiculeRepository VehiculeRepository { get; }
        ICategorieRepository CategorieRepository { get; }
        IEtageRepository EtageRepository { get; }
        IPersonnelRepository PersonnelRepo
public class InstrumentModel : StudioElement {
    public string instrumentName;
    private InstrumentController controller;
    public enum InstroTypes
    {
        LeadVocal, BackupVocal, AcousticGuitar, ElectricGuitar, 
        Piano, Violin, Saxophone, Flute, Cello, Clarinet, Trumpet, Harp,
        Drums, Kick, Snare, Tom, HiHat, Cymbal
    }
    public InstroTypes type;
    public Color color;
    public AudioClip clip;
    private InstrumentType instrumentType;
    private Instrument instrument;
    void Start () {
        controller = GetComponent<InstrumentController>();
        instrumentType = new InstrumentType(type.ToString());
        color = instrumentType.DefaultColor;
        instrument = new Instrument(instrumentName, instrumentType, color, clip);
        controller.SetInstrumentProperties(instrument);
    }
	void Update () {
		
	}
    public Instrument GetCurrentInstrumentValue()
    {
        Debug.Log("what is instro???: " + instrument);
        return instrument;
namespace ToracLibrary.UnitTest.Core
    public class InvokeTest
    {
        #region Framework
        private class InvokeRegularMethod
        {
            #region Constants
            public const int InvokeStaticMethodResult = 5;
            #endregion
            #region Static Methods
            public static int InvokeStaticMethod()
            {
                return InvokeStaticMethodResult;
            }
            public static int InvokeStaticMethodWithParameter(int BaseNumber)
            {
                return BaseNumber + InvokeStaticMethodResult;
            }
            #endregion
            #region Instance Methods
            public int InvokeInstanceMethod()
            {
                return InvokeStaticMethodResult;
            }
            public static int InvokeInstanceMethodWithParameter(int BaseNumber)
            {
                return BaseNumber + InvokeStaticMethodResult;
            }
            #endregion
            #region Static Gener

            public static int InvokeStaticGenericMethodWithNoParameter<T>()
            {
                return InvokeStaticMethodResult;
            }
            public static int InvokeStaticGenericMethodWithParameters<T>(int BaseNumber)
            {
                return BaseNumber + InvokeStaticMethodResult;
            }
            public static int InvokeStaticGenericMethodWithGenericParameters<T>(int BaseNumber, IEnumerable<T> GenericParameter)
            {
                return BaseNumber + InvokeStaticMethodResult;
            }
            public static int InvokeStaticGenericMethodPassingInT<T>(int BaseNumber, T Item)
                where T : TestGenericClass
            {
                return BaseNumber + Item.Id;
            }
            #endregion
            #region Instance Generic Methods
            public int InvokeInstanceGenericMethodWithNoParameter<T>()
            {
                return InvokeStaticMethodResult;
            }
            public int 

            {
                return BaseNumber + InvokeStaticMethodResult;
            }
            public int InvokeInstanceGenericMethodWithGenericParameters<T>(int BaseNumber, IEnumerable<T> GenericParameter)
            {
                return BaseNumber + InvokeStaticMethodResult;
            }
            public int InvokeInstanceGenericMethodPassingInT<T>(int BaseNumber, T Item)
             where T : TestGenericClass
            {
                return BaseNumber + Item.Id;
            }
            #endregion
        }
        private class TestGenericClass
        {
            public int Id { get { return InvokeRegularMethod.InvokeStaticMethodResult; } }
        }
        #endregion
        #region Unit Tests
        #region Static Methods
        [Fact]
        public void InvokeRegularStaticMethodWithNoParametersTest1()
        {
            Assert.Equal(InvokeRegularMethod.InvokeStaticMethodResult, new NonGenericStaticMethodFinder(typeof(InvokeRegularMethod), nameof(
namespace Umbra.Utilities.Threading
	public class SetupThread
	{
		ChunkQueue LoadQueue;
		ChunkQueue GenerationQueue;
		ChunkQueue VegetationQueue;
		ChunkQueue BuildQueue;
		ChunkQueue SetupQueue;
		ChunkQueue UnloadQueue;
		public SetupThread()
		{
			LoadQueue = new ChunkQueue();
			GenerationQueue = new ChunkQueue();
			VegetationQueue = new ChunkQueue();
			BuildQueue = new ChunkQueue();
			SetupQueue = new ChunkQueue();
			UnloadQueue = new ChunkQueue();
		}
		public void AddToLoad(Chunk chunk)
		{
			LoadQueue.Enqueue(chunk);
		}
		public void AddToGeneration(Chunk chunk)
		{
			GenerationQueue.Enqueue(chunk);
		}
		public void AddToVegetation(Chunk chunk)
		{
			VegetationQueue.Enqueue(chunk);
		}
		public void AddToBuild(Chunk chunk)
		{
			BuildQueue.Enqueue(chunk);
		}
		public void AddToSetup(Chunk chunk)
		{
			SetupQueue.AddSorted(chunk);
		}
		public void AddToUnload(Chunk chunk)
		{
			if (!LoadQueue.Contains(chunk))
			{
				UnloadQueue.Enqueue(chunk);
			}
			LoadQue

			GenerationQueue.Remove(chunk);
			VegetationQueue.Remove(chunk);
			BuildQueue.Remove(chunk);
			SetupQueue.Remove(chunk);
			chunk.WillBeUnloaded = true;
		}
		public void Run()
		{
			Chunk currentChunk;
			while (true)
			{
				if (!Variables.Game.IsInitialized)
				{
					continue;
				}
				if (UnloadQueue.Count > 0)
				{
					currentChunk = UnloadQueue.Dequeue();
					if (currentChunk == null)
					{
						continue;
					}
					if (Constants.World.SaveDynamicWorld)
					{
						ChunkManager.StoreChunkImmediate(currentChunk);
					}
					else
					{
						currentChunk = null;
					}
					Console.Write("UnloadQueue: " + UnloadQueue.Count);
					LoadQueue.Remove(currentChunk);
					GenerationQueue.Remove(currentChunk);
					SetupQueue.Remove(currentChunk);
				}
				else if (LoadQueue.Count > 0)
				{
					currentChunk = LoadQueue.Dequeue();
					if (currentChunk == null)
					{
						continue;
					}
					ChunkManager.LoadChunkImmediate(currentChunk);
					currentChunk.BuildOc

					currentChunk.HasData = true;
					Console.Write("LoadQueue: " + LoadQueue.Count);
					if (SetupQueue.Contains(currentChunk))
					{
						SetupQueue.Remove(currentChunk);
						SetupQueue.Enqueue(currentChunk);
					}
					else
					{
						SetupQueue.Enqueue(currentChunk);
					}
				}
				else if (GenerationQueue.Count > 0)
				{
					currentChunk = GenerationQueue.Dequeue();
					if (currentChunk == null)
					{
						continue;
					}
					TerrainGenerator.SetChunkTerrain(currentChunk);
					Console.Write("GenerationQueue: " + GenerationQueue.Count);
					if (VegetationQueue.Contains(currentChunk))
					{
						VegetationQueue.Remove(currentChunk);
						VegetationQueue.Enqueue(currentChunk);
					}
					else
					{
						AddToVegetation(currentChunk);
					}
				}
				else if (VegetationQueue.Count > 0)
				{
					currentChunk = VegetationQueue.Dequeue();
					if (currentChunk == null)
					{
						continue;
					}
					Vegetation.Vegetate(currentChunk);
					Console.Write("
namespace KiddyShop.Data.Repositories
    public class UnitOfWork : IUnitOfWork
    {
        private IDbFactory _dbFactory;
        private IKSDataContext _dbContext;
        private IAppClaimRepository _appClaimRepository;
        private IAppFunctionRepository _appFunctionRepository;
        private IRoleGroupRepository _roleGroupRepository;
        private ICountryRepository _countryRepository;
        private ITimezoneRepository _timezoneRepository;
        private IUserAttachmentRepository _userAttachmentRepository;
        private IProfileRepository _profileRepository;
        private IAccountRepository _accountRepository;
        private ITeacherRepository _teacherRepository;
        private IPostCategoryRepository _postCategoryRepository;
        private IMessagingDataMappingRepository _messagingDataMappingRepository;
        private IMessagingMessageRepository _messagingMessageRepository;
        private IMessagingTemplateContentRepository _messagingTemplateContentRepository;

        private IMessagingTemplateRepository _messagingTemplateRepository;
        private IMessagingTypeRepository _messagingTypeRepository;
        public UnitOfWork()
        {
            this._dbFactory = new DbFactory();
            _dbContext = _dbFactory.Init();
        }
        public UnitOfWork(IKSDataContext context)
        {
            _dbContext = context;
        }
        public int SaveChanges()
        {
            return _dbContext.SaveChanges();
        }
        public IAppClaimRepository AppClaimRepository => _appClaimRepository ?? (_appClaimRepository = new AppClaimRepository(_dbContext));
        public IAppFunctionRepository AppFunctionRepository => _appFunctionRepository ?? (_appFunctionRepository = new AppFunctionRepository(_dbContext));
        public IRoleGroupRepository RoleGroupRepository => _roleGroupRepository ?? (_roleGroupRepository = new RoleGroupRepository(_dbContext));
        public ICountryRepository CountryRepository => _countryRepository ??

        public ITimezoneRepository TimezoneRepository => _timezoneRepository ?? (_timezoneRepository = new TimezoneRepository(_dbContext));
        public IUserAttachmentRepository UserAttachmentRepository => _userAttachmentRepository ?? (_userAttachmentRepository = new UserAttachmentRepository(_dbContext));
        public IProfileRepository ProfileRepository => _profileRepository ?? (_profileRepository = new ProfileRepository(_dbContext));
        public IAccountRepository AccountRepository => _accountRepository ?? (_accountRepository = new AccountRepository(_dbContext));
        public ITeacherRepository TeacherRepository => _teacherRepository ?? (_teacherRepository = new TeacherRepository(_dbContext));
        public IPostCategoryRepository PostCategoryRepository => _postCategoryRepository ?? (_postCategoryRepository = new PostCategoryRepository(_dbContext));
        public IMessagingDataMappingRepository MessagingDataMappingRepository => _messagingDataMappingRepository ?? (_messag
public class TerrainGen
    float stoneBaseHeight = -24;
    float stoneBaseNoise = 0.05f;
    float stoneBaseNoiseHeight = 4;
    float stoneMountainHeight = 48;
    float stoneMountainFrequency = 0.008f;
    float stoneMinHeight = -12;
    float dirtBaseHeight = 1;
    float dirtNoise = 0.04f;
    float dirtNoiseHeight = 3;
    float caveFrequency = 0.025f;
    int caveSize = 7;
    public Chunk ChunkGen(Chunk chunk)
    {
        for (int x = chunk.pos.x - 3; x < chunk.pos.x + Chunk.chunkSize + 3; x++)
        {
            for (int z = chunk.pos.z - 3; z < chunk.pos.z + Chunk.chunkSize + 3; z++)
            {
                chunk = ChunkColumnGen(chunk, x, z);
            }
        }
        return chunk;
    }
    public static int GetNoise(int x, int y, int z, float scale, int max)
    {
        return Mathf.FloorToInt((Noise.Generate(x * scale, y * scale, z * scale) + 1f) * (max / 2f));
    }
    public Chunk ChunkColumnGen(Chunk chunk, int x, int z)
    {
        int stoneHeig

        stoneHeight += GetNoise(x, 0, z, stoneMountainFrequency, Mathf.FloorToInt(stoneMountainHeight));
        if (stoneHeight < stoneMinHeight)
            stoneHeight = Mathf.FloorToInt(stoneMinHeight);
        stoneHeight += GetNoise(x, 0, z, stoneBaseNoise, Mathf.FloorToInt(stoneBaseNoiseHeight));
        int dirtHeight = stoneHeight + Mathf.FloorToInt(dirtBaseHeight);
        dirtHeight += GetNoise(x, 50, z, dirtNoise, Mathf.FloorToInt(dirtNoiseHeight));
        for (int y = chunk.pos.y - 8; y < chunk.pos.y + Chunk.chunkSize; y++)
        {
            {
                if(Random.Range(0, 4) >= 1)
                    SetBlock(x, y, z, new Block(), chunk);
                else
                    SetBlock(x, y, z, new BlockCoal(), chunk);
            }
            else if (y <= dirtHeight && caveSize < caveChance)
            {
                SetBlock(x, y, z, new BlockGrass(), chunk);
                if (y == dirtHeight && GetNoise(x, 0, z, treeFrequency, 100) < treeDensity)
 

            }
            else
            {
                SetBlock(x, y, z, new BlockAir(), chunk);
            }
        }
        return chunk;
    }
    public static void SetBlock(int x, int y, int z, Block block, Chunk chunk, bool replaceBlocks = false)
    {
        x -= chunk.pos.x;
        y -= chunk.pos.y;
        z -= chunk.pos.z;
        if (Chunk.InRange(x) && Chunk.InRange(y) && Chunk.InRange(z))
        {
            if (replaceBlocks || chunk.blocks[x, y, z] == null)
                chunk.SetBlock(x, y, z, block);
        }
    }
    float treeFrequency = 0.2f;
    int treeDensity = 3;
    void CreateTree(int x, int y, int z, Chunk chunk)
    {
        int leavesHeight = Random.Range(4, 6);
        
        for (int xi = -2; xi <= 2; xi++)
        {
            for (int yi = 4; yi <= 4 + leavesHeight; yi++)
            {
                for (int zi = -2; zi <= 2; zi++)
                {
                    SetBlock(x + xi, y + yi, z + zi, new BlockLeaves(), chunk, tr
namespace RicksApp
    class Inventory
    {
        readonly List<Instrument> _inventory;
        public Inventory()
        {
            _inventory = new List<Instrument>();
        }
        public void AddInstrument(Instrument instrument)
        {
            _inventory.Add(instrument);
        }
        public Instrument GetInstrument(string serialNumber)
        {
            foreach (var instrument in _inventory)
            {
                if (instrument.SerialNumber == serialNumber)
                {
                    return instrument;
                }
            }
            return null;
        }
        public List<Instrument> SearchInstrument(InstrumentSpec searchedSpec)
        {
            var matchingInstrument = new List<Instrument>();
            foreach (var instrument in _inventory)
            {
                if(instrument.Spec.CompareSpecWith(searchedSpec))
                matchingInstrument.Add(instrument);
            }
            return matchingIn
namespace NXKit.XForms
    [SerializableAnnotation]
    public class UIBindingState :
        IAttributeSerializableAnnotation
    {
        XName dataType;
        bool relevant = true;
        bool readOnly = false;
        bool required = false;
        bool valid = true;
        string value = "";
        bool dispatchValueChanged;
        bool dispatchReadOnly;
        bool dispatchReadWrite;
        bool dispatchRequired;
        bool dispatchOptional;
        bool dispatchEnabled;
        bool dispatchDisabled;
        bool dispatchValid;
        bool dispatchInvalid;
        public string Value
        {
            get { return value; }
            set { this.value = value; }
        }
        public bool DispatchValueChanged
        {
            get { return dispatchValueChanged; }
            set { dispatchValueChanged = value; }
        }
        public XName DataType
        {
            get { return dataType; }
            set { dataType = value; }
        }
        pub

        {
            get { return relevant; }
            set { relevant = value; }
        }
        public bool DispatchEnabled
        {
            get { return dispatchEnabled; }
            set { dispatchEnabled = value; if (dispatchEnabled) dispatchDisabled = false; }
        }
        public bool DispatchDisabled
        {
            get { return dispatchDisabled; }
            set { dispatchDisabled = value; if (dispatchDisabled) dispatchEnabled = false; }
        }
        public bool ReadOnly
        {
            get { return readOnly; }
            set { readOnly = value; }
        }
        public bool DispatchReadOnly
        {
            get { return dispatchReadOnly; }
            set { dispatchReadOnly = value; if (dispatchReadOnly) dispatchReadWrite = false; }
        }
        public bool DispatchReadWrite
        {
            get { return dispatchReadWrite; }
            set { dispatchReadWrite = value; if (dispatchReadWrite) dispatchReadOnly = false; }
      

        public bool Required
        {
            get { return required; }
            set { required = value; }
        }
        public bool DispatchRequired
        {
            get { return dispatchRequired; }
            set { dispatchRequired = value; if (dispatchRequired) dispatchOptional = false; }
        }
        public bool DispatchOptional
        {
            get { return dispatchOptional; }
            set { dispatchOptional = value; if (dispatchOptional) dispatchRequired = false; }
        }
        public bool Valid
        {
            get { return valid; }
            set { valid = value; }
        }
        public bool DispatchValid
        {
            get { return dispatchValid; }
            set { dispatchValid = value; if (dispatchValid) dispatchInvalid = false; }
        }
        public bool DispatchInvalid
        {
            get { return dispatchInvalid; }
            set { dispatchInvalid = value; if (dispatchInvalid) dispatchValid = false; }
      
namespace ProjetPhoneDaveMuret.Model
    class Instrument
    {
        private int idInstrument;
        public int IdInstrument
        {
            get { return idInstrument; }
            set { idInstrument = value; }
        }
        private Photo photoInstrument;
        public Photo PhotoInstrument
        {
            get { return photoInstrument; }
            set { photoInstrument = value; }
        }
        private String nom;
        public String Nom
        {
            get { return nom; }
            set
            { nom = value;}
        }
        private String description;
        public String Description
        {
            get { return description; }
            set { description = value; }
        }
        private String son;
        public String Son
        {
            get { return son; }
            set { son = value; }
        }
        private Categorie categorieInstrument;
        public Categorie CategorieInstrument
        {
            get { re
public class Planet : MonoBehaviour {
	public static int worldSize = 8;
	public GameObject chunkPrefab;
	public Dictionary<Vector3, Chunk> chunks = new Dictionary<Vector3, Chunk>(); 
	public ThreadManager manager;
	void Start () {
		int threads = SystemInfo.processorCount - 2;
		manager = new ThreadManager (4);
		for (int x=-worldSize; x<worldSize; x++){
			for (int y=-worldSize; y<worldSize; y++){
				for (int z=-worldSize; z<worldSize; z++){
					CreateChunk(x*Chunk.size, y*Chunk.size, z*Chunk.size);
				}
			}
		}
	}
	void Update () {
		if (Input.GetButtonDown ("Fire1")) {
			manager.Clear();
		}
		if (Input.GetButtonDown ("Fire2")) {
			Debug.Log ("Coda: "+manager.GetWaitingThreads());
			Debug.Log("Processi attivi: "+manager.GetRunningThreads());
		}
	}
	public void CreateChunk(int x, int y, int z){
		Vector3 chunkPos = new Vector3 (x, y, z);
		GameObject newChunkObject = Instantiate(chunkPrefab, Vector3.zero, Quaternion.Euler(Vector3.zero)) as GameObject;
		newChunkObject.transfo
namespace MiNET.Utils
	public struct ChunkCoordinates : IEquatable<ChunkCoordinates>
	{
		public int X, Z;
		public ChunkCoordinates(int value)
		{
			X = Z = value;
		}
		public ChunkCoordinates(int x, int z)
		{
			X = x;
			Z = z;
		}
		public ChunkCoordinates(ChunkCoordinates v)
		{
			X = v.X;
			Z = v.Z;
		}
		public ChunkCoordinates(PlayerLocation location)
		{
			X = ((int)Math.Floor(location.X)) >> 4;
			Z = ((int)Math.Floor(location.Z)) >> 4;
		}
		public override string ToString()
		{
			return string.Format("<{0},{1}>", X, Z);
		}
		#region Math
		public double DistanceTo(ChunkCoordinates other)
		{
			return Math.Sqrt(Square(other.X - X) +
			                 Square(other.Z - Z));
		}
		private int Square(int num)
		{
			return num*num;
		}
		public double Distance
		{
			get { return DistanceTo(Zero); }
		}
		public static ChunkCoordinates Min(ChunkCoordinates value1, ChunkCoordinates value2)
		{
			return new ChunkCoordinates(
				Math.Min(value1.X, value2.X),
				Math.M

				);
		}
		public static ChunkCoordinates Max(ChunkCoordinates value1, ChunkCoordinates value2)
		{
			return new ChunkCoordinates(
				Math.Max(value1.X, value2.X),
				Math.Max(value1.Z, value2.Z)
				);
		}
		#endregion
		#region Operators
		public static bool operator !=(ChunkCoordinates a, ChunkCoordinates b)
		{
			return !a.Equals(b);
		}
		public static bool operator ==(ChunkCoordinates a, ChunkCoordinates b)
		{
			return a.Equals(b);
		}
		public static ChunkCoordinates operator +(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X + b.X, a.Z + b.Z);
		}
		public static ChunkCoordinates operator -(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X - b.X, a.Z - b.Z);
		}
		public static ChunkCoordinates operator -(ChunkCoordinates a)
		{
			return new ChunkCoordinates(
				-a.X,
				-a.Z);
		}
		public static ChunkCoordinates operator *(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X*b.X, 

		}
		public static ChunkCoordinates operator /(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X/b.X, a.Z/b.Z);
		}
		public static ChunkCoordinates operator %(ChunkCoordinates a, ChunkCoordinates b)
		{
			return new ChunkCoordinates(a.X%b.X, a.Z%b.Z);
		}
		public static ChunkCoordinates operator +(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X + b, a.Z + b);
		}
		public static ChunkCoordinates operator -(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X - b, a.Z - b);
		}
		public static ChunkCoordinates operator *(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X*b, a.Z*b);
		}
		public static ChunkCoordinates operator /(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X/b, a.Z/b);
		}
		public static ChunkCoordinates operator %(ChunkCoordinates a, int b)
		{
			return new ChunkCoordinates(a.X%b, a.Z%b);
		}
		public static ChunkCoordinates operator +(int a, ChunkCoordinates b)
		{
			
namespace PricePublisher.ViewModels
    public class PriceHistoryViewModel: ModelBase, IDisposable
    {
        ObservableCollection<InstrumentPriceHistory> _priceHistory;
        IObservable<KeyValuePair<string, InstrumentPriceUpdate[]>> _priceInstrumentHistoryObservable;
        IDisposable priceInstrumentHistorySubscription;
        private readonly TaskFactory _instrumentUpdaterTaskFactory;
        public ObservableCollection<InstrumentPriceHistory> PriceHistory
        {
            get
            {
                if (_priceHistory == null)
                {
                    _priceHistory = new ObservableCollection<InstrumentPriceHistory>();
                }
                OnPropertyChanged("PriceHistory");
                return _priceHistory;
            }
            set
            {
                _priceHistory = value;
                OnPropertyChanged("PriceHistory");
            }
        }
        public PriceHistoryViewModel(IObservable<KeyValuePair<string, Inst

        {
            this._priceInstrumentHistoryObservable = priceInstrumentHistoryObservable;
            _instrumentUpdaterTaskFactory = new TaskFactory(TaskScheduler.FromCurrentSynchronizationContext());
            priceInstrumentHistorySubscription = _priceInstrumentHistoryObservable
                .Where(x=>x.Key == instrument)
                .Subscribe(new System.Reactive.AnonymousObserver<KeyValuePair<string, InstrumentPriceUpdate[]>>(items =>
            {
                _instrumentUpdaterTaskFactory.StartNew(() => {
                    PriceHistory.Clear();
                    foreach (var item in items.Value.Select(x => new InstrumentPriceHistory { InstrumentName = x.Instrument, Price = x.Price }))
                    {
                        PriceHistory.Add(item);
                    }
                });
            }));
        }
        public void Dispose()
        {
            if (priceInstrumentHistorySubscription != null) { priceInstrumentHistorySubscription
public class AudienceBehaviour : MonoBehaviour {
    const string instrumentPool = "Active Instrument Pool";
    
    
    
	Animator rootAnimator;
    void Start () {
		rootAnimator = this.gameObject.transform.parent.gameObject.GetComponent<Animator> ();
	}
	void Update () {
	    if(assignedInstrumentScript)
        {
            Debug.Log("audience loop update");
            if (assignedInstrumentScript.audioSource)
            {
                if (assignedInstrumentScript.audioSource.gameObject.activeSelf
                && assignedInstrumentScript.audioSource.volume > 0.1
                && assignedInstrumentScript.isPlaying())
                {
                    Debug.Log("audience animator set active true");
					rootAnimator.enabled = true;
                }
                else
                {
                    Debug.Log("audience animater set active false");
					rootAnimator.enabled= false;
                }
            }
        }
	}
	public void setAssignedInstrument
namespace GarboDev
    partial class FastArmCore
    {
        #region Delegate Dispatcher
        private void DispatchFunc0()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterLslImmed();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc1()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterLslReg();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc2()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & Bar

            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc3()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterLsrReg();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc4()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterAsrImmed();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc5()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] =

            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc6()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterRorImmed();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc7()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] = rn & BarrelShifterRorReg();
            if (rd == 15)
            {
                this.FlushQueue();
            }
        }
        private void DispatchFunc8()
        {
            uint rn, rd;
            rn = registers[(this.curInstruction >> 16) & 0xF];
            rd = (this.curInstruction >> 12) & 0xF;
            registers[rd] =
namespace VoxEngine.Managers
    public class SceneChunkManager : GameComponent
    {
        private static ConcurrentDictionary<Vector3, Chunk> _chunks = new ConcurrentDictionary<Vector3, Chunk>();
        public static ConcurrentDictionary<Vector3, Chunk> Chunks
        {
            get { return _chunks; }
        }
        private static bool _initialized = false;
        public static bool Initialized
        {
            get { return _initialized; }
        }
        private static Perlin _perlin;
        public static Perlin Perlin
        {
            get { return _perlin; }
        }
        private static byte _chunkSize;
        public static byte ChunkSize
        {
            get { return _chunkSize; }
        }
        #region Threaded Chunk Management
        #endregion
        private static List<Vector3> _dirtyVoxels = new List<Vector3>();
        public static List<Vector3> DirtyVoxels
        {
            get { return _dirtyVoxels; }
            set { _dirtyVoxe

        }
        
        public SceneChunkManager(Game game, byte chunkSize) : base(game)
        {
            _chunkSize = chunkSize;
            Enabled = true;
        }
        public override void Initialize()
        {
            base.Initialize();
            _perlin = new Perlin();
            _perlin.Frequency = 0.008f;
            _perlin.Lacunarity = 1f;
            _perlin.NoiseQuality = NoiseQuality.Standard;
            _perlin.OctaveCount = 1;
            _perlin.Persistence = 0.1f;
            _perlin.Seed = 100;
            ThreadManager.CreateThread("ChunkManager", ManageChunks);
            int meshThreads = 4;
            for(int i=0;i<meshThreads;i++)
                ThreadManager.CreateThread("ChunkMesh"+i, ManageChunkMeshing);
            ThreadManager.CreateThread("PriorityChunkMesh", ManagePriorityChunkMeshing);
            _initialized = true;
        }
        private static BlockingCollection<Tuple<Action<object>, object>> _chunkManagerEventQueue = new 

        private static List<Tuple<Action<object>, object>> _chunkManagerEventList = new List<Tuple<Action<object>, object>>();
        private static BlockingCollection<Action> _chunkManagerMeshQueue = new BlockingCollection<Action>();
        public static List<Action> _chunkManagerMeshList = new List<Action>();
        private static BlockingCollection<Action> _chunkManagerPriorityMeshQueue = new BlockingCollection<Action>();
        public static List<Action> _chunkManagerPriorityMeshList = new List<Action>();
        void ManageChunkMeshing()
        {
            while (true)
                foreach (var workItem in _chunkManagerMeshQueue.GetConsumingEnumerable())
                    workItem();
        }
        void ManagePriorityChunkMeshing()
        {
            while (true)
                foreach (var workItem in _chunkManagerPriorityMeshQueue.GetConsumingEnumerable())
                    workItem();
        }
        void ManageChunks()
        {
            while (true)
public class SimpleWorld : MonoBehaviour
    public SimpleChunkTextureDictionary textureDict;
    public Dictionary<WorldPos, SimpleChunk> simpleChunks = new Dictionary<WorldPos, SimpleChunk>();
    public GameObject simpleChunkPrefab;
    public string worldName = "simple_world";
    public void CreateSimpleChunk(int x, int y, int z)
    {
        WorldPos worldPos = new WorldPos(x, y, z);
        GameObject newSimpleChunkObject = Instantiate(
                        simpleChunkPrefab, new Vector3(x, y, z),
                        Quaternion.Euler(Vector3.zero)
                    ) as GameObject;
        SimpleChunk newSimpleChunk = newSimpleChunkObject.GetComponent<SimpleChunk>();
        newSimpleChunk.pos = worldPos;
        newSimpleChunk.simpleWorld = this;
        simpleChunks.Add(worldPos, newSimpleChunk);
        var terrainGen = new TerrainGen();
        newSimpleChunk = terrainGen.SimpleChunkGen(newSimpleChunk);
        if(newSimpleChunk.simpleChunkType == SimpleChunkType.A

        newSimpleChunkObject.GetComponent<Renderer>().material.mainTexture = textureDict.textDict[newSimpleChunk.simpleChunkType];
    }
    public void DestroySimpleChunk(int x, int y, int z)
    {
        SimpleChunk simpleChunk = null;
        if (simpleChunks.TryGetValue(new WorldPos(x, y, z), out simpleChunk))
        {
            Object.Destroy(simpleChunk.gameObject);
            simpleChunks.Remove(new WorldPos(x, y, z));
        }
    }
    public SimpleChunk GetSimpleChunk(int x, int y, int z)
    {
        WorldPos pos = new WorldPos();
        float multiple = SimpleChunk.chunkSize;
        pos.x = Mathf.FloorToInt(x / multiple) * SimpleChunk.chunkSize;
        pos.y = Mathf.FloorToInt(y / multiple) * SimpleChunk.chunkSize;
        pos.z = Mathf.FloorToInt(z / multiple) * SimpleChunk.chunkSize;
        SimpleChunk containerSimpleChunk = null;
        simpleChunks.TryGetValue(pos, out containerSimpleChunk);
        return containerSimpleChunk;
    }
    public void SetSimp
namespace GameStore.DAL.UnitOfWorks
    public class UnitOfWorks : IUnitOfWorks
    {
        private readonly EfGameStoreContext _context = new EfGameStoreContext();
        private readonly EfNorthwindContext _northwindContext = new EfNorthwindContext();
        private IBanRepository _banRepository;
        private IBasketDetailsRepository _basketDetailsRepository;
        private IBasketRepository _basketRepository;
        private ICommentRepository _commentRepository;
        private IGameRepository _gameRepository;
        private IGenreRepository _genreRepository;
        private IOrderDetailsRepository _orderDetailsRepository;
        private IOrderRepository _orderRepository;
        private IPlatformTypeRepository _platformRepository;
        private IPublisherRepository _publisherRepository;
        private IRoleRepository _roleRepository;
        private IShipperRepository _shipperRepository;
        private IStatisticRepository _statisticRepository;
        private IUserR

        public IGameRepository GameRepository
        {
            get
            {
                return _gameRepository ?? 
                    (_gameRepository = new GameSynchronizedRepository(_context,_northwindContext));
            }
        }
        public ICommentRepository CommentRepository
        {
            get { return _commentRepository ?? (_commentRepository = new CommentRepository(_context)); }
        }
        public IGenreRepository GenreRepository
        {
            get
            {
                return _genreRepository ??
                       (_genreRepository = new GenreSynchronizedRepository(_context, _northwindContext));
            }
        }
        public IPlatformTypeRepository PlatformTypeRepository
        {
            get { return _platformRepository ?? (_platformRepository = new PlatformTypeRepository(_context)); }
        }
        public IPublisherRepository PublisherRepository
        {
            get
            {
                re

                       (_publisherRepository = new PublisherSynchronizedRepository(_context, _northwindContext));
            }
        }
        public IOrderRepository OrderRepository
        {
            get
            {
                return _orderRepository ??
                       (_orderRepository = new OrderSynchronizedRepository(_context, _northwindContext));
            }
        }
        public IOrderDetailsRepository OrderDetailsRepository
        {
            get { return _orderDetailsRepository ?? (_orderDetailsRepository = new OrderDetailsRepository(_context)); }
        }
        public IBasketRepository BasketRepository
        {
            get { return _basketRepository ?? (_basketRepository = new BasketRepository(_context)); }
        }
        public IBasketDetailsRepository BasketDetailsRepository
        {
            get
            {
                return _basketDetailsRepository ?? (_basketDetailsRepository = new BasketDetailsRepository(_context));
   
namespace JumpAndRun.Content.TerrainGeneration.Generators
    public class NewGenerator : IWorldGenerator
    {
        public int Seed { get; }
        public NewGenerator(int seed)
        {
            Seed = seed;
        }
        private static IBiom BiomForColumn(int column)
        {
            return ContentManager.Instance.Biomes[Math.Abs(column / 6) % 2];
        }
        public Chunk GenerateChunk(Index2 position)
        {
            var chunk = new Chunk(position, 1);
            IBiom biom = BiomForColumn(position.X);
            var heightmap0 = new int[Chunk.Sizex];
            for (var i = 0; i < Chunk.Sizex; i++)
            {
                heightmap0[i] = BiomForColumn(position.X - 1).GetHeight(i + (position.X - 1) * Chunk.Sizex);
            }
            var heightmap1 = new int[Chunk.Sizex];
            for (var i = 0; i < Chunk.Sizex; i++)
            {
                heightmap1[i] = BiomForColumn(position.X).GetHeight(i + position.X * Chunk.Sizex);
      

            bool useInterpolate = BiomForColumn(position.X) != BiomForColumn(position.X - 1);
                
            var heightmap = new int[Chunk.Sizex];
            for (var i = 0; i < Chunk.Sizex; i++)
            {
                int map0 = (int)(heightmap0[i] * (-(1 / (float)Chunk.Sizex) * i + 1));
                int map1 = (int)(heightmap1[i] * 1 / (float)Chunk.Sizex * i);
                heightmap[i] = useInterpolate ? map0 + map1 : heightmap1[i];
            }
            var maxBiomHeight = GameLib.Helper.ArrayMax(heightmap);
            var minBiomHeight = GameLib.Helper.ArrayMin(heightmap);
            if (maxBiomHeight < position.Y * Chunk.Sizey)
            {
                for (var x = 0; x < Chunk.Sizex; x++)
                {
                    for (var y = 0; y < Chunk.Sizey; y++)
                    {
                        SetBlock(chunk, null, x, y);
                    }
                }
            }
            else if (minBiomHeight >= (position.Y +

            {
                for (var x = 0; x < Chunk.Sizex; x++)
                {
                    for (var y = 0; y < Chunk.Sizey; y++)
                    {
                        SetBlock(chunk, biom.Filler, x, y);
                    }
                }
            }
            else
            {
                for (var x = 0; x < Chunk.Sizex; x++)
                {
                    var height = heightmap[x];
                    var chunkHeight = height - Chunk.Sizey * position.Y;
                    if (height > position.Y * Chunk.Sizey && height < (position.Y + 1) * Chunk.Sizey)
                    {
                        SetBlock(chunk, biom.Surface, x, chunkHeight);
                        for (var y = 0; y < chunkHeight; y++)
                        {
                            SetBlock(chunk, biom.Filler, x, y);
                        }
                        for (var y = chunkHeight + 1; y < Chunk.Sizey; y++)
                        {
                     
namespace AkkaProcessManager {
    public class ProcessStarted {
        public string ProcessId { get; private set; }
        public IActorRef Process { get; private set; }
        public ProcessStarted(string processId, IActorRef process) {
            ProcessId = processId;
            Process = process;
        }
    }
    public class ProcessStopped {
        public string ProcessId { get; private set; }
        public IActorRef Process { get; private set; }
        public ProcessStopped(string processId, IActorRef process) {
            ProcessId = processId;
            Process = process;
        }
    }
    public class ProcessManager : ReceiveActor {
        private readonly Dictionary<string, IActorRef> _processes;
        public ProcessManager() {
            _processes = new Dictionary<string, IActorRef>();
        }
        public IActorRef ProcessOf(string processId) {
            if (_processes.ContainsKey(processId)) {
                return _processes[processId];
     
namespace NewLife.Queue.Storage
    public class ChunkWriter
    {
        public Chunk CurrentChunk { get { return _currentChunk; } }
        private readonly ChunkManager _chunkManager;
        private readonly object _lockObj = new object();
        private bool _isClosed = false;
        private Chunk _currentChunk;
        public ChunkWriter(ChunkManager chunkManager)
        {
            Ensure.NotNull(chunkManager, "chunkManager");
            _chunkManager = chunkManager;
           
        }
        public void Open()
        {
            _currentChunk = _chunkManager.GetLastChunk();
            if (!_chunkManager.IsMemoryMode && !_chunkManager.Config.SyncFlush)
            {
                QueueService.ScheduleService.StartTask("FlushChunk", Flush, 1000, _chunkManager.Config.FlushChunkIntervalMilliseconds);
            }
            _isClosed = false;
        }
        public long Write(ILogRecord record)
        {
            lock (_lockObj)
            {
               

                {
                    return -1L;
                }
                if (_currentChunk.IsCompleted)
                {
                    _currentChunk = _chunkManager.AddNewChunk();
                }
                var result = _currentChunk.TryAppend(record);
                if (!result.Success)
                {
                    _currentChunk.Complete();
                    _currentChunk = _chunkManager.AddNewChunk();
                    result = _currentChunk.TryAppend(record);
                    if (!result.Success)
                    {
                        throw new ChunkWriteException(_currentChunk.ToString(), "Write record to chunk failed.");
                    }
                }
                if (!_chunkManager.IsMemoryMode && _chunkManager.Config.SyncFlush)
                {
                    _currentChunk.Flush();
                }
                return result.Position;
            }
        }
        public void Close()
        {
            
public class MapTester : MonoBehaviour
	void Start ()
    {
        Tile[][][] map = new Tile[32][][];
        for(int i = 0; i < 32; i++)
        {
            map[i] = new Tile[16][];
            for(int j = 0; j < 16; j++)
            {
                map[i][j] = new Tile[16];
                for(int k = 0; k < 16; k++ )
                {
                    map[i][j][k] = new Tile();
                    if((j+k)%2 == 0 )
                    {
                        map[i][j][k].ID = 1;
                    }
                    else
                    {
                        map[i][j][k].ID = 2;
                    }
                }
            }
        }
        Chunk chunk = new Chunk(map);
        ChunkSet c = ChunkSet.NewBuilder()
                             .Add(chunk)
                             .Add(chunk)
                             .Add(chunk)
                             .Add(chunk)
                             .Add(chunk)
                             .Add(chunk
namespace System.ServiceModel.Dispatcher
    class WorkflowDispatchContext : IDisposable
    {
        [ThreadStatic]
        static WorkflowDispatchContext workflowDispatchContext = null;
        bool isWorkflowStarting;
        bool synchronous;
        public WorkflowDispatchContext(bool synchronous)
            : this(synchronous, false)
        {
        }
        public WorkflowDispatchContext(bool synchronous, bool isWorkflowStarting)
        {
            this.synchronous = synchronous;
            this.isWorkflowStarting = isWorkflowStarting;
            workflowDispatchContext = this;
        }
        public static WorkflowDispatchContext Current
        {
            get
            {
                return workflowDispatchContext;
            }
        }
        public bool IsSynchronous
        {
            get
            {
                return this.synchronous;
            }
        }
        public bool IsWorkflowStarting
        {
            get
            {
    
namespace BinaryOptions.OptionServer.Services
    public class RatesService : ReceiveActor
    {
        private readonly InstrumentRepository m_instrumentRepository;
        private readonly Protocol m_protocol;
        private InstrumentRateRepository m_rateRepository = new InstrumentRateRepository();
        
        public RatesService(InstrumentRepository instrumentRepository, Protocol protocol)
        {
            m_instrumentRepository = instrumentRepository;
            m_protocol = protocol;
            Receive<OneSecondElapsed>(e => Handle(e));
            Receive<InstrumentsRequest>(c => GetInstrumentNames(c));
        }
        private void GetInstrumentNames(InstrumentsRequest instrumentsRequest)
        {
            Sender.Tell(new InstrumentsReply(m_instrumentRepository.GetInstrumentsNames()), Self);
        }
        private void Handle(OneSecondElapsed @event)
        {
            GenerateFakeRates();
            var ratesSubscriber = Context.ActorSelection(m_proto

            
            foreach (Instrument instrument in m_instrumentRepository.GetInstruments())
            {
                ratesSubscriber.Tell(new InstrumentUpdated(instrument.Name, instrument.Rate), Self);
            }
        }
        private void GenerateFakeRates() 
        {
            Random rand = new Random();
            foreach (var instrument in m_instrumentRepository.GetInstruments())
            {
                double d = Math.Round(rand.NextDouble() * (instrument.Max - instrument.Min) + instrument.Min, 4);
                instrument.Update(d);
                m_instrumentRepository.Update(instrument);
            }
        }
        private void HandleInstrumentRates(InstrumentRatesRequest instrumentRatesRequest)
        {
            IList<InstrumentRate> instrumentRates = m_rateRepository.GetInstrumentById(instrumentRatesRequest.Id);
            IList<InstrumentRateReply> ratesReply = instrumentRates.Select(i => new InstrumentRateReply(i.Id, i.Rate, i.Time
﻿namespace LibiadaMusic.Tests.ScoreModel
    [TestFixture(TestOf = typeof(Instrument))]
    public class InstrumentTests
    {
        private const int InstrumentsCount = 1;
        [Test]
        public void InstrumentCountTest()
        {
            var actualCount = ArrayExtensions.ToArray<Instrument>().Length;
            Assert.AreEqual(InstrumentsCount, actualCount);
        }
        [Test]
        public void InstrumentValuesTest()
        {
            var instruments = ArrayExtensions.ToArray<Instrument>();
            for (int i = 0; i < InstrumentsCount; i++)
            {
                Assert.IsTrue(instruments.Contains((Instrument)i));
            }
        }
        [TestCase((Instrument)0, "AnyOrUnknown")]
        public void InstrumentNamesTest(Instrument instrument, string name)
        {
            Assert.AreEqual(name, instrument.GetName());
        }
        [Test]
        public void InstrumentHasDisplayValueTest([Values]Instrument instrument)
        {
     
namespace WebInstruments.Controllers
    [AuthorizationFilter]
    public class InstrumentTypeController : Controller
    {
        private ApplicationDbContext _context;
        public InstrumentTypeController()
        {
            _context = new ApplicationDbContext();
        }
        public ActionResult InstrumentTypeList()
        {
            var viewModel = new NewInstrumentTypeViewModel()
            {
                InstrumentTypes = _context.InstrumentTypes.ToList(),
            };
            return View(viewModel);
        }
        public ActionResult Remove(int id)
        {
            _context.InstrumentTypes.Remove(_context.InstrumentTypes.SingleOrDefault(it => it.Id == id));
            _context.SaveChanges();
            return RedirectToAction("InstrumentTypeList");
        }
        public ActionResult Save(InstrumentType instrumentType)
        {
            if (Convert.ToInt32(instrumentType.Id) == 0)
            {
                _context.InstrumentTypes.Ad
public class World : MonoBehaviour
	public static World currentWorld;
	public Dictionary<WorldPos, Chunk> chunks = new Dictionary<WorldPos, Chunk> ();
	public GameObject chunkPrefab;
	public string worldName = "world";
	public int seed = 0;
	public bool genChunk;
	void Awake()
	{
		currentWorld = null;
		seed = worldName.GetHashCode ();
		currentWorld = this;
	}
	void Start ()
	{
	}
	void Update ()
	{
	}
	public void CreateChunk (int x, int y, int z)
	{
		WorldPos worldPos = new WorldPos (x, 0, z);
		GameObject newChunkObject = Instantiate (chunkPrefab, new Vector3 (x, 0, z), Quaternion.identity) as GameObject;
		
		Chunk newChunk = newChunkObject.GetComponent<Chunk> ();
		newChunk.name = "Chunk@" + new Vector3(x, y, z);
		newChunk.pos = worldPos;
		newChunk.world = this;
		
		chunks.Add (worldPos, newChunk);
		
		var terrainGen = new TerrainGen ();
		newChunk = terrainGen.ChunkGen (newChunk);
		
		newChunk.SetBlocksUnmodified ();
		
		Serialization.Load (newChunk);
	}
	public void Des

	{
		Chunk chunk = null;
		if (chunks.TryGetValue (new WorldPos (x, y, z), out chunk))
		{
			Object.Destroy (chunk.gameObject);
			chunks.Remove (new WorldPos (x, y, z));
		}
	}
	public Chunk GetChunk (int x, int y, int z)
	{
		WorldPos pos = new WorldPos ();
		float multiple = Chunk.chunkWidth;
		pos.x = Mathf.FloorToInt (x / multiple) * Chunk.chunkWidth;
		pos.y = 0;
		pos.z = Mathf.FloorToInt (z / multiple) * Chunk.chunkWidth;
		
		Chunk containerChunk = null;
		
		chunks.TryGetValue (pos, out containerChunk);
		
		return containerChunk;
	}
	public Block GetBlock (int x, int y, int z)
	{
		Chunk containerChunk = GetChunk (x, y, z);
		
		if (containerChunk != null)
		{
			Block block = containerChunk.GetBlock (x - containerChunk.pos.x, y, z - containerChunk.pos.z);
			return block;
		} else
		{
			return new Block ();
		}
	}
	public Block GetBlock (WorldPos pos)
	{
		return GetBlock (pos.z, pos.y, pos.z);
	}
	public void SetBlock (int x, int y, int z, Block block)
	{
		Chunk chunk 
namespace Dermatologic.Data
    public class RepositoryFactory : AbstractRepositoryFactory
    {
        public override IOfficeRepository GetOfficeRepository()
        {
            return new OfficeRepository();
        }
        public override IAppointmentRepository GetAppointmentRepository()
        {
            return new AppointmentRepository();
        }
        public override IMedicalCareRepository GetMedicalCareRepository()
        {
            return new MedicalCareRepository();
        }
        public override IServiceRepository GetServiceRepository()
        {
            return new ServiceRepository();
        }
        public override ISessionRepository GetSessionRepository()
        {
            return new SessionRepository();
        }
        public override IUbigeoRepository GetUbigeoRepository()
        {
            return new UbigeoRepository();
        }
        public override IMenuRepository GetMenuRepository()
        {
            return  new MenuReposit

        }
        public override IMenuRoleRepository GetMenuRoleRepository()
        {
            return new MenuRoleRepository();
        }
        public override IUsersInRolesRepository GetUsersInRolesRepository()
        {
            return new UsersInRolesRepository();
        }
        public override IUsersRepository GetUsersRepository()
        {
            return new UsersRepository();
        }
        public override IRoleRepository GetRoleRepository()
        {
            return new RoleRepository();
        }
        public override IMedicationRepository GetMedicationRepository()
        {
            return new MedicationRepository();
        }
        public override IRateRepository GetRateRepository()
        {
            return new RateRepository();
        }
        public override ISupplyRepository GetSupplyRepository()
        {
            return new SupplyRepository();
        }
        public override IPersonRepository GetPersonRepository()
        {
     

        }
        public override IPersonTypeRepository GetPersonTypeRepository()
        {
            return new PersonTypeRepository();
          
        }
        public override IExchangeRateRepository GetExchangeRateRepository()
        {
            return new ExchangeRateRepository();
           
        }
        public override IAccountRepository GetAccountRepository()
        {
            return new AccountRepository();
        }
        public override ICostCenterRepository GetCostCenterRepository()
        {
            return new CostCenterRepository();
        }
        public override IInvoiceRepository GetInvoiceRepository()
        {
            return new InvoiceRepository();
        }
        public override ICashMovementRepository GetCashMovementRepository()
        {
            return new CashMovementRepository();
        }
        public override IPatientInformationRepository GetPatientInformationRepository()
        {
            return new PatientInformatio
namespace TraderClient.OrderBLL
    internal sealed class Instrument
    {
        internal Instrument(XElement element)
        {
            this.Id = Guid.Parse(element.ParseContent("ID"));
            this.Code = element.ParseContent("Code");
            int category = int.Parse(element.ParseContent("Category"));
            this.IsPhysical = category == 20 ;
        }
        internal Guid Id { get; private set; }
        internal string Code { get; private set; }
        internal bool IsPhysical { get; private set; }
    }
    internal sealed class InstrumentManager
    {
        internal static readonly InstrumentManager Default = new InstrumentManager();
        private Dictionary<Guid, Instrument> _instrumentDict = new Dictionary<Guid, Instrument>();
        static InstrumentManager() { }
        private InstrumentManager() { }
        internal void Initialize()
        {
            foreach (var eachElement in Settings.Default.SettingElement.Elements("Instrument"))
          

                Guid id = Guid.Parse(eachElement.ParseContent("ID"));
                if (!_instrumentDict.ContainsKey(id))
                {
                    var instrument = new Instrument(eachElement);
                    _instrumentDict.Add(id, instrument);
                }
            }
        }
        internal Instrument GetInstrument(Guid instrumentId)
        {
            Instrument result;
            _instrumentDict.TryGetValue(instrumentId, out result);
            return result;
        }
    }
    internal sealed class Settings
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(Settings));
        internal static readonly Settings Default = new Settings();
        static Settings() { }
        private Settings() { }
        internal XElement SettingElement { get; private set; }
        internal void Initialize()
        {
            try
            {
                this.SettingElement = XElement.Load(SettingManager.Default.SettingFile
namespace Tickets.DataAccess
    /**
     * User Repository
     **/
    public interface IUserRepository : IGenericDataRepository<User>
    {
    }
    public class UserRepository : GenericDataRepository<User>, IUserRepository
    {
    }
    /**
     * Event Repository
     **/
    public interface IEventRepository : IGenericDataRepository<Event>
    {
    }
    public class EventRepository : GenericDataRepository<Event>, IEventRepository
    {
    }
    /**
     * Ticket Repository
     **/
    public interface ITicketRepository : IGenericDataRepository<Ticket>
    {
    }
    public class TicketRepository : GenericDataRepository<Ticket>, ITicketRepository
    {
    }
    /**
     * Transaction Repository
     **/
    public interface ITransactionRepository : IGenericDataRepository<Transaction>
    {
    }
    public class TransactionRepository : GenericDataRepository<Transaction>, ITransactionRepository
    {
    }
    /**
     * Session Repository
     **/
    public interface ISe
namespace Workload.Models
	public static class RepositoryHelper
	{
		public static IUnitOfWork GetUnitOfWork()
		{
			return new EFUnitOfWork();
		}		
		
		public static audit_editRepository Getaudit_editRepository()
		{
			var repository = new audit_editRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static audit_editRepository Getaudit_editRepository(IUnitOfWork unitOfWork)
		{
			var repository = new audit_editRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static budget_planRepository Getbudget_planRepository()
		{
			var repository = new budget_planRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static budget_planRepository Getbudget_planRepository(IUnitOfWork unitOfWork)
		{
			var repository = new budget_planRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static Login_authRepository GetLogin_authRepository()

		{
			var repository = new Login_authRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static Login_authRepository GetLogin_authRepository(IUnitOfWork unitOfWork)
		{
			var repository = new Login_authRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static MonthDataRepository GetMonthDataRepository()
		{
			var repository = new MonthDataRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static MonthDataRepository GetMonthDataRepository(IUnitOfWork unitOfWork)
		{
			var repository = new MonthDataRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static PrjDataRepository GetPrjDataRepository()
		{
			var repository = new PrjDataRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static PrjDataRepository GetPrjDataRepository(IUnitOfWork unitOfWork)
		{
			var repository = new PrjData

			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static sysdiagramsRepository GetsysdiagramsRepository()
		{
			var repository = new sysdiagramsRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static sysdiagramsRepository GetsysdiagramsRepository(IUnitOfWork unitOfWork)
		{
			var repository = new sysdiagramsRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static V_EmpdataRepository GetV_EmpdataRepository()
		{
			var repository = new V_EmpdataRepository();
			repository.UnitOfWork = GetUnitOfWork();
			return repository;
		}
		public static V_EmpdataRepository GetV_EmpdataRepository(IUnitOfWork unitOfWork)
		{
			var repository = new V_EmpdataRepository();
			repository.UnitOfWork = unitOfWork;
			return repository;
		}		
		public static WorksheetRepository GetWorksheetRepository()
		{
			var repository = new WorksheetRepository();
			repository.UnitOfWork = GetUnitOfWork()
namespace Vlc.DotNet.Core.Helpers
    internal static class EventsHelper
    {
        public static void RaiseEvent<TSender, THandler>(VlcEventHandler<TSender, THandler> handler, TSender sender, VlcEventArgs<THandler> arg)
        {
            if (handler == null)
                return;
            foreach (VlcEventHandler<TSender, THandler> singleInvoke in handler.GetInvocationList())
            {
                var syncInvoke = singleInvoke.Target as ISynchronizeInvoke;
                if (syncInvoke == null)
                {
                    singleInvoke.DynamicInvoke(new object[] {sender, arg});
                    continue;
                }
                try
                {
                    if (syncInvoke.InvokeRequired)
                        syncInvoke.Invoke(singleInvoke, new object[] {sender, arg});
                    else
                        singleInvoke(sender, arg);
                }
                catch (ObjectDisposedException)
                {
  
namespace EventStore.Core.TransactionLog.Chunks
    public class TFChunkManager: IDisposable
    {
        private static readonly ILogger Log = LogManager.GetLoggerFor<TFChunkManager>();
        public int ChunksCount { get { return _chunksCount; } }
        private readonly TFChunkDbConfig _config;
        private readonly TFChunk.TFChunk[] _chunks = new TFChunk.TFChunk[MaxChunksCount];
        private volatile int _chunksCount;
        private volatile bool _cachingEnabled;
        
        private readonly object _chunksLocker = new object();
        private int _backgroundPassesRemaining;
        private int _backgroundRunning;
        public TFChunkManager(TFChunkDbConfig config)
        {
            Ensure.NotNull(config, "config");
            _config = config;
        }
        public void EnableCaching()
        {
            if (_chunksCount == 0)
                throw new Exception("No chunks in DB.");
            lock (_chunksLocker)
            {
                _caching

                TryCacheChunk(_chunks[_chunksCount - 1]);
            }
        }
        private void BackgroundCachingProcess(object state)
        {
            do
            {
                do
                {
                    CacheUncacheReadOnlyChunks();
                } while (Interlocked.Decrement(ref _backgroundPassesRemaining) > 0);
                Interlocked.Exchange(ref _backgroundRunning, 0);
            } while (Interlocked.CompareExchange(ref _backgroundPassesRemaining, 0, 0) > 0 
                     && Interlocked.CompareExchange(ref _backgroundRunning, 1, 0) == 0);
        }
        private void CacheUncacheReadOnlyChunks()
        {
            int lastChunkToCache;
            lock (_chunksLocker)
            {
                long totalSize = 0;
                lastChunkToCache = _chunksCount;
                for (int chunkNum = _chunksCount - 1; chunkNum >= 0;)
                {
                    var chunk = _chunks[chunkNum];
                    var c

                            ? chunk.ChunkFooter.PhysicalDataSize + chunk.ChunkFooter.MapSize + ChunkHeader.Size + ChunkFooter.Size
                            : chunk.ChunkHeader.ChunkSize + ChunkHeader.Size + ChunkFooter.Size;
                    if (totalSize + chunkSize > _config.MaxChunksCacheSize)
                        break;
                    totalSize += chunkSize;
                    lastChunkToCache = chunk.ChunkHeader.ChunkStartNumber;
                    chunkNum = chunk.ChunkHeader.ChunkStartNumber - 1;
                }
            }
            for (int chunkNum = lastChunkToCache - 1; chunkNum >= 0;)
            {
                var chunk = _chunks[chunkNum];
                if (chunk.IsReadOnly)
                    chunk.UnCacheFromMemory();
                chunkNum = chunk.ChunkHeader.ChunkStartNumber - 1;
            }
            for (int chunkNum = lastChunkToCache; chunkNum < _chunksCount; )
            {
                var chunk = _chunks[chunkNum];
       
﻿namespace ConnectCMS.Repositories
	public class ConnectCMSRepository : BaseRepository
	{
		private AccountRepository _accountRepository;
		private BingRepository _bingRepository;
		private CategoryRepository _categoryRepository;
		private DeviceRepository _deviceRepository;
		private EnterpriseRepository _enterpriseRepository;
		private EventRepository _eventRepository;
		private HotelRepository _hotelRepository;
		private HotelBrandRepository _hotelBrandRepository;
		private ImageRepository _imageRepository;
		private RecommendationRepository _recommendationRepository;
		private SalesForceRepository _salesForceRepository;
		private SecurityRepository _securityRepository;
		private TipRepository _tipRepository;
		private UtilityRepository _utilityRepository;
		private IReleaseNoteRepository _releaseNoteRepository;
		private IRequestRepository _requestRepository;
		private EntityRepository _entityRepository;
		private EnvisionRepository _envisionRepository;
		private EmailRepository _e

		private IDashboardRepository _dashboardRepository;
		private AnalyticRepository _analyticRepository;
		private MobileAppRepository _mobileAppRepository;
		private SubDeviceRepository _subDeviceRepository;
		private SmsRepository _smsRepository;
		private BeaconRepository _beaconRepository;
		private WelcomeTabletRepository _welcomeTabletRepository;
		private MarketingCampaignRepository _marketingCampaignRepository;
		private INotificationRepository _notificationRepository;
		public AccountRepository AccountRepository
		{
			get { return _accountRepository ?? ( _accountRepository = new AccountRepository( this ) ); }
		}
		public BingRepository BingRepository
		{
			get { return _bingRepository ?? ( _bingRepository = new BingRepository( this ) ); }
		}
		public CategoryRepository CategoryRepository
		{
			get { return _categoryRepository ?? ( _categoryRepository = new CategoryRepository( this ) ); }
		}
		public DeviceRepository DeviceRepository
		{
			get { return _deviceRepository ?

		}
		public EnterpriseRepository EnterpriseRepository
		{
			get { return _enterpriseRepository ?? ( _enterpriseRepository = new EnterpriseRepository( this ) ); }
		}
		public EventRepository EventRepository
		{
			get { return _eventRepository ?? ( _eventRepository = new EventRepository( this ) ); }
		}
		public HotelRepository HotelRepository
		{
			get { return _hotelRepository ?? ( _hotelRepository = new HotelRepository( this ) ); }
		}
		public HotelBrandRepository HotelBrandRepository
		{
			get { return _hotelBrandRepository ?? ( _hotelBrandRepository = new HotelBrandRepository( this ) ); }
		}
		public ImageRepository ImageRepository
		{
			get { return _imageRepository ?? ( _imageRepository = new ImageRepository( this ) ); }
		}
		public RecommendationRepository RecommendationRepository
		{
			get { return _recommendationRepository ?? ( _recommendationRepository = new RecommendationRepository( this ) ); }
		}
		public SalesForceRepository SalesForceRepository
		{
			get { re
namespace General.CIR.Controller.ViewModelController
	[Export]
	public class DispatchCommandController : ControllerBase<DispatchCommandViewModel>
	{
		public DispatchCommandController()
		{
			EventAggregator.GetEvent<NetWorkDataEvent>().Subscribe(CommandResponse, ThreadOption.UIThread);
		}
		private void CommandResponse(NetWorkEventArgs obj)
		{
			CIRViewModel instance = ServiceLocator.Current.GetInstance<CIRViewModel>();
			bool flag = obj.BusinessType == BusinessType.Command;
			if (flag)
			{
				DispatchInfo dispatchInfo = (DispatchInfo)CIRCommAgent.BytesToStruct(obj.Data.Buff, typeof(DispatchInfo), 0);
				DispatchCommandUnit dispatchCommandUnit = new DispatchCommandUnit(dispatchInfo);
				bool flag2 = 31 >= dispatchInfo.cmdType && dispatchInfo.cmdType >= 24;
				if (flag2)
				{
					dispatchCommandUnit.CommandType = CommandType.OtherInfo;
				}
				else
				{
					dispatchCommandUnit.CommandType = (CommandType)dispatchInfo.cmdType;
				}
				dispatchCommandUnit.TrainNumber = 

				dispatchCommandUnit.EngineNumber = dispatchInfo.TrainID.ToStrNumber();
				dispatchCommandUnit.ReleaseTime = dispatchInfo.DispatchDateTime;
				dispatchCommandUnit.ReleasePlace = dispatchInfo.SendDispatchCmdName;
				dispatchCommandUnit.ReleaseName = dispatchInfo.Dispatcher;
				dispatchCommandUnit.CommandName = dispatchInfo.DispatchCmdName;
				dispatchCommandUnit.Number = dispatchInfo.CmdNum;
				dispatchCommandUnit.Current = (instance.MainContentViewModel.SystemInfosViewModel.IsSupplyOrder ? "本" : "补");
				dispatchCommandUnit.Content = GetContent(dispatchInfo.DispatchCmdContext, instance.MainContentViewModel.SystemInfosViewModel.KMMark);
				ViewModel.AllUnit.Add(dispatchCommandUnit);
				ViewModel.DisplayUnit = dispatchCommandUnit;
				BtnResponseBase.OperateTime = DateTime.Now;
				instance.Controller.NavigatorToKey(BtnItemKeys.调度命令详细界面);
				CIRPacket cIRPacket = default(CIRPacket);
				cIRPacket.Init();
				cIRPacket.SetHeadInfo(1, 35, 6, 81);
				DispatchInfoSignConfirm d

				dispatchInfoSignConfirm.Init();
				dispatchInfoSignConfirm.InfoName = 129;
				dispatchInfoSignConfirm.cmdForm = dispatchInfo.cmdForm;
				dispatchInfoSignConfirm.TrainID = dispatchInfo.TrainID;
				dispatchInfoSignConfirm.TrainNum = dispatchInfo.TrainNum;
				dispatchInfoSignConfirm.CmdNum = dispatchInfo.CmdNum;
				cIRPacket.SetData(CIRCommAgent.StructToBytes(dispatchInfoSignConfirm));
				AppLog.Info("自动确认收到调度命令pack1.GetPackLen()：{0}", new object[]
				{
					cIRPacket.GetPackLen()
				});
				CIRCommAgent.SendCIRData(CIRCommAgent.StructToBytes(cIRPacket), cIRPacket.GetDataLen(), false, 0);
			}
		}
		private string GetContent(string str, double kmMark)
		{
			StringBuilder stringBuilder = new StringBuilder(str);
			stringBuilder.Append("\r\n\r\n");
			stringBuilder.Append("接收时间：");
			stringBuilder.AppendLine(DateTime.Now.ToString("hh时mm分ss秒"));
			stringBuilder.AppendLine(string.Format("接受地点：公里标{0:F1}", kmMark));
			return stringBuilder.ToString();
		}
		private string GetRe

