"""
(Description)
Created on Dec 31, 2014
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class SearchController(BaseController):
  def __init__(self, config, session=None):
    BaseController.__init__(self, config, session)
    self.attribute_definition_broker = self.broker_factory(AttributeDefinitionBroker)
    self.attribute_broker = self.broker_factory(AttributeBroker)
    self.search_broker = self.broker_factory(SearchBroker)
    self.reference_definition_broker = self.broker_factory(ReferenceDefintionsBroker)
    self.reference_broker = self.broker_factory(ReferenceBroker)
  def get_all_attributes(self):
    """
    Returns all the attribute definitions formated for the combobox
    """
    try:
      attributes = self.attribute_definition_broker.get_all()
      return attributes
    except BrokerException as error:
      raise ControllerException(error)
  def get_all_ref

    try:
      references = self.reference_definition_broker.get_all()
      return references
    except BrokerException as error:
      raise ControllerException(error)
  def search(self, needle, operator, definition_id):
    needle = needle.strip()
    found_values = list()
    if len(needle) < 2:
      raise ControllerException('Needle has to be larger than 2')
    if definition_id is None:
      found_values = self.__look_for_any_value(needle, operator)
    elif definition_id == 'uuid':
      found_values = self.__look_for_uuids(needle, operator)
    elif definition_id == 'title':
      found_values = self.__look_for_title(needle, operator)
    elif definition_id == 'description':
      found_values = self.__look_for_description(needle, operator)
    else:
      if 'attribute' in definition_id:
        uuid = definition_id.replace('attribute:', '')
        if valid_uuid(uuid):
          definition = self.attribute_definition_broker.get_by_uuid(uuid)
          found_values = self.

                                                                        needle,
                                                                        operator)
        else:
          raise ControllerException(u'{0} is not a valid uuid'.format(uuid))
      elif 'reference' in definition_id:
        uuid = definition_id.replace('reference:', '')
        if valid_uuid(uuid):
          definition = self.reference_definition_broker.get_by_uuid(uuid)
          found_values = self.reference_broker.look_for_reference_value(definition,
                                                                        needle,
                                                                        operator)
        else:
          raise ControllerException(u'{0} is not a valid uuid'.format(uuid))
      else:
        raise ControllerException(u'{0} is not a valid definition identifier'.format(definition_id))
    return found_values
  def __look_for_any_value(self, needle, operator):
    found_values = se
class BaseTest(object):
    '''
    Base class for all Tests
    '''
    def create_product(self, base_url, selenium, profile=None):
        create_product_pg = MozTrapCreateProductPage(base_url, selenium)
        create_product_pg.go_to_create_product_page()
        product = create_product_pg.create_product(profile=profile)
        return product
    def delete_product(self, base_url, selenium, product):
        manage_products_pg = MozTrapManageProductsPage(base_url, selenium)
        manage_products_pg.go_to_manage_products_page()
        manage_products_pg.filter_form.filter_by(lookup='name', value=product['name'])
        manage_products_pg.delete_product(name=product['name'])
    def create_version(self, base_url, selenium, product):
        create_version_pg = MozTrapCreateVersionPage(base_url, selenium)
        create_version_pg.go_to_create_version_page()
        version = create_version_pg.create_version(product_name=product['name'])
        version['product'] = product
    

    def delete_version(self, base_url, selenium, version):
        manage_versions_pg = MozTrapManageVersionsPage(base_url, selenium)
        manage_versions_pg.go_to_manage_versions_page()
        manage_versions_pg.filter_form.filter_by(lookup='version', value=version['name'])
        manage_versions_pg.delete_version(name=version['name'], product_name=version['product']['name'])
    def create_run(self, base_url, selenium, product, activate=False, version=None, suite_name_list=None):
        create_run_pg = MozTrapCreateRunPage(base_url, selenium)
        if version is None:
            version = self.create_version(base_url, selenium, product=product)
        create_run_pg.go_to_create_run_page()
        product_version = u'%(product_name)s %(version_name)s' % {'product_name': product['name'], 'version_name': version['name']}
        run = create_run_pg.create_run(product_version=product_version, suite_list=suite_name_list)
        run['version'] = version
        if activate:
   

            manage_runs_pg.filter_form.filter_by(lookup='name', value=run['name'])
            manage_runs_pg.activate_run(name=run['name'])
        return run
    def delete_run(self, base_url, selenium, run, delete_version=False):
        manage_runs_pg = MozTrapManageRunsPage(base_url, selenium)
        manage_runs_pg.go_to_manage_runs_page()
        manage_runs_pg.filter_form.filter_by(lookup='name', value=run['name'])
        manage_runs_pg.delete_run(name=run['name'])
        if delete_version:
            self.delete_version(base_url, selenium, version=run['version'])
    def create_suite(self, base_url, selenium, product, api=None, status='active', case_list=[], **kwargs):
        if api is not None:
            suite = MockSuite()
            api.create_suite(suite, product, case_list)
        else:
            create_suite_pg = MozTrapCreateSuitePage(base_url, selenium)
            create_suite_pg.go_to_create_suite_page()
            suite = create_suite_pg.create_suite(pro
class app_manage_page():
    '''
                             版本 应用商店4.0.1
                             编号 AppStore2-909
                            标题    管理界面验证
        '''
    def __init__(self):
        self.common_fn = CommonFunctions()
      
    def manage_page(self):
        try:
            manage_buttons=self.common_fn.wait_for_elements(r'com.tclmarket:id/text',By.ID)
            manage_button_num=self.common_fn.wait_for_element(r'com.tclmarket:id/manager_update_app_tips')
            manage_num=manage_button_num.text
            print manage_num
            if manage_buttons[4].text==u'管理':
                manage_buttons[4].click()
                time.sleep(2)
                print u'go into manage page\n'
            else:
                print u'manage_button[4].text do not equal to 管理' 
                
            try:
                action_texts=self.common_fn.wait_for_elements(r'com.tclmarket:id/manage_text',By.ID)
                for i in range(5):
                  

                print u'manage page is right\n'
                try:            
                    action_buttons=self.common_fn.wait_for_elements(r'com.tclmarket:id/manage_image',By.ID)
                    action_buttons[1].click()
                    time.sleep(2)
                    try:
                        updated_titles=self.common_fn.wait_for_elements('com.tclmarket:id/header_text',By.ID)
                        if updated_titles:
                            print updated_titles[0].text
                            print manage_num
                            manage_num_str=u'可更新（'+manage_num+u'）'
                            if updated_titles[0].text==manage_num_str:
                                print u'the number of apps to be updated is right\n'
                                return True
                        else:
                            print u'no app to be updated\n' 
                            return True
                    except Exception as e:
         

                        print u'can not get number of updated_title \n'
                        return False
                except Exception as e:
                    print u'error 2:'+e
                    print u'action_buttons are wrong\n'    
                    return False
            except Exception as e:
                print u'error 1:'+e
                print u'fail to go into download task page'  
                return False
        except Exception as e:
            print e
            print u'not find manage button\n'
            s = sys.exc_info()
            print 'Error %s on line %d' % (s[1],s[2].tb_lineno)
            return False
        finally:
            self.common_fn.driver.remove_app('com.tencent.qqlive')        
                
    def run(self):
        start = startOperate()
        return self.common_fn.run_test_case(lambda: self.common_fn.launch_app('4.0.1'),
                                     lambda: start.baseOperate(),
                          
class Scaffolding(object):
    """
    Scaffolding Component
    """
    def __init__(self, controller):
        self.controller = controller
        self._init_meta()
        self._init_flash()
    def _init_flash(self):
        if not FlashMessages in self.controller.Meta.components:
            self.controller.components['flash_messages'] = FlashMessages(self.controller)
    def _init_meta(self):
        """
        Constructs the controller's scaffold property from the controller's Scaffold class.
        If the controller doens't have a scaffold, uses the automatic one.
        """
        if not hasattr(self.controller.Meta, 'Model'):
            _load_model(self.controller)
        if not hasattr(self.controller, 'Scaffold'):
            setattr(self.controller, 'Scaffold', Scaffold)
        if not issubclass(self.controller.Scaffold, Scaffold):
            self.controller.Scaffold = type('Scaffold', (self.controller.Scaffold, Scaffold), {})
        setattr(self.controller, 'sca

        self.controller.events.template_names += self._on_template_names
        self.controller.events.before_render += self._on_before_render
        self.controller.events.scaffold_before_parse += self._on_scaffold_before_parse
    def _on_scaffold_before_parse(self, controller):
        if not hasattr(controller.meta, 'Form') or not controller.meta.Form:
            controller.meta.Form = controller.scaffold.ModelForm
    def _on_template_names(self, controller, templates):
        """Injects scaffold templates into the template list"""
        controller, prefix, action, ext = self.controller.route.name, self.controller.route.prefix, self.controller.route.action, self.controller.meta.view.template_ext
        if prefix:
            templates.append('scaffolding/%s_%s.%s' % (prefix, action, ext))
        templates.append('scaffolding/%s.%s' % (action, ext))
    def _on_before_render(self, controller):
        controller.context['scaffolding'] = {
            'name': controller.nam

            'proper_name': controller.proper_name,
            'title': controller.scaffold.title,
            'plural': controller.scaffold.plural,
            'singular': controller.scaffold.singular,
            'form_action': controller.scaffold.form_action,
            'form_encoding': controller.scaffold.form_encoding,
            'display_properties': controller.scaffold.display_properties
        }
class Scaffold(object):
    """
    Scaffold Meta Object Base Class
    """
    def __init__(self, controller):
        defaults = dict(
            title=inflector.titleize(controller.proper_name),
            plural=inflector.underscore(controller.name),
            singular=inflector.underscore(inflector.singularize(controller.name)),
            ModelForm=model_form(controller.meta.Model),
            display_properties=[name for name, property in controller.meta.Model._properties.items()],
            redirect=controller.uri(action='list') if controller.uri_exists(action='list'
class controller:
    def __init__(self,com_port,baudrate):                           
        
    def iscontrollerconnected(self):
        try:
            controller=serial.Serial(self.controller_port,self.controller_baudrate,timeout=1)  
            controller.write("c")                                                              
            while 1:                                                                            
                ping_back_value=controller.read()                                             
                if ping_back_value=="1":                                                        
                    controller.close()                                                          
                    return True
                else:
                    controller.close()                                                                              return False
        except:
            return False
    
    def checkleftjoystickx(self):
        if se

            controller=serial.Serial(self.controller_port,self.controller_baudrate,timeout=1)
            controller.write("j")
            controller.write("l")
            controller.write("x")
            while 1:
                reading=controller.read()
                controller.close()
                return reading
        else:
            return -1
    def checkleftjoysticky(self):
        if self.iscontrollerconnected():
            controller=serial.Serial(self.controller_port,self.controller_baudrate,timeout=1)
            controller.write("j")
            controller.write("l")
            controller.write("y")
            while 1:
                reading=controller.read()
                controller.close()
                return reading
        else:
            return -1
    def checkrightjoystickx(self):
        if self.iscontrollerconnected():
            controller=serial.Serial(self.controller_port,self.controller_baudrate,timeout=1)
            controller.write("j"

            controller.write("r")
            controller.write("x")
            while 1:
                reading=controller.read()
                controller.close()
                return reading
        else:
            return -1
    def checkrightjoysticky(self):
        if self.iscontrollerconnected():
            controller=serial.Serial(self.controller_port,self.controller_baudrate,timeout=1)
            controller.write("j")
            controller.write("r")
            controller.write("y")
            while 1:
                reading=controller.read()
                controller.close()
                return reading
        else:
            return -1
    def checkyellowbutton(self):
        if self.iscontrollerconnected():
            controller=serial.Serial(self.controller_port,self.controller_baudrate,timeout=1)
            controller.write("b")
            controller.write("y")
            while 1:
                reading=controller.read()
                controller.clo
def main():
    rootobj_def = pb.getObjectAt("localhost", 8800, 30)
    rootobj_def.addCallbacks(got_rootobj)
    obj2_def = getSomeObjectAt("localhost", 8800, 30, "two")
    obj2_def.addCallbacks(got_obj2)
    obj3_def = getSomeObjectAt("localhost", 8800, 30, "three")
    obj3_def.addCallbacks(got_obj3)
    reactor.run()
def got_rootobj(rootobj):
    print "got root object:", rootobj
    print "telling root object to do foo(A)"
    rootobj.callRemote("foo", "A")
def got_obj2(obj2):
    print "got second object:", obj2
    print "telling second object to do foo(B)"
    obj2.callRemote("foo", "B")
def got_obj3(obj3):
    print "got third object:", obj3
    print "telling third object to do foo(C)"
    obj3.callRemote("foo", "C")
class my_ObjectRetrieval(pb._ObjectRetrieval):
    def __init__(self, broker, d, objname):
        pb._ObjectRetrieval.__init__(self, broker, d)
        self.objname = objname
    def connectionMade(self):
        assert not self.term, "How did this get called?"
class Scaffolding(object):
    """
    Scaffolding Component
    """
    def __init__(self, controller):
        self.controller = controller
        self._init_meta()
        self._init_flash()
    def _init_flash(self):
        if not FlashMessages in self.controller.Meta.components:
            self.controller.components['flash_messages'] = FlashMessages(self.controller)
    def _init_meta(self):
        """
        Constructs the controller's scaffold property from the controller's Scaffold class.
        If the controller doens't have a scaffold, uses the automatic one.
        """
        if not hasattr(self.controller.Meta, 'Model'):
            _load_model(self.controller)
        if not hasattr(self.controller, 'Scaffold'):
            setattr(self.controller, 'Scaffold', Scaffold)
        if not issubclass(self.controller.Scaffold, Scaffold):
            self.controller.Scaffold = type('Scaffold', (self.controller.Scaffold, Scaffold), {})
        setattr(self.controller, 'sca

        self.controller.events.template_names += self._on_template_names
        self.controller.events.before_render += self._on_before_render
        self.controller.events.scaffold_before_parse += self._on_scaffold_before_parse
    def _on_scaffold_before_parse(self, controller):
        if not hasattr(controller.meta, 'Form') or not controller.meta.Form:
            controller.meta.Form = controller.scaffold.ModelForm
    def _on_template_names(self, controller, templates):
        """Injects scaffold templates into the template list"""
        controller, prefix, action, ext = self.controller.route.name, self.controller.route.prefix, self.controller.route.action, self.controller.meta.view.template_ext
        if prefix:
            templates.append('scaffolding/%s_%s.%s' % (prefix, action, ext))
        templates.append('scaffolding/%s.%s' % (action, ext))
    def _on_before_render(self, controller):
        controller.context['scaffolding'] = {
            'name': controller.nam

            'proper_name': controller.proper_name,
            'title': controller.scaffold.title,
            'plural': controller.scaffold.plural,
            'singular': controller.scaffold.singular,
            'form_action': controller.scaffold.form_action,
            'form_encoding': controller.scaffold.form_encoding,
            'display_properties': controller.scaffold.display_properties,
            'layouts': controller.scaffold.layouts
        }
class Scaffold(object):
    """
    Scaffold Meta Object Base Class
    """
    def __init__(self, controller):
        defaults = dict(
            query_factory=default_query_factory,
            create_factory=default_create_factory,
            title=inflector.titleize(controller.proper_name),
            plural=inflector.underscore(controller.name),
            singular=inflector.underscore(inflector.singularize(controller.name)),
            ModelForm=model_form(controller.meta.Model),
            display_properties=sorted([n
class AgileKeychainSpec:
    def it_unlocks_the_keychain_with_the_right_password(self):
        encryption_key = self._encryption_key_that_provides_decrypt()
        encryption_key_repository = self._encryption_key_repository_that_returns_key(encryption_key)
        keychain_item_repository = getMock(KeychainItemRepository)
        keychain = Keychain(encryption_key_repository, keychain_item_repository)
        keychain.unlock('rightpassword')
        eq_(keychain.is_locked(), False)
    @raises(InvalidPasswordException)
    def it_raises_invalidpasswordexception_with_wrong_password(self):
        encryption_key = self._encryption_key_that_raises_invalid_password_exception()
        encryption_key_repository = self._encryption_key_repository_that_returns_key(encryption_key)
        keychain_item_repository = getMock(KeychainItemRepository)
        keychain = Keychain(encryption_key_repository, keychain_item_repository)
        keychain.unlock('wrongpassword')
    def it_fails_to_unlock

        encryption_key = self._encryption_key_that_raises_invalid_password_exception()
        encryption_key_repository = self._encryption_key_repository_that_returns_key(encryption_key)
        keychain_item_repository = getMock(KeychainItemRepository)
        keychain = Keychain(encryption_key_repository, keychain_item_repository)
        try:
            keychain.unlock('wrongpassword')
        except InvalidPasswordException:
            pass
        eq_(keychain.is_locked(), True)
    def it_locks_when_lock_is_called(self):
        encryption_key = self._encryption_key_that_provides_decrypt()
        encryption_key_repository = self._encryption_key_repository_that_returns_key(encryption_key)
        keychain_item_repository = getMock(KeychainItemRepository)
        keychain = Keychain(encryption_key_repository, keychain_item_repository)
        keychain.unlock('rightpassword')
        eq_(keychain.is_locked(), False)
        keychain.lock()
        eq_(keychain.is_locked(), True

    def it_returns_a_decrypted_item_by_unique_id(self):
        encryption_key = self._encryption_key_that_provides_decrypt()
        encryption_key_repository = self._encryption_key_repository_that_returns_key(encryption_key)
        keychain_item = getMock(KeychainItem)
        keychain_item.expects('decrypt').with_args("master_key")
        keychain_item_repository = getMock(KeychainItemRepository)
        keychain_item_repository.provides('item_by_unique_id').with_args('random_unique_id').returns(keychain_item)
        keychain = Keychain(encryption_key_repository, keychain_item_repository)
        keychain.unlock("password")
        eq_(keychain_item, keychain.get_item_by_unique_id('random_unique_id'))
        fudge.verify()
    @raises(KeychainLockedException)
    def it_raises_keychainlocked_exception_when_trying_to_get_item_from_locked_keychain(self):
        key_repository = getMock(EncryptionKeyRepository)
        item_repository = getMock(KeychainItemRepository)
        key
"""
file: readRepo.py
authors: Ben Grawi <bjg1568@rit.edu>, Christoffer Rosen <cbr4830@rit.edu>
date: October 2013
description: This module contains the functions for ingesting a repository with
             a given id. 
"""
def ingestRepo(repository_to_ingest, session):
  """
  Ingests a given repository
  @param repository_to_ingest   The repository to inspect
  @param session 				The SQLAlchemy session
  @private
  """
  logging.info( 'A worker is starting scan repository: ' +
                      repository_to_ingest.id )
  repository_to_ingest.status = "Ingesting"
  session.commit()
  local_repo = LocalRepository(repository_to_ingest)
  local_repo.sync()
  session.merge(repository_to_ingest) 
  session.commit() 
  logging.info( 'A worker finished ingesting repo ' + 
                  repository_to_ingest.id )
  session.close()
def ingest(repo_id):
  """
  Ingest a repository with the given id. Gets the repository information
  from the repository table and starts ingesting using 
'''
Created on Mar 4, 2013
@author: Devindra
The main class. Links the program together and then starts the fun.
'''
def on_exit():
    print("Exiting...")
def init_states(window):
    game_model = model.game.Game()
    global_controller = controller.controller.Controller()
    
    print("Initializing Game States...")
    State('game',
        window     = window,
        model      = game_model,
        view       = view.game.GameView(window),
        controller = global_controller,
        commands   = controller.game.commands,
    )
    
    State('properties',
        window     = window,
        model      = game_model,
        view       = view.properties.PropertiesView(window),
        controller = global_controller,
        commands   = controller.properties.commands,
    )
    
    State('traits',
        window     = window,
        model      = game_model,
        view       = view.traits.TraitsView(window),
        controller = global_controller,
        commands   = contr
class OptionsController:
	def OPTIONS(self, *args, **kwargs):
		return ""
def CORS():
	cherrypy.response.headers["Access-Control-Allow-Origin"] = "*"
	cherrypy.response.headers["Access-Control-Allow-Methods"] = "GET, PUT, POST, DELETE, OPTIONS"
	cherrypy.response.headers["Access-Control-Allow-Credentials"] = "true"
def start_service():
	dispatcher = cherrypy.dispatch.RoutesDispatcher()
	mdb = _movie_database()
	movieController = MovieController(mdb)
	userController = UserController(mdb)
	voteController = VoteController(mdb)
	ratingController = RatingController(mdb)
	resetController = ResetController(mdb)
	favoriteController = FavoriteController(mdb)
	optionsController = OptionsController()
	dispatcher.connect('movie_get', '/movies/:movie_id', controller=movieController, action='GET', conditions=dict(method=['GET']))
	dispatcher.connect('movie_put', '/movies/:movie_id', controller=movieController, action='PUT', conditions=dict(method=['PUT']))
	dispatcher.connect('movie_delete', '/movie

	dispatcher.connect('movie_get_idx', '/movies/', controller=movieController, action='GET_INDEX', conditions=dict(method=['GET']))
	dispatcher.connect('movie_post_idx', '/movies/', controller=movieController, action='POST_INDEX', conditions=dict(method=['POST']))
	dispatcher.connect('movie_delete_idx', '/movies/', controller=movieController, action='DELETE_INDEX', conditions=dict(method=['DELETE']))
	dispatcher.connect('user_get', '/users/:user_id', controller=userController, action='GET', conditions=dict(method=['GET']))
	dispatcher.connect('user_put', '/users/:user_id', controller=userController, action='PUT', conditions=dict(method=['PUT']))
	dispatcher.connect('user_delete', '/users/:user_id', controller=userController, action='DELETE', conditions=dict(method=['DELETE']))
	dispatcher.connect('user_get_idx', '/users/', controller=userController, action='GET_INDEX', conditions=dict(method=['GET']))
	dispatcher.connect('user_post_idx', '/users/', controller=userController, action='POS

	dispatcher.connect('user_delete_idx', '/users/', controller=userController, action='DELETE_INDEX', conditions=dict(method=['DELETE']))
	dispatcher.connect('votes_get', '/recommendations/:user_id', controller=voteController, action='GET', conditions=dict(method=['GET']))
	dispatcher.connect('votes_put', '/recommendations/:user_id', controller=voteController, action='PUT', conditions=dict(method=['PUT']))
	dispatcher.connect('votes_delete_idx', '/recommendations/', controller=voteController, action='DELETE_INDEX', conditions=dict(method=['DELETE']))
	dispatcher.connect('favs_get', '/favorites/:user_id', controller=favoriteController, action='GET', conditions=dict(method=['GET']))
	dispatcher.connect('favs_put', '/favorites/:user_id', controller=favoriteController, action='PUT', conditions=dict(method=['PUT']))
	dispatcher.connect('favs_put_idx', '/favorites/', controller=favoriteController, action='GET_INDEX', conditions=dict(method=['GET'])) 
	dispatcher.connect('favs_post_idx', '/fav
_global_broker = None
def createEventBroker(obj):
    global _global_broker
    if not _global_broker:
        _global_broker = TGSGlobalEventBroker()
    return _global_broker
class TGSGlobalEventBroker:
    def __init__(self):
        TGSCommunityEvent = AndroidFacade.CommunityEvent()
        self._squareUpdateEvent = TGSCommunityEvent
        self._newSquareUpdate = TGSNewCommunitySignal(self._squareUpdateEvent)
        self._squareInfoUpdated = TGSCommunityInfoUpdatedSignal(self._squareUpdateEvent)
    def newCommunityCreated(self, square):
        self._newSquareUpdate.emit(square)
    def newPreviewCommunityCreated(self, square):
        pass
    def newHotCommunitiesAvailable(self, squares, texts):
        pass
    def memberInfoUpdated(self, member):
        AndroidFacade.monitor('memberInfo updated: {}'.format(member))
    def messageReceived(self, text):
        AndroidFacade.monitor('message received: {}'.format(text))
    def squareInfoUpdated(self, square):
        Android
class DispatchInlineAdmin(admin.TabularInline):
    model = Dispatch
    extra = 0
    raw_id_fields = ('recipient',)
    readonly_fields = ('retry_count',)
class DispatchErrorInlineAdmin(admin.TabularInline):
    model = DispatchError
    extra = 0
    readonly_fields = ('time_created', 'dispatch', 'error_log')
class MessageAdmin(admin.ModelAdmin):
    list_display = ('time_created', 'cls', 'dispatches_ready')
    list_filter = ('cls', 'dispatches_ready')
    ordering = ('-time_created',)
    inlines = (DispatchInlineAdmin,)
class DispatchAdmin(admin.ModelAdmin):
    list_display = ('time_created', 'dispatch_status', 'address', 'time_dispatched', 'messenger', 'retry_count')
    list_filter = ('dispatch_status', 'messenger')
    ordering = ('-time_created',)
    raw_id_fields = ('recipient',)
    readonly_fields = ('retry_count',)
    inlines = (DispatchErrorInlineAdmin,)
class DispatchErrorAdmin(admin.ModelAdmin):
    list_display = ('time_created', 'dispatch')
    ordering = ('-time_
deploy_contracts = [
    "BuildByteArrayFactory",
def test_reclaiming_deposit_with_no_challenge(deploy_client, get_computation_request,
                                              deploy_broker_contract, deployed_contracts,
                                              get_log_data, StatusEnum, deploy_coinbase):
    factory = deployed_contracts.BuildByteArrayFactory
    broker = deploy_broker_contract(factory._meta.address)
    deposit_amount = broker.getRequiredDeposit("abcdefg");
    expected = "\x01\x02\x03\x04\x05\x06\x07"
    _id = get_computation_request(
        broker, "abcdefg",
        initial_answer=expected,
        initial_answer_deposit=deposit_amount + 1,
        soft_resolve=True,
        finalize=True,
    )
    assert broker.getRequest(_id)[5] == StatusEnum.Finalized
    reclaim_txn_h = broker.reclaimDeposit(_id)
    reclaim_txn_r = deploy_client.wait_for_transaction(reclaim_txn_h)
    deposit_log_data = get_log_data(broker.DepositReturned, reclaim_txn_h)
    assert
@pytest.fixture
def dispatch():
    return RPCDispatcher()
@pytest.fixture()
def subdispatch():
    return RPCDispatcher()
@pytest.fixture()
def mock_request(method='subtract', args=None, kwargs=None):
    mock_request = Mock(RPCRequest)
    mock_request.method = method
    mock_request.args = args or [4, 6]
    mock_request.kwargs = kwargs or {}
    mock_request.respond = Mock(RPCRequest.respond)
    mock_request.error_respond = Mock(RPCRequest.error_respond)
    return mock_request
def test_function_decorating_without_paramters(dispatch):
    @dispatch.public
    def foo(bar):
        pass
    assert dispatch.get_method('foo') == foo
def test_function_decorating_with_empty_paramters(dispatch):
    @dispatch.public()
    def foo(bar):
        pass
    assert dispatch.get_method('foo') == foo
def test_function_decorating_with_paramters(dispatch):
    @dispatch.public(name='baz')
    def foo(bar):
        pass
    with pytest.raises(KeyError):
        dispatch.get_method('foo')
    asse

def test_subdispatchers(dispatch, subdispatch):
    @dispatch.public()
    def foo(bar):
        pass
    @subdispatch.public(name='foo')
    def subfoo(bar):
        pass
    dispatch.add_subdispatch(subdispatch, 'sub.')
    assert dispatch.get_method('foo') == foo
    assert dispatch.get_method('sub.foo') == subfoo
def test_object_method_marking():
    class Foo(object):
        def foo1(self):
            pass
        @public
        def foo2(self):
            pass
        @public(name='baz')
        def foo3(self):
            pass
    f = Foo()
    assert not hasattr(f.foo1, '_rpc_public_name')
    assert f.foo2._rpc_public_name == 'foo2'
    assert f.foo3._rpc_public_name == 'baz'
def test_object_method_register(dispatch):
    class Foo(object):
        def foo1(self):
            pass
        @public
        def foo2(self):
            pass
        @public(name='baz')
        def foo3(self):
            pass
    f = Foo()
    dispatch.register_instance(f)
    with pytest.raise

        assert dispatch.get_method('foo1')
    assert dispatch.get_method('foo2') == f.foo2
    assert dispatch.get_method('baz') == f.foo3
def test_object_method_register_with_prefix(dispatch):
    class Foo(object):
        def foo1(self):
            pass
        @public
        def foo2(self):
            pass
        @public(name='baz')
        def foo3(self):
            pass
    f = Foo()
    dispatch.register_instance(f, 'myprefix')
    with pytest.raises(KeyError):
        assert dispatch.get_method('foo1')
    with pytest.raises(KeyError):
        assert dispatch.get_method('myprefixfoo1')
    with pytest.raises(KeyError):
        assert dispatch.get_method('foo2')
    with pytest.raises(KeyError):
        assert dispatch.get_method('foo3')
    assert dispatch.get_method('myprefixfoo2') == f.foo2
    assert dispatch.get_method('myprefixbaz') == f.foo3
def test_dispatch_calls_method_and_responds(dispatch, mock_request):
    m = Mock()
    m.subtract = Mock(return_value=-2)
  
"""
Protocol command interpret/dispatch
"""
class HeaderDispatch(pyglet.event.EventDispatcher):
    """Dispatch packet unwrapping header"""
    def __init__(self):
        super(HeaderDispatch, self).__init__()
    def dispatch(self, data, address):
        ident, = struct.unpack("!6s", data[:6])
        if ident != "BOXMAN":
            return
        self.dispatch_event('received_header', data[6:], address)
HeaderDispatch.register_event_type('received_header')
class CommandDispatch(pyglet.event.EventDispatcher):
    """Dispatch packet unwrapping command type"""
    def __init__(self):
        super(CommandDispatch, self).__init__()
    def dispatch(self, data, address):
        cmd, = struct.unpack("!B", data[:1])
        if cmd == CMD_HELLO:
            self.dispatch_event('received_hello', data[1:], address)
        elif cmd == CMD_QUIT:
            self.dispatch_event('received_quit', data[1:], address)
        elif cmd == CMD_SPAWN:
            self.dispatch_event('received_spawn

        elif cmd == CMD_DESTROY:
            self.dispatch_event('received_destroy', data[1:], address)
        elif cmd == CMD_UPDATE:
            self.dispatch_event('received_update', data[1:], address)
        elif cmd == CMD_CLIENT:
            self.dispatch_event('received_client', data[1:], address)
CommandDispatch.register_event_type('received_hello')
CommandDispatch.register_event_type('received_quit')
CommandDispatch.register_event_type('received_spawn')
CommandDispatch.register_event_type('received_destroy')
CommandDispatch.register_event_type('received_update')
CommandDispatch.register_event_type('received_client')
class HelloDispatch(pyglet.event.EventDispatcher):
    """Dispatch packet unwrapping hello command"""
    def __init__(self):
        super(HelloDispatch, self).__init__()
    def dispatch(self, data, address):
        self.dispatch_event('on_hello', address)
HelloDispatch.register_event_type('on_hello')
class QuitDispatch(pyglet.event.EventDispatcher):
    """D

    def __init__(self):
        super(QuitDispatch, self).__init__()
    def dispatch(self, data, address):
        self.dispatch_event('on_quit', address)
QuitDispatch.register_event_type('on_quit')
class SpawnDispatch(pyglet.event.EventDispatcher):
    """Dispatch packet unwrapping spawn entity command"""
    def __init__(self):
        super(SpawnDispatch, self).__init__()
    def dispatch(self, data, address):
        type, id, color_r, color_g, color_b = struct.unpack("!BBBBB", data[:5])
        color = (color_r, color_g, color_b)
        self.dispatch_event('on_spawn_entity', type, id, color, address)
SpawnDispatch.register_event_type('on_spawn_entity')
class DestroyDispatch(pyglet.event.EventDispatcher):
    """Dispatch packet unwrapping destroy entity command"""
    def __init__(self):
        super(DestroyDispatch, self).__init__()
    def dispatch(self, data, address):
        id, = struct.unpack("!B", data[:1])
        self.dispatch_event('on_destroy_entity', id, address)
D
class _NotificationMVC:
    def __init__(self):
        self.__model = None
        self.__alertsController = None
        self.__layoutController = None
        self.__visibilityController = None
        self.__actionsHandlers = None
        self.__actionsHandlers = None
        return
    def initialize(self):
        self.__model = NotificationsModel()
        self.__actionsHandlers = NotificationsActionsHandlers()
        self.__alertsController = AlertController(self.__model)
        self.__layoutController = LayoutController(self.__model)
        self.__visibilityController = NotificationVisibilityController(self.__model)
        self.__visibilityController.registerNotifications((NOTIFICATION_TYPE.CLUB_INVITE,))
    def getModel(self):
        return self.__model
    def getAlertController(self):
        return self.__alertsController
    def handleAction(self, typeID, entityID, action):
        self.__actionsHandlers.handleAction(self.__model, int(typeID), long(entityID), action
roslib.load_manifest('pr2_control_utilities')
class ControllerManagerError(Exception):
    pass
class ControllerManagerClient:
    def __init__(self):
        '''Class for starting/stopping/loading/unloading PR2 controllers.
        '''
        load_controller_service_uri = 'pr2_controller_manager/load_controller'
        unload_controller_service_uri = 'pr2_controller_manager/unload_controller'
        list_controllers_service_uri = 'pr2_controller_manager/list_controllers'
        switch_controller_service_uri = 'pr2_controller_manager/switch_controller'
        rospy.loginfo("Waiting for pr2_controller_manager services")
        rospy.wait_for_service(load_controller_service_uri)
        rospy.wait_for_service(unload_controller_service_uri)
        rospy.wait_for_service(list_controllers_service_uri)
        rospy.wait_for_service(switch_controller_service_uri)
        self._load_controller_service = rospy.ServiceProxy(load_controller_service_uri, LoadController)
        self._unloa

        self._list_controllers_service = rospy.ServiceProxy(list_controllers_service_uri, ListControllers)
        self._switch_controller_service = rospy.ServiceProxy(switch_controller_service_uri, SwitchController)
        self.known_controllers = {}
        
        rospy.loginfo("Controller manager loaded")
        self._controllers = {}
    def _update(self):
        '''Update list of controllers and their state.
        '''
        res = self._list_controllers_service()
        self._controllers = {}
        for controller_name, controller_state in zip(res.controllers, res.state):
            self._controllers[controller_name] = controller_state
    def list_controllers(self):
        '''Get list of all loaded controllers, and their state.
        Returns:
            controllers (list of str): Dictionary whose keys are the names of the loaded controllers,
               and whose values are their respective states.
        '''
        self._update()
        return copy.copy(sel

        
    def load_controller(self, controller_name):
        '''Load the given controller.
        Args:
            controller_name (str): Name of controller to load.
        Raises:
            ControllerManagerError if unable to load controller.
        '''
        self._update()
        if controller_name in self._controllers:
            return True
        res = self._load_controller_service(controller_name)
        if not res.ok:
            raise ControllerManagerError('Unable to load controller %s' % controller_name)
    def unload_controller(self, controller_name):
        '''Unload the given controller.
        Succeeds quietly if controller not loaded.
        Raises:
            ControllerManagerError if unable to unload controller.
        '''
        self._update()
        if controller_name not in self._controllers:
            return
        res = self._unload_controller_service(controller_name)
        if not res.ok:
            raise ControllerManagerError('Unab
class Foo(object):
    pass
def _fallback():
    pass
def _foo_func():
    pass
def _foo_cls():
    pass
def test_multistrategy_dispatch_register_cls():
    _fallback()
    _foo_func()
    _foo_cls()
    dispatch = MultiStrategyDispatch(_fallback)
    assert dispatch.dispatch(Foo) == _fallback
    dispatch.register_cls_list([(Foo, _foo_cls)])
    assert dispatch.dispatch(Foo) == _foo_cls
def test_multistrategy_dispatch_register_func():
    dispatch = MultiStrategyDispatch(_fallback)
    assert dispatch.dispatch(Foo) == _fallback
    dispatch.register_func_list([
        (lambda cls: issubclass(cls, Foo), _foo_func)
    ])
    assert dispatch.dispatch(Foo) == _foo_func
def test_multistrategy_dispatch_conflict_class_wins():
    """
    When a class dispatch and a function dispatch
    are registered which handle the same type, the
    class dispatch should return.
    """
    dispatch = MultiStrategyDispatch(_fallback)
    dispatch.register_func_list([
        (lambda cls: issubclass(cls
try:
    io.use_plugin('pil')
    PIL_available = True
    priority_plugin = 'pil'
except ImportError:
    PIL_available = False
try:
    io.use_plugin('freeimage')
    FI_available = True
    priority_plugin = 'freeimage'
except RuntimeError:
    FI_available = False
def setup_module():
def teardown_module():
    io.reset_plugins()
@contextmanager
def protect_preferred_plugins():
    """Contexts where `preferred_plugins` can be modified w/o side-effects."""
    preferred_plugins = manage_plugins.preferred_plugins.copy()
    try:
        yield
    finally:
        manage_plugins.preferred_plugins = preferred_plugins
def test_read():
    io.imread('test.png', as_grey=True, dtype='i4', plugin='test')
def test_save():
    io.imsave('test.png', [1, 2, 3], plugin='test')
def test_show():
    io.imshow([1, 2, 3], plugin_arg=(1, 2), plugin='test')
def test_collection():
    io.imread_collection('*.png', conserve_memory=False, plugin='test')
def test_use():
    manage_plugins.use_plugin('test'

    manage_plugins.use_plugin('test', 'imshow')
@raises(ValueError)
def test_failed_use():
    manage_plugins.use_plugin('asd')
@skipif(not PIL_available and not FI_available)
def test_use_priority():
    manage_plugins.use_plugin(priority_plugin)
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, priority_plugin)
    manage_plugins.use_plugin('test')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'test')
@skipif(not PIL_available)
def test_use_priority_with_func():
    manage_plugins.use_plugin('pil')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'pil')
    manage_plugins.use_plugin('test', 'imread')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'test')
    plug, func = manage_plugins.plugin_store['imsave'][0]
    assert_equal(plug, 'pil')
    manage_plugins.use_plugin('test')
    plug, func = manage_plugins.plugin_store['imsave'][0]
    assert_equal(p

def test_plugin_order():
    p = io.plugin_order()
    assert 'imread' in p
    assert 'test' in p['imread']
def test_available():
    assert 'qt' in io.available_plugins
    assert 'test' in io.find_available_plugins(loaded=True)
def test_load_preferred_plugins_all():
    with protect_preferred_plugins():
        manage_plugins.preferred_plugins = {'all': ['null']}
        manage_plugins.reset_plugins()
        for plugin_type in ('imread', 'imsave', 'imshow'):
            plug, func = manage_plugins.plugin_store[plugin_type][0]
            assert func == getattr(null_plugin, plugin_type)
def test_load_preferred_plugins_imread():
    with protect_preferred_plugins():
        manage_plugins.preferred_plugins['imread'] = ['null']
        manage_plugins.reset_plugins()
        plug, func = manage_plugins.plugin_store['imread'][0]
        assert func == null_plugin.imread
        plug, func = manage_plugins.plugin_store['imshow'][0]
        assert func != null_plugin.imshow
if __name__ =
class TestUIControllerReview(MnemosyneTest):
   
    def test_1(self):
        card_1 = None
        self.review_controller().reset()
        for i in range(10):
            fact_data = {"q": "question" + str(i),
                         "a": "answer" + str(i)}
            if i % 2:
                card_type = self.card_type_by_id("1")
            else:
                card_type = self.card_type_by_id("2")            
            card = self.controller().create_new_cards(fact_data, card_type,
                    grade=4, tag_names=["default" + str(i)])[0]
            if i == 0:
                card_1 = card
                card.next_rep -= 1000 * 24 * 60 * 60 
                self.database().update_card(card)
        self.review_controller().new_question()
        self.review_controller().show_answer()        
        assert self.review_controller().card == card_1
        assert self.review_controller().get_counters() == (1, 0, 15)       
        self.review_controller().grade_answer(0

        assert self.review_controller().get_counters() == (0, 1, 15)
        self.review_controller().grade_answer(2)
        assert self.review_controller().get_counters() == (0, 0, 15)        
    def test_2(self):
        card_1 = None
        self.review_controller().reset()
        for i in range(10):
            fact_data = {"q": "question" + str(i),
                         "a": "answer" + str(i)}
            if i % 2:
                card_type = self.card_type_by_id("1")
            else:
                card_type = self.card_type_by_id("2")            
            card = self.controller().create_new_cards(fact_data, card_type,
                    grade=4, tag_names=["default" + str(i)])[0]
            if i == 0:
                card_1 = card
                card.next_rep -= 1000 * 24 * 60 * 60
                self.database().update_card(card)
        self.review_controller().new_question()
        assert self.review_controller().card == card_1
        self.review_controller()
urlpatterns = patterns(
    "ccui.manage.views",
    url("^$", "home", name="manage"),
    url("^products/$", "products", name="manage_products"),
    url("^product/add/$", "add_product", name="manage_product_add"),
    url("^product/(?P<product_id>\d+)/$", "edit_product", name="manage_product_edit"),
    url("^testcycles/$", "testcycles", name="manage_testcycles"),
    url("^testcycles/_detail/(?P<cycle_id>\d+)/$",
        "testcycle_details",
        name="manage_testcycle_details"),
    url("^testcycle/add/$", "add_testcycle", name="manage_testcycle_add"),
    url("^testcycle/(?P<cycle_id>\d+)/$", "edit_testcycle", name="manage_testcycle_edit"),
    url("^testruns/$", "testruns", name="manage_testruns"),
    url("^testruns/_detail/(?P<run_id>\d+)/$",
        "testrun_details",
        name="manage_testrun_details"),
    url("^testrun/add/$", "add_testrun", name="manage_testrun_add"),
    url("^testrun/(?P<run_id>\d+)/$", "edit_testrun", name="manage_testrun_edit"),
    url("^testsui

    url("^testsuites/_detail/(?P<suite_id>\d+)/$",
        "testsuite_details",
        name="manage_testsuite_details"),
    url("^testsuite/add/$", "add_testsuite", name="manage_testsuite_add"),
    url("^testsuite/(?P<suite_id>\d+)/$", "edit_testsuite", name="manage_testsuite_edit"),
    url("^testcases/$", "testcases", name="manage_testcases"),
    url("^testcases/_detail/(?P<case_id>\d+)/$",
        "testcase_details",
        name="manage_testcase_details"),
    url("^testcase/add/$", "add_testcase", name="manage_testcase_add"),
    url("^testcase/add/bulk/$", "add_testcase_bulk", name="manage_testcase_add_bulk"),
    url("^testcase/(?P<case_id>\d+)/$", "edit_testcase", name="manage_testcase_edit"),
    url(r"^environments/$", "environment_profiles", name="manage_environments"),
    url(r"^environment/add/$", "add_environment_profile", name="manage_environment_add"),
    url(r"^environment/edit/(?P<profile_id>\d+)/$", "edit_environment_profile", name="manage_environment_edit"),

class Manage_StudentOfficers_BaseHandler(Manage_BaseHandler):
    pass
class Manage_StudentOfficers_Handler(Manage_StudentOfficers_BaseHandler):
    def get(self):
        self.generate_manage_bar()
        self.template_vars['existingStudentOfficers'] = StudentOfficer.gql("ORDER BY DisplayOrder ASC").fetch(50)
        self.template_vars['form'] = self.generate_form(StudentOfficer_Form)
        self.render_template("manage/student_officers/student_officers.html")
    def post(self):
        def post_process_model(filled_student_officer):
            filled_student_officer.Image = images.resize(filled_student_officer.Image, 100, 196)
            if not filled_student_officer.DisplayOrder:
                displayOrderObject = StudentOfficer.gql("ORDER BY DisplayOrder DESC").get()
                if displayOrderObject and displayOrderObject.DisplayOrder:
                    filled_student_officer.DisplayOrder = displayOrderObject.DisplayOrder + 1
                else:
                    

        filled_student_officer = self.process_form(StudentOfficer_Form, StudentOfficer,
                                                   PostProcessing=post_process_model)
        if filled_student_officer:
            self.redirect(self.request.path)
        else:
            self.redirect(self.request.path + '?edit=%s&retry=1' % self.request.get("edit"))
class Manage_StudentOfficers_OrderHandler(Manage_StudentOfficers_BaseHandler):
    def get(self, direction, displayOrderToMove):
        displayOrderToMove = int(displayOrderToMove)
        FirstObject = StudentOfficer.gql("WHERE DisplayOrder = :1", displayOrderToMove).get()
        if direction == 'u':
            SecondObject = StudentOfficer.gql("WHERE DisplayOrder < :1 ORDER BY DisplayOrder DESC",
                                              displayOrderToMove).get()
        else:
            SecondObject = StudentOfficer.gql("WHERE DisplayOrder > :1 ORDER BY DisplayOrder ASC",
                                              di
"""
"""
class TestSerialization(ComparisonTestCase):
    """
    Test the basic serializer and deserializer (i.e. using pickle),
    including metadata access.
    """
    def setUp(self):
        self.image1 = Image(np.array([[1,2],[4,5]]))
        self.image2 = Image(np.array([[5,4],[3,2]]))
    def tearDown(self):
        for f in os.listdir('.'):
            if f.endswith('.pkl'):
                os.remove(f)
    def test_serializer_save(self):
        Serializer.save(self.image1, 'test_serializer_save.pkl',
                        info={'info':'example'}, key={1:2})
    def test_serializer_save_no_file_extension(self):
        Serializer.save(self.image1, 'test_serializer_save_no_ext',
                        info={'info':'example'}, key={1:2})
        if 'test_serializer_save_no_ext.pkl' not in os.listdir('.'):
            raise AssertionError('File test_serializer_save_no_ext.pkl not found')
    def test_serializer_save_and_load_data_1(self):
        Serializer.save(self.image1,

        loaded = Deserializer.load('test_serializer_save_and_load_data_1.pkl')
        self.assertEqual(loaded, self.image1)
    def test_serializer_save_and_load_data_2(self):
        Serializer.save(self.image2, 'test_serializer_save_and_load_data_2.pkl')
        loaded = Deserializer.load('test_serializer_save_and_load_data_2.pkl')
        self.assertEqual(loaded, self.image2)
    def test_serializer_save_and_load_key(self):
        input_key = {'test_key':'key_val'}
        Serializer.save(self.image1, 'test_serializer_save_and_load_data.pkl', key=input_key)
        key = Deserializer.key('test_serializer_save_and_load_data.pkl')
        self.assertEqual(key, input_key)
    def test_serializer_save_and_load_info(self):
        input_info = {'info':'example'}
        Serializer.save(self.image1, 'test_serializer_save_and_load_data.pkl', info=input_info)
        info = Deserializer.info('test_serializer_save_and_load_data.pkl')
        self.assertEqual(info['info'], input_info['info

    def test_serialize_deserialize_1(self):
        data,_ = Serializer(self.image1)
        obj =   Deserializer(data)
        self.assertEqual(obj, self.image1)
    def test_serialize_deserialize_2(self):
        data,_ = Serializer(self.image2)
        obj =   Deserializer(data)
        self.assertEqual(obj, self.image2)
class TestBasicPickler(ComparisonTestCase):
    """
    Test pickler and unpickler using the .hvz format, including
    metadata access.
    """
    def setUp(self):
        self.image1 = Image(np.array([[1,2],[4,5]]))
        self.image2 = Image(np.array([[5,4],[3,2]]))
    def tearDown(self):
        for f in os.listdir('.'):
            if f.endswith('.hvz'):
                os.remove(f)
    def test_pickler_save(self):
        Pickler.save(self.image1, 'test_pickler_save.hvz',
                     info={'info':'example'}, key={1:2})
    def test_pickler_save_no_file_extension(self):
        Pickler.save(self.image1, 'test_pickler_save_no_ext',
                 
class Save_filter(Filter_base):
    name = 'Save data'
    guiColor = (128,128,255)
    def __init__(self):
        Filter_base.__init__(self)        
        self.description = "\
Save the input to single file on the hard drive, \
or to a numbered image file sequence. Input on first input \
is prioritized."
        self.setupInputsOutputs(['BW,RGB,array','Red', 'Green', 'Blue'], [])
        self.addParam( Parameter(name='Save file', 
                                 param_type='file', 
                                 description="Select a place and name to save the image. \
                                 Enabled filetypes are PNG, JPG, BMP, TIFF, or TXT (textfile)",
                                 rank=0) )
        self.addParam( Parameter(name='Save mode', 
                                 param_type='list', 
                                 default='Overwrite single', 
                                 other_content=['Overwrite single','Save sequence'], 
                         

                                 over and over, or if a numbered sequence of files should be saved.',
                                 rank=1) )
        self.addParam( Parameter(name="Notification on file write", 
                                 param_type='list',
                                 default='Yes',
                                 other_content=['Yes','No'],
                                 rank=9) )
        self.sequence_no = 0
        self.last_file = None
        self.filtertype = OUTPUT_FILTER
    def process(self, input_images, connected_outs):
        if len(input_images) != 0:
            save_file = self.getParamContent('Save file')
            if save_file == None:
                print "In '%s': Please choose a valid file to save to." %self.name
                return FAIL        
            if os.path.splitext(save_file)[1].lower() not in ['.png','.bmp',
                                                              '.jpg','.jpeg',
                            

                save_file += '.jpg'
            
            if 'B&W or RGB' in input_images:
                save_image = input_images['B&W or RGB']   
            else:
                first_image = input_images[input_images.keys()[0]]
                save_image = numpy.zeros( (first_image.shape[0], first_image.shape[1], 3),
                                          dtype='f' )
                for i, color in enumerate(['Red','Green','Blue']):
                    if color in input_images:
                        if input_images[color].ndim == 2:
                            save_image[:,:,i] = input_images[color]
                        elif input_images[color].shape[2] == 3:
                            save_image[:,:,i] = input_images[color][:,:,i]
                        else:
                            print "In '%s': Input image '%s' has wrong number of channels." %(self.name,color)
                            return FAIL
                    
            dir_name, ext = os.path.
experiences_controller,positions_controller, mainpage_controller
urlpatterns = patterns(
    'ahrm.main',
    (r'^tinymce/', include('tinymce.urls')),
    (r'^$', 'mainpage_controller.index'),
    (r'index^$', 'mainpage_controller.index'),
    (r'^mainpage$', 'mainpage_controller.goto_mainpage'),
    (r'^about_ahrm$', 'mainpage_controller.about_ahrm'),
    
    
    (r'^logout$', 'users_controller.user_logout'),
    (r'^accounts/login', 'users_controller.control_login'),
    (r'^login/verification$', 'users_controller.submit_login'),
    
    (r'^user/create/save$', 'users_controller.user_create'),
    (r'^user/delete/(?P<user_id>\d+)$', 'users_controller.user_delete'),
    (r'^user/edit/save/(?P<user_id>\d+)$', 'users_controller.user_edit'),
    (r'^user/changpwd$', 'users_controller.change_password'),
    (r'^user/pwd/update/(?P<user_id>\d+)$', 'users_controller.user_update_pwd'),
    
    (r'^users/list$', 'users_controller.users_list'),
    (r'^user/new$', 'users_controller.user_cr

    (r'^user/detail/(?P<user_id>\d+)$', 'users_controller.user_edit'),
    
    
    
    (r'^company/edit/(?P<com_id>\d+)$', 'companies_controller.company_edit'),
    (r'^company/enter/(?P<com_id>\d+)$', 'companies_controller.enter_company'),
    (r'^company/delete/(?P<com_id>\d+)$', 'companies_controller.company_delete'),
    (r'^company/new$', 'companies_controller.company_new'),
    (r'^company/change$', 'companies_controller.change_company'),
    
    (r'^movenode/$', 'companies_controller.movenode'),
    (r'^viewdetail/$', 'companies_controller.viewdetail'),
    (r'^companies/list$', 'companies_controller.companies_list'),
    (r'^companies/show$', 'companies_controller.companies_show'),
    (r'^treedata/(?P<id>\d+)/?$', 'companies_controller.treedata'),
    (r'^company/structure/', 'companies_controller.company_structure'),
    (r'^company/initialize$', 'companies_controller.company_inititialize'),
    
    
    (r'^employee/edit/(?P<employee_id>\d+)$', 'employees_controller.em

    (r'^employee/delete/(?P<employee_id>\d+)$', 'employees_controller.employee_delete'),
    (r'^employee/new', 'employees_controller.employee_create'),
    (r'^employee/addnewpage', 'employees_controller.goto_newemployee'),
    
    (r'^employees/contacts_list/pdf$', 'reports.contacts_list'),
    (r'^employee/search$', 'employees_controller.search_employee'),
    (r'^employee/personal$', 'employees_controller.goto_newemployee'), 
    (r'^employee/contactlist$', 'employees_controller.employees_contacts_list'),
    
    
    
    (r'^employee/experience/new$', 'experiences_controller.experience_new'),
    (r'^employee/experience_edit/(?P<exp_id>\d+)$', 'experiences_controller.experience_edit'),
    (r'^employee/experience/save$', 'experiences_controller.employee_save_experience'),
    (r'^employee/experience_delete/(?P<exp_id>\d+)$', 'experiences_controller.experience_delete'),
    
    (r'^employee/experience$', 'experiences_controller.employee_create_experience'),
    
    
    (r'^e
class DockerhubDal(dal.Dal):
    def create_follow(cur, uuid, repository):
        try:
            cur.execute(""" INSERT INTO dockerhub_repository
                              (uuid, repository)
                            VALUES (?, ?)
                        """, [uuid, repository])
            return True
        except sqlite3.IntegrityError:
            return False
    def delete_follow(cur, uuid, repository):
        cur.execute(""" DELETE FROM dockerhub_repository
                        WHERE uuid = ?
                        AND repository = ?
                    """, [uuid, repository])
    def read_by_repository(cur, repository):
        return cur.execute(""" SELECT uuid
                               FROM dockerhub_repository
                               WHERE repository = ?
                           """, [repository]).fetchone()
    def read_by_username(cur, username):
        return cur.execute(""" SELECT uuid
                               FROM dockerhub_username

urlpatterns = patterns(
    '',
    (r'^status/$',
     api_handlers.status_resource,
     {},
     'moca-api-status'),
    (r'^notification/(?P<notification_id>\d+)$',
     api_handlers.notification_resource,
     {},
     'moca-api-notification-by-id'),
    (r'^notification/$',
     api_handlers.notification_resource,
     {},
     'moca-api-notification'),
    (r'^patient/(?P<patient_id>[\d-]+)$',
     api_handlers.patient_resource,
     {},
     'moca-api-patient-by-id'),
    (r'^patient/$',
     api_handlers.patient_resource,
     {},
     'moca-api-patient'),
    (r'^roles/$',
     api_handlers.roles_resource,
     {},
     'moca-api-roles'),
    (r'^locations/$',
     api_handlers.locations_resource,
     {},
     'moca-api-locations'),
    (r'^procedure/(?P<procedure_id>\d+)$',
     api_handlers.procedure_resource,
     {},
     'moca-api-procedure-by-id'),
    (r'^procedure/$',
     api_handlers.procedure_resource,
     {},
     'moca-api-procedure'),
    (r'^case/(?P<case_id>
class Manage_TopTen_BaseHandler(Manage_BaseHandler):
    pass
class Manage_TopTen_Handler(Manage_TopTen_BaseHandler):
    def get(self):
        self.generate_manage_bar()
        query = TopTen.query().order(-TopTen.QuestionDate)
        self.template_vars['TopTens'] = query
        self.render_template("manage/top_ten/top_ten.html")
class Manage_TopTenCreate_Handler(Manage_TopTen_BaseHandler):
    def get(self):
        self.generate_manage_bar()
        form = self.generate_form(TopTen_Form)
        if len(form.Answers) == 0:
            for i in xrange(10):
                form.Answers.append_entry()
        self.template_vars['form'] = form
        self.render_template("manage/top_ten/top_ten_create.html")
    def post(self):
        filled_top_ten = self.process_form(TopTen_Form, TopTen)
        if filled_top_ten:
            self.redirect("/manage/top_ten")
        else:
            self.redirect(self.request.path + '?edit=%s&retry=1' % self.request.get("edit"))
class Manage_Top
def show_result(is_deleted, is_empty):
    print 'deleted? %s\nempty? %s\n' % (is_deleted, is_empty)
if __name__ == '__main__':
    db_file = ':memory:'
    broker = ContainerBroker(db_file=db_file,
                             account='account',
                             container='container')
    broker.initialize(Timestamp(time()).internal, 0)
    obj = 'object'
    print 'put object:'
    broker.put_object(obj, Timestamp(time()).internal, 10, '', '')
    info, is_deleted = broker.get_info_is_deleted()
    show_result(is_deleted, broker.empty())
    print 'delete object:'
    broker.delete_object(obj, Timestamp(time()).internal)
    info, is_deleted = broker.get_info_is_deleted()
    show_result(is_deleted, broker.empty())
    print 'delete db:'
    broker.delete_db(Timestamp(time()).internal)
    info, is_deleted = broker.get_info_is_deleted()
    show_result(is_deleted, broker.empty())
    print 'put object:'
    broker.put_object(obj, Timestamp(time()).internal, 10, '', '')
  
"""
    Relax all servos by disabling the torque for each.
"""
roslib.load_manifest('pr2lite_moveit_config')
class Relax():
    def __init__(self):
        rospy.init_node('relax_all_servos')
        
        dynamixels = ["head_pan_controller", "head_tilt_controller", "left_elbow_flex_controller", "left_elbow_pan_controller", "left_gripper_left_controller", "left_gripper_right_controller", "left_shoulder_pan_controller", "left_wrist_flex_controller", "left_wrist_roll_controller", "lidar_tilt_controller", "right_elbow_flex_controller", "right_elbow_pan_controller", "velo_gripper_ax12_controller", "right_shoulder_pan_controller", "right_wrist_flex_controller ", "right_wrist_roll_controller"]
        
        torque_services = list()
        speed_services = list()
            
        for name in sorted(dynamixels):
            controller = name.replace("_joint", "") + "_controller"
            
            torque_service = '/' + controller + '/torque_enable'
            rospy.wait_for_
def url_routes(map):
	map.connect('', controller = 'homepage.views:ViewHomepage')
	map.connect('recent', controller = 'homepage.views:RecentUpdates')
	map.connect('autobot', controller = 'autobot.views:Autobot')
	map.connect('login', controller = 'accounts.views:Login')
	map.connect('login/response', controller = 'accounts.views:LoginResponse')
	map.connect('logout', controller = 'accounts.views:Logout')
	map.connect('register', controller = 'accounts.views:Register')
	map.connect('profile/*username', controller = 'profiles.views:ViewProfile')
	map.connect('edit_profile', controller = 'profiles.views:EditProfile')
	map.connect('edit_sponsor_settings', controller = 'profiles.views:EditSponsorSettings')
	map.connect('subjects/*subjects', controller = 'editor.views:EditSubjects')
	map.connect('subjects', controller = 'editor.views:EditSubjects')
	map.connect('preview/proficiency', controller = 'store.views:ChooseProficiency')
		
	map.connect('preview/profile', controller = 'profiles.views

	map.connect('preview/employer/profile', controller = 'profiles.views:ViewEmployerProfile')
	map.connect('preview/employer/profile/browse', controller = 'profiles.views:BrowseProfiles')
	map.connect('preview/employer/load_profile', controller = 'profiles.views:LoadUserProfile')
	map.connect('demo', controller = 'quiztaker.views:PQDemo')
	map.connect('preview/ad_embed', controller = 'quiztaker.views:PQDemo')
	map.connect('st_quiz', controller = 'quiztaker.views:ViewSnaptalentQuiz')
	map.connect('st_quiz/close', controller = 'quiztaker.views:ViewNone')	
	map.connect('quiz/*quiz', controller = 'quiztaker.views:TakeQuiz')
	map.connect('widget', controller = 'quiztaker.views:Widget')	
	map.connect('quiz_item', controller = 'quiztaker.views:QuizItemTemplate')		
	map.connect('intro', controller = 'quiztaker.views:PQIntro')
	map.connect('quiz_complete', controller = 'quiztaker.views:QuizComplete')
	map.connect('quiz_frame', controller = 'quiztaker.views:QuizFrame')
	map.connect('js/quiz/:quiz

	map.connect('css/quiz', controller = 'widget.handler:QuizCSS')
		
	map.connect('edit/:subject', controller = 'editor.views:QuizEditor')
	map.connect('editor', controller = 'editor.views:Editor')
	map.connect('editor/induction', controller = 'editor.views:InductionInterface')		
	map.connect('editor/item', controller = 'editor.views:RawItemTemplate')
	map.connect('quiztaker/rpc', controller = 'quiztaker.rpc:RPCHandler')
	map.connect('editor/rpc/get', controller = 'editor.rpc:RPCMethods')		
	map.connect('editor/rpc/post', controller = 'editor.rpc:RPCMethods')	
	map.connect('editor/rpc/post*data', controller = 'editor.rpc:RPCMethods')	
	map.connect('employer/rpc', controller = 'employer.rpc:RPCHandler')	
	map.connect('employer/rpc/post', controller = 'employer.rpc:SponsorPost')		
	map.connect('accounts/rpc', controller = 'accounts.rpc:RPCHandler')	
	map.connect('accounts/rpc/post', controller = 'accounts.rpc:Post')	
	map.connect('profiles/rpc', controller = 'profiles.rpc:RPCHandler')
	ma
"""Majordomo Protocol Client API, Python version.
Author: Min RK <benjaminrk@gmail.com>
Based on Java example by Arkadiusz Orzechowski
"""
class MajorDomoClient(object):
    """Majordomo Protocol Client API, Python version.
    """
    broker = None
    ctx = None
    client = None
    poller = None
    timeout = 2500
    retries = 3
    verbose = False
    def __init__(self, broker, verbose=False):
        self.broker = broker
        self.verbose = verbose
        self.ctx = zmq.Context()
        self.poller = zmq.Poller()
        logging.basicConfig(format="%(asctime)s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",
                level=logging.INFO)
        self.reconnect_to_broker()
    def reconnect_to_broker(self):
        """Connect or reconnect to broker"""
        if self.client:
            self.poller.unregister(self.client)
            self.client.close()
        self.client = self.ctx.socket(zmq.REQ)
        self.client.linger = 0
        self.client.connect(self.broker)
    

        if self.verbose:
            logging.info("I: connecting to broker at %s...", self.broker)
    def send(self, service, request):
        """Send request to broker and get reply by hook or crook.
        Takes ownership of request message and destroys it when sent.
        Returns the reply message or None if there was no reply.
        """
        if not isinstance(request, list):
            request = [request]
        request = [MDP.C_CLIENT, service] + request
        if self.verbose:
            logging.warn("I: send request to '%s' service: ", service)
            dump(request)
        reply = None
        retries = self.retries
        while retries > 0:
            self.client.send_multipart(request)
            try:
                items = self.poller.poll(self.timeout)
            except KeyboardInterrupt:
            if items:
                msg = self.client.recv_multipart()
                if self.verbose:
                    logging.info("I: received reply:")
   
urlpatterns = patterns('plugins.filebrowser.views',
    url(r'^$', 'repositories', name='filebrowser_repositories'),
    url(r'^(?P<repository_name>[\w-]+)/$', 'root', name='filebrowser_root'),
    url({'en': r'^(?P<repository_name>[\w-]+)/listing/$',
         'es': r'^(?P<repository_name>[\w-]+)/listado/$'},
         'listing', name='filebrowser_root_listing'),
    url({'en': r'^(?P<repository_name>[\w-]+)/listing/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/listado/(?P<path>.*)$'},
         'listing', name="filebrowser_dir_listing"),
    url({'en': r'^(?P<repository_name>[\w-]+)/download/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/descargar/(?P<path>.*)$'},
         'download', name='filebrowser_download'),
    url({'en': r'^(?P<repository_name>[\w-]+)/upload/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/subir/(?P<path>.*)$'},
         'upload', name='filebrowser_upload'),
    url({'en': r'^(?P<repository_name>[\w-]+)/create/folder/(

         'es': r'^(?P<repository_name>[\w-]+)/crear/carpeta/(?P<path>.*)$'},
         'createdir', name='filebrowser_createdir'),
    url({'en': r'^(?P<repository_name>[\w-]+)/action/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/accion/(?P<path>.*)$'},
         'action', name='filebrowser_action'),
    url({'en': r'^(?P<repository_name>[\w-]+)/create/document/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/crear/documento/(?P<path>.*)$'},
         'createdoc', name='filebrowser_createdoc'),
    url({'en': ur'^(?P<repository_name>[\w-]+)/view/document/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$',
         'es': ur'^(?P<repository_name>[\w-]+)/ver/documento/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$'},
         'viewdoc', name='filebrowser_viewdoc'),
    url({'en': ur'^(?P<repository_name>[\w-]+)/edit/document/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$',
         'es': ur'^(?P<repository_name>[\w-]+)/editar/documento/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$'},
         'editdoc', name='f
__revision__ = "__FILE__ __REVISION__ __DATE__ __DEVELOPER__"
if sys.platform == 'win32':
    _exe = '.exe'
else:
    _exe = ''
test = TestSCons.TestSCons()
test.subdir('repository', ['repository', 'src'])
workpath_repository = test.workpath('repository')
repository_foo = test.workpath('repository', 'foo' + _exe)
repository_src_bar = test.workpath('repository', 'src', 'bar' + _exe)
test.write(['repository', 'SConstruct'], """
Repository(r'%s')
SConscript('src/SConscript')
env = Environment()
env.Program(target = 'foo', source = ['aaa.c', 'bbb.c', 'foo.c'])
""" % workpath_repository)
test.write(['repository', 'aaa.c'], r"""
void
aaa(void)
        printf("repository/aaa.c\n");
""")
test.write(['repository', 'bbb.c'], r"""
void
bbb(void)
        printf("repository/bbb.c\n");
""")
test.write(['repository', 'foo.c'], r"""
extern void aaa(void);
extern void bbb(void);
int
main(int argc, char *argv[])
        argv[argc++] = "--";
        aaa();
        bbb();
        printf("repository/foo.c\
'use restful api to monitor activemq broker'
__author__ = 'afred.lyj'
logHandler = TimedRotatingFileHandler("logfile.log",when="d", interval=1, backupCount=5)
logFormatter = logging.Formatter('%(asctime)s %(name)-12s %(levelname)-8s %(message)s')
logHandler.setFormatter(logFormatter)
logger = logging.getLogger('activemqMonitorLog')
logger.addHandler(logHandler)
logger.setLevel(logging.INFO)
username = 'admin'
password = 'admin'
mqList='192.168.1.101:8161:example.MyQueue,opaycenter_queue_notify_2000;192.168.1.102:8161:example.MyQueue,opaycenter_queue_notify_2000'
def parseMqList(mqList):
    li = mqList.split(';')
    l = list()
    for entry in li:
        d = dict()
        broker = entry.split(':')
        d['host'] = broker[0]
        d['port'] = broker[1]
        queues = broker[2].split(',')
        d['queues'] = queues
        l.append(d)
    return l
def httpGet(host,port,url,timeout=10):
    base64String = base64.encodestring('%s:%s' % (username, password))
    authHeader = 'Ba

    headers = {'Authorization': authHeader}
    try:
        conn = httplib.HTTPConnection(host,port=port,timeout=timeout)
        conn.request("GET",url, None, headers)
        response = conn.getresponse()
        if response.status == httplib.OK:
            data = response.read()
            return data
    except Exception, e:
        logger.error(e)
        return "";
def checkBrokerAttribute(host, port, attribute):
    uri = "/api/jolokia/read/org.apache.activemq:type=Broker,brokerName=localhost/" + attribute
    response = httpGet(host, port, uri)
    if response:
        result = json.loads(response)
        percent = result['value']
        if percent >= 10:
            print "alert : the usage of broker memory arrived %d" % percent
            return True
        else:
            print "everything is ok, haha"
            return False
    else:
        print "alert : mq broker is shutdown, please try to restart it"
        return True
def checkBroker(host, port):
    retur

def checkQueue(host, port, queueName):
    uri = "/api/jolokia/read/org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=%s/" % queueName
    response = httpGet(host, port, uri)
    if response:
        result = json.loads(response)
        values = result.get('value')
        queueSize = values.get('QueueSize')
        if queueSize > 10:
            print "current queue size is %d, need alert" % queueSize
        memoryPercentUsage = values.get('MemoryPercentUsage')
        if memoryPercentUsage > 10:
            print 'current queue memory percent usage %d, need alert' % memoryPercentUsage
    else:
        print 'no response from activemq broker, need alert'
if __name__=='__main__':
    logger.info("hello")
    l = parseMqList(mqList)
    for broker in l:
        brokerDown = checkBroker(broker['host'], int(broker['port']))
        if brokerDown:
            continue;
        queues = broker.get('queues')
        for queue in queues:
          
PKG = 'appctl'
NAME = 'test_proc_controller'
TEST_CMD = ['sleep', '5']
NUM_THREADS_TO_TEST = 8
class StateFlipper(threading.Thread):
    """Rapidly flips a controller between start() and stop() states"""
    def __init__(self, controller, iterations=100):
        super(StateFlipper, self).__init__()
        self.daemon = False
        self.controller = controller
        self.iterations = iterations
        self.failed = False
    def run(self):
        methods = [self.controller.start, self.controller.stop]
        for i in range(self.iterations):
            method = methods[i % 2]
            try:
                method()
            except:
                self.failed = True
                break
class TestProcController(unittest.TestCase):
    def setUp(self):
        self.controller = ProcController(TEST_CMD)
    def tearDown(self):
        self.controller.stop()
    def test_start_and_stop(self):
        self.assertFalse(self.controller.started,
                         'Control

        self.controller.start()
        self.assertTrue(self.controller.started,
                        'Controller must be started on start()')
        time.sleep(0.1)
        watcher = self.controller.watcher
        self.assertTrue(watcher.is_alive(),
                        'Process watcher must be alive while started')
        self.controller.stop()
        self.assertFalse(self.controller.started,
                         'Controller must not be started after stop()')
        watcher.join()
        self.assertFalse(watcher.is_alive(),
                         'Process watcher must not be alive after joined')
    def test_concurrency(self):
        flippers = [StateFlipper(self.controller) for i in range(NUM_THREADS_TO_TEST)]
        map(lambda f: f.start(), flippers)
        map(lambda f: f.join(), flippers)
        self.assertFalse(any([f.failed for f in flippers]))
    def test_redundant_start(self):
        self.controller.start()
        watcher = self.controller.watcher
  

        self.assertIs(watcher, self.controller.watcher,
                      'Stray process watcher on redundant start')
    def test_respawn_flag_forward_to_runner(self):
        """
        Test forwarding of the respawn flag setting and associated
        behaviour. Both for True (default value) and False from the
        higher-lever proc_controller POV.
        """
        self.assertTrue(self.controller.respawn, "The 'respawn' flag is by default True.")
        self.controller.start()
        self.assertTrue(self.controller.watcher.respawn, "The 'respawn' flag is by default True.")
        self.controller.stop()
        time.sleep(0.1)
        self.controller = ProcController(TEST_CMD, respawn=False)
        self.assertFalse(self.controller.respawn, "The 'respawn' flag is False now.")
        self.controller.start()
        self.assertFalse(self.controller.watcher.respawn, "The 'respawn' flag is False now.")
        self.controller.stop()
        time.sleep(0.1)
class TestClean
                    tan)
unset_show()
def tmp_file(name=''):
    return NamedTemporaryFile(suffix='.png').name
def plot_and_save():
    x = Symbol('x')
    y = Symbol('y')
    z = Symbol('z')
    plot_implicit(Eq(y, cos(x)), (x, -5, 5), (y, -2, 2)).save(tmp_file())
    plot_implicit(Eq(y**2, x**3 - x), (x, -5, 5),
            (y, -4, 4)).save(tmp_file())
    plot_implicit(y > 1 / x, (x, -5, 5),
            (y, -2, 2)).save(tmp_file())
    plot_implicit(y < 1 / tan(x), (x, -5, 5),
            (y, -2, 2)).save(tmp_file())
    plot_implicit(y >= 2 * sin(x) * cos(x), (x, -5, 5),
            (y, -2, 2)).save(tmp_file())
    plot_implicit(y <= x**2, (x, -3, 3),
            (y, -1, 5)).save(tmp_file())
    plot_implicit(Eq(y**2, x**3 - x)).save(tmp_file())
    plot_implicit(Eq(y**2, x**3 - x), adaptive=False).save(tmp_file())
    plot_implicit(Eq(y**2, x**3 - x), adaptive=False, points = 500).save(tmp_file())
    plot_implicit(y > x, (x, -5, 5)).save(tmp_file())
    plot_implicit(And(y > exp(
ZkKafkaBroker = namedtuple('ZkKafkaBroker', ['id', 'host', 'port'])
ZkKafkaSpout = namedtuple('ZkKafkaSpout', ['id', 'partitions'])
ZkKafkaTopic = namedtuple('ZkKafkaTopic', ['topic', 'broker', 'num_partitions'])
class ZkError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg
class ZkClient:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.client = KazooClient(hosts=':'.join([host, str(port)]))
    @classmethod
    def _zjoin(cls, e):
        return '/'.join(e)
    def brokers(self, broker_root='/brokers'):
        '''
        Returns a list of ZkKafkaBroker tuples, where each value is a
        ZkKafkaBroker.
        '''
        b = []
        id_root = self._zjoin([broker_root, 'ids'])
        self.client.start()
        try:
            for c in self.client.get_children(id_root):
                n = self.client.get(self._zjoin([id_root, c]))[0]
                b.append(ZkKa

        except NoNodeError:
            raise ZkError('Broker nodes do not exist in Zookeeper')
        self.client.stop()
        return b
    def topics(self, broker_root='/brokers'):
        '''
        Returns a list of ZkKafkaTopic tuples, where each tuple represents
        a topic being stored in a broker.
        '''
        topics = []
        t_root = self._zjoin([broker_root, 'topics'])
        self.client.start()
        try:
            for t in self.client.get_children(t_root):
                for b in self.client.get_children(self._zjoin([t_root, t])):
                    n = self.client.get(self._zjoin([t_root, t, b]))[0]
                    topics.append(ZkKafkaTopic._make([t, b, n]))
        except NoNodeError:
            raise ZkError('Topic nodes do not exist in Zookeeper')
        self.client.stop()
        return topics
    def spouts(self, spout_root, topology):
        '''
        Returns a list of ZkKafkaSpout tuples, where each tuple represents
        a Sto
class NullHandler(logging.Handler):
    def emit(self, record):
        pass
logger = logging.getLogger('kafka.codec').addHandler(NullHandler())
class ProcessorError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg
PartitionState = namedtuple('PartitionState',
    [
    ])
PartitionsSummary = namedtuple('PartitionsSummary',
    [
    ])
def process(spouts):
    '''
    Returns a named tuple of type PartitionsSummary.
    '''
    results = []
    total_depth = 0
    total_delta = 0
    brokers = []
    for s in spouts:
        for p in s.partitions:
            try:
                k = KafkaClient(p['broker']['host']+":"+str(p['broker']['port']))
            except socket.gaierror, e:
                raise ProcessorError('Failed to contact Kafka broker %s (%s)' %
                                     (p['broker']['host'], str(e)))
            
	    earliest_off = OffsetRequest(str(p['topic']), p['partition'], -2, 1)
          
class TestMessages(unittest.TestCase):
    def setUp(self):
        self.location_a = Location(5, 3)
        self.node_a = Node(node_id="1", location=self.location_a)
        self.arguments_a = {'arg_1':1, 'arg_2':2, 'arg_3':3}
        self.message_a = Message(sender=self.node_a, emit_location=self.location_a, \
                                          function_to_call=self.an_example_function, arguments=self.arguments_a)
        self.location_b = Location(1, 2)
        self.message_b = Message(sender=self.node_a, emit_location=self.location_b, \
                                          function_to_call=self.an_example_function, arguments=self.arguments_a)
        self.message_broker = MessageBroker()
    def test_message_to_be_transmitted_list_empty(self):
        self.assert_(self.message_broker.still_msgs_to_be_transmitted())
        self.message_broker.add_to_be_transmitted(self.message_a)
        self.assertFalse(self.message_broker.still_msgs_to_be_transmitted())
        messag

        self.assertTrue(message)
        self.assertTrue(self.message_broker.still_msgs_to_be_transmitted())
    def test_message_to_transmitt_addition_and_get(self):
        self.message_broker.add_to_be_transmitted(self.message_a)
        message = self.message_broker.get_message_to_be_transmitted()
        self.assertEqual(message, self.message_a)
        self.message_broker.add_to_be_transmitted(self.message_b)
        message = self.message_broker.get_message_to_be_transmitted()
        self.assertEqual(message, self.message_b)
    def test_asynchronous_message_reset(self):
        self.assert_(self.message_broker.still_msgs_to_be_transmitted())
        self.message_broker.add_to_be_transmitted(self.message_a)
        self.assertFalse(self.message_broker.still_msgs_to_be_transmitted())
        self.message_broker.add_to_be_transmitted(self.message_b)
        message = self.message_broker.get_message_to_be_transmitted()
        self.assertEqual(message, self.message_b)
        sel

        self.assertTrue(self.message_broker.still_msgs_to_be_transmitted())
    def test_direct_message(self):
        node_b = Node(node_id="2", location=self.location_b)
        destination_list = [node_b.id]
        direct_message = DirectMessage(sender=self.node_a, emit_location=self.location_a, function_to_call=self.an_example_function,
                                                     arguments={}, destination_list=destination_list)
        self.assertEqual(direct_message.destination_list, destination_list)
        ret = direct_message.run(all_nodes={self.node_a.id:self.node_a, node_b.id:node_b}, plane=None)
        self.assertFalse(ret['messages'])
        self.assertFalse(ret['asynchronous'])
        self.assertFalse(ret['simulator'])
    def test_broadcast_message(self):
        destination_list = [2]
        node_with_power = Node(node_id="1", location=self.location_a, power=10)
        broadcast_message = BroadcastMessage(sender=node_with_power, emit_location=self.locati
admin.autodiscover()
urlpatterns = patterns('',
	url(r'^api-copa/register-push-device/$', 'planeta_brasil.api_copa.views.register_push_device', name='register_push_device'),
	url(r'^api/news/$', 'planeta_brasil.api_copa.views.api_news', name='api_news'),
	url(r'^api/news/(?P<pk>\d)/$', 'planeta_brasil.api_copa.views.api_news_detail', name='api_news_detail'),
	url(r'^api/photos/$', 'planeta_brasil.api_copa.views.api_photos', name='api_photos'),
	url(r'^api/guesses/$', 'planeta_brasil.api_copa.views.api_guesses', name='api_guesses'),
    
	url(r'^api/venue/(?P<pk>\d)/$', 'planeta_brasil.api_copa.views.api_venue_detail', name='api_venue_detail'),
	url(r'^api/matches_by_groups/$', 'planeta_brasil.api_copa.views.api_matches_by_groups', name='api_matches_by_groups'),
	url(r'^api/last_games/$', 'planeta_brasil.api_copa.views.api_last_games', name='api_last_games'),
	url(r'^api/finals/$', 'planeta_brasil.api_copa.views.api_finals', name='api_finals'),
	url(r'^api/home/$', 'planeta_brasil.api_c
TOP_CLASSES = (
    Management.Tabs,
    Management.Navigation,
    ObjectManager.ObjectManager,
    SimpleItem.Item,
MAINS = (
    'manage',
    'manage_main',
    'manage_menu',
    'manage_top_frame',
    'manage_page_header',
    'manage_page_footer',
    'manage_workspace',
OTHERS = (
    'manage_pack',
    'manage_components',
    'manage_propertiesForm',
    'manage_access',
    'manage_UndoForm',
    'manage_interfaces',
    'manage_findForm',
    'manage_owner',
    'manage_search',
BLACK_LIST = (
    'manage_afterAdd',
    'manage_addProduct',
    'manage_upload',
    'manage_delObjects',
    'manage_properties',
    'manage_editDiffFields',
    'manage_reindexIndex',
    'manage_setTypePolicies',
    'manage_updateProtocolMapping',
    'manage_updateProtocolMapping',
    'manage_activateInterfaces',
    'manage_addPolicy',
    'manage_editProps',
    'manage_setLanguageSettings',
DISCOVERED = set()
def patch_zmi():
    pass
zmi.patch_zmi = patch_zmi
OPTION = {'label': 'Conte

def fake_manage(instance):
    """no more"""
    return "no more zmi"
def del_manage_(klass):
    for name in MAINS:
        if hasattr(klass, name):
            setattr(klass, name, fake_manage)
    for name in OTHERS:
        if hasattr(klass, name):
            try:
                delattr(klass, name)
            except AttributeError:
                pass
    if hasattr(klass, 'manage_options'):
        klass.manage_options = (OPTION,)
    members = klass.__dict__.keys()
    for name in members:
        if name.startswith('manage_'):
            if name == 'manage_options':
                continue
            if name in MAINS:
                continue
            if name in OTHERS:
                continue
            if name.endswith('__roles__'):
                continue
            if name in BLACK_LIST:
                continue
            if not hasattr(klass, name):
                continue
            DISCOVERED.add(name)
            try:
                delattr(klass, na
WEB_SERVER_PORT = 80
settings = {
    "resources_path": os.path.join(os.path.dirname(__file__), "resources"),
    "template_path": os.path.join(os.path.dirname(__file__), "pages"),
    "cookie_secret": "61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=",
    "xsrf_cookies": False,
    "debug" : True
application = tornado.web.Application([
    (r"/resources/(.*)", tornado.web.StaticFileHandler, dict(path=settings['resources_path'])),
    (r"/forend/(\w*)", ForendDefaultController),
    (r"/forend/myCenter/(\w*)", ForendMyCenterController),
    (r"/forend/roomBooking/(\w*)", ForendRoomBookingController),
    (r"/forend/mealBooking/(\w*)", ForendMealBookingController),
    (r"/backend/(\w*)", BackendDefaultController),
    (r"/backend/customer/(\w*)", BackendCustomerController),
    (r"/backend/room/(\w*)", BackendRoomController),
    (r"/backend/cleanTask/(\w*)", BackendCleanTaskController),
    (r"/backend/employee/(\w*)", BackendEmployeeController),
    (r"/backend/roomBooking/(\w*)", Backe
members_api = Api(api_name='members')
members_api.register(UserResource())
members_api.register(MemberResource())
members_api.register(PortalResource())
turbines_api = Api(api_name='turbines')
turbines_api.register(TurbineResource())
turbines_api.register(TurbineDataResource())
solarcells_api = Api(api_name='solarcells')
solarcells_api.register(SolarcellResource())
solarcells_api.register(SolarcellDataResource())
service_api = Api(api_name='service')
service_api.register(ServiceConfResource())
report_api = Api(api_name='report')
report_api.register(ReportResource())
admin.autodiscover()
urlpatterns = patterns('',
                       url(r'^$', TemplateView.as_view(template_name='index.jade')),
                       url(r'^api/', include(members_api.urls)),
                       url(r'^api/', include(service_api.urls)),
                       url(r'^api/', include(report_api.urls)),
                       url(r'^api/', include(turbines_api.urls)),
                       url(r'^api/
routes = [Endpoint('/', get=HTMLController('Server/templates/index.html')),
          Endpoint('/api/game/<int:gameId>', get=GetGameController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>', get=GetGameForPlayerController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/activate', post=ActivateCardController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/buy', post=BuyCardController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/choose', post=ChooseController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/defend', post=DefendController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/endturn', post=EndTurnController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/pickcard', post=PickCardController()),
          Endpoint('/api/game/<int:gameId>/player/<int:playerId>/play', post=PlayCardController()),
          Endpoint('/api/game/<int:game

          Endpoint('/api/lobbies', get=GetLobbiesController(), post=NewLobbyController()),
          Endpoint('/api/lobbies/<int:lobbyId>', get=GetLobbyController()),
          Endpoint('/api/lobbies/<int:lobbyId>/join', post=JoinLobbyController()),
          Endpoint('/api/lobbies/<int:lobbyId>/start', post=StartGameController()),
          Endpoint('/api/lobbies/<int:lobbyId>/player/<int:playerId>', get=GetLobbyForPlayerController()),
          Endpoint('/api/lobbies/<int:lobbyId>/player/<int:playerId>/changecharacter', post=ChangeCharacterController()),
          Endpoint('/api/lobbies/<int:lobbyId>/player/<int:playerId>/changename', post=ChangeNameController()),
          Endpoint('/api/lobbies/<int:lobbyId>/player/<int:playerId>/changedeck', post=ChangeDeckForRoleController()),
          Endpoint('/api/lobbies/<int:lobbyId>/player/<int:playerId>/changenumberofvillains', post=ChangeNumberOfVillainsController()),
          Endpoint('/api/characters', get=GetCharactersController()),
"""
Basic Unit tests for Chandler repository
"""
__revision__  = "$Revision$"
__date__      = "$Date$"
__copyright__ = "Copyright (c) 2003-2004 Open Source Applications Foundation"
__license__   = "http://osafoundation.org/Chandler_0.1_license_terms.htm"
class TestRepositoryBasic(unittest.TestCase):
    """ Very basic repository tests """
    def _repositoryExists(self):
        try:
            self.rep.open()
            self.fail()
        except DBNoSuchFileError:
            pass
        except RepositoryOpenDeniedError:
            pass
    def setUp(self):
        self.rootdir = os.environ['CHANDLERHOME']
        self.testdir = os.path.join(self.rootdir, 'repository',
                                    'tests')
        self.rep = DBRepository(os.path.join(self.testdir, '__repository__'))
    def testNonExistent(self):
        """ The repository should not exist at this point """
        self.assert_(not self._repositoryExists())
    def testCreate(self):
        """ Create a re

        util.timing.reset()
        util.timing.begin("repository.TestRepositoryBasic.testCreate")
        self.rep.create()
        util.timing.end("repository.TestRepositoryBasic.testCreate")
        util.timing.results(verbose=False)
        self.assert_(self.rep.check())
        self.assert_(self.rep.isOpen())
    def testDestroy(self):
        """ Create and then delete a repository, verify it doesn't exist """
        self.rep.create()
        self.rep.close()
        self.rep.delete()
        self.assert_(not self._repositoryExists())
    def testLoadPack(self):
        """ Minimal test to ensure that we can load packs
TODO is there more pack testing we need to do?
        """
        self.rep.create()
        self.assert_(self.rep.check())
        util.timing.reset()
        util.timing.begin("repository.TestRepositoryBasic.testLoadPack")
        self.rep.getCurrentView()
        util.timing.end("repository.TestRepositoryBasic.testLoadPack")
        util.timing.results(verbose
""" Views for Person, Name, and Surname """
dji = DjangoInterface()
    """
    Process act on person. Can return a redirect.
    """
    context["tview"] = _("Repository")
    context["tviews"] = _("Repositories")
    context["action"] = "view"
    view_template = "view_repository_detail.html"
    
    if handle == "add":
        act = "add"
    if request.POST.has_key("action"):
        act = request.POST.get("action")
    if act == "share":
        item, handle = add_to
        context["pickform"] = PickForm("Pick repository", 
                                       Repository, 
                                       (),
                                       request.POST)     
        context["object_handle"] = handle
        context["object_type"] = item
        return render_to_response("pick.html", context)
    elif act == "save-share":
        item, handle = add_to 
        pickform = PickForm("Pick repository", 
                            Repository, 
                        

                            request.POST)
        if pickform.data["picklist"]:
            ref_handle = pickform.data["picklist"]
            ref_obj = Repository.objects.get(handle=ref_handle) 
            dji.add_repository_ref_default(parent_obj, ref_obj)
        else:
            context["pickform"] = pickform
            context["object_handle"] = handle
            context["object_type"] = item
            return render_to_response("pick.html", context)
    elif act == "add":
        repository = Repository(gramps_id=dji.get_next_id(Repository, "R"))
        repositoryform = RepositoryForm(instance=repository)
        repositoryform.model = repository
    elif act in ["view", "edit"]: 
        repository = Repository.objects.get(handle=handle)
        repositoryform = RepositoryForm(instance=repository)
        repositoryform.model = repository
    elif act == "save": 
        repository = Repository.objects.get(handle=handle)
        repositoryform = RepositoryForm(request.POS

        repositoryform.model = repository
        if repositoryform.is_valid():
            update_last_changed(repository, request.user.username)
            repository = repositoryform.save()
            dji.rebuild_cache(repository)
            act = "view"
        else:
            act = "edit"
    elif act == "create": 
        repository = Repository(handle=create_id())
        repositoryform = RepositoryForm(request.POST, instance=repository)
        repositoryform.model = repository
        if repositoryform.is_valid():
            update_last_changed(repository, request.user.username)
            repository = repositoryform.save()
            dji.rebuild_cache(repository)
            if add_to:
                item, handle = add_to
                model = dji.get_model(item)
                obj = model.objects.get(handle=handle)
                dji.add_repository_ref_default(obj, repository)
                dji.rebuild_cache(obj)
            act = "view"
        else:
       
'''
Created on Oct 20, 2015
@author: sum
'''
class Test(unittest.TestCase):
    def test100_010_ShouldConstruct(self):
        self.assertIsInstance(Controller.Controller(), Controller.Controller)
    def test200_010_ShouldInitializeWithArchitectureFile(self):
        myController = Controller.Controller()
        architectureFile = "file.xml"
        result = ['Device', 'StarSensor']
        self.assertEquals(myController.initialize(architectureFile), result) 
        
    def test200_020_ShouldInitializeWithArchitectureFileReturnEmptyList(self):
        myController = Controller.Controller()
        architectureFile = "file2.xml"
        self.assertEquals(myController.initialize(architectureFile), [])    
        
    def test200_030_ShouldInitializeWithNewArchitectureFile(self):
        myController = Controller.Controller()
        architectureFile = "file3.xml"
        result = ['Device', 'StarSensor', 'SolarCollector']
        self.assertEquals(myController.initialize(architectur

        
    def test200_910ShouldRaiseExceptionOnIncorrectFileName(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile="Xfile.xml") 
    
    def test200_920ShouldRaiseExceptionOnIncorrectFileExtension(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile="file.csv")     
            
    def test200_930ShouldRaiseExceptionOnFileNameLessThanOne(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile=".xml")     
     
    def test200_940ShouldRaiseExceptionOnMissingFileName(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize()                   
    def test2

        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile=2)
    
    def test200_960ShouldRaiseExceptionOnFileEmpty(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile="Empty.xml")
            
    def test200_970ShouldRaiseExceptionOnInvalidRateData(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile="invalid1.xml")
            
    def test200_980ShouldRaiseExceptionOnInvalidDeviceType(self):
        with self.assertRaises(ValueError) as context:
            myController = Controller.Controller()
            myController.initialize(architectureFile="invalid2.xml")    
    
    def test200_990ShouldRaiseExceptionOnInvalidDeviceName(self):
        with self.ass
class RevisionTest(TestCase):
    sha = '73a5e15bc8a67024ba0d989d28731605ad83144c'
    sha_similiar = '73a5e15bc8a67024ba0d989d28731605ad83144d'
    def _create_repository(self):
        return Repository(
            url='http://example.com/git-repo',
            backend=RepositoryBackend.git,
        )
    def test_prefix_prefix(self):
        repository = self._create_repository()
        revision = self.create_revision(repository=repository, sha=self.sha)
        assert Revision.get_by_sha_prefix_query(repository.id, '73a5').scalar() == revision
    def test_prefix_full(self):
        repository = self._create_repository()
        revision = self.create_revision(repository=repository, sha=self.sha)
        assert Revision.get_by_sha_prefix_query(repository.id, self.sha).scalar() == revision
    def test_prefix_ambiguous(self):
        repository = self._create_repository()
        revision_1 = self.create_revision(repository=repository, sha=self.sha)
        revision_2 = self.creat
"""
This module contains the main TurboGears Controller implementation.
"""
class TGController(DecoratedController, ObjectDispatcher):
    """
    TGController is a specialized form of ObjectDispatchController that forms the
    basis of standard TurboGears controllers.  The "Root" controller of a standard
    tg project must be a TGController.
    This controller can be used as a baseclass for anything in the
    object dispatch tree, but it MUST be used in the Root controller
    and any controller which you intend to do object dispatch from
    using Routes.
    This controller has a few reserved method names which provide special functionality.
    +-----------------+--------------------------------------------------------------+--------------------------------------------+
    | Method          | Description                                                  | Example URL(s)                             |
    +=================+========================================================

    | index           | The root of the controller.                                  | /                                          |
    +-----------------+--------------------------------------------------------------+--------------------------------------------+
    | default         | A method to call when all other methods have failed.         | /movies                                    |
    +-----------------+--------------------------------------------------------------+--------------------------------------------+
    | lookup          | Allows the developer to return a                             | /location/23.35/2343.34/elevation          |
    |                 | Controller instance for further dispatch.                    |                                            |
    +-----------------+--------------------------------------------------------------+--------------------------------------------+
    :References:
      `Controller <../main/Controllers.html>`_  A basic ov
"""Dispatch from command-line arguments to functions."""
__all__ = ('dispatch', 'DispatchError')
__author__ = 'Vladimir Keleshev <vladimir@keleshev.com>'
__version__ = '0.0.2'
__license__ = 'MIT'
__keywords__ = 'docopt dispatch function adapter kwargs'
__url__ = 'https://github.com/halst/docopt-dispatch'
class DispatchError(Exception):
    pass
class Dispatch(object):
    def __init__(self):
        self._functions = OrderedDict()
    def on(self, *patterns):
        def decorator(function):
            self._functions[patterns] = function
            return function
        return decorator
    def __call__(self, *args, **kwargs):
        arguments = docopt(*args, **kwargs)
        for patterns, function in self._functions.items():
            if all(arguments[pattern] for pattern in patterns):
                function(**self._kwargify(arguments))
                return
        raise DispatchError('None of dispatch conditions %s is triggered'
                            % self._format
urlpatterns = patterns('',
    url(r'^$', views.index, name = 'index'),
    url(r'^api/user/new/',      api.new_user, name = 'new user'),
    url(r'^api/user/login/',    api.login, name = 'login'),
    url(r'^api/user/',          api.user_info, name = 'list user info'),
    url(r'^api/game/new/',      api.new_game, name = 'new game'),
    url(r'^api/game/join/',     api.join_game, name = 'join game'),
    url(r'^api/game/rules/',    api.rules, name= 'game rules'),
    url(r'^api/game/start/',    api.start_game, name = 'start game'),
    url(r'^api/game/leave/',    api.leave_game, name = 'leave game'),
    url(r'^api/game/list/',     api.list_games, name= 'list games/players'),
    url(r'^api/game/',          api.game_info, name = 'game info'),  
    url(r'^api/role/wolves/',   api.list_wolves, name = 'list wolves'),
    url(r'^api/role/kill/',     api.kill, name = 'kill'),
    url(r'^api/role/vote/',     api.vote, name = 'vote'),
    url(r'^api/role/location/', api.report_position, nam
try:
except:
class TestControllerPlugin(unittest.TestCase):
    def test_make_cache_controllerplugin_factory(self):
        controller = DummyController()
        plugin = controllerplugin.make_cache_controllerplugin(controller)
        self.assertEqual(controller, plugin.ctl)
    def test_ctor_assigns_controller(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        self.assertEqual(controller, plugin.ctl)
    def test_do_cache_clear(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        cache_interface = plugin.cache
        cache_interface.cache = dict(foo='bar')
        plugin.do_cache_clear('')
        self.assertEqual({}, cache_interface.cache)
    def test_do_cache_clear_accepts_no_args(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        plugin.do_cache_clear('arg')
        out = controller.sio.getvalue()
        self.assertTrue(out.startswith('cache_clea

    def test_help_cache_clear(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        plugin.help_cache_clear()
        out = controller.sio.getvalue()
        self.assertTrue(out.startswith('cache_clear'))
    def test_do_cache_count(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        cache_interface = plugin.cache
        cache_interface.cache = dict(foo='bar', baz='qux')
        plugin.do_cache_count('')
        output = controller.sio.getvalue()
        self.assertEqual('2', output)
    def test_do_cache_count_accepts_no_args(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        plugin.do_cache_count('arg')
        out = controller.sio.getvalue()
        self.assertTrue(out.startswith('cache_count'))
    def test_help_cache_count(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        plugin.help_cache_count()
       

        self.assertTrue(out.startswith('cache_count'))
    def test_do_cache_delete(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        cache_interface = plugin.cache
        cache_interface.cache = dict(foo='bar', baz='qux')
        plugin.do_cache_delete('foo')
        self.assertTrue('foo' not in cache_interface.cache.keys())
        self.assertEqual('qux', cache_interface.cache['baz'])
    def test_do_cache_delete_accepts_a_quoted_arg(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        cache_interface = plugin.cache
        cache_interface.cache = {'f o o': 'bar', 'baz': 'qux'}
        plugin.do_cache_delete('"f o o"')
        self.assertTrue('f o o' not in cache_interface.cache.keys())
    def test_do_cache_delete_accepts_only_one_arg(self):
        controller = DummyController()
        plugin = self.makeOne(controller)
        plugin.do_cache_delete('first second')
        out = controller.s
def register_repository(name, host, offering_collection, resource_collection, api_version, default=False):
    """
    Register a new repository in WStore, these repositories will be used for the storage
    of the USDL descriptions of offerings and resources
    """
    if host[-1] != '/':
        host += '/'
    if len(Repository.objects.filter(name=name) | Repository.objects.filter(host=host)) > 0:
        raise ConflictError('The given repository is already registered')
    if default:
        _unset_default()
    elif len(Repository.objects.all()) == 0:
        default = True
    Repository.objects.create(
        name=name,
        host=host,
        offering_collection=offering_collection,
        resource_collection=resource_collection,
        api_version=api_version,
        is_default=default
    )
def _get_repository(repository):
    rep = None
    try:
        rep = Repository.objects.get(name=repository)
    except:
        raise ObjectDoesNotExist('The specified reposito

    return rep
def _unset_default():
    def_rep = Repository.objects.filter(is_default=True)
    for rep in def_rep:
        rep.is_default = False
        rep.save()
def unregister_repository(repository):
    """
    Unregisters a repository from WStore
    """
    rep = _get_repository(repository)
    rep.delete()
    if rep.is_default:
        repos = Repository.objects.all()
        if len(repos) > 0:
            repos[0].is_default = True
            repos[0].save()
def get_repositories():
    repositories = Repository.objects.all()
    response = []
    for rep in repositories:
        response.append({
            'name': rep.name,
            'host': rep.host,
            'is_default': rep.is_default,
            'offering_collection': rep.offering_collection,
            'resource_collection': rep.resource_collection,
            'api_version': rep.api_version
        })
    return response
def set_default_repository(repository):
    rep = _get_repository(repository)
    _un
DB_SHARED_THREAD = """\
DatabaseWrapper objects created in a thread can only \
be used in that same thread.  The object with alias '{0}' \
was created in thread id {1} and this is thread id {2}.\
"""
VALIDATE_MODELS = not django.VERSION >= (1, 7)
def patch_thread_ident():
    if getattr(patch_thread_ident, 'called', False):
        return
    try:
        if 'validate_thread_sharing' in BaseDatabaseWrapper.__dict__:
            _get_ident = thread.get_ident
            __old__init__ = BaseDatabaseWrapper.__init__
            def _init(self, *args, **kwargs):
                __old__init__(self, *args, **kwargs)
                self._thread_ident = _get_ident()
            def _validate_thread_sharing(self):
                if (not self.allow_thread_sharing and
                        self._thread_ident != _get_ident()):
                    raise DatabaseError(
                        DB_SHARED_THREAD % (
                            self.alias, self._thread_ident, _get_ident()),
        

            BaseDatabaseWrapper.__init__ = _init
            BaseDatabaseWrapper.validate_thread_sharing = \
                _validate_thread_sharing
        patch_thread_ident.called = True
    except ImportError:
        pass
patch_thread_ident()
class CeleryCommand(BaseCommand):
    options = BaseCommand.option_list
    skip_opts = ['--app', '--loader', '--config', '--no-color']
    requires_model_validation = VALIDATE_MODELS
    keep_base_opts = False
    stdout, stderr = sys.stdout, sys.stderr
    def get_version(self):
        return 'celery {c.__version__}\ndjango-celery {d.__version__}'.format(
            c=celery, d=djcelery,
        )
    def execute(self, *args, **options):
        broker = options.get('broker')
        if broker:
            self.set_broker(broker)
        super(CeleryCommand, self).execute(*args, **options)
    def set_broker(self, broker):
        setenv('CELERY_BROKER_URL', broker)
    def run_from_argv(self, argv):
        self.handle_default_options(

        return super(CeleryCommand, self).run_from_argv(argv)
    def handle_default_options(self, argv):
        acc = []
        broker = None
        for i, arg in enumerate(argv):
            if '--settings=' in arg:
                _, settings_module = arg.split('=')
                setenv('DJANGO_SETTINGS_MODULE', settings_module)
            elif '--pythonpath=' in arg:
                _, pythonpath = arg.split('=')
                sys.path.insert(0, pythonpath)
            elif '--broker=' in arg:
                _, broker = arg.split('=')
            elif arg == '-b':
                broker = argv[i + 1]
            else:
                acc.append(arg)
        if broker:
            self.set_broker(broker)
        return argv if self.keep_base_opts else acc
    def die(self, msg):
        sys.stderr.write(msg)
        sys.stderr.write('\n')
        sys.exit()
    def _is_unwanted_option(self, option):
        return option._long_opts and option._long_opts[0] in self.skip_opt
io.use_plugin('pil')
priority_plugin = 'pil'
def setup_module():
def teardown_module():
    io.reset_plugins()
@contextmanager
def protect_preferred_plugins():
    """Contexts where `preferred_plugins` can be modified w/o side-effects."""
    preferred_plugins = manage_plugins.preferred_plugins.copy()
    try:
        yield
    finally:
        manage_plugins.preferred_plugins = preferred_plugins
def test_read():
    io.imread('test.png', as_grey=True, dtype='i4', plugin='test')
def test_save():
    io.imsave('test.png', [1, 2, 3], plugin='test')
def test_show():
    io.imshow([1, 2, 3], plugin_arg=(1, 2), plugin='test')
def test_collection():
    io.imread_collection('*.png', conserve_memory=False, plugin='test')
def test_use():
    manage_plugins.use_plugin('test')
    manage_plugins.use_plugin('test', 'imshow')
@raises(ValueError)
def test_failed_use():
    manage_plugins.use_plugin('asd')
def test_use_priority():
    manage_plugins.use_plugin(priority_plugin)
    plug, func = manag

    assert_equal(plug, priority_plugin)
    manage_plugins.use_plugin('test')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'test')
def test_use_priority_with_func():
    manage_plugins.use_plugin('pil')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'pil')
    manage_plugins.use_plugin('test', 'imread')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'test')
    plug, func = manage_plugins.plugin_store['imsave'][0]
    assert_equal(plug, 'pil')
    manage_plugins.use_plugin('test')
    plug, func = manage_plugins.plugin_store['imsave'][0]
    assert_equal(plug, 'test')
def test_plugin_order():
    p = io.plugin_order()
    assert 'imread' in p
    assert 'test' in p['imread']
def test_available():
    assert 'qt' in io.available_plugins
    assert 'test' in io.find_available_plugins(loaded=True)
def test_load_preferred_plugins_all():
    with protect_preferred_plugins():
        mana
class MainController():
	main_interface_controller = None
	telnet_controller = None
	melted_telnet_polling_controller = None
	initialise_units_controller = None
	units_controller = None
	playlist_controller = None
	loaded = False
	def __init__(self):
		GObject.threads_init()
		self.telnet_controller = MeltedTelnetController(Smelted_Settings.HOST, Smelted_Settings.PORT)
		self.melted_telnet_polling_controller = MeltedTelnetPollingController(Smelted_Settings.HOST, Smelted_Settings.PORT)
		self.main_interface_controller = MainInterfaceController(self, self.telnet_controller)
		main_interface_controller = MainInterfaceView.MainInterfaceView(self.main_interface_controller)
		self.initialise_units_controller = InitialiseUnitsController(self, self.telnet_controller, self.on_loaded_from_telnet)
		self.playlist_file_controller = PlaylistFileController(self, self.telnet_controller)
		self.units_controller = UnitsController(self, self.telnet_controller)
		self.start_load_wait()
	def start_load_wa
def create_app(cnf):
    app = Flask(__name__)
    app.config.from_object(cnf)
    db.init_app(app)
    api = Api(app)
    api.add_resource(UserList, '/api/v1.0/user', '/api/v1.0/user/')
    api.add_resource(UserResource, '/api/v1.0/user/<user_id>')
    api.add_resource(Login, '/api/v1.0/login', '/api/v1.0/login/')
    api.add_resource(BuildingList, '/api/v1.0/building', '/api/v1.0/building/')
    api.add_resource(BuildingResource, '/api/v1.0/building/<building_id>')
    api.add_resource(FloorList, '/api/v1.0/floor', '/api/v1.0/floor/')
    api.add_resource(FloorResource, '/api/v1.0/floor/<floor_id>')
    api.add_resource(RoomList, '/api/v1.0/room', '/api/v1.0/room/')
    api.add_resource(RoomResource, '/api/v1.0/room/<room_id>')
    api.add_resource(DeviceList, '/api/v1.0/device', '/api/v1.0/device/')
    api.add_resource(DeviceResource, '/api/v1.0/device/<device_id>')
    api.add_resource(dList, '/api/v1.0/data', '/api/v1.0/data/')
    api.add_resource(DataResource, '/api/v1.0/data/<
"""
Migration script to add the repository_dependency and repository_repository_dependency_association tables.
"""
now = datetime.datetime.utcnow
log = logging.getLogger( __name__ )
log.setLevel( logging.DEBUG )
handler = logging.StreamHandler( sys.stdout )
format = "%(name)s %(levelname)s %(asctime)s %(message)s"
formatter = logging.Formatter( format )
handler.setFormatter( formatter )
log.addHandler( handler )
metadata = MetaData( migrate_engine )
RepositoryDependency_table = Table( "repository_dependency", metadata,
    Column( "id", Integer, primary_key=True ),
    Column( "create_time", DateTime, default=now ),
    Column( "update_time", DateTime, default=now, onupdate=now ),
    Column( "tool_shed_repository_id", Integer, ForeignKey( "tool_shed_repository.id" ), index=True, nullable=False ) )
RepositoryRepositoryDependencyAssociation_table = Table( "repository_repository_dependency_association", metadata,
    Column( "id", Integer, primary_key=True ),
    Column( "create_time", D

    Column( "update_time", DateTime, default=now, onupdate=now ),
    Column( "tool_shed_repository_id", Integer, ForeignKey( "tool_shed_repository.id" ), index=True ),
    Column( "repository_dependency_id", Integer, ForeignKey( "repository_dependency.id" ), index=True ) )
def upgrade():
    print __doc__
    metadata.reflect()
    try:
        RepositoryDependency_table.create()
    except Exception, e:
        log.debug( "Creating repository_dependency table failed: %s" % str( e ) )
    try:
        RepositoryRepositoryDependencyAssociation_table.create()
    except Exception, e:
        log.debug( "Creating repository_repository_dependency_association table failed: %s" % str( e ) )
def downgrade():
    metadata.reflect()
    try:
        RepositoryRepositoryDependencyAssociation_table.drop()
    except Exception, e:
        log.debug( "Dropping repository_repository_dependency_association table failed: %s" % str( e ) )
    try:
        RepositoryDependency_table.drop()
    except 
__version__ = '0.1'
__all__ = ['core','alarm','geo','logs','param','report','sys','system','zone']
	('/api/info.*', 'api.core.Info'),
	('/api/version.*', 'api.core.Version'),
	('/api/debug_jqGrid.*', 'api.core.Debug_jqGrid'),
	('/api/debug_geo.*', 'api.core.DebugGeo'),
	('/api/get_geo.*', 'api.core.GetGeo'),
	('/api/gmap/ceng*', 'api.core.GMapCeng'),
	('/api/misc/drivers*', 'api.core.Sys_Misc_Drivers'),
	('/api/admin/operations*', 'api.core.Admin_Operations'),
	('/api/geo/del.*', 'api.geo.Del'),
	('/api/geo/taskdel.*', 'api.geo.Task_Del'),
	('/api/geo/taskdelall.*', 'api.geo.Task_DelAll'),
	('/api/geo/get*', 'api.geo.Get'),
	('/api/geo/dates*', 'api.geo.Dates'),
	('/api/geo/info*', 'api.geo.Info'),
	('/api/geo/last*', 'api.geo.Last'),
	('/api/geo/count*', 'api.geo.Count'),
	('/api/geo/report*', 'api.geo.Report'),
	('/api/report/get*', 'api.report.Get'),
	('/api/export/xls*', 'api.export.XLS'),
	('/api/export/list*', 'api.export.List'),
	('/api/export/del*', 'api.export.Del'),
	('/api/e

	('/api/system/add*', 'api.system.Add'),
	('/api/system/del*', 'api.system.Del'),
	('/api/system/desc*', 'api.system.Desc'),
	('/api/system/sort*', 'api.system.Sort'),
	('/api/system/config*', 'api.system.Config'),
	('/api/system/tags*', 'api.system.Tags'),
	('/api/system/car*', 'api.system.Car'),
	('/api/system/secure_list*', 'api.system.SecureList'),
	('/api/system/saveconfig*', 'api.system.SaveConfig'),
	('/api/system/seticon*', 'api.system.SetIcon'),
	('/api/param/desc*', 'api.param.Desc'),
	('/api/logs/get*', 'api.logs.Get'),
	('/api/logs/del*', 'api.logs.Del'),
	('/api/logs/purge*', 'api.logs.Purge'),
	('/api/logs/count*', 'api.logs.Count'),
	('/api/zone/add*', 'api.zone.Add'),
	('/api/zone/get*', 'api.zone.Get'),
	('/api/zone/del*', 'api.zone.Del'),
	('/api/zone/info*', 'api.zone.Info'),
	('/api/zone/rule/create*', 'api.zone.Rule_Create'),
	('/api/zone/rule/get*', 'api.zone.Rule_Get'),
	('/api/zone/rule/del*', 'api.zone.Rule_Del'),
	('/api/alarm/confirm*', 'api.alarm.Confirm'),
app = None
def setup():
    template_vars = {
            'package': 'mokshatest',
            'project': 'mokshatest',
            'egg': 'mokshatest',
            'egg_plugins': ['Moksha'],
    }
    args = {
        'controller': True,
        'controller_name': 'MokshatestController',
    }
    template = MokshaControllerTemplate
    templates = ['moksha.controller']
    global app
    app = setup_quickstart(template=template, templates=templates, args=args,
                           template_vars=template_vars)
def teardown():
    teardown_quickstart()
class TestControllerQuickstart(QuickstartTester):
    def setUp(self):
        self.app = app
    def get_controller(self):
        return self.get_entry('moksha.application')
    def test_entry_point(self):
        assert self.get_controller(), \
                "Cannot find mokshatest on `moksha.app` entry-point"
    def test_controller_class(self):
        assert isinstance(self.get_controller(), Controller) or \
               
class TestSessionBroker(unittest.TestCase):
    def setUp(self):
        self.session_broker = session_broker.SessionBroker()
        self.session_broker.registerGame('my-game', MyModel)
    def test_should_allow_to_create_a_session(self):
        id = self.session_broker.create_session('my-game')
        self.assertIn(id, self.session_broker.sessions)
    def test_should_allow_to_remove_a_session(self):
        id = self.session_broker.create_session('my-game')
        self.session_broker.remove(id)
        self.assertNotIn(id, self.session_broker.sessions)
    def test_should_remove_a_session_if_its_not_alive_anymore(self):
        id = self.session_broker.create_session('my-game')
        session = self.session_broker.get_session(id)
        session.add_player("tata", "toto")
        self.session_broker.kill_if_dead(id)
        self.assertIn(id, self.session_broker.sessions)
        session.remove("tata")
        self.assertNotIn(id, self.session_broker.sessions)
    def test_should
class FreeVarsVisitor(Visitor):
    def visitName(self, n):
        if n.name in builtin_functions:
            return set([])
        else:
            return set([n.name])
    def visitConst(self, n):
        return set([])
    def visitAdd(self, n):
        return self.dispatch(n.left) | self.dispatch(n.right)
    def visitUnarySub(self, n):
        return self.dispatch(n.expr)
    def visitCallFunc(self, n):
        sss = [self.dispatch(arg) for arg in n.args]
        ss = reduce(lambda a,b: a | b, sss, set([]))
        return ss | self.dispatch(n.node)
    def visitLambda(self, n):
        local_vars = FindLocalsVisitor().preorder(n.code)
        return (self.dispatch(n.code) - local_vars) - set(n.argnames)
    def visitIfExp(self, n):
        return self.dispatch(n.test) | self.dispatch(n.then) | self.dispatch(n.else_)        
    def visitCompare(self, n):
        return self.dispatch(n.expr) | self.dispatch(n.ops[0][1])
    def visitSubscript(self, n):
        return self.dispa

    def visitGetTag(self, n):
        return self.dispatch(n.arg)
    def visitInjectFrom(self, n):
        return self.dispatch(n.arg)
    def visitProjectTo(self, n):
        return self.dispatch(n.arg)
    def visitLet(self, n):
        return self.dispatch(n.rhs) | (self.dispatch(n.body) - set([n.var]))
    def visitSetSubscript(self, n):
        return self.dispatch(n.container) | self.dispatch(n.key) | self.dispatch(n.val)
    def visitStmt(self, n):
        sss  = [self.dispatch(s) for s in n.nodes]
        return reduce(lambda a,b: a | b, sss, set([]))
    def visitPrintnl(self, n):
        return self.dispatch(n.nodes[0])
    def visitAssign(self, n):
        return self.dispatch(n.expr)
    def visitDiscard(self, n):
        return self.dispatch(n.expr)
    def visitReturn(self, n):
        return self.dispatch(n.value)
    def visitInjectFrom(self, n):
        return self.dispatch(n.arg)
    def visitProjectTo(self, n):
        return self.dispatch(n.arg)
    def visitGetTa
  CreatePlaylistForEvent
@receiver(CreateEvent.command_signal)
def create_event(_aggregate_repository=None, **kwargs):
  if not _aggregate_repository: _aggregate_repository = aggregate_repository
  command = kwargs['command']
  request = Event.from_attrs(**command.data)
  _aggregate_repository.save(request, -1)
@receiver(AssociateArtistWithEvent.command_signal)
def associate_artist_with_event(_aggregate_repository=None, **kwargs):
  if not _aggregate_repository: _aggregate_repository = aggregate_repository
  command = kwargs['command']
  ag = _aggregate_repository.get(Event, kwargs['aggregate_id'])
  artist_id = command.data['artist_id']
  if artist_id not in ag._artist_ids:
    version = ag.version
    ag.associate_artist(artist_id)
    _aggregate_repository.save(ag, version)
@receiver(RefreshEventPlaylist.command_signal)
def refersh_event_playlist(_aggregate_repository=None, **kwargs):
  if not _aggregate_repository: _aggregate_repository = aggregate_repository
  ag = _aggregate_repo
class TestResolve(unittest.TestCase):
    def _repository_factory(self, packages):
        repository = Repository()
        for p in packages:
            repository.add_package(p)
        return repository
    def test__latest_egg_simple(self):
        packages = [
            dummy_repository_package_factory("swig", "1.3.40", 1),
            dummy_repository_package_factory("swig", "1.3.40", 2),
            dummy_repository_package_factory("swig", "2.0.1", 1),
        ]
        repository = self._repository_factory(packages)
        resolver = Resolve(repository)
        latest = resolver._latest_egg(Requirement("swig"))
        self.assertEqual(latest, "swig-2.0.1-1.egg")
        resolver = Resolve(repository)
        latest = resolver._latest_egg(Requirement("swigg"))
        self.assertIsNone(latest)
    def test__latest_egg_multiple_python_versions(self):
        packages = [
            dummy_repository_package_factory("swig", "1.3.40", 1),
            dummy_repository_package_
class GameControllerManager(object):
    def __init__(self, controllers):
        self.controllers = controllers
        args = controllers[0][1]
        constructor = controllers[0][0]
        self.active_controller = constructor(*args)
        self.active_controller_index = 0
    def next_controller(self):
        if self.active_controller_index < len(self.controllers) - 1:
            self.active_controller_index += 1
        else:
            self.active_controller_index = 0
        args = self.controllers[self.active_controller_index][1]
        constructor = self.controllers[self.active_controller_index][0]
        self.active_controller = constructor(*args)
def init_game():
    window = pygame.display.set_mode(RESOLUTION)
    pygame.display.set_caption("Pirate Squirrel")
    screen = pygame.display.get_surface()
    return window, screen
def mainloop(screen, started_at):
    sc = SpacebarController()
    game_controllers = [
        (OutroController, (screen,)),
    ]
    cm = G
roslib.load_manifest('ee_cart_imped_control')
class PR2CMClient:
    '''
    This class switches between the ee_cart_imped controller and the 
    standard arm_navigation suite of controllers on the PR2 arms.
    When invoked, the methods stop one controller and start the other.  
    They require that the controllers are already loaded (albeit stopped).
    The arm_navigation controllers can be loaded from that stack or by
    launching the 
    pr2_tabletop_manipulation_launch/launch/pr2_tabletop_manipulation.launch 
    file.  The ee_cart_imped controller can be launched using the
    ee_cart_imped_launch/launch/load_ee_cart_imped.launch file.  Note that
    using the ee_cart_imped.launch file will not work as that not only starts
    the ee_cart_imped controller, but also continuously inhibits the
    arm_navigation controllers.
    '''
   
    @staticmethod
    def load_ee_cart_imped(arm_name):
        '''
        Stops the standard arm controllers and starts the ee_cart_imped
   

        @type arm_name: string
        @param arm_name: the arm to control.  Must be 'right_arm' or 'left_arm'
        '''
        rospy.logdebug('Starting ee_cart_imped controller on '+ arm_name)
        status = pr2_controller_manager.pr2_controller_manager_interface.stop_controller(arm_name[0]+'_arm_controller')
        status = pr2_controller_manager.pr2_controller_manager_interface.stop_controller\
            (arm_name[0]+'_arm_cartesian_trajectory_controller')
        status = pr2_controller_manager.pr2_controller_manager_interface.stop_controller\
            (arm_name[0]+'_arm_cartesian_pose_controller')
        status = pr2_controller_manager.pr2_controller_manager_interface.start_controller\
            (arm_name[0]+'_arm_cart_imped_controller')
        rospy.logdebug('Controller started')
        return status
        
    @staticmethod
    def load_cartesian(arm_name):
        '''
        Stops the ee_cart_imped controller and the arm_navigation controllers
        and lo
def load(directory=None, hierarchy=None):
    ret = []
    if directory and hierarchy:
        base = "%s/%s" % (directory, hierarchy)
    elif directory:
        base = directory 
    else:
        base = "./controller"
    for controller in os.listdir(base):
        if os.path.isdir("%s/%s" % (base, controller)) is True:
            print >>sys.stdout, "[INFO] register controller hierarchy. %s" \
                  % ("%s/%s" % (base, controller))
            ret += load(base, controller)
            continue
            name = controller[0: controller.index(".")]
            if name == "__init__":
                continue
            try:
                if hierarchy is None:
                    imp = "controller/" + name
                else:
                    imp = "controller/" + hierarchy + "/" + name
                method = mod
                ret += method.urls
                print >>sys.stdout, "[INFO] register controller. %s" % (imp)
            except Exception, e:
     
CONTENT_MANAGE_OPTIONS = (
 {'action': 'manage_change_history_page', 'label': 'History'},
 {'action': 'view', 'label': 'View'},
 {'action': 'manage_interfaces', 'label': 'Interfaces'},
class BaseContentMixin(CatalogMultiplex,
                       BaseObject,
                       PortalContent,
                       Historical):
    """A not-so-basic CMF Content implementation that doesn't
    include Dublin Core Metadata"""
    implements(IBaseContent, IReferenceable)
    security = ClassSecurityInfo()
    manage_options = CONTENT_MANAGE_OPTIONS
    isPrincipiaFolderish = 0
    isAnObjectManager = 0
    __dav_marshall__ = True
    security.declarePrivate('manage_afterAdd')
    def manage_afterAdd(self, item, container):
        BaseObject.manage_afterAdd(self, item, container)
    security.declarePrivate('manage_afterClone')
    def manage_afterClone(self, item):
        BaseObject.manage_afterClone(self, item)
    security.declarePrivate('manage_beforeDelete')
    def manage_befo

        BaseObject.manage_beforeDelete(self, item, container)
        self._v_cp_refs = None
    def _notifyOfCopyTo(self, container, op=0):
        """OFS.CopySupport notify
        """
        BaseObject._notifyOfCopyTo(self, container, op=op)
        if op==1:
            self._v_cp_refs = 1
    security.declareProtected(permissions.ModifyPortalContent, 'PUT')
    PUT = WebDAVSupport.PUT
    security.declareProtected(permissions.View, 'manage_FTPget')
    manage_FTPget = WebDAVSupport.manage_FTPget
    security.declarePrivate('manage_afterPUT')
    manage_afterPUT = WebDAVSupport.manage_afterPUT
InitializeClass(BaseContentMixin)
class BaseContent(BaseContentMixin,
                  ExtensibleMetadata,
                  PropertyManager):
    """A not-so-basic CMF Content implementation with Dublin Core
    Metadata included"""
    implements(IBaseContent, IReferenceable, IExtensibleMetadata)
    schema = BaseContentMixin.schema + ExtensibleMetadata.schema
    def __init__(self, oid,
class BrokerVolumeTooBigError(ValueError):
    pass
class Broker(object):
    def __init__(self, name, price):
        self.__name = name
        self.__price = price
        self.__total_volume = []
    def __calculate_cost(self, volume):
        if volume > 100:
            raise BrokerVolumeTooBigError("Order volume is bigger then 100")
        commission_policy_params = {'volume': volume}
        commission = (1 + self._commission_policy(commission_policy_params))
        final_price = self.__price * commission
        return final_price * volume
    def _commission_policy(self, params):
        raise NotImplementedError
    def quote(self, volume):
        return self.__calculate_cost(volume)
    def execute(self, volume):
        self.__total_volume.append(volume)
        return self.__calculate_cost(volume)
    @staticmethod
    def max_volume():
        return 100
    @property
    def total_volume(self):
        return sum(self.__total_volume)
    @property
    def name(self):
dispatch = cherrypy.dispatch.RoutesDispatcher()
dispatch.connect('register', 'register', controller=AJAXController(), action='register')
dispatch.connect('update', ':name_encoded/update', controller=AJAXController(), action='update')
dispatch.connect('new_message', ':name_encoded/message', controller=AJAXController(), action='new_message')
dispatch.connect('set_topic', ':name_encoded/topic', controller=AJAXController(), action='set_topic')
dispatch.connect('room_new', 'new', controller=RoomsController(), action='new')
dispatch.connect('room_leave', ':name_encoded/leave', controller=RoomsController(), action='leave')
dispatch.connect('room_delete', ':name_encoded/delete', controller=RoomsController(), action='delete')
dispatch.connect('room', ':name_encoded', controller=RoomsController(), action='chat')
dispatch.connect('index', '', controller=RoomsController(), action='index')
cherrypy.config.update(config.cherrypy)
cherrypy.quickstart(AppController(), '/', {
  '/': {
    'tools.static
class Site(object):
    def __init__(self):
        self.controllers = {}
        self.helpers = {}
        self.logger = logging.getLogger(__name__)
    def autodiscover(self, include_apps = [], exclude_apps = []):
        """Autodiscover all urls within all applications that regex match any entry in 'include_apps'
        and exclude any in 'exclude_apps'.
        """
        
        if type(include_apps) not in (list, tuple):
            include_apps = (include_apps,)
        if type(exclude_apps) not in (list, tuple):
            exclude_apps = (exclude_apps,)
        
        if len(include_apps) == 0:
            include_apps = settings.INSTALLED_APPS
        
        for app in settings.INSTALLED_APPS:
            must_skip = False
            if app.endswith('django_url_framework'):
                continue
            
            for inc in include_apps:
                if re.search(inc, app):
                    must_skip = False
                    break
                el

                    must_skip = True
            for excl in exclude_apps:
                if re.search(excl, app):
                    must_skip = True
                    break
            if must_skip:
                continue
            try:
                available_controllers = []
                if app_path[0][-1] != os.path.sep:
                    app_path[0] = app_path[0]+os.path.sep
                    
                for f in dircache.listdir(app_path[0]):
                    if f.endswith('_controller.py'):
                        available_controllers.append(f[:-14])
                self.load_controllers(app_path, available_controllers)
            except AttributeError, e:
                self.logger.exception(e)
                continue
                
    def load_controllers(self, app_path, controllers):
        found_controller, found_helper = (None, None)
        
        for controller_file in controllers:
            """Load controller"""
            try:
   

            except ImportError, e:
                self.logger.warning("Failed to find proper controller in %s" % controller_file, exc_info=True)
                continue
            else:
                controller_module = imp.load_module('%s_controller' % controller_file, *found_controller)
                self.logger.debug("Loaded controller from %s" % controller_file)
                for controller_class_name in dir(controller_module):
                    if not controller_class_name.endswith('Controller'):
                        continue
                        
                    controller_class = getattr(controller_module, controller_class_name)
                    
                    if controller_class != ActionController and issubclass(controller_class, ActionController):
                        controller_name = get_controller_name(controller_class)
                        if controller_name in self.controllers:
                            continue
                    
   
def runcmd(cmd):  
  try:  
    print "Executing %s" % ' '.join(cmd)  
    output = subprocess.check_output(cmd)  
    print output  
    return output  
  except:  
    print "Failed"  
    return None  
  
VBoxManage = '/usr/bin/VBoxManage'  
vboxConfBios = './vboxConfBiosWin7.py'  
for machine in sys.argv[1:]:  
  hdpath = os.path.join('/','data','VirtualBox VMs',machine,machine+'.vdi')  
  runcmd([VBoxManage,'createhd','--filename',hdpath,'--size',str(80*1024)])  
  runcmd([VBoxManage,'createvm','--name',machine,'--ostype','Windows7_64','--register'])  
  runcmd([VBoxManage,'storagectl',machine,'--name','SATA Controller','--add','sata','--controller','IntelAHCI'])  
  runcmd([VBoxManage,'storageattach', machine,'--storagectl','SATA Controller','--port','0','--device','0','--type','hdd','--medium',hdpath])  
  runcmd([VBoxManage,'storagectl',machine,'--name','PIIX4','--add','ide','--controller','PIIX4'])
  runcmd([VBoxManage,'storageattach', machine,'--storagectl','PIIX4','--por
class RepositoryConfig(config.Config):
    def __init__(self, configFileName):
        config.Config.__init__(self, configFileName)
        self.repos = {}
        for r in self.getRepositories():
            name = self.getRepositoryName(r)
            if name in self.repos:
                raise KeyError('Duplicate repository name %s: %s and %s'
                               %(name, self.repos[name], r))
            self.repos[name] = r
        self.requireAbsolutePaths('skeleton')
    def getRepositories(self):
        return set(self.sections()) - set(('GLOBAL',))
    @staticmethod
    def getRepositoryName(repository):
        return os.path.basename(repository)
    def getRepositoryByName(self, repositoryName):
        if self.has_section(repositoryName):
            return repositoryName
        return self.repos[repositoryName]
    def getCVSRoot(self, repository):
        return self.getGlobalFallback(repository, 'cvsroot')
    def getGitRef(self, repository):
        gitroot

        if gitroot.startswith('/') or '://' in gitroot:
            return '/'.join((gitroot, repository))
        return ':'.join((gitroot, repository))
    def getCVSPath(self, repository):
        return self.get(repository, 'cvspath')
    def getSkeleton(self, repository):
        return self.getGlobalFallback(repository, 'skeleton', error=False)
    def getBranchFrom(self, repository):
        return self.getOptional(repository, 'branchfrom')
    def getBranchPrefix(self, repository, branch):
        optname = 'prefix.'+branch
        return self.getOptional(repository, optname)
    def getGitLogOptions(self, repository, branch):
        optname = 'gitlog.'+branch
        return self.getOptional(repository, optname)
    def getImportBranchMaps(self, repository):
        'return: [(cvsbranch, gitbranch), ...]'
        return [(x[4:], 'cvs-' + self.get(repository, x))
                 for x in sorted(self.options(repository))
                 if x.startswith('cvs.')]
    def getCVS

        'return: ["VARIABLE=value", ...]'
        return ['='.join((x[7:], '' + self.getGlobalFallback(repository, x)))
                for x in sorted(set(self.options(repository) +
                                    self.options('GLOBAL')))
                if x.startswith('cvsvar.')]
    def getExportBranchMaps(self, repository):
        'return: [(gitbranch, cvsbranch, exportbranch), ...]'
        return [(x[4:], self.get(repository, x), 'export-' + x[4:])
                 for x in sorted(self.options(repository))
                 if x.startswith('git.')]
    def getMergeBranchMaps(self, repository):
        'return: {sourcebranch, set(targetbranch, targetbranch, ...), ...}'
        return dict((x[6:], set(self.get(repository, x).strip().split()))
                    for x in sorted(self.options(repository))
                    if x.startswith('merge.'))
    def getHook(self, type, when, repository):
        return self.getGlobalFallback(repository, when+'hook.'+type, error=False)
class Ui_manageTransaction(object):
    def setupUi(self, manageTransaction):
        manageTransaction.setObjectName("manageTransaction")
        manageTransaction.resize(350, 150)
        manageTransaction.setMinimumSize(QtCore.QSize(350, 150))
        manageTransaction.setMaximumSize(QtCore.QSize(350, 150))
        self.verticalLayout = QtWidgets.QVBoxLayout(manageTransaction)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(manageTransaction)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.dateEdit = QtWidgets.QDateEdit(manageTransaction)
        self.dateEdit.setObjectName("dateEdit")
        self.horizontalLayout.addWidget(self.dateEdit)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
     

        self.label_2 = QtWidgets.QLabel(manageTransaction)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.categorysBox = QtWidgets.QComboBox(manageTransaction)
        self.categorysBox.setObjectName("categorysBox")
        self.horizontalLayout.addWidget(self.categorysBox)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_4 = QtWidgets.QLabel(manageTransaction)
        self.label_4.setObjectName("label_4")
        self.horizontalLayout_2.addWidget(self.label_4)
        self.amountBox = QtWidgets.QDoubleSpinBox(manageTransaction)
        self.amountBox.setMinimum(-100000000.0)
        self.amountBox.setMaximum(100000000.0)
        self.amountBox.setObjectName("amountBox")
        self.horizontalLayout_2.addWidget(self.amountBox)
        spacerItem1 = QtWidgets.QSpace

        self.horizontalLayout_2.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_5 = QtWidgets.QLabel(manageTransaction)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_3.addWidget(self.label_5)
        self.infoEdit = QtWidgets.QLineEdit(manageTransaction)
        self.infoEdit.setObjectName("infoEdit")
        self.horizontalLayout_3.addWidget(self.infoEdit)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem2)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem3)
        self.buttonBox = QtWidg
    '',
    url(r'^$', views.login_check, name='fms_login'),
    url(r'^manage/fees_type/$', views.manage_fees_type,
        name='manage_fees_type'),
    url(r'^manage/add_fee_type/$', views.add_fee_type, name='add_fee_type'),
    url(r'^manage/edit_fee_type/(?P<ftype_id>[0-9]+)/$', views.edit_fee_type,
        name='edit_fee_type'),
    url(r'^manage/delete/$', views.deactivate, name='delete_object'
        ),
    url(r'^manage/levels/$', views.manage_levels, name='manage_levels'),
    url(r'^manage/level/add/$', views.add_level, name='add_level'),
    url(r'^manage/level/edit/$', views.edit_level, name='edit_level'),
    url(r'^manage/fees/$', views.manage_fees, name='manage_fees'),
    url(r'^manage/fees/get_semester/$', views.fees_get_semester,
        name='fees_get_semester'),
    url(r'^manage/fees/add/$', views.add_fee, name='add_fee'),
    url(r'^manage/fees/edit/(?P<fee_id>[0-9]+)/$', views.edit_fee,
        name='edit_fee'),
    url(r'^manage/student_fees/$', views.manage_s

        name='manage_student_fees'),
    url(r'^manage/student_fees/add/$', views.add_student_fee,
        name='add_student_fee'),
    url(r'^manage/student_fees/edit/(?P<student_payment_id>[0-9]+)/$',
        views.edit_student_fee, name='edit_student_fee'),
    url(r'^manage/student_fees/pay/(?P<student_payment_id>[0-9]+)/$',
        views.student_payment, name='student_payment'),
    url(r'^manage/student_fees/payment_details/(?P<student_payment_id>[0-9]+)/$',
        views.show_payment_details, name='show_payment_details'),
    url(r'^manage/fine_type/$', views.manage_fine_type,
        name='manage_fine_type'),
    url(r'^manage/fine_type/add/$', views.add_fine_type, name='add_fine_type'
        ),
    url(r'^manage/fine_type/edit/(?P<fine_type_id>[0-9]+)/$',
        views.edit_fine_type, name='edit_fine_type'),
    url(r'^manage/fees_schedule/(?P<fee_id>[0-9]+)/$',
        views.manage_fees_schedule, name='manage_fees_schedule'),
    url(r'^manage/fees_schedule/add/(?P<fee_id>[
class TeleinfoOperations:
	CONST_TOPIC = '/bst/sensor/teleinfo/raw'
	def __init__(self, serialPort, broker):
		self.mqtt = broker
	def sendRecord(self, msg):
		dmsg = "%s -> %s" % (self.CONST_TOPIC, msg)
		print dmsg
	def run(self):		
		baseCnt = 127598
		while 1:
			try:
				time.sleep(1)
				trame = dict([["PAPP","2200"], ["IINST", "3"], ["BASE", str(baseCnt)]])
				baseCnt += 1
				
				if not os.path.exists('./stop'):
					self.sendRecord(json.dumps(trame))
				
			except KeyError:
				pass		
def on_connect(mosq, userdata, rc): 
	print "on_connect:"+str(rc) 
def on_log(mosq, userdata, level, buf): 
	print "log: "+buf
def usage():
	print 'readTeleinfo [-l] -s <serialPort> -b <brokerAddress>'
serialPort = '/dev/ttyS0'
brokerAddress = 'localhost'
try:
	opts, args = getopt.getopt(sys.argv[1:],"hls:b:",["help", "log", "serial=","broker="])
except getopt.GetoptError as err:
	print err
	usage()
	sys.exit(2)
dolog=False
for opt, arg in opts:
	if opt in ("-h", "--help"):
		usage()
      		s
app = Flask(__name__)
producers = {}
enablePickle = False
class Producer(object):
    """docstring for Sensor"""
    def __init__(self, producer_id,  sensors, lat, lng, access_time, broker_address, broker_pid):
        super(Producer, self).__init__()
        self.sensors = sensors
        self.lat = lat
        self.lng = lng
        self.access_time = access_time
        self.broker_address = broker_address
        self.producer_id = producer_id
        self.broker_pid = broker_pid
    def __str__(self):
        return str([self.producer_id, self.sensors, self.lat, self.lng, self.access_time, self.broker_address, self.broker_pid])
def save_state(producers):
    if (enablePickle):
        pickle.dump(producers, open( "producers.p", "wb" ))
def load_state():
    if enablePickle and os.path.isfile("producers.p"):
        producers = pickle.load(open( "producers.p", "rb" ))
@app.route("/list_brokers", methods=['GET'])
def list_brokers():
    resp = ""
    resp += str(len(producers.values

    for producer in producers.values():
        resp += "<p>" + str(producer) + "</p>"
    return resp
@app.route("/replace_broker", methods=['GET'])
def replace_broker():
    """Used by the producer to request a new broker, if the initial one dies"""
    producer_id = request.args.get('producer_id', type=str)
    producer = producers[producer_id] 
    open_port = pick_unused_port()
    open_port2 = pick_unused_port()
    BROKER_COMMAND = ['nohup','python', "broker.py", "-p" + str(open_port), "-t" + str(open_port2), "-s", str(producer.sensors)]
    broker = subprocess.Popen(BROKER_COMMAND, stdout=open('/dev/null', 'w'), stderr=open('logfile.log', 'a'), preexec_fn=os.setpgrp, close_fds = True)
    broker_address = "ws://" + constants.BROKER_HOST + ":" + str(open_port)
    producer.broker_address = broker_address
    producer.broker_pid = broker.pid
    producers[producer_id] = producer
    save_state(producers)
    response = {"broker_address" : producers[producer_id].broker_address}
 

    return response_json
@app.route("/register_producer", methods=['GET'])
def register_producer():
    producer_id = request.args.get('producer_id', type=str)
    if producer_id in producers:
        producers[producer_id].access_time = datetime.datetime.now()
        save_state(producers)
    else:
        sensors = request.args.get('sensors', type=str).split(",")
        lat = request.args.get('lat', type=str)
        lng = request.args.get('lng', type=str)
        access_time = datetime.datetime.now()
        open_port = pick_unused_port()
        open_port2 = pick_unused_port()
        BROKER_COMMAND = ['nohup','python', "broker.py", "-p" + str(open_port), "-t" + str(open_port2), "-s", str(sensors)]
        broker = subprocess.Popen(BROKER_COMMAND, stdout=open('/dev/null', 'w'), stderr=open('logfile.log', 'a'), preexec_fn=os.setpgrp, close_fds = True)
        access_time = datetime.datetime.now()
        broker_address = "ws://" + constants.BROKER_HOST + ":" + str(open_port)
    
def control_call_back(xboxControlId, value):
    print ("Control ID = " + str(xboxControlId) +  " Value = " + str(value))
def left_thumb_x(xValue):
    print("LX" + str(xValue))
def right_thumb_x(xValue):
    print("RX" + str(xValue))
def right_thumb_y(yValue):
    print("RY" + str(yValue))
def left_thumb_y(yValue):
    print("LY" + str(yValue))
def left_trigger(value):
    print("Left Trigger:" + str(value))
def right_trigger(value):
    print("Right Trigger: " + str(value))
if __name__ == '__main__':
    controller = controllerClass.Controller(controller_call_back=None, dead_zone=0.1, scale=1, invert_Y_axis=True, controller_is_xbox=True)
    xboxControls = controllerClass.XboxControls
    controller.setup_control_call_back(controller.controller_mapping.L_THUMB_X, left_thumb_x)
    controller.setup_control_call_back(controller.controller_mapping.L_THUMB_Y, left_thumb_y)
    controller.setup_control_call_back(controller.controller_mapping.L_TRIGGER, left_trigger)
    controller.setup_c
repertory_ct = ContentType.objects.get_or_create(app_label='music', model='repertory')[0]
event_repertory_ct = ContentType.objects.get_or_create(app_label='music',
                                                       model='event_repertory')[0]
rehearsal_ct = ContentType.objects.get_or_create(app_label='music', model='rehearsal')[0]
section_ct = ContentType.objects.get_or_create(app_label='section', model='section')[0]
event_ct = ContentType.objects.get_or_create(app_label='event', model='event')[0]
location_ct = ContentType.objects.get_or_create(app_label='event', model='location')[0]
photo_ct = ContentType.objects.get_or_create(app_label='photo', model='photoalbum')[0]
video_ct = ContentType.objects.get_or_create(app_label='video', model='videoalbum')[0]
music_ct = ContentType.objects.get_or_create(app_label='music', model='music')[0]
Permission.objects.get_or_create(name=_('Manage main repertory'),
                                 codename='manage_main_repertory',
                

Permission.objects.get_or_create(name=_('Manage event repertories'),
                                 codename='manage_event_repertories',
                                 content_type=event_repertory_ct)
Permission.objects.get_or_create(name=_('Manage rehearsals'),
                                 codename='manage_rehearsals',
                                 content_type=rehearsal_ct)
Permission.objects.get_or_create(name=_('Manage sections'),
                                 codename='manage_sections',
                                 content_type=section_ct)
Permission.objects.get_or_create(name=_('Manage events'),
                                 codename='manage_events',
                                 content_type=event_ct)
Permission.objects.get_or_create(name=_('Manage photos'),
                                 codename='manage_photoalbums',
                                 content_type=photo_ct)
Permission.objects.get_or_create(name=_('Manage locations'),
                  
urlpatterns = patterns('dashboard',
    url(r'^success/$', 'views.index', name='index'),
    url(r'^authorize_manage/', include('dashboard.authorize_manage.urls')),
    url(r'^control_manage/', include('dashboard.control_manage.urls')),
    url(r'^instance_manage/', include('dashboard.instance_manage.urls')),
    url(r'^image_template_manage/', include('dashboard.image_template_manage.urls')),
    url(r'^hard_template_manage/', include('dashboard.hard_template_manage.urls')),
    url(r'^user_manage/', include('dashboard.user_manage.urls')),
    url(r'^project_manage/', include('dashboard.project_manage.urls')),
    url(r'^node_manage/', include('dashboard.node_manage.urls')),
    url(r'^software_manage/', include('dashboard.software_manage.urls')),
    url(r'^volume_manage/', include('dashboard.volume_manage.urls')),
    url(r'^log_manage/', include('dashboard.log_manage.urls')),
    url(r'^monitor_manage/', include('dashboard.monitor_manage.urls')),
    url(r'^securitygroup_manage/', 
def message_post_save(sender, instance, created, **kwargs):
    if created:
        instance.chat.last_message = instance
        instance.chat.save()
def conference_membership_post_save(sender, instance, created, **kwargs):
    if created:
        instance.conference.member_count += 1
        instance.conference.is_active = True
        instance.conference.save()
    else:
        if instance.is_deleted and not instance.is_deleted_was:
            instance.conference.member_count -= 1
            if instance.conference.member_count == 0:
                instance.conference.is_active = False
            instance.conference.save()
def conference_post_save(sender, instance, created, **kwargs):
    if created:
        cm = ConferenceMembership(conference=instance,
                                  profile=instance.owner,
                                  invite_from=instance.owner)
        cm.save()
post_save.connect(message_post_save, Message, dispatch_uid='tt_message_post_save')
post_sa
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'])
    map.minimization = False
    map.explicit = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.connect('/browse', controller='browse', action='main')
    map.connect('/browse/page/{page}', controller='browse', action='main')
    map.connect('/browse/best', controller='browse', action='best')
    map.connect('/browse/best/page/{page}', controller='browse', action='best')
    map.connect('/browse/worst', controller='browse', action='worst')
    map.connect('/browse/worst/page/{page}', controlle

    map.connect('/browse/tags', controller='browse', action='tags')
    map.connect('/browse/tags/{tag}', controller='browse', action='tags')
    map.connect('/browse/tags/{tag}/page/{page}', controller='browse', action='tags')
    map.connect('/browse/disapproved', controller='browse', action='disapproved')
    map.connect('/browse/disapproved/page/{page}', controller='browse', action='disapproved')
    map.connect('/browse/unapproved', controller='browse', action='unapproved')
    map.connect('/browse/unapproved/page/{page}', controller='browse', action='unapproved')
    map.connect('/browse/deleted', controller='browse', action='deleted')
    map.connect('/browse/deleted/page/{page}', controller='browse', action='deleted')
    map.connect('/browse/reported', controller='browse', action='reported')
    map.connect('/browse/reported/page/{page}', controller='browse', action='reported')
    map.connect('/browse/favourites', controller='browse', action='favourites')
    map.connect('/b

    map.connect('/browse/random', controller='browse', action='random')
    map.connect('/browse/{ref_id}', controller='browse', action='view_one')
    map.connect('/search', controller='browse', action='search')
    map.connect('/search/{term}', controller='browse', action='search')
    map.connect('/search/{term}/page/{page}', controller='browse', action='search')
    map.connect('/create', controller='create', action='quote')
    map.connect('/signup', controller='account', action='create')
    map.connect('/login', controller='account', action='login')
    map.connect('/logout', controller='account', action='logout')
    map.connect('/reset_password', controller='account', action='reset_password')
    map.connect('/api/v1/quotes/{quote_id}/approve', controller='api_v1', action='approve')
    map.connect('/api/v1/quotes/{quote_id}/delete', controller='api_v1', action='delete')
    map.connect('/api/v1/quotes/{quote_id}/disapprove', controller='api_v1', action='disapprove')
    map.
class ServiceApi(wsgi.Router):
    """WSGI entry point for Keystone Service API requests."""
    def __init__(self, options):
        self.options = options
        mapper = routes.Mapper()
        db.configure_backends(options)
        auth_controller = AuthController(options)
        mapper.connect("/tokens", controller=auth_controller,
                       action="authenticate",
                       conditions=dict(method=["POST"]))
        mapper.connect("/ec2tokens", controller=auth_controller,
                       action="authenticate_ec2",
                       conditions=dict(method=["POST"]))
        mapper.connect("/s3tokens", controller=auth_controller,
                       action="authenticate_s3",
                       conditions=dict(method=["POST"]))
        tenant_controller = TenantController(options, True)
        mapper.connect("/tenants",
                        controller=tenant_controller,
                        action="get_tenants",
                   

        user_controller = UserController(options)
        mapper.connect("/tenants/{tenant_id}/users",
                    controller=user_controller,
                    action="get_tenant_users",
                    conditions=dict(method=["GET"]))
        mapper.connect("/users/{user_id}/eppn",
                    controller=user_controller,
                    action="set_user_eppn",
                    conditions=dict(method=["PUT"]))
        """
        get token by email
        add by colony.
        """
        token_by_controller = TokenByController(options)
        mapper.connect("/token_by/email",
                    controller=token_by_controller,
                    action="get_token_by",
                    conditions=dict(method=["POST"]))
        mapper.connect("/token_by/eppn",
                    controller=token_by_controller,
                    action="get_token_by",
                    conditions=dict(method=["POST"]))
        version_controller = VersionControl

        mapper.connect("/",
                        controller=version_controller,
                        action="get_version_info", file="service/version",
                        conditions=dict(method=["GET"]))
        extensions_controller = ExtensionsController(options)
        mapper.connect("/extensions",
                        controller=extensions_controller,
                        action="get_extensions_info",
                        path="content/service/extensions",
                        conditions=dict(method=["GET"]))
        static_files_controller = StaticFilesController(options)
        mapper.connect("/identitydevguide.pdf",
                        controller=static_files_controller,
                        action="get_pdf_contract",
                        root="content/service/", pdf="identitydevguide.pdf",
                        conditions=dict(method=["GET"]))
        mapper.connect("/identity.wadl",
                        controller=static_files_controlle
class DECSETTiteInhibitTests(SaveRestoreCursorTests):
  def __init__(self):
    SaveRestoreCursorTests.__init__(self)
  def saveCursor(self):
    esccmd.DECSET(esccmd.SaveRestoreCursor)
  def restoreCursor(self):
    esccmd.DECRESET(esccmd.SaveRestoreCursor)
  @knownBug(terminal="iTerm2", reason="Not implemented")
  def test_SaveRestoreCursor_Basic(self):
    SaveRestoreCursorTests.test_SaveRestoreCursor_Basic(self)
  @knownBug(terminal="iTerm2", reason="Not implemented")
  def test_SaveRestoreCursor_MoveToHomeWhenNotSaved(self):
    SaveRestoreCursorTests.test_SaveRestoreCursor_MoveToHomeWhenNotSaved(self)
  @knownBug(terminal="iTerm2", reason="Not implemented")
  def test_SaveRestoreCursor_ResetsOriginMode(self):
    SaveRestoreCursorTests.test_SaveRestoreCursor_ResetsOriginMode(self)
  @knownBug(terminal="iTerm2", reason="Not implemented")
  def test_SaveRestoreCursor_WorksInLRM(self, shouldWork=True):
    SaveRestoreCursorTests.test_SaveRestoreCursor_WorksInLRM(self)
  @knownBug(te
class businessRecord(object):
    def __init__(self):
        self.Duns = None
        self.GUODuns = None
        self.VB = None
        self.GRP =None
        self.LTD = None
        self.STD = None
        self.Life = None
        self.ADD = None
        self.IDI = None
        self.ILTC = None
        self.GLTC = None
        self.Prod1 = None
        self.Prod2 = None
        self.Prod3 = None
        self.Prod4 = None
        self.UnumProds = None
        self.JudyProds =None
        self.AllProds =None
        self.Broker1= None
        self.Broker2= None
        self.Broker3= None
        self.Broker4= None
        self.UnumCustomer = None
        self.UnumVBBroker = None
        self.UnumGrpBroker = None
        self.UnumIDIBroker = None
        self.UnumILTCBroker = None
        self.UnumGLTCBroker = None
    def unumPortfolio(self):
        unumProdsList = [self.VB, self.GRP, self.LTD, self.STD, self.Life, self.ADD, self.IDI, self.ILTC, self.GLTC]
        self.UnumProds = un

        
    def judyPortfolio(self):
        def delimit(word):
            return word.split(' ')
        a = delimit(self.Prod1)
        b = delimit(self.Prod2)
        c = delimit(self.Prod3)
        d = delimit(self.Prod4)
        e = a + b + c + d
        judyProdsList = set(e)
        self.JudyProds = judyProdsList
        
    def allPortfolio(self):
        self.AllProds = self.JudyProds.union(self.UnumProds)
        a = [value for value in a if ( not (isinstance(value, float)) and value != '')]
        self.AllProds = a
        
    def keyUKBroker(self):
        forbiddenList =["aon", "gallagher",'lockton','jlt','jardine lloyd thompson','towers watson']
        compBrokers = [self.Broker1,self.Broker2,self.Broker3,self.Broker4,self.UnumCustomer,self.UnumVBBroker,self.UnumGrpBroker,self.UnumIDIBroker,self.UnumILTCBroker,self.UnumGLTCBroker]
    
        flag = False     
        for forbiddenBroker in forbiddenList:
            for broker in compBrokers:
                if f

                    flag = True
        return flag
    def intermediatedBy(self, inputBroker):
        brokerDesired = inputBroker.lower()
        brokerList =[self.Broker1,self.Broker2,self.Broker3,self.Broker4,self.UnumCustomer,self.UnumVBBroker,self.UnumGrpBroker,self.UnumIDIBroker,self.UnumILTCBroker,self.UnumGLTCBroker]
        flag = False     
        for broker in brokerList:
            if brokerDesired in broker.lower():
                flag = True
        return flag
        
def readAllComp(tabName):
    filLocation = r"E:\Marketing Insight And Analysis\Analysis - Internal\Broker Packs\Mercer\20150109 -US owned startups in UK\US GUO Duns Output CJ v2.xlsx"
    data_df =read_excel(filLocation,tabName)
    return data_df
companies= {}
    a = businessRecord()
    a.Duns = row ['Duns_No']
    a.GUODuns= row['Duns_No_Global_Parent']
    a.VB = row['VB']
    a.STD = row['STD']
    a.Life = row['Life']
    a.ADD = row['ADD']
    a.IDI= row['IDI']
    a.ILTC = row['ILTC']
    a.
urlpatterns = [
    url(r'^search$', views.search, name="repository-search"),
    url(r'^newScore$', views.newScore, name="repository-newScore"),
    url(r'^showRepositoryProduction/(?P<pk>\d+)$', views.showRepositoryProduction, name="repository-showRepositoryProduction"),
    url(r'^showRepositoryDeveloppement/(?P<pk>\d+)$', views.showRepositoryDeveloppement, name="repository-showRepositoryDeveloppement"),
    url(r'^addFile/(?P<pk>\d+)$', views.addFile, name="repository-addFile"),
    url(r'^editRepository/(?P<pk>\d+)$', views.editRepository, name="repository-editRepository"),
    url(r'^deleteRepository/(?P<pk>\d+)$', views.deleteRepository, name="repository-deleteRepository"),
    url(r'^deleteFile/(?P<pk>\d+)/(?P<pk_commit>\d+)$', views.deleteFile, name="repository-deleteFile"),
    url(r'^deleteCommit/(?P<pk>\d+)$', views.deleteCommit, name="repository-deleteCommit"),
    url(r'^renameFile/(?P<pk>\d+)/(?P<pk_commit>\d+)$', views.renameFile, name="repository-renameFile"),
    url(

    url(r'^mergeCommit/(?P<pk>\d+)$', views.mergeCommit, name="repository-mergeCommit"),
    url(r'^showFile/(?P<pk>\d+)/(?P<pk_commit>\d+)$', views.showFile, name="repository-showFile"),
    url(r'^downloadViewsFile/(?P<pk>.+)/(?P<pk_commit>.+)$', views.downloadViewsFile, name="repository-downloadViewsFile"),
    url(r'^downloadCommit/(?P<pk>.+)/$', views.downloadCommit, name="repository-downloadCommit"),
    url(r'^createBranch/(?P<pk>.+)/$', views.createBranch, name="repository-createBranch"),
    url(r'^updateDatabase/(?P<pk>.+)/$', views.updateDatabase, name="repository-updateDatabase"),
    url(r'^deleteBranch/(?P<pk>.+)/$', views.deleteBranch, name="repository-deleteBranch"),
    url(r'^editMarkdown/(?P<pk>.+)/(?P<pk_file>.+)$', views.editMarkdown, name="repository-editMarkdown"),
    url(r'^warningDownloadFile/(?P<pk>\d+)/(?P<pk_commit>\d+)$', views.warningDownloadFile, name="repository-warningDownloadFile"),
    url(r'^downloadFile/(?P<pk>.+)/$', views.downloadFile, name="rep

    url(r'^warningDownloadRepository/(?P<pk>\d+)$', views.warningDownloadRepository, name="repository-warningDownloadRepository"),
    url(r'^warningDownloadCommit/(?P<pk>\d+)/(?P<pk_commit>\d+)$', views.warningDownloadCommit, name="repository-warningDownloadCommit"),
    url(r'^downloadCommit$', views.downloadCommit, name="repository-downloadCommit"),
    url(r'^changeDeprecated/(?P<pk>\d+)/(?P<boolean>\d+)$', views.changeDeprecated, name="repository-changeDeprecated"),
    url(r'^changeCommitVisibility/(?P<pk>\d+)/(?P<boolean>\d+)$', views.changeCommitVisibility, name="repository-changeCommitVisibility"),
    url(r'^restartRepositoryByOldCommit/(?P<pk>\d+)/$', views.restartRepositoryByOldCommit, name="repository-restartRepositoryByOldCommit"),
    url(r'^commits/(?P<pk>\d+)$', views.listCommits, name="repository-listCommits"),
    url(r'^listContributeurs/(?P<pk>\d+)$', views.listContributeurs, name="repository-listContributeurs"),
    
    url(r'^listDownload$', views.listDownload,
response.title = settings.title
response.subtitle = settings.subtitle
response.meta.author = '%(author)s <%(author_email)s>' % settings
response.meta.keywords = settings.keywords
response.meta.description = settings.description
response.menu = [
(T('Index'),URL('default','index')==URL(),URL('default','index'),[]),
(T('Employee'),URL('default','employee_manage')==URL(),URL('default','employee_manage'),[]),
(T('Course'),URL('default','course_manage')==URL(),URL('default','course_manage'),[]),
(T('Document'),URL('default','document_manage')==URL(),URL('default','document_manage'),[]),
(T('Doctype'),URL('default','doctype_manage')==URL(),URL('default','doctype_manage'),[]),
(T('Session'),URL('default','session_manage')==URL(),URL('default','session_manage'),[]),
(T('Attendance'),URL('default','attendance_manage')==URL(),URL('default','attendance_manage'),[]),
(T('Certification'),URL('default','certification_manage')==URL(),URL('default','certification_manage'),[]),
(T('Empcert'),URL('defau
 	
class ControllerTest(unittest.TestCase):
	"""ControllerTest: Test Controller Singleton"""
	def assertNotNone(self):
		"""ControllerTest: Test instance not null"""
		controller = puremvc.core.Controller.getInstance()
   		self.assertNotEqual(None, controller) 
	def assertIController(self):
		"""ControllerTest: Test instance implements IController"""
		controller = puremvc.core.Controller.getInstance()
   		self.assertEqual(True, isinstance(controller, puremvc.interfaces.IController))
	def testRegisterAndExecuteCommand(self):
 		"""ControllerTest: Test registerCommand() and executeCommand(0)"""
		controller = puremvc.core.Controller.getInstance()
		controller.registerCommand('ControllerTest', utils.controller.ControllerTestCommand)
		
		vo = utils.controller.ControllerTestVO(12)
		note = puremvc.patterns.observer.Notification('ControllerTest', vo)
		controller.executeCommand(note)
		
		self.assertEqual(True, vo.result == 24 )
  		
	def testRegisterAndRemoveCommand(self): 
		"""Control
app = Flask(__name__)
app.config.from_object('config') 
db.init_app(app)
bcrypt.init_app(app)
redis_store.init_app(app)
mail = Mail(app)
api = Api(app)
api.decorators = [cors.crossdomain(origin='*',
                                   headers='my-header, accept, content-type, token')]
api.add_resource(UserAPI, '/create_user')
api.add_resource(LoginAPI, '/login')
api.add_resource(FBUserAPI, '/fb_create_user')
api.add_resource(FBLoginAPI, '/fb_login')
api.add_resource(ActivateAPI, '/activate_account')
api.add_resource(ChangePasswordAPI, '/change_password')
api.add_resource(ForgetPasswordAPI, '/forget_password')
api.add_resource(ProfileAPI, '/profile')
api.add_resource(ProfileIconAPI, '/upload_profile_icon')
api.add_resource(FindProfileAPI, '/search_profile')
api.add_resource(ViewProfileAPI, '/view_profile/<int:profileID>')
api.add_resource(FriendsListAPI, '/friends_list')
api.add_resource(FriendsRequestAPI, '/friends_request')
api.add_resource(LolTeamAPI, '/create_team/lol')
api.add_resou

api.add_resource(ManagelolTeamAPI, '/manage_team/lol')
api.add_resource(LolTeamIconAPI, '/upload_team_icon/lol')
api.add_resource(SearchlolTeamAPI, '/search_team/lol')
api.add_resource(ViewlolTeamAPI, '/view_team/lol/<int:teamID>')
api.add_resource(InviteTeamRequestAPI, '/invite_request/lol')
api.add_resource(JoinTeamRequestAPI, '/join_request/lol')
api.add_resource(CreateTournamentAPI, '/create_tournament')
api.add_resource(JoinTournamentAPI, '/join_tournament')
api.add_resource(TournamentResultAPI, '/report_result')
api.add_resource(ViewTournamentAPI, '/view_tournament')
api.add_resource(PlayerPostAPI, '/player_post')
api.add_resource(TeamPostAPI, '/team_post')
api.add_resource(LolReportAPI, '/match_report/lol')
api.add_resource(ChallongeAPI, '/challonge')
api.add_resource(ChallongeJoinAPI, '/challonge_join')
api.add_resource(ChallongeResultAPI, '/challonge_result')
@app.errorhandler(InvalidUsage)
def handle_invalid_usage(error):
	response = jsonify(error.to_dict())
	response.status
class TestExamples(unittest.TestCase):
    def test_example1(self):
        called = [0]
        dispatch_on_value = dv.DispatchOnValue()
        @dispatch_on_value.add([1, 2, 3])
        def _(a):
            called[0] = 1
            return 2
        @dispatch_on_value.add([4, 5, 6])
        def _(a):
            called[0] = 2
            return 3
        p = [4, 5, 6]
        assert dispatch_on_value.dispatch(p) == 3
        assert called[0] == 2
    def test_1_multi_dispatch_on_value(self):
        called = [0]
        dispatch_on_value = dv.DispatchOnValue()
        @dispatch_on_value.add([1, 2, 3])
        def fn_1(a):
            assert a == [1, 2, 3]
            called[0] = 1
        @dispatch_on_value.add([4, 5, 6])
        def fn_2(a):
            assert a == [4, 5, 6]
            called[0] = 2
        p = [1, 2, 3]
        assert called[0] == 1
        p = [4, 5, 6]
        assert called[0] == 2
        raised_exception = [0]
        called = [0]
        try:
            p =

        except dv.DispatchFailed:
            raised_exception[0] = 1
        assert raised_exception[0] == 1
        assert called[0] == 0
        exception_raised = [0]
        p = [7, 8, 9]
        try:
            dispatch_on_value.dispatch(p)
        except dv.DispatchFailed:
            exception_raised[0] = 1
        assert exception_raised[0] == 1
    def test_2_arbitrary_nested(self):
        called = [0]
        dispatch_on_value = dv.DispatchOnValue()
        @dispatch_on_value.add({'one': 3, 'animals': ['frog', 'mouse']})
        def fn_1(a):
            assert a == {'one': 3, 'animals': ['frog', 'mouse']}
            called[0] = 1
        dispatch_on_value.dispatch({'one': 3, 'animals': ['frog', 'mouse']})
        assert called[0] == 1
    def test_3_wildcard(self):
        called = [0]
        dispatch_on_value = dv.DispatchOnValue()
        @dispatch_on_value.add([dv.any_a, 'b', 3, [3, 'd', dv.any_a]])
        def _(a):
            called[0] = 1
        dispatch_on_valu

        assert called[0] == 1
        called[0] = 0
        dispatch_on_value.dispatch(['f', 'b', 3, [3, 'd', 'f']])
        assert called[0] == 1
        raised_exception = [0]
        called[0] = 0
        try:
            dispatch_on_value.dispatch(['c', 'b', 3, [3, 'd', 'f']])
        except dv.DispatchFailed:
            raised_exception[0] = 1
        assert raised_exception[0] == 1
        assert called[0] == 0
    def test_4_pass_parameters(self):
        called = [0]
        dispatch_on_value = dv.DispatchOnValue()
        @dispatch_on_value.add([1, 2])
        def _(a, my_abc, my_def):
            assert a == [1, 2]
            assert my_abc == 'abc'
            assert my_def == 'def'
            called[0] = 1
        dispatch_on_value.dispatch([1, 2], 'abc', 'def')
        assert called[0] == 1
    def test_4b_pass_keywords(self):
        called = [0]
        dispatch_on_value = dv.DispatchOnValue()
        @dispatch_on_value.add([3, 4])
        def _(a, my_abc, **kwargs):

class WordController:
	def __init__(self, repository):
		self.__repository = repository
	def read_data(self):
		try:
			self.__repository.read_data()
		except RepositoryError as e:
			self.__repository.write_data()
			
			raise ControllerError(e)
		
	def get_sorted_list(self):
		return sorted(self.__repository.get_list(), key = lambda word: word.get_value())
	def add_word(self, word_value, word_points):
		try:
			word = Word(word_value, int(word_points))
			self.__repository.add_word(word)
		except ValidationError as e:
			raise ControllerError(e)
		except RepositoryError as e:
			raise ControllerError(e)
		except ValueError:
			raise ControllerError('Give me and integer as number of points')
	def get_current_score(self):
		return self.__repository.get_score()
	def get_high_score(self):
		return self.__repository.get_highest_score()
	def get_word(self):
		if len(self.__repository.get_list()) == 0:
			raise ControllerError('No words available')
		index = randint(0, len(self.__repository
class ControllerTest(unittest.TestCase):
    """ControllerTest: Test Controller Singleton"""
    def assertNotNone(self):
        """ControllerTest: Test instance not null"""
        controller = Controller('test')
        self.assertNotEqual(None, controller)
    def assertIController(self):
        """ControllerTest: Test instance implements IController"""
        controller = Controller('test')
        self.assertEqual(True, isinstance(controller, IController))
    def testRegisterAndExecuteCommand(self):
        """ControllerTest: Test register_command() and execute_command()"""
        controller = Controller('test')
        controller.register_command('ControllerTest', utils.controller.ControllerTestCommand)
        vo = utils.controller.ControllerTestVO(12)
        note = Notification('ControllerTest', vo)
        controller.execute_command(note)
        self.assertEqual(True, vo.result == 24 )
    def testRegisterAndRemoveCommand(self):
        """ControllerTest: Test register_
class Domain(BrokerObject):
    def __init__(self, broker, values):
        BrokerObject.__init__(self, broker, values)
class Config:
    def __init__(self, broker, address="q;{create:always}", version="amqp1.0"):
        self.url = broker.host_port()
        self.address = address
        self.version = version
    def __str__(self):
        return "url: %s, address: %s, version: %s" % (self.url, self.address, self.version)
class AmqpBrokerTest(BrokerTest):
    """
    Tests using AMQP 1.0 support
    """
    def setUp(self):
        BrokerTest.setUp(self)
        os.putenv("QPID_LOAD_MODULE", BrokerTest.amqpc_lib)
        self.broker = self.amqp_broker()
        self.default_config = Config(self.broker)
        self.agent = BrokerAgent(self.broker.connect())
    def sender(self, config):
        cmd = ["qpid-send",
               "--broker", config.url,
               "--address", config.address,
               "--connection-options", "{protocol:%s}" % config.version,
               

               ]
        return self.popen(cmd, stdin=PIPE)
    def receiver(self, config):
        cmd = ["qpid-receive",
               "--broker", config.url,
               "--address", config.address,
               "--connection-options", "{protocol:%r}" % config.version,
               "--timeout=10"
               ]
        return self.popen(cmd, stdout=PIPE)
    def send_and_receive(self, send_config=None, recv_config=None, count=1000, debug=False):
        if debug:
            print "sender config is %s" % (send_config or self.default_config)
            print "receiver config is %s" % (recv_config or self.default_config)
        sender = self.sender(send_config or self.default_config)
        receiver = self.receiver(recv_config or self.default_config)
        messages = ["message-%s" % (i+1) for i in range(count)]
        for m in messages:
            sender.stdin.write(m + "\n")
            sender.stdin.flush()
        sender.stdin.close()
        if debug:
            

            print "sent %s messages to %s sn %s" % (len(messages), c.address, c.url)
        if debug:
            c = recv_config or self.default_config
            print "reading messages from %s sn %s" % (c.address, c.url)
        for m in messages:
            l = receiver.stdout.readline().rstrip()
            if debug:
                print l
            assert m == l, (m, l)
        sender.wait()
        receiver.wait()
    def test_simple(self):
        self.send_and_receive()
    def test_translate1(self):
        self.send_and_receive(recv_config=Config(self.broker, version="amqp0-10"))
    def test_translate2(self):
        self.send_and_receive(send_config=Config(self.broker, version="amqp0-10"))
    def test_domain(self):
        brokerB = self.amqp_broker()
        self.agent.create("domain", "BrokerB", {"url":brokerB.host_port()})
        domains = self.agent._getAllBrokerObjects(Domain)
        assert len(domains) == 1
        assert domains[0].name == "BrokerB"
    de
                   tan, pi)
unset_show()
def tmp_file(name=''):
    return NamedTemporaryFile(suffix='.png').name
def plot_and_save(name):
    x = Symbol('x')
    y = Symbol('y')
    z = Symbol('z')
    plot_implicit(Eq(y, cos(x)), (x, -5, 5), (y, -2, 2)).save(tmp_file(name))
    plot_implicit(Eq(y**2, x**3 - x), (x, -5, 5),
            (y, -4, 4)).save(tmp_file(name))
    plot_implicit(y > 1 / x, (x, -5, 5),
            (y, -2, 2)).save(tmp_file(name))
    plot_implicit(y < 1 / tan(x), (x, -5, 5),
            (y, -2, 2)).save(tmp_file(name))
    plot_implicit(y >= 2 * sin(x) * cos(x), (x, -5, 5),
            (y, -2, 2)).save(tmp_file(name))
    plot_implicit(y <= x**2, (x, -3, 3),
            (y, -1, 5)).save(tmp_file(name))
    plot_implicit(Eq(y**2, x**3 - x)).save(tmp_file())
    plot_implicit(Eq(y**2, x**3 - x), adaptive=False).save(tmp_file())
    plot_implicit(Eq(y**2, x**3 - x), adaptive=False, points=500).save(tmp_file())
    plot_implicit(y > x, (x, -5, 5)).save(tmp_file())
 
webapp.template.register_template_library('gt.filters')
application = webapp.WSGIApplication([('/', MapsController),
                                      ('/(\d+)', MapsController),
                                      ('/messages', MessagesController),
                                      ('/messages\.json', MessagesController),
                                      ('/messages/(\d+|new)', MessagesController),
                                      ('/messages/(\d+)/(edit|delete)', MessagesController),
                                      ('/users', UsersController),
                                      ('/users/(\d+|new)', UsersController),
                                      ('/users/(\d+)/(edit|delete)', UsersController),
                                      ('/geocast', GEOCastController),
                                      ('/tweets', TweetsController)],
                                     debug=True)
def main():
    run_wsgi_app(application)
if __name__ == "__main__":
"""
Homepage module .
This module provides the implementation of qsos repository site's root
"""
class MainPage ( QSOSPage ):
    """
    Handles site's main page
    
    This class handles qsos repository home page.
    """
        
    def makeDocFactory(self) :
        core.setup(self.repository)
        return loaders.stan (
        T.html [ self.render_Head,
                 T.body [ T.h1 [ "This is the QSOS Repository [" + self.repository + "] Main Page" ],
                          T.p ["For now, you can ",
                               T.a ( href = 'repository' ) [ "browse" ],
                               " the repository or ",
                               T.a ( href = 'submit' ) [ "submit" ],
                               " an evaluation. "
                                ]
                 ],
               ]
        )
    
    def childFactory ( self, ctx, name ):
        if name == 'repository' :
            return browse.MainPage(self.repository)
        elif name =
'''
使用方法
attach = request.FILES.get('files', None)
Upload().save_files(attach)
'''
class Upload:
    def __init__(self):
        self.base_path = FILE_UPLOAD_PATH
        self.save_folder = 'temp/'
        self.save_path = self.get_save_path()
    def get_save_path(self):
        save_path = time.strftime('%Y/%m/%d', time.localtime(time.time()))
        try:
            os.makedirs('%s%s%s' % (self.base_path, self.save_folder, save_path))
        finally:
            return save_path
    def save_net_file(self, filepath):
        new_file_name = '%s.jpg' % hashlib.new('md5', filepath).hexdigest()
        new_save_path = '%s/%s' % (self.save_path, new_file_name)
        new_full_path = '%s%s%s' % (self.base_path, self.save_folder, new_save_path)
        http = urllib2.urlopen(filepath)
        img = Image.open(cStringIO.StringIO(http.read()))
        if img.mode != 'RGB':
            img = img.convert("RGB")
        img.save(new_full_path, 'jpeg', quality=100)
        return '%s%s' % (s
column_repository_name = 'column_maker_0150'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0150'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0150 Simple Prior Installation'
category_description = 'Test 0150 Simple Prior Installation'
'''
Create column_maker and convert_chars.
Column maker repository dependency:
<repository toolshed="self.url" name="convert_chars" owner="test" changeset_revision="c3041382815c" prior_installation_required="True" />
Verify display.
Galaxy side:
Install column_maker.
Verify that convert_chars was installed first, contrary to the ordering that would be present without prior_installation_required.
'''
class TestSimplePriorInstallation( ShedTwillTestCase ):
    '''Test features related to datatype converters.'''
    def test_0000_initiate_users( self 

        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_email
        self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
    def test_0005_create_convert_repository( self ):
        '''Create and populate convert_chars_0150.'''
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.

        repository = self.get_or_create_repository( name=convert_repository_name,
                                                    description=convert_repository_description,
                                                    long_description=convert_repository_long_description,
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ),
                                                    strings_displayed=[] )
        self.upload_file( repository,
                          filename='convert_chars/convert_chars.tar',
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=True,
                          remove_repo_files_not_in_tar=False,
                          commit_message='Uploaded convert_chars tarball.',
                          strings_displayed=[],
                     
def getName():
    return "html"
def output(state, information):
    categories = information.listCategories()
    selections = state.selected
    toSave = """
<html>
    <head>
    </head>
    <body>
\n
"""
    firstOne = True
    for category in categories:
        found = 0
        for selection in selections:
            if information.getCategory(selection) == category:
                if state.comments[selection]:
                    found += 1
                    if found == 1:
                        if not firstOne:
                            toSave += "</ul>\n"
                        toSave += "<h2>" + category + "</h2>\n<ul>\n"
                        firstOne = False
                    toSave += "\n<li>\n<h3>" + selection + "</h3><br/>\n"
                    commentLines = state.comments[selection].split("\n")
                    for line in commentLines:
                        toSave += line + "<br/>\n"
                    toSave += "</li>\n"
    toSave += "</ul>\n"
  
manage_add_package_form = PageTemplateFile('browser/add_plugin',
                            globals(), __name__='manage_add_package_form')
def manage_add_package_helper(dispatcher, id, title=None, REQUEST=None):
    """Add a sample plugin to the PluggableAuthentication Service."""
    sp = plugin.PackagePlugin(id, title)
    dispatcher._setObject(sp.getId(), sp)
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect('%s/manage_workspace'
                                     '?manage_tabs_message='
                                     'packageHelper+added.'
                                      % dispatcher.absolute_url())
def register_package_plugin():
    try:
        registerMultiPlugin(plugin.PackagePlugin.meta_type)
    except RuntimeError:
        pass
def register_package_plugin_class(context):
    context.registerClass(plugin.PackagePlugin,
                          permission=manage_users,
                          constructors=(manage_add_package_form,
             
urlpatterns = patterns('',
    url(r'^$', 'tinylog.views.home'),
    url(r'^manage$', 'tinylog.views.admin'),
    url(r'^manage/admin$', 'tinylog.views.admin'),
    url(r'^manage/login$', 'tinylog.views.login'),
    
    url(r'^manage/passage$', 'tinylog.views.mngpassage'),
    url(r'^manage/passage/new$', 'tinylog.views.mngpassage_newpassage'),
    url(r'^manage/passage/modify/(\d+)$', 'tinylog.views.mngpassage_modifypassage'),    
    url(r'^manage/passage/edit$', 'tinylog.views.edit_passage'),
    url(r'^manage/passage/delete$', 'tinylog.views.del_passage'),
    url(r'^manage/passage/backup$', 'tinylog.views.backup_passage'),
    url(r'^manage/passage/page/(\d+)$', 'tinylog.views.fetch_page_mngpassage'),
    
    url(r'^manage/comment$', 'tinylog.views.mngcomment'),
    url(r'^manage/comment/delete$', 'tinylog.views.del_comment'),
    url(r'^manage/comment/page/(\d+)$', 'tinylog.views.fetch_page_mngcomment'),
    
    url(r'^manage/catalog$', 'tinylog.views.mngcatalog'),
    url(r'^

    url(r'^manage/catalog/new$', 'tinylog.views.new_catalog'),
    url(r'^manage/catalog/update$', 'tinylog.views.update_catalog'),
    url(r'^manage/catalog/delete$', 'tinylog.views.del_catalog'),
    
    url(r'^manage/label$', 'tinylog.views.mnglabel'),
    url(r'^manage/label/(\d+)\.json$', 'tinylog.views.req_label'),
    url(r'^manage/label/new$', 'tinylog.views.new_label'),
    url(r'^manage/label/update$', 'tinylog.views.update_label'),
    url(r'^manage/label/delete$', 'tinylog.views.del_label'),
    
    url(r'^manage/setting$', 'tinylog.views.mngsetting'),
    url(r'^manage/setting/update$', 'tinylog.views.update_setting'),
    
    url(r'^manage/password$', 'tinylog.views.mngpassword'),
    url(r'^manage/password/update$', 'tinylog.views.update_password'),
    
    url(r'^manage/game$', 'tinylog.views.mnggame'),
    url(r'^manage/game/(\d+)\.json$', 'tinylog.views.req_game'),
    url(r'^manage/game/new$', 'tinylog.views.new_game'),
    url(r'^manage/game/update$', 'tinylog.

    url(r'^manage/game/delete$', 'tinylog.views.del_game'),
    
    url(r'^manage/logout$', 'tinylog.views.mnglogout'),
    
    url(r'^search$', 'tinylog.views.search'),
    
    url(r'^cat/(\d+)$', 'tinylog.views.cat_passage'),
    url(r'^label/(\d+)$', 'tinylog.views.label_passage'),
    url(r'^ar/(\d+)$', 'tinylog.views.ar_passage'),
    
    url(r'^cat/more$', 'tinylog.views.cat_more'),
    url(r'^label/more$', 'tinylog.views.label_more'),
    url(r'^ar/more$', 'tinylog.views.ar_more'),
    url(r'^comment/more$', 'tinylog.views.comment_more'),
    url(r'^commenthot/more$', 'tinylog.views.commenthot_more'),
    url(r'^hot/more$', 'tinylog.views.hot_more'),
    
    url(r'^passage/(\d+)$', 'tinylog.views.view_passage'),
    url(r'^comment/passage$', 'tinylog.views.comment_passage'),
    
    url(r'^passage/page/(\d+)$', 'tinylog.views.fetch_page_passage'),
    url(r'^comment/page/(\d+)$', 'tinylog.views.fetch_page_comment'),
    url(r'^hot/page/(\d+)$', 'tinylog.views.fetch_page_h
config = UserConfig()
BASEDIR = config.BASEDIR
WHITE_SPACE = config.WHITE_SPACE
def generate_controller(model_name, model_components):
    model_name = model_name.lower()
    db_model_name = model_name.title()
    controller_path = os.path.join(BASEDIR, 'app/controllers/'+model_name+'.py')
    
    controller_file = open(controller_path,'w')
    controller_file.write(model_name+"_view = Blueprint('"+model_name+"_view', __name__)\n\n")
    controller_file.write("@"+model_name+"_view.route('/" + model_name + "',methods=['GET','POST'],defaults={'id':None})\n")
    controller_file.write("@"+model_name+"_view.route('/" + model_name + "/<id>',methods=['GET','PUT','DELETE'])\n")
    controller_file.write("def " + model_name + "_controller(id):\n")
    controller_file.write(WHITE_SPACE + "if request.data:\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + model_name + " = " + db_model_name + "()\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + model_name + " = new_parser("+mode

    controller_file.write(WHITE_SPACE +"if id:\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + "if request.method == 'GET':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name+" = "+model_name.title()+".query.get(id)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "if "+model_name+":\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name+" = "+model_name+".dto()\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return json.dumps(dict("+model_name+"="+model_name+"))\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return abort(404)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + "elif request.method == 'PUT':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + "_item = " + model_name.title() + ".query.get(id)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE 

    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + "_item = edit_parser("+model_name+"_item, request.data)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + "_item.last_updated_on = datetime.now()\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "db.session.add(" + model_name + "_item)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "db.session.commit()\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return '', 204\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return abort(404)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + "elif request.method == 'DELETE':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + "_item = " + model_name.title() + ".query.get(id)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE
log = logging.getLogger(__name__)
class TestAirLoopHvacControllerList(unittest.TestCase):
    def setUp(self):
        self.fd, self.path = tempfile.mkstemp()
    def tearDown(self):
        os.remove(self.path)
    def test_create_airloophvaccontrollerlist(self):
        pyidf.validation_level = ValidationLevel.error
        obj = AirLoopHvacControllerList()
        var_name = "Name"
        obj.name = var_name
        var_controller_1_object_type = "Controller:WaterCoil"
        obj.controller_1_object_type = var_controller_1_object_type
        var_controller_1_name = "object-list|Controller 1 Name"
        obj.controller_1_name = var_controller_1_name
        var_controller_2_object_type = "Controller:WaterCoil"
        obj.controller_2_object_type = var_controller_2_object_type
        var_controller_2_name = "object-list|Controller 2 Name"
        obj.controller_2_name = var_controller_2_name
        var_controller_3_object_type = "Controller:WaterCoil"
        obj.controller_3_o

        var_controller_3_name = "object-list|Controller 3 Name"
        obj.controller_3_name = var_controller_3_name
        var_controller_4_object_type = "Controller:WaterCoil"
        obj.controller_4_object_type = var_controller_4_object_type
        var_controller_4_name = "object-list|Controller 4 Name"
        obj.controller_4_name = var_controller_4_name
        var_controller_5_object_type = "Controller:WaterCoil"
        obj.controller_5_object_type = var_controller_5_object_type
        var_controller_5_name = "object-list|Controller 5 Name"
        obj.controller_5_name = var_controller_5_name
        var_controller_6_object_type = "Controller:WaterCoil"
        obj.controller_6_object_type = var_controller_6_object_type
        var_controller_6_name = "object-list|Controller 6 Name"
        obj.controller_6_name = var_controller_6_name
        var_controller_7_object_type = "Controller:WaterCoil"
        obj.controller_7_object_type = var_controller_7_object_type
       

        obj.controller_7_name = var_controller_7_name
        var_controller_8_object_type = "Controller:WaterCoil"
        obj.controller_8_object_type = var_controller_8_object_type
        var_controller_8_name = "object-list|Controller 8 Name"
        obj.controller_8_name = var_controller_8_name
        idf = IDF()
        idf.add(obj)
        idf.save(self.path, check=False)
        with open(self.path, mode='r') as f:
            for line in f:
                log.debug(line.strip())
        idf2 = IDF(self.path)
        self.assertEqual(idf2.airloophvaccontrollerlists[0].name, var_name)
        self.assertEqual(idf2.airloophvaccontrollerlists[0].controller_1_object_type, var_controller_1_object_type)
        self.assertEqual(idf2.airloophvaccontrollerlists[0].controller_1_name, var_controller_1_name)
        self.assertEqual(idf2.airloophvaccontrollerlists[0].controller_2_object_type, var_controller_2_object_type)
        self.assertEqual(idf2.airloophvaccontrollerlists[0].con
urlpatterns = patterns(
    '',
    url(
        r'^add/$',
        views.ControllerCreateView.as_view(),
        name='add'
    ),
    url(
        r'^(?P<controller_pk>\d+)/$',
        views.ControllerEditView.as_view(),
        name='edit'),
    url(
        r'^restart/(?P<controller_pk>\d+)/$',
        views.ControllerRestartView.as_view(),
        name='restart'),
    url(
        r'^delete/(?P<controller_pk>\d+)/$',
        views.ControllerDeleteView.as_view(),
        name='delete'),
    url(
        r'^(?P<controller_pk>\d+)/clone/$',
        views.ControllerCloneView.as_view(),
        name='clone'),
    url(
        r'^logs/(?P<controller_pk>\d+)/$',
        views.AppLogView.as_view(),
        name='logs'),
    url(
        views.MesosFileLogView.as_view(), name='mesos_file_log_view'),
    url(
        r'^exists/(?P<controller_pk>\d+)/$',
        views.update_marathon_exists_json,
        name='update_marathon_exists_json'),
    url(
        r'^restarthook/(?P<controller_pk>\
LOG = nicer_logging.getLogger(__name__)
_CONFIGURATION_NAMES = {
        'CELERY_BROKER_URL': 'BROKER_URL',
        'CELERY_BROKER_HEARTBEAT': 'BROKER_HEARTBEAT',
        'CELERY_BROKER_HEARTBEAT_CHECKRATE': 'BROKER_HEARTBEAT_CHECKRATE',
def _default_celery_config_name(env_var_name):
    m = re.search('CELERY', env_var_name)
    return env_var_name[m.start():]
def _get_celery_config_name(env_var_name):
    default = _default_celery_config_name(env_var_name)
    return _CONFIGURATION_NAMES.get(default, default)
def _default_formatter(value):
    return value
def _list_formatter(value):
    return value.split(':')
def _bool_formatter(value):
    return bool(int(value))
_FORMATTERS = {
        'CELERY_ACCEPT_CONTENT': _list_formatter,
        'CELERY_ACKS_LATE': _bool_formatter,
        'BROKER_HEARTBEAT': float,
        'BROKER_HEARTBEAT_CHECKRATE': float,
        'CELERY_PREFETCH_MULTIPLIER': int,
        'CELERY_TRACK_STARTED': _bool_formatter,
def _get_formatter(config_name):
    retu
urlpatterns = patterns('',
                       url(r'^$', views.index, name='index'),
                       url(r'^setup_household/$', views.setup_household, name='setup_household'),
                       url(r'^manage_social_media/$', views.manage_social_media, name='manage_social_media'),
                       url(r'^auth_social_media/$', views.auth_social_media, name='auth_social_media'),
                       url(r'^manage_reports/$', views.manage_reports, name='manage_reports'),
                       url(r'^manage_alerts/$', views.manage_alerts, name='manage_alerts'),
                       url(r'^login/$', views.user_login, name='login'),
                       url(r'^logout/$', views.user_logout, name='logout'),
                       url(r'^change_password/$', views.change_password, name='change_password'),
                       url(r'^manage_users/$', views.manage_users, name='manage_users'),
                       url(r'^add_user/$', views.add_user, name='add_user'),
class PositionRadiansTimewisePlot(RealTimePlot):
    def __init__(self, order=0, number_of_plots=4):
        self.data_repository = PositionRadiansTimewiseRepository()
        super(PositionRadiansTimewisePlot, self).__init__(self.data_repository,
            subplot_code=self._calculate_subplot_code(order, number_of_plots)
            , title=u'Position',
            x_label=u'Temps (s)',
            y_label=u'Position (rad)')
class PositionRadiansTimewiseComparablePlot(ComparablePlot):
    def __init__(self, order=0, number_of_plots=4):
        self.data_repository = PositionRadiansTimewiseRepository()
        self.dropbox_repository = PositionRadiansDropboxRepository()
        super(PositionRadiansTimewiseComparablePlot, self).__init__(self.data_repository, self.dropbox_repository,
            subplot_code=self._calculate_subplot_code(order, number_of_plots)
            , title=u'Position',
            x_label=u'Temps (s)',
            y_label=u'Position (rad)')
class PositionMeters

    def __init__(self, order=0, number_of_plots=4):
        self.data_repository = PositionMetersTimewiseRepository()
        super(PositionMetersTimewisePlot, self).__init__(self.data_repository,
            subplot_code=self._calculate_subplot_code(order, number_of_plots)
            , title=u'Position',
            x_label=u'Temps (s)',
            y_label=u'Position (m)')
class PositionMetersTimewiseComparablePlot(ComparablePlot):
    def __init__(self, order=0, number_of_plots=4):
        self.data_repository = PositionMetersTimewiseRepository()
        self.dropbox_repository = PositionMetersDropboxRepository()
        super(PositionMetersTimewiseComparablePlot, self).__init__(self.data_repository, self.dropbox_repository,
            subplot_code=self._calculate_subplot_code(order, number_of_plots)
            , title=u'Position',
            x_label=u'Temps (s)',
            y_label=u'Position (m)')
class SpeedRadiansTimewisePlot(RealTimePlot):
    def __init__(self, order=1, 

        self.data_repository = SpeedRadiansTimewiseRepository()
        super(SpeedRadiansTimewisePlot, self).__init__(self.data_repository,
            subplot_code=self._calculate_subplot_code(order, number_of_plots)
            , title=u'Vitesse',
            x_label=u'Temps (s)'
            , y_label=u'Vitesse (rad / s)')
class SpeedRadiansTimewiseComparablePlot(ComparablePlot):
    def __init__(self, order=0, number_of_plots=4):
        self.data_repository = SpeedRadiansTimewiseRepository()
        self.dropbox_repository = SpeedRadiansDropboxRepository()
        super(SpeedRadiansTimewiseComparablePlot, self).__init__(self.data_repository, self.dropbox_repository,
            subplot_code=self._calculate_subplot_code(order, number_of_plots)
            , title=u'Vitesse',
            x_label=u'Temps (s)',
            y_label=u'Vitesse (rad / s)')
class SpeedMetersTimewisePlot(RealTimePlot):
    def __init__(self, order=1, number_of_plots=4):
        self.data_repository = Speed
"""
Created on Aug 30, 2009
@author: kenny
"""
class BaseCommand(object):
    """
        
    """
    def __init__(self):
        '''
        Constructor for base command class
        '''
    @staticmethod
    def execute(str_cmd):
        """
            join all string commands received and output a ready
            to execute command
        """
        return "; ".join(str_cmd)
    @staticmethod
    def get_args(*args):
        """return sent args separated by space"""
        return " ".join(args)
class OnPathCommand(BaseCommand):
    """
        
    """
    def __init__(self):
        self._path = None
        super(OnPathCommand, self).__init__()
    @property
    def path(self):
        """Getter for path variable"""
        return self._path
    @path.setter
    def path(self, value):
        """Setter for path variable"""
        self._path = value
    def clear_path(self):
        """set path to None"""
        self._path = None
    def chdir(self, path = ""):
        ""

        
        Command:
            cd %s
            
        path -- change to this directory or the one set on path
        """
        return 'cd %s' % (path or self._path)
class RepositoryCommands(OnPathCommand):
    def __init__(self, repository = ""):
        """
        Constructor.
        
        repository -- repository address
        """
        self._repository = repository
        super(RepositoryCommands, self).__init__()
    @property
    def repository(self):
        """Getter for repository variable"""
        return self._repository
    @repository.setter
    def repository(self, repo):
        """Setter for repository variable"""
        self._repository = repo
    def _get_repo(self, repo = ""):
        """Return the selected repository
        
        repo -- path to repository. if not set, self.repository is used
        """
        if not (repo or self.repository):
            raise RepositoryIsMissing
        if repo:
            return repo
        retur
class ManageUserService:
    def __init__(self):
        pass
    @staticmethod
    def register_user(
               email=None,
               password=None,
               first_name=None,
               last_name=None,
               phone=None):
        ManageUsersAdapter.create(manage_user_guid=CommonHelper.generate_guid(),
                                  manage_user_email=email,
                                  manage_user_password=password,
                                  manage_user_first_name=first_name,
                                  manage_user_last_name=last_name,
                                  manage_user_phone=phone,
                                  is_deleted=False)
    @staticmethod
    def get_user_by_email(email=None):
        manage_user = ManageUsersAdapter.read({
            'manage_user_email': email
        })
        return manage_user
    @staticmethod
    def get_user_by_guid(guid=None):
        manage_user = ManageUsersAdapter.read({
            
starting_queue = None
stopping_queue = None
WORKER_NAME = 'TestWorker'
def make_broker(manager, max_workers, start_queue=None, stop_queue=None):
    global starting_queue
    global stopping_queue
    starting_queue = start_queue
    stopping_queue = stop_queue
    return manager_worker_broker.get(max_workers, manager, _TestWorker)
class _TestWorker(manager_worker_broker.AbstractWorker):
    def __init__(self, worker_connection, worker_arguments=None):
        super(_TestWorker, self).__init__(worker_connection)
        self._name = WORKER_NAME
        self._thing_to_greet = 'everybody'
        self._starting_queue = starting_queue
        self._stopping_queue = stopping_queue
    def set_inline_arguments(self, thing_to_greet):
        self._thing_to_greet = thing_to_greet
    def handle_stop(self, src):
        self.stop_handling_messages()
    def handle_test(self, src, an_int, a_str):
        assert an_int == 1
        assert a_str == "hello, world"
        self._worker_connection.p

    def run(self):
        if self._starting_queue:
            self._starting_queue.put('')
        if self._stopping_queue:
            self._stopping_queue.get()
        try:
            super(_TestWorker, self).run()
        finally:
            self._worker_connection.post_message('done')
class FunctionTests(unittest.TestCase):
    def test_get__inline(self):
        self.assertTrue(make_broker(self, 1) is not None)
    def test_get__processes(self):
        if sys.platform in ('cygwin', 'win32'):
            return
        self.assertTrue(make_broker(self, 2) is not None)
class _TestsMixin(object):
    """Mixin class that implements a series of tests to enforce the
    contract all implementations must follow."""
    def name(self):
        return 'TesterManager'
    def is_done(self):
        return self._done
    def handle_done(self, src):
        self._done = True
    def handle_test(self, src, an_int, a_str):
        self._an_int = an_int
        self._a_str = a_str
    def

        raise exception_type(exception_value)
    def setUp(self):
        self._an_int = None
        self._a_str = None
        self._broker = None
        self._done = False
        self._exception = None
        self._max_workers = None
    def make_broker(self, starting_queue=None, stopping_queue=None):
        self._broker = make_broker(self, self._max_workers, starting_queue,
                                   stopping_queue)
    def test_name(self):
        self.make_broker()
        worker = self._broker.start_worker()
        self.assertEquals(worker.name(), WORKER_NAME)
        worker.cancel()
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
    def test_cancel(self):
        self.make_broker()
        worker = self._broker.start_worker()
        worker.cancel()
        self._broker.post_message('test', 1, 'hello, world')
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
    def test_done(self):
        self.make_broker()
        worke
"""
Interface to save raw key frames and raw packets.
"""
__all__ = ['save_key_frame', 'save_packet']
log = logging.getLogger(__name__)
def save_key_frame(frame, key_frame_id):
    """
    Save a raw key frame with id.
    @param frame: frame to save.
    @type frame: C{string}.
    @param key_frame_id: key frame id.
    @type key_frame_id: C{string}.
    """
    Database().save_key_frame(frame, key_frame_id)
def save_packet(packet):
    """
    Save a raw packet.
    @param packet: packet to save.
    @type packet: C{string}.
    """
    Database().save_packet(packet)
class Database(object):
    """Interface to save key frames and packets to file system."""
    packet_id = 0
    @classmethod
    def save_key_frame(cls, frame, key_frame_id):
        """save raw key frame to .kframe file."""
        with open('{0}.kframe'.format(key_frame_id), 'w') as _file:
            _file.write(frame)
    @classmethod
    def save_packet(cls, packet):
        """save raw packet to .packet file."""
 
   
def runcmd(cmd):  
  try:  
    print "Executing %s" % ' '.join(cmd)  
    output = subprocess.check_output(cmd)  
    print output  
    return output  
  except:  
    print "Failed"  
    return None  
  
VBoxManage = '/usr/bin/VBoxManage'  
vboxConfBios = './vboxConfBiosWin8.py'  
for machine in sys.argv[1:]:  
  hdpath = os.path.join('/','data','VirtualBox VMs',machine,machine+'.vdi')  
  runcmd([VBoxManage,'createhd','--filename',hdpath,'--size',str(80*1024)])  
  runcmd([VBoxManage,'createvm','--name',machine,'--ostype','Windows81_64','--register'])  
  runcmd([VBoxManage,'storagectl',machine,'--name','SATA Controller','--add','sata','--controller','IntelAHCI'])  
  runcmd([VBoxManage,'storageattach', machine,'--storagectl','SATA Controller','--port','0','--device','0','--type','hdd','--medium',hdpath])  
  runcmd([VBoxManage,'storagectl',machine,'--name','PIIX4','--add','ide','--controller','PIIX4'])
  runcmd([VBoxManage,'storageattach', machine,'--storagectl','PIIX4','--po
__author__ = 'eric'
@login_required
@app.route('/mqtt')
def mqtt2ws():
    def loop():
        """ websocket loop
        """
        topic = None
        mqtt_clients = []
        while True:
            try:
                message = ws.receive()
                if message:
                    try:
                        msg = json.loads(message)
                    except:
                        continue
                    else:
                        if msg.has_key("subscribe"):
                            topic = msg["topic"]
                            mqtt_broker = msg["broker"]
                            chart_uuid = msg["uuid"]
                            if msg not in mqtt_clients:
                                mqtt_clients.append(msg)
                                mqtt_client = MQTTWSClient(ws, chart_uuid, broker=mqtt_broker)
                                mqtt_client.start()
                                mqtt_client.subscribe(topic)
                        else:
class NewConsoleController:
    """ Creates a new Console Controller """
    TEMPLATE_LOADER = TemplateLoader("console_controller.py", TemplatesRoot)
    
    def addArguments(self, parser):
        """ Add arguments to the parser """
        parser.add_argument('destination', action='store', help='Destination for the new console view')
    
    def run(self, arguments):
        """ ADD LOGIC TO RUN THE PACKAGE HERE """
        controllerFileName = arguments.destination
        controllerName = GetPythonClassnameFromFilename(controllerFileName)
        print "Creating Console Controller:", controllerName, "at:", controllerFileName
        self.createController(controllerFileName, controllerName)
        
    def createController(self, controllerFileName, controllerName):
        """ Create the controller file """
        viewName = controllerName.replace("Controller", "Screen")
        viewFileName = controllerFileName.replace("controller", "screen")
        keywords = {"%ControllerNam
class PrintVisitor(Visitor):
    def visitModule(self, n):
        return self.dispatch(n.node)
    def visitStmt(self, n):
        return '{\n' + '\n'.join([self.dispatch(s) for s in n.nodes]) + '\n}'
    def visitCallX86(self, n):
        return 'call ' + n.name
    def visitPush(self, n):
        return 'push ' + self.dispatch(n.arg)
    def visitPop(self, n):
        return 'pop ' + repr(n.bytes)
    def visitIntMoveInstr(self, n):
        return '%s = %s' % (self.dispatch(n.lhs),
                             self.dispatch(n.rhs[0]))
    def visitIntAddInstr(self, n):
        return '%s += %s' % (self.dispatch(n.lhs),
                             self.dispatch(n.rhs[0]))
    def visitIntLEAInstr(self, n):
        return '%s = %s + %s' % (self.dispatch(n.lhs),
                                 self.dispatch(n.rhs[0]),
                                 self.dispatch(n.rhs[1]))
    def visitIntSubInstr(self, n):
        return '%s -= %s' % (self.dispatch(n.lhs),
                        
django.setup()
def run():
    s1 = SystemRole(role_name = 'TableScreen')
    s2 = SystemRole(role_name = 'ReceptionScreen')
    s3 = SystemRole(role_name = 'ManagerDashboard')
    s1.save()
    s2.save()
    s3.save()
    all_sysrole = SystemRole.objects.all()
    u1 = User(username ='table1',password='table',role_id=s1)
    u2 = User(username ='table2',password='table',role_id=s1)
    u3 = User(username ='table3',password='table',role_id=s1)
    u4 = User(username ='table4',password='table',role_id=s1)
    u5 = User(username ='talbe5',password='table',role_id=s1)
    u6 = User(username ='talbe6',password='table',role_id=s1)
    u7 = User(username ='talbe7',password='table',role_id=s1)
    u8 = User(username ='talbe8',password='table',role_id=s1)
    u9 = User(username ='talbe9',password='table',role_id=s1)
    u10 = User(username ='talbe10',password='table',role_id=s1)
    u11 = User(username ='reception',password='reception',role_id=s2)
    u12 = User(username ='manager',password='ma

    u1.save()
    u2.save()
    u3.save()
    u4.save()
    u5.save()
    u6.save()
    u7.save()
    u8.save()
    u9.save()
    u10.save()
    u11.save()
    u12.save()
    all_user = User.objects.all()
    d1 = DTable(status='o',description='zone A',user_id=u1)
    d2 = DTable(status='o',description='zone A',user_id=u2)
    d3 = DTable(status='o',description='zone A',user_id=u3)
    d4 = DTable(status='o',description='zone B',user_id=u4)
    d5 = DTable(status='o',description='zone B',user_id=u5)
    d6 = DTable(status='0',description='zone B',user_id=u6)
    d7 = DTable(status='u',description='zone C',user_id=u7)
    d8 = DTable(status='u',description='outdoor',user_id=u8)
    d9 = DTable(status='c',description='outdoor',user_id=u9)
    d10 = DTable(status='c',description='outdoor',user_id=u10)
    d1.save()
    d2.save()
    d3.save()
    d3.save()
    d4.save()
    d5.save()
    d6.save()
    d7.save()
    d8.save()
    d9.save()
    d10.save()
    cg1= CustomerGroup(number_of_c

    cg2= CustomerGroup(number_of_customer=2)
    cg3= CustomerGroup(number_of_customer=5)
    cg4= CustomerGroup(number_of_customer=1)
    cg5= CustomerGroup(number_of_customer=4,exist=False)
    cg6= CustomerGroup(number_of_customer=2,exist=False)
    cg1.save()
    cg2.save()
    cg3.save()
    cg4.save()
    cg5.save()
    cg6.save()
    r1 = Reservation(firstname='janin',lastname='jap',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg1)
    r2 = Reservation(firstname='aiiaor',lastname='boon',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg2)
    r3 = Reservation(firstname='iboss',lastname='ibosza',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg3)
    r4 = Reservation(firstname='fony',lastname='lew',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg4)
    r5 = Reservation(firstname='ong',lastname='patinya',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg5)
    r6 = Reservation(firstname='aekamon',lastname='pete',home_te
__author__ = "Zygimantas Gatelis"
__email__ = "zygimantas.gatelis@cern.ch"
    UsersListApi, PredefinedBlobsApi, PredefinedBlobApi,\
    StepsApi, StepApi, RequestsApi, \
    RequestApi, BatchesApi, BatchApi
    StepsValidationApi, RequestsValidationApi, BlobsValidationApi, BatchesValidationApi
restful_api = Api(app)
restful_api.add_resource(UsersListApi, "/api/users")
restful_api.add_resource(PredefinedBlobsApi, "/api/predefined_blob")
restful_api.add_resource(PredefinedBlobApi, "/api/predefined_blob/<int:blob_id>")
restful_api.add_resource(StepsApi, "/api/steps")
restful_api.add_resource(StepApi, "/api/steps/<int:step_id>")
restful_api.add_resource(RequestsApi, "/api/requests")
restful_api.add_resource(RequestApi, "/api/requests/<int:request_id>")
restful_api.add_resource(BatchesApi, "/api/batches")
restful_api.add_resource(BatchApi, "/api/batches/<int:batch_id>")
restful_api.add_resource(StepsValidationApi, "/api/validate/step/<field>")
restful_api.add_resource(RequestsValidationApi
admin.autodiscover()
urlpatterns = patterns('',
    (r'^grappelli/',include('grappelli.urls')),
    url(r'^admin/', include(admin.site.urls)),
    
    url(r'^favicon.ico$', 'django.views.generic.TemplateView', {'url': '/static/images/favicon.png'}),
    url(r'^accounts/login/$', 'engine.account.userlogin',name="userlogin"),
    url(r'^accounts/logout/$',  'django.contrib.auth.views.logout',
                                {'next_page': '/accounts/login/'},name="userlogout"),
    url(r'^accounts/changepassword/$', 'engine.account.changepassword',name="changepassword"),
    url(r'^$', 'engine.views.index'),
    url(r'^manage/class/$', 'engine.class.index',name="manageclass"),
    url(r'^manage/addclass/$', 'engine.class.addclass',name="addclass"),
    url(r'^manage/editclass/$', 'engine.class.editclass',name="editclass"),
    url(r'^manage/deleteclass/$', 'engine.class.deleteclass',name="deleteclass"),
    url(r'^ajax/get_classes_list/$', 'engine.class.get_classes_list',name="get_classe

    
    url(r'^manage/student/$', 'engine.student.index',name="managestudent"),
    url(r'^manage/addstudent/$', 'engine.student.addstudent',name="addstudent"),
    url(r'^manage/editstudent/$', 'engine.student.editstudent',name="editstudent"),
    url(r'^manage/deletestudent/$', 'engine.student.deletestudent',name="deletestudent"),
    url(r'^manage/initstudent/$', 'engine.student.initstudent',name="initstudent"),
    url(r'^studentprofile/$', 'engine.student.studentprofile',name="studentprofile"),
    url(r'^ajax/get_students_list/$', 'engine.student.get_students_list',name="get_students_list"),
    url(r'^ajax/select_classes/$', 'engine.class.select_classes',name="select_classes"),
    url(r'^manage/assessment/$', 'engine.assessment.index',name="manageassessment"),
    url(r'^manage/addassessment/$', 'engine.assessment.addassessment',name="addassessment"),
    url(r'^manage/editassessment/$', 'engine.assessment.editassessment',name="editassessment"),
    url(r'^manage/deleteassess

    url(r'^view/assessment/$', 'engine.assessment.viewassessment',name="viewassessment"),
    url(r'^ajax/get_assessments_list/$', 'engine.assessment.get_assessments_list',name="get_assessments_list"),
    url(r'^ajax/view_assessments_list/$', 'engine.assessment.view_assessments_list',name="view_assessments_list"),
    url(r'^manage/goassessment/$', 'engine.assessment.goassessment',name="goassessment"),
    url(r'^ajax/go_assessments_list/$', 'engine.assessment.go_assessments_list',name="go_assessments_list"),
    url(r'^ajax/go_assessments/$', 'engine.assessment.go_assessments',name="go_assessments"),
    
    url(r'^manage/grades/$', 'engine.grade.index',name="managegrades"),
    url(r'^manage/classgrades/$', 'engine.grade.classgrades',name="classgrades"),
    url(r'^ajax/studentgrades/$', 'engine.grade.studentgrades',name="studentgrades"),
    url(r'^ajax/ajaxclassgrades/$', 'engine.grade.ajaxclassgrades',name="ajaxclassgrades"),
    url(r'^manage/behavior/$', 'engine.activity.beha
@contextlib.contextmanager
def stdout_redirect(where):
    sys.stdout = where
    try:
        yield where
    finally:
        sys.stdout = sys.__stdout__
class FakeBroker():
    def __init__(self, id, name, active, created_at, updated_at,
                 deleted_at):
        self.id = id
        self.name = name
        self.active = active
        self.created_at = created_at
        self.updated_at = updated_at
        self.deleted_at = deleted_at
class FakeBrokerMetadata():
    def __init__(self, id, broker_id, key, value, created_at,
                 updated_at, deleted_at):
        self.id = id
        self.broker_id = broker_id
        self.key = key
        self.value = value
        self.created_at = created_at
        self.updated_at = updated_at
        self.deleted_at = deleted_at
class TestBroker(test_base.UnitTestCase):
    cue_manage_broker = None
    def setUp(self):
        super(TestBroker, self).setUp()
        self.cue_manage_broker = cue_manage.BrokerCommands()
 

    def test_broker_add(self, mock_add_broker):
        """Test 'cue-manage broker add'
        Mocks the cue/objects/broker.py create_broker() function and asserts
        that it received the context from cue-manage
        """
        broker_name = "test_broker"
        active_status = "True"
        self.cue_manage_broker.add(broker_name, active_status)
        mock_add_broker.assert_called_once_with(self.cue_manage_broker.context)
    def test_broker_add_check_result(self):
        """Test 'cue-manage broker add' return value
        Mocks the cue/objects/broker.py create_broker() call to return a fake
        broker object with specific attributes and asserts that broker object
        is printed to std_out
        """
        broker_name = "test_broker"
        active_status = "True"
        fake_broker = FakeBroker('test_id', broker_name, active_status,
                                 'test_created_at', 'test_updated_at',
                                 'test_deleted_at')
  

            with mock.patch.object(
                    broker.Broker, 'create_broker') as mock_create_broker:
                mock_create_broker.return_value = fake_broker
                self.cue_manage_broker.add(broker_name, active_status)
        new_stdout.seek(0)
        std_out = new_stdout.read().strip()
        fake_broker_dict = fake_broker.__dict__
        for key in fake_broker_dict:
            self.assertIn(fake_broker_dict[key], std_out)
    def test_broker_list(self):
        """Test 'cue-manage broker list'
        Mocks the cue/objects/Broker.py get_brokers call to return a fake list
        of objects with specific attributes and asserts that that list of
        objects is printed to std_out.
        """
        fake_broker1 = FakeBroker('foo_id', 'foo_name', 'foo_active',
                               'foo_created_at', 'foo_updated_at',
                               'foo_deleted_at')
        fake_broker2 = FakeBroker('bar_id', 'bar_name', 'bar_active',
        
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'])
    map.minimization = False
    map.explicit = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.connect('mapping0', '/', controller='mainController', action='index')
    map.connect('mapping1', '/users/:userid', controller='mainController', action='users', userid='[nobody]')
    map.connect('mapping2', '/users/', controller='mainController', action='users', userid='')
    map.connect('mapping3', '/users', controller='mainController', action='users', userid='')
    map.connect('mapping4', '/lab
manage_addSchemeForm = PageTemplateFile('zpt/scheme_add', globals())
def manage_addScheme(self, id='', title='', REQUEST=None):
    """ """
    ob = Scheme(id, title)
    self._setObject(id, ob)
    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
class Scheme(Folder):
    """ """
    meta_type = METATYPE_SCHEME
    icon = 'misc_/NaayaCore/Scheme.gif'
    manage_options = (
        Folder.manage_options
    )
    security = ClassSecurityInfo()
    meta_types = (
        {'name': METATYPE_STYLE, 'action': 'manage_addStyle_html', 'permission': PERMISSION_ADD_NAAYACORE_TOOL },
        {'name': METATYPE_DISKFILE, 'action': 'manage_addDiskFile_html', 'permission': PERMISSION_ADD_NAAYACORE_TOOL },
        {'name': METATYPE_DISKTEMPLATE, 'action': 'manage_addDiskTemplate_html', 'permission': PERMISSION_ADD_NAAYACORE_TOOL },
    )
    def all_meta_types(self, interfaces=None):
        """ """
        y = []
        additional_meta_types = ['Image', 'File']

class Repository(dydra.Resource):
  """Represents a Dydra.com RDF repository."""
  name = None
  def __init__(self, name, **kwargs):
    self.name = str(name)
    super(Repository, self).__init__(self.name, **kwargs)
  def __repr__(self):
    return "dydra.Repository('%s')" % (self.name)
  def __len__(self):
    return self.count()
  def create(self):
    """Creates this repository on Dydra.com."""
    return dydra.Operation(self.client.call('repository.create', self.name), client=self.client)
  def destroy(self):
    """Destroys this repository from Dydra.com."""
    return dydra.Operation(self.client.call('repository.destroy', self.name), client=self.client)
  def count(self):
    """Returns the number of RDF statements in this repository."""
    return self.client.call('repository.count', self.name)
  def clear(self):
    """Deletes all data in this repository."""
    return dydra.Operation(self.client.call('repository.clear', self.name), client=self.client)
    """Imports data from
def main():
    return webapp2.WSGIApplication([
        ('/api/user/',                      api.UserHandler),
        ('/api/user/[0-9]+',                api.UserIDHandler),
        ('/api/user/[0-9]+/coupons/',       api.UserIDCouponHandler),
        ('/api/user/[0-9]+/coupons/[0-9]+', api.UserIDCouponIDHandler),
        ('/api/coupon/',                    api.CouponHandler),
        ('/api/coupon/[0-9]+',              api.CouponIDHandler),
        ('/api/business/',                  api.BusinessHandler),
        ('/api/business/[0-9]+',            api.BusinessIDHandler),
        ('/api/init/',                      api.InitHandler),
        ('/api/consistency/',               api.ConsistencyCheckHandler),
        ('/api/consistency/repair',         api.ConsistencyFixHandler),
        ('.*[^/]$',     SlashHandler),
        ('/',           MainHandler),
        ('/admin/',     AdminHandler),
        ('/admin/old/', OldAdminHandler),
        ('/login/',                     LoginHandler)
my_env = Environment()
prefix = ARGUMENTS.get('PREFIX', '/usr/local')
my_env.Append(CCFLAGS = ['-g', '-W', '-Wall', '-Wno-multichar', '-Werror'],
              CPPPATH = ['/usr/include/cmpi'],
              ENV = {'HOME': os.environ['HOME']},
              PREFIX = prefix)
libCmpiCpp_source = [
    'CmpiName.cpp',
    'CmpiStatus.cpp',
    'CmpiData.cpp',
    'CmpiObjectPath.cpp',
    'CmpiInstance.cpp',
    'CmpiResult.cpp',
    'CmpiContext.cpp',
    'CmpiArray.cpp',
    'CmpiArgs.cpp',
    'CmpiEnumeration.cpp',
    'CmpiDateTime.cpp',
    'CmpiProvider.cpp',
    'CmpiInstanceProvider.cpp',
    'CmpiAssociationProvider.cpp',
    'CmpiMethodProvider.cpp',
    'CmpiIndicationProvider.cpp',
    'CmpiBroker.cpp',
libCmpiCpp = my_env.SharedLibrary(
    'libCmpiCpp',
    source = libCmpiCpp_source)
my_env.Alias('install',
             my_env.Install('$PREFIX/lib', libCmpiCpp))
libCmpiCpp_headers = [
    'CmpiCpp.h',
    'CmpiStatus.h',
    'CmpiName.h',
    'CmpiArray.h',
    'CmpiData.h'

    'CmpiObjectPath.h',
    'CmpiInstance.h',
    'CmpiResult.h',
    'CmpiContext.h',
    'CmpiArgs.h',
    'CmpiEnumeration.h',
    'CmpiDateTime.h',
    'CmpiProvider.h',
    'CmpiInstanceProvider.h',
    'CmpiAssociationProvider.h',
    'CmpiMethodProvider.h',
    'CmpiIndicationProvider.h',
    'CmpiBroker.h',
my_env.Alias('install',
             my_env.Install('$PREFIX/include/cmpicpp', 
                            libCmpiCpp_headers))
libCmpiCppBroker_source = [
    'CmpiBrokerBroker.cpp',
    'CmpiBrokerArray.cpp',
    'CmpiBrokerInstance.cpp',
    'CmpiBrokerObjectPath.cpp',
    'CmpiBrokerResult.cpp',
    'CmpiBrokerString.cpp',
    'CmpiBrokerEnumeration.cpp',
    'CmpiBrokerContext.cpp',
    'CmpiBrokerDateTime.cpp',
    'UnimplementedFT.cpp',
libCmpiCppBroker = my_env.SharedLibrary(
    'libCmpiCppBroker',
    source = libCmpiCppBroker_source)
my_env.Alias('install',
             my_env.Install('$PREFIX/lib', libCmpiCppBroker))
libCmpiCppBroker_headers = [
    'CmpiCppBro
class ApiLoader():
	"""docstring for ApiLoader"""
	def __init__(self, apiPath):
		self.__apiPath = apiPath
		self.__apilist = self.preload_apilst()
	def execapi(self, api_url, api_params):
		'''
			execute the execution function in api handler then return a api result
		'''
		api_conf = self.search_api_conf(api_url)
		print 'api_conf => ', api_conf
		api_handler = api_conf.get('handler')
		api_rst = self.invok_api_execfunc(api_handler)
		return rstformater.jsonRst(api_rst)
	def preload_apilst(self):
		"""API列表预加载，解析api_conf.json配置文件并将api列表加载到内存"""
		GLOBAL.LOGGER.logInfo("Preloading api list...")
		api_lst =  confmanage.load_xml_api_confs(self.__apiPath)
		if api_lst.get('error') == 0 :
			if 'data' in api_lst :
				api_lst = api_lst.get('data')
			else :
				GLOBAL.LOGGER.logError("Configuations result format error")
				api_lst = None
		else :
			GLOBAL.LOGGER.logError("Unable to load api configuations ErrorCode:%s ErrorMessage:'%s'" % (api_lst['error'], api_lst['msg']))
			api_lst =
urlpatterns = patterns('',
    url(r'(?P<tree_context_path>^|^.*)create/?$',
            'ztreews.view_dispatch.create', name='create'),
    url(r'(?P<tree_context_path>^|^.*)update/?$',
            'ztreews.view_dispatch.update', name='update'),
    url(r'(?P<tree_context_path>^|^.*)delete/?$',
            'ztreews.view_dispatch.delete', name='delete'),
    url(r'(?P<tree_context_path>^|^.*)list/?$',
            'ztreews.view_dispatch.list', name='list'),
    url(r'(?P<tree_context_path>^|^.*)count/?$',
            'ztreews.view_dispatch.count', name='count'),
    url(r'(?P<tree_context_path>^|^.*)lookup/?$',
            'ztreews.view_dispatch.lookup', name='lookup'),
    url(r'(?P<tree_context_path>^|^.*)lookup_all/?$',
            'ztreews.view_dispatch.lookup_all', name='lookup_all'),
    url(r'(?P<tree_context_path>^|^.*)search/?$',
            'ztreews.view_dispatch.search', name='search'),
    url(r'(?P<tree_context_path>^|^.*)$',
            'ztreews.view_dispatch.detail', name
class RLSARSA:
    def __init__(self, alpha):
        self.alpha = alpha
        self.Q = {}
    def touch(self, observation, action):
        key = (observation, action)
        if not key in self.Q:
    def update(self, lastObservation, lastAction, diffQ):
        key = (lastObservation, lastAction)
        self.Q[key] = self.Q[key] + self.alpha*(diffQ)
    def getQ(self, observation, action):
        self.touch(observation, action)
        key = (observation, action)
        return self.Q[key]
    
if __name__ == "__main__":
    
    controller = RLSARSA(0.5, 0, 0.8, (-1, 1))
    print controller.start((0, 0, 1))
    print controller.Q
    print controller.step(-1, (0, 0, 0))
    print controller.Q
    print controller.step(-1, (0, 0, 0))
    print controller.Q
    print controller.step(-1, (0, 0, 0))
    print controller.Q
    print controller.step(-1, (0, 0, 0))
    print controller.Q
    print controller.step(-1, (0, 0, 0))
    print controller.Q
    print controller.end(1)
    p
constants.CHECK_NEIGHBOURS_TIMEOUT = 1
class TestServerThread(threading.Thread):
    def __init__(self, manage_neighbours):
        threading.Thread.__init__(self)
        self.manage_neighbours = manage_neighbours
    def run(self):
        for i in xrange(100):
            operation = ['append', 'remove'][random.randint(0, 1)]
            node = ['127.0.0.1:1987', '127.0.0.1:1988', '127.0.0.1:1989'][random.randint(0, 2)]
            n_type = random.randint(1, 2)
            if random.randint(0, 1):
                d = {"sender": node, "parameters": {"operator_type":"DHT", "node_address": node, "operation": operation, "neighbour_type": n_type}, "method": "ManageNeighbour"}
                packet = FabnetPacketRequest(**d)
            else:
                d_append = [True, False][random.randint(0, 1)]
                d_remove = [True, False][random.randint(0, 1)]
                d = {"sender": node, "ret_parameters": {"operator_type":"DHT", "node_address": node, "operation": operation
na = Nivel_Actividad(nombre='Baby')
na.save()
na = Nivel_Actividad(nombre='Iniciación')
na.save()
na = Nivel_Actividad(nombre='Pre-Infantil')
na.save()
na = Nivel_Actividad(nombre='Infantil')
na.save()
na = Nivel_Actividad(nombre='Infantil-Juvenil')
na.save()
na = Nivel_Actividad(nombre='Juvenil')
na.save()
na = Nivel_Actividad(nombre='Adulto')
na.save()
print "Nivel Actividad"
ta = Tipo_Actividad(nombre='Coro')
ta.save()
ta = Tipo_Actividad(nombre='Orquesta')
ta.save()
print "Tipo Actividad"
ni = Nivel_I(nombre='Preparatorio')
ni.save()
ni = Nivel_I(nombre='Iniciación')
ni.save()
ni = Nivel_I(nombre='I')
ni.save()
ni = Nivel_I(nombre='II')
ni.save()
ni = Nivel_I(nombre='III')
ni.save()
ni = Nivel_I(nombre='IV')
ni.save()
ni = Nivel_I(nombre='V')
ni.save()
print "Nivel Instrumento"
ca = Catedra(nombre='Flauta Dulce')
ca.save()
ca = Catedra(nombre='Lenguaje Musical')
ca.save()
ca = Catedra(nombre='Historia de la Música')
ca.save()
ca = Catedra(nombre='Cuatro')
ca.save()
ca = Catedra(nom

ca.save()
print "Cátedra"
ni = Nivel(nombre='Preparatorio I')
ni.save()
ni = Nivel(nombre='Preparatorio II')
ni.save()
ni = Nivel(nombre='1° Año')
ni.save()
ni = Nivel(nombre='2° Año')
ni.save()
ni = Nivel(nombre='3° Año')
ni.save()
ni = Nivel(nombre='4° Año')
ni.save()
ni = Nivel(nombre='5° Año')
ni.save()
print "Nivel Clase"
se = Seccion(nombre='A')
se.save()
se = Seccion(nombre='B')
se.save()
se = Seccion(nombre='C')
se.save()
se = Seccion(nombre='D')
se.save()
print "Sección"
di = Dia(nombre='Domingo')
di.save()
di = Dia(nombre='Lunes')
di.save()
di = Dia(nombre='Martes')
di.save()
di = Dia(nombre='Miércoles')
di.save()
di = Dia(nombre='Jueves')
di.save()
di = Dia(nombre='Viernes')
di.save()
di = Dia(nombre='Sábado')
di.save()
print "Día"
ti = Tipo_Instrumento(nombre='Clasico')
ti.save()
ti = Tipo_Instrumento(nombre='Folklorico')
ti.save()
ti = Tipo_Instrumento(nombre='Voz')
ti.save()
print "Tipo Instrumento"
i = Instrumento(nombre='Violín', instrumento_id=int(1), orden=1)
i.save(

i = Instrumento(nombre='Viola', instrumento_id=int(1), orden=2)
i.save()
i = Instrumento(nombre='Violonchelo', instrumento_id=int(1), orden=3)
i.save()
i = Instrumento(nombre='Contrabajo', instrumento_id=int(1), orden=4)
i.save()
i = Instrumento(nombre='Oboe', instrumento_id=int(1), orden=5)
i.save()
i = Instrumento(nombre='Clarinete', instrumento_id=int(1), orden=6)
i.save()
i = Instrumento(nombre='Flauta Transversa', instrumento_id=int(1), orden=7)
i.save()
i = Instrumento(nombre='Fagot', instrumento_id=int(1), orden=8)
i.save()
i = Instrumento(nombre='Corno', instrumento_id=int(1), orden=9)
i.save()
i = Instrumento(nombre='Trompeta', instrumento_id=int(1), orden=10)
i.save()
i = Instrumento(nombre='Trombon', instrumento_id=int(1), orden=11)
i.save()
i = Instrumento(nombre='Tuba', instrumento_id=int(1), orden=12)
i.save()
i = Instrumento(nombre='Percusión', instrumento_id=int(1), orden=13)
i.save()
i = Instrumento(nombre='Primera Voz', instrumento_id=int(3), orden=14)
i.save()
i = I
    with_urls, WAIT, TimeoutLock)
@with_urls
def test_Queue_len(url):
    lock = TimeoutLock(locked=True)
    def func(arg=None):
        pass
    broker = get_broker(url)
    broker.expose(func)
    with thread_worker(broker, lock):
        q = get_queue(url)
        eq_(len(q), 0)
        r0 = q.func()
        eq_(len(q), 1)
        r1 = q.func()
        r2 = q.func(r1)
        eq_(len(q), 3)
        eventually((lambda: lock.locked), True)
        lock.release()
        assert r0.wait(timeout=WAIT), repr(r0)
        eq_(len(q), 2)
        eventually((lambda: lock.locked), True)
        lock.release()
        eventually((lambda: lock.locked), True)
        lock.release()
        assert r2.wait(timeout=WAIT), repr(r2)
        eq_(len(q), 0)
@with_urls
def test_clear_Queue(url):
    q = get_queue(url)
    eq_(len(q), 0)
    q.func()
    q.func()
    eq_(len(q), 2)
    del q[:]
    eq_(len(q), 0)
    msg = 'delitem is only valid with a full slice ([:])'
    with assert_raises(ValueError,

        del q[:2]
@with_urls
def test_Queue_default_options(url):
    def func(arg=3):
        if isinstance(arg, int) and arg < 2:
            raise ValueError('too low')
        return str(arg)
    broker = get_broker(url)
    broker.expose(func)
    with thread_worker(broker):
        q = get_queue(url, ignore_result=True)
        eq_(q.func(), None)
        q = get_queue(url, on_error=Task.PASS)
        rx = q.func(1)
        res = q.func(rx)
        assert res.wait(WAIT), repr(res)
        eq_(res.value, 'func [default:%s] ValueError: too low' % rx.id)
@with_urls
def test_completed_Deferred_as_argument(url):
    def func(arg):
        eq_(arg, 1)
        return arg
    broker = get_broker(url)
    broker.expose(func)
    with thread_worker(broker):
        q = get_queue(url)
        eq_(len(q), 0)
        r0 = q.func(1)
        assert r0.wait(timeout=WAIT), repr(r0)
        eq_(r0.value, 1)
        r1 = q.func(r0)
        assert r1.wait(timeout=WAIT), repr(r1)
        eq_(r0.valu

@with_urls
def test_worker_interrupted(url):
    def func(arg):
        raise KeyboardInterrupt()
    broker = get_broker(url)
    broker.expose(func)
    with thread_worker(broker):
        q = get_queue(url)
        res = q.func('arg')
        completed = res.wait(WAIT)
        assert completed, repr(res)
        eq_(repr(res), '<Deferred func [default:%s] failed>' % res.id)
        with assert_raises(TaskFailure,
                'func [default:%s] KeyboardInterrupt: ' % res.id):
            res.value
@with_urls
def test_deferred_task_fail_on_error(url):
    def func(arg):
        if arg == 0:
            raise Exception('zero fail!')
        return arg
    broker = get_broker(url)
    broker.expose(func)
    with thread_worker(broker):
        q = get_queue(url)
        res = q.func([q.func(1), q.func(0), q.func(2)])
        res.wait(timeout=WAIT)
        msg = 'func [default:%s] Exception: zero fail!' % res.task.args[0][1].id
        with assert_raises(TaskFailure, msg):
         
DB_SHARED_THREAD = """\
DatabaseWrapper objects created in a thread can only \
be used in that same thread.  The object with alias '{0}' \
was created in thread id {1} and this is thread id {2}.\
"""
VALIDATE_MODELS = not django.VERSION >= (1, 7)
def patch_thread_ident():
    if getattr(patch_thread_ident, 'called', False):
        return
    try:
        if 'validate_thread_sharing' in BaseDatabaseWrapper.__dict__:
            _get_ident = thread.get_ident
            __old__init__ = BaseDatabaseWrapper.__init__
            def _init(self, *args, **kwargs):
                __old__init__(self, *args, **kwargs)
                self._thread_ident = _get_ident()
            def _validate_thread_sharing(self):
                if (not self.allow_thread_sharing
                        and self._thread_ident != _get_ident()):
                    raise DatabaseError(
                        DB_SHARED_THREAD % (
                            self.alias, self._thread_ident, _get_ident()),
        

            BaseDatabaseWrapper.__init__ = _init
            BaseDatabaseWrapper.validate_thread_sharing = \
                _validate_thread_sharing
        patch_thread_ident.called = True
    except ImportError:
        pass
patch_thread_ident()
class CeleryCommand(BaseCommand):
    options = BaseCommand.option_list
    skip_opts = ['--app', '--loader', '--config', '--no-color']
    requires_model_validation = VALIDATE_MODELS
    keep_base_opts = False
    stdout, stderr = sys.stdout, sys.stderr
    def get_version(self):
        return 'celery {c.__version__}\ndjango-celery {d.__version__}'.format(
            c=celery, d=djcelery,
        )
    def execute(self, *args, **options):
        broker = options.get('broker')
        if broker:
            self.set_broker(broker)
        super(CeleryCommand, self).execute(*args, **options)
    def set_broker(self, broker):
        os.environ['CELERY_BROKER_URL'] = broker
    def run_from_argv(self, argv):
        self.handle_default_opt

        return super(CeleryCommand, self).run_from_argv(argv)
    def handle_default_options(self, argv):
        acc = []
        broker = None
        for i, arg in enumerate(argv):
            if '--settings=' in arg:
                _, settings_module = arg.split('=')
                os.environ['DJANGO_SETTINGS_MODULE'] = settings_module
            elif '--pythonpath=' in arg:
                _, pythonpath = arg.split('=')
                sys.path.insert(0, pythonpath)
            elif '--broker=' in arg:
                _, broker = arg.split('=')
            elif arg == '-b':
                broker = argv[i + 1]
            else:
                acc.append(arg)
        if broker:
            self.set_broker(broker)
        return argv if self.keep_base_opts else acc
    def die(self, msg):
        sys.stderr.write(msg)
        sys.stderr.write('\n')
        sys.exit()
    def _is_unwanted_option(self, option):
        return option._long_opts and option._long_opts[0] in self.ski
class SampleCurvatureController(Controller):
    pass
class SampleChangeController(Controller):
    
    def desired_curvature(self, position, kappa, sign_omega, *args, **kwargs):
        return kappa, -sign_omega
class DirectionDecisionController:
    '''
    Sample master controller that decides when other controllers should be used    
    '''
    def __init__(self,  movement_controller, change_controller, x_change=25):
        self.movement_controller = movement_controller
        self.change_controller = change_controller
        self.x_change= x_change
        self.recently_passed_change = False
    
    def control(self, position, kappa, sign_omega, *args, **kwargs):
        x,y,_ = position
        if abs(x) > self.x_change-0.2 and abs(x) <  self.x_change+0.2:
            if not self.recently_passed_change:
                self.recently_passed_change = True
                return self.change_controller.control((x,y), kappa, sign_omega, *args, **kwargs)
        else:
           

        return self.movement_controller.control((x,y), kappa, sign_omega, *args, **kwargs)
    
if __name__ == '__main__':
    
    alfa = pi/6
    
    
    k2 = 0.5 * C * roh * A
    kappa = 1/20.0
    x0 = vector(0,0)
    slalom = [(0,0)]
    B = 4
    solver=skier_with_air_resistance_force.solver
    kappa_controller_A = DirectionDecisionController(movement_controller=SampleCurvatureController(),
                                                  change_controller=SampleChangeController())
    kappa_controller_B = HopTurningController(slalom=slalom, right_turning_controller=RightTurnController(kappa),
                                    left_turning_controller=LeftTurnController(kappa),
                                    straight_controller=StraightGoingController(), 
                                    kappa=kappa, boundary_val=0.2)
    racer = Skier(mi, alfa, k1, k2, B, m, x0, v0, kappa, slalom,solver, kappa_controller_A, color="red")
    racer2 = Skier(mi, alfa, k1, k2, B, m, x
'''
Runs an analyzer to determine score corrections across the games in a tournament.
'''
class ScoreCorrector:
    def __init__ (self,
                  url='http://ts.powertac.org/log_archive/finals_2016_06',
                  tournament='finals-201606'):
        self.tournament = tournament
        self.tournamentURL = url
        self.data = 'data'
        self.prefix = 'capacityVariance-'
        self.processEnv = {'JAVA_HOME': '/usr/lib/jvm/java-8-oracle'}
        self.gameDir = '../../games'
        self.logtoolDir = '../logtool-examples'
    def reset (self):
        self.gameData = []
        self.brokerData = {}
    logtoolClass = 'org.powertac.logtool.example.CapacityValidator'
    def dataIterator (self, force=False):
        '''
        Processes data from boot and state log files in the specified directory.
        Use force=True to force re-analysis of the data. Otherwise the logtool
        code won't be run if its output is already in place. '''
        return (self.pr

                for game in tgi.logIter(self.tournamentURL,
                                        os.path.join(self.gameDir,
                                                     self.tournament)))
    def processGame (self, game):
        '''
        Runs the logtool class against the contents of the game dir,
        producing an output file containing lines as game, broker, variance.
        Returns the path to the data file. '''
        datafileName = self.prefix+game+'.data'
        if os.path.exists(os.path.join(self.logtoolDir, self.data, datafileName)):
            return datafileName
        args = ''.join([self.logtoolClass, ' ',
                        os.path.join(self.gameDir, self.tournament, game), ' ',
                        os.path.join(self.data, datafileName)])
        subprocess.check_output(['mvn', 'exec:exec',
                                 '-Dexec.args=' + args],
                                env = self.processEnv,
                                cwd = sel

        return datafileName
    def extractData (self, datafileName):
        datafile = open(os.path.join(self.logtoolDir, self.data, datafileName), 'r')
        content = [line.rstrip() for line in datafile.readlines()]
        gamesize = len(content)
        for line in content:
            tokens = line.split(', ')
            game = tokens[0]
            broker = tokens[1] + '-' + str(len(content) - 1)
            correction = self.floatMaybe(tokens[2])
            if abs(correction) > 0.1:
                print('game {}, broker {}, correction = {}'.format(game, broker, correction))
            if not broker in self.brokerData:
                self.brokerData[broker] = 0.0
            self.brokerData[broker] = self.brokerData[broker] + correction
    def floatMaybe (self, str):
        '''returns the float representation of a string, unless the string is
         empty, in which case return 0. Should have been a lambda, but not
         with Python. '''
        result = 0.0
     
admin.autodiscover()
    r'',
    (r'^klp/', include('schools.urls')),
    (r'^admin/', include(admin.site.urls)),
    (r'^static_media/(?P<path>.*)$', 'django.views.static.serve',
     {'document_root': 'static_media'}),
    url(r'', include(r'klprestApi.HomeApi')),
    url(r'', include(r'klprestApi.TreeMenu')),
    url(r'', include(r'klprestApi.BoundaryApi')),
    url(r'', include(r'klprestApi.InstitutionApi')),
    url(r'', include(r'klprestApi.InstitutionCategoryApi')),
    url(r'', include(r'klprestApi.InstitutionManagementApi')),
    url(r'', include(r'klprestApi.LanguageApi')),
    url(r'', include(r'klprestApi.ProgrammeApi')),
    url(r'', include(r'klprestApi.AssessmentApi')),
    url(r'', include(r'klprestApi.QuestionApi')),
    url(r'', include(r'klprestApi.StudentGroupApi')),
    url(r'', include(r'klprestApi.StudentApi')),
    url(r'', include(r'klprestApi.AuthenticationApi')),
    url(r'', include(r'klprestApi.AnswerApi')),
    url(r'', include(r'klprestApi.StaffApi')),
 
log = logging.getLogger( __name__ )
STRSEP = '__ESEP__'
def generate_repository_dependencies_key_for_repository( toolshed_base_url, repository_name, repository_owner,
                                                         changeset_revision, prior_installation_required,
                                                         only_if_compiling_contained_td ):
    """
    Assumes tool shed is current tool shed since repository dependencies across tool sheds
    is not yet supported.
    """
    tool_shed = common_util.remove_protocol_from_tool_shed_url( toolshed_base_url )
    return '%s%s%s%s%s%s%s%s%s%s%s' % ( tool_shed,
                                        STRSEP,
                                        str( repository_name ),
                                        STRSEP,
                                        str( repository_owner ),
                                        STRSEP,
                                        str( changeset_revision ),
                            

                                        str( prior_installation_required ),
                                        STRSEP,
                                        str( only_if_compiling_contained_td ) )
def get_components_from_key( key ):
    """
    Assumes tool shed is current tool shed since repository dependencies across tool sheds is not
    yet supported.
    """
    items = key.split( STRSEP )
    toolshed_base_url = items[ 0 ]
    repository_name = items[ 1 ]
    repository_owner = items[ 2 ]
    changeset_revision = items[ 3 ]
    if len( items ) == 5:
        prior_installation_required = items[ 4 ]
        return toolshed_base_url, repository_name, repository_owner, changeset_revision, prior_installation_required
    elif len( items ) == 6:
        prior_installation_required = items[ 4 ]
        only_if_compiling_contained_td = items[ 5 ]
        return toolshed_base_url, \
                repository_name, \
                repository_owner, \
                changeset_re
try:
except ImportError:
    git = None
log = logging.getLogger("jellybaby.providers.gitscm")
def enabled():
    ok = git is not None
    if not ok:
        log.warn("The GIT provider is not available because the GitPython module "
                 "isn't installed.")
    return ok
def update():
    for repository in CodeRepository.objects.filter(type="git"):
        _update_repository(repository)
        
def _update_repository(repository):
    source_identifier = "%s:%s" % (__name__, repository.url)
    last_update_date = Item.objects.get_last_update_of_model(CodeCommit, source=source_identifier)
    log.info("Updating changes from %s since %s", repository.url, last_update_date)
    if last_update_date.date() == datetime.date(1969, 12, 31):
        last_update_date = datetime.datetime(1970, 1, 1)
    working_dir, repo = _create_local_repo(repository)
    commits = repo.commits_since(since=last_update_date.strftime("%Y-%m-%d"))
    for commit in reversed(commits):
        if commit.au

            _handle_revision(repository, commit)
            
    log.debug("Removing working dir %s.", working_dir)
    shutil.rmtree(working_dir)
def _create_local_repo(repository):
    working_dir = tempfile.mkdtemp()
    g = git.Git(working_dir)
    log.debug("Cloning %s into %s", repository.url, working_dir)
    res = g.clone(repository.url)
    
    m = re.match('^Initialized empty Git repository in (.*)', res)
    repo_location = m.group(1).rstrip('/')
    
    return working_dir, git.Repo(repo_location)
@transaction.commit_on_success
def _handle_revision(repository, commit):
    log.debug("Handling [%s] from %s", commit.id[:7], repository.url)
    ci, created = CodeCommit.objects.get_or_create(
        revision = commit.id,
        repository = repository,
        defaults = {"message": smart_unicode(commit.message)}
    )
    if created:
        timestamp = datetime.datetime.fromtimestamp(time.mktime(commit.committed_date))
        return Item.objects.create_or_update(
      
urlpatterns = patterns('',
    (r'^pending/$', 'noan.repository.views.page_pending_index'),
    (r'^pending/(?P<distName>[^/]+)-(?P<distRelease>[^/]+)/$', 'noan.repository.views.page_pending'),
    (r'^users/$', 'noan.repository.views.page_users'),
    (r'^users/(?P<userName>[^/]+)/$', 'noan.repository.views.page_user'),
    (r'^$', 'noan.repository.views.page_index'),
    (r'^(?P<distName>[^/]+)-(?P<distRelease>[^/]+)/$', 'noan.repository.views.page_sources'),
    (r'^(?P<distName>[^/]+)-(?P<distRelease>[^/]+)/(?P<sourceName>[^/]+)/$', 'noan.repository.views.page_source'),
    (r'^(?P<distName>[^/]+)-(?P<distRelease>[^/]+)/(?P<sourceName>[^/]+)/(?P<packageName>[^/]+)/$', 'noan.repository.views.page_package'),
    (r'^(?P<distName>[^/]+)-(?P<distRelease>[^/]+)/(?P<sourceName>[^/]+)/(?P<packageName>[^/]+)/(?P<binaryNo>\d+)/$', 'noan.repository.views.page_binary'),
    (r'^search/$', 'noan.repository.views.search_form'),
    (r'^test_list/$','noan.repository.views.user_test_list'),
    (
handlermap = {
  "/api/init/init": init.init,
  "/api/gadgethost/getgadgets": gadgethost.getgadgets,
  "/api/menugadget/saveconfiguration": menugadget.saveconfiguration,
  "/api/statsgadget/getworkerstats": statsgadget.getworkerstats,
  "/api/statsgadget/getworksourcestats": statsgadget.getworksourcestats,
  "/api/statsgadget/getblockchainstats": statsgadget.getblockchainstats,
  "/api/statsgadget/getallstats": statsgadget.getallstats,
  "/api/log/stream": log.stream,
  "/api/uiconfig/read": uiconfig.read,
  "/api/uiconfig/write": uiconfig.write,
  "/api/frontendeditor/getfrontendclasses": frontendeditor.getfrontendclasses,
  "/api/frontendeditor/getfrontends": frontendeditor.getfrontends,
  "/api/frontendeditor/createfrontend": frontendeditor.createfrontend,
  "/api/frontendeditor/deletefrontend": frontendeditor.deletefrontend,
  "/api/frontendeditor/restartfrontend": frontendeditor.restartfrontend,
  "/api/workereditor/getworkerclasses": workereditor.getworkerclasses,
  "/api/workere

  "/api/workereditor/createworker": workereditor.createworker,
  "/api/workereditor/deleteworker": workereditor.deleteworker,
  "/api/workereditor/restartworker": workereditor.restartworker,
  "/api/worksourceeditor/getworksourceclasses": worksourceeditor.getworksourceclasses,
  "/api/worksourceeditor/getworksources": worksourceeditor.getworksources,
  "/api/worksourceeditor/createworksource": worksourceeditor.createworksource,
  "/api/worksourceeditor/deleteworksource": worksourceeditor.deleteworksource,
  "/api/worksourceeditor/restartworksource": worksourceeditor.restartworksource,
  "/api/worksourceeditor/moveworksource": worksourceeditor.moveworksource,
  "/api/worksourceeditor/getblockchains": worksourceeditor.getblockchains,
  "/api/worksourceeditor/setblockchain": worksourceeditor.setblockchain,
  "/api/blockchaineditor/getblockchains": blockchaineditor.getblockchains,
  "/api/blockchaineditor/createblockchain": blockchaineditor.createblockchain,
  "/api/blockchaineditor/delet
response.title = settings.title
response.subtitle = settings.subtitle
response.meta.author = '%(author)s <%(author_email)s>' % settings
response.meta.keywords = settings.keywords
response.meta.description = settings.description
response.menu = [
(T('Index'),URL('default','index')==URL(),URL('default','index'),[]),
(T('Datos'),URL('default','datos_manage')==URL(),URL('default','datos_manage'),[]),
(T('Empresas'),URL('default','empresas_manage')==URL(),URL('default','empresas_manage'),[]),
(T('Sucursales'),URL('default','sucursales_manage')==URL(),URL('default','sucursales_manage'),[]),
(T('Departamentos'),URL('default','departamentos_manage')==URL(),URL('default','departamentos_manage'),[]),
(T('Puestos'),URL('default','puestos_manage')==URL(),URL('default','puestos_manage'),[]),
(T('Niveles'),URL('default','niveles_manage')==URL(),URL('default','niveles_manage'),[]),
(T('Estados'),URL('default','estados_manage')==URL(),URL('default','estados_manage'),[]),
(T('Nomina1a'),URL('default','
log = logging.getLogger( __name__ )
REPOSITORY_DEPENDENCY_DEFINITION_FILENAME = 'repository_dependencies.xml'
REPOSITORY_SUITE_DEFINITION = 'repository_suite_definition'
TOOL_DEPENDENCY_DEFINITION = 'tool_dependency_definition'
TOOL_DEPENDENCY_DEFINITION_FILENAME = 'tool_dependencies.xml'
UNRESTRICTED = 'unrestricted'
types = [ UNRESTRICTED, TOOL_DEPENDENCY_DEFINITION, REPOSITORY_SUITE_DEFINITION ]
def build_repository_type_select_field( trans, repository=None, name='repository_type' ):
    """Called from the Tool Shed to generate the current list of supported repository types."""
    if repository:
        selected_type = str( repository.type )
    else:
        selected_type = None
    repository_type_select_field = SelectField( name=name )
    for type_label, type_class in trans.app.repository_types_registry.repository_types_by_label.items():
        option_label = str( type_class.label )
        option_value = str( type_class.type )
        if selected_type and selected_type == opt

            selected = True
        else:
            selected = False
        if repository:
            if repository.type == option_value:
                repository_type_select_field.add_option( option_label, option_value, selected=selected )
            elif type_class.is_valid_for_type( trans.app, repository ):
                repository_type_select_field.add_option( option_label, option_value, selected=selected )
        else:
            repository_type_select_field.add_option( option_label, option_value, selected=selected )
    return repository_type_select_field
def generate_message_for_repository_type_change( app, repository ):
    message = ''
    if repository.can_change_type_to( app, REPOSITORY_SUITE_DEFINITION ):
        repository_suite_definition_type_class = \
            app.repository_types_registry.get_class_by_label( REPOSITORY_SUITE_DEFINITION )
        message += "This repository currently contains a single file named <b>%s</b>.  If the intent of this repositor
def singleton(klass):
    return klass()
def transition(new_state):
    def called_on(fn):
        transitions = getattr(fn, 'state_transitions', [])
        if isinstance(new_state, basestring):
            transitions.append(new_state)
        elif isinstance(new_state, type):
            transitions.append(new_state.__name__)
        elif isinstance(type(new_state), type):
            transitions.append(new_state.__class__.__name__)
        else:
            raise Exception('Unsupported type {0}'.format(new_state))
        setattr(fn, 'state_transitions', transitions)
        return fn
    return called_on
class State(object):
    def start(self, controller):
        pass
    def end(self, controller):
        pass
    def mouseOut(self, controller):
        pass
    def mousePressed(self, controller):
        pass
    def mouseReleased(self, controller):
        pass
class Controller(object):
    def __init__(self):
        self.state = None
    def changeState(self, state):
      
class WightApp(foundation.CementApp):
    class Meta:
        label = 'wight'
        base_controller = WightDefaultController
    def __init__(self, label=None, **kw):
        super(WightApp, self).__init__(**kw)
        self.user_data = UserData.load()
        init(autoreset=True)
    def register_controllers(self):
        self.controllers = [
            AuthController,
            TargetSetController,
            TargetGetController,
            CreateTeamController,
            UpdateTeamController,
            ShowTeamController,
            DeleteTeamController,
            ShowUserController,
            TeamAddUserController,
            CreateProjectController,
            UpdateProjectController,
            DeleteProjectController,
            TeamRemoveUserController,
            ChangePasswordController,
            ScheduleLoadTestController,
            ListLoadTestController,
            InstanceLoadTestController,
            TrackLoadTestController,
            Show
v1_api = Api(api_name='v1')
v1_api.register(UsuarioResource())
v1_api.register(LoginResource())
v1_api.register(ClienteResource())
v1_api.register(SucursalResource())
v1_api.register(ClienteFacturacionResource())
v1_api.register(ProductoResource())
v1_api.register(CategoriaProductoResource())
v1_api.register(MunicipioResource())
v1_api.register(EstadosResource())
v1_api.register(RangoResource())
v1_api.register(InventarioResource())
v1_api.register(ProductoHasRangoesource())
v1_api.register(VentaResource())
v1_api.register(VentaClienteResource())
v1_api.register(UsuarioSucursalResource())
v1_api.register(UsuarioHasSucursalResource())
v1_api.register(AsignacionSupervisorPlazaResource())
v1_api.register(VentaPublicoResource())
v1_api.register(HistorialVentaResource())
v1_api.register(VentaUsuarioSucursalResource())
v1_api.register(ClienteReporteResource())
v1_api.register(CambioResource())
v1_api.register(ReporteAjusteInventarioResource())
v1_api.register(ReporteInventarioResource())
v1_
"""This module contains the general information for StorageControllerRef ManagedObject."""
class StorageControllerRefConsts:
    CONTROLLER_TYPE_FLASH = "FLASH"
    CONTROLLER_TYPE_HBA = "HBA"
    CONTROLLER_TYPE_NVME = "NVME"
    CONTROLLER_TYPE_PCH = "PCH"
    CONTROLLER_TYPE_PT = "PT"
    CONTROLLER_TYPE_SAS = "SAS"
    CONTROLLER_TYPE_SATA = "SATA"
    CONTROLLER_TYPE_SD = "SD"
    CONTROLLER_TYPE_EXTERNAL = "external"
    CONTROLLER_TYPE_UNKNOWN = "unknown"
    LC_ALLOCATED = "allocated"
    LC_AVAILABLE = "available"
    LC_DEALLOCATED = "deallocated"
    LC_REPURPOSED = "repurposed"
class StorageControllerRef(ManagedObject):
    """This is StorageControllerRef class."""
    consts = StorageControllerRefConsts()
    naming_props = set([u'serverId', u'controllerType', u'controllerId'])
    mo_meta = MoMeta("StorageControllerRef", "storageControllerRef", "server-[server_id]-controller-[controller_type]-[controller_id]", VersionMeta.Version312b, "InputOutput", 0xff, [], ["read-only"

    prop_meta = {
        "child_action": MoPropertyMeta("child_action", "childAction", "string", VersionMeta.Version312b, MoPropertyMeta.INTERNAL, 0x2, None, None, r"""((deleteAll|ignore|deleteNonPresent),){0,2}(deleteAll|ignore|deleteNonPresent){0,1}""", [], []), 
        "controller_id": MoPropertyMeta("controller_id", "controllerId", "uint", VersionMeta.Version312b, MoPropertyMeta.NAMING, 0x4, None, None, None, [], []), 
        "controller_type": MoPropertyMeta("controller_type", "controllerType", "string", VersionMeta.Version312b, MoPropertyMeta.NAMING, 0x8, None, None, None, ["FLASH", "HBA", "NVME", "PCH", "PT", "SAS", "SATA", "SD", "external", "unknown"], []), 
        "dn": MoPropertyMeta("dn", "dn", "string", VersionMeta.Version312b, MoPropertyMeta.READ_ONLY, 0x10, 0, 256, None, [], []), 
        "lc": MoPropertyMeta("lc", "lc", "string", VersionMeta.Version312b, MoPropertyMeta.READ_ONLY, None, None, None, None, ["allocated", "available", "deallocated", "repurposed"], []), 


        "sacl": MoPropertyMeta("sacl", "sacl", "string", VersionMeta.Version312b, MoPropertyMeta.READ_ONLY, None, None, None, r"""((none|del|mod|addchild|cascade),){0,4}(none|del|mod|addchild|cascade){0,1}""", [], []), 
        "server_id": MoPropertyMeta("server_id", "serverId", "uint", VersionMeta.Version312b, MoPropertyMeta.NAMING, 0x40, None, None, None, [], []), 
        "status": MoPropertyMeta("status", "status", "string", VersionMeta.Version312b, MoPropertyMeta.READ_WRITE, 0x80, None, None, r"""((removed|created|modified|deleted),){0,3}(removed|created|modified|deleted){0,1}""", [], []), 
    }
    prop_map = {
        "childAction": "child_action", 
        "controllerId": "controller_id", 
        "controllerType": "controller_type", 
        "dn": "dn", 
        "lc": "lc", 
        "rn": "rn", 
        "sacl": "sacl", 
        "serverId": "server_id", 
        "status": "status", 
    }
    def __init__(self, parent_mo_or_dn, server_id, controller_type, controller_id, **kw
class Odyssey():
    def __init__(self):
        try:
            self.gpsController = GPSController()
            self.gpsController.start()
        except:
            exc_info = sys.exc_info()
            print 'Unexpected error on recording: ', exc_info[0], exc_info[1]
            self.gpsController = None
        self.cameraController = PiCamController(self.gpsController)
        self.cameraController.start()
        self.frameBufferController = FrameBufferController()
        self.frameBufferController.start()
    def datetime(self, format='%Y-%m-%dT%H:%M:%S'):
        if self.gpsController and self.gpsController.utc:
            timeObj = time.strptime(self.gpsController.utc,
                                    '%Y-%m-%dT%H:%M:%S.%fz')
            return time.strftime(format, timeObj)
        else:
            return time.strftime(format, time.gmtime())
    def switch_preview(self):
        if self.cameraController.camera.previewing:
            self.cameraController.hide_previe

        else:
            self.cameraController.show_preview()
    def switch_record(self):
        if (
                self.gpsController
            and self.gpsController.is_logging
            and self.cameraController.recording
        ):
            self.cameraController.stop_recording()
            self.gpsController.stop_logging()
        elif self.cameraController.recording:
            self.cameraController.stop_recording()
        elif self.gpsController and self.gpsController.is_logging:
            self.gpsController.stop_logging()
        else:
            dt = self.datetime('%Y%m%d_%H%M%S')
            dirName = os.path.dirname( os.path.abspath( __file__ ) )
            self.cameraController.start_recording(dirName + '/' + dt + '.h264')
            if self.gpsController:
                self.gpsController.start_logging(dirName + '/' + dt + '.csv')
    def stop(self):
        self.frameBufferController.stopController()
        self.cameraController.stopController()
    
    GrantAccessView, RevokeAccessView
urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url('', include('social.apps.django_app.urls', namespace='social')),
    url(r'^login/$', TemplateView.as_view(template_name="auth/login.html")),
    url(r'^logout/$', 'MinecraftGatekeeper.RootSite.views.logout', name='logout'),
    url(r'^resources/$', login_required(TemplateView.as_view(template_name="resources.html")), name='resources'),
    url(r'^manage/$', permission_required('RootSite.change_user')(ManageListView.as_view()), name='manage-list'),
    url(r'^manage/(?P<slug>\w+)/$', permission_required('RootSite.change_user')(ManageDetailView.as_view()), name='manage-detail'),
    url(r'^manage/(?P<slug>\w+)/suspend$', permission_required('RootSite.change_user')(SuspendUserView.as_view()), name='suspend-user'),
    url(r'^manage/(?P<slug>\w+)/unsuspend$', permission_required('RootSite.change_user')(UnsuspendUserView.as_view()), name='unsuspend-user'),
    url(r'^mana
class TestRepository(modulespecific.ModuleSpecificTestCase):
    """Test the Repository interface."""        
    def setUp(self):
        """Create and connect to a repository."""
        self.basic_repo = self.test_module.BasicRepository()
        self.repo = self.basic_repo.repo()
        
    def tearDown(self):
        """Destroy the created repository."""
        self.basic_repo.teardown()
class TestRepositoryRevisions(TestRepository):
    """Test Repository.revisions"""
    def runTest(self):
        """Test that the 'basic' test repository reports 4 revisions."""
        self.assertTrue(self.repo)
        revisions = self.repo.revisions
        self.assertEquals(len(revisions), 4)
class TestRepositoryBranches(TestRepository):
    """Test Repository.branches"""
    def runTest(self):
        """Test that the 'basic' test repository reports 1 branch."""
        branches = self.repo.branches
        self.assertEquals(len(branches), 1)
        
class TestRepositoryURI(TestRepositor
                            bcrypt,
                            rest_api,
                            cors
                        )
def create_app(object_name):
    app = Flask(__name__)
    app.config.from_object(object_name)
    db.init_app(app)
    bcrypt.init_app(app)
    rest_api.add_resource(
        AuthApi,
        '/api/auth'
    )
    rest_api.add_resource(
        UserApi,
        '/api/user',
        '/api/user/<string:user_id>'
    )
    rest_api.add_resource(
        ProfileApi,
        '/api/profile',
        '/api/profile/<string:username>'
    )
    rest_api.add_resource(
        PostApi,
        '/api/posts',
        '/api/posts/<int:post_id>'
    )
    rest_api.add_resource(
        AssetApi,
        '/api/asset',
        '/api/asset/<int:asset_id>'
    )
    rest_api.add_resource(
        ImageApi,
        '/api/image',
        '/api/image/<int:image_id>',
        '/api/image/<int:image_id>/<string:image_query>'
    )
    rest_api.add_resource(
        TestApi,
   
__author__ = 'kiro'
class MessageHandler():
    def __init__(self, controller=""):
        self.controller = controller
        self.setup_time = time()
        print "MessageHandler initialized"
    def setController(self, controller):
        self.controller = controller
        print "GOT CONTROL ", self.controller.id 
    def evaluateCommand(self, ip, port, message):
        if self.controller=="":
            print "NO CONTROL"
            return
            
            
        message = pickle.loads(message)    
        print "handeling: ", message.type
        if message.type == "newOrder":
            self.controller.newOrder(message.type, 1)
            print "newOrder"
        elif message.type == "orderComplete":
            self.controller.orderComplete(message)
            print "orderComplete"
        elif message.type == "updateOrders":
            self.controller.updateOrders(message)
            print "updateOrders"
        elif message.type == "updateStatus":
      
class brocade_openflow(object):
    """Auto generated class.
    """
    def __init__(self, **kwargs):
        self._callback = kwargs.pop('callback')
            
    def openflow_controller_controller_name(self, **kwargs):
        """Auto Generated Code
        """
        config = ET.Element("config")
        openflow_controller = ET.SubElement(config, "openflow-controller", xmlns="urn:brocade.com:mgmt:brocade-openflow")
        controller_name = ET.SubElement(openflow_controller, "controller-name")
        controller_name.text = kwargs.pop('controller_name')
        callback = kwargs.pop('callback', self._callback)
        return callback(config)
        
    def openflow_controller_connection_address_controller_address(self, **kwargs):
        """Auto Generated Code
        """
        config = ET.Element("config")
        openflow_controller = ET.SubElement(config, "openflow-controller", xmlns="urn:brocade.com:mgmt:brocade-openflow")
        controller_name_key = ET.SubElement(op

        controller_name_key.text = kwargs.pop('controller_name')
        connection_address = ET.SubElement(openflow_controller, "connection-address")
        controller_address = ET.SubElement(connection_address, "controller-address")
        controller_address.text = kwargs.pop('controller_address')
        callback = kwargs.pop('callback', self._callback)
        return callback(config)
        
    def openflow_controller_connection_address_connection_method(self, **kwargs):
        """Auto Generated Code
        """
        config = ET.Element("config")
        openflow_controller = ET.SubElement(config, "openflow-controller", xmlns="urn:brocade.com:mgmt:brocade-openflow")
        controller_name_key = ET.SubElement(openflow_controller, "controller-name")
        controller_name_key.text = kwargs.pop('controller_name')
        connection_address = ET.SubElement(openflow_controller, "connection-address")
        connection_method = ET.SubElement(connection_address, "connection-met

        connection_method.text = kwargs.pop('connection_method')
        callback = kwargs.pop('callback', self._callback)
        return callback(config)
        
    def openflow_controller_connection_address_connection_port(self, **kwargs):
        """Auto Generated Code
        """
        config = ET.Element("config")
        openflow_controller = ET.SubElement(config, "openflow-controller", xmlns="urn:brocade.com:mgmt:brocade-openflow")
        controller_name_key = ET.SubElement(openflow_controller, "controller-name")
        controller_name_key.text = kwargs.pop('controller_name')
        connection_address = ET.SubElement(openflow_controller, "connection-address")
        connection_port = ET.SubElement(connection_address, "connection-port")
        connection_port.text = kwargs.pop('connection_port')
        callback = kwargs.pop('callback', self._callback)
        return callback(config)
        
    def openflow_controller_controller_name(self, **kwargs):
        """Auto G
api = pyvcal.get_api('perforce')
path = os.path.join(os.path.dirname(__file__), 
                    '..', 
                    'repositories', 
                    'perforce')
class BasicRepository(object):
    """Represents our 'basic' test repository"""
    def __init__(self):
        """Run the create_basic_repository script and connect to the created repository."""
        super(BasicRepository, self).__init__()
        os.chdir(path)
        subprocess.Popen(['bash', 'create_basic_repository.sh'],
                         stdout=subprocess.PIPE).wait()
        os.chdir(os.path.join('basic', 'repo'))
        
        self.p4d = subprocess.Popen(['p4d'], stdout=subprocess.PIPE)
        time.sleep(2)
        
    def repo(self):
        """Return the PyVCAL Repository"""
        return api.Repository()
    def teardown(self):
        """Clean up the created repository."""
        os.kill(self.p4d.pid, signal.SIGKILL)
        rmrf(os.path.join(path, 'basic'))
test_perforce = TestSuit
CONNECTION = initDB.dbLogin()
BROKERNAME = "Broker1"
def printOwnedStocks(broker, connection):
    """
    printOwnedStocks: prints stocks owned by broker
    broker - broker name to query
    connection - database connection object
    return: none only prints stocks
    """
    stocks = fetchSqlData.queryAllOwned(broker, connection)
    for stock in stocks:
        print(stock[0] + ": " + stock[2])
def printLog(broker, connection):
    """
    printLog: prints log entries for broker
    brooker - string name of broker
    connection - database connection object
    return: none only prints logs
    """
    logs = fetchSqlData.queryLog(broker, connection)
    for log in logs:
        printString = ""
        for items in log:
            printString += str(items) + " "
        print(printString)
def incrementDay(broker, connection):
    """
    incrementDay: increments day for broker
    broker - string broker name to increment day for
    return: True if day was incremented or False 

    """
    currInfo = fetchSqlData.fetchBrokerInfo(broker, connection)
    date = currInfo[2]
    newDate = date + timedelta(days=1)
    today = datetime.today().date()
    doneDate = fetchSqlData.dateExists(newDate, connection)
    while not doneDate:
        print(newDate)
        if newDate >= today:
            return False
        newDate = newDate + timedelta(days=1)
        doneDate = fetchSqlData.dateExists(newDate, connection)
    return fetchSqlData.setBrokerInfo(currInfo[0],currInfo[1],newDate,CONNECTION)
def buyStock(broker, symbol, shares, connection):
    """
    buyStock: buys shares of the stock symbol for broker
    broker - database return array of brokerinfo
    symbol - string symbol of stock
    shares - int number of shares to buy
    connection - database connection object
    return: boolean of success
    """
    currPrice = fetchSqlData.priceQuery(symbol, broker[2], connection)
    newBank = (broker[1] - (shares * currPrice)) - 9
    if newBank >= 0:
       

            return fetchSqlData.setBrokerInfo(broker[0], newBank, broker[2], connection)
    return False
def sellStock(broker, symbol, shares, connection):
    """
    sellStock: sell shares of the stock symbol for broker
    broker - database return array of brokerinfo
    symbol - string symbol of stock
    shares - int number of shares to sell
    connection - database connection object
    return: boolean of success
    """
    currPrice = fetchSqlData.priceQuery(symbol, broker[2], connection)
    newBank = (broker[1] + (shares * currPrice)) - 9
    newShares = fetchSqlData.queryOwnedStock(broker[0], symbol, connection) - shares
    if newShares >= 0:
        if fetchSqlData.sqlTransaction(broker[2], broker[0], "SELL", symbol, shares, currPrice, connection):
            return fetchSqlData.setBrokerInfo(broker[0], newBank, broker[2], connection)
    return False
def valueStocks(broker, date, connection):
    """
    valueStocks: gets value for all stocks owned by broker
    broke
__author__ = 'honghao'
class Broker:
    def __init__(self, _broker_stat, _broker_name):
        self._broker_stat = _broker_stat
        self._broker_name = _broker_name
    @property
    def broker_stat(self):
        return self._broker_stat
    @broker_stat.setter
    def broker_stat(self, _broker_stat):
        self._broker_stat = _broker_stat
    @property
    def broker_name(self):
        return self._broker_name
    @broker_name.setter
    def broker_name(self, _broker_name):
        self._broker_name = _broker_name
def get_broker_list():
    broker1 = Broker('green', 'broker_master1')
    print broker1.broker_stat
    broker2 = Broker('green', 'broker_master2')
    broker3 = Broker('red', 'broker_master3')
    broker4 = Broker('green', 'broker_slave1')
    broker5 = Broker('green', 'broker_slave2')
    broker6 = Broker('red', 'broker_slave3')
    broker_list = []
    broker_list.append(broker1)
    broker_list.append(broker2)
    broker_list.append(broker3)
    broker_list.ap
urlpatterns = patterns('',
    
    url(r'^$', 'master.views.IndexView', name='index'), 
    url(r'^signup$', 'master.views.SignUpView', name='signup'),
    url(r'^login$', 'master.views.LoginView', name='login'),
    url(r'^logout$', 'master.views.LogoutView', name='logout'),
    url(r'^dashboard/(?P<username>\w+)$', 'master.views.DashboardView', name='dashboard'),
    url(r'^dashboard/(?P<username>\w+)/event-manage/add/$', 'master.views.EventManageAddView', name='master-event-manage-add'),
    url(r'^dashboard/(?P<username>\w+)/event-manage/delete/(?P<eventid>\d+)$', 'master.views.EventManageDeleteView', name='master-event-manage-delete'),
    url(r'^dashboard/(?P<username>\w+)/event-manage/update/(?P<eventid>\d+)$', 'master.views.EventManageUpdateView', name='master-event-manage-update'),
    url(r'^dashboard/(?P<username>\w+)/todo-manage/add/$', 'master.views.TodoManageAddView', name='master-todo-manage-add'),
    url(r'^dashboard/(?P<username>\w+)/todo-manage/done/(?P<todoid>\d+)$

    url(r'^dashboard/(?P<username>\w+)/todo-manage/delete/(?P<todoid>\d+)$', 'master.views.TodoManageDeleteView', name='master-todo-manage-delete'),
    url(r'^dashboard/(?P<username>\w+)/todo-manage/update/(?P<todoid>\d+)$', 'master.views.TodoManageUpdateView', name='master-todo-manage-update'),
    url(r'^dashboard/(?P<username>\w+)/10khours-manage/add/$', 'master.views.HoursManageAddView', name='master-hours-manage-add'),
    url(r'^dashboard/(?P<username>\w+)/10khours-manage/delete/(?P<trackerid>\d+)$', 'master.views.HoursManageDeleteView', name='master-hours-manage-delete'),
    url(r'^dashboard/(?P<username>\w+)/10khours-manage/update/(?P<trackerid>\d+)$', 'master.views.HoursManageUpdateView', name='master-hours-manage-update'),
    url(r'^dashboard/(?P<username>\w+)/mood-manage/add/$', 'master.views.MoodManageAddView', name='master-mood-manage-add'),
    url(r'^dashboard/(?P<username>\w+)/mood-manage/delete/(?P<moodid>\d+)$', 'master.views.MoodManageDeleteView', name='master-mo

    url(r'^dashboard/(?P<username>\w+)/mood-manage/update/(?P<moodid>\d+)$', 'master.views.MoodManageUpdateView', name='master-mood-manage-update'),
    url(r'^dashboard/(?P<username>\w+)/dream-manage/add/$', 'master.views.DreamManageAddView', name='master-dream-manage-add'),
    url(r'^dashboard/(?P<username>\w+)/dream-manage/delete/(?P<dreamid>\d+)$', 'master.views.DreamManageDeleteView', name='master-dream-manage-delete'),
    url(r'^dashboard/(?P<username>\w+)/dream-manage/update/(?P<dreamid>\d+)$', 'master.views.DreamManageUpdateView', name='master-dream-manage-update'),
    url(r'^dashboard/(?P<username>\w+)/diary-manage/add/$', 'master.views.DiaryManageAddView', name='master-diary-manage-add'),
    url(r'^dashboard/(?P<username>\w+)/diary-manage/delete/(?P<diaryid>\d+)$', 'master.views.DiaryManageDeleteView', name='master-diary-manage-delete'),
    url(r'^dashboard/(?P<username>\w+)/diary-manage/update/(?P<diaryid>\d+)$', 'master.views.DiaryManageUpdateView', name='master-diary
TERMSET1 = ['set1_1', 'set1_1']
TERMSET2 = ['set2_1', 'set2_2']
TERMSET3 = ['set3_1', 'set3_2']
class listener(StreamListener):
    def on_data(self, data):
        try:
            
            tweet = data.split(',"text":"')[1].split('","source')[0]
            username = data.split(',"screen_name":"')[1].split('","location')[0]
            print username
            print tweet + '\n'
            saveThis = str(datetime.now())+ ' ¶ ' + username + ' ¶ ' + tweet
            saveFile = open('twitout - ARCHIVE.csv','a')
            saveFile.write(saveThis)
            saveFile.write('\n')
            saveFile.close()
            
            for TR1 in TERMSET1:                
                if TR1 in tweet:
                    saveThis = str(datetime.now())+ ' ¶ ' + username + ' ¶ ' + tweet
                    saveFile = open('twitout - term1.csv','a')
                    saveFile.write(saveThis)
                    saveFile.write('\n')
                    saveFile.close()
          

                pass
            
            for TR2 in TERMSET2:                
                if TR2 in tweet:
                    saveThis = str(datetime.now())+ ' ¶ ' + username + ' ¶ ' + tweet
                    saveFile = open('twitout - term2.csv','a')
                    saveFile.write(saveThis)
                    saveFile.write('\n')
                    saveFile.close()
            else:
                pass
            for TR3 in TERMSET3:                
                if TR3 in tweet:
                    saveThis = str(datetime.now())+ ' ¶ ' + username + ' ¶ ' + tweet
                    saveFile = open('twitout - term3.csv','a')
                    saveFile.write(saveThis)
                    saveFile.write('\n')
                    saveFile.close()
            else:
                pass
            return True
        except BaseException, e:
            print 'failed ondata,',str(e)
            time.sleep(5)
    def on_error(self, status):
        print status
aut
__author__ = 'anderson'
app = Flask(__name__)
def advertise_f(xml_string, broker_url):
    target_url = broker_url+"/advertisement"
    r = requests.post(target_url, xml_string)
    return r.content
def update_f(xml_string, broker_url):
    target_url = broker_url+"/update"
    r = requests.post(target_url, xml_string)
    return r.content
@app.route('/advertise')
def advertise():
    xml_string= request.args.get('xml_string')
    broker_url = request.args.get('broker_url')
    result = advertise_f(xml_string,broker_url)
    return result
@app.route('/update')
def update():
    xml_string = request.args.get('xml_string')
    broker_url = request.args.get('broker_url')
    result = update_f(xml_string,broker_url)
    return result
@app.route('/getContext', methods=['GET'])
def get_context():
    scope_list = request.args.get('scope_list')
    entities = request.args.get('entities')
    r = '<contextML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://ContextML/1.6c" ' 
__author__ = 'Administrator'
def fun_template():
    '''
    default 模板的 方法控制器
    '''
    funMap={}
    funMap['404']=(views.page404,('/404.html',))
    funMap['index']=(views.index,('/index.html',))
    funMap['blogAdmin']=(views.blogAdmin,('/admindefault.html',))
    funMap['manageMenu']=(views.manageMenu,('/adminMenu.html',))
    funMap['manageMenu_save']=(views.manageMenu_save,('/adminMenu.html',))
    funMap['webinfo']=(views.webinfo,('/admindefault.html',))
    funMap['AdminInfo']=(views.adminInfo,('/adminInfo.html',))
    funMap['AdminInfo_save']=(views.adminInfo_save,('/adminInfo.html',))
    funMap['managePaper_save']=(views.managePaper_save,('/adminedit.html',))
    funMap['managePaperImage_save']=(views.managePaperImage_save,('/adminimageedit.html',))
    funMap['managePaperImage_upload']=(views.managePaperImage_upload,('/adminimageedit.html',))
    funMap['managePaper_list']=(views.managePaper_list,('/adminPaperList.html',))
    funMap['manageAlbum_list']=(views.manageAlbu
__author__ = 'Ian Fenech Conti'
sys.path.append('/home/ian/Documents/GITHUB/great03/')
ROOT_PATH = '/home/ian/Documents/GREAT03/'
BRANCH_PATH = 'branch/real_galaxy/ground/constant/'
FILE_NAME = 'starfield_image-'
SAMPLE_HEADER = '%sutils/sample.fits' \
                % ROOT_PATH
PROCESS_START = 0
PROCESS_FINISH = 200
POSTAGE_SIZE = 48
if len(sys.argv) < 1:
    print 'not enough args. passed to psf_pipeline'
    exit()
branch_collection = BranchCollection()
branch_collection.branch_path = '%s%s' % (ROOT_PATH, BRANCH_PATH)
def model_psf(package):
    for sub_tile in package:
        print sub_tile.image_path
for ID in range(PROCESS_START, PROCESS_FINISH):
    SAVE_TYPE = 'image%03d' % ID
    starfield_image = StarfieldImage()
    starfield_image.image_id = ID
    starfield_image.file_name = '%s%03d-0.fits' % (FILE_NAME, ID)
    starfield_image.file_path = '%s%s' % (branch_collection.branch_path,
                                          starfield_image.file_name)
    starfield_image.cat

                                                                   ID)
    starfield_image.image_data = load_grid_image(starfield_image.file_path)
    save_directory = '%srggc_1/%d/' % (branch_collection.branch_path,
                                       starfield_image.image_id)
    save_image = '%s%s.fits' % (save_directory, SAVE_TYPE)
    save_catalogue_path_before = '%s%s.before.asc' % (save_directory, SAVE_TYPE)
    save_catalogue_path = '%s%s.asc' % (save_directory, SAVE_TYPE)
    save_table_path = '%s%s.table.fits' % (save_directory, SAVE_TYPE)
    save_head_path = '%s%s.head' % (save_directory, SAVE_TYPE)
    save_placeholder_path = '%s%s.placeholder.fits' % (save_directory, SAVE_TYPE)
    branch_collection.images.append(starfield_image)
    if os.path.isdir(save_directory):
        shutil.rmtree(save_directory)
    os.mkdir(save_directory)
    stars_in_image = get_starfield_images_tile_constant(starfield_image.catalogue_path)
    print stars_in_image
    image_data, stars_in
column_repository_name = 'column_maker_0080'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0080'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0080 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryCircularDependencies( ShedTwillTestCase ):
    '''Verify that the code correctly handles circular dependencies.'''
    
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_priv

        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        
    def test_0005_create_column_repository( self ):
        """Create and populate the column_maker repository."""
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name, 
                                                    description=column_repository_description, 
                                                    long_description=column_repository_long_description, 
                               

                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        self.upload_file( repository, 
                          filename='column_maker/column_maker.tar',
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=True,
                          remove_repo_files_not_in_tar=False, 
                          commit_message='Uploaded column_maker tarball.',
                          strings_displayed=[], 
                          strings_not_displayed=[] )
        
    def test_0005_create_convert_repository( self ):
        """Create and populate the convert_chars repository."""
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        category = self.create_category( name=category_name, description=category_description )
        sel
class SaveDialog:
	def __init__(self):
		builderfile = "save_dialog.glade"
		builder = gtk.Builder()
		builder.add_from_file(builderfile)
		self.save_dialog = builder.get_object("save_dialog")
		self.save_button = builder.get_object("save_button")
		self.cancel_button = builder.get_object("cancel_button")
		self.save_button.connect("clicked", self.on_save_clicked)
		self.cancel_button.connect("clicked", self.on_cancel_clicked)
		
		self.status = status_text.StatusText()
		self.save_cb = None
		self.filename = ""
	def set_slave_callback(self, save_cb):
		self.save_cb = save_cb 
	def show(self):
		self.save_dialog.show()
	def on_save_clicked(self, widget):
		f = self.save_dialog.get_filenames()
		if len(f) == 0:
			self.status.print_warning(__file__, "No file selected")
			return
		self.filename = f[0]
		self.status.print_info(__file__, "Saving %s" % str(self.filename))
		self.save_dialog.hide()
		if self.save_cb is not None:
			self.save_cb(self.filename)
	def on_cancel_clicked(self, wi
__author__ = 'dmarkey'
class ControlBase(object):
    @staticmethod
    def init(controller):
        pass
    @staticmethod
    def on_beacon(controller):
        pass
    @staticmethod
    def get_extra_items(controller):
        return None
class Sockets(ControlBase):
    @staticmethod
    def init(controller, number_of_sockets=4):
        for i in range(1, number_of_sockets + 1):
            Socket(controller=controller, number=i).save()
    @staticmethod
    def event(controller, event):
        if event['event'] == "BEACON":
            for s in Socket.objects.filter(controller=controller):
                s.send_state()
class Temperature(ControlBase):
    @staticmethod
    def init(controller):
        pass
    @staticmethod
    def event(controller, event):
        if event['event'] == "Temp":
            zone = Temperature.get_zone(controller, event)
            TemperatureRecord(temperature=event['value'], zone=zone).save()
    @staticmethod
    def get_extra_items(controller

        try:
            return TemperatureRecord.objects.filter(zone__controller=controller).order_by("-pk").values()[0]
        except IndexError:
            return None
    @staticmethod
    def get_zone(controller, event):
        zone = event.get("zone", "main")
        (zone_obj, _) = TemperatureZone.objects.get_or_create(controller=controller, name=zone)
        return zone_obj
class RemoteControl(ControlBase):
    @staticmethod
    def init(controller):
        pass
    @staticmethod
    def event(controller, event):
        print("RC Event")
        if event['event'] == "IRIN":
            RemoteEvent(encoding=event['encoding'], value=event['code'], controller=controller).save()
            for x in RegisteredRemoteEvent.objects.filter(value=event['code'], encoding=event['encoding']):
                x.execute()
        elif event['event'] == "BEACON":
            RemoteEvent.objects.filter(controller=controller).delete()
CONTROL_CLASSES = {"Sockets": Sockets,
              
DB_SHARED_THREAD = """\
DatabaseWrapper objects created in a thread can only \
be used in that same thread.  The object with alias '%s' \
was created in thread id %s and this is thread id %s.\
"""
def patch_thread_ident():
    if getattr(patch_thread_ident, 'called', False):
        return
    try:
        if 'validate_thread_sharing' in BaseDatabaseWrapper.__dict__:
            _get_ident = thread.get_ident
            __old__init__ = BaseDatabaseWrapper.__init__
            def _init(self, *args, **kwargs):
                __old__init__(self, *args, **kwargs)
                self._thread_ident = _get_ident()
            def _validate_thread_sharing(self):
                if (not self.allow_thread_sharing and
                        self._thread_ident != _get_ident()):
                    raise DatabaseError(
                        DB_SHARED_THREAD % (
                            self.alias, self._thread_ident, _get_ident()),
                    )
            BaseDatabaseWrapper.__in

            BaseDatabaseWrapper.validate_thread_sharing = \
                _validate_thread_sharing
        patch_thread_ident.called = True
    except ImportError:
        pass
patch_thread_ident()
class CeleryCommand(BaseCommand):
    options = BaseCommand.option_list
    skip_opts = ['--app', '--loader', '--config']
    keep_base_opts = False
    def get_version(self):
        return 'celery %s' % (celery.__version__)
    def execute(self, *args, **options):
        broker = options.get('broker')
        if broker:
            self.set_broker(broker)
        super(CeleryCommand, self).execute(*args, **options)
    def set_broker(self, broker):
        os.environ['CELERY_BROKER_URL'] = broker
    def run_from_argv(self, argv):
        self.handle_default_options(argv[2:])
        return super(CeleryCommand, self).run_from_argv(argv)
    def handle_default_options(self, argv):
        acc = []
        broker = None
        for i, arg in enumerate(argv):
            if '--settings=' 
__author__ = "Simone Campagna"
__all__ = [
    'controller_builder',
def controller_builder(logger, controller_type, data, attributes=None, attribute_files=None, title=None):
    if attributes is None:
        attributes = {}
    if attribute_files is None:
        attribute_files = []
    config = get_config()
    if isinstance(controller_type, (list, tuple)):
        orig_controller_types = tuple(controller_type)
    else:
        orig_controller_types = (controller_type, )
    controller_types = []
    for controller_type in orig_controller_types:
        if controller_type is None or controller_type == "auto":
            if isinstance(data, np.ndarray):
                usable_controller_types = []
                for vt in get_controller_types():
                    vc = get_controller_class(vt, logger)
                    if vc is not None and vc.DATA_CHECK(data):
                        usable_controller_types.append(vt)
                if not usable_controller_types:
          

                if config.preferred_controller in usable_controller_types:
                    usable_controller_type = config.preferred_controller
                else:
                    usable_controller_type = usable_controller_types[0]
                if usable_controller_type is None:
                    raise RubikError("cannot find a valid controller for {} object".format(type(data)))
                controller_types.append(usable_controller_type)
        else:
            if not controller_type in get_controller_types():
                raise RubikError("invalid controller_type {!r}".format(controller_type))
            controller_types.append(controller_type)
    controller_class = None
    for controller_type in controller_types:
        controller_class = get_controller_class(controller_type, logger)
        if controller_class is not None:
            break
    else:
        raise RubikError("no usable controller")
    
    controller_attributes = {}
    controller_attri
log = logging.getLogger( __name__ )
REPOSITORY_DEPENDENCY_DEFINITION_FILENAME = 'repository_dependencies.xml'
REPOSITORY_SUITE_DEFINITION = 'repository_suite_definition'
TOOL_DEPENDENCY_DEFINITION = 'tool_dependency_definition'
TOOL_DEPENDENCY_DEFINITION_FILENAME = 'tool_dependencies.xml'
UNRESTRICTED = 'unrestricted'
types = [ UNRESTRICTED, TOOL_DEPENDENCY_DEFINITION, REPOSITORY_SUITE_DEFINITION ]
def build_repository_type_select_field( trans, repository=None, name='repository_type' ):
    """Called from the Tool Shed to generate the current list of supported repository types."""
    if repository:
        selected_type = str( repository.type )
    else:
        selected_type = None
    repository_type_select_field = SelectField( name=name )
    for type_label, type_class in trans.app.repository_types_registry.repository_types_by_label.items():
        option_label = str( type_class.label )
        option_value = str( type_class.type )
        if selected_type and selected_type == opt

            selected = True
        else:
            selected = False
        if repository:
            if repository.type == option_value:
                repository_type_select_field.add_option( option_label, option_value, selected=selected )
            elif type_class.is_valid_for_type( trans.app, repository ):
                repository_type_select_field.add_option( option_label, option_value, selected=selected )
        else:
            repository_type_select_field.add_option( option_label, option_value, selected=selected )
    return repository_type_select_field
def generate_message_for_repository_type_change( app, repository ):
    message = ''
    if repository.can_change_type_to( app, REPOSITORY_SUITE_DEFINITION ):
        repository_suite_definition_type_class = \
            app.repository_types_registry.get_class_by_label( REPOSITORY_SUITE_DEFINITION )
        message += "This repository currently contains a single file named <b>%s</b>.  If the intent of this repositor
class NetworkLoader:
	def __init__(self):
		self.saveFileVersionName = "VeRx1.0"
		self.saveFileVersionCode = 10
		self.saves = []
	def updateSave(self, network, save):
		foundSave = ["/saveName/", "/notFound/"] 
		
		for existingSave in self.saves:
			if(existingSave[0] == save):
				foundSave = existingSave
		
		if(foundSave[0] == "/saveName/" and foundSave[1] == "/notFound/"):
			er("Save " + save + " not found, please check your if your save exists")
	def createSave(self, name, network = None):
		if(not cnf.useSaveFile):
			er("You are trying to create a save while saves are disabled, enable saving by running 'NetworkLoader.enableSaves()'")
			return
		if(not os.path.isdir("saves")):
			os.makedirs("saves/")
			specificSaveFile = open("saves/"+name, 'ab+')
		
		saveFile = open('saveFile', 'ab+')
		while(saveFile.read().find("save:"+name) != -1):
			er("Save already exists.")
			newName = raw_input("Please input a new name: ")
			name = str(newName)
		specificSaveFile = open('saves/

		saveFile.write("\nsave:"+name +" = " + "\"saves/"+name+"\"")
		saveFile.close()
		if(network != None):
			lol = False
	def enableSaves(self):
		if(cnf.useSaveFile):
			pr("Saves are already enabled")
		else:
			cnf.useSaveFile = True
	def loadSave(self, id):
		return self.saves[id]
	def checkForPossibleSaves(self):
		db("Checking for saves")
		if(not os.path.isfile('saveFile')): 
			ans = raw_input("You dont have a saveFile, do you want to make one(y/n)? ")
			if(ans.lower() == "y"):
				f = open('saveFile', 'w+')
				f.close()
			else:
				cnf.useSaveFile = False
			return 
		saveFile = open('saveFile', 'r')
		saveFileContent = saveFile.read()
		commentLines = []
		while(index != -1):
			newLineIndex = saveFileContent.find("\n", index)
			if(newLineIndex == -1):
				commentLines.append(saveFileContent[index:])
			else:
				commentLines.append(saveFileContent[index:newLineIndex])
		for line in commentLines:
			saveFileContent = saveFileContent.replace(line, "")
		version = extractVa

		if(version == cnf.notFoundHash):
			er("Could not find meta:version in the saveFile. Please manually add: " + self.saveFileVersionName)
		elif(version == cnf.errorHash):
			er("Something went wrong while looking for meta:version...")
		if(not version == self.saveFileVersionName):
			try:
				verId = int(version.replace(".", "").split("x")[1])
				if(verId > self.saveFileVersionCode):
					er("saveFile's version is ahead of yours, perhaps its time to udpate?")
				else:
					er("saveFile's version is outdated, do you want to update it?")
					answer = raw_input("(y/n): ")
					if(answer.lower() == "y"):
						db("Updating saveFile...")
					else:
						pr("Working with outdated saveFile, errors might occur.")
			except:
				er("Illformatted version? Version should be: " + str(self.saveFileVersionCode))
		saveFile.close()
		saveCount = extractValue(saveFileContent, "meta:count")
		if(saveCount == cnf.notFoundHash):
			er("Could not find meta:count in saveFile. Please add one reflectin
if  __package__ is None:
    G_NAME_MODULE_STORAGE_CONTROLLER = "unknown"
    G_NAME_GROUP_STORAGE_CONTROLLER_CONTROLLER_MANAGER = "unknown"
else:
blinky_generated_enums=a.api.yang.modules.tech.common.qwilt_tech_storage_disk.qwilt_tech_storage_disk_module_gen
class ControllerkManager(object):
    def __init__ (self,logger):
        self._log = logger.createLogger(G_NAME_MODULE_STORAGE_CONTROLLER, G_NAME_GROUP_STORAGE_CONTROLLER_CONTROLLER_MANAGER)
        self._candidateControllerList = {}
        self._runningControllerList   = {}
    def preCreateController (self,key):
        self._log("precreate-controller").debug3("preCreateController(key=%s)  was called, self._candidateControllerList[%s] = None",key,key)
        if key in self._candidateControllerList:
            self._log("controller-already-exist").error("a controller named '%s' already exists",key)
            return ReturnCodes.kGeneralError
        self._candidateControllerList[key] = None
        return ReturnCodes.kOk
   

        controller = None
        if ((implementatonType == blinky_generated_enums.ControllerImplementationType.kDellH710) or
            (implementatonType == blinky_generated_enums.ControllerImplementationType.kDellH810)):
        self._candidateControllerList[key] = controller
        return controller
    def managerTrxStart (self):
        self._log("controller-manager-trx-start").debug3("managerTrxStart()  was called, running --> candidate, running = %s ,candidate = %s",self._runningControllerList,self._candidateControllerList)
        self._candidateControllerList = self._runningControllerList.copy()
        return ReturnCodes.kOk
    def managerTrxVerifyPublicConfig (self):
        self._log("controller-manager-trx-verify-public").debug3("managerTrxVerifyPublicConfig() was called")
        return ReturnCodes.kOk
    def managerTrxCommit (self):
        self._log("controller-manager-trx-start").debug3("managerTrxCommit()  was called, candidate --> running, running = %s ,candida

        self._runningControllerList = self._candidateControllerList.copy()
        return ReturnCodes.kOk
    def managerTrxAbort (self):
        self._log("controller-manager-trx-abort").debug3("managerTrxAbort() was called, None --> candidate")
        self._candidateControllerList = None
        return ReturnCodes.kOk
    def getController (self,controllerName):
        if controllerName in self._runningControllerList:
            return self._runningControllerList[controllerName]
        self._log("cannot-fetch-running-controller").debug2("could not fetch running controller '%s'", controllerName)
        return None
    def init (self,diskControllersCfgJson):
        self._log("controller-mngr-init").debug2("ControllerManager init() is called (diskControllersCfgJson=%s)",diskControllersCfgJson)
        diskControllersCfg = None 
        try:
            diskControllersCfg = a.infra.format.json.readFromFile(self._log,diskControllersCfgJson)
            self._log("disk-controller-cf
Import('env')
if env.get('RELEASE'):
	env.AppendUnique(CCFLAGS = ['-Os'])
	env.AppendUnique(CPPDEFINES = ['NDEBUG'])
else:
	env.AppendUnique(CCFLAGS = ['-g'])
if env.get('LOGGING'):
	env.AppendUnique(CPPDEFINES = ['TB_LOG'])
lib_env = env.Clone()
SConscript(env.get('SRC_DIR') + '/service/third_party_libs.scons', 'lib_env')
src_dir = lib_env.get('SRC_DIR')
gtest_dir = src_dir + '/extlibs/gtest/gtest-1.7.0'
broker_test_env = lib_env.Clone()
target_os = env.get('TARGET_OS')
gtest = File(gtest_dir + '/lib/.libs/libgtest.a')
gtest_main = File(gtest_dir + '/lib/.libs/libgtest_main.a')
broker_test_env.AppendUnique(CPPPATH = ['../include'])
broker_test_env.AppendUnique(CPPPATH = ['../../../include'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/primitiveResource/include'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/expiryTimer/include'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/expiryTimer/src'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/utils/inclu

broker_test_env.PrependUnique(CPPPATH = [env.get('SRC_DIR')+'/extlibs/hippomocks-master',
                             gtest_dir + '/include'])
broker_test_env.AppendUnique(LIBPATH = [env.get('BUILD_DIR')])
broker_test_env.PrependUnique(LIBS = ['rcs_client','rcs_common', 'oc', 'octbstack', 'oc_logger', 'connectivity_abstraction', 'coap', gtest, gtest_main])
if target_os not in ['windows', 'winrt']:
    broker_test_env.AppendUnique(CXXFLAGS = ['-O2', '-g', '-Wall', '-fmessage-length=0', '-std=c++0x'])
if target_os == 'linux':
    broker_test_env.AppendUnique(LIBS = ['pthread'])
broker_test_src = env.Glob('./*.cpp')
broker_test = broker_test_env.Program('broker_test', broker_test_src)
Alias("broker_test", broker_test)
env.AppendTarget('broker_test')
if env.get('TEST') == '1':
        target_os = env.get('TARGET_OS')
        if target_os == 'linux':
                run_test(broker_test_env,
                         '',
                         'service/resource-encapsulation/src/resource
PIXELS_PER_INCH = api.PixelsPerInchResolution
PIXELS_PER_CENTIMETER = api.PixelsPerCentimeterResolution
BESSEL_FILTER = api.BesselFilter
BLACKMAN_FILTER = api.BlackmanFilter
BOX_FILTER = api.BoxFilter
CATROM_FILTER = api.CatromFilter
CUBIC_FILTER = api.CubicFilter
GAUSSIAN_FILTER = api.GaussianFilter
HANNING_FILTER = api.HanningFilter
HERMITE_FILTER = api.HermiteFilter
LANCZOS_FILTER = api.LanczosFilter
MITCHELL_FILTER = api.MitchellFilter
POINT_FILTER = api.PointFilter
QUADRATIC_FILTER = api.QuadraticFilter
SINC_FILTER = api.SincFilter
TRIANGLE_FILTER = api.TriangleFilter
CMYK_COLORSPACE = api.CMYKColorspace
CMY_COLORSPACE = api.CMYColorspace
OHTA_COLORSPACE = api.OHTAColorspace
LAB_COLORSPACE = api.LabColorspace
HWB_COLORSPACE = api.HWBColorspace
REC601YCBCR_COLORSPACE = api.Rec601YCbCrColorspace
REC709YCBCR_COLORSPACE = api.Rec709YCbCrColorspace
YIQ_COLORSPACE = api.YIQColorspace
TRANSPARENT_COLORSPACE = api.TransparentColorspace
YUV_COLORSPACE = api.YUVColorspace
YCC_COLORSPACE = a

SRGB_COLORSPACE = api.sRGBColorspace
HSL_COLORSPACE = api.HSLColorspace
REC601LUMA_COLORSPACE = api.Rec601LumaColorspace
HSB_COLORSPACE = api.HSBColorspace
REC709LUMA_COLORSPACE = api.Rec709LumaColorspace
GRAY_COLORSPACE = api.GRAYColorspace
LOG_COLORSPACE = api.LogColorspace
XYZ_COLORSPACE = api.XYZColorspace
YCBCR_COLORSPACE = api.YCbCrColorspace
RGB_COLORSPACE = api.RGBColorspace
YPBPR_COLORSPACE = api.YPbPrColorspace
RED_CHANNEL = api.RedChannel
CYAN_CHANNEL = api.CyanChannel
GREEN_CHANNEL = api.GreenChannel
MAGENTA_CHANNEL = api.MagentaChannel
BLUE_CHANNEL = api.BlueChannel
YELLOW_CHANNEL = api.YellowChannel
ALPHA_CHANNEL = api.AlphaChannel
OPACITY_CHANNEL = api.OpacityChannel
BLACK_CHANNEL = api.BlackChannel
INDEX_CHANNEL = api.IndexChannel
ALL_CHANNELS = api.AllChannels
LOSSLESS_JPEG_COMPRESSION = api.LosslessJPEGCompression
JPEG_COMPRESSION = api.JPEGCompression
NO_COMPRESSION = api.NoCompression
JPEG2000_COMPRESSION = api.JPEG2000Compression
RLE_COMPRESSION = api.RLECompressi

GROUP4_COMPRESSION = api.Group4Compression
FAX_COMPRESSION = api.FaxCompression
UNDEFINED_COMPRESSION = api.UndefinedCompression
BZIP_COMPRESSION = api.BZipCompression
LZW_COMPRESSION = api.LZWCompression
ZIP_COMPRESSION = api.ZipCompression
MINUS_COMPOSITE_OP = api.MinusCompositeOp
ADD_COMPOSITE_OP = api.AddCompositeOp
IN_COMPOSITE_OP = api.InCompositeOp
DIFFERENCE_COMPOSITE_OP = api.DifferenceCompositeOp
PLUS_COMPOSITE_OP = api.PlusCompositeOp
BUMPMAP_COMPOSITE_OP = api.BumpmapCompositeOp
ATOP_COMPOSITE_OP = api.AtopCompositeOp
XOR_COMPOSITE_OP = api.XorCompositeOp
SUBTRACT_COMPOSITE_OP = api.SubtractCompositeOp
OUT_COMPOSITE_OP = api.OutCompositeOp
COPY_COMPOSITE_OP = api.CopyCompositeOp
DISPLACE_COMPOSITE_OP = api.DisplaceCompositeOp
OVER_COMPOSITE_OP = api.OverCompositeOp
MAX_OPERATOR = api.MaxEvaluateOperator
MIN_OPERATOR = api.MinEvaluateOperator
MULTIPLY_OPERATOR = api.MultiplyEvaluateOperator
SET_OPERATOR = api.SetEvaluateOperator
XOR_OPERATOR = api.XorEvaluateOperator
AND_OP
class TestReplicatorSync(test_db_replicator.TestReplicatorSync):
    backend = backend.AccountBroker
    datadir = server.DATADIR
    replicator_daemon = replicator.AccountReplicator
    def test_sync(self):
        broker = self._get_broker('a', node_index=0)
        put_timestamp = normalize_timestamp(time.time())
        broker.initialize(put_timestamp)
        daemon = replicator.AccountReplicator({})
        part, node = self._get_broker_part_node(broker)
        info = broker.get_replication_info()
        success = daemon._repl_to_node(node, broker, part, info)
        self.assertTrue(success)
        self.assertEqual(1, daemon.stats['no_change'])
    def test_sync_remote_missing(self):
        broker = self._get_broker('a', node_index=0)
        put_timestamp = time.time()
        broker.initialize(put_timestamp)
        part, node = self._get_broker_part_node(broker)
        daemon = self._run_once(node)
        self.assertEqual(2, daemon.stats['rsync'])
        local_info = s

            'a', node_index=0).get_info()
        for i in range(1, 3):
            remote_broker = self._get_broker('a', node_index=i)
            self.assertTrue(os.path.exists(remote_broker.db_file))
            remote_info = remote_broker.get_info()
            for k, v in local_info.items():
                if k == 'id':
                    continue
                self.assertEqual(remote_info[k], v,
                                 "mismatch remote %s %r != %r" % (
                                     k, remote_info[k], v))
    def test_sync_remote_missing_most_rows(self):
        put_timestamp = time.time()
        broker = self._get_broker('a', node_index=0)
        broker.initialize(put_timestamp)
        remote_broker = self._get_broker('a', node_index=1)
        remote_broker.initialize(put_timestamp)
        broker.put_container('/a/c', time.time(), 0, 0, 0,
                             POLICIES.default.idx)
        daemon = replicator.AccountReplicator({})
        def _rs

            remote_server, remote_path = remote_file.split('/', 1)
            dest_path = os.path.join(self.root, remote_path)
            shutil.copy(db_file, dest_path)
            return True
        daemon._rsync_file = _rsync_file
        part, node = self._get_broker_part_node(remote_broker)
        info = broker.get_replication_info()
        success = daemon._repl_to_node(node, broker, part, info)
        self.assertTrue(success)
        self.assertEqual(1, daemon.stats['remote_merge'])
        local_info = self._get_broker(
            'a', node_index=0).get_info()
        remote_info = self._get_broker(
            'a', node_index=1).get_info()
        for k, v in local_info.items():
            if k == 'id':
                continue
            self.assertEqual(remote_info[k], v,
                             "mismatch remote %s %r != %r" % (
                                 k, remote_info[k], v))
    def test_sync_remote_missing_one_rows(self):
        put_timestamp = time
CONF = config.CONF
LOG = logging.getLogger(__name__)
class SimpleReadOnlyNovaManageTest(cli.ClientTestBase):
    """
    This is a first pass at a simple read only nova-manage test. This
    only exercises client commands that are read only.
    This should test commands:
    * with and without optional parameters
    * initially just check return codes, and later test command outputs
    """
    @classmethod
    def resource_setup(cls):
        if not CONF.service_available.nova:
            msg = ("%s skipped as Nova is not available" % cls.__name__)
            raise cls.skipException(msg)
        if not CONF.cli.has_manage:
            msg = ("%s skipped as *-manage commands not available"
                   % cls.__name__)
            raise cls.skipException(msg)
        super(SimpleReadOnlyNovaManageTest, cls).resource_setup()
    def nova_manage(self, *args, **kwargs):
        return self.clients.nova_manage(*args, **kwargs)
    def test_admin_fake_action(self):
        self.ass

                          self.nova_manage,
                          'this-does-nova-exist')
    def test_help_flag(self):
        self.nova_manage('', '-h')
    def test_version_flag(self):
        self.assertNotEqual("", self.nova_manage('', '--version',
                                                 merge_stderr=True))
        self.assertEqual(self.nova_manage('version'),
                         self.nova_manage('', '--version', merge_stderr=True))
    def test_debug_flag(self):
        self.assertNotEqual("", self.nova_manage('service list',
                            '--debug'))
    def test_verbose_flag(self):
        self.assertNotEqual("", self.nova_manage('service list',
                            '--verbose'))
    def test_version(self):
        self.assertNotEqual("", self.nova_manage('version'))
    def test_db_sync(self):
        self.nova_manage('db sync')
    def test_db_version(self):
        self.assertNotEqual("", self.nova_manage('db version'))
    def test_ce
class TestFakeAccountBroker(unittest.TestCase):
    def test_fake_broker_get_info(self):
        broker = utils.FakeAccountBroker()
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            info = broker.get_info()
        timestamp = Timestamp(now)
        expected = {
            'container_count': 0,
            'object_count': 0,
            'bytes_used': 0,
            'created_at': timestamp.internal,
            'put_timestamp': timestamp.internal,
        }
        self.assertEqual(info, expected)
    def test_fake_broker_list_containers_iter(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.list_containers_iter(), [])
    def test_fake_broker_metadata(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.metadata, {})
    def test_fake_broker_get_policy_stats(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.get_policy_stats(), {})
class TestAccountUti

    def test_get_response_headers_fake_broker(self):
        broker = utils.FakeAccountBroker()
        now = time.time()
        expected = {
            'X-Account-Container-Count': 0,
            'X-Account-Object-Count': 0,
            'X-Account-Bytes-Used': 0,
            'X-Timestamp': Timestamp(now).normal,
            'X-PUT-Timestamp': Timestamp(now).normal,
        }
        with mock.patch('time.time', new=lambda: now):
            resp_headers = utils.get_response_headers(broker)
        self.assertEqual(resp_headers, expected)
    def test_get_response_headers_empty_memory_broker(self):
        broker = backend.AccountBroker(':memory:', account='a')
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            broker.initialize(Timestamp(now).internal)
        expected = {
            'X-Account-Container-Count': 0,
            'X-Account-Object-Count': 0,
            'X-Account-Bytes-Used': 0,
            'X-Timestamp': Timestamp(now).norm

            'X-PUT-Timestamp': Timestamp(now).normal,
        }
        resp_headers = utils.get_response_headers(broker)
        self.assertEqual(resp_headers, expected)
    @patch_policies
    def test_get_response_headers_with_data(self):
        broker = backend.AccountBroker(':memory:', account='a')
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            broker.initialize(Timestamp(now).internal)
        ts = (Timestamp(t).internal for t in itertools.count(int(now)))
        total_containers = 0
        total_objects = 0
        total_bytes = 0
        for policy in POLICIES:
            delete_timestamp = next(ts)
            put_timestamp = next(ts)
            object_count = int(policy)
            bytes_used = int(policy) * 10
            broker.put_container('c-%s' % policy.name, put_timestamp,
                                 delete_timestamp, object_count, bytes_used,
                                 int(policy))
            total_conta
log = logging.getLogger(__name__)
try:
    check_output = subprocess.check_output
except AttributeError:
    def check_output(*args, **kwargs):
        process = subprocess.Popen(stdout=subprocess.PIPE, *args, **kwargs)
        output, unused_err = process.communicate()
        code = process.poll()
        if code:
            cmd = kwargs.get('args')
            if cmd is None:
                cmd = args[0]
            raise subprocess.CalledProcessError(code, cmd, output=output)
        return output
class RequiresAPI(object):
    def __init__(self, token, base_url='https://requires.io/api/v2/', verify=True):
        self.token = token
        self.base_url = base_url
        if self.base_url[-1] != '/':
            self.base_url += '/'
        self.verify = verify
    def _get_headers(self, content_type='application/json'):
        headers = {
            'Authorization': 'Token %s' % self.token,
            'Accept': 'application/json',
        }
        if content_type:
         

        return headers
    def _update_reference(self, url, paths):
        payload = []
        for path, relative in paths.items():
            log.info('add %s to payload', relative)
            with open(path, 'rb') as f:
                payload.append({
                    'path': relative,
                    'content': base64.b64encode(f.read()).decode('utf-8'),
                })
        requests.put(
            url,
            headers=self._get_headers(),
            data=json.dumps(payload),
            verify=self.verify,
        ).raise_for_status()
    def _get_repository_url(self, repository):
        return '%srepos/%s' % (self.base_url, repository)
    def update_repository(self, repository, private):
        payload = dict(
            private=private,
        )
        requests.put(
            self._get_repository_url(repository),
            headers=self._get_headers(),
            data=json.dumps(payload),
            verify=self.verify,
        ).raise_for_stat

    def delete_repository(self, repository):
        log.info('delete repository %s', repository)
        requests.delete(
            self._get_repository_url(repository),
            headers=self._get_headers(),
            verify=self.verify,
        ).raise_for_status()
    def _get_branch_url(self, repository, name):
        return '%s/branches/%s' % (self._get_repository_url(repository), name)
    def update_branch(self, repository, name, paths):
        log.info('update branch %s on repository %s', name, repository)
        return self._update_reference(
            self._get_branch_url(repository, name),
            paths,
        )
    def delete_branch(self, repository, name):
        log.info('delete branch %s on repository %s', name, repository)
        requests.delete(
            self._get_branch_url(repository, name),
            headers=self._get_headers(),
            verify=self.verify,
        ).raise_for_status()
    def _get_tag_url(self, repository, name):
      
LOG = logging.getLogger(__name__)
Session = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))
engine = None
repository = None
def db_init(engine):
    """ Initialize a fresh database and place it under version control """
    LOG.warn('Initializing database')
    if repository is None:
        LOG.warn('No valid repository found. Aborting.')
        return
    versioning_api.version_control(url=engine, repository=repository)
def db_upgrade(engine, version=None):
    """ Upgrade a database to the latest, or specified, version """
    if version is None:
        LOG.warn('Upgrading database to latest version')
    else:
        LOG.warn("Upgrading database to version '%s'" % str(version))
    if repository is None:
        LOG.warn('No valid repository found. Aborting.')
        return
    versioning_api.upgrade(url=engine, repository=repository, version=version)
def includeme(config):
    """ Set up SQLAlchemy """
    LOG.debug('Initializing SQLAlchemy session')
    glo
'''
Represents a GitHub repository
@since 1.0
@author Oskar Jarczyk
'''
class MyRepository():
    element_type = 'Team'
    key = None
    def __init__(self):
        self.data = []
    repository_branches = None
    repository_commits = None
    repository_contributors = None
    repository_contributors_count = None
    repository_created_at = None
    repository_default_branch = None
    repository_description = None
    repository_is_fork = None
    repository_forks = None
    repository_forks_count = None
    repository_has_downloads = None
    repository_has_issues = None
    repository_has_wiki = None
    repository_has_forks = None
    repository_homepage = None
    repository_integrate_branch = None
    repository_issues = None
    repository_labels = None
    repository_language = None
    repository_master_branch = None
    repository_name = None
    repository_open_issues = None
    repository_organization = None
    repository_owner = None
    repository_private = None
    

    repository_pulls_count = None
    repository_pushed_at = None
    repository_updated_at = None
    repository_size = None
    repository_stargazers_count = None
    repository_subscribers = None
    repository_watchers = None
    repository_url = None
    repository_network_count = None
    repo_object = None
    def setRepoObject(self, repoobject):
        self.repo_object = repoobject
    def getRepoObject(self):
        return self.repo_object
    def setKey(self, key):
        self.key = key
    def getKey(self):
        return self.key
    def setUrl(self, url):
        self.repository_url = url
    def getUrl(self):
        return self.repository_url
    def purge(self):
        'TO DO: implement this method'
    'basicly first init of data transcripted from input (csvs)'
    'name with owner, and count of forks and watchers'
    def setInitials(self, name, owner, watchers=None, forks=None):
        self.repository_name = name
        self.repository_owner = owner
        se

        self.repository_forks_count = forks
    def setName(self, name):
        self.repository_name = name
    def getName(self):
        return self.repository_name
    def setOrganization(self, repository_organization):
        self.repository_organization = repository_organization
    def getOrganization(self):
        return self.repository_organization
    def setDescription(self, repository_description):
        self.repository_description = repository_description
    def getDescription(self):
        return self.repository_description
    def setOwner(self, owner):
        self.repository_owner = owner
    def getOwner(self):
        return self.repository_owner
    def setCreatedAt(self, repository_created_at):
        self.repository_created_at = repository_created_at
    def getCreatedAt(self):
        return self.repository_created_at
    def setDefaultBranch(self, repository_default_branch):
        self.repository_default_branch = repository_default_branch
    def getDe
class TeleinfoOperations:
	CONST_TOPIC = '/bst/sensor/teleinfo/raw'
	def __init__(self, serialPort, broker):
		self.mqtt = broker
	def sendRecord(self, msg):
		self.mqtt.publish(self.CONST_TOPIC, msg)
	def run(self):		
		baseCnt = 127598
		while 1:
			try:
				time.sleep(1)
				trame = dict([["PAPP","2200"], ["IINST", "3"], ["BASE", str(baseCnt)]])
				baseCnt += 1
				
				if not os.path.exists('./stop'):
					self.sendRecord(json.dumps(trame))
				
			except KeyError:
				pass		
def on_connect(mosq, userdata, rc): 
	print "on_connect:"+str(rc) 
def on_log(mosq, userdata, level, buf): 
	print "log: "+buf
def usage():
	print 'readTeleinfo [-l] -s <serialPort> -b <brokerAddress>'
serialPort = '/dev/ttyS0'
brokerAddress = 'localhost'
try:
	opts, args = getopt.getopt(sys.argv[1:],"hls:b:",["help", "log", "serial=","broker="])
except getopt.GetoptError as err:
	print err
	usage()
	sys.exit(2)
dolog=False
for opt, arg in opts:
	if opt in ("-h", "--help"):
		usage()
      		sys.exit()
	elif 
controller = milight.MiLight({'host': '192.168.42.100', 'port': 8899}, wait_duration=.01)
light = milight.LightBulb(['white'])
def dawn():
	controller.send(light.brightness(30,4))
	controller.send(light.warmness(70,4))
	controller.send(light.brightness(30,1))
	controller.send(light.warmness(70,1))
	print("%s --- Lights set to dawn." % str(datetime.datetime.now()))
def sunrise():
        controller.send(light.brightness(100,4))
        controller.send(light.warmness(70,4))
	controller.send(light.brightness(100,1))
	controller.send(light.warmness(70,1))
	print("%s --- Lights set to sunrise." % str(datetime.datetime.now()))
def noon():
        controller.send(light.brightness(100,4))
        controller.send(light.warmness(30,4))
	controller.send(light.brightness(100,1))
	controller.send(light.warmness(30,1))
	print("%s --- Lights set to noon." % str(datetime.datetime.now()))
def sunset():
        controller.send(light.brightness(100,4))
        controller.send(light.warmness(100,4))
	cont
def clone_repository(clone_url, path, private_key_file):
    dulwich.client.get_ssh_vendor = dulwich.client.ParamikoSSHVendor
    client, host_path = dulwich.client.get_transport_and_path(clone_url)
    client.ssh_kwargs = {
        "pkey": private_key_file
    }
    r = dulwich.repo.Repo.init(path, mkdir=True)
    remote_refs = client.fetch(host_path, r, determine_wants=r.object_store.determine_wants_all)
    r["HEAD"] = remote_refs["HEAD"]
    r._build_tree()
@shared_task(bind=True)
def scan_repository(self, repository_id):
    repository = Repository.objects.get(pk=repository_id)
    if repository is not None:
        repository_keys = repository.repositorykey_set.all()
        auth_success = False
        for key_pair in repository_keys:
            try:
                working_dir = os.path.join(tempfile.gettempdir(), self.request.id)
                private_key_file = StringIO(key_pair.private_key)
                clone_repository(repository.clone_url, working_dir, private_key_fi
""":mod:`irianas_client.main` -- Program entry point
"""
sys.path[0:0] = [""]
    (ApacheServiceAPI, MySQLServiceAPI, vsFTPServiceAPI, BINDServiceAPI,
     ApacheConfigAPI, MySQLConfigAPI, BINDConfigAPI, vsFTPConfigAPI,
     SSHDServiceAPI, SSHDConfigAPI)
    (TaskBasicAPI, ConnectAPI, ClientInfoAPI)
api_services = '/api/services/'
api_services_conf = '/api/services/conf/'
api_task = '/api/task/'
debug = False
path = None
if 'VIRTUAL_ENV' in os.environ:
    path = os.path.join(os.environ['VIRTUAL_ENV'], 'ssl-demo')
    debug = True
else:
    path = '/etc/ssl/certs/'
    debug = False
try:
    context = SSL.Context(SSL.SSLv23_METHOD)
    context.use_privatekey_file(os.path.join(path, 'server.key'))
    context.use_certificate_file(os.path.join(path, 'server.crt'))
except SSL.Error:
    context = None
def main():
    app = Flask(__name__)
    api = restful.Api(app)
    api.add_resource(ApacheServiceAPI, api_services + 'apache/<string:action>',
                     api_services + 'apache'

    api.add_resource(ApacheConfigAPI, api_services_conf + 'apache')
    api.add_resource(SSHDServiceAPI, api_services + 'ssh/<string:action>',
                     api_services + 'ssh')
    api.add_resource(SSHDConfigAPI, api_services_conf + 'ssh')
    api.add_resource(MySQLServiceAPI, api_services + 'mysql/<string:action>',
                     api_services + 'mysql')
    api.add_resource(MySQLConfigAPI, api_services_conf + 'mysql')
    api.add_resource(vsFTPServiceAPI, api_services + 'vsftpd/<string:action>',
                     api_services + 'vsftpd')
    api.add_resource(vsFTPConfigAPI, api_services_conf + 'vsftpd')
    api.add_resource(BINDServiceAPI, api_services + 'bind/<string:action>',
                     api_services + 'bind')
    api.add_resource(BINDConfigAPI, api_services_conf + 'bind')
    api.add_resource(TaskBasicAPI, api_task + '<string:action>')
    api.add_resource(ClientInfoAPI, api_task + 'info')
    api.add_resource(ConnectAPI, '/api/connect')
    app.config.u
    PartitionsSummary,
    PartitionState
class TestStormKafkaMonitorCollector(CollectorTestCase):
    def setUp(self):
        config = get_collector_config('StormKafkaMonitorCollector', {
            'interval': 10
        })
        self.collector = StormKafkaMonitorCollector(config, None)
    @patch.object(StormKafkaMonitorCollector, 'get_zk_client')
    def test_running_topologies(self, zk):
        zk.return_value.client.get_children.return_value = [
            'foo-1-123123',
            'bar-12-456778',
        ]
        self.assertEqual(['foo', 'bar'], self.collector.running_topologies())
    @patch.object(StormKafkaMonitorCollector, 'get_zk_client')
    def test_metric_name_from_partition_state(self, zk):
        partition_state = PartitionState('broker.local','foo',0,2000,1000,0,'topo',1000,0)
        self.assertEqual(self.collector.metric_name_from_state(partition_state), 'broker.0.foo.')
    @patch.object(StormKafkaMonitorCollector, 'get_zk_client')
    def test_metrics_f

        partition_state = PartitionState('broker.i.foo.bar','foo',0,2000,1000,0,'bar',1000,0)
        self.assertEqual(self.collector.metrics_from_partition_state(partition_state), [
            ('broker.0.foo.earliest', 2000),
            ('broker.0.foo.latest', 1000),
            ('broker.0.foo.depth', 0),
            ('broker.0.foo.current', 1000),
            ('broker.0.foo.delta', 0),
        ])
    @patch.object(Collector, 'publish')
    @patch.object(StormKafkaMonitorCollector, 'get_summaries')
    @patch.object(StormKafkaMonitorCollector, 'get_zk_client')
    def test_collect(self, zk, summaries, publish_mock):
        partition_state = PartitionState('broker.local','foo',0,2000,1000,0,'topo',1000,0)
        partition = PartitionsSummary(1,2,1,3,[partition_state])
        summaries.return_value = [('topo', partition)]
        expected_metrics = {
            'topo.total_depth': 1,
            'topo.total_delta': 2,
            'topo.num_partitions': 1,
            'topo.num_br
test_namespace = dict()
orig_dispatch = dispatch
dispatch = partial(dispatch, namespace=test_namespace)
def test_singledispatch():
    @dispatch(int)
    def f(x):
        return x + 1
    @dispatch(int)
    def g(x):
        return x + 2
    @dispatch(float)
    def f(x):
        return x - 1
    assert f(1) == 2
    assert g(1) == 3
    assert f(1.0) == 0
    assert raises(NotImplementedError, lambda: f('hello'))
def test_multipledispatch():
    @dispatch(int, int)
    def f(x, y):
        return x + y
    @dispatch(float, float)
    def f(x, y):
        return x - y
    assert f(1, 2) == 3
    assert f(1.0, 2.0) == -1.0
class A(object): pass
class B(object): pass
class C(A): pass
class D(C): pass
class E(C): pass
def test_inheritance():
    @dispatch(A)
    def f(x):
        return 'a'
    @dispatch(B)
    def f(x):
        return 'b'
    assert f(A()) == 'a'
    assert f(B()) == 'b'
    assert f(C()) == 'a'
def test_inheritance_and_multiple_dispatch():
    @dispatch(A, A)
    def f

        return type(x), type(y)
    @dispatch(A, B)
    def f(x, y):
        return 0
    assert f(A(), A()) == (A, A)
    assert f(A(), C()) == (A, C)
    assert f(A(), B()) == 0
    assert f(C(), B()) == 0
    assert raises(NotImplementedError, lambda: f(B(), B()))
def test_competing_solutions():
    @dispatch(A)
    def h(x):
        return 1
    @dispatch(C)
    def h(x):
        return 2
    assert h(D()) == 2
def test_competing_multiple():
    @dispatch(A, B)
    def h(x, y):
        return 1
    @dispatch(C, B)
    def h(x, y):
        return 2
    assert h(D(), B()) == 2
def test_competing_ambiguous():
    @dispatch(A, C)
    def f(x, y):
        return 2
    @dispatch(C, A)
    def f(x, y):
        return 2
    assert f(A(), C()) == f(C(), A()) == 2
def test_caching_correct_behavior():
    @dispatch(A)
    def f(x):
        return 1
    assert f(C()) == 1
    @dispatch(C)
    def f(x):
        return 2
    assert f(C()) == 2
def test_union_types():
    @dispatch((A, C))
    d

        return 1
    assert f(A()) == 1
    assert f(C()) == 1
def test_namespaces():
    ns1 = dict()
    ns2 = dict()
    def foo(x):
        return 1
    foo1 = orig_dispatch(int, namespace=ns1)(foo)
    def foo(x):
        return 2
    foo2 = orig_dispatch(int, namespace=ns2)(foo)
    assert foo1(0) == 1
    assert foo2(0) == 2
"""
Fails
def test_dispatch_on_dispatch():
    @dispatch(A)
    @dispatch(C)
    def q(x):
        return 1
    assert q(A()) == 1
    assert q(C()) == 1
"""
def test_methods():
    class Foo(object):
        @dispatch(float)
        def f(self, x):
            return x - 1
        @dispatch(int)
        def f(self, x):
            return x + 1
        @dispatch(int)
        def g(self, x):
            return x + 3
    foo = Foo()
    assert foo.f(1) == 2
    assert foo.f(1.0) == 0.0
    assert foo.g(1) == 4
def test_methods_multiple_dispatch():
    class Foo(object):
        @dispatch(A, A)
        def f(x, y):
            return 1
        @dispatch(A, C)

urlpatterns = patterns('exam.views',
    url(r'^$', 'index'),
    url(r'^login/$', 'user_login'),
    url(r'^quizzes/$','quizlist_user'),
    url(r'^results/$','results_user'),
    url(r'^start/$', 'start'),
    url(r'^start/(?P<questionpaper_id>\d+)/$','start'),
    url(r'^quit/(?P<questionpaper_id>\d+)/$', 'quit'),
    url(r'^intro/(?P<questionpaper_id>\d+)/$','intro'),
    url(r'^complete/$', 'complete'),
    url(r'^complete/(?P<questionpaper_id>\d+)/$', 'complete'),
    url(r'^register/$', 'user_register'),
    url(r'^(?P<q_id>\d+)/$', 'question'),
    url(r'^(?P<q_id>\d+)/check/$', 'check'),
    url(r'^(?P<q_id>\d+)/check/(?P<questionpaper_id>\d+)/$', 'check'),
    url(r'^intro/$', 'start'),
    url(r'^manage/$', 'prof_manage'),
    url(r'^manage/addquestion/$', 'add_question'),
    url(r'^manage/addquestion/(?P<question_id>\d+)/$', 'add_question'),
    url(r'^manage/addquiz/$', 'add_quiz'),
    url(r'^manage/editquiz/$', 'edit_quiz'),
    url(r'^manage/editquestion/$', 'edit_ques

    url(r'^manage/addquiz/(?P<quiz_id>\d+)/$', 'add_quiz'),
    url(r'^manage/gradeuser/$', 'show_all_users'),
    url(r'^manage/gradeuser/(?P<username>[a-zA-Z0-9_.]+)/$', 'grade_user'),
    url(r'^manage/questions/$', 'show_all_questions'),
    url(r'^manage/showquiz/$','show_all_quiz'),
    url(r'^manage/monitor/$', 'monitor'),
    url(r'^manage/showquestionpapers/$','show_all_questionpapers'),
    url(r'^manage/showquestionpapers/(?P<questionpaper_id>\d+)/$',\
                                                    'show_all_questionpapers'),
    url(r'^manage/monitor/(?P<questionpaper_id>\d+)/$', 'monitor'),
    url(r'^manage/user_data/(?P<username>[a-zA-Z0-9_.]+)/$','user_data'),
    url(r'^manage/designquestionpaper/$','design_questionpaper'),
    url(r'^manage/designquestionpaper/(?P<questionpaper_id>\d+)/$',\
                                                        'design_questionpaper'),
    url(r'^manage/designquestionpaper/automatic/(?P<questionpaper_id>\d+)/$',\
              
io.use_plugin('pil')
priority_plugin = 'pil'
def setup_module():
def teardown_module():
    io.reset_plugins()
@contextmanager
def protect_preferred_plugins():
    """Contexts where `preferred_plugins` can be modified w/o side-effects."""
    preferred_plugins = manage_plugins.preferred_plugins.copy()
    try:
        yield
    finally:
        manage_plugins.preferred_plugins = preferred_plugins
def test_read():
    io.imread('test.png', as_grey=True, dtype='i4', plugin='test')
def test_save():
    io.imsave('test.png', [1, 2, 3], plugin='test')
def test_show():
    io.imshow([1, 2, 3], plugin_arg=(1, 2), plugin='test')
def test_collection():
    ic = io.imread_collection('*.png', conserve_memory=False, plugin='test')
    io.imshow_collection(ic)
def test_use():
    manage_plugins.use_plugin('test')
    manage_plugins.use_plugin('test', 'imshow')
@raises(ValueError)
def test_failed_use():
    manage_plugins.use_plugin('asd')
def test_use_priority():
    manage_plugins.use_plugin(prior

    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, priority_plugin)
    manage_plugins.use_plugin('test')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'test')
def test_use_priority_with_func():
    manage_plugins.use_plugin('pil')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'pil')
    manage_plugins.use_plugin('test', 'imread')
    plug, func = manage_plugins.plugin_store['imread'][0]
    assert_equal(plug, 'test')
    plug, func = manage_plugins.plugin_store['imsave'][0]
    assert_equal(plug, 'pil')
    manage_plugins.use_plugin('test')
    plug, func = manage_plugins.plugin_store['imsave'][0]
    assert_equal(plug, 'test')
def test_plugin_order():
    p = io.plugin_order()
    assert 'imread' in p
    assert 'test' in p['imread']
def test_available():
    assert 'qt' in io.available_plugins
    assert 'test' in io.find_available_plugins(loaded=True)
def test_load_preferred_plugins
ROOT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
sys.path.insert(0, os.path.join( os.path.dirname(__file__), '../' ) )
def convertCamelCase2Underscore(name):
  s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
  return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
def run_application(options, instance_name):
  input_log_file_handler = logging.handlers.TimedRotatingFileHandler(
    os.path.expanduser(options.mailer_log), when='MIDNIGHT')
  input_log_file_handler.setFormatter(logging.Formatter(u"%(asctime)s - %(message)s"))
  mail_logger = logging.getLogger(instance_name)
  mail_logger.setLevel(logging.INFO)
  mail_logger.addHandler(input_log_file_handler)
  ch = logging.StreamHandler(sys.stdout)
  ch.setLevel(logging.DEBUG)
  ch.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
  mail_logger.addHandler(ch)
  mail_logger.info('START')
  def log(command, key, value=None):
    log_msg = u'%s, %s, %s' %(command, key, valu

    mail_logger.info(unicode(log_msg))
  log('PARAM', 'BEGIN')
  log('PARAM', 'trade_in',                      options.trade_in)
  log('PARAM', 'trade_pub',                     options.trade_pub)
  log('PARAM', 'mailer_log',                    options.mailer_log)
  log('PARAM', 'mailchimp_apikey',              options.mailchimp_apikey)
  log('PARAM', 'mandrill_apikey',               options.mandrill_apikey)
  log('PARAM', 'mailer_username',               options.mailer_username)
  log('PARAM', 'mailchimp_newsletter_list_id',  options.mailchimp_newsletter_list_id)
  log('PARAM', 'END')
  context = zmq.Context()
  socket = context.socket(zmq.SUB)
  socket.connect(options.trade_pub)
  socket.setsockopt(zmq.SUBSCRIBE, "^EMAIL$")
  trade_in_socket = context.socket(zmq.REQ)
  trade_in_socket.connect(options.trade_in)
  application_trade_client = TradeClient( context, trade_in_socket)
  application_trade_client.connect()
  login_response = application_trade_client.sendJSON( MessageBuilder.lo

                                                                            options.mailer_username,
                                                                            options.mailer_password))
  if login_response.get('UserStatus') != 1:
    raise RuntimeError("Invalid user id")
  brokers = {}
  broker_list, broker_list_columns = application_trade_client.getBrokerList(['1'])
  for b in  broker_list:
    brokers[b[0]] = { "params": b }
  broker_mandrill_column_index = None
  try:
    broker_mandrill_column_index = broker_list_columns.index('MandrillApiKey')
  except ValueError:
    pass
  for broker_id, broker_data  in brokers.iteritems():
    if broker_mandrill_column_index and broker_data['params'][ broker_mandrill_column_index ]:
      broker_data['MandrillApiKey'] =  broker_data['params'][ broker_mandrill_column_index ]
    else:
      broker_data['MandrillApiKey'] = options.mandrill_apikey
  for broker_id, broker_data  in brokers.iteritems():
    print broker_id, broker_d
LTinfo = Corso.objects.get(titolo="LT-Informatica")
insegnamento = Insegnamento(titolo="Algebra lineare", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Algoritmi e strutture dati", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Analisi matematica I", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Analisi matematica II", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Apprendimento ed evoluzione in sistemi artificiali", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Architettura dei calcolatori", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Basi di dati", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Calcolo numerico", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Calcolo parallelo", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Elaborazione degli elementi in chimica", corso=LTi

insegnamento.save()
insegnamento = Insegnamento(titolo="Fisica", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Geometria", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Gestione avanzata dell'informazione", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Inglese", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Linguaggi dinamici", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Linguaggi formali e compilazione", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Metodi di ottimizzazione per la logistica", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Progetto del software", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Programmazione I", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Programmazione II", corso=LTinfo)
insegnamento.save()
insegnamento = Insegnamento(titolo="Programmazi
urlpatterns = patterns("djangopypi.views",
    url(r'^$', "root", name="djangopypi-root"),
    url(r'^simple/$','packages.simple_index', name='djangopypi-package-index-simple'),
    url(r'^bootstrap/$', 'releases.bootstrap_index', name='djangopypi-bootstrap-index-simple'),
    url(r'^search/$','packages.search',name='djangopypi-search'),
    url(r'^pypi/$', 'root', name='djangopypi-release-index'),
    
    url(r'^simple/(?P<package>[\w\d_\.\-]+)/$','packages.simple_details',
        name='djangopypi-package-simple'),
    
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/$','packages.details',
        name='djangopypi-package'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/doap.rdf$','packages.doap',
        name='djangopypi-package-doap'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/manage/$','packages.manage',
        name='djangopypi-package-manage'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/manage/versions/$','packages.manage_versions',
        name='djangopypi-package-manage-versions'),
    

    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/$',
        'releases.details',name='djangopypi-release'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/doap.rdf$',
        'releases.doap',name='djangopypi-release-doap'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/manage/$',
        'releases.manage',name='djangopypi-release-manage'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/metadata/$',
        'releases.manage_metadata',name='djangopypi-release-manage-metadata'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/files/$',
        'releases.manage_files',name='djangopypi-release-manage-files'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/files/upload/$',
        'releases.upload_file',name='djangopypi-release-upload-file'),
    url(
        r'^%s/(?P<path>.*)$' % (settings.DJANGOPYPI_RELEASE_URL.strip('/')),
        'releases.download_dist', {
      
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map():
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'], explicit=True)
    map.minimization = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.connect('/', controller='post', action='home')
    map.connect('/blog', controller='post', action='blog')
    
    """Administrative actions
    """
    map.connect('/admin/dashboard', 
                controller='account', 
                action='dashboard')
    
    map.connect('/signout', 
                controller='account', 
                action='signout')
    
    map.connect('/admin/signin', 
           

                action='signinagain')
    
    map.connect('/admin/{controller}/new',
                controller='{controller}',
                action='new'
                )
    map.connect('/admin/{controller}/create',
                controller='{controller}',
                action='create'
                )
    map.connect('/admin/{controller}/edit/{id}',
                controller='{controller}',
                action='edit'
                )
    map.connect('/admin/{controller}/save/{id}',
                controller='{controller}',
                action='save'
                )
    map.connect('/admin/{controller}/list',
                controller='{controller}',
                action='list'
                )
    map.connect('/admin/{controller}/approve_confirm/{id}',
                controller='{controller}',
                action='approve_confirm'
                )
    map.connect('/admin/{controller}/approve/{id}',
                controller='{controller}',
            

                )
    map.connect('/admin/{controller}/disapprove_confirm/{id}',
                controller='{controller}',
                action='disapprove_confirm'
                )
    map.connect('/admin/{controller}/disapprove/{id}',
                controller='{controller}',
                action='disapprove'
                )
    map.connect('/admin/{controller}/delete_confirm/{id}',
                controller='{controller}',
                action='delete_confirm'
                )
    map.connect('/admin/{controller}/delete/{id}',
                controller='{controller}',
                action='delete'
                )  
    
    map.connect('/feeds/', 
                controller='feed', 
                action='redirect_wp_feeds')
    
    map.connect('/feeds/blog', 
                controller='feed', 
                action='posts_feed')
    
    map.connect('/feeds/blog/sitemap', 
                controller='feed', 
                action='posts_feed_sitemap')
    
 
class Scaffolding(object):
    """
    Scaffolding Component
    """
    def __init__(self, controller):
        self.controller = controller
        self._init_meta()
        self._init_flash()
    def _init_flash(self):
        if not FlashMessages in self.controller.Meta.components:
            self.controller.components['flash_messages'] = FlashMessages(self.controller)
    def _init_meta(self):
        """
        Constructs the controller's scaffold property from the controller's Scaffold class.
        If the controller doens't have a scaffold, uses the automatic one.
        """
        if not hasattr(self.controller.Meta, 'Model'):
            _load_model(self.controller)
        if not hasattr(self.controller, 'Scaffold'):
            setattr(self.controller, 'Scaffold', Scaffold)
        if not issubclass(self.controller.Scaffold, Scaffold):
            self.controller.Scaffold = type('Scaffold', (self.controller.Scaffold, Scaffold), {})
        setattr(self.controller, 'sca

        self.controller.events.template_names += self._on_template_names
        self.controller.events.before_render += self._on_before_render
        self.controller.events.scaffold_before_parse += self._on_scaffold_before_parse
    def _on_scaffold_before_parse(self, controller):
        if not hasattr(controller.meta, 'Form') or not controller.meta.Form:
            controller.meta.Form = controller.scaffold.ModelForm
    def _on_template_names(self, controller, templates):
        """Injects scaffold templates into the template list"""
        controller, prefix, action, ext = self.controller.route.name, self.controller.route.prefix, self.controller.route.action, self.controller.meta.view.template_ext
        if prefix:
            templates.append('scaffolding/%s_%s.%s' % (prefix, action, ext))
        templates.append('scaffolding/%s.%s' % (action, ext))
    def _on_before_render(self, controller):
        controller.context['scaffolding'] = {
            'name': controller.nam

            'proper_name': controller.proper_name,
            'title': controller.scaffold.title,
            'plural': controller.scaffold.plural,
            'singular': controller.scaffold.singular,
            'form_action': controller.scaffold.form_action,
            'form_encoding': controller.scaffold.form_encoding,
            'display_properties': controller.scaffold.display_properties,
            'layouts': controller.scaffold.layouts
        }
class Scaffold(object):
    """
    Scaffold Meta Object Base Class
    """
    def __init__(self, controller):
        defaults = dict(
            query_factory=default_query_factory,
            create_factory=default_create_factory,
            title=inflector.titleize(controller.proper_name),
            plural=inflector.underscore(controller.name),
            singular=inflector.underscore(inflector.singularize(controller.name)),
            ModelForm=model_form(controller.meta.Model),
            display_properties=sorted([n
class ActionMenuController(PygameController):
    """ Controller for Battle Rounds """
    
    def __init__(self, pokemon, battle, screen):
        """ Initialize the Battle Round Controller """
        self.pokemon = pokemon
        self.battle = battle
        self.action = None
        
        entries = [TextMenuEntry("Fight", self.chooseAttack),
                   TextMenuEntry("Switch", self.switch),
                   TextMenuEntry("Item", None),
                   TextMenuEntry("Run", None)]
        self.menu = Menu(entries, columns=2)
        
        self.view = ActionMenuWidget(self.menu, self.getWindow().width*.9, self.getWindow().height*.3)
        screen.setBottomView(self.view)
        cmds = {commands.UP:self.menu.up,
                commands.DOWN:self.menu.down,
                commands.LEFT:self.menu.left,
                commands.RIGHT:self.menu.right,
                commands.SELECT:self.menu.enter}
        PygameController.__init__(self, screen, commands=cmds)
   
def save_data(vocabulary, examples, cal_only):
  save_file = str()
  if cal_only:
    save_file = os.path.expanduser(private_consts.SAVE_DIR)+"uninflated_data.{0}_cal_only.pickle".format(len(examples))
  else:
    save_file = os.path.expanduser(private_consts.SAVE_DIR)+"uninflated_data.{0}.pickle".format(len(examples))
  pickle.dump( {"vocabulary":vocabulary, "examples":examples} , open( save_file, "wb" ) )
def save_model(model, name, size, cal_only):
  print "saving model {0} {1}".format(name,size)
  save_file = os.path.expanduser(private_consts.SAVE_DIR)+"{0}.{1}.pickle".format(name, size)
  if cal_only:
    save_file = os.path.expanduser(private_consts.SAVE_DIR)+"{0}.{1}_cal_only.pickle".format(name, size)
  pickle.dump( model , open( save_file, "wb" ) )
def load_model(name, size, cal_only):
  save_file = os.path.expanduser(private_consts.SAVE_DIR)+"{0}.{1}.pickle".format(name, size)
  if cal_only:
    save_file = os.path.expanduser(private_consts.SAVE_DIR)+"{0}.{1}_cal_only.pickle"

  return pickle.load( open( save_file, "rb" ) )
def load_data(num_examples, cal_only = False):
  save_file = str()
  if cal_only:
    save_file = os.path.expanduser(private_consts.SAVE_DIR)+"uninflated_data.{0}_cal_only.pickle".format(num_examples)
  else:
    save_file = os.path.expanduser(private_consts.SAVE_DIR)+"uninflated_data.{0}.pickle".format(num_examples)
  uninflated_data = pickle.load( open( save_file, "rb" ) )
  vocabulary = uninflated_data["vocabulary"]
  x = []
  t = [example[1] for example in uninflated_data["examples"]]
  for example in uninflated_data["examples"]:
    tokens_list = [0] * len(vocabulary)
    for token in example[0]:
      tokens_list[list(vocabulary).index(token)] = 1
    x.append(tokens_list)
  return (x,t, vocabulary)
def load_and_split_data(num_examples = 100, percent_train = 0.8):
  (x, t, v) = load_data(num_examples)
  num_train = int(num_examples*percent_train)
  train_indices = random.sample(range(num_examples), num_train)
  x_train = [x[i] for 
class RedisBroker(object):
    instance = None
    def __init__(self):
        if not self.instance:
            self.connection = redis.Redis(
                    settings.REDIS_URL, settings.REDIS_PORT)
            self.instance = self
        else:
            self = self.instance
    def notify(self, channel, message):
        print "sending message '{message}' on channel '{channel}' PORT-{port}, HOST-{host}".format(
                            message=message,
                            channel=channel,
                            port=settings.REDIS_PORT,
                            host=settings.REDIS_URL
                        )
        return self.connection.publish(channel, message)
class DefaultBroker(object):
    def __init__(self):
        print "INVALID BROKER NAME - RUNING IN DEFAULT MODE \
                (PRINTING MESSAGES IN CONSOLE)"
    def notify(self, channel, message):
        print "sending message '{message}' on channel '{channel}' \
                PORT-{por
__author__ = 'christophe'
class KeyAuthenticationTests(AuthenticationTest):
  def setUp(self):
    ApplicationTest.setUp(self)
    self.startApplication(pluginPackages={
      IAuth: keyAuth
    })
  def testAnonymous(self):
    remoteRepository = self._testPush(None)
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
  def testInvalidUser(self):
    remoteRepository = self._testPush("random")
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
  def testValidUser(self):
    remoteRepository = self._testPush("key")
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository, keyFile = "test")

class PasswordAuthenticationTests(AuthenticationTest):
  def setUp(self):
    ApplicationTest.setUp(self)
    self.startApplication(pluginPackages={
      IAuth: passAuth
    })
  def _testSSH(self, user):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(None, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("ssh", self.ssh, remoteRepository.path.split('/')[-1], user))
    self.generateComplicatedCommit()
    return remoteRepository
  def _testHTTP(self, user):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(None, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("http", self.http, remoteRepository.path.split('/')[-1], user))
    self.generateComplicatedCommit()
    return remoteRepository
  def testSSHInvalidUser(self):
    remoteRepository = self._testSSH("random")
    def processEnded(result):
      self.assertPermissionDenied()
      self.asse

    return self.pushRepository(self.repository).addCallback(processEnded)
  def testHTTPInvalidUser(self):
    remoteRepository = self._testHTTP("random")
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
  def testSSHValidUserWrongPassword(self):
    remoteRepository = self._testSSH("pass")
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository, "test").addCallback(processEnded)
  def testHTTPValidUserWrongPassword(self):
    remoteRepository = self._testHTTP("pass")
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository, "test").addCallback(processEnded)
  def testSSHValidUser(self):
    remoteReposit
def obj_to_dictionary(repository):
    if not repository:
        return None
    return {'name': repository.name,
            'description': repository.description,
            'url': repository.url,
            'graph_url': repository.graph_url}
def obj_to_tuple(repository):
    if not repository:
        return None
    return (repository.name,
            repository.description,
            repository.url,
            repository.graph_url)
def dict_to_tuple(repository):
    if not repository:
        return None
    return (repository['name'],
            repository['description'],
            repository['url'],
            repository['graph_url'])
def update_models(project_list, user):
    for project in project_list:
        update_model(project, user)
def update_model(project, user):
    proj_model = models.Project(name=project['name'],
                 description=project['description'],
                 url=project['url'],
                 graph_url=project['graph_url'],
     
g = Digraph('loan market', filename='loan_market.gv')
a = Digraph('cluster_a')
a.attr('node', shape='box')
a.body.append('style=filled'); a.body.append('color=white')
arbs = ['Arbitrageur 1', 'Arbitrageur 2', 'Arbitrageur 3', 'Arbitrageur 4',
         'Arbitrageur 5', 'Arbitrageur 6']
for arb in arbs:
    a.node(arb)
a.edge('Arbitrageur 1', 'Arbitrageur 2', style='invis')
a.edge('Arbitrageur 2', 'Arbitrageur 3', style='invis')
a.edge('Arbitrageur 3', 'Arbitrageur 4', style='invis')
a.edge('Arbitrageur 4', 'Arbitrageur 5', style='invis')
a.edge('Arbitrageur 5', 'Arbitrageur 6', style='invis')
b = Digraph('cluster_b')
b.attr('node', shape='ellipse')
b.body.append('style=filled'); b.body.append('color=white')
brokers = ['Broker 1', 'Broker 2', 'Broker 3']
for bro in brokers:
    b.node(bro)
b.edge('Broker 1', 'Broker 2', style='invis')
b.edge('Broker 2', 'Broker 3', style='invis')
l = Digraph('cluster_l')
l.attr('node', shape='box')
l.body.append('style=filled'); l.body.append('color=whit
OpenDatabase("localhost:/Users/jkulesza/tmp/simple_case_core_FSRmesh.vtk", 0)
AddPlot("FilledBoundary", "materials", 1, 1)
DrawPlots()
AnnotationAtts = AnnotationAttributes()
AnnotationAtts.axes3D.autoSetTicks = 0
AnnotationAtts.axes3D.xAxis.tickMarks.visible = 1
AnnotationAtts.axes3D.xAxis.tickMarks.majorMinimum = 0
AnnotationAtts.axes3D.xAxis.tickMarks.majorMaximum = 42.84
AnnotationAtts.axes3D.xAxis.tickMarks.minorSpacing = 1.26
AnnotationAtts.axes3D.xAxis.tickMarks.majorSpacing = 1.26 
AnnotationAtts.axes3D.yAxis.tickMarks.visible = 0
AnnotationAtts.axes3D.zAxis.tickMarks.visible = 0
AnnotationAtts.axes3D.xAxis.title.visible = 0
AnnotationAtts.axes3D.xAxis.label.visible = 0
AnnotationAtts.axes3D.yAxis.title.visible = 0
AnnotationAtts.axes3D.yAxis.label.visible = 0
AnnotationAtts.axes3D.zAxis.title.visible = 0
AnnotationAtts.axes3D.zAxis.label.visible = 0
SetAnnotationAttributes(AnnotationAtts)          
View3DAtts = View3DAttributes()
View3DAtts.viewNormal = (0, 0, 1)
View3DAtts.fo

View3DAtts.viewUp = (0, 1, 0)
View3DAtts.viewAngle = 30
View3DAtts.parallelScale = 21.5035
View3DAtts.nearPlane = -43.007
View3DAtts.farPlane = 43.007
View3DAtts.imagePan = (0, 0)
View3DAtts.imageZoom = 1
View3DAtts.perspective = 0
View3DAtts.eyeAngle = 2
View3DAtts.centerOfRotationSet = 0
View3DAtts.centerOfRotation = (21.42, 0.63, 1.785)
View3DAtts.axis3DScaleFlag = 0
View3DAtts.axis3DScales = (1, 1, 1)
View3DAtts.shear = (0, 0, 1)
View3DAtts.windowValid = 1
SetView3D(View3DAtts)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 1
SaveWindowAtts.outputDirectory = "."
SaveWindowAtts.fileName = "simple_case_plot_material"
SaveWindowAtts.family = 0
SaveWindowAtts.quality = 90
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
DeleteActivePlots()
AddPlot("Pseudocolor", "flux___1", 1, 1)
DrawPlots()
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 1
SaveWindowAtts.outputDirectory = "."
SaveWindowAtts.fileName = "simple_ca

SaveWindowAtts.family = 0
SaveWindowAtts.quality = 90
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetQueryFloatFormat("%g")
Query("Lineout", end_point=(42.84, 0.63, 1.785), num_samples=50, start_point=(0, 0.63, 1.785), use_sampling=0, 
    vars=("flux___1", "flux___2", "flux___3", "flux___4", "flux___5", "flux___6", "flux___7", "flux___8", "flux___9", "flux__10",   
          "flux__11", "flux__12", "flux__13", "flux__14", "flux__15", "flux__16", "flux__17", "flux__18", "flux__19", "flux__20", 
          "flux__21", "flux__22", "flux__23", "flux__24", "flux__25", "flux__26", "flux__27", "flux__28", "flux__29", "flux__30", 
          "flux__31", "flux__32", "flux__33", "flux__34", "flux__35", "flux__36", "flux__37", "flux__38", "flux__39", "flux__40", 
          "flux__41", "flux__42", "flux__43", "flux__44", "flux__45", "flux__46", "flux__47", "flux__48", "flux__49", "flux__50", 
          "flux__51", "flux__52", "flux__53", "flux__54", "flux__55", "flux__56"))
SetActiveWindo
urlpatterns = patterns('parsifal.reviews.planning.views',
    url(r'^save_source/$', 'save_source', name='save_source'),
    url(r'^remove_source/$', 'remove_source_from_review', name='remove_source_from_review'),
    url(r'^suggested_sources/$', 'suggested_sources', name='suggested_sources'),
    url(r'^add_suggested_sources/$', 'add_suggested_sources', name='add_suggested_sources'),
    url(r'^save_question/$', 'save_question', name='save_question'),
    url(r'^save_question_order/$', 'save_question_order', name='save_question_order'),
    url(r'^save_picoc/$', 'save_picoc', name='save_picoc'),
    url(r'^add_or_edit_question/$', 'add_or_edit_question', name='add_or_edit_question'),
    url(r'^remove_question/$', 'remove_question', name='remove_question'),
    url(r'^save_objective/$', 'save_objective', name='save_objective'),
    url(r'^add_criteria/$', 'add_criteria', name='add_criteria'),
    url(r'^remove_criteria/$', 'remove_criteria', name='remove_criteria'),
    url(r'^add_key

    url(r'^edit_keyword/$', 'edit_keyword', name='edit_keyword'),
    url(r'^remove_keyword/$', 'remove_keyword', name='remove_keyword'),
    url(r'^add_quality_assessment_question/$', 'add_quality_assessment_question', name='add_quality_assessment_question'),
    url(r'^edit_quality_assessment_question/$', 'edit_quality_assessment_question', name='edit_quality_assessment_question'),
    url(r'^save_quality_assessment_question/$', 'save_quality_assessment_question', name='save_quality_assessment_question'),
    url(r'^save_quality_assessment_question_order/$', 'save_quality_assessment_question_order', name='save_quality_assessment_question_order'),
    url(r'^remove_quality_assessment_question/$', 'remove_quality_assessment_question', name='remove_quality_assessment_question'),
    url(r'^add_quality_assessment_answer/$', 'add_quality_assessment_answer', name='add_quality_assessment_answer'),
    url(r'^edit_quality_assessment_answer/$', 'edit_quality_assessment_answer', name='edit_qu

    url(r'^save_quality_assessment_answer/$', 'save_quality_assessment_answer', name='save_quality_assessment_answer'),
    url(r'^remove_quality_assessment_answer/$', 'remove_quality_assessment_answer', name='remove_quality_assessment_answer'),
    url(r'^add_suggested_answer/$', 'add_suggested_answer', name='add_suggested_answer'),
    url(r'^add_new_data_extraction_field/$', 'add_new_data_extraction_field', name='add_new_data_extraction_field'),
    url(r'^edit_data_extraction_field/$', 'edit_data_extraction_field', name='edit_data_extraction_field'),
    url(r'^save_data_extraction_field/$', 'save_data_extraction_field', name='save_data_extraction_field'),
    url(r'^save_data_extraction_field_order/$', 'save_data_extraction_field_order', name='save_data_extraction_field_order'),
    url(r'^remove_data_extraction_field/$', 'remove_data_extraction_field', name='remove_data_extraction_field'),
    url(r'^calculate_max_score/$', 'calculate_max_score', name='calculate_max_score'),
   
try:
except ImportError:
HA_BROKER = "org.apache.qpid.ha:habroker:ha-broker"
class ExitStatus(Exception):
    """Raised if a command want's a non-0 exit status from the script"""
    def __init__(self, status): self.status = status
class Command:
    commands = {}
    def __init__(self, name, help, arg_names=[]):
        Command.commands[name] = self
        self.name = name
        self.arg_names = arg_names
        usage="%s [options] %s\n\n%s"%(name, " ".join(arg_names), help)
        self.help = help
        self.op=optparse.OptionParser(usage)
        self.op.add_option("--sasl-mechanism", action="store", type="string", metavar="<mech>", help="SASL mechanism for authentication (e.g. EXTERNAL, ANONYMOUS, PLAIN, CRAM-MD, DIGEST-MD5, GSSAPI). SASL automatically picks the most secure available mechanism - use this option to override.")
        self.op.add_option("--ssl-certificate", action="store", type="string", metavar="<cert>", help="Client SSL certificate (PEM Format)")
        se

        self.op.add_option("-b", "--broker", action="store", type="string", default="localhost:5672", metavar="<address>", help="Address of qpidd broker with syntax: [username/password@] hostname | ip-address [:<port>]")
    def execute(self, args):
        opts, args = self.op.parse_args(args)
        if len(args) != len(self.arg_names)+1:
            self.op.print_help()
            raise Exception("Wrong number of arguments")
        conn_options = {}
        if opts.sasl_mechanism:
            conn_options['sasl_mechanisms'] = opts.sasl_mechanism
        if opts.ssl_certificate:
            conn_options['ssl_certfile'] = opts.ssl_certificate
        if opts.ssl_key:
            if not opts.ssl_certificate:
                self.op.error("missing '--ssl-certificate' (required by '--ssl-key')")
            conn_options['ssl_keyfile'] = opts.ssl_key
        conn_options['client_properties'] = {'qpid.ha-admin' : 1}
        connection = Connection.establish(opts.broker, **conn_options)


        ha_broker = qmf_broker.getHaBroker()
        if not ha_broker: raise Exception("HA module is not loaded on broker at %s" % opts.broker)
        try: self.do_execute(qmf_broker, ha_broker, opts, args)
        finally: connection.close()
    def do_execute(self, qmf_broker, opts, args):
        raise Exception("Command '%s' is not yet implemented"%self.name)
class PromoteCmd(Command):
    def __init__(self):
        Command.__init__(self, "promote","Promote broker from backup to primary")
    def do_execute(self, qmf_broker, ha_broker, opts, args):
        qmf_broker._method("promote", {}, HA_BROKER)
PromoteCmd()
class StatusCmd(Command):
    def __init__(self):
        Command.__init__(self, "status", "Print HA status")
        self.op.add_option(
            "--expect", type="string", metavar="<status>",
            help="Don't print status. Return 0 if it matches <status>, 1 otherwise")
        self.op.add_option(
            "--is-primary", action="store_true", default=False
in_access = django.dispatch.Signal(providing_args=["event"])
in_attrib = django.dispatch.Signal(providing_args=["event"])
in_close_nowrite = django.dispatch.Signal(providing_args=["event"])
in_close_write = django.dispatch.Signal(providing_args=["event"])
in_create = django.dispatch.Signal(providing_args=["event"])
in_delete = django.dispatch.Signal(providing_args=["event"])
in_delete_self = django.dispatch.Signal(providing_args=["event"])
in_ignored = django.dispatch.Signal(providing_args=["event"])
in_modify = django.dispatch.Signal(providing_args=["event"])
in_move_self = django.dispatch.Signal(providing_args=["event"])
in_moved_from = django.dispatch.Signal(providing_args=["event"])
in_moved_to = django.dispatch.Signal(providing_args=["event"])
in_open = django.dispatch.Signal(providing_args=["event"])
in_q_overflow = django.dispatch.Signal(providing_args=["event"])
in_unmount = django.dispatch.Signal(providing_args=["event"])
@receiver(request_finished)
def in_access_callback(in_a
robots = ['j2n6s300', 'm1n6s300', 'm1n6s200', 'j2n7s300', 'j2s6s300', 'j2s7s300']
joint_p = [5000,5000,5000,500,200,500,500]
joint_i = [0,0,0,0,0,0,0]
joint_d = [0,0,0,0,0,0,0]
finger_p = [10,10,10]
finger_i = [0,0,0]
finger_d = [0,0,0]
for robot_name in robots:
  dof = int(robot_name[3])
  fingers = int(robot_name[5])
  robot_joints = []
  finger_joints = []
  if (dof ==7):
    joints_p = [5000,5000,500,500,200,500,500]
  for i in range(1,dof+1):  
    robot_joints.append(robot_name + '_joint_' + str(i))
  for i in range(1,fingers+1):  
    finger_joints.append(robot_name + '_joint_finger_' + str(i))
  joint_state_controller = {'joint_state_controller':{'type':'joint_state_controller/JointStateController', 'publish_rate' : 50}}
  robot_controllers = joint_state_controller
  joints =[]
  gains = {}
  constraints = {}
  i = 0
  for joint in robot_joints:  
    joints.append(joint)
    gains.update({joint:
                           {'p': joint_p[i], 'i': joint_i[i], 'd': joint_d[i], 'i_

                        })    
    constraints.update({joint:
                         {
                          'trajectory':0.05,
                          'goal': 0.02
                         }
                       })
    i = i + 1
  joints = {'joints': joints}
  gains = {'gains': gains}
  constraints_dic = {  'goal_time': 1.0,
                         'stopped_velocity_tolerance': 0.02}                   			              
  constraints_dic.update(constraints)              
  constraints_dic = {'constraints': constraints_dic}
  robot_trajectory_position_controller = {'type':'effort_controllers/JointTrajectoryController'}
  robot_trajectory_position_controller.update(joints)
  robot_trajectory_position_controller.update(gains)
  robot_trajectory_position_controller.update(constraints_dic)
  robot_trajectory_position_controller_dic = {'effort_joint_trajectory_controller': 
                                               robot_trajectory_position_controller}
  robot_controllers.up

  joints =[]
  gains = {}
  constraints = {}
  i=0
  for joint in finger_joints:  
    joints.append(joint)
    gains.update({joint:
                           {'p': finger_p[i], 'i': finger_i[i], 'd': finger_d[i], 'i_clamp': 1}
                        })    
    constraints.update({joint:
                         {
                          'trajectory':0.05,
                          'goal': 0.02
                         }
                       })
    i = i + 1
  joints = {'joints': joints}
  gains = {'gains': gains}
  constraints_dic = {  'goal_time': 1.0,
                         'stopped_velocity_tolerance': 0.02}                   			              
  constraints_dic.update(constraints)              
  constraints_dic = {'constraints': constraints_dic}
  robot_trajectory_position_controller = {'type':'effort_controllers/JointTrajectoryController'}
  robot_trajectory_position_controller.update(joints)
  robot_trajectory_position_controller.update(gains)
  robot_trajectory_positio
def delete(serial_number, controller_ip):
    res = None
    if get_controller(serial_number, controller_ip):
        res = controllers_dao.delete_controller(serial_number, controller_ip)
    return res
def insert(controller):
    res = None
    if installationHandler.get(controller.get('installation')):
        if not controllers_dao.get_controller(controller.get('ip'), controller.get('installation')):
            res = controllers_dao.create_controller(controller)
    return res
def update(controller):
    res = False
    if get_controller(controller.get('installation'), controller.get('ip')):
        res = controllers_dao.update_controller(controller)
    return res
def get_controller(serial_number, controller_ip, internal=False):
    res = None
    if installationHandler.get(serial_number, internal):
        res = controllers_dao.get_controller(controller_ip, serial_number)
    return res
def get_controllers(serial_number):
    res = None
    if installationHandler.get(serial_numbe
freebayes_repository_name = 'freebayes_0040'
freebayes_repository_description = "Galaxy's freebayes tool"
freebayes_repository_long_description = "Long description of Galaxy's freebayes tool"
filtering_repository_name = 'filtering_0040'
filtering_repository_description = "Galaxy's filtering tool"
filtering_repository_long_description = "Long description of Galaxy's filtering tool"
class TestRepositoryCircularDependencies( ShedTwillTestCase ):
    '''Verify that the code correctly displays repositories with circular repository dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = test_db_util.get_private_role

        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
    def test_0005_create_category( self ):
        """Create a category for this test suite"""
        self.create_category( name='test_0040_repository_circular_dependencies', description='Testing handling of circular repository dependencies.' )
    def test_0010_create_freebayes_repository( self ):
        '''Create and populate freebayes_0040.'''
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=freebayes_repository_name, 
                                                    description=freebayes_repository_description, 


                                                    owner=common.test_user_1_name,
                                                    categories=[ 'test_0040_repository_circular_dependencies' ], 
                                                    strings_displayed=[] )
        self.upload_file( repository, 
                          'freebayes/freebayes.tar', 
                          strings_displayed=[], 
                          commit_message='Uploaded freebayes.tar.' )
    def test_0015_create_filtering_repository( self ):
        '''Create and populate filtering_0040.'''
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=filtering_repository_name, 
                                                    description=filtering_repository_description, 
                                                    long_description=filtering_repository_long_description, 
         
class ZohoProjects:
    """This class is used to create an object for projects service and to provide instance for all APIs."""
    def __init__(self, authtoken, portal_id=None):
        """Initialize parameters for zoho projects.
        Args:
            authtoken(str): User's Authtoken.
            portal_name(str): User's portal name.
        """
        self.authtoken = authtoken
        self.portal_id = portal_id
    def get_portals_api(self):
        """Get instance for portals api.
        Returns:
            instance: Portals api instance.
    
        """
        portals_api = PortalsApi(self.authtoken)
        return portals_api
    def get_projects_api(self):
        """Get instance for projects api.
        Returns:
            instance: Projects api instance.
        """
        projects_api = ProjectsApi(self.authtoken, self.portal_id)
        return projects_api
    def get_dashboard_api(self):
        """Get instance for dashboard api.
        Returns:
            ins

      
        """
        dashboard_api = DashboardApi(self.authtoken, self.portal_id)
        return dashboard_api
  
    def get_milestone_api(self):
        """Get instance for milestone api.
        Returns:
            instance: Milestone api instance.
        """
        milestone_api = MilestonesApi(self.authtoken, self.portal_id)
        return milestone_api
    def get_tasklist_api(self):
        """Get instance for tasklist api.
        Returns:
            instance: Tasklist api instance.
        """
        tasklist_api = TaskListApi(self.authtoken, self.portal_id)
        return tasklist_api
    def get_tasks_api(self):
        """Get instance for tasks api.
        Returns:
            instance: Tasks api instance.
        """
        tasks_api = TasksApi(self.authtoken, self.portal_id)
        return tasks_api
    def get_timesheets_api(self):
        """Get instance for timesheets api.
        Returns:
            instance: Timesheets api.
        """
        timeshee

        return timesheets_api
    def get_bugs_api(self):
        """Get instance for bugs api.
        Returns:
            instance: Bugs api.
        """
        bugs_api = BugsApi(self.authtoken, self.portal_id)
        return bugs_api
  
    def get_events_api(self):
        """Get instance for events api.
        Returns:
            instance: Events api.
        """
        events_api = EventsApi(self.authtoken, self.portal_id) 
        return events_api
    def get_documents_api(self):
        """Get instance for Documents api.
        Returns:
            instance: Documents api.
        """
        documents_api = DocumentsApi(self.authtoken, self.portal_id)
        return documents_api
    def get_folders_api(self):
        """Get instance for folders api.
        Returns: 
            instance: Folders api.
        """
        folders_api = FoldersApi(self.authtoken, self.portal_id)
        return folders_api
    def get_forums_api(self):
        """Get instance for forums
datatypes_repository_name = 'emboss_datatypes_0020'
datatypes_repository_description = "Galaxy applicable data formats used by Emboss tools."
datatypes_repository_long_description = "Galaxy applicable data formats used by Emboss tools.  This repository contains no tools."
emboss_repository_name = 'emboss_0020'
emboss_repository_description = 'Galaxy wrappers for Emboss version 5.0.0 tools for test 0020'
emboss_repository_long_description = 'Galaxy wrappers for Emboss version 5.0.0 tools for test 0020'
base_datatypes_count = 0
repository_datatypes_count = 0
class ToolWithRepositoryDependencies( ShedTwillTestCase ):
    '''Test installing a repository with repository dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not N

        self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = self.test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_galaxy_private_role( galaxy_admin_user )
    def test_0005_ensure_repositories_and_categories_exist( self ):
        '''Create the 0020 category and any missing repositories.'''
        global repository_datatypes_count
        category = se

        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        datatypes_repository = self.get_or_create_repository( name=datatypes_repository_name,
                                                              description=datatypes_repository_description,
                                                              long_description=datatypes_repository_long_description,
                                                              owner=common.test_user_1_name,
                                                              category_id=self.security.encode_id( category.id ),
                                                              strings_displayed=[] )
        if self.repository_is_new( datatypes_repository ):
            self.upload_file( datatypes_repository,
                              filename='emboss/datatypes/datatypes_conf.xml',
                              filepath=None,
                              valid_tools_on
try:
    QPIDTOOLLIBS_AVAILABLE = True
except ImportError:
    QPIDTOOLLIBS_AVAILABLE = False
try:
    QPID_MESSAGING_AVAILABLE = True
except ImportError:
    QPID_MESSAGING_AVAILABLE = False
TROUBLESHOOTING_URL = 'http://pulp-user-guide.readthedocs.org/en/2.4-release/troubleshooting.html%s'
logger = logging.getLogger(__name__)
def migrate(*args, **kwargs):
    """
    Migrate qpid queues:
    - Ensure pulp.task is no longer *exclusive*.
    - Rename agent queues: consumer_id> => pulp.agent.<consumer_id>
    """
    transport = pulp_conf.get('messaging', 'transport')
    if transport != 'qpid':
        return
    if not QPID_MESSAGING_AVAILABLE:
        msg = _('Migration 0009 did not run because the python package qpid.messaging is not '
                'installed. Please install qpid.messaging and rerun the migrations. See %s'
                'for more information.')
        msg = msg % QPID_MESSAGING_URL
        logger.error(msg)
        raise Exception(msg)
    if not QPIDTOOLLIBS_

        msg = _('Migration 0009 did not run because the python package qpidtoollibs is not '
                'installed. Please install qpidtoollibs and rerun the migrations. See %s for more '
                'information.')
        msg = msg % QPIDTOOLLIBS_URL
        logger.error(msg)
        raise Exception(msg)
    url = urlparse(pulp_conf.get('messaging', 'url'))
    connection = Connection(
        host=url.hostname,
        port=url.port,
        transport=url.scheme,
        reconnect=False,
        ssl_certfile=pulp_conf.get('messaging', 'clientcert'),
        ssl_skip_hostname_check=True)
    connection.attach()
    broker = BrokerAgent(connection)
    _migrate_reply_queue(broker)
    _migrate_agent_queues(broker)
    connection.detach()
def _migrate_reply_queue(broker):
    """
    Ensure pulp.task is no longer *exclusive*.
    :param broker: A qpidtools broker.
    :type broker: BrokerAgent
    """
    name = Services.REPLY_QUEUE
    queue = broker.getQueue(name)
    if no

        return
    if queue.values['exclusive'] or queue.values['arguments'].get('exclusive', False):
        _del_queue_catch_queue_in_use_exception(broker, name)
        broker.addQueue(name, durable=True)
def _migrate_agent_queues(broker):
    """
    Rename agent queues: consumer_id> => pulp.agent.<consumer_id>
    :param broker: A qpidtools broker.
    :type broker: BrokerAgent
    """
    _add_agent_queues(broker)
    _del_agent_queues(broker)
def _add_agent_queues(broker):
    """
    Add queues named: pulp.agent.<consumer_id> foreach consumer.
    :param broker: A qpidtools broker.
    :type broker: BrokerAgent
    """
    collection = Consumer.get_collection()
    for consumer in collection.find():
        name = 'pulp.agent.%s' % consumer['id']
        queue = broker.getQueue(name)
        if queue:
            continue
        broker.addQueue(name, durable=True)
def _del_agent_queues(broker):
    """
    Delete queues named: <consumer_id> foreach consumer.
    :param broker
class TestRepository(unittest.TestCase):
    def setUp(self):
        self.root = tempfile.mkdtemp()
        self.repository = Repository(self.root)
    def tearDown(self):
        shutil.rmtree(self.root)
    def test_should_get_vcs_dir(self):
        self.assertEqual(
            self.repository.get_vcs_dir(),
            join(self.root, '.myvcs')
        )
    def test_should_get_log_path(self):
        self.assertEqual(
            self.repository.get_log_path(),
            join(self.root, '.myvcs', '.log.json')
        )
    def test_should_write_log(self):
        data = {
            '1': {
                'timestamp': 123412.12,
                'message': 'Dummy commit'
            }
        }
        self.repository.write_log(data)
        with open(self.repository.get_log_path()) as f:
            saved_data = json.load(f)
        self.assertDictEqual(data, saved_data)
    def test_should_read_log(self):
        data = {
            '1': {
                'timestamp': 123412
class Adventure(object):
    def __init__(self, pages=None, choices=None, start_page=None, 
            save_file=None):
        """docstring for __init__"""
        self._start_page = start_page
        if pages == None:
            self._pages = []
        else:
            self._pages = pages
        if choices == None:
            self._choices = []
        else:
            self._choices = choices
        if save_file == None and self.get_start_page() != None:
                self._save_file = "./" + self.get_start_page().get_text()
        else:
            self._save_file = save_file
    def get_start_page(self):
        """Return the start page."""
        return(self._start_page)
    def get_save_file_name(self):
        """Return the file name for saved Adventure object."""
        return(self._save_file)
    def write(self):
        """Write the Adventure to a file."""
        output = open(self.get_save_file_name(), 'wb')
        if self.get_save_file_name():
            pi
LTfis = Corso.objects.get(titolo="LT-Fisica")
insegnamento = Insegnamento(titolo="Analisi dei dati meteoclimatici", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Analisi matematica", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Chimica", corso=LTfis)
insegnamento.save()	
insegnamento = Insegnamento(titolo="Complementi di analisi matematica", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Fisica dell'atmosfera", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Fisica dello stato solido", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Fisica generale I", corso=LTfis)
insegnamento.save()	
insegnamento = Insegnamento(titolo="Fisica generale II", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Fisica generale III", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Fondamenti di programmazione e calcolo numerico", corso=LTfis)
insegnamento.sav

insegnamento = Insegnamento(titolo="Geometria", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Informatica di base e applicazioni scientifiche", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Istituzioni di struttura della materia", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Laboratorio di fisica I", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Laboratorio di fisica II", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Inglese", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Meccanica analitica", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Meccanica quantistica", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Metodi matematici per la fisica", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Spettroscopia", corso=LTfis)
insegnamento.save()
insegnamento = Insegnamento(titolo="Termodinami
__author__ = 'xbfool'
urls = (
    '/echo',                      'app.controller.echo_test',
    '/user/add',                  'app.controller.user_add',
    '/user/friends/add',          'app.controller.friend_add',    
    '/video/(\d+)',               'app.controller.video',
    '/video/add',                 'app.controller.video_add',
    '/fileupload',                'app.controller.file_upload',
    '/video/list/username/(.*)',  'app.controller.video_list',
    '/user/following/(.*)',       'app.controller.user_following',
    '/user/follower/(.*)',        'app.controller.user_follower',
    '/user/video/like/(.*)',      'app.controller.user_likevideos',
    '/video/user/like/(.*)',      'app.controller.video_likeby_users',
    '/video/comment/(.*)',        'app.controller.video_comment',
    '/allvideo/(.*)',             'app.controller.all_video',
    '/user/headimage',            'app.controller.upload_headimage',
    '/video/like',                'app.controller.like_video',

column_repository_name = 'column_maker_0080'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0080'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0080 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryCircularDependencies( ShedTwillTestCase ):
    '''Verify that the code correctly handles circular dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_r

        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
    def test_0005_initiate_category_repositories( self ):
        """Create a category for this test suite and add repositories to it."""
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name, 
                                                    description=column_repository_description, 
                                                    long_description=column_repository_long_description, 
                 

                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        self.upload_file( repository, 
                          'column_maker/column_maker.tar', 
                          strings_displayed=[], 
                          commit_message='Uploaded column_maker.tar.' )
        repository = self.get_or_create_repository( name=convert_repository_name, 
                                                    description=convert_repository_description, 
                                                    long_description=convert_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        self.upload_file( repository, 
          
class TestServicesRepository(unittest.TestCase):
    def test_no_config_file(self):
        service_repository = repository.ServicesRepository()
        service_repository.load()
        self.assertIsInstance(service_repository['mail'], services.Mail)
        self.assertEqual(service_repository['mail'].host, "127.0.0.1")
        self.assertEqual(service_repository['mail'].port, 25)
        self.assertEqual(service_repository['mail'].timeout, 120.0)
        self.assertIsInstance(service_repository['database'], services.Database)
        self.assertEqual(service_repository['database'].host, "localhost")
        self.assertEqual(service_repository['database'].port, 3306)
        self.assertFalse(service_repository['database'].debug)
        self.assertIsInstance(service_repository['manager'], services.Manager)
        self.assertEqual(service_repository['manager'].db, service_repository['database'])
        self.assertEqual(service_repository['manager'].mail, service_repository['mail'])
 

        service_repository = repository.ServicesRepository()
        service_repository.load(None, {'services': {'mail': {'host': 'smtp.local'}}})
        self.assertIsInstance(service_repository['mail'], services.Mail)
        self.assertEqual(service_repository['mail'].host, 'smtp.local')
        self.assertEqual(service_repository['mail'].port, 25)
        self.assertEqual(service_repository['mail'].timeout, 120.0)
        self.assertIsInstance(service_repository['database'], services.Database)
        self.assertEqual(service_repository['database'].host, "localhost")
        self.assertEqual(service_repository['database'].port, 3306)
        self.assertFalse(service_repository['database'].debug)
        self.assertIsInstance(service_repository['manager'], services.Manager)
        self.assertEqual(service_repository['manager'].db, service_repository['database'])
        self.assertEqual(service_repository['manager'].mail, service_repository['mail'])
    def test_with_config_file(s

        service_repository = repository.ServicesRepository()
        service_repository.load(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'config.ini'))
        self.assertIsInstance(service_repository['mail'], services.Mail)
        self.assertEqual(service_repository['mail'].host, "8.8.8.8")
        self.assertEqual(service_repository['mail'].port, 52)
        self.assertEqual(service_repository['mail'].timeout, 300.0)
        self.assertIsInstance(service_repository['database'], services.Database)
        self.assertEqual(service_repository['database'].host, "database.local")
        self.assertEqual(service_repository['database'].port, 5432)
        self.assertTrue(service_repository['database'].debug)
        self.assertIsInstance(service_repository['manager'], services.Manager)
        self.assertEqual(service_repository['manager'].db, service_repository['database'])
        self.assertEqual(service_repository['manager'].mail, service_repository['mail'])
    def tes
dispatch = sql.SQLNotifyBootstrap('mail', 'evilserve', 'SJG')
maindb = dispatch
dbmanage = sql.SQLManage()
result = dispatch.Query("""SELECT DISTINCT on (server_id) server_id, username,
                           password, database, concat_hosts_func(dns_resources.name,
                           dns_zones.origin) FROM server_db_logins, servers,
                           server_types, dns_resources, dns_zones WHERE
                           server_db_logins.server_id=servers.id AND
                           servers.server_type_id=server_types.id AND
                           server_types.type='mail'""")
for i in result:
    dbmanage.Add(i[0], i[3], i[1], i[2], i[4])
sdl = db.server_db_logins(maindb, dbmanage)
usq = db.user_server_quota(maindb, dbmanage)
sc = db.server_config(maindb, dbmanage)
u = db.users(maindb, dbmanage)
dz = db.dns_zones(maindb, dbmanage)
dr = db.dns_resources(maindb, dbmanage)
mu = db.mail_users(maindb, dbmanage)
ma = db.mail_aliases(maindb, dbmanage)
dispatch.
"""Standard management interface support
$Id: Management.py 40222 2005-11-18 15:46:28Z andreasjung $
"""
class Tabs(ExtensionClass.Base):
    """Mix-in provides management folder tab support."""
    manage_tabs__roles__=('Anonymous',)
    manage_tabs=DTMLFile('dtml/manage_tabs', globals())
    manage_options  =()
    filtered_manage_options__roles__=None
    def filtered_manage_options(self, REQUEST=None):
        validate=getSecurityManager().validate
        result=[]
        try:
            options=tuple(self.manage_options)
        except TypeError:
            options=tuple(self.manage_options())
        for d in options:
            filter=d.get('filter', None)
            if filter is not None and not filter(self):
                continue
            path=d.get('path', None)
            if path is None:
                    path=d['action']
            o=self.restrictedTraverse(path, None)
            if o is None:
                continue
            result.append(d)
        r

    manage_workspace__roles__=('Authenticated',)
    def manage_workspace(self, REQUEST):
        """Dispatch to first interface in manage_options
        """
        options=self.filtered_manage_options(REQUEST)
        try:
            m=options[0]['action']
            if m=='manage_workspace':
                    raise TypeError
        except (IndexError, KeyError):
            raise Unauthorized, (
                'You are not authorized to view this object.')
        if m.find('/'):
            raise Redirect, (
                "%s/%s" % (REQUEST['URL1'], m))
        return getattr(self, m)(self, REQUEST)
    def tabs_path_default(self, REQUEST,
                          unquote=urllib.unquote,
                          ):
        steps = REQUEST._steps[:-1]
        script = REQUEST['BASEPATH1']
        linkpat = '<a href="%s/manage_workspace">%s</a>'
        out = []
        url = linkpat % (escape(script, 1), '&nbsp;/')
        if not steps:
            return url
        las

        for step in steps:
            script = '%s/%s' % (script, step)
            out.append(linkpat % (escape(script, 1), escape(unquote(step))))
        script = '%s/%s' % (script, last)
        out.append('<a class="strong-link" href="%s/manage_workspace">%s</a>'%
                   (escape(script, 1), escape(unquote(last))))
        return '%s%s' % (url, '/'.join(out))
    def tabs_path_info(self, script, path,
                       quote=urllib.quote,
                       ):
        out=[]
        while path[:1]=='/':
            path = path[1:]
        while path[-1:]=='/':
            path = path[:-1]
        while script[:1]=='/':
            script = script[1:]
        while script[-1:]=='/':
            script = script[:-1]
        path=path.split('/')[:-1]
        if script:
            path = [script] + path
        if not path:
            return ''
        script=''
        last=path[-1]
        del path[-1]
        for p in path:
            script="%s/%s" % (scri
"""
@author Jerome Monceaux
Aldebaran Robotics (c) 2007 All Rights Reserved - This file is confidential.
To use this file soapPy is required
Version : $Id$
"""
class ALError(Exception):
    """Class for ALLib related errors."""
    def __init__ (self, who, mess, detail):
        "Creates an exception."
        self.who =who
        self.mess = mess
        self.detail = detail
        Exception.__init__(self, self.who, self.mess, self.detail)
    def __str__(self):
        "Calculates the string representation."
        s = '\n\ALError from %s : %s\n Detail: %s\n' % (self.who, self.mess, self.detail)
        return s
    __repr__ = __str__
class ALModuleInfo():
    """structure containing module information"""
    def __init__(self):
        self.processId = -1
        self.name = "no name"
        self.ip = -1
        self.port = -1
        self.modulePointer = -1
        self.architecture = -1
        self.isABroker = 1
class ALModule():
    """generic class used to define a module""

    def __init__(self):
        """docstring for %s"""
        pass
    def execute( self, methodName, param ):
        return
    def getMethodList( self):
        return
    def getMethodHelp( self, methodName ):
        return
    def moduleHelp( self ):
        return
    def dataChanged( self, dataName, value, message ):
        return
    def version( self ):
        return
    def getName( self ):
        return
    def setParentBroker( self, albroker ):
        return
    def getModuleInfo( self ):
        return
    def bindMethod( self ):
        return
    def setModuleDescription( self ):
        return
class ALBroker(threading.Thread):
    """ALBroker create a soap server. It expose soap methods to communicate with python modules."""
    def __init__(self, name, parentIP = "127.0.0.1", parentPort=9559, brokerIP="127.0.0.1", brokerPort=0):
        if brokerPort == 0:
            raise ALError("ALBoker Python", "no port defined", "A port number must be specify to launch the

        self.name = name
        self.ip = brokerIP
        self.port = brokerPort
        self.parentIP = parentIP
        self.parentPort = parentPort
        endpoint = parentIP + ":" + str(parentPort)
        print "endpoint of the broker : " + endpoint
        parentBroker = SOAPpy.SOAPProxy(endpoint)
        self.brokerInfo = ALModuleInfo()
        self.brokerInfo.processId = -1
        self.brokerInfo.name = self.name
        self.brokerInfo.ip = self.ip
        self.brokerInfo.port = self.port
        self.brokerInfo.modulePointer = 0
        self.brokerInfo.architecture = 3
        self.brokerInfo.isABroker = 1
        print "register Broker"
        parentBroker._ns("urn:albroker").registerBroker(self.brokerInfo, 1)
        threading.Thread.__init__ ( self )
    def callNaoqi( self, moduleName, methodName, param ): return
    def pCallNaoqi( self, moduleName, methodName ): return
    def getModuleByName( self, moduleName ):
        return
    def exploreToGetModuleByName( se
PROJECT_ROOT = os.path.dirname(__file__)
def manage(command='help'):
    local("python src/{{ project_name }}/manage.py %s" % command)
def run():
    manage('runserver 0.0.0.0:8000')
def runplus():
    manage('runserver_plus 0.0.0.0:8000')
def shell():
    manage('shell_plus')
def syncdb(options='--migrate'):
    manage('syncdb %s' % options)
def migration(app, options='--auto'):
    manage('schemamigration %s %s' % (app, options))
def migrate(options=''):
    manage('migrate %s' % options)
def buildstatic():
    manage('collectstatic -v0 --noinput')
def test(options='', settings='baseapp.settings.test'):
    manage('test %s --settings=%s' % (options, settings))
def thumbor():
    local('thumbor --conf=develop/conf/thumbor.conf --port=8001')
def less():
    main_less = os.path.join(PROJECT_ROOT, 'src', '{{ project_name }}',
                             'baseapp', 'static', 'less', 'main.less')
    local('python develop/bin/watchless.py %s' % main_less)
def clear_pyc():
    local('find 
m = me.MaybeError
l = combinators.ConsList
def good(rest, state, result):
    return m.pure({'rest': rest, 'state': state, 'result': result})
def bad(message, position):
    return m.error({'message': message, 'position': position})
def run(parser, i):
    return combinators.run(parser, i, 1)
def node(name, count, **kwargs):
    kwargs['_name'] = name
    kwargs['_state'] = count
    return kwargs
loop = token('reserved', (1,1), keyword='loop')
stop = token('reserved', (2,2), keyword='stop')
save_c = token('reserved', (3,3), keyword='save close')
save_o = token('reserved', (4,4), keyword='save open', value='hi')
data_o = token('reserved', (5,5), keyword='data open', value='bye')
id1 = token('identifier', (6,6), value='matt')
id2 = token('identifier', (7,7), value='dog')
val1 = token('value', (8,8), value='hihi')
val2 = token('value', (9,9), value='blar')
class TestCombinations(u.TestCase):
    def testLoop(self):
        inp = [loop, id1, id2, val1, val2, stop]
        output = good(l(

                      node('loop', 1, open=loop, close=stop, keys=[id1, id2], values=[val1, val2]))
        self.assertEqual(run(p.loop, inp), output)
    def testDatum(self):
        inp = [id2, val1, save_c]
        output = good(l([save_c]), 3, 
                      node('datum', 1, key=id2, value=val1))
        self.assertEqual(run(p.datum, inp), output)
    
    def testSaveBasic(self):
        inp = [save_o, save_c, stop]
        output = good(l([stop]), 3,
                      node('save',
                           1, 
                           open=save_o,
                           close=save_c,
                           datums=[],
                           loops=[]))
        self.assertEqual(run(p.save, inp), output)
    
    def testSaveComplex(self):
        inp = [save_o, id1, val2, loop, stop, save_c, save_o]
        output = good(l([save_o]), 7, 
                      node('save',
                           1,
                           open=save_o,
              

                           datums=[node('datum', 2, key=id1, value=val2)],
                           loops=[node('loop', 4, open=loop, close=stop, keys=[], values=[])]))
        self.assertEqual(run(p.save, inp), output)
    def testDataBasic(self):
        inp = [data_o, id1]
        output = good(l([id1]), 2,
                      node('data',
                           1,
                           open=data_o,
                           saves=[]))
        self.assertEqual(run(p.data, inp), output)
        
    def testDataComplex(self):
        inp = [data_o, save_o, id1, val1, save_c, save_c]
        output = good(l([save_c]), 6,
                      node('data',
                           1,
                           open=data_o,
                           saves=[node('save',
                                       2, 
                                       open=save_o,
                                       close=save_c,
                                       datums=[node('da
def mock_job_controller(job_controller):
    job_controller.redirect = MagicMock()
    job_controller.url_for = MagicMock()
    job_controller.job_repository = MagicMock()
    job_controller.prompt_for_password = MagicMock()
    job_controller.abort = MagicMock()
    job_controller.user_is_authenticated = MagicMock()
    job_controller.render = MagicMock()
    job_controller.get_job_from_request = MagicMock()
    return job_controller
class TestJobCreation(unittest.TestCase):
    def test_job_with_a_non_active_status_returns_404(self):
        controller = mock_job_controller(JobController(database = None))
        controller.job_repository.find.return_value = Job(id = 1, status = 'pending')
        controller.view(id = 1)
        assert controller.abort.call_args[0][0] == 404
    def test_job_with_an_active_status_does_not_return_404(self):
        controller = mock_job_controller(JobController(database = None))
        controller.job_repository.find.return_value = Job(id = 2, status 

        controller.view(id = 2)
        assert controller.abort.called == False
    def test_job_with_a_non_active_status_can_not_be_previewed_if_incorrect_token_supplied(self):
        controller = mock_job_controller(JobController(database = None))
        controller.job_repository.find.return_value = Job(id = 1, status = 'pending', edit_url = 'banana')
        controller.preview(id = 1, token = 'apple')
        assert controller.abort.called == True
    def test_job_with_a_non_active_status_can_be_previewed_if_correct_token_supplied(self):
        controller = mock_job_controller(JobController(database = None))
        controller.job_repository.find.return_value = Job(id = 1, status = 'pending', edit_url = 's3cR3t')
        controller.preview(id = 1, token = 's3cR3t')
        assert controller.abort.called == False
    def test_job_is_saved_when_user_is_authenticated(self):
        controller = mock_job_controller(JobController(database = None))
        controller.user_is_authentic
movie_repository = movie_repository.movie_repository()
movie_validator = movie_validator.movie_validator()
client_repository = client_repository.client_repository()
client_validator = client_validator.client_validator()
rent_repository = rent_repository.rent_repository()
rent_validator = rent_validator.rent_validator()
clients_file = client_file("clients.txt", client_repository)
movies_file = movie_file("movies.txt", movie_repository)
rents_file = rent_file("rents.txt", rent_repository)
client_l = clients_file.loadFromFile()
movie_l = movies_file.loadFromFile()
rent_l = rents_file.loadFromFile()
movie_controller = movie_controller.movie_controller(movie_repository, movie_validator)
client_controller = client_controller.client_controller(client_repository, client_validator)
rent_controller = rent_controller.rent_controller(rent_repository, rent_validator, movie_repository, client_repository)
ui = UI(client_controller, movie_controller, rent_controller, clients_file, movies_file, rents_f
if __name__ == "__main__":
    dev_appserver.fix_sys_path()
class SummaryGenerator():
    def __init__(self):
        self._sharkAttackRepository = SharkAttackRepository()
        self._countryRepository = CountryRepository()
        self._areaRepository = AreaRepository()
    def generateCountrySummaries(self):
        for country in self._countryRepository.getCountries():
            attacksForCountry = self._sharkAttackRepository.getDescendantAttacksForCountry(country.urlPart)
            ps = PlaceSummary(attacksForCountry)
            self._countryRepository.updatePlaceSummary(country, ps)
            message = "Generated place summary for %s.\n%s\n" % (country.name, ps)
            logging.info(message)
            yield message
class GenerateSummaries(webapp2.RequestHandler):
    def __init__(self, request, response):
        self.initialize(request, response)
        self._sg = SummaryGenerator()
    def get(self):
        for message in self._sg.generateCountrySummaries():
   
def kafkacat(topic,hosts):
    consumer = KafkaConsumer(topic,
                             bootstrap_servers=hosts,
                             group_id='kafkacat')
    for message in consumer:
        print("%s:%d:%d key=%s value=%s" % (message.topic,
                                            message.partition,
                                            message.offset,
                                            message.key,
                                            message.value))
def main():
    parser = OptionParser(usage="usage: %prog [options] ")
    parser.add_option("-b","--broker",
                      action="store",
                      dest="broker",
                      default="localhost:9092",
                      help="Kafka Broker hosts")
    parser.add_option("-t","--topic",
                      action="store",
                      dest="topic",
                      help="listen Kafka topic")
    (options,args) = parser.parse_args()
    kafkacat(options.
                         protocol='fake', share_type='fake', **kwargs):
    fake_share = {
        'export_path': export_path,
        'service_host': service_host,
        'protocol': protocol,
        'share_type': share_type,
    }
    fake_share.update(kwargs)
    return {'share': fake_share}
@ddt.ddt
class ShareManageTest(test.TestCase):
    """Share Manage Test."""
    def setUp(self):
        super(ShareManageTest, self).setUp()
        self.controller = share_manage.ShareManageController()
        self.resource_name = self.controller.resource_name
        self.request = fakes.HTTPRequest.blank('/share/manage',
                                               use_admin_context=True)
        self.context = self.request.environ['manila.context']
        self.mock_policy_check = self.mock_object(
            policy, 'check_policy', mock.Mock(return_value=True))
    @ddt.data({},
              {'shares': {}},
              {'share': get_fake_manage_body('', None, None)})
    def test_

        self.assertRaises(webob.exc.HTTPUnprocessableEntity,
                          self.controller.create,
                          self.request,
                          body)
        self.mock_policy_check.assert_called_once_with(
            self.context, self.resource_name, 'manage')
    def test_share_manage_service_not_found(self):
        body = get_fake_manage_body()
        self.mock_object(db_api, 'service_get_by_host_and_topic', mock.Mock(
            side_effect=exception.ServiceNotFound(service_id='fake')))
        self.assertRaises(webob.exc.HTTPNotFound,
                          self.controller.create,
                          self.request,
                          body)
        self.mock_policy_check.assert_called_once_with(
            self.context, self.resource_name, 'manage')
    def test_share_manage_share_type_not_found(self):
        body = get_fake_manage_body()
        self.mock_object(db_api, 'service_get_by_host_and_topic', mock.Mock())
        self

        self.mock_object(db_api, 'share_type_get_by_name', mock.Mock(
            side_effect=exception.ShareTypeNotFoundByName(
                share_type_name='fake')))
        self.assertRaises(webob.exc.HTTPNotFound,
                          self.controller.create,
                          self.request,
                          body)
        self.mock_policy_check.assert_called_once_with(
            self.context, self.resource_name, 'manage')
    def _setup_manage_mocks(self, service_is_up=True):
        self.mock_object(db_api, 'service_get_by_host_and_topic', mock.Mock(
            return_value={'host': 'fake'}))
        self.mock_object(share_types, 'get_share_type_by_name_or_id',
                         mock.Mock(return_value={'id': 'fake'}))
        self.mock_object(utils, 'service_is_up', mock.Mock(
            return_value=service_is_up))
              {'service_is_up': True, 'service_host': 'fake@host'})
    def test_share_manage_bad_request(self, settings):
        b
"""Run acid test against latest repositories on Github."""
TMP_DIR = os.path.join(os.path.abspath(os.path.dirname(__file__)),
                       'github_tmp')
def latest_repositories():
    """Return names of latest released repositories on Github."""
    try:
        for result in requests.get('https://github.com/timeline.json').json():
            try:
                repository = result['repository']
                size = repository['size']
                if 0 < size < 1000 and repository['language'] == 'Python':
                    yield repository['url']
            except KeyError:
                continue
    except (requests.exceptions.RequestException, ValueError):
        pass
def download_repository(name, output_directory):
    """Download repository to output_directory.
    Raise CalledProcessError on failure.
    """
    subprocess.check_call(['git', 'clone', name],
                          cwd=output_directory)
def interesting(repository_path):
    """Return True i

    print(repository_path)
    process = subprocess.Popen(['git', 'log'],
                               cwd=repository_path,
                               stdout=subprocess.PIPE)
    try:
        return len(re.findall(
            'pep8',
            process.communicate()[0].decode('utf-8'))) > 2
    except UnicodeDecodeError:
        return False
def complete(repository):
    """Fill in missing paths of URL."""
    if ':' in repository:
        return repository
    else:
        assert '/' in repository
        return 'https://github.com/' + repository.strip()
def main():
    """Run main."""
    try:
        os.mkdir(TMP_DIR)
    except OSError:
        pass
    args = acid.process_args()
    if args.paths:
        names = [complete(a) for a in args.paths]
    else:
        names = None
    checked_repositories = []
    skipped_repositories = []
    interesting_repositories = []
    while True:
        if args.paths:
            if not names:
                break
        else:
  

                names = [p for p in latest_repositories()
                         if p not in checked_repositories and
                         p not in skipped_repositories]
                if not names:
                    time.sleep(1)
        repository_name = names.pop(0)
        print(repository_name)
        user_tmp_dir = os.path.join(
            TMP_DIR,
            os.path.basename(os.path.split(repository_name)[0]))
        try:
            os.mkdir(user_tmp_dir)
        except OSError:
            pass
        repository_tmp_dir = os.path.join(
            user_tmp_dir,
            os.path.basename(repository_name))
        try:
            os.mkdir(repository_tmp_dir)
        except OSError:
            print('Skipping already checked repository')
            skipped_repositories.append(repository_name)
            continue
        try:
            download_repository(repository_name,
                                output_directory=repository_tmp_dir)
        except su
"""Tests for go.api.go_api.utils."""
class TestGoApiError(VumiTestCase):
    def test_go_api_error(self):
        err = GoApiError("Testing")
        self.assertEqual(err.faultString, "Testing")
        self.assertEqual(err.faultCode, 400)
    def test_go_api_error_with_fault_code(self):
        err = GoApiError("Other", fault_code=314)
        self.assertEqual(err.faultString, "Other")
        self.assertEqual(err.faultCode, 314)
class TestGoApiSubHandler(VumiTestCase):
    def setUp(self):
        self.account = Mock(key=u"account-1")
        self.user_api = Mock()
        self.vumi_api = Mock(
            get_user_api=Mock(return_value=self.user_api),
        )
    def test_create(self):
        sub = GoApiSubHandler(self.account.key, self.vumi_api)
        self.assertEqual(sub.user_account_key, self.account.key)
        self.assertEqual(sub.vumi_api, self.vumi_api)
    def test_get_user_api(self):
        sub = GoApiSubHandler(self.account.key, self.vumi_api)
        user_api = sub
                                    dummy_repository_package_factory,
                                    repository_factory)
class TestSolverNoDependencies(unittest.TestCase):
    def setUp(self):
        self.prefix = tempfile.mkdtemp()
    def tearDown(self):
        shutil.rmtree(self.prefix)
    def test_install_simple(self):
        entries = [
            dummy_repository_package_factory("numpy", "1.6.1", 1),
            dummy_repository_package_factory("numpy", "1.8.0", 2),
            dummy_repository_package_factory("numpy", "1.7.1", 2),
        ]
        r_actions = [
            ('install', 'numpy-1.8.0-2.egg')
        ]
        repository = repository_factory(entries)
        installed_repository = Repository._from_prefixes([self.prefix])
        solver = Solver(repository, installed_repository)
        request = Request()
        request.install(Requirement("numpy"))
        actions = solver.resolve(request)
        self.assertEqual(actions, r_actions)
    def test_instal

        entries = [
            dummy_repository_package_factory("numpy", "1.6.1", 1),
            dummy_repository_package_factory("numpy", "1.8.0", 2),
        ]
        repository = repository_factory(entries)
        installed_repository = Repository._from_prefixes([self.prefix])
        solver = Solver(repository, installed_repository)
        request = Request()
        request.install(Requirement("scipy"))
        with self.assertRaises(NoPackageFound):
            solver.resolve(request)
    def test_install_missing_dependency(self):
        entries = [
            dummy_repository_package_factory("numpy", "1.8.0", 2,
                                             dependencies=["MKL 10.3"]),
        ]
        repository = repository_factory(entries)
        installed_repository = Repository._from_prefixes([self.prefix])
        solver = Solver(repository, installed_repository)
        request = Request()
        request.install(Requirement("numpy"))
        with self.assertRaise

            solver.resolve(request)
    def test_remove_actions(self):
        repository = Repository()
        for egg in [DUMMY_EGG]:
            egginst = EggInst(egg, self.prefix)
            egginst.install()
        solver = Solver(repository, Repository._from_prefixes([self.prefix]))
        request = Request()
        request.remove(Requirement("dummy"))
        actions = solver.resolve(request)
        self.assertEqual(actions, [("remove", os.path.basename(DUMMY_EGG))])
    def test_remove_non_existing(self):
        entries = [
            dummy_repository_package_factory("numpy", "1.6.1", 1),
            dummy_repository_package_factory("numpy", "1.8.0", 2),
        ]
        repository = repository_factory(entries)
        solver = Solver(repository, Repository._from_prefixes([self.prefix]))
        request = Request()
        request.remove(Requirement("numpy"))
        with self.assertRaises(EnpkgError):
            solver.resolve(request)
    def test_chained_override_
urlpatterns = patterns('apps.vehicle.views',
       url(r'^(?P<year>\d+)/(?P<make>[-\w]+)/(?P<model>[-\w]+)/(?P<hex_id>[-\w]+)$', 'profile', name='vehicle-profile'),
       url(r'^new/$', 'new', name='vehicle-new'),
       url(r'moderators/approve/$', 'approve', name='vehicle-approve'),
urlpatterns += patterns('',
       url(r'^api/cars(/(?P<id>\d+))?$',   api.CarList.as_view(),    name='car-api'),
       url(r'^api/image$',   api.ImageDetail.as_view(),    name='image-detail-api'),
       url(r'^api/makes$',                                                                              api.MakeList.as_view(), name='make-list-api'),
       url(r'^api/models$',                                                                             api.ModelDetail.as_view(),   name='model-detail-api'),
       url(r'^api/models/(?P<make>[-\w]+)/(?P<model>[-\w]+)/(?P<year>\d+)(/(?P<trim>[-\w]+))?$',        api.ModelDetail.as_view(),   name='model-detail-api'),
       url(r'^api/models/(?P<make>[-\w]+)(/(
class RpiRoot(pb.Referencable)
    def remote_registerPi(self, iden, refs):
        """
        Each pi will call this method first to send identifiers and references to the server
        identity is a dict containing identifiers about the pi:
            hostname: <string> the pi's hostname
            ip: <str> the pi's ip address
        refs is a dict containing remoteReferences to the pi's Referencable objects
            experimentalProtocols:
            camera:
        """
        self.broker.clientName = iden['name']
        self.broker.clientType = iden['clientType']
        self.broker.registerWithFactory()
class RPiServerBroker(pb.Broker):
    """
    I am the broker object used to handle connections and remote function calls with the
    Raspberry Pis.  At the moment, I don't do anything
    """
    clientName = None
    clientType = None
    cameraControls = None
    def registerWithFactory(iden):
        self.factory.connectedBrokers[self.clientName] = self
class RootDi
urlpatterns = patterns('',
    url(r'^/$', 'controller.basic.views.home', name='home'),
    url(r'^/get_port/(?P<port_id>\d+)$', 'controller.basic.views.get_port', name='get_port'),
    url(r'^/get_port_list/(?P<controller_id>\d+)$', 'controller.basic.views.get_port_list', name='get_port_list'),
    url(r'^/get_controller_list/$', 'controller.basic.views.get_controller_list', name='get_controller_list'),
    url(r'^/set_port/(?P<port_id>\d+)/(?P<high>\d+)/(?P<low>\d+)$', 'controller.basic.views.set_port', name='set_port'),
    url(r'^/add_controller/(?P<description>[\w\s]+)/(?P<i2c_bus>\d+)/(?P<i2c_address>\d+)/(?P<frequency>\d+)$', 'controller.basic.views.add_controller', name='add_controller'),
    url(r'^/add_port/(?P<controller_id>\d+)/(?P<port>\d+)/(?P<high>\d+)/(?P<low>\d+)$', 'controller.basic.views.add_port', name='add_port'),
    url(r'^/add_port_dialog$', 'controller.basic.views.add_port_dialog', name='add_port_dialog'),
    url(r'^/remove_controller/(?P<controller_id>\d+)$',
class TestReplicatorSync(test_db_replicator.TestReplicatorSync):
    backend = backend.AccountBroker
    datadir = server.DATADIR
    replicator_daemon = replicator.AccountReplicator
    def test_sync(self):
        broker = self._get_broker('a', node_index=0)
        put_timestamp = normalize_timestamp(time.time())
        broker.initialize(put_timestamp)
        daemon = replicator.AccountReplicator({})
        part, node = self._get_broker_part_node(broker)
        info = broker.get_replication_info()
        success = daemon._repl_to_node(node, broker, part, info)
        self.assertTrue(success)
        self.assertEqual(1, daemon.stats['no_change'])
    def test_sync_remote_missing(self):
        broker = self._get_broker('a', node_index=0)
        put_timestamp = time.time()
        broker.initialize(put_timestamp)
        part, node = self._get_broker_part_node(broker)
        daemon = self._run_once(node)
        self.assertEqual(2, daemon.stats['rsync'])
        local_info = s

            'a', node_index=0).get_info()
        for i in range(1, 3):
            remote_broker = self._get_broker('a', node_index=i)
            self.assertTrue(os.path.exists(remote_broker.db_file))
            remote_info = remote_broker.get_info()
            for k, v in local_info.items():
                if k == 'id':
                    continue
                self.assertEqual(remote_info[k], v,
                                 "mismatch remote %s %r != %r" % (
                                     k, remote_info[k], v))
    def test_sync_remote_missing_most_rows(self):
        put_timestamp = time.time()
        broker = self._get_broker('a', node_index=0)
        broker.initialize(put_timestamp)
        remote_broker = self._get_broker('a', node_index=1)
        remote_broker.initialize(put_timestamp)
        broker.put_container('/a/c', time.time(), 0, 0, 0,
                             POLICIES.default.idx)
        daemon = replicator.AccountReplicator({})
        def _rs

            remote_server, remote_path = remote_file.split('/', 1)
            dest_path = os.path.join(self.root, remote_path)
            shutil.copy(db_file, dest_path)
            return True
        daemon._rsync_file = _rsync_file
        part, node = self._get_broker_part_node(remote_broker)
        info = broker.get_replication_info()
        success = daemon._repl_to_node(node, broker, part, info)
        self.assertTrue(success)
        self.assertEqual(1, daemon.stats['remote_merge'])
        local_info = self._get_broker(
            'a', node_index=0).get_info()
        remote_info = self._get_broker(
            'a', node_index=1).get_info()
        for k, v in local_info.items():
            if k == 'id':
                continue
            self.assertEqual(remote_info[k], v,
                             "mismatch remote %s %r != %r" % (
                                 k, remote_info[k], v))
    def test_sync_remote_missing_one_rows(self):
        put_timestamp = time
basedir = os.path.abspath(os.path.dirname(__file__))
class Config(object):
    SECRET_KEY = os.environ.get('SECRET_KEY') or 't0p s3cr3t'
class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'flower-db-dev.db')
    CELERY_BROKER_URL = os.environ.get('DEV_BROKER_DATABASE_URL') or \
        'redis://localhost:6379/0'
    CELERY_RESULT_BACKEND = os.environ.get('DEV_BROKER_DATABASE_URL') or \
        'redis://localhost:6379/0'
class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'flower-db-test.db')
    CELERY_BROKER_URL = os.environ.get('TEST_BROKER_DATABASE_URL') or \
        'sqla+sqlite:///' + os.path.join(basedir, 'flower-db-test.db')
    CELERY_RESULT_BACKEND = os.environ.get('TEST_BROKER_DATABASE_URL') or \
        'db+sqlite:///' + os.path.join(basedir, 'flower-db
def cleandata(string1, number):
    if str(string1)=="week":
        if number==0:
            for edge in edgedata.objects.all():
                edge.week1=0;
                edge.save();
            for edge in locationtopicdata.objects.all():
                edge.week1=0;
                edge.save();
            for edge in locationtimedata.objects.all():
                edge.week1=0;
                edge.save();
        if number==1:
            for edge in edgedata.objects.all():
                edge.week2=0;
                edge.save();
            for edge in locationtopicdata.objects.all():
                edge.week2=0;
                edge.save();
            for edge in locationtimedata.objects.all():
                edge.week2=0;
                edge.save();
        if number==2:
            for edge in edgedata.objects.all():
                edge.week3=0;
                edge.save();
            for edge in locationtopicdata.objects.all():
                edge.week3=0;
   

            for edge in locationtimedata.objects.all():
                edge.week3=0;
                edge.save();
        if number==3:
            for edge in edgedata.objects.all():
                edge.week4=0;
                edge.save();
            for edge in locationtopicdata.objects.all():
                edge.week4=0;
                edge.save();
            for edge in locationtimedata.objects.all():
                edge.week4=0;
                edge.save();
    if str(string1)=="month":
        if number==0:
            for edge in edgedata.objects.all():
                edge.month1=0;
                edge.save();
            for edge in locationtopicdata.objects.all():
                edge.month1=0;
                edge.save();
            for edge in locationtimedata.objects.all():
                edge.month1=0;
                edge.save();
        if number==1:
            for edge in edgedata.objects.all():
                edge.month2=0;
                edge.save();
 
"""
  This script shows how to create a NaoQi module written in Python
"""
NAO_PORT = 9559
path = `os.environ.get("AL_DIR")`
home = `os.environ.get("HOME")`
if path == "None":
        print "the environnement variable AL_DIR is not set, aborting..."
        sys.exit(1)
else:
        alPath = path + "/extern/python/aldebaran"
        alPath = alPath.replace("~", home)
        alPath = alPath.replace("'", "")
        sys.path.append(alPath)
class MyModulePython(ALModule):
  def printSomething(self,myString ):
    "A method that just print on screen what is sent, and also calls ALLogger"
    
    print "Printing something: " + myString
    try:
      loggerProxy = ALProxy("ALLogger")
      loggerProxy.debug("MyModulePython","printSomething called with:" + myString )
    except:
      print "Unable to create proxy to ALLogger"
ThisBrokerIP = "127.0.0.1"
ThisBrokerPort = BPORT
try:
  pythonBroker = ALBroker("pythonBroker",ThisBrokerIP,ThisBrokerPort, NAO_IP, NAO_PORT)
except RuntimeError,e:
""" Remanes tokens in compiler.ast structures.
"""
def rename(ast, mode, old, new):
    if mode not in ['variable', 'function']:
        raise ValueError("mode '%s' not supported")
    rename_ast = RenameAst(ast, mode, old, new)
    return rename_ast.tree, rename_ast.modifications
class RenameAst:
    """ Methods in this class recursively traverse an AST and
        rename tokens
    """
    def __init__(self, tree, mode, old, new):
        """ Unparser(tree, mode, old, new) -> None.
            For a given mode, renames all occurences of old to new.
            'variable' and 'function' are the only modes currently supported
        """
        self.mode = mode
        self.old = old
        self.new = new
        self.tree = tree
        self.modifications = 0
        self._dispatch(self.tree)
    def _dispatch(self, tree):
        "_dispatcher function, _dispatching tree type T to method _T."
        if isinstance(tree, list):
            for t in tree:
                result.append

            return
        if tree.__class__.__name__ == 'NoneType' and not self._do_indent:
            return
        if tree.__class__.__name__ == 'NoneType' and not self._do_indent:
            return
        if hasattr(self, "_"+tree.__class__.__name__):
            meth = getattr(self, "_"+tree.__class__.__name__)
            meth(tree)
    def _Add(self, t):
        self._dispatch(t.left)
        self._dispatch(t.right)
    def _And(self, t):
        for node in t.nodes:
            self._dispatch(node)
    def _Assign(self, t):
        """ Expression Assignment such as "a = 1".
            This only handles assignment in expressions.  Keyword assignment
            is handled separately.
        """
        for node in t.nodes:
            self._dispatch(node)
        self._dispatch(t.expr)
    def _AssName(self, t):
        """ Name on left hand side of expression.
            Treat just like a name on the right side of an expression.
        """
        if t.name == self.old

            t.name = self.new
            self.modifications += 1
    def _AssTuple(self, t):
        """ Tuple on left hand side of an expression.
        """
        for node in t.nodes:
            self._dispatch(node)
    def _AugAssign(self, t):
        """ +=,-=,*=,/=,**=, etc. operations
        """
        self._dispatch(t.node)
        self._dispatch(t.expr)
    def _Bitand(self, t):
        """ Bit and operation.
        """
        for node in t.nodes:
            self._dispatch(node)
    def _Bitor(self, t):
        """ Bit or operation
        """
        for node in t.nodes:
            self._dispatch(node)
    def _CallFunc(self, t):
        """ Function call.
        """
        if self.mode == "function":
            self._dispatch(t.node)
        for arg in t.args:
            self._dispatch(arg)
    def _Compare(self, t):
        """ Comparison operator.
        """
        self._dispatch(t.expr)
        for op in t.ops:
            self._dispatch(op[1])
    def _Di
admin.autodiscover()
api = Api(api_name="api")
api.register(AdministratorResource())
api.register(GroupResource())
api.register(AssetClassResource())
api.register(AuditorResource())
api.register(BenchComponentResource())
api.register(BrokerResource())
api.register(CounterPartyResource())
api.register(CountryResource())
api.register(CurrencyResource())
api.register(CurrencyRateResource())
api.register(CustodianResource())
api.register(FeeResource())
api.register(BenchPeerResource())
api.register(AlarmResource())
api.register(FundStyleResource())
api.register(GicsCategoryResource())
api.register(HfSectorResource())
api.register(IcbCategoryResource())
api.register(IndustryGroupResource())
api.register(IndustrySectorResource())
api.register(IndustrySubGroupResource())
api.register(IssuerIndustryResource())
api.register(ManagerResource())
api.register(RegionResource())
api.register(ClientValAuditResource())
api.register(FundFeeResource())
api.register(FundFeeAuditResource())
api.register(Fu

api.register(InvestmentCategoryResource())
api.register(FundResource())
api.register(FundReturnDailyResource())
api.register(FundReturnMonthlyResource())
api.register(FundReturnMonthlyResource2())
api.register(FundReturnMonthlyResource3())
api.register(HoldingResource())
api.register(HoldingDailyResource())
api.register(HoldingMonthlyResource())
api.register(HoldingDepositResource())
api.register(HoldingEtfResource())
api.register(HoldingEquityResource())
api.register(HoldingFixedIncomeResource())
api.register(HoldingForwardResource())
api.register(HoldingFutureResource())
api.register(HoldingHedgeFundsResource())
api.register(HoldingMutualFundResource())
api.register(HoldingOptionResource())
api.register(HoldingWarrantResource())
api.register(HoldingPositionDailyResource())
api.register(PositionMonthlyResource())
api.register(TradeResource())
api.register(ClientPositionResource())
api.register(ClientTransactionResource())
"""
api.register(FundReturnMonthlyResource())
api.register(Fun

api.register(FundReturnDailyResource())
api.register(FundsResource())
"""
"""
api.register(HoldingResource())
api.register(HoldingHistoryResource())
api.register(HoldingValuationResource())
api.register(BreakdownResource())
api.register(CountryBreakdownResource())
api.register(CategoryResource())
api.register(TradeResource())
api.register(AlpheusSubscriptionResource())
api.register(ClientResource())
api.register(ClientHistoryResource())
api.register(SubscriptionRedemptionResource())
"""
api.register(InfoResource())
api.register(UserResource())
api.register(WidgetsResource())
api.register(LoggedInResource())
api.register(MenuResource())
api.register(MenuParentItemsResource())
api.register(PageResource(),canonical=True)
api.register(PageWindowResource(),canonical=True)
"""
api.register(BenchmarkResource())
api.register(BenchmarkHistoryResource())
api.register(PeerResource())
api.register(PeerHistoryResource())
"""
urlpatterns = patterns('',
    (r'^robots\.txt$', lambda r: HttpResponse(
def run_netkit_on_single_relation(path, n_runs=10, save_to=None):
    inferencemethod='relaxlabel'
    res_wvrn, pred  = netkit.run(path, classifier='wvrn',
            inferencemethod=inferencemethod, cv_folds=n_runs, verbose=False)
    res_wvrn.columns = ['wvrn_acc', 'wvrn_std', 'ratio']
    res_nlb, pred  = netkit.run(path, classifier='nLB',
            inferencemethod=inferencemethod, cv_folds=n_runs, verbose=False)
    res_nlb.columns = ['nlb_acc', 'nlb_std', 'ratio']
    res_all = pd.merge(res_wvrn, res_nlb, on='ratio')
    if save_to is not None:
        res_all.to_csv('../results/' + save_to + '/netkit.csv', index=False)
def run_single_relation_experiments():
    path = 'citeseer/citeseer'
    save_to = 'citeseer'
    run_netkit_on_single_relation(path, save_to=save_to)
    path = 'cora/cora'
    save_to = 'cora'
    run_netkit_on_single_relation(path, save_to=save_to)
    path = 'imdb_all/imdb_all'
    save_to = 'imdb'
    run_netkit_on_single_relation(path, save_to=save_to)
r
urlpatterns = patterns(
    '',
    url(r'^lattice/$',
        lattices,
        name='lattices'),
    url(r'^lattice/savelatticeinfo/$',
        saveLatticeInfo,
        name='saveLatticeInfo'),
    url(r'^lattice/savelattice$',
        saveLattice,
        name='saveLattice'),
    url(r'^lattice/savemodel$',
        saveModel,
        name='saveModel'),
    url(r'^lattice/web/$',
        lattice_home,
        name='lattice_home'),
    url(r'^lattice/web/index.html$',
        lattice_home,
        name='lattice_home'),
    url(r'^lattice/web/content.html$',
        lattice_content_home,
        name='lattice_content_home'),
    url(r'^lattice/web/search.html$',
        lattice_content_search,
        name='lattice_content_search'),
    url(r'^lattice/web/list.html$',
        lattice_content_list,
        name='lattice_content_list'),
    url(r'^lattice/web/model_list.html$',
        lattice_content_model_list,
        name='lattice_content_model_list'),
    url(r'^lattice/web/details.
    UserAPI,AdminAPI,ClientAPI,AdminManage,
    ClientManage,AdminDashboard,WifisiteAPI,
    WifisiteManage,SiteDashboard,LandingpageAPI,
    LandingpageManage,FileAPI,LandingpagePreview,
    GuestViewAPI,GuestDataManage,
    AccountAPI,AccountManage,NotificationAPI,
    MailOptionsAPI,MailOptionsManage,TestEmail
def media(filename):
    return send_from_directory(current_app.config.get('MEDIA_ROOT'), filename)
def static_from_root():
    return send_from_directory(current_app.static_folder, request.path[1:])
class IndexView(FlaskView):
    decorators = [login_required]
    def index(self):
        if current_user.type =='admin':
            return redirect(url_for('AdminDashboard:index'))
        elif current_user.type =='client':
            return redirect(url_for('AdminDashboard:index'))     
        else:
            current_app.logger.error("Unknown User Type!! for ID:%s"%current_user.id)
            abort(400)
def configure(app):
    IndexView.register(app, route_base='/')
    A

    register_flaskview(app, AdminDashboard)
    UserAPI.register(app, route_base='/user')
    @app.context_processor
    def inject_userform():
        if current_user and current_user.is_authenticated:
            userform = UserForm()
            userform.populate()            
            return dict(userform=userform)
        else:
             return {}            
    @app.context_processor
    def inject_newsiteform():
        if current_user and current_user.is_authenticated:
            newsiteform = get_wifisite_form(baseform=True)
            newsiteform.populate()            
            return dict(newsiteform=newsiteform)
        else:
             return {}
    AdminAPI.register(app, route_base='/admin/')
    ClientAPI.register(app, route_base='/client/')
    AdminManage.register(app, route_base='/a/manage/admin/')
    register_flaskview(app, AdminManage)
    ClientManage.register(app, route_base='/a/manage/client/')
    register_flaskview(app, ClientManage)
    Account

    AccountManage.register(app, route_base='/a/manage/settings/')
    register_flaskview(app, AccountManage)
    MailOptionsAPI.register(app, route_base='/mailoptions/api')
    MailOptionsManage.register(app, route_base='/a/manage/mailoptions/')
    register_flaskview(app, MailOptionsManage)
    TestEmail.register(app, route_base='/testemail/api')
    NotificationAPI.register(app, route_base='/notifications/')
    WifisiteAPI.register(app, route_base='/site/')
    WifisiteManage.register(app, route_base='/s/manage/site/<siteid>')
    register_flaskview(app, WifisiteManage)
    SiteDashboard.register(app, route_base='/s/dashboard/<siteid>')
    register_flaskview(app, SiteDashboard)
    LandingpageAPI.register(app, route_base='/s/manage/landingpage/<siteid>')
    FileAPI.register(app, route_base='/s/upload/file/<siteid>')
    LandingpageManage.register(app, route_base='/s/landing/<siteid>')
    register_flaskview(app, LandingpageManage)
    
    LandingpagePreview.register(app, route_b
urlpatterns = patterns('',
    url(r'^$',
        'django_gitweb.views.repository_list',
        name='gitweb_repository_list'),
    url(r'^(?P<slug>[\w-]+)/$',
        'django_gitweb.views.repository_summary',
        name='gitweb_repository_summary'),
    url(r'^(?P<slug>[\w-]+)/commit/(?P<commit>[\w-]+)/$',
        'django_gitweb.views.repository_commit',
        name='gitweb_repository_commit'),
    url(r'^(?P<slug>[\w-]+)/commit/(?P<commit>[\w-]+)/diff/$',
        'django_gitweb.views.repository_commit', {'template_name': 'gitweb/repository_commit_diff.html'},
        name='gitweb_repository_commit_diff'),
    url(r'^(?P<slug>[\w-]+)/tree/(?P<branch>[\w-]+)/(?P<path>.*)$',
        'django_gitweb.views.repository_tree',
        name='gitweb_repository_tree'),
    url(r'^(?P<slug>[\w-]+)/log/(?P<branch>[\w-]+)/$',
        'django_gitweb.views.repository_log',
        name='gitweb_repository_log'),
    url(r'^(?P<slug>[\w-]+)/log/$',
        'django_gitweb.views.repository_log',
    
''' Core mDS API emitters.
@author: Sana Dev Team
Created on May 20, 2011
'''
class APIResponseEmitter(Emitter):
    """
    Emitter for the Django serialized format.
    """
    def render(self, request, format='xml'):
        if isinstance(self.data, HttpResponse):
            return self.data
        elif isinstance(self.data, (int, str)):
            response = self.data
        else:
            response = serializers.serialize(format, self.data, indent=True)
        return response
class DispatchEmitter(Emitter):
    
    def emit(self, method='GET'):
        if method == 'POST': 
            cleaned_dispatch = self._post_dispatch()
        else:
            cleaned_dispatch = self._get_dispatch()
        return cleaned_dispatch
    
    def _post_dispatch(self):
        self.full_clean()
        if self.is_valid():
            return self.cleaned_data
        else:
            return {}
        
    def _get_dispatch(self):
        cleaned_dispatch = {}
        for field in self
class Manage_StaffPositions_BaseHandler(Manage_BaseHandler):
    pass
class Manage_StaffPositions_Handler(Manage_StaffPositions_BaseHandler):
    def get(self):
        self.generate_manage_bar()
        self.template_vars['existingStaffPositions'] = StaffPosition.gql("ORDER BY DisplayOrder ASC").fetch(50)
        self.template_vars['form'] = self.generate_form(StaffPosition_Form)
        self.render_template("manage/staff_positions/staff_positions.html")
    def post(self):
        def post_process_model(filled_staff_position):
            filled_staff_position.Image = images.resize(filled_staff_position.Image, 147, 123)
            if not filled_staff_position.DisplayOrder:
                displayOrderObject = StaffPosition.gql("ORDER BY DisplayOrder DESC").get()
                if displayOrderObject and displayOrderObject.DisplayOrder:
                    filled_staff_position.DisplayOrder = displayOrderObject.DisplayOrder + 1
                else:
                    filled_staff_p

        filled_staff_position = self.process_form(StaffPosition_Form, StaffPosition, PostProcessing=post_process_model)
        if filled_staff_position:
            self.redirect(self.request.path)
        else:
            self.redirect(self.request.path + '?edit=%s&retry=1' % self.request.get("edit"))
class Manage_StaffPositions_OrderHandler(Manage_StaffPositions_BaseHandler):
    def get(self, direction, displayOrderToMove):
        displayOrderToMove = int(displayOrderToMove)
        FirstObject = StaffPosition.gql("WHERE DisplayOrder = :1", displayOrderToMove).get()
        if direction == 'u':
            SecondObject = StaffPosition.gql("WHERE DisplayOrder < :1 ORDER BY DisplayOrder DESC",
                                              displayOrderToMove).get()
        else:
            SecondObject = StaffPosition.gql("WHERE DisplayOrder > :1 ORDER BY DisplayOrder ASC",
                                              displayOrderToMove).get()
        FirstObject.DisplayOrder, Se
path = "DataBackups"
auth = ["User"]
fitapp = ["UserFitbit", "TimeSeriesDataType", "TimeSeriesData"]
tracktivityPetsWebsite = ["Inventory",
                          "Level",
                          "Scenery",
                          "CollectedScenery",
                          "Pet",
                          "CollectedPet",
                          "BodyPart",
                          "Item",
                          "CollectedItem",
                          "Profile",
                          "Happiness",
                          "Experience",
                          "Mood",
                          "Phrase",
                          "Story",
                          "MicroChallenge",
                          "MicroChallengeMedal",
                          "MicroChallengeState",
                          "UserMicroChallengeState",
                          "UserMicroChallenge",
                          "PetSwap",
                          "MicroChallengeGoal",
   

                          "UserNotification"]
if __name__ == "__main__":
    if sys.argv[1] == "-dump":
        
        for i in auth:
            print("Running command: python manage.py dumpdata auth.{0} --indent 4 --format json > {1}/{0}.json".format(i, path))
            os.system("python manage.py dumpdata auth.{0} --indent 4 --format json > {1}/{0}.json".format(i, path))
        for i in fitapp:
            print("Running command: python manage.py dumpdata fitapp.{0} --indent 4 --format json > {1}/{0}.json".format(i, path))
            os.system("python manage.py dumpdata fitapp.{0} --indent 4 --format json > {1}/{0}.json".format(i, path))
                 
        for i in tracktivityPetsWebsite:
            print("Running command: python manage.py dumpdata tracktivityPetsWebsite.{0} --indent 4 --format json > {1}/{0}.json".format(i, path))
            os.system("python manage.py dumpdata tracktivityPetsWebsite.{0} --indent 4 --format json > {1}/{0}.json".format(i, path))
    
class TestFakeAccountBroker(unittest.TestCase):
    def test_fake_broker_get_info(self):
        broker = utils.FakeAccountBroker()
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            info = broker.get_info()
        timestamp = Timestamp(now)
        expected = {
            'container_count': 0,
            'object_count': 0,
            'bytes_used': 0,
            'created_at': timestamp.internal,
            'put_timestamp': timestamp.internal,
        }
        self.assertEqual(info, expected)
    def test_fake_broker_list_containers_iter(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.list_containers_iter(), [])
    def test_fake_broker_metadata(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.metadata, {})
    def test_fake_broker_get_policy_stats(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.get_policy_stats(), {})
class TestAccountUti

    def test_get_response_headers_fake_broker(self):
        broker = utils.FakeAccountBroker()
        now = time.time()
        expected = {
            'X-Account-Container-Count': 0,
            'X-Account-Object-Count': 0,
            'X-Account-Bytes-Used': 0,
            'X-Timestamp': Timestamp(now).normal,
            'X-PUT-Timestamp': Timestamp(now).normal,
        }
        with mock.patch('time.time', new=lambda: now):
            resp_headers = utils.get_response_headers(broker)
        self.assertEqual(resp_headers, expected)
    def test_get_response_headers_empty_memory_broker(self):
        broker = backend.AccountBroker(':memory:', account='a')
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            broker.initialize(Timestamp(now).internal)
        expected = {
            'X-Account-Container-Count': 0,
            'X-Account-Object-Count': 0,
            'X-Account-Bytes-Used': 0,
            'X-Timestamp': Timestamp(now).norm

            'X-PUT-Timestamp': Timestamp(now).normal,
        }
        resp_headers = utils.get_response_headers(broker)
        self.assertEqual(resp_headers, expected)
    @patch_policies
    def test_get_response_headers_with_data(self):
        broker = backend.AccountBroker(':memory:', account='a')
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            broker.initialize(Timestamp(now).internal)
        ts = (Timestamp(t).internal for t in itertools.count(int(now)))
        total_containers = 0
        total_objects = 0
        total_bytes = 0
        for policy in POLICIES:
            delete_timestamp = ts.next()
            put_timestamp = ts.next()
            object_count = int(policy)
            bytes_used = int(policy) * 10
            broker.put_container('c-%s' % policy.name, put_timestamp,
                                 delete_timestamp, object_count, bytes_used,
                                 int(policy))
            total_con
class RamTests(TestCase):
    def test_create_ram(self):
        ram = RamController(500)
        self.assertEqual(len(ram), 500)
    def test_read_write(self):
        ram = RamController(32)
        ram[0] = 0xFF
        self.assertEqual(ram[0], 0xFF)
class MemoryControllerTests(TestCase):
    def test_register_controller(self):
        ram = RamController(32)
        mem = MemoryController()
        mem.register_controller(ram, 0)
        self.assertIs(mem._memory_map[0].controller, ram)
    def test_get_controller(self):
        ram1 = RamController(32)
        ram2 = RamController(64)
        mem = MemoryController()
        mem.register_controller(ram1, 0)
        mem.register_controller(ram2, 32)
        c = mem._get_controller(15)
        self.assertIs(c.controller, ram1)
        c = mem._get_controller(31)
        self.assertIs(c.controller, ram1)
        c = mem._get_controller(32)
        self.assertIs(c.controller, ram2)
        c = mem._get_controller(95)
        self.asse
urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^media/(?P<path>.*)$', 'django.views.static.serve', {'document_root': settings.MEDIA_ROOT}),
    url(r'^l3admin$', 'back.views.l3admin'),
    url(r'^l3back$', 'back.views.l3back'),
    url(r'^regist$', 'back.views.regist'),
    url(r'^login$', 'back.views.login'),
    url(r'^logout$', 'back.views.logout'),
    url(r'^permission$', 'back.views.permission'),
    url(r'^getCAPTCHA', 'back.views.getCAPTCHA'),
    url(r'^getAccount$', 'back.views.getAccount'),
    url(r'^managePassword$', 'back.views.managePassword'),
    url(r'^manageAccount$', 'back.views.manageAccount'),
    url(r'^getClassOne$', 'back.views.getClassOne'),
    url(r'^manageClassOne$', 'back.views.manageClassOne'),
    url(r'^getClassTwo$', 'back.views.getClassTwo'),
    url(r'^manageClassTwo$', 'back.views.manageClassTwo'),
    url(r'^getProduct$', 'back.views.getProduct'),
    url(r'^getProductInfo$', 'back.views.getProductInfo'),
    ur

    url(r'^manageProductPic$', 'back.views.manageProductPic'),
    url(r'^saveProductInfoPic$', 'back.views.saveProductInfoPic'),
    url(r'^manageBestProducts$', 'back.views.manageBestProducts'),
    url(r'^saveNewsPic$', 'back.views.saveNewsPic'),
    url(r'^manageNews$', 'back.views.manageNews'),
    url(r'^manageJob$', 'back.views.manageJob'),
    url(r'^manageCompanyCulture$', 'back.views.manageCompanyCulture'),
    url(r'^manageContactUs$', 'back.views.manageContactUs'),
    url(r'^manageCase$', 'back.views.manageCase'),
    url(r'^saveCaseFirstPic$', 'back.views.saveCaseFirstPic'),
    url(r'^saveCasePic$', 'back.views.saveCasePic'),
    url(r'^saveCaseInfo$', 'back.views.saveCaseInfo'),
    url(r'^manageShop$', 'back.views.manageShop'),
    url(r'^saveShopFirstPic$', 'back.views.saveShopFirstPic'),
    url(r'^saveShopPic$', 'back.views.saveShopPic'),
    url(r'^saveShopInfo$', 'back.views.saveShopInfo'),
    url(r'^getPic/(?P<ImgName>.*\.(jpg|png|gif|jpeg|ico)$)', 'back.views.
log = logging.getLogger( __name__ )
def get_latest_changeset_revision( app, repository, repo ):
    repository_tip = repository.tip( app )
    repository_metadata = suc.get_repository_metadata_by_changeset_revision( app,
                                                                             app.security.encode_id( repository.id ),
                                                                             repository_tip )
    if repository_metadata and repository_metadata.downloadable:
        return repository_tip
    changeset_revisions = suc.get_ordered_metadata_changeset_revisions( repository, repo, downloadable=False )
    if changeset_revisions:
        return changeset_revisions[ -1 ]
    return hg_util.INITIAL_CHANGELOG_HASH
def get_latest_repository_metadata( app, decoded_repository_id, downloadable=False ):
    """Get last metadata defined for a specified repository from the database."""
    sa_session = app.model.context.current
    repository = sa_session.query( app.

    repo = hg_util.get_repo_for_repository( app, repository=repository, repo_path=None, create=False )
    if downloadable:
        changeset_revision = suc.get_latest_downloadable_changeset_revision( app, repository, repo )
    else:
        changeset_revision = get_latest_changeset_revision( app, repository, repo )
    return suc.get_repository_metadata_by_changeset_revision( app,
                                                              app.security.encode_id( repository.id ),
                                                              changeset_revision )
def get_previous_metadata_changeset_revision( repository, repo, before_changeset_revision, downloadable=True ):
    """
    Return the changeset_revision in the repository changelog that has associated metadata prior to
    the changeset to which before_changeset_revision refers.  If there isn't one, return the hash value
    of an empty repository changelog, hg_util.INITIAL_CHANGELOG_HASH.
    """
    changeset_revisions =

    if len( changeset_revisions ) == 1:
        changeset_revision = changeset_revisions[ 0 ]
        if changeset_revision == before_changeset_revision:
            return hg_util.INITIAL_CHANGELOG_HASH
        return changeset_revision
    previous_changeset_revision = None
    for changeset_revision in changeset_revisions:
        if changeset_revision == before_changeset_revision:
            if previous_changeset_revision:
                return previous_changeset_revision
            else:
                return hg_util.INITIAL_CHANGELOG_HASH
        else:
            previous_changeset_revision = changeset_revision
def get_repository_dependency_tups_from_repository_metadata( app, repository_metadata, deprecated_only=False ):
    """
    Return a list of of tuples defining repository objects required by the received repository.  The returned
    list defines the entire repository dependency tree.  This method is called only from the Tool Shed.
    """
    dependency_tups = []
  
log = logging.getLogger(__name__)
repository_name = 'filtering_1470'
repository_description = "Galaxy's filtering tool"
repository_long_description = "Long description of Galaxy's filtering tool"
category_name = 'Test 1470 - Updating Installed Repositories'
category_description = 'Functional test suite to ensure that updating installed repositories does not create white ghosts.'
'''
1. Install a repository into Galaxy.
2. In the Tool Shed, update the repository from Step 1.
3. In Galaxy, get updates to the repository.
4. In Galaxy, uninstall the repository.
5. In Galaxy, reinstall the repository.
6. Make sure step 5 created no white ghosts.
'''
class TestUpdateInstalledRepository( ShedTwillTestCase ):
    '''Verify that the code correctly handles updating an installed repository, then uninstalling and reinstalling.'''
    
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, use

        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = self.test_db_util.get_private_role( admin_user )
        
    def test_0005_create_filtering_repository( self ):
        """Create and populate the filtering_0530 repository."""
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository =

                                                    description=repository_description, 
                                                    long_description=repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        self.upload_file( repository, 
                          filename='filtering/filtering_1.1.0.tar',
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=True,
                          remove_repo_files_not_in_tar=False, 
                          commit_message='Uploaded filtering 1.1.0 tarball.',
                          strings_displayed=[], 
                          strings_not_displayed=[] )
        
    def test_0010_install_filtering_to_galaxy( self
"""App interfaces.
"""
class INavigation(Interface):
    """Basic navigation UI support"""
    manage = Attribute(""" """)
    manage_menu = Attribute(""" """)
    manage_top_frame = Attribute(""" """)
    manage_page_header = Attribute(""" """)
    manage_page_footer = Attribute(""" """)
    manage_form_title = Attribute("""Add Form""")
    zope_quick_start = Attribute(""" """)
    manage_copyright = Attribute(""" """)
    manage_zmi_prefs = Attribute(""" """)
    def manage_zmi_logout(REQUEST, RESPONSE):
        """Logout current user"""
INavigation.setTaggedValue('manage_page_style.css', Attribute(""" """))
class IPersistentExtra(Interface):
    def bobobase_modification_time():
        """
        """
class IUndoSupport(Interface):
    manage_UndoForm = Attribute("""Manage Undo form""")
    def undoable_transactions(first_transaction=None,
                              last_transaction=None,
                              PrincipiaUndoBatchSize=None):
        """
        """
    def
class ProjectControllerTest(unittest.TestCase):
	def testProjectController(self):
		projectController = ProjectController.Instance()
		self.assertIsNotNone(projectController.currentProject)
		projectController.newProject()
		self.assertIsNone(projectController.currentProject.title)
	def testSavingAndLoadingProjectsToDisk(self):
		projectController = ProjectController.Instance()
		path = os.path.dirname(os.path.abspath(__file__))
		projectPath = path + "/project"
		if not os.path.exists(projectPath):
			os.makedirs(projectPath)
		projectController.currentProject.title = "Unique title"
		projectController.currentProject.folder = unicode(projectPath)
		projectController.saveProject()
		projectController.newProject()
		self.assertIsNone(projectController.currentProject.title)
		self.assertIsNone(projectController.currentProject.folder)
		self.assertTrue(os.path.exists(projectPath + "/project.yaml"))
		self.assertTrue(projectController.loadProject(projectPath))
		projectController.loadProje
__author__ = 'Hossein Zolfi <hossein.zolfi@gmail.com>'
def test_add_amount():
    repository = TransactionRepository()
    repository.add_amount('2', '13.0')
    repository.add_amount('2', '17.0')
    repository.add_amount(7,    -19.0)
    repository.add_amount(7,    21.0)
    repository.add_amount(5,    23.0)
    repository.add_amount(29,   -31.0)
    assert repository.get_account_amount(2)    == 30
    assert repository.get_account_amount('2')  == 30
    assert repository.get_account_amount('7')  == 2
    assert repository.get_account_amount('29') == -31
def test_get_formatted_transactions_asc():
    repository = TransactionRepository()
    repository.add_amount('1234567890123456', 1)
    repository.add_amount('1234567890123457', 1)
    repository.add_amount('1234567890123458', 1)
    assert list(repository.get_formatted_transactions()) == [
        (1234567890123456, 1.0), (1234567890123457, 1.0), (1234567890123458, 1.0)
    ]
def test_get_formatted_transactions_desc():
    reposito
store = storage.load()
logger = logging.getLogger(__name__)
@app.route('/v1/repositories/<path:repository>/tags',
           methods=['GET'])
@toolkit.parse_repository_name
@toolkit.requires_auth
def get_tags(namespace, repository):
    logger.debug("[get_tags] namespace={0}; repository={1}".format(namespace,
                 repository))
    data = {}
    try:
        for fname in store.list_directory(store.tag_path(namespace,
                                                         repository)):
            tag_name = fname.split('/').pop()
            if not tag_name.startswith('tag_'):
                continue
            data[tag_name[4:]] = store.get_content(fname)
    except OSError:
        return toolkit.api_error('Repository not found', 404)
    return toolkit.response(data)
@app.route('/v1/repositories/<path:repository>/tags/<tag>',
           methods=['GET'])
@toolkit.parse_repository_name
@toolkit.requires_auth
def get_tag(namespace, repository, tag):
    logger.debug("[ge

                 namespace, repository, tag))
    data = None
    try:
        data = store.get_content(store.tag_path(namespace, repository, tag))
    except IOError:
        return toolkit.api_error('Tag not found', 404)
    return toolkit.response(data)
@app.route('/v1/repositories/<path:repository>/tags/<tag>',
           methods=['PUT'])
@toolkit.parse_repository_name
@toolkit.requires_auth
def put_tag(namespace, repository, tag):
    logger.debug("[put_tag] namespace={0}; repository={1}; tag={2}".format(
                 namespace, repository, tag))
    data = None
    try:
        data = json.loads(flask.request.data)
    except json.JSONDecodeError:
        pass
    if not data or not isinstance(data, basestring):
        return toolkit.api_error('Invalid data')
    if not store.exists(store.image_json_path(data)):
        return toolkit.api_error('Image not found', 404)
    store.put_content(store.tag_path(namespace, repository, tag), data)
    sender = flask.current_app._get

    signals.tag_created.send(sender, namespace=namespace,
                             repository=repository, tag=tag, value=data)
    return toolkit.response()
@app.route('/v1/repositories/<path:repository>/tags/<tag>',
           methods=['DELETE'])
@toolkit.parse_repository_name
@toolkit.requires_auth
def delete_tag(namespace, repository, tag):
    logger.debug("[delete_tag] namespace={0}; repository={1}; tag={2}".format(
                 namespace, repository, tag))
    try:
        store.remove(store.tag_path(namespace, repository, tag))
        sender = flask.current_app._get_current_object()
        signals.tag_deleted.send(sender, namespace=namespace,
                                 repository=repository, tag=tag)
    except OSError:
        return toolkit.api_error('Tag not found', 404)
    return toolkit.response()
@app.route('/v1/repositories/<path:repository>/tags',
           methods=['DELETE'])
@toolkit.parse_repository_name
@toolkit.requires_auth
def delete_repository(
if  __package__ is None:
    G_NAME_MODULE_STORAGE_CONTROLLER = "unknown"
else:
class Controller(object):
    """
    A base class representing a disk controller.
    """
    def __init__ (self,name,internalId,groupName,logger):
        self._log = logger.createLogger(G_NAME_MODULE_STORAGE_CONTROLLER, groupName)
        self._controllerName = name
        self._runningControllerConfig   = None
        self._candidateControllerConfig = None
        self._activeControllerConfig    = None 
    
    def controllerTrxStart (self):
        self._log("controller-trx-start").debug3("diskControllerTrxStart()  was called for controller %s, running --> candidate",self._controllerName)
        self._candidateControllerConfig.copyFrom(self._runningControllerConfig)
        return ReturnCodes.kOk
    def controllerValueSet (self,data):
        self._log("controller-value-set").debug3("controllerValueSet(data=%s)  was called for controller %s, data --> candidate",data,self._controllerName)
        se
"""
url规则：
统一的url，需要以/结尾
带参数的url，以参数结尾，不带/
"""
urlpatterns = patterns('ymgweb.views',
    (r'^$', 'home'),
    (r'^/$', 'home'),
    (r'^home_best_humor/$', 'home_best_humor'),
    (r'^home_best_riddle/$', 'home_best_riddle'),
    (r'^home_best_iq/$', 'home_best_iq'),
    (r'^digg/(?P<type>\d*)/(?P<id>\d*)$', 'digg'),
    (r'^bury/(?P<type>\d*)/(?P<id>\d*)$', 'bury'),
urlpatterns += patterns('ymgweb.site.views',
    (r'^site/(?P<template>\w*)/$', 'site'),
urlpatterns += patterns('ymgweb.manage.views',
    (r'^manage/change/$', 'change'),
    (r'^manage/url_list/$', 'url_list'),
    (r'^manage/style_center/$', 'style_center'),
    (r'^manage/$', 'index'),
    (r'^manage/humor_data/$', 'humor_data', {'page_id':'1'}),
    (r'^manage/humor_data/(?P<page_id>\d*)$', 'humor_data'),
    (r'^manage/humor_delete/(?P<humor_id>\d*)$', 'humor_delete'),
    (r'^manage/iq_data/$', 'iq_data', {'page_id':'1'}),
    (r'^manage/iq_data/(?P<page_id>\d*)$', 'iq_data'),
    (r'^manage/iq_delete/(?P<iq_id>\d

    (r'^manage/riddle_data/$', 'riddle_data', {'page_id':'1'}),
    (r'^manage/riddle_data/(?P<page_id>\d*)$', 'riddle_data'),
    (r'^manage/riddle_delete/(?P<riddle_id>\d*)$', 'riddle_delete'),
    (r'^manage/content_edit/(?P<content_id>\d*)$', 'content_edit'),
    (r'^manage/promotion/$', 'promotion'),
    (r'^manage/add_promotion/$', 'add_promotion'),
    (r'^manage/edit_promotion/(?P<promotion_id>\d*)$', 'edit_promotion'),
    (r'^manage/delete_promotion/(?P<promotion_id>\d*)$', 'delete_promotion'),
urlpatterns += patterns('ymgweb.user.views',
    (r'^user/join/$', 'join'),
    (r'^user/join_success/$', 'join_success'),
    (r'^user/login/$', 'login'),
    (r'^user/logout/$', 'logout'),
    (r'^user/edit/$', 'edit'),
urlpatterns += patterns('ymgweb.category.views',
    (r'^category/add/$', 'add'),
urlpatterns += patterns('ymgweb.article.views',
    (r'^article/$', 'list', {'page_id':'1'}),
    (r'^article/add/$', 'add'),
urlpatterns += patterns('ymgweb.humor.views',
    (r'^humor
MENU_ICONS_DIR = os.path.join(MAIN_DIR, "image", "menu_icons")
menu_icon_normal = lambda x: os.path.join(MENU_ICONS_DIR,"%s-symbolic-small-norml.svg" % x)
menu_icon_hover = lambda x: os.path.join(MENU_ICONS_DIR, "%s-symbolic-small-hover.svg" % x)
menu_icon_tuple = lambda x: (menu_icon_normal(x), menu_icon_hover(x))
save_sub_menu = [
    CheckableMenuItem("save:radio:_op_auto_save", _("Autosave")),
    CheckableMenuItem("save:radio:_op_save_to_desktop", _("Save to desktop")),
    CheckableMenuItem("save:radio:_op_copy_to_clipboard", _("Copy to clipboard")),
    CheckableMenuItem("save:radio:_op_save_as", _("Save to specified folder")),
    CheckableMenuItem("save:radio:_op_copy_and_save", _("Autosave and copy to clipboard")),
right_click_menu = [
    ("_rectangle", _("Rectangle tool"), menu_icon_tuple("rectangle-tool")),
    ("_ellipse", _("Ellipse tool"), menu_icon_tuple("ellipse-tool")),
    ("_arrow", _("Arrow tool"), menu_icon_tuple("arrow-tool")),
    ("_line", _("Brush tool"), men

    ("_text", _("Text tool"), menu_icon_tuple("text-tool")),
    None,
    ("_save", _("Save"), menu_icon_tuple("save")),
    ("_share", _("Share"), menu_icon_tuple("share")),
    ("_exit", _("Exit"), menu_icon_tuple("exit")),
class MenuController(QObject):
    toolSelected = pyqtSignal(str, arguments=["toolName"])
    saveSelected = pyqtSignal(int, arguments=["saveOption"])
    shareSelected = pyqtSignal()
    exitSelected = pyqtSignal()
    preMenuShow = pyqtSignal()
    postMenuHide = pyqtSignal()
    def __init__(self):
        super(MenuController, self).__init__()
    def _menu_unregistered(self):
        self.postMenuHide.emit()
    def _menu_item_invoked(self, _id, _checked):
        self.postMenuHide.emit()
        if _id == "_rectangle":
            self.toolSelected.emit("_rectangle")
        if _id == "_ellipse":
            self.toolSelected.emit("_ellipse")
        if _id == "_arrow":
            self.toolSelected.emit("_arrow")
        if _id == "_line":
            sel

        if _id == "_text":
            self.toolSelected.emit("_text")
        if _id == "save:radio:_op_auto_save":
            self.saveSelected.emit(1)
        if _id == "save:radio:_op_save_to_desktop":
            self.saveSelected.emit(0)
        if _id == "save:radio:_op_copy_to_clipboard":
            self.saveSelected.emit(4)
        if _id == "save:radio:_op_save_as":
            self.saveSelected.emit(2)
        if _id == "save:radio:_op_copy_and_save":
            self.saveSelected.emit(3)
        if _id == "_share":
            self.shareSelected.emit()
        if _id == "_exit":
            self.exitSelected.emit()
    @pyqtSlot(int)
    def show_menu(self, saveOption):
        self.preMenuShow.emit()
        self.menu = Menu(right_click_menu)
        self.menu.getItemById("_save").setSubMenu(Menu(save_sub_menu))
        self.menu.getItemById("save:radio:_op_auto_save").checked = \
            saveOption == 1
        self.menu.getItemById("save:radio:_op_save_to_desktop"
@patch('expyrimenter.clouds.cloudstack.api.json')
class TestAPI(unittest.TestCase):
    @patch('expyrimenter.clouds.cloudstack.api.API._http_get')
    def test_url_begins_with_api_url(self, get, json):
        api = self._get_api()
        api.a_test_command()
        self.assertRegex(api.value, r'^url?')
    @patch('expyrimenter.clouds.cloudstack.api.API._http_get')
    def test_url_has_command(self, get, json):
        api = self._get_api()
        api.a_test_command()
        self.assertRegex(api.value, r'.*command=a_test_command')
    @patch('expyrimenter.clouds.cloudstack.api.API._http_get')
    def test_url_has_apiKey(self, get, json):
        api = self._get_api()
        api.a_test_command()
        self.assertRegex(api.value, r'.*apiKey=key')
    @patch('expyrimenter.clouds.cloudstack.api.API._http_get')
    def test_url_has_signature(self, get, json):
        api = self._get_api()
        api.a_test_command()
        self.assertRegex(api.value, r'.*signature=.+')
    @patch('

    def test_url_has_kwargs(self, get, json):
        api = self._get_api()
        api.a_test_command(param1='value1', param2='value2')
        self.assertRegex(api.value, r'.*param1=value1&param2=value2')
    @patch('expyrimenter.clouds.cloudstack.api.API._http_get')
    def test_url_with_args_exception(self, get, json):
        api = self._get_api()
        self.assertRaises(TypeError, api.a_test_command, 'value1')
    @patch('expyrimenter.clouds.cloudstack.api.API._http_get')
    def test_boolean_quoting(self, get, json):
        api = self._get_api()
        api.a_test_command(true=True, false=False)
        self.assertRegex(api.value, r'.*false=false.*&true=true')
    @patch('expyrimenter.clouds.cloudstack.api.urlopen')
    def test_urlopen_is_called(self, urlopen, json):
        response = urlopen.return_value
        response.read.decode = ''
        api = self._get_api()
        api.a_test_command()
        self.assertEqual(1, urlopen.call_count)
    @patch('expyrimenter.clou
DEBUG_MODE = (os.environ.get('SERVER_SOFTWARE', '').startswith('Development')
    or 'test' in os.environ.get('HTTP_HOST', os.environ.get('SERVER_NAME')))
application = ndb.toplevel(webapp2.WSGIApplication([
  webapp2.Route('/', app.views.user.Landing, 'landing'),
  webapp2.Route('/login',  app.views.simple.Login,  'login'),
  webapp2.Route('/logout', app.views.simple.Logout, 'logout'),
  webapp2.Route('/signup', app.views.user.Signup, 'signup'),
  webapp2.Route('/guidelines', app.views.user.Guidelines, 'guidelines'),
  webapp2.Route('/missions/create', app.views.mission.Create, 'create_mission'),
  webapp2.Route('/missions/<guid>', app.views.mission.View, 'view_mission'),
  webapp2.Route('/missions/<guid>/update', app.views.mission.Update, 'update_mission'),
  webapp2.Route('/queue', app.views.mission.Queue, 'mission_queue'),
  webapp2.Route('/manage', app.views.manage.Root, 'manage_root'),
  webapp2.Route('/manage/', app.views.manage.Root, 'manage_root_s'),
  webapp2.Route('/manage/u
class DS3SaveMgr:
    def __init__(self, game_save_loc, game_save_file, save_repo_loc):
        self.game_save_loc = game_save_loc
        self.game_save_file = game_save_file
        self.save_repo_loc = save_repo_loc
    def backup(self, backup_subdir='backup', game_save_must_exist=True):
        backup_dir = os.path.join(self.save_repo_loc, backup_subdir)
        self.create_dir(backup_dir)
        backup_counter = 0
        backup_file = self.generate_backup_file(backup_counter)
        existing_backup_files = os.listdir(backup_dir)
        while backup_file in existing_backup_files:
            backup_counter += 1
            backup_file = self.generate_backup_file(backup_counter)
        game_save_path = os.path.join(self.game_save_loc, self.game_save_file)
        backup_path = os.path.join(backup_dir, backup_file)
        self.validate_file(game_save_path, game_save_must_exist)
        if os.path.exists(game_save_path) and os.path.isfile(game_save_path):
            print('Back

            shutil.copyfile(game_save_path, backup_path)
    def restore(self):
        self.backup('replaced', False)
        backup_dir = os.path.join(self.save_repo_loc, 'backup')
        save_name, save_ext = os.path.splitext(self.game_save_file)
        existing_backup_files = os.listdir(backup_dir)
        for backup_file in reversed(existing_backup_files):
            if save_name in backup_file and save_ext in backup_file:
                break
        backup_path = os.path.join(backup_dir, backup_file)
        self.validate_file(backup_path, True)
        game_save_path = os.path.join(self.game_save_loc, self.game_save_file)
        self.create_dir(self.game_save_loc)
        print('Restoring file \'{}\' to \'{}\'...'.format(backup_path, game_save_path))
        shutil.copyfile(backup_path, game_save_path)
    def generate_backup_file(self, counter):
        save_name, save_ext = os.path.splitext(self.game_save_file)
        return '{}_{}{}'.format(save_name, str(counter).zfi
class Settings():
    def __init__(self, settings):
        self.CRONJOBS = getattr(settings, 'CRONJOBS', [])
        self.CRONTAB_EXECUTABLE = getattr(settings, 'CRONTAB_EXECUTABLE', '/usr/bin/crontab')
        self.DJANGO_PROJECT_NAME = getattr(settings, 'CRONTAB_DJANGO_PROJECT_NAME', os.environ['DJANGO_SETTINGS_MODULE'].split('.')[0])
        self.DJANGO_SETTINGS_MODULE = getattr(settings, 'CRONTAB_DJANGO_SETTINGS_MODULE', None)
        if hasattr(settings, 'CRONTAB_DJANGO_MANAGE_PATH'):
            self. DJANGO_MANAGE_PATH = settings.CRONTAB_DJANGO_MANAGE_PATH
            if not os.path.exists(self.DJANGO_MANAGE_PATH):
                print('ERROR: No manage.py file found at "%s". Check settings.CRONTAB_DJANGO_MANAGE_PATH!' % self.DJANGO_MANAGE_PATH)
        else:
            def ext(fpath):
                return os.path.splitext(fpath)[0] + '.py'
            except ImportError:
                except ImportError:
                    print('ERROR: Can\'t find your manage.py - plea
urls = (
        '/',                "controller.mobile.index",
        '/a/(\d+)/?',       "controller.mobile.article",
        '/c/(\d+)/?',       "controller.mobile.category",
        
        '/login',           "controller.mobile.login",
        '/logout',          "controller.mobile.logout",
        '/register',        "controller.mobile.register",
        '/find_password',   "controller.mobile.find_password",
        
        "/admin/?",         "controller.admin.index",
        "/admin/login/?",   "controller.admin.login",
        "/admin/logout/?",  "controller.admin.logout",
        
        
        "/admin/user_list",            "controller.admin.user.user_list",
        "/admin/user_read/(\d+)",      "controller.admin.user.user_read",
        "/admin/user_edit/(\d+)",      "controller.admin.user.user_edit",
        "/admin/user_delete/(\d+)",    "controller.admin.user.user_delete",
        
        "/admin/insp_type_list",            "controller.admin.insp_type.insp_type_l

        "/admin/insp_type_read/(\d+)",      "controller.admin.insp_type.insp_type_read",
        "/admin/insp_type_edit/(\d+)",      "controller.admin.insp_type.insp_type_edit",
        "/admin/insp_type_delete/(\d+)",    "controller.admin.insp_type.insp_type_delete",
        
        "/admin/insp_item_list",            "controller.admin.insp_item.insp_item_list",
        "/admin/insp_item_read/(\d+)",      "controller.admin.insp_item.insp_item_read",
        "/admin/insp_item_edit/(\d+)",      "controller.admin.insp_item.insp_item_edit",
        "/admin/insp_item_delete/(\d+)",    "controller.admin.insp_item.insp_item_delete",
        
        "/admin/insp_plan_list",            "controller.admin.insp_plan.insp_plan_list",
        "/admin/insp_plan_read/(\d+)",      "controller.admin.insp_plan.insp_plan_read",
        "/admin/insp_plan_edit/(\d+)",      "controller.admin.insp_plan.insp_plan_edit",
        "/admin/insp_plan_delete/(\d+)",    "controller.admin.insp_plan.insp_plan_delet
'''
Created on 2011/05/07
@author: miio
'''
class SvnTestRepositoryTest(unittest.TestCase):
    def setUp(self):
        settings.PROJECTS_REPOSITORY_DIRECTORY = settings.PROJECTS_REPOSITORY_DIRECTORY_UNIT
        master_name                            = "unit_1_master"
        co_name                                = "1"
        self.client                            = pysvn.Client()
        self.repository                        = SvnTestRepository()
        self.repository.set_repository_base_path(settings.PROJECTS_REPOSITORY_DIRECTORY)
        self.repository_master_path            = self.repository.create_master(master_name)
        self.repository_path                   = self.repository.create_checkout(master_name,co_name)
        
    def tearDown(self):
        self.repository.delete()
        
    def test_exist_repository_master_directory(self):
        self.assertTrue(os.path.isdir(self.repository_master_path))
    
    def test_exist_repository_directory(self):
        sel
	RandomMapController, MapInfoController
	HelpController, TimeController, MeController,
	TomController, ReminderController, HadesController
	LoginController, WhoController, FinishLineController,
	RankingsController, RegistrationController,
	LogoutController, BestTimeController, SpeedRankingsController,
	SpeedAwardController, WorldRecordController,
	LoginReminderController, SetPasswordController
routes = g.routes
routes.addRule("entrance", LoginReminderController)
routes.addRule("login", LoginController)
routes.addRule("logout", LogoutController)
routes.addRule("register", RegistrationController)
routes.addRule("whoami", WhoController)
routes.addRule("random", RandomMapController)
routes.addRule("findmap", RandomMapController)
routes.addRule("h", HelpController)
routes.addRule("time", TimeController)
routes.addRule("me", MeController)
routes.addRule("mapinfo", MapInfoController)
routes.addRule("clienttimerstop", FinishLineController)
routes.addRule("clientspeedaward", SpeedAwardControlle
def split_and_validate_path(path):
    split_path = path.split('.')
    if '' in split_path:
        raise ValueError("Path may not contain empty components.")
    if split_path[0] != 'page':
        raise ValueError("The root controller must be 'page'")
    return split_path
class ViewState(object):
    def __init__(self, root_controller):
        self.root_controller = root_controller
        root_controller.make_root(self)
    def controller_from_path(self, path):
        split_path = split_and_validate_path(path)
        if path == 'page':
            return self.root_controller
        controller = self.root_controller
        for path_component in split_path[1:]:
            controller = controller.get_child(path_component)
        return controller
    def post_setup(self):
        self.root_controller._post_attach()
    def _add_controller_to_parent(self, parent_controller, controller, child_key, is_push):
        if is_push:
            parent_controller.push_child(child_key, 

        else:
            parent_controller.set_child(child_key, controller)
    def _parent_controller_and_child_key_from_path(self, path):
        split_path = split_and_validate_path(path)
        if len(split_path) < 2:
            raise ValueError('To retrieve a parent controller, path must have at least two components.')
        parent_controller = self.controller_from_path('.'.join(split_path[:-1]))
        return parent_controller, split_path[-1]
    def insert_controller(self, path, controller):
        """
        Inserts an already initialised controller at the given path.
        Will replace the stack of controllers already at the path, with a new stack,
        containing just this controller.
        """
        parent_controller, child_key = self._parent_controller_and_child_key_from_path(path)
        self._add_controller_to_parent(parent_controller, controller, child_key, False)
    def insert_new_controller(self, path, component_name, *args, **kwargs):
        """
 

        and arguments and will init the controller before inserting it at the given path,
        replacing the existing controller stack with a new stack containing just this
        controller.
        """
        controller = init_controller(component_name, *args, **kwargs)
        self.insert_controller(path, controller)
        return controller
    def push_controller(self, path, controller):
        """
        Pushes and already initialised controller onto the stack at the given path.
        """
        parent_controller, child_key = self._parent_controller_and_child_key_from_path(path)
        self._add_controller_to_parent(parent_controller, controller, child_key, True)
    def push_new_controller(self, path, component_name, *args, **kwargs):
        """
        Similar to the push_controller method, however it takes a component name
        and arguments and will init the controller before pushing it onto the given path.
        """
        controller = init_controller(com
column_repository_name = 'column_maker_1087'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_1087'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 1087 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryDependencies( ShedTwillTestCase ):
    '''Test installing a repository, then updating it to include repository dependencies.'''
    def test_0000_create_or_login_admin_user( self ):
        """Create necessary user accounts and login as an admin user."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with email 

        galaxy_admin_user_private_role = test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
  
    def test_0005_create_and_populate_column_repository( self ):
        """Create a category for this test suite and add repositories to it."""
        category =

        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name, 
                                                    description=column_repository_description, 
                                                    long_description=column_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        if self.repository_is_new( repository ):
            self.upload_file( repository, 
                              filename='column_maker/column_maker.tar',
                              filepath=None,
                              valid_tools_only=True,
                              uncompress_file=True,
                             
register = template.Library()
def submit_row_save_only(context):
    """
    Displays the row of buttons for delete and save.
    """
    opts = context['opts']
    change = context['change']
    is_popup = context['is_popup']
    save_as = context['save_as']
    return {
        'onclick_attrib': (opts.get_ordered_objects() and change
                            and 'onclick="submitOrderForm();"' or ''),
        'show_delete_link': (not is_popup and context['has_delete_permission']
                              and (change or context['show_delete'])),
        'show_save_as_new': not is_popup and change and save_as,
        'show_save_and_add_another': context['has_add_permission'] and
                            not is_popup and (not save_as or context['add']),
        'show_save_and_continue': not is_popup and context['has_change_permission'],
        'is_popup': is_popup,
        'show_save': True
    }
submit_row_save_only = register.inclusion_tag('admin/submit_line_save_only.html'
class TestPOSTSecurity(CMFFormControllerTestCase):
    """A simple test to show that the form can optionally require POST requests
    """
    def afterSetUp(self):
        manage_addControllerPageTemplate(self.portal, 'base_controller')
        self.base_controller = self.portal.base_controller
        self.base_state = ControllerState(id="my_id", context=self.portal,
                                          button="default")
    def test_POSTRequiredOffByDefault(self):
        self.failIf(self.base_controller.getPOSTRequired())
    def test_changePOSTRequired(self):
        self.base_controller.require_post = True
        self.failUnless(self.base_controller.getPOSTRequired)
    def test_GETSucceedsByDefault(self):
        self.assertEqual(self.app.REQUEST['REQUEST_METHOD'], 'GET')
        self.base_controller.getValidators(self.base_state, self.app.REQUEST)
    def test_GETFailsWhenDisallowed(self):
        self.base_controller.require_post = True
        self.assertRaises(Forbidde
column_repository_name = 'column_maker_0080'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0080'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0080 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryCircularDependencies( ShedTwillTestCase ):
    '''Verify that the code correctly handles circular dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_email
        self.test

        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
    def test_0005_create_column_repository( self ):
        """Create and populate the column_maker repository."""
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name,
                                                    description=column_repository_description,
                                                    long_description=column_repository_long_description,
                                                    

                                                    category_id=self.security.encode_id( category.id ),
                                                    strings_displayed=[] )
        self.upload_file( repository,
                          filename='column_maker/column_maker.tar',
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=True,
                          remove_repo_files_not_in_tar=False,
                          commit_message='Uploaded column_maker tarball.',
                          strings_displayed=[],
                          strings_not_displayed=[] )
    def test_0005_create_convert_repository( self ):
        """Create and populate the convert_chars repository."""
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
  
class GameSetupController(ConsoleController):
    """ Controller for Game Setup """
    
    def __init__(self):
        """ Initialize the Game Setup Controller """
        self.playerCount = 0
        self.names = []
        screen = GameSetupScreen()
        ConsoleController.__init__(self, screen, commands={'1':self.setPlayerCount,
                                                           '2':self.setPlayerCount,
                                                           '3':self.setPlayerCount,
                                                           '4':self.setPlayerCount,
                                                           '5':self.setPlayerCount,
                                                           '6':self.setPlayerCount})
        
    def setPlayerCount(self, event):
        """ Set the player Count """
        self.playerCount = int(event)
        
        for i in range(self.playerCount):
            controller = PlayerNameController()
            self.runC
CONTENT_MANAGE_OPTIONS = (
    {'action': 'manage_change_history_page', 'label': 'History'},
    {'action': 'view', 'label': 'View'},
    {'action': 'manage_interfaces', 'label': 'Interfaces'},
@implementer(IBaseContent, IReferenceable)
class BaseContentMixin(CatalogMultiplex,
                       BaseObject,
                       PortalContent,
                       Historical):
    """A not-so-basic CMF Content implementation that doesn't
    include Dublin Core Metadata"""
    security = ClassSecurityInfo()
    manage_options = CONTENT_MANAGE_OPTIONS
    isPrincipiaFolderish = 0
    isAnObjectManager = 0
    __dav_marshall__ = True
    security.declarePrivate('manage_afterAdd')
    def manage_afterAdd(self, item, container):
        BaseObject.manage_afterAdd(self, item, container)
    security.declarePrivate('manage_afterClone')
    def manage_afterClone(self, item):
        BaseObject.manage_afterClone(self, item)
    security.declarePrivate('manage_beforeDelete')
    def mana

        BaseObject.manage_beforeDelete(self, item, container)
        self._v_cp_refs = None
    def _notifyOfCopyTo(self, container, op=0):
        BaseObject._notifyOfCopyTo(self, container, op=op)
        if op == 1:
            self._v_cp_refs = 1
    security.declareProtected(permissions.ModifyPortalContent, 'PUT')
    PUT = WebDAVSupport.PUT
    security.declareProtected(permissions.View, 'manage_FTPget')
    manage_FTPget = WebDAVSupport.manage_FTPget
    security.declarePrivate('manage_afterPUT')
    manage_afterPUT = WebDAVSupport.manage_afterPUT
InitializeClass(BaseContentMixin)
@implementer(IBaseContent, IReferenceable, IExtensibleMetadata)
class BaseContent(BaseContentMixin,
                  ExtensibleMetadata,
                  PropertyManager):
    """A not-so-basic CMF Content implementation with Dublin Core
    Metadata included"""
    schema = BaseContentMixin.schema + ExtensibleMetadata.schema
    def __init__(self, oid, **kwargs):
        BaseContentMixin.__init__(
manage = Manage(main.application)
def run_command(command):
    """ We frequently inspect the return result of a command so this is just
        a utility function to do this. Generally we call this as:
        return run_command ('command_name args')
    """
    result = os.system(command)
    return 0 if result == 0 else 1
@manage.command
def coffeelint():
    return run_command('coffeelint app/coffee')
@manage.command
def coffeebuild():
    return run_command('coffee -c -o app/static/generated/ app/coffee')
@manage.command
def test_all():
    return run_command("python -m unittest app.main")
@manage.command
def test():
    """ Eventually this could become a convenience command for calling the
        other test commands quickly with just test -x.
    """
    return test_all()
@manage.command
def test_casper(name=None):
    """Run the specified single CasperJS test, or all if not given"""
    coffeebuild()
    phantom_test = PhantomTest('test_run')
    phantom_test.set_single(name)
 
def create_certificate():
    intkey = 324521
    print 'Request generate code',intkey
    return ('http://certificate.mui.com/'+str(intkey)+'.html',intkey)
def update_certificate(certnumber):
    print 'Update certificate request';
    return 0;
def save_product_name(certnumber,data):
    print 'Save Product Name, certnumber=%d,product name=%s' % (certnumber,data)
    return 0;
def save_product_type(certnumber,data):
    print 'Save Product Type, certnumber=%d,product type=%s' % (certnumber,data)
    return 0;
def save_issued_date(certnumber,data):
    print 'Save Issued date, certnumber=%d,product type=%s' % (certnumber,data)
    return 0;
def save_limit_validation_date(certnumber,data):
    print 'Save limit validation date, certnumber=%d,product type=%s' % (certnumber,data)
    return 0;
def save_company_name(certnumber,data):
    print 'Save company name, certnumber=%d,product type=%s' % (certnumber,data)
    return 0;
def save_company_address(certnumber,data):
    print 'Save com
class Foo(Resource):
    prefix = "/foo"
class Test(Resource):
    prefix = "/test"
class Tests(Resource):
    prefix = "/test/"
class Testing(Resource):
    prefix = "/testing"
class TestDispatch(BaseTest):
    def setUp(self):
        self.dispatch = Dispatch(Foo, Test, Tests, Testing)
        self.req = Request.blank("/test")
    def test_match(self):
        resource = self.dispatch.match(self.req, self.dispatch.resources)
        self.assertEqual(resource, Test)
    def test_match_reverse_order(self):
        resources = sorted(self.dispatch.resources, reverse=True)
        resource = self.dispatch.match(self.req, resources)
        self.assertEqual(resource, Test)
    def test_match_prefix(self):
        req = Request.blank("/testing")
        resource = self.dispatch.match(req, self.dispatch.resources)
        self.assertEqual(resource, Testing)
    def test_match_collection(self):
        req = Request.blank("/test/1")
        resource = self.dispatch.match(req, self.dispatch.r
rest_routes = [
                                                                                        params_get=None,
                                                                                        method_post=None, 
                                                                                        params_post=None,
                                                                                        method_put=None, 
                                                                                        params_put=None,
                                                                                        method_delete=None,
                                                                                        params_delete=None
                                                                                        ))
        ),
                                                                                        params_get=["page"],
                             

                                                                                        params_post=None,
                                                                                        method_put=None, 
                                                                                        params_put=None,
                                                                                        method_delete=None,
                                                                                        params_delete=None
                                                                                        ))
        ),
                                                                                        method_post=None, 
                                                                                        method_put="create", 
                                                                                        method_delete=None
                                         

        ),
                                                                                        params_get=["id"],
                                                                                        method_post="update", 
                                                                                        params_post=["id"],
                                                                                        method_put="create", 
                                                                                        params_put=["id"],
                                                                                        method_delete="delete",
                                                                                        params_delete=["id"]
                                                                                        ))
        ),
                                                                                        params_get=["id"],
               
"""Standard management interface support
$Id: Management.py,v 1.61 2002/08/14 21:31:40 mj Exp $"""
__version__='$Revision: 1.61 $'[11:-2]
class Tabs(ExtensionClass.Base):
    """Mix-in provides management folder tab support."""
    manage_tabs__roles__=('Anonymous',)
    manage_tabs=DTMLFile('dtml/manage_tabs', globals())
    manage_options  =()
    filtered_manage_options__roles__=None
    def filtered_manage_options(self, REQUEST=None):
        validate=getSecurityManager().validate
        result=[]
        try: options=tuple(self.manage_options)
        except: options=tuple(self.manage_options())
        for d in options:
            filter=d.get('filter', None)
            if filter is not None and not filter(self):
                continue
            path=d.get('path', None)
            if path is None: path=d['action']
            o=self.unrestrictedTraverse(path, None)
            if o is None: continue
            try:
                if validate(None, self, None, o):
      

            except:
                if not hasattr(o, '__roles__'):
                    result.append(d)
        return result
    manage_workspace__roles__=('Authenticated',)
    def manage_workspace(self, REQUEST):
        """Dispatch to first interface in manage_options
        """
        options=self.filtered_manage_options(REQUEST)
        try:
            m=options[0]['action']
            if m=='manage_workspace': raise TypeError
        except:
            raise Unauthorized, (
                'You are not authorized to view this object.')
        if m.find('/'):
            raise 'Redirect', (
                "%s/%s" % (REQUEST['URL1'], m))
        return getattr(self, m)(self, REQUEST)
    def tabs_path_default(self, REQUEST,
                          unquote=urllib.unquote,
                          ):
        steps = REQUEST._steps[:-1]
        script = REQUEST['BASEPATH1']
        linkpat = '<a href="%s/manage_workspace">%s</a>'
        out = []
        url = linkpat % (

        if not steps:
            return url
        last = steps.pop()
        for step in steps:
            script = '%s/%s' % (script, step)
            out.append(linkpat % (script, unquote(step)))
        script = '%s/%s' % (script, last)
        out.append('<a class="strong-link" href="%s/manage_workspace">%s</a>'%
                   (script, unquote(last)))
        return '%s%s' % (url, '/'.join(out))
    def tabs_path_info(self, script, path,
                       quote=urllib.quote,
                       ):
        out=[]
        while path[:1]=='/': path=path[1:]
        while path[-1:]=='/': path=path[:-1]
        while script[:1]=='/': script=script[1:]
        while script[-1:]=='/': script=script[:-1]
        path=path.split('/')[:-1]
        if script: path=[script]+path
        if not path: return ''
        script=''
        last=path[-1]
        del path[-1]
        for p in path:
            script="%s/%s" % (script, quote(p))
            out.append('<a href="%s/
class Config:
    def __init__(self):
        return
    def make_controller(self):
        controllers = { }
        for c in self.config_dict['controllers']:
            cont_dict = self.config_dict['controllers'][c]
            controller_ = controller.Controller()
            controller_.name = c
            controllers[c] = controller_
            controller_.in1.name = cont_dict['in1'][0]
            controller_.in1.min = cont_dict['in1'][1]
            controller_.in1.max = cont_dict['in1'][2]
            for l in cont_dict['in1'][3]:
                controller_.in1.pushling(l)
            controller_.in1.makeling()
            controller_.in2.name = cont_dict['in2'][0]
            controller_.in2.min = cont_dict['in2'][1]
            controller_.in2.max = cont_dict['in2'][2]
            for l in cont_dict['in2'][3]:
                controller_.in2.pushling(l)
            controller_.in2.makeling()
            controller_.out.name = cont_dict['out'][0]
            controller_.ou

            controller_.out.max = cont_dict['out'][2]
            for l in cont_dict['out'][3]:
                controller_.out.pushling(l)
            controller_.out.makeling()
            
            controller_.rulebase.rulebase = cont_dict['rules']
            controller_.integral = cont_dict['integral']
        args = self.config_dict['args']
        return controllers, args
    def read(self, fname):
        lines = filter (lambda x: x!='\n' and x != '', 
                map (lambda x: x.strip(), 
                    tuple(open(fname, 'r')))))
        config = '\n'.join(lines)
        config_dict = { 'args': {}, 'controllers' : {} }
        for entry_match in re.finditer(r'(Controller|Arguments)\s*\(([^]]*)\]\s*\)', 
                config, re.DOTALL):
            etype,ebody = entry_match.groups()
            if etype == 'Controller':
                m = re.match(r'\s*([^,]*)[^[]*\[(.*)', ebody, re.DOTALL)
                cname, cbody = m.groups()
                cont_dict = 

                config_dict['controllers'][cname] = cont_dict
                for param_match in re.finditer(r'\s*([^(]*)\(([^)]*)\)', 
                        cbody, re.DOTALL):
                    pname, pbody = [x.strip() for x in param_match.groups() ]
                    pvals = pbody.split(',')
                    if pname in ['in1','in2','out']:
                        ioname = pvals[0].strip()
                        iomin  = float(pvals[2].strip())
                        iomax  = float(pvals[3].strip())
                        iolist = pvals[1].strip(' {}').split(' ')
                        cont_dict[pname] = [ioname, iomin, iomax, iolist]
                    elif pname == 'rulebase':
                        rules = [ re.sub(r' +', ' ', x.strip(' {}')) 
                                for x in pbody.split('\n') ]
                        rules = [ x.split(' ') for x in rules if x != '']
                        cont_dict['rules'] = rules
                    elif pname == 'int
__author__ = 'christophe'
class RepositoryRouterTests(GitTestHelper):
  def setUp(self):
    GitTestHelper.setUp(self)
    self.config = _createDefaultConfigFile(self.repoPath)
    pluginPackages = {
      IRepositoryRouter: plugins
    }
    self.app = Factory(self.config, pluginPackages)
    self.ssh = reactor.listenTCP(0, self.app.createSSHFactory())
    self.http = reactor.listenTCP(0, self.app.createHTTPFactory())
  def testInitialization(self):
    self.app._invariant()
  def testDefaultScheme(self):
    remoteRepository = self.createTemporaryRepository()
    path = self.app.getRepositoryRouter().route(self.app, ["DEFAULT", remoteRepository.path.split("/")[-1]])
    self.assertEqual(path, remoteRepository.path)
  def testCustomScheme(self):
    projectPath = tempfile.mkdtemp()
    self.app.getConfig().add_section("project")
    self.app.getConfig().set("project", "repositoryPath", projectPath)
    remoteRepository = self.createTemporaryRepository(path=projectPath)
    path = self

    self.assertEqual(path, remoteRepository.path)
    shutil.rmtree(projectPath)
  def testMultipleCustomScheme(self):
    projectPath = tempfile.mkdtemp()
    sandboxPath = tempfile.mkdtemp()
    self.app.getConfig().add_section("project")
    self.app.getConfig().set("project", "repositoryPath", projectPath)
    self.app.getConfig().add_section("sandbox")
    self.app.getConfig().set("sandbox", "repositoryPath", sandboxPath)
    remoteProjectRepository = self.createTemporaryRepository(path=projectPath)
    path = self.app.getRepositoryRouter().route(self.app, ["project", remoteProjectRepository.path.split("/")[-1]])
    self.assertEqual(path, remoteProjectRepository.path)
    remoteSandboxRepository = self.createTemporaryRepository(path=sandboxPath)
    path = self.app.getRepositoryRouter().route(self.app, ["sandbox", remoteSandboxRepository.path.split("/")[-1]])
    self.assertEqual(path, remoteSandboxRepository.path)
    shutil.rmtree(projectPath)
    shutil.rmtree(sandboxPath)
  
serialPort = "/dev/ttyACM0"
controller = Controller(serialPort, 9600, 1)
sensor1 = [0, 0]
sensor2 = [0, 0]
count = [0, 0]
timeOn = 0
sensors = [0, 0]
out = open('SensorOutput', 'w')
try:
    if controller.connected:
        print ("Connected")
        time.sleep(2)
    else:
        print ("Failed to Connect")
        raise KeyboardInterrupt
    controller.writeSteerPacket('S', 90, 90, 90, 90)
    controller.writeDrivePacket('D', 255, 255, 'R', 'R')
    
    while True:
        controller.getSensor(2)
        sensors[0] = controller.currentSensor
        sensor1.append(controller.currentSensor)
        print("One: " + str(controller.currentSensor))
        controller.getSensor(3)
        sensors[1] = controller.currentSensor
        sensor2.append(controller.currentSensor)
        print("Two: " + str(controller.currentSensor))
        timeOn += 0.1
        count.append(timeOn)
        print("Time: "+ str(timeOn))
        time.sleep(0.1)
        out.write(str(sensors[0]) + ',' + str(sen
eventlet.monkey_patch(
    os=True,
    select=True,
    socket=True,
    thread=True,
    time=True)
DATE_FORMAT_STRING = '%Y-%m-%d %H:%M:%S'
class GithubRepositorySensor(PollingSensor):
    def __init__(self, sensor_service, config=None, poll_interval=None):
        super(GithubRepositorySensor, self).__init__(sensor_service=sensor_service,
                                                     config=config,
                                                     poll_interval=poll_interval)
        self._trigger_ref = 'github.repository_event'
        self._logger = self._sensor_service.get_logger(__name__)
        self._client = None
        self._repositories = []
        self._last_event_ids = {}
        self.EVENT_TYPE_WHITELIST = []
    def setup(self):
        config_base_url = self._config.get('base_url', None) or None
        config_token = self._config.get('token', None) or None
        self._client = Github(config_token or None, base_url=config_base_url)
        repository_sen

        if repository_sensor is None:
            raise ValueError('"repository_sensor" config value is required.')
        self.EVENT_TYPE_WHITELIST = repository_sensor.get('event_type_whitelist', [])
        repositories = repository_sensor.get('repositories', None)
        if not repositories:
            raise ValueError('GithubRepositorySensor should have at least 1 repository.')
        for repository_dict in repositories:
            user = self._client.get_user(repository_dict['user'])
            repository = user.get_repo(repository_dict['name'])
            self._repositories.append((repository_dict['name'], repository))
    def poll(self):
        for repository_name, repository_obj in self._repositories:
            self._logger.debug('Processing repository "%s"' %
                               (repository_name))
            self._process_repository(name=repository_name,
                                     repository=repository_obj)
    def _process_repository(self, nam

        """
        Retrieve events for the provided repository and dispatch triggers for
        new events.
        :param name: Repository name.
        :type name: ``str``
        :param repository: Repository object.
        :type repository: :class:`Repository`
        """
        assert(isinstance(name, basestring))
        count = self._config['repository_sensor'].get('count', 30)
        events = repository.get_events()[:count]
        events = list(reversed(list(events)))
        last_event_id = self._get_last_id(name=name)
        for event in events:
            if last_event_id and int(event.id) <= int(last_event_id):
                continue
            self._handle_event(repository=name, event=event)
        if events:
            self._set_last_id(name=name, last_id=events[-1].id)
    def cleanup(self):
        pass
    def add_trigger(self, trigger):
        pass
    def update_trigger(self, trigger):
        pass
    def remove_trigger(self, trigger):
        pass
  
""" The default action set for the scene UI plugin. """
PKG = '.'.join(__name__.split('.')[:-1])
scene_group = Group(
    id='TVTKSceneGroup',
    path='MenuBar/File', before='ExitGroup'
view_group = Group(
    id='TVTKViewGroup',
    path='MenuBar/Tools', before='PreferencesGroup'
new_menu = Menu(
    name='&New',
    path='MenuBar/File', group='TVTKSceneGroup'
save_scene_as_menu = Menu(
    id='SaveSceneAs', name="Sa&ve Scene As",
    path='MenuBar/File', group='TVTKSceneGroup', after='New'
new_scene = Action(
    class_name = PKG + '.actions.NewScene',
    path       = 'MenuBar/File/New', group='additions'
save_scene = Action(
    class_name = PKG + '.actions.SaveScene',
    path       = 'MenuBar/File', group='TVTKSceneGroup', after='SaveSceneAs'
save_scene_to_png = Action(
    class_name = PKG + '.actions.SaveSceneToPNG',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_jpeg = Action(
    class_name = PKG + '.actions.SaveSceneToJPEG',
    path       = 'MenuBar/File/SaveSce

save_scene_to_bmp = Action(
    class_name = PKG + '.actions.SaveSceneToBMP',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_tiff = Action(
    class_name = PKG + '.actions.SaveSceneToTIFF',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_ps = Action(
    class_name = PKG + '.actions.SaveSceneToPS',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_gl2ps = Action(
    class_name = PKG + '.actions.SaveSceneToGL2PS',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_rib = Action(
    class_name = PKG + '.actions.SaveSceneToRIB',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_oogl = Action(
    class_name = PKG + '.actions.SaveSceneToOOGL',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_iv = Action(
    class_name = PKG + '.actions.SaveSceneToIV',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_vrml = Action(
    class_name = PKG + '.actions.SaveSceneToVRML',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_obj

    class_name = PKG + '.actions.SaveSceneToOBJ',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_pov = Action(
    class_name = PKG + '.actions.SaveSceneToPovray',
    path       = 'MenuBar/File/SaveSceneAs'
save_scene_to_x3d = Action(
    class_name = PKG + '.actions.SaveSceneToX3D',
    path       = 'MenuBar/File/SaveSceneAs'
reset_zoom = Action(
    class_name = PKG + '.actions.ResetZoom',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
isometric_view = Action(
    class_name = PKG + '.actions.IsometricView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
x_plus_view = Action(
    class_name = PKG + '.actions.XPlusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
x_minus_view = Action(
    class_name = PKG + '.actions.XMinusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
y_plus_view = Action(
    class_name = PKG + '.actions.YPlusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
y_minus_view = Action(
    class_na
cache = cache_page(60 * 15) if not settings.DEBUG else lambda x: x
FeedbackSubmissionView_view = cache(views.FeedbackSubmissionView.as_view())
ManageCourseListView_view = views.ManageCourseListView.as_view()
ManageNotRespondedListView_view = views.ManageNotRespondedListView.as_view()
UserListView_view = views.UserListView.as_view()
UserFeedbackListView_view = views.UserFeedbackListView.as_view()
UserFeedbackView_view = views.UserFeedbackView.as_view()
RespondFeedbackView_view = views.respond_feedback_view_select(
    views.RespondFeedbackView.as_view(),
    views.RespondFeedbackViewAjax.as_view()
FeedbackTagView_view = views.FeedbackTagView.as_view()
PATH_REGEX = r'[\w\d\-./]'
MANAGE = r'^manage/'
MANAGE_SITE = MANAGE + r'(?P<site_id>\d+)/'
urlpatterns = [
    url(r'^feedback/$',
        FeedbackSubmissionView_view,
        name='submission'),
    url(r'^feedback/(?P<path_key>{path_regex}+)$'.format(path_regex=PATH_REGEX),
        FeedbackSubmissionView_view,
        name='submission')

    url(r'^manage/$',
        views.ManageSiteListView.as_view(),
        name='site-list'),
    url(r'^manage/courses/$',
        ManageCourseListView_view,
        name='course-list'),
    url(r'^manage/courses/(?P<site_id>\d+)/$',
        ManageCourseListView_view,
        name='course-list'),
    url(r'^manage/(?P<course_id>\d+)/clear-cache/$',
        views.ManageClearCacheView.as_view(),
        name='clear-cache'),
    url(r'^manage/(?P<course_id>\d+)/update-studenttags/$',
        views.ManageUpdateStudenttagsView.as_view(),
        name='update-studenttags'),
    url(r'^manage/(?P<course_id>\d+)/unread/$',
        ManageNotRespondedListView_view,
        name='notresponded-course'),
    url(r'^manage/(?P<course_id>\d+)/unread/(?P<path_filter>{path_regex}*)$'.format(path_regex=PATH_REGEX),
        ManageNotRespondedListView_view,
        name='notresponded-course'),
    url(r'^manage/(?P<course_id>\d+)/feedbacks/$',
        views.ManageFeedbacksListView.as_view(),
        name

    url(r'^manage/(?P<course_id>\d+)/user/$',
        UserListView_view,
        name='user-list'),
    url(r'^manage/(?P<course_id>\d+)/byuser/(?P<user_id>\d+)/$',
        UserFeedbackListView_view,
        name='byuser'),
    url(r'^manage/(?P<course_id>\d+)/byuser/(?P<user_id>\d+)/(?P<exercise_id>\d+)/$',
        UserFeedbackView_view,
        name='byuser'),
    url(r'^manage/(?P<course_id>\d+)/byuser/(?P<user_id>\d+)/(?P<exercise_id>\d+)/(?P<path_filter>{path_regex}*)$'.format(path_regex=PATH_REGEX),
        UserFeedbackView_view,
        name='byuser'),
    url(r'^manage/(?P<course_id>\d+)/tags/$',
        views.FeedbackTagListView.as_view(),
        name='tags'),
    url(r'^manage/(?P<course_id>\d+)/tags/(?P<tag_id>\d+)/$',
        views.FeedbackTagEditView.as_view(),
        name='tags-edit'),
    url(r'^manage/(?P<course_id>\d+)/tags/(?P<tag_id>\d+)/remove/$',
        views.FeedbackTagDeleteView.as_view(),
        name='tags-remove'),
    url(r'^manage/respond/(?P<feedback_id
datatypes_repository_name = 'emboss_datatypes_0020'
datatypes_repository_description = "Galaxy applicable data formats used by Emboss tools."
datatypes_repository_long_description = "Galaxy applicable data formats used by Emboss tools.  This repository contains no tools."
emboss_repository_name = 'emboss_0020'
emboss_repository_description = 'Galaxy wrappers for Emboss version 5.0.0 tools'
emboss_repository_long_description = 'Galaxy wrappers for Emboss version 5.0.0 tools'
base_datatypes_count = 0
repository_datatypes_count = 0
class ToolWithRepositoryDependencies( ShedTwillTestCase ):
    '''Test installing a repository with repository dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user wit

        test_user_1_private_role = test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        galaxy_admin_user_private_role = test_db_util.get_galaxy_private_role( galaxy_admin_user )
    def test_0005_ensure_repositories_and_categories_exist( self ):
        '''Create the 0020 category and any missing repositories.'''
  

        category = self.create_category( name='Test 0020 Basic Repository Dependencies', description='Test 0020 Basic Repository Dependencies' )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        datatypes_repository = self.get_or_create_repository( name=datatypes_repository_name, 
                                                              description=datatypes_repository_description, 
                                                              long_description=datatypes_repository_long_description, 
                                                              owner=common.test_user_1_name,
                                                              category_id=self.security.encode_id( category.id ), 
                                                              strings_displayed=[] )
        if self.repository_is_new( datatypes_repository ):
            self.upload_file( datatypes_repository, 'emboss/datatypes/
urlpatterns = patterns('proxynow5_proj.proxynow5.WebProxy.views',
                       (r'^wp/save/$', 'wp_save'),
                       
                       (r'^wpprofile/$', 'wpprofile_page'),
                       (r'^wpprofile/save/$', 'wpprofile_save'),
                       (r'^wpprofile/delete/$', 'wpprofile_delete'),
                       (r'^wpprofile/save/enable/$', 'wpprofile_save_enable'),
                       (r'^wpprofile/save/location/$', 'wpprofile_save_location'),
                       (r'^wpprofile/list/$', 'wpprofile_list'),
                       
                       (r'^wpadvance/$', 'wpadvance_save'),
                       (r'^wpadvanceskip/$', 'wpadvanceskip_page'),
                       (r'^wpadvanceskip/save/$', 'wpadvanceskip_save'),
                       (r'^wpadvanceskip/delete/$', 'wpadvanceskip_delete'),
                       
                       (r'^wpadvanceallow/$', 'wpadvanceallow_page'),
                       (r'^wpadvanceallow/
class RepositoryFactory:
    Type = enum(Invalid=-1, Unknown=0, Subversion=1, Git=2)
    @staticmethod
    def detect_type(path):
        if os.path.isdir(path):
            if SubversionRepository.is_valid(path):
                return RepositoryFactory.Type.Subversion
            elif arsoft.git.GitRepository.find_repository_root(path) is not None:
                return RepositoryFactory.Type.Git
            else:
                return RepositoryFactory.Type.Unknown
        else:
            return RepositoryFactory.Type.Invalid
    @staticmethod
    def create(path, verbose=False, traverse_parent_dirs=False):
        ret = None
        if os.path.isdir(path):
            if ret is None:
                if SubversionRepository.is_valid(path):
                    ret = SubversionRepository(path, verbose=verbose)
            if ret is None:
                if traverse_parent_dirs:
                    repo_path = arsoft.git.GitRepository.find_repository_root(path)
                    
class ControllerFactory(object):
	"""
	Factory of all controllers.
	"""
	@staticmethod
	def createAppController():
		app_controller = AppController()
		app_controller.about_controller = ControllerFactory.createAboutController(app_controller)
		app_controller.documents_controller = ControllerFactory.createDocumentsController(app_controller)
		app_controller.preferences_controller = ControllerFactory.createPreferencesController(app_controller)
		app_controller.initController()
		return app_controller
	@staticmethod
	def createAboutController(app_controller):
		about_controller = AboutController()
		about_controller.app_controller = app_controller
		about_controller.view = ViewFactory.createAboutView(app_controller)
		about_controller.initController()
		return about_controller
	@staticmethod
	def createDocumentController(app_controller, file_path=None):
		doc_controller = DocumentController()
		doc_controller.app_controller = app_controller
		doc_view = ViewFactory.createDocumentView(app_

		if file_path is None:
			doc_model = DocumentFactory.createEmptyDocument()
		else:
			doc_model = DocumentFactory.createDocumentFromFilePath(file_path)
		errors_controller = ControllerFactory.createErrorsController(app_controller, doc_controller, doc_view)
		doc_controller.errors_controller = errors_controller
		preview_controller = ControllerFactory.createPreviewController(app_controller, doc_controller, doc_view)
		doc_controller.preview_controller = preview_controller
		doc_controller.view = doc_view
		doc_controller.model = doc_model
		doc_controller.initController()
		return doc_controller
	@staticmethod
	def createErrorsController(app_controller, doc_controller, doc_view):
		errors_controller = ErrorsController()
		errors_controller.app_controller = app_controller
		errors_controller.doc_controller = doc_controller
		errors_controller.content_view = doc_view.content_view
		errors_controller.errors_view = doc_view.feedback_view.errors_view
		errors_controller.initController()
	
manage_add_openxchange_form = PageTemplateFile('../browser/add_plugin',
                    globals(), __name__='manage_add_openxchange_form' )
def manage_add_openxchange_helper(dispatcher, id, title=None, REQUEST=None):
    """Add an sqlalchemy Helper to the PluggableAuthentication Service."""
    sp = plugin.OpenXChangeHelper(id, title)
    dispatcher._setObject( sp.getId(), sp)
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect( '%s/manage_workspace'
                                      '?manage_tabs_message='
                                      'OpenXChangeHelper+added.'
                                      % dispatcher.absolute_url())
def register_plugin():
    try:
        registerMultiPlugin(plugin.OpenXChangeHelper.meta_type)
    except RuntimeError:
        pass
def register_plugin_class(context):
    context.registerClass(plugin.OpenXChangeHelper,
                          permission = manage_users,
                          constructors = (manage_add_openxc
urlpatterns = patterns('',
    url(r'^pickmeapp/$', 'ordering.passenger_controller.pickmeapp_home', name="pickmeapp"),
    (r'^pickmeapp/$', 'ordering.passenger_controller.passenger_home'),
    (r'^dl/$', 'ordering.passenger_controller.pickmeapp_home'),
    (r'^info$', 'ordering.passenger_controller.info_pages'),
    (r'^workstation/(?P<workstation_id>\d+)$', 'ordering.station_controller.workstation_home'),
    (r'^orders/(?P<order_id>\d+)$', 'ordering.order_manager.order_status'),
    (r'^book_order/$', 'ordering.order_manager.book_order'),
    (r'^orders/history/$', 'ordering.passenger_controller.get_passenger_orders_history'),
    (r'^passenger/profile/$', 'ordering.passenger_controller.profile_page'),
    (r'^passenger/stations/$', 'ordering.passenger_controller.stations_tab'),
    (r'^business_tab/$', 'ordering.passenger_controller.business_tab'),
    (r'^business_registration/$', 'ordering.passenger_controller.business_registration'),
    (r'^station/profile/$', 'ordering.station

    (r'^station/download_workstation/$', 'ordering.station_controller.download_workstation'),
    (r'^station/history/$', 'ordering.station_controller.get_station_orders_history'),
    (r'^station/analytics/$', 'ordering.station_controller.station_analytics'),
    (r'^o/(?P<order_id>\d+)/$', 'ordering.passenger_controller.track_order'),
    (r'^get_order_position/(?P<order_id>\d+)/$', 'ordering.passenger_controller.get_order_position'),
    (r'^passenger/logout/$', 'django.contrib.auth.views.logout'),
    (r'^workstation/logout/$', 'django.contrib.auth.views.logout'),
    (r'^orders/logout/$', 'django.contrib.auth.views.logout'),
    (r'^station/logout/$', 'django.contrib.auth.views.logout'),
    (r'^station/home/logout/$', 'django.contrib.auth.views.logout'),
    (r'^station/(?P<subdomain_name>\w+)/$', 'ordering.station_controller.station_page'),
    (r'^b/$', 'ordering.station_controller.station_business_page'),
    (r'^station/(?P<subdomain_name>\w+)/b/$', 'ordering.station_control

    (r'^station/home/$', 'ordering.station_controller.station_home'),
    (r'^stations/$', 'ordering.station_controller.stations_home'),
    url(r'^stations/login/$', 'django.contrib.auth.views.login' ,
        {'template_name': 'station_home.html'},
        name="station_login"),
    (r'^services/resolve_address/$', 'ordering.passenger_controller.resolve_address'),
    (r'^services/resolve_station_address/$', 'ordering.station_controller.resolve_address'),
    (r'^services/resolve_coordinates/$', 'ordering.passenger_controller.resolve_coordinates'),
    (r'^services/get_order_address/$', 'ordering.passenger_controller.get_order_address'),
    (r'^services/estimate_cost/$', 'ordering.passenger_controller.estimate_ride_cost'),
    (r'^services/book_order/$', 'ordering.passenger_controller.book_order'),
    (r'^services/redispatch_ignored/$', 'ordering.order_manager.redispatch_ignored_orders'),
    (r'^services/redispatch_pending/$', 'ordering.order_manager.redispatch_pending_orders'),

"""Majordomo Protocol Worker API, Python version
Author: Min RK <benjaminrk@gmail.com>
Based on Java example by Arkadiusz Orzechowski
"""
class MajorDomoWorker(object):
    """Majordomo Protocol Worker API, Python version
    """
    broker = None
    ctx = None
    service = None
    reply_to = None
    def __init__(self, broker, service, verbose=False):
        self.broker = broker
        self.service = service
        self.verbose = verbose
        self.ctx = zmq.Context()
        self.poller = zmq.Poller()
        logging.basicConfig(format="%(asctime)s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",
                level=logging.INFO)
        self.reconnect_to_broker()
    def reconnect_to_broker(self):
        """Connect or reconnect to broker"""
        if self.worker:
            self.poller.unregister(self.worker)
            self.worker.close()
        self.worker = self.ctx.socket(zmq.DEALER)
        self.worker.linger = 0
        self.worker.connect(self.broker)
        self.po

        if self.verbose:
            logging.info("I: connecting to broker at %s...", self.broker)
        self.send_to_broker(MDP.W_READY, self.service, [])
        self.liveness = self.HEARTBEAT_LIVENESS
        self.heartbeat_at = time.time() + 1e-3 * self.heartbeat
    def send_to_broker(self, command, option=None, msg=None):
        """Send message to broker.
        If no msg is provided, creates one internally
        """
        if msg is None:
            msg = []
        elif not isinstance(msg, list):
            msg = [msg]
        if option:
            msg = [option] + msg
        msg = ['', MDP.W_WORKER, command] + msg
        if self.verbose:
            logging.info("I: sending %s to broker", command)
            dump(msg)
        self.worker.send_multipart(msg)
    def recv(self, reply=None):
        """Send reply, if any, to broker and wait for next request."""
        assert reply is not None or not self.expect_reply
        if reply is not None:
            assert

            reply = [self.reply_to, ''] + reply
            self.send_to_broker(MDP.W_REPLY, msg=reply)
        self.expect_reply = True
        while True:
            try:
                items = self.poller.poll(self.timeout)
            except KeyboardInterrupt:
            if items:
                msg = self.worker.recv_multipart()
                if self.verbose:
                    logging.info("I: received message from broker: ")
                    dump(msg)
                self.liveness = self.HEARTBEAT_LIVENESS
                assert len(msg) >= 3
                empty = msg.pop(0)
                assert empty == ''
                header = msg.pop(0)
                assert header == MDP.W_WORKER
                command = msg.pop(0)
                if command == MDP.W_REQUEST:
                    self.reply_to = msg.pop(0)
                    assert msg.pop(0) == ''
                elif command == MDP.W_HEARTBEAT:
                    pass
                elif command == MD
'''
Common command line tool
'''
def print_help_exit(msg = ''):
    if msg:
        print msg    
    print '''
    usage: tee {plot|data|eval|ext|help} [-h] [<arg1>,<arg2>,...]
      plot     Plotting script
      data     Dataset management script
      eval     Evaluation script
      ext      Extraction management script
      help     Print out help text for the tee command
     
    flags:
      -h       Print out help text for the selected script
    '''
    sys.exit(-1)
def main():
    args = sys.argv[1:]
    if len(args) == 0:
        print_help_exit('Not enough arguments')
    if args[0] not in ('plot','data','eval','ext','help'):
        print_help_exit('Unknown command')      
          
    if args[0] == 'help':
        print_help_exit()
    elif args[0] == 'plot':
        plot_manage.main(args[1:])
    elif args[0] == 'data':
        dataset_manage.main(args[1:])
    elif args[0] == 'eval':
        evaluate_manage.main(args[1:])
    elif args[0] == 'ext':
        extract_
class ManageShiftPage(BasePage):
    shift_page = PageUrls.manage_volunteer_shift_page
    shift_assignment_text = 'Assign Shift'
    no_volunteer_shift_message = 'This volunteer does not have any upcoming shifts.'
    live_server_url = ''
    def __init__(self, driver):
        self.driver = driver
        self.home_page = HomePage(self.driver)
        self.sign_up_elements = EventSignUpPageLocators()
        self.manage_elements = ManageShiftPageLocators()
        super(ManageShiftPage, self).__init__(driver)
    def navigate_to_manage_shift_page(self):
        self.get_page(self.live_server_url, self.shift_page)
    def submit_form(self):
        self.element_by_xpath(self.manage_elements.SUBMIT_PATH).submit()
    def assign_shift(self):
        self.click_link(self.shift_assignment_text)
    def select_volunteer(self, number):
        link_path = '//table//tbody//tr[' + str(number) + ']//td[10]//a'
        self.element_by_xpath(link_path).click()
    def navigate_to_shift_assignmen

        self.element_by_xpath(self.sign_up_elements.VIEW_JOBS_PATH + "//a").click()
        self.element_by_xpath(self.sign_up_elements.VIEW_SHIFTS_PATH + "//a").click()
        self.element_by_xpath(self.sign_up_elements.ASSIGN_SHIFTS_PATH + "//a").click()
    def get_info_box(self):
        return self.element_by_class_name(self.manage_elements.INFO_BOX).text
    def find_table_row(self):
        return self.element_by_tag_name('tr')
    def get_cancel_shift(self):
        return self.element_by_xpath(self.manage_elements.CANCEL_SHIFT_PATH)
    def cancel_shift(self):
        self.element_by_xpath(self.manage_elements.CANCEL_SHIFT_PATH + "//a").click()
    def get_cancellation_box(self):
        return self.element_by_class_name(self.manage_elements.CANCELLATION_PANEL)
    def get_cancellation_header(self):
        return self.element_by_class_name(self.manage_elements.CANCELLATION_HEAD).text
    def get_cancellation_message(self):
        return self.element_by_class_name(self.mana
"""Create sinusoidal grating stimulus and allow control with gratingPyroGUI
"""
VisionEgg.start_default_logging(); VisionEgg.watch_exceptions()
pyro_server = PyroServer()
screen = get_default_screen()
stimulus = SinGrating2D()
viewport = Viewport(screen=screen,stimuli=[stimulus])
p = Presentation(viewports=[viewport])
tf_controller = PyroConstantController(during_go_value=0.0)
pyro_server.connect(tf_controller,'tf_controller')
p.add_controller(stimulus,'temporal_freq_hz', tf_controller)
sf_controller = PyroConstantController(during_go_value=0.0)
pyro_server.connect(sf_controller,'sf_controller')
p.add_controller(stimulus,'spatial_freq', sf_controller)
contrast_controller = PyroConstantController(during_go_value=0.0)
pyro_server.connect(contrast_controller,'contrast_controller')
p.add_controller(stimulus,'contrast', contrast_controller)
orient_controller = PyroConstantController(during_go_value=0.0)
pyro_server.connect(orient_controller,'orient_controller')
p.add_controller(stimulus,'or
RESPONSE_BLANK = """(function(){})();"""
REMOTE_IP = 'remote_ip'
REFERER = 'Referer'
USER_AGENT = 'User-Agent'
def urlsafe_b64encode(string):
    encoded = base64.urlsafe_b64encode(string)
    return encoded.replace( '=', '')
def urlsafe_b64decode(s):
    mod4 = len(s) % 4
    if mod4:
        s += ((4 - mod4) * '=')
    return base64.urlsafe_b64decode(str(s))
class DefaultHandler(tornado.web.RequestHandler):
    def get(self, *args, **kwargs):
        logger.debug( self.request )
        self.write(RESPONSE_BLANK)
    
class Application(tornado.web.Application):
    def __init__(self, broker):
        handlers = [
            (r'/v',SuperShowHandler, dict(broker = broker)),
            (r'/s',SuperShowHandler, dict(broker = broker)),
            (r'/click',SuperClickHandler, dict(broker = broker)),
            (r'/c',SuperClickHandler, dict(broker = broker)),
            (r'/wbshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/wbclick.*',SuperClickHandler, dict(broker =

            (r'/gdtshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/gdtclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/inmoshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/inmoclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/soshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/soclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/tshow',SuperShowHandler, dict(broker = broker)),
            (r'/tclick',SuperClickHandler, dict(broker = broker)),
            (r'/ayclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/ayshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/ykclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/ykshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/mgclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/mgshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/amshow.*',SuperSh

            (r'/amclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/tdshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/tdclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/saxshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/saxclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/besshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/besclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/jxshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/jxclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/mzshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/mzclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/gyshow.*',SuperShowHandler, dict(broker = broker)),
            (r'/gyclick.*',SuperClickHandler, dict(broker = broker)),
            (r'/(.*)',DefaultHandler)
        ]
        tornado.web.Application.__init__(self,han
"""AppAssure 5 REST API"""
class IRepositoryManagement(AppAssureAPI):
    """Full documentation online at
    http://docs.appassure.com/display/AA50D/IRepositoryManagement
    """
    def getConfiguration(self):
        """Retrieves the current configuration of the repository
        service.
        """
        return self.session.request('reposManagement/config')
    def setConfiguration(self, data):
        """Sets the configuration of the repository service."""
        return self.session.request('reposManagement/config', 'POST',
                    self.getXML(data, 'reposServiceConfig'))
    def applyDefaultDeduplicationCacheConfiguration(self):
        """Create default deduplication cache configuration."""
        return self.session.request('reposManagement/defaults', 'PUT')
    def getFreeDiskSpace(self, data):
        """Gets the free space in the directory or UNC share."""
        return self.session.request('reposManagement/getFreeDiskSpace', 'POST',
                    se

    def create(self, data):
        """Creates a new repository."""
        return self.session.request('reposManagement/repositories', 'PUT',
                    self.getXML(data, 'newRepos'))
    def getRepositories(self):
        """Gets a list of all repositories, including
        configuration and status.
        """
        return self.session.request('reposManagement/repositories')
    def updateWriteCachePolicy(self, data, repositoryId):
        """Updates files write caching policies."""
        return self.session.request('reposManagement/repositories/%s/writePolicy'
                % (repositoryId), 'PUT',
                    self.getXML(data, 'reposUpdateWriteCachingPolicies'))
    def verifyFileSpecifications(self, data):
        """Verifies paths and free space on the specified devices."""
        return self.session.request('reposManagement/repositories/verifyFileSpecifications', 'POST',
                    self.getXML(data, 'reposFilesSpec'))
    def verifyNetworkCred

        """Verifies network credentials for specified paths."""
        return self.session.request('reposManagement/repositories/verifyNetworkCredentials', 'POST',
                    self.getXML(data, 'reposFilesSpec'))
    def getRepositoryById(self, id):
        """Gets the configuration and status information for a
        repository.
        """
        return self.session.request('reposManagement/repositories/%s/id'
                % (id))
    def getRepositoryUsage(self, id):
        """Gets the current uses of a specified repository."""
        return self.session.request('reposManagement/repositories/%s/usage'
                % (id))
    def deleteRepository(self, repositoryId):
        """Deletes the specified repository and all data therein."""
        return self.session.request('reposManagement/repositories/%s'
                % (repositoryId))
    def renameRepository(self, repositoryId, newReposName):
        """Renames a repository."""
        return self.session.requ
log = logging.getLogger( __name__ )
repository_name = 'filtering_0530'
repository_description = 'Filtering repository for test 0530'
repository_long_description = 'This is the filtering repository for test 0530.'
category_name = 'Test 0530 Repository Admin Role'
category_description = 'Verify the functionality of the code that handles the repository admin role.'
'''
1. Create new repository as user user1.
2. Check to make sure a new role was created named <repo_name>_user1_admin.
3. Check to make sure a new repository_role_association record was created with appropriate repository id and role id.
4. Change the name of the repository created in step 1 - this can be done as long as the repository has not been installed or cloned.
5. Make sure the name of the role initially inspected in Step 2 has been changed to reflect the new repository name from Step 4.
6. Log into the Tool Shed as a user that is not the repository owner (e.g., user2) and make sure the repository name
   and descripti

7. As user user1, add user user2 as a repository admin user.
8. Log into the Tool Shed as user user2 and make sure the repository name and description can now be changed.
'''
class TestRepositoryAdminRole( ShedTwillTestCase ):
    '''Verify that the code correctly handles the repository admin role.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_email
        self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.test_user_2_email, username=common.test_user_2_name )
        test_user_2 = self.test_db_util.get_user( common.test_user_2_email )
        assert test_user_2 is not None, 'Problem retr

        self.test_db_util.get_private_role( test_user_2 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
    def test_0005_create_filtering_repository( self ):
        """Create and populate the filtering_0530 repository."""
        '''
        This is step 1 - Create new repository as user user1.
        '''
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=repository_name,
                                                    description=repository_description,
                      
"""Define helpers for Django signals"""
def _default_dispatch_uid(receiver):
    return '{}.{}'.format(APP_NAME, receiver.__name__)
def unique_receiver(*args, **kwargs):
    """Decorate by wrapping `django.dispatch.receiver` to set `dispatch_uid` automatically
    Purpose:
        This decorator eliminates the need to set `dispatch_uid` for a Django
        receiver manually. You would want to set `dispatch_uid` to prevent a
        receiver from being run twice.
    Usage:
        Simply substitute this decorator for `django.dispatch.receiver`. If
        you define `dispatch_uid` yourself, this decorator will use that
        supplied value instead of the receiver function's name.
    Implementation Notes:
        - The default value for `dispatch_uid` (if you do not provide it
          yourself) is ‘ctflex’ composed with the receiver function’s name.
    """
    def decorator(receiver):
        default_dispatch_uid = _default_dispatch_uid(receiver)
        kwargs.setdefault('dispat
starting_queue = None
stopping_queue = None
WORKER_NAME = 'TestWorker'
def make_broker(manager, worker_model, start_queue=None, stop_queue=None):
    global starting_queue
    global stopping_queue
    starting_queue = start_queue
    stopping_queue = stop_queue
    return manager_worker_broker.get(worker_model, manager, _TestWorker)
class _TestWorker(manager_worker_broker.AbstractWorker):
    def __init__(self, worker_connection, worker_arguments=None):
        super(_TestWorker, self).__init__(worker_connection)
        self._name = WORKER_NAME
        self._thing_to_greet = 'everybody'
        self._starting_queue = starting_queue
        self._stopping_queue = stopping_queue
    def set_inline_arguments(self, thing_to_greet):
        self._thing_to_greet = thing_to_greet
    def handle_stop(self, src):
        self.stop_handling_messages()
    def handle_test(self, src, an_int, a_str):
        assert an_int == 1
        assert a_str == "hello, world"
        self._worker_connection

    def run(self):
        if self._starting_queue:
            self._starting_queue.put('')
        if self._stopping_queue:
            self._stopping_queue.get()
        try:
            super(_TestWorker, self).run()
        finally:
            self._worker_connection.post_message('done')
class FunctionTests(unittest.TestCase):
    def test_get__inline(self):
        self.assertTrue(make_broker(self, 'inline') is not None)
    def test_get__processes(self):
        if sys.platform in ('cygwin', 'win32'):
            return
        self.assertTrue(make_broker(self, 'processes') is not None)
    def test_get__unknown(self):
        self.assertRaises(ValueError, make_broker, self, 'unknown')
class _TestsMixin(object):
    """Mixin class that implements a series of tests to enforce the
    contract all implementations must follow."""
    def name(self):
        return 'TesterManager'
    def is_done(self):
        return self._done
    def handle_done(self, src):
        self._done =

    def handle_test(self, src, an_int, a_str):
        self._an_int = an_int
        self._a_str = a_str
    def handle_exception(self, src, exception_type, exception_value, stack):
        raise exception_type(exception_value)
    def setUp(self):
        self._an_int = None
        self._a_str = None
        self._broker = None
        self._done = False
        self._exception = None
        self._worker_model = None
    def make_broker(self, starting_queue=None, stopping_queue=None):
        self._broker = make_broker(self, self._worker_model, starting_queue,
                                   stopping_queue)
    def test_name(self):
        self.make_broker()
        worker = self._broker.start_worker()
        self.assertEquals(worker.name(), WORKER_NAME)
        worker.cancel()
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
    def test_cancel(self):
        self.make_broker()
        worker = self._broker.start_worker()
        worker.cancel()
        sel
USAGE_TEXT = """\
  nimbusctl [target] command
Omit the target to perform the command for all targets.
Targets:
%(targets)s\
Commands:
%(commands)s\
"""
NIMBUS_HOME = os.getenv("NIMBUS_HOME")
if not NIMBUS_HOME:
    sys.exit("The NIMBUS_HOME environment variable is not set!")
if not os.path.isdir(NIMBUS_HOME):
    sys.exit("$NIMBUS_HOME does not exist: "+ NIMBUS_HOME)
CONFIG_PATH = os.path.join(NIMBUS_HOME, 'nimbus-setup.conf')
_NO_CONFIG_ERROR = """
Could not find the Nimbus setup config file:
    %s
This file is created after successful completion of the nimbus-configure
program. You should try running nimbus-configure before using this program.
""" % CONFIG_PATH
config = ConfigParser.SafeConfigParser()
if not config.read(CONFIG_PATH):
    sys.exit(_NO_CONFIG_ERROR)
broker_enabled = config.getboolean('nimbussetup', 'broker.enabled')
if not (broker_enabled):
    sys.exit("Broker is not enabled. "+
            "See the '%s' config file to adjust this setting." % CONFIG_PATH)
try:
    s
class Repository(RepositoryBase, RepositoryActions):
    '''
    classdocs
    '''
    def __init__(self, repositoryType=None, locations=list(), usage=list(), path=None, properties=list(), cloud=None, size=None):
        '''
        Constructor
        @param repositoryType: repositoryType minOccurs=0
        @type repositoryType: string
        @param locations: locations minOccurs=0 maxOccurs=unbounded
        @type locations: string
        @param usage: usage minOccurs=0 maxOccurs=unbounded
        @type usage: RepositoryUsage
        @param path: path minOccurs=0
        @type path: string
        @param properties: properties minOccurs=0 maxOccurs=unbounded
        @type properties: Property
        @param cloud: cloud minOccurs=0
        @type cloud: Link
        @param size: size minOccurs=0
        @type size: long
        '''
        RepositoryBase.__init__(self, repositoryType=repositoryType, locations=locations, usage=usage, path=path, properties=properties, cloud=cloud, si
urlpatterns = patterns('trans.manage.views',
    url(r'^$', 'Index', name='manage_index'),
    url(r'^addbook/$', 'AddBook', name='manage_addbook'),
    url(r'^addtoc/book/(?P<book>[^/]*)/$', 'AddToc', name='manage_addtoc'),
    url(r'^addlang/$', 'AddLang', name='manage_addlang'),
	url(r'^listbooks/$', 'ListBooks', name='manage_listbooks'),
    url(r'^editbook/(?P<slug>[^/]*)/$', 'EditBook', name='manage_editbook'),
    url(r'^edittoc/book/(?P<book>[^/]*)/toc/(?P<toc>[^/]*)/$', 'EditToc', name='manage_edittoc'),
    url(r'^deltoc/book/(?P<book>[^/]*)/toc/(?P<toc>[^/]*)/$', 'DelToc', name='manage_deltoc'),
urlpatterns += patterns('trans.manage.ajax',
	url(r'^check/book_slug_unique/$', 'BookSlugUnique'),
	url(r'^ajax/get_toclist/$', 'GetToclist'),
    url(r'^ajax/del_para/(?P<para_id>[^/]*)/$', 'DelParagraph'),
    url(r'^ajax/save_paras/$', 'SaveParagraphs'),
    url(r'^ajax/info_para/$', 'InfoParagraph'),
urlpatterns += patterns('trans.manage.authviews',
	url(r'^login/$', 'Login', nam
SConscript(dirs=['lib', 'src'])
env = DefaultEnvironment()
env.Alias('controller/test', [
    'controller/src/agent:test',
    'controller/src/analytics:test',
    'controller/src/base:test',
    'controller/src/bfd:test',
    'controller/src/bgp:test',
    'controller/src/control-node:test',
    'controller/src/db:test',
    'controller/src/discovery:test',
    'controller/src/dns:test',
    'controller/src/gendb:test',
    'controller/src/ifmap:test',
    'controller/src/io:test',
    'controller/src/net:test',
    'controller/src/query_engine:test',
    'controller/src/schema:test',
    'controller/src/xmpp:test',
])
env.Alias('controller/flaky-test', [
    'controller/src/agent:flaky-test',
    'controller/src/analytics:flaky-test',
    'controller/src/base:flaky-test',
    'controller/src/bfd:flaky-test',
    'controller/src/bgp:flaky-test',
    'controller/src/db:flaky-test',
    'controller/src/dns:flaky-test',
    'controller/src/gendb:flaky-test',
    'controller/src/ifmap:fla
"""Initialize CMFFormController"""
GLOBALS = globals()
def initialize(context):
    tools = (FormController.FormController,)
    ToolInit('Form Controller Tool',
             tools=tools,
             icon='tool.gif',
            ).initialize( context )
    context.registerClass(
        ControllerPageTemplate.ControllerPageTemplate,
        constructors=(ControllerPageTemplate.manage_addControllerPageTemplateForm,
                      ControllerPageTemplate.manage_addControllerPageTemplate),
        icon='www/cpt.gif',
        )
    context.registerClass(
        ControllerPythonScript.ControllerPythonScript,
        constructors=(ControllerPythonScript.manage_addControllerPythonScriptForm,
                      ControllerPythonScript.manage_addControllerPythonScript),
        icon='www/cpy.gif',
        )
    context.registerClass(
        ControllerValidator.ControllerValidator,
        constructors=(ControllerValidator.manage_addControllerValidatorForm,
                      Contr
"""This module provides container classes and interfaces
for inserting data into the database.
Created on Jul 9, 2013
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class ObservableBroker(BrokerBase):
  """
  This broker handles all operations on event objects
  """
  def __init__(self, session):
    BrokerBase.__init__(self, session)
  def get_broker_class(self):
    """
    overrides BrokerBase.get_broker_class
    """
    return Observable
  def get_by_id_and_event_id(self, identifier, event_id):
    try:
      result = self.session.query(Observable).filter(and_(Observable.identifier == identifier, Observable.event_id == event_id)).one()
    except sqlalchemy.orm.exc.NoResultFound:
      raise NothingFoundException('No observable found with ID :{0} in event with ID {1}'.format(identifier, event_id))
    except sqlalchemy.orm.exc.MultipleResultsFound:
      raise TooManyResu
class TestDjango(ApiTestCase):
    def test_django_manage_simple_command(self):
        django.manage('test')
        self.assertSudo('python manage.py test --noinput',
            user=DeployUser.sudo_identity())
    def test_django_manage_command_with_args(self):
        django.manage('test', ['--arg1 234', '--arg2 foo'])
        self.assertSudo('python manage.py test --noinput --arg1 234 --arg2 foo',
            user=DeployUser.sudo_identity())
    def test_django_manage_command_with_input(self):
        django.manage('test', ['--arg1 234', '--arg2 foo'], noinput=False)
        self.assertSudo('python manage.py test --arg1 234 --arg2 foo',
            user=DeployUser.sudo_identity())
    def test_django_manage_dont_use_sudo(self):
        django.manage('test', use_sudo=False)
        self.assertRun('python manage.py test --noinput')
    def test_django_manage_use_sudo_with_user(self):
        django.manage('test', use_sudo=True, user='dave')
        self.assertSudo('python manage.py
class BrokerManager(Console):
  def __init__(self, host, mechanism):
    self.url = host
    self.objects = {}
    self.filter  = None
    self.session = Session(self, rcvEvents=False, rcvHeartbeats=False,
                           userBindings=True, manageConnections=True)
    self.broker  = self.session.addBroker(self.url, None, mechanism)
    self.firstError = True
  def setFilter(self,filter):
    self.filter = filter
  def brokerConnected(self, broker):
    if not self.firstError:
      print "*** Broker connected"
    self.firstError = False
  def brokerDisconnected(self, broker):
    print "*** Broker connection lost - %s, retrying..." % broker.getError()
    self.firstError = False
    self.objects.clear()
  def objectProps(self, broker, record):
    className = record.getClassKey().getClassName()
    if className != "queue":
      return
    id = record.getObjectId().__repr__()
    if id not in self.objects:
      self.objects[id] = (record.name, None, None)
  def objectStats

    className = record.getClassKey().getClassName()
    if className != "queue":
      return
    id = record.getObjectId().__repr__()
    if id not in self.objects:
      return
    (name, first, last) = self.objects[id]
    if first == None:
      self.objects[id] = (name, record, None)
      return
    if len(self.filter) > 0 :
      match = False
      for x in self.filter:
        if x.match(name):                 
          match = True
          break
      if match == False:
        return
    if last == None:
      lastSample = first
    else:
      lastSample = last
    self.objects[id] = (name, first, record)
    deltaTime   = float (record.getTimestamps()[0] - lastSample.getTimestamps()[0])
    if deltaTime < 1000000000.0:
      return
    enqueueRate = float (record.msgTotalEnqueues - lastSample.msgTotalEnqueues) / \
        (deltaTime / 1000000000.0)
    dequeueRate = float (record.msgTotalDequeues - lastSample.msgTotalDequeues) / \
        (deltaTime / 1000000000.0)
   

        (name, deltaTime / 1000000000, record.msgDepth, enqueueRate, dequeueRate)
    sys.stdout.flush()
  def Display (self):
    self.session.bindClass("org.apache.qpid.broker", "queue")
    print "Queue Name                                     Sec       Depth     Enq Rate     Deq Rate"
    print "========================================================================================"
    sys.stdout.flush()
    try:
      while True:
        sleep (1)
        if self.firstError and self.broker.getError():
          self.firstError = False
          print "*** Error: %s, retrying..." % self.broker.getError()
    except KeyboardInterrupt:
      print
    self.session.delBroker(self.broker)
def main(argv=None):
  p = optparse.OptionParser()
  p.add_option('--broker-address','-a', default='localhost' , help='broker-addr is in the form:  [username/password@] hostname | ip-address [:<port>] \n ex:  localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost')
  p.add_option('--fi
PACKAGE_REGEX = r'(?P<package>[^//]+)'
VERSION_REGEX = r'(?P<version>[\w\d_\.\-]+)'
urlpatterns = patterns("packageindex.views",
    url(r'^$', "root", name="packageindex-root"),
    url(r'^packages/$','packages.index', name='packageindex-package-index'),
    url(r'^simple/$','packages.simple_index', name='packageindex-package-index-simple'),
    url(r'^search/$','packages.search',name='packageindex-search'),
    url(r'^pypi/$', 'root', name='packageindex-release-index'),
    url(r'^rss/$', ReleaseFeed(), name='packageindex-rss'),
    
    url(r'^simple/' + PACKAGE_REGEX + r'/$','packages.simple_details',
        name='packageindex-package-simple'),
    
    url(r'^pypi/' + PACKAGE_REGEX + r'/$','packages.details',
        name='packageindex-package'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/rss/$', ReleaseFeed(),
        name='packageindex-package-rss'),    
    url(r'^pypi/' + PACKAGE_REGEX + r'/doap.rdf$','packages.doap',
        name='packageindex-package-doap'),
    url(r'^pypi/' +

        name='packageindex-package-manage'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/manage/versions/$','packages.manage_versions',
        name='packageindex-package-manage-versions'),
    
    url(r'^pypi/' + PACKAGE_REGEX + r'/' + VERSION_REGEX + r'/$',
        'releases.details',name='packageindex-release'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/' + VERSION_REGEX + r'/doap.rdf$',
        'releases.doap',name='packageindex-release-doap'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/' + VERSION_REGEX + r'/manage/$',
        'releases.manage',name='packageindex-release-manage'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/' + VERSION_REGEX + r'/metadata/$',
        'releases.manage_metadata',name='packageindex-release-manage-metadata'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/' + VERSION_REGEX + r'/files/$',
        'releases.manage_files',name='packageindex-release-manage-files'),
    url(r'^pypi/' + PACKAGE_REGEX + r'/' + VERSION_REGEX + r'/files/upload/$',
        'releases.upload_file',name
def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('paths', nargs='+')
    parser.add_argument('-o', '--out', default='save.zip')
    args = parser.parse_args()
    return args
def zip_save(args):
    temp_dir = "."
    save_dir = os.path.join(temp_dir, "save")
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    for save_source_path in tqdm(args.paths):
        _, model_name = os.path.split(model_dir)
        cur_dir = os.path.join(save_dir, model_name)
        if not os.path.exists(cur_dir):
            os.makedirs(cur_dir)
        save_target_path = os.path.join(cur_dir, "save")
        shared_target_path = os.path.join(cur_dir, "shared.json")
        readme_path = os.path.join(cur_dir, "readme.txt")
        shared_source_path = os.path.join(model_dir, "shared.json")
        shutil.copy(save_source_path, save_target_path)
        shutil.copy(shared_source_path, shared_target_path)
        with open(readme_path, 'w') as fh:
            fh
QUEUE_FORMAT = """
. %(name)s -> exchange:%(exchange)s (%(exchange_type)s) \
binding:%(binding_key)s
"""
BROKER_FORMAT = "%(carrot_backend)s://%(userid)s@%(host)s%(port)s%(vhost)s"
TIME_UNITS = (("day", 60 * 60 * 24, lambda n: int(math.ceil(n))),
              ("hour", 60 * 60, lambda n: int(math.ceil(n))),
              ("minute", 60, lambda n: int(math.ceil(n))),
              ("second", 1, lambda n: "%.2f" % n))
def humanize_seconds(secs, prefix=""):
    """Show seconds in human form, e.g. 60 is "1 minute", 7200 is "2
    hours"."""
    for unit, divider, formatter in TIME_UNITS:
        if secs >= divider:
            w = secs / divider
            punit = w > 1 and (unit + "s") or unit
            return "%s%s %s" % (prefix, formatter(w), punit)
    return "now"
def textindent(t, indent=0):
    """Indent text."""
    return "\n".join(" " * indent + p for p in t.split("\n"))
def format_queues(queues, indent=0):
    """Format routing table into string for log dumps."""
    format = 

    info = "\n".join(format(name=name, **config)
                            for name, config in queues.items())
    return textindent(info, indent=indent)
def get_broker_info(broker_connection=None):
    if broker_connection is None:
        broker_connection = establish_connection()
    carrot_backend = broker_connection.backend_cls
    if carrot_backend and not isinstance(carrot_backend, str):
        carrot_backend = carrot_backend.__name__
    carrot_backend = carrot_backend or "amqp"
    port = broker_connection.port or \
                broker_connection.get_backend_cls().default_port
    port = port and ":%s" % port or ""
    vhost = broker_connection.virtual_host
    if not vhost.startswith("/"):
        vhost = "/" + vhost
    return {"carrot_backend": carrot_backend,
            "userid": broker_connection.userid,
            "host": broker_connection.hostname,
            "port": port,
            "vhost": vhost}
def format_broker_info(info=None):
    """Get message broker
class BaseContentMixin(CatalogMultiplex,
                       BaseObject,
                       PortalContent,
                       Historical):
    """A not-so-basic CMF Content implementation that doesn't
    include Dublin Core Metadata"""
    __implements__ = z2IBaseContent, IReferenceable, PortalContent.__implements__
    implements(IBaseContent)
    security = ClassSecurityInfo()
    manage_options = PortalContent.manage_options + Historical.manage_options
    isPrincipiaFolderish = 0
    isAnObjectManager = 0
    __dav_marshall__ = True
    security.declarePrivate('manage_afterAdd')
    def manage_afterAdd(self, item, container):
        BaseObject.manage_afterAdd(self, item, container)
        CatalogMultiplex.manage_afterAdd(self, item, container)
    security.declarePrivate('manage_afterClone')
    def manage_afterClone(self, item):
        BaseObject.manage_afterClone(self, item)
        CatalogMultiplex.manage_afterClone(self, item)
    security.declarePrivate('manage_

    def manage_beforeDelete(self, item, container):
        BaseObject.manage_beforeDelete(self, item, container)
        CatalogMultiplex.manage_beforeDelete(self, item, container)
        self._v_cp_refs = None
    def _notifyOfCopyTo(self, container, op=0):
        """OFS.CopySupport notify
        """
        BaseObject._notifyOfCopyTo(self, container, op=op)
        PortalContent._notifyOfCopyTo(self, container, op=op)
    security.declareProtected(permissions.ModifyPortalContent, 'PUT')
    PUT = WebDAVSupport.PUT
    security.declareProtected(permissions.View, 'manage_FTPget')
    manage_FTPget = WebDAVSupport.manage_FTPget
    security.declarePrivate('manage_afterPUT')
    manage_afterPUT = WebDAVSupport.manage_afterPUT
InitializeClass(BaseContentMixin)
class BaseContent(BaseContentMixin,
                  ExtensibleMetadata,
                  PropertyManager):
    """A not-so-basic CMF Content implementation with Dublin Core
    Metadata included"""
    __implements__ = BaseC
class Repository:
    
    def __init__(self):
        self.datasets = []
    
    
    def list(self):
        return self.datasets
        
    
class GitHubRepository(Repository):
    
    def __init__(self, repository_type, username):
        Repository.__init__(self)
        
        repository_request_url = 'https://api.github.com/{}/{}/repos'.format(repository_type,username)
        
        r = requests.get(repository_request_url)
        
        if r.ok :
            github_datasets = json.loads(r.text or r.content)
            
            for dataset in github_datasets:
                identifier = url = dataset['clone_url']
                name = dataset['name']
                description = dataset['description']
                
                self.datasets.append({'identifier': identifier,
                                      'url': url,
                                      'name': name,
                                      'description': description})
        else 
class OnceSaveStrategy(Vertex):
    """
    Should be enforced on vid
    """
class OnChangeSaveStrategy(Vertex):
    val = properties.Integer(save_strategy=properties.SAVE_ONCHANGE)
class AlwaysSaveStrategy(Vertex):
    val = properties.Integer(save_strategy=properties.SAVE_ALWAYS)
class ModelLevelSaveStrategy(Vertex):
    __default_save_strategy__ = properties.SAVE_ONCHANGE
    
    val = properties.Integer()
class DefaultModelLevelSaveStrategy(Vertex):
    val = properties.Integer()
    
class TestOnceSaveStrategy(BaseThunderdomeTestCase):
    def test_should_be_able_to_resave_with_once_strategy(self):
        """Once save strategy should allow saving so long as columns haven't changed'"""
        v = OnceSaveStrategy.create()
        assert 'vid' not in v.as_save_params()
        v.save()
        
    def test_should_enforce_once_save_strategy(self):
        """Should raise SaveStrategyException if once save strategy violated"""
        v = OnceSaveStrategy.create()
        v.vid =

        with self.assertRaises(SaveStrategyException):
            v.save()
            
class TestOnChangeSaveStrategy(BaseThunderdomeTestCase):
    def test_should_be_able_to_save_columns_with_on_change(self):
        """Should be able to resave models with on change save policy"""
        v = OnChangeSaveStrategy.create(val=1)
        v.save()
    def test_should_persist_changes_with_on_change_strategy(self):
        """Should still persist changes with onchange save strategy"""
        v = OnChangeSaveStrategy.create(val=1)
        assert 'val' not in v.as_save_params()
        v.val = 2
        assert 'val' in v.as_save_params()
        v.save()
        v1 = OnChangeSaveStrategy.get(v.vid)
        assert v1.val == 2
        
class TestAlwaysSaveStrategy(BaseThunderdomeTestCase):
    def test_should_be_able_to_save_with_always(self):
        """Should be able to save with always save strategy"""
        v = AlwaysSaveStrategy.create(val=1)
        assert 'val' in v.as_save_params(
try:
except ImportError:
class ZopeVersion(Version.Version, RoleManager, OFS.SimpleItem.Item):
    """The ZopeVersion class builds on the core Version class to provide
       the Zope management interface and other product trappings."""
    security = AccessControl.ClassSecurityInfo()
    security.setDefaultAccess('deny')
    meta_type = 'Version'
    manage_options=(
        ( {'label': 'Information',  'action':'manage_main',
           'help': ('ZopeVersionControl', 'Version-Manage.stx')},
          {'label': 'Properties', 'action':'manage_properties_form',
           'help': ('ZopeVersionControl', 'Version-Properties.stx')},
        ) +
        RoleManager.manage_options +
        OFS.SimpleItem.Item.manage_options
        )
    icon='misc_/ZopeVersionControl/Version.gif'
    security.declareProtected('View management screens', 'manage_main')
    manage_main = DTMLFile('dtml/VersionManageMain', globals())
    manage_main._setName('manage_main')
    manage = manage_main
    security.
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'])
    
    map.minimization = False
    map.explicit = False
    
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.connect(None, '/', controller='user_overview', action='index')
    map.connect(None, '/user', controller='user_overview', action='index')
    map.connect(None, '/user/', controller='user_overview', action='index')
    map.connect(None, '/user/overview', controller='user_overview')
    map.connect(None, '/user/overview/', controller='user_overview')
    map.connect(None, '/user/overview/{ac

    map.connect(None, '/user/vos', controller='user_vos', action='index')
    map.connect(None, '/user/clusters', controller='user_clusters', action='index')
    map.connect(None, '/user/clusters/', controller='user_clusters', action='index')
    map.connect(None, '/user/clusters/{action}', controller='user_clusters', )
    map.connect(None, '/user/clusters/{action}/{id}', controller='user_clusters')
    map.connect(None, '/user/clusters/{action}/{id}/{queue}', controller='user_clusters')
    map.connect(None, '/user/jobs', controller='user_jobs')
    map.connect(None, '/user/jobs/', controller='user_jobs')
    map.connect(None, '/user/jobs/{action}', controller='user_jobs')
    map.connect(None, '/user/jobs/{action}/{status}', controller='user_jobs')
    map.connect(None, '/user/jobdetails/{dn}/{jobid}',controller='user_job_details')
    map.connect(None, '/user/statistics', controller='user_statistics')
    map.connect(None, '/user/statistics/', controller='user_statistics')
    map

    map.connect(None, '/user/tickets', controller='user_tickets')
    map.connect(None, '/user/tickets/', controller='user_tickets')
    map.connect(None, '/user/links', controller='user_links')
    map.connect(None, '/user/links/', controller='user_links')
    
    map.connect(None, '/siteadmin', controller='siteadmin_overview', action='index')
    map.connect(None, '/siteadmin/', controller='siteadmin_overview', action='index')
    map.connect(None, '/siteadmin/overview', controller='siteadmin_overview')
    map.connect(None, '/siteadmin/overview/', controller='siteadmin_overview')
    map.connect(None, '/siteadmin/overview/{action}', controller='siteadmin_overview')
    map.connect(None, '/siteadmin/clusters', controller='siteadmin_clusters', action='index')
    map.connect(None, '/siteadmin/clusters/', controller='siteadmin_clusters', action='index')
    map.connect(None, '/siteadmin/clusters/{action}', controller='siteadmin_clusters', )
    map.connect(None, '/siteadmin/clusters/
datatypes_repository_name = 'emboss_datatypes_0020'
datatypes_repository_description = "Galaxy applicable data formats used by Emboss tools."
datatypes_repository_long_description = "Galaxy applicable data formats used by Emboss tools.  This repository contains no tools."
emboss_repository_name = 'emboss_0020'
emboss_repository_description = 'Galaxy wrappers for Emboss version 5.0.0 tools'
emboss_repository_long_description = 'Galaxy wrappers for Emboss version 5.0.0 tools'
base_datatypes_count = 0
repository_datatypes_count = 0
running_standalone = False
class UninstallingAndReinstallingRepositories( ShedTwillTestCase ):
    '''Test uninstalling and reinstalling a repository with tool dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = test_db_util.get_galaxy_user( common.admin_email )
      

        galaxy_admin_user_private_role = test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
    def test_0005_ensure_repositories_and_categories_exist( self ):
        '''Create the 0020 category and upload the emboss repository to the tool shed, if n

        global repository_datatypes_count
        global running_standalone
        category = self.create_category( name='Test 0020 Basic Repository Dependencies', description='Tests for a repository with tool dependencies.' )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        datatypes_repository = self.get_or_create_repository( name=datatypes_repository_name, 
                                                              description=datatypes_repository_description, 
                                                              long_description=datatypes_repository_long_description, 
                                                              owner=common.test_user_1_name,
                                                              category_id=self.security.encode_id( category.id ), 
                                                              strings_displayed=[] )
        if self.repository_is_new( datatypes_r
__all__ = ["SDL_GameController", "SDL_CONTROLLER_BINDTYPE_NONE",
           "SDL_CONTROLLER_BINDTYPE_BUTTON", "SDL_CONTROLLER_BINDTYPE_AXIS",
           "SDL_CONTROLLER_BINDTYPE_HAT", "SDL_GameControllerBindType",
           "SDL_GameControllerButtonBind", "SDL_GameControllerAddMapping",
           "SDL_GameControllerMappingForGUID", "SDL_GameControllerMapping",
           "SDL_IsGameController", "SDL_GameControllerNameForIndex",
           "SDL_GameControllerOpen", "SDL_GameControllerName",
           "SDL_GameControllerGetAttached", "SDL_GameControllerGetJoystick",
           "SDL_GameControllerEventState", "SDL_GameControllerUpdate",
           "SDL_CONTROLLER_AXIS_INVALID", "SDL_CONTROLLER_AXIS_LEFTX",
           "SDL_CONTROLLER_AXIS_LEFTY", "SDL_CONTROLLER_AXIS_RIGHTX",
           "SDL_CONTROLLER_AXIS_RIGHTY", "SDL_CONTROLLER_AXIS_TRIGGERLEFT",
           "SDL_CONTROLLER_AXIS_TRIGGERRIGHT", "SDL_CONTROLLER_AXIS_MAX",
           "SDL_GameControllerAxis", "SDL_GameControllerGetAxisF

           "SDL_GameControllerGetStringForAxis",
           "SDL_GameControllerGetBindForAxis", "SDL_GameControllerGetAxis",
           "SDL_CONTROLLER_BUTTON_INVALID", "SDL_CONTROLLER_BUTTON_A",
           "SDL_CONTROLLER_BUTTON_B", "SDL_CONTROLLER_BUTTON_X",
           "SDL_CONTROLLER_BUTTON_Y", "SDL_CONTROLLER_BUTTON_BACK",
           "SDL_CONTROLLER_BUTTON_GUIDE", "SDL_CONTROLLER_BUTTON_START",
           "SDL_CONTROLLER_BUTTON_LEFTSTICK", "SDL_CONTROLLER_BUTTON_RIGHTSTICK",
           "SDL_CONTROLLER_BUTTON_LEFTSHOULDER",
           "SDL_CONTROLLER_BUTTON_RIGHTSHOULDER",
           "SDL_CONTROLLER_BUTTON_DPAD_UP", "SDL_CONTROLLER_BUTTON_DPAD_DOWN",
           "SDL_CONTROLLER_BUTTON_DPAD_LEFT", "SDL_CONTROLLER_BUTTON_DPAD_RIGHT",
           "SDL_CONTROLLER_BUTTON_MAX", "SDL_GameControllerButton",
           "SDL_GameControllerGetButtonFromString",
           "SDL_GameControllerGetStringForButton",
           "SDL_GameControllerGetBindForButton", "SDL_GameControllerGetButton",
    

           "SDL_GameControllerAddMappingsFromRW"
           ]
class SDL_GameController(Structure):
    pass
SDL_CONTROLLER_BINDTYPE_NONE = 0
SDL_CONTROLLER_BINDTYPE_BUTTON = 1
SDL_CONTROLLER_BINDTYPE_AXIS = 2
SDL_CONTROLLER_BINDTYPE_HAT = 3
SDL_GameControllerBindType = c_int
class _gchat(Structure):
    _fields_ = [("hat", c_int), ("hat_mask", c_int)]
class _gcvalue(Union):
    _fields_ = [("button", c_int), ("axis", c_int), ("hat", _gchat)]
class SDL_GameControllerButtonBind(Structure):
    _fields_ = [("bindType", SDL_GameControllerBindType), ("value", _gcvalue)]
SDL_GameControllerAddMapping = _bind("SDL_GameControllerAddMapping", [c_char_p], c_int)
SDL_GameControllerMappingForGUID = _bind("SDL_GameControllerMappingForGUID", [SDL_JoystickGUID], c_char_p)
SDL_GameControllerMapping = _bind("SDL_GameControllerMapping", [POINTER(SDL_GameController)], c_char_p)
SDL_IsGameController = _bind("SDL_IsGameController", [c_int], SDL_bool)
SDL_GameControllerNameForIndex = _bind("SDL_GameControll
log = logging.getLogger( __name__ )
column_repository_name = 'column_maker_0150'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0150'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0150 Simple Prior Installation'
category_description = 'Test 0150 Simple Prior Installation'
'''
Create column_maker and convert_chars.
Column maker repository dependency:
<repository toolshed="self.url" name="convert_chars" owner="test" changeset_revision="c3041382815c" prior_installation_required="True" />
Verify display.
Galaxy side:
Install column_maker.
Verify that convert_chars was installed first, contrary to the ordering that would be present without prior_installation_required.
'''
running_standalone = False
class TestSimplePriorInstallation( ShedTwillTestCase ):
    '''Test features related to 

    
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        galaxy_admin_user_private_role = test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        

        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        
    def test_0005_create_convert_repository( self ):
        '''Create and populate convert_chars_0150.'''
        global running_standalone
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=convert_repository_name, 
                                                    description=convert_repository_description, 
                                                    long_description=convert_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_
"""Role manager
"""
class RoleManager(BaseRoleManager):
    """An object that has configurable permissions"""
    security = ClassSecurityInfo()
    manage_options=(
        {'label': 'Security', 'action': 'manage_access'},
        )
    security.declareProtected(change_permissions, 'manage_roleForm')
    manage_roleForm=DTMLFile('dtml/roleEdit', globals(),
                             management_view='Security')
    security.declareProtected(change_permissions, 'manage_role')
    @requestmethod('POST')
    def manage_role(self, role_to_manage, permissions=[], REQUEST=None):
        """Change the permissions given to the given role.
        """
        BaseRoleManager.manage_role(
            self, role_to_manage, permissions=permissions)
        if REQUEST is not None:
            return self.manage_access(REQUEST)
    security.declareProtected(change_permissions, 'manage_acquiredForm')
    manage_acquiredForm=DTMLFile('dtml/acquiredEdit', globals(),
                                 m

    security.declareProtected(change_permissions, 'manage_acquiredPermissions')
    @requestmethod('POST')
    def manage_acquiredPermissions(self, permissions=[], REQUEST=None):
        """Change the permissions that acquire.
        """
        BaseRoleManager.manage_acquiredPermissions(
            self, permissions=permissions)
        if REQUEST is not None:
            return self.manage_access(REQUEST)
    security.declareProtected(change_permissions, 'manage_permissionForm')
    manage_permissionForm=DTMLFile('dtml/permissionEdit', globals(),
                                   management_view='Security')
    security.declareProtected(change_permissions, 'manage_permission')
    @requestmethod('POST')
    def manage_permission(self, permission_to_manage,
                          roles=[], acquire=0, REQUEST=None):
        """Change the settings for the given permission.
        If optional arg acquire is true, then the roles for the permission
        are acquired, in addition

        permissions are restricted to only the designated roles.
        """
        BaseRoleManager.manage_permission(
            self, permission_to_manage, roles=roles, acquire=acquire)
        if REQUEST is not None:
            return self.manage_access(REQUEST)
    _normal_manage_access=DTMLFile('dtml/access', globals())
    manage_reportUserPermissions=DTMLFile(
        'dtml/reportUserPermissions', globals())
    security.declareProtected(change_permissions, 'manage_access')
    def manage_access(self, REQUEST, **kw):
        """Return an interface for making permissions settings.
        """
        return apply(self._normal_manage_access, (), kw)
    security.declareProtected(change_permissions, 'manage_changePermissions')
    @requestmethod('POST')
    def manage_changePermissions(self, REQUEST):
        """Change all permissions settings, called by management screen.
        """
        valid_roles=self.valid_roles()
        indexes=range(len(valid_roles))
        have=RE
class MendeleyCache(Flask):
    def __init__(self, *args, **kwargs):
        super(MendeleyCache, self).__init__(*args, **kwargs)
        self.configuration = ServiceConfiguration()
        self.configuration.load()
        log.info("Configuration has been loaded")
        self.data_controller = DataController(self.configuration.database)
        self.data_controller.assert_schema()
        log.info("Schema has been checked")
        self.crawler = None
        """:type : AbstractCrawler"""
        if not self.configuration.uses_mendeley:
            log.info("Pipeline uses FileCrawler")
            self.crawler = FileCrawler()
        else:
            log.info("Pipeline uses SDKCrawler".format(
                app_id=self.configuration.crawler.app_id,
                app_secret=self.configuration.crawler.app_secret
            ))
            self.crawler = SDKCrawler(
                app_id=self.configuration.crawler.app_id,
                app_secret=self.configuration.crawler.app_s

            )
        self.crawl_controller = CrawlController(self.crawler, self.configuration.crawler.research_group)
        self.analysis_controller = AnalysisController()
        self.pipeline_controller = PipelineController(
            data_controller=self.data_controller,
            crawl_controller=self.crawl_controller,
            analysis_controller=self.analysis_controller
        )
        log.info("Pipeline has been initialized")
        self.fields_controller = FieldsController(self, self.data_controller)
        self.profiles_controller = ProfilesController(self, self.data_controller, self.configuration.cache)
        self.publications_controller = DocumentsController(self, self.data_controller)
        self.cache_controller = CacheController(self,
                                                self.data_controller,
                                                self.pipeline_controller,
                                                self.configuration)
        sel
'''
A lightweight proxy for saltstack
'''
log = logging.getLogger(__name__)
class PubBroker(multiprocessing.Process):
    '''
    Publish broker, a simple zeromq PUB/SUB proxy
    '''
    def __init__(self, opts):
        super(PubBroker, self).__init__()
        self.opts = opts
        self.opts['master_ip'] = salt.utils.dns_check(self.opts['master'])
    def run(self):
        '''
        Build a PUB/SUB proxy
        http://zguide.zeromq.org/py:wuproxy
        '''
        appendproctitle(self.__class__.__name__)
        context = zmq.Context()
        master_pub = 'tcp://{0}:{1}'.format(self.opts['master_ip'],
                                            self.opts['publish_port'])
        sub_sock = context.socket(zmq.SUB)
        sub_sock = set_tcp_keepalive(sub_sock,
                                     opts=self.opts)
        log.debug('Starting set up a broker SUB sock on {0}'.format(master_pub))
        sub_sock.connect(master_pub)
        pub_uri = 'tcp://{0}:{1}'.format(self.

                                         self.opts['publish_port'])
        pub_sock = context.socket(zmq.PUB)
        pub_sock = set_tcp_keepalive(pub_sock,
                                     opts=self.opts)
        log.debug('Starting set up a broker PUB sock on {0}'.format(pub_uri))
        pub_sock.bind(pub_uri)
        sub_sock.setsockopt(zmq.SUBSCRIBE, b'')
        try:
            while True:
                message = sub_sock.recv_multipart()
                pub_sock.send_multipart(message)
        except KeyboardInterrupt:
            log.warn('Stopping the PubBorker')
            if sub_sock.closed is False:
                sub_sock.setsockopt(zmq.LINGER, 1)
                sub_sock.close()
            if pub_sock.closed is False:
                pub_sock.setsockopt(zmq.LINGER, 1)
                pub_sock.close()
            if context.closed is False:
                context.term()
class RetBroker(multiprocessing.Process):
    '''
    Ret broker, a simple zeromq message q

    '''
    def __init__(self, opts):
        super(RetBroker, self).__init__()
        self.opts = opts
        self.opts['master_ip'] = salt.utils.dns_check(self.opts['master'])
    def run(self):
        '''
        Build a QUEUE device
        http://zguide.zeromq.org/py:msgqueue
        '''
        appendproctitle(self.__class__.__name__)
        context = zmq.Context()
        router_uri = 'tcp://{0}:{1}'.format(self.opts['interface'],
                                            self.opts['ret_port'])
        router_sock = context.socket(zmq.ROUTER)
        router_sock = set_tcp_keepalive(router_sock,
                                        opts=self.opts)
        log.info(
            'Starting set up a broker ROUTER sock on {0}'.format(router_uri))
        router_sock.bind(router_uri)
        dealer_sock = context.socket(zmq.DEALER)
        dealer_sock = set_tcp_keepalive(dealer_sock,
                                        opts=self.opts)
        self.opts['master_uri'] = 'tc
try:
except ImportError:
class OdnoklassnikiAPIChainingTest(unittest.TestCase):
    def test_method_group_and_name_are_empty_when_no_chain_is_provided(self):
        ok_api = OdnoklassnikiAPI()
        self.assertIsNone(ok_api._api_method_group)
        self.assertIsNone(ok_api._api_method_name)
    def test_magic_method_does_not_affect_group_or_name_assigning(self):
        ok_api = OdnoklassnikiAPI()
        dir(ok_api)
        self.assertIsNone(ok_api._api_method_group)
        self.assertIsNone(ok_api._api_method_name)
    def test_first_chain_produces_method_group(self):
        ok_api = OdnoklassnikiAPI()
        self.assertEqual(ok_api.group._api_method_group, 'group')
        self.assertIsNone(ok_api.group._api_method_name)
    def test_second_chain_produces_method_name(self):
        ok_api = OdnoklassnikiAPI()
        self.assertEqual(ok_api.group.getCurrentUser._api_method_group, 'group')
        self.assertEqual(ok_api.group.getCurrentUser._api_method_name,
                

    def test_third_chain_produces_attribute_error(self):
        ok_api = OdnoklassnikiAPI()
        expected_exc_message = (
            "'OdnoklassnikiAPI' method's group, name have already been set"
        )
        with self.assertRaisesRegexp(AttributeError, expected_exc_message):
            ok_api.group.name.blah
class OdnoklassnikiAPICallableTest(unittest.TestCase):
    def test_api_instance_is_not_callable(self):
        ok_api = OdnoklassnikiAPI()
        expected_exc_message = "'OdnoklassnikiAPI' object is not callable"
        with self.assertRaisesRegexp(TypeError, expected_exc_message):
            ok_api()
    def test_first_chain_of_api_instance_is_not_callable(self):
        ok_api = OdnoklassnikiAPI()
        expected_exc_message = "'OdnoklassnikiAPI' object is not callable"
        with self.assertRaisesRegexp(TypeError, expected_exc_message):
            ok_api.users()
    @mock.patch('pyodnoklassniki.requestor.session', autospec=True)
    def test_second_chain_of
urlpatterns = patterns(
    '',
    url(r'^lattice/$',
        lattices,
        name='lattices'),
    url(r'^lattice/savelatticeinfo/$',
        saveLatticeInfo,
        name='saveLatticeInfo'),
    url(r'^lattice/savelattice$',
        saveLattice,
        name='saveLattice'),
    url(r'^lattice/savemodel$',
        saveModel,
        name='saveModel'),
    url(r'^lattice/web/$',
        lattice_home,
        name='lattice_home'),
    url(r'^lattice/web/index.html$',
        lattice_home,
        name='lattice_home'),
    url(r'^lattice/web/content.html$',
        lattice_content_home,
        name='lattice_content_home'),
    url(r'^lattice/web/search.html$',
        lattice_content_search,
        name='lattice_content_search'),
    url(r'^lattice/web/list.html$',
        lattice_content_list,
        name='lattice_content_list'),
    url(r'^lattice/web/model_list.html$',
        lattice_content_model_list,
        name='lattice_content_model_list'),
    url(r'^lattice/web/details.
class TestManageTagsPage(BaseTest):
    def test_creating_a_tag_with_no_product_value_set(self, base_url, selenium, login):
        manage_tags_pg = MozTrapManageTagsPage(base_url, selenium)
        manage_tags_pg.go_to_manage_tags_page()
        create_tag_pg = manage_tags_pg.click_create_tag_button()
        assert not create_tag_pg.is_multiselect_widget_visible
        tag = MockTag()
        create_tag_pg.create_tag(tag)
        manage_tags_pg.filter_form.filter_by(lookup='name', value=tag['name'])
        displayed_tags = manage_tags_pg.tags()
        assert tag['name'] in [t.name for t in displayed_tags]
    def test_creating_a_tag_with_a_product_value_and_no_cases(self, base_url, selenium, login, product):
        manage_tags_pg = MozTrapManageTagsPage(base_url, selenium)
        manage_tags_pg.go_to_manage_tags_page()
        create_tag_pg = manage_tags_pg.click_create_tag_button()
        tag = MockTag(product=product['name'])
        create_tag_pg.create_tag(tag, save_tag=Fal

        assert create_tag_pg.is_multiselect_widget_visible
        create_tag_pg.save_tag()
        manage_tags_pg.filter_form.filter_by(lookup='name', value=tag['name'])
        displayed_tags = manage_tags_pg.tags()
        assert tag['name'] in [t.name for t in displayed_tags]
    def test_creating_a_tag_with_a_product_value_and_cases(self, api, base_url, selenium, login, product):
        cases = self.create_bulk_cases(base_url, selenium, product, api=api)
        manage_tags_pg = MozTrapManageTagsPage(base_url, selenium)
        manage_tags_pg.go_to_manage_tags_page()
        create_tag_pg = manage_tags_pg.click_create_tag_button()
        tag = MockTag(product=product['name'])
        create_tag_pg.create_tag(tag, save_tag=False)
        expected_case_names = [case.name for case in cases]
        actual_case_names = [case.name for case in create_tag_pg.available_caseversions]
        assert sorted(expected_case_names) == sorted(actual_case_names)
        create_tag_pg.include_ca
class TestWightApp(TestCase):
    app_class = WightApp
    def setUp(self):
        super(TestWightApp, self).setUp()
        self.reset_backend()
        self.app = WightApp(argv=[], config_files=[])
    def test_wight_app(self):
        self.app.setup()
        self.app.run()
        self.app.close()
    def test_has_proper_controllers(self):
        self.app.setup()
        self.app.register_controllers()
        expect(self.app.controllers).to_length(20)
        expect(self.app.controllers).to_include(TargetSetController)
        expect(self.app.controllers).to_include(TargetGetController)
        expect(self.app.controllers).to_include(AuthController)
        expect(self.app.controllers).to_include(CreateTeamController)
        expect(self.app.controllers).to_include(ShowTeamController)
        expect(self.app.controllers).to_include(UpdateTeamController)
        expect(self.app.controllers).to_include(DeleteTeamController)
        expect(self.app.controllers).to_include(ShowUserC
class TestMaybeWarnDeprecated(unittest.TestCase):
    def setUp(self):
        self._orig_deprecatedManageAddDeleteClasses = (
            deprecatedManageAddDeleteClasses[:])
        self.deprecatedManageAddDeleteClasses = (
            deprecatedManageAddDeleteClasses)
        self.deprecatedManageAddDeleteClasses.append(int)
        self.logfile = StringIO.StringIO()
        self.log_handler = logging.StreamHandler(self.logfile)
        logging.root.addHandler(self.log_handler)
        self.old_log_level = logging.root.level
        logging.root.setLevel(logging.DEBUG)
    def tearDown(self):
        self.deprecatedManageAddDeleteClasses[:] = (
            self._orig_deprecatedManageAddDeleteClasses)
        logging.root.removeHandler(self.log_handler)
        logging.root.setLevel(self.old_log_level)
    def assertLog(self, class_, expected):
        maybeWarnDeprecated(class_(), 'manage_afterAdd')
        self.assertEquals(expected, self.logfile.getvalue())
    def test_method_dep

        class Deprecated(object):
            def manage_afterAdd(self):
                pass
            manage_afterAdd.__five_method__ = True
        self.assertLog(Deprecated, '')
    def test_class_deprecated(self):
        class Deprecated(object):
            def manage_afterAdd(self):
                pass
        self.deprecatedManageAddDeleteClasses.append(Deprecated)
        self.assertLog(Deprecated, '')
    def test_subclass_deprecated(self):
        class Deprecated(object):
            def manage_afterAdd(self):
                pass
        class ASubClass(Deprecated):
            pass
        self.deprecatedManageAddDeleteClasses.append(Deprecated)
        self.assertLog(ASubClass, '')
    def test_not_deprecated(self):
        class Deprecated(object):
            def manage_afterAdd(self):
                pass
        self.assertLog(
            Deprecated,
            'OFS.tests.test_subscribers.Deprecated.manage_afterAdd is '
            'discouraged. You should use
roslib.load_manifest('vigir_rqt_system_command')
class SystemCommandDialog(Plugin):
    def __init__(self, context):
        super(SystemCommandDialog, self).__init__(context)
        self.setObjectName('SystemCommandDialog')
        self.sys_command_pub  = rospy.Publisher('/syscommand',String, None, False, True, None, queue_size=10)
        self._widget = QWidget()
        vbox = QVBoxLayout()
        reset_world_command = QPushButton("Reset World Model")
        reset_world_command.clicked.connect(self.apply_reset_world_command_callback)
        vbox.addWidget(reset_world_command)
        save_octomap = QPushButton("Save Octomap")
        save_octomap.clicked.connect(self.apply_save_octomap_command_callback)
        vbox.addWidget(save_octomap)
        save_pointcloud = QPushButton("Save Pointcloud")
        save_pointcloud.clicked.connect(self.apply_save_pointcloud_command_callback)
        vbox.addWidget(save_pointcloud)
        save_image_left_eye = QPushButton("Save Image Head")


        vbox.addWidget(save_image_left_eye)
        save_image_left_hand = QPushButton("Save Left Hand Image")
        save_image_left_hand.clicked.connect(self.apply_save_image_left_hand_command_callback)
        vbox.addWidget(save_image_left_hand)
        save_image_right_hand = QPushButton("Save Right Hand Image")
        save_image_right_hand.clicked.connect(self.apply_save_image_right_hand_command_callback)
        vbox.addWidget(save_image_right_hand)
        vbox.addStretch(1)
        self._widget.setLayout(vbox)
        context.add_widget(self._widget)
    def shutdown_plugin(self):
        print "Shutting down ..."
        self.sys_command_pub.unregister()
        print "Done!"
    def apply_reset_world_command_callback(self):
        msg = String("reset")
        print "Send system command = <",msg.data,">"
        self.sys_command_pub.publish(msg)
    def apply_save_octomap_command_callback(self):
        msg = String("save_octomap")
        print "Send system command = <"
def main():
    window = Engine((720, 480), FPS=60)
    background = window.load_image("img/background.png")
    while True:
            print("Controller > LSTICK : ",(window.get_left_stick()))
            
            print("Controller > RSTICK : ",(window.get_right_stick()))
    
        if window.down(window.controller.BUTTON_O):     print("Controller >   DOWN : BUTTON_O")
        elif window.motion(window.controller.BUTTON_O): print("Controller > MOTION : BUTTON_O")
        elif window.up(window.controller.BUTTON_O):     print("Controller >     UP : BUTTON_O")
        
        if window.down(window.controller.BUTTON_U):     print("Controller >   DOWN : BUTTON_U")
        elif window.motion(window.controller.BUTTON_U): print("Controller > MOTION : BUTTON_U")
        elif window.up(window.controller.BUTTON_U):     print("Controller >     UP : BUTTON_U")
        
        if window.down(window.controller.BUTTON_Y):     print("Controller >   DOWN : BUTTON_Y")
        elif window.motion

        elif window.up(window.controller.BUTTON_Y):     print("Controller >     UP : BUTTON_Y")
        
        if window.down(window.controller.BUTTON_A):     print("Controller >   DOWN : BUTTON_A")
        elif window.motion(window.controller.BUTTON_A): print("Controller > MOTION : BUTTON_A")
        elif window.up(window.controller.BUTTON_A):     print("Controller >     UP : BUTTON_A")
        
        if window.down(window.controller.BUTTON_L1):     print("Controller >   DOWN : BUTTON_L1")
        elif window.motion(window.controller.BUTTON_L1): print("Controller > MOTION : BUTTON_L1")
        elif window.up(window.controller.BUTTON_L1):     print("Controller >     UP : BUTTON_L1")
        
        if window.down(window.controller.BUTTON_L2):     print("Controller >   DOWN : BUTTON_L2")
        elif window.motion(window.controller.BUTTON_L2): print("Controller > MOTION : BUTTON_L2")
        elif window.up(window.controller.BUTTON_L2):     print("Controller >     UP : BUTTON_L2")


        if window.down(window.controller.BUTTON_L3):     print("Controller >   DOWN : BUTTON_L3")
        elif window.motion(window.controller.BUTTON_L3): print("Controller > MOTION : BUTTON_L3")
        elif window.up(window.controller.BUTTON_L3):     print("Controller >     UP : BUTTON_L3")
        
        if window.down(window.controller.BUTTON_R1):     print("Controller >   DOWN : BUTTON_R1")
        elif window.motion(window.controller.BUTTON_R1): print("Controller > MOTION : BUTTON_R1")
        elif window.up(window.controller.BUTTON_R1):     print("Controller >     UP : BUTTON_R1")
        
        if window.down(window.controller.BUTTON_R2):     print("Controller >   DOWN : BUTTON_R2")
        elif window.motion(window.controller.BUTTON_R2): print("Controller > MOTION : BUTTON_R2")
        elif window.up(window.controller.BUTTON_R2):     print("Controller >     UP : BUTTON_R2")
        
        if window.down(window.controller.BUTTON_R3):     print("Controller >   DOWN : BUTT
class Allocation(object):
    def __init__(self, jagent, ragent=None):
        self.jagent = jagent
        self.ragent = ragent
    @property
    def job(self):
        return self.jagent.job
    @property
    def id(self):
        return self.jagent.job.id
    def __str__(self):
        return "Alloc(%s, %s)" % (self.jagent, self.ragent)
class MessageWithAllocation(Message):
    def __init__(self, allocation, *a, **kw):
        super(MessageWithAllocation, self).__init__(*a, **kw)
        self.allocation = allocation
class AllocationRequest(MessageWithAllocation):
    def process(self, src, dst, trace, **kw):
        if dst.broker:
            dst.broker.listen_process.signal("allocate", self.allocation)
        else:
            trace("WARNING: no broker for allocate request at node %s" %
                    (dst.id))
class AllocationResponse(MessageWithAllocation):
    def process(self, src, dst, trace, **kw):
        agent = check_target(dst, self.allocation.jagent, trace)
       
class OptionMarker(Exception):
    pass
class ArgumentMarker(Exception):
    pass
doc = 'usage: prog [--option] [<argument>]'
@fixture
def dispatch():
    dispatch = Dispatch()
    @dispatch.on('--option')
    def option(**kwargs):
        raise OptionMarker(kwargs)
    @dispatch.on('<argument>')
    def argument(**kwargs):
        raise ArgumentMarker(kwargs)
    yield dispatch
def test_dispatch_can_dispatch_on_option(dispatch):
    with raises(OptionMarker) as error:
        dispatch(doc, '--option')
    assert error.value.message == {'option': True, 'argument': None}
def test_dispatch_can_dispatch_on_argument(dispatch):
    with raises(ArgumentMarker) as error:
        dispatch(doc, 'hi')
    assert error.value.message == {'option': False, 'argument': 'hi'}
def test_dispatch_will_raise_error_if_it_cannot_dispatch(dispatch):
    with raises(DispatchError) as error:
        dispatch(doc, '')
    message = ('None of dispatch conditions --option, <argument> '
               'is triggere
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'])
    map.minimization = False
    map.explicit = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.redirect('/*(url)^(/)', '/{url}/', _redirect_code='302 Moved Temporarily')
    map.connect('/', controller='home', action='index')
    map.connect('/trade/{id}/', controller='trade', action='index')
    map.connect('/bet/{id}/', controller='bet', action='index')
    map.connect('/manage/leagues/add/', controller='manage', action='addLeague')
    map.connect('/manage/leagues/edit/{id}/', controller='
class BaseContentMixin(CatalogMultiplex,
                       BaseObject,
                       PortalContent,
                       Historical):
    """A not-so-basic CMF Content implementation that doesn't
    include Dublin Core Metadata"""
    __implements__ = z2IBaseContent, z2IReferenceable, PortalContent.__implements__
    implements(IBaseContent, IReferenceable)
    security = ClassSecurityInfo()
    manage_options = PortalContent.manage_options + Historical.manage_options
    isPrincipiaFolderish = 0
    isAnObjectManager = 0
    __dav_marshall__ = True
    security.declarePrivate('manage_afterAdd')
    def manage_afterAdd(self, item, container):
        BaseObject.manage_afterAdd(self, item, container)
    security.declarePrivate('manage_afterClone')
    def manage_afterClone(self, item):
        BaseObject.manage_afterClone(self, item)
    security.declarePrivate('manage_beforeDelete')
    def manage_beforeDelete(self, item, container):
        BaseObject.manage_beforeDe

        self._v_cp_refs = None
    def _notifyOfCopyTo(self, container, op=0):
        """OFS.CopySupport notify
        """
        BaseObject._notifyOfCopyTo(self, container, op=op)
        if op==1:
            self._v_cp_refs = 1
    security.declareProtected(permissions.ModifyPortalContent, 'PUT')
    PUT = WebDAVSupport.PUT
    security.declareProtected(permissions.View, 'manage_FTPget')
    manage_FTPget = WebDAVSupport.manage_FTPget
    security.declarePrivate('manage_afterPUT')
    manage_afterPUT = WebDAVSupport.manage_afterPUT
InitializeClass(BaseContentMixin)
class BaseContent(BaseContentMixin,
                  ExtensibleMetadata,
                  PropertyManager):
    """A not-so-basic CMF Content implementation with Dublin Core
    Metadata included"""
    __implements__ = BaseContentMixin.__implements__, IExtensibleMetadata
    implements(IBaseContent, IReferenceable)
    schema = BaseContentMixin.schema + ExtensibleMetadata.schema
    manage_options = BaseContentMixi
"""Base implementation classes.
The public-facing ``Events`` serves as the base class for an event interface;
it's public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.
"""
_registrars = util.defaultdict(list)
def _is_event_name(name):
    return not name.startswith('_') and name != 'dispatch'
class _UnpickleDispatch(object):
    """Serializable callable that re-generates an instance of
    :class:`_Dispatch` given a particular :class:`.Events` subclass.
    """
    def __call__(self, _parent_cls):
        for cls in _parent_cls.__mro__:
            if 'dispatch' in cls.__dict__:
                return cls.__dict__['dispatch'].dispatch_cls(_parent_cls)
        else:
            raise AttributeError("No class with a 'disp

class _Dispatch(object):
    """Mirror the event listening definitions of an Events class with
    listener collections.
    Classes which define a "dispatch" member will return a
    non-instantiated :class:`._Dispatch` subclass when the member
    is accessed at the class level.  When the "dispatch" member is
    accessed at the instance level of its owner, an instance
    of the :class:`._Dispatch` class is returned.
    A :class:`._Dispatch` class is generated for each :class:`.Events`
    class defined, by the :func:`._create_dispatcher_class` function.
    The original :class:`.Events` classes remain untouched.
    This decouples the construction of :class:`.Events` subclasses from
    the implementation used by the event internals, and allows
    inspecting tools like Sphinx to work in an unsurprising
    way against the public API.
    """
    _events = None
    """reference the :class:`.Events` class which this
        :class:`._Dispatch` is created for."""
    def __init__(s

        self._parent_cls = _parent_cls
    @util.classproperty
    def _listen(cls):
        return cls._events._listen
    def _join(self, other):
        """Create a 'join' of this :class:`._Dispatch` and another.
        This new dispatcher will dispatch events to both
        :class:`._Dispatch` objects.
        """
        if '_joined_dispatch_cls' not in self.__class__.__dict__:
            cls = type(
                    "Joined%s" % self.__class__.__name__,
                    (_JoinedDispatcher, self.__class__), {}
                )
            for ls in _event_descriptors(self):
                setattr(cls, ls.name, _JoinedDispatchDescriptor(ls.name))
            self.__class__._joined_dispatch_cls = cls
        return self._joined_dispatch_cls(self, other)
    def __reduce__(self):
        return _UnpickleDispatch(), (self._parent_cls, )
    def _update(self, other, only_propagate=True):
        """Populate from the listeners in another :class:`_Dispatch`
            object
class Vertex(GraphElement):
    Broker = VertexBroker
    def outE(self, *edge_classes):
        g = self._graph
        return g.outE(self._id, *edge_classes) if g else None
    def inE(self, *edge_classes):
        g = self._graph
        return g.inE(self._id, *edge_classes) if g else None
    def bothE(self, *edge_classes):
        g = self._graph
        return g.bothE(self._id, *edge_classes) if g else None
    def out(self, *edge_classes):
        g = self._graph
        return g.out(self._id, *edge_classes) if g else None
    def in_(self, *edge_classes):
        g = self._graph
        return g.in_(self._id, *edge_classes) if g else None
    def both(self, *edge_classes):
        g = self._graph
        return g.both(self._id, *edge_classes) if g else None
    def __call__(self, edge_or_broker):
        """Provides syntactic sugar for creating edges."""
        if hasattr(edge_or_broker, 'broker'):
            edge_or_broker = edge_or_broker.broker.element_cls
        elif has
  SaveEducationalDetails, SaveResumeDetails, SavePhotoDetails, JobSeekerView, EditDetails,\
JobSearch, ApplyJobs,Companies, ActivityLog, JobDetails, SaveUserLoginDetails, JobseekerDashboard
urlpatterns = patterns('',
    url(r'^registration/$', JobseekerRegistration.as_view(), name="jobseeker_registration"),
    url(r'^dashboard/$', login_required(JobseekerDashboard.as_view(), login_url="/login/"), name="jobseeker_dashboard"),
    url(r'^save_user_login_details/$', SaveUserLoginDetails.as_view(), name="save_user_login_details"),
    url(r'^save_personal_details/$', SavePersonalDetails.as_view(), name="save_personal_details"),
    url(r'^save_current_employer_details/$', SaveCurrentEmployerDetails.as_view(), name="save_current_employer_details"),
    url(r'^save_educational_details/$', SaveEducationalDetails.as_view(), name="save_educational_details"),
    url(r'^save_resume_details/$', SaveResumeDetails.as_view(), name="save_resume_details"),
    url(r'^save_photo_details/$', SavePhoto
LOG = logging.getLogger("CENI")
def create_controller(slice_obj, controller_info):
    """创建控制器
    """
    if slice_obj:
        try:
            if controller_info['controller_type'] == 'default_create':
                controller = create_default_controller(slice_obj,
                                                       controller_info['controller_sys'])
            else:
                controller = create_user_defined_controller(slice_obj,
                                                            controller_info['controller_ip'],
                                                            controller_info['controller_port'])
            return controller
        except Exception:
            raise
    else:
        raise DbError("数据库异常")
def create_add_controller(slice_obj, controller_info):
    """创建并添加slice控制器
    """
    if slice_obj:
        try:
            if controller_info['controller_type'] == 'default_create':
                controller = create_default_controller(sli

                                                       controller_info['controller_sys'])
            else:
                controller = create_user_defined_controller(slice_obj,
                                                            controller_info['controller_ip'],
                                                            controller_info['controller_port'])
            slice_add_controller(slice_obj, controller)
            return controller
        except Exception:
            raise
    else:
        raise DbError("数据库异常")
def slice_add_controller(slice_obj, controller):
    """slice添加控制器
    """
    LOG.debug('slice_add_controller')
    if slice_obj and controller:
        if controller.is_used():
            raise ControllerUsedError('控制器已经被使用！')
        try:
            if not slice_obj.get_controller():
                slice_obj.add_resource(controller)
        except Exception:
            raise DbError("数据库异常")
    else:
        raise DbError("数据库异常")
def create_user_

    """创建用户自定义控制器记录
    """
    if slice_obj:
        try:
            controller = Controller(
                name='user_define',
                ip=controller_ip,
                port=int(controller_port),
                island=slice_obj.get_island())
            controller.save()
            return controller
        except Exception:
            raise DbError("数据库异常")
    else:
        raise DbError("数据库异常")
def create_default_controller(slice_obj, controller_sys):
    """创建默认控制器
    """
    if slice_obj:
        island = slice_obj.get_island()
        try:
            vm, ip = create_vm_for_controller(island_obj=island,
                                              slice_obj=slice_obj,
                                              image_name=controller_sys)
        except Exception, ex:
            raise DbError(ex.message)
        try:
            controller = Controller(name=controller_sys,
                                    port=6633,
                                    isl
class PageManager(object):
    def __init__(self, controller):
        self.controller = controller
        self.controller.actions['tab1'] = self.switchto
        self.controller.actions['tab2'] = self.switchto
        self.controller.actions['tab3'] = self.switchto
        self.controller.actions['tab4'] = self.switchto
        self.pages = {
            'tab1': diff.Diff(controller),
            'tab2': log.Log(controller),
            'tab3': branches.Branches(controller),
        }
        self.refreshevent = None
        self.switchto('tab1', None)
    def switchto(self, action, message):
        self.active = action
        self.pages[self.active].activate()
    def refresh(self):
        self.pages[self.active].draw()
def main(inargs=None):
    args = gitgrid.utils.utils.controller_args()
    sys.stdout = gitgrid.utils.utils.Unbuffered(sys.stdout)
    controller = gridcontroller.create(args.controller, args.input, args.output)
    manager = PageManager(controller)
    controlle
iteritems = six.iteritems
class EB(foundation.CementApp):
    class Meta:
        label = 'eb'
        base_controller = base.EbBaseController
        defaults = init_defaults('eb', 'log.logging')
        defaults['log.logging']['level'] = 'WARN'
        config_defaults = defaults
        exit_on_close = True
    def setup(self):
        ebglobals.app = self
        hook.register('post_argument_parsing', hooks.pre_run_hook)
        environment_controllers = [
            InitController,
            PlatformController,
            LogsController,
            SSHController,
            ConfigController,
            CreateController,
            EventsController,
            PrintEnvController,
            StatusController,
            TerminateController,
            DeployController,
            SwapController,
            OpenController,
            ConsoleController,
            ScaleController,
            UseController,
            SetEnvController,
            ListController,
     

            UpgradeController,
            AbortController,
            LabsController,
            LocalController,
            HealthController,
            CodeSourceController,
            RestoreController,
            AppVersionController,
            LifecycleController,
        ]
        platform_controllers = [
            ConfigController,
            ConsoleController,
            EventsController,
            ListController,
            LogsController,
            HealthController,
            SSHController,
            StatusController,
            TerminateController,
            PlatformController,
            UpgradeController,
        ]
        workspace_type = fileoperations.get_workspace_type(Constants.WorkSpaceTypes.APPLICATION)
        if Constants.WorkSpaceTypes.APPLICATION == workspace_type:
            for c in environment_controllers:
                c._add_to_handler(handler)
        elif Constants.WorkSpaceTypes.PLATFORM == workspace_type:
            for c 
host_name = 'shitouren'
domain_name = host_name+'.com'
pfx = 'lohas'
img_limit = 9
url = {
    'img_default'        : '/img/lohas/nopic_400.png',
    'http_moai'          : 'http://moai.shitouren.com',
    'guest_main'         : r"/" ,
    'guest_items'        : r"/items" ,
    'guest_index'        : r"/index" ,
    'guest_signout'      : r"/signout" ,
    'guest_findpwd'      : r"/findpwd" ,
    'guest_resetpwd'     : r"/resetpwd" ,
    'host_home'          : r"/home" ,
    'host_admin'         : r"/admin" ,
    'host_app'           : r"/admin/app" ,
    'host_stat'          : r"/admin/stat" ,
    'host_appadd'        : r"/admin/appadd" ,
    'host_profile'       : r"/admin/profile" ,
    'host_nodeinfo'      : r"/admin/nodeinfo" ,
    'host_node'          : r"/admin/node" ,
    'api_signin'         : r"/api/signin" ,
    'api_signout'        : r"/api/signout" ,
    'api_signup'         : r"/api/signup" ,
    'api_findpwd'        : r"/api/findpwd" ,
    'api_resetpwd'       : r"/api/r

    'api_emailedit'      : r"/api/emailedit",
    'api_pwdedit'        : r"/api/pwdedit",
    'api_phoneedit'      : r"/api/phoneedit",
    'api_appadd'         : r"/api/appadd" ,
    'api_appupdate'      : r"/api/appupdate" ,
    'api_appdeactive'    : r"/api/appdeactive" ,
    'api_nodeadd'        : r"/api/nodeadd" ,
    'api_nodedel'        : r"/api/nodedel" ,
    'api_nodeupdate'     : r"/api/nodeupdate" ,
    'api_nodesort'       : r"/api/nodesort" ,
    'api_nodeimgupdate'  : r"/api/nodeimgupdate" ,
    'api_nodeimgadd'     : r"/api/nodeimgadd" ,
    'api_nodeimgdel'     : r"/api/nodeimgdel" ,
    'api_stat'           : r"/api/stat" ,
    'api_click'          : r"/api/click" ,
    'api_link'           : r"/api/link" ,
    'api_items'          : r"/api/items" ,
    'api_appdel'         : r"/api/appdel" ,
msg = {
    'err_500'           : etc.err_500,
    'err_timeout'       : etc.err_timeout,
    'err_op'            : etc.err_op,
    'st_app_keys'       : ['浏览次数','弹层次数','进入'],
  
class ControllerTest(unittest.TestCase):
    """ControllerTest: Test Controller Singleton"""
    def testAssertNotNone(self):
        """ControllerTest: Test instance not null"""
        controller = puremvc.core.Controller.getInstance()
        self.assertNotEqual(None, controller)
    def testAssertIController(self):
        """ControllerTest: Test instance implements IController"""
        controller = puremvc.core.Controller.getInstance()
        self.assertEqual(True, isinstance(controller, puremvc.interfaces.IController))
    def testRegisterAndExecuteCommand(self):
        """ControllerTest: Test registerCommand() and executeCommand()"""
        controller = puremvc.core.Controller.getInstance()
        controller.registerCommand('ControllerTest', utils.controller.ControllerTestCommand)
        vo = utils.controller.ControllerTestVO(12)
        note = puremvc.patterns.observer.Notification('ControllerTest', vo)
        controller.executeCommand(note)
        self.assertEqual(Tru

    def testRegisterAndRemoveCommand(self):
        """ControllerTest: Test registerCommand() and removeCommand()"""
        controller = puremvc.core.Controller.getInstance()
        controller.registerCommand('ControllerRemoveTest', utils.controller.ControllerTestCommand)
        vo = utils.controller.ControllerTestVO(12)
        note = puremvc.patterns.observer.Notification('ControllerRemoveTest', vo)
        controller.executeCommand(note)
        self.assertEqual(True, vo.result == 24 )
        vo.result = 0
        controller.removeCommand('ControllerRemoveTest')
        controller.executeCommand(note)
        self.assertEqual(True, vo.result == 0)
    def testHasCommand(self):
        """ControllerTest: Test hasCommand()"""
        controller = puremvc.core.Controller.getInstance()
        controller.registerCommand('hasCommandTest', utils.controller.ControllerTestCommand)
        self.assertEqual(True, controller.hasCommand('hasCommandTest'))
        controller.removeCommand('
def gen_books(release, source_dir, output_dir):
    input_dir = join(source_dir, "doc", "book")
    stylesheet = """<?xml version='1.0'?>
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    </xsl:stylesheet>"""
    write(join(input_dir, "xsl", "html-custom.xsl"), stylesheet)
    call("make -C {} clean all", input_dir)
    cpp_broker_input_dir = join(input_dir, "build", "AMQP-Messaging-Broker-CPP-Book")
    java_broker_input_dir = join(input_dir, "build", "AMQP-Messaging-Broker-Java-Book")
    programming_input_dir = join(input_dir, "build", "Programming-In-Apache-Qpid")
    cpp_broker_output_dir = join(output_dir, "cpp-broker")
    java_broker_output_dir = join(output_dir, "java-broker")
    programming_output_dir = join(output_dir, "programming")
    remove(cpp_broker_output_dir)
    remove(java_broker_output_dir)
    remove(programming_output_dir)
    copy(join(cpp_broker_input_dir, "html"), join(cpp_broker_output_dir, "book"))
    copy(join(java_b

    copy(join(programming_input_dir, "html"), join(programming_output_dir, "book"))
    copy(join(cpp_broker_input_dir, "pdf", "AMQP-Messaging-Broker-CPP-Book.pdf"),
         join(cpp_broker_output_dir, "cpp-broker-book.pdf"))
    copy(join(java_broker_input_dir, "pdf", "AMQP-Messaging-Broker-Java-Book.pdf"),
         join(java_broker_output_dir, "java-broker-book.pdf"))
    copy(join(programming_input_dir, "pdf", "Programming-In-Apache-Qpid.pdf"),
         join(programming_output_dir, "programming-book.pdf"))
    for dir in (cpp_broker_output_dir, java_broker_output_dir, programming_output_dir):
        for path in find(dir, "*.html"):
            tree = ElementTree.parse(path)
            elem = tree.find(".//{http://www.w3.org/1999/xhtml}body")
            elem.tag = "div"
            elem.set("class", "docbook")
            remove_namespace(elem, "http://www.w3.org/1999/xhtml")
            content = ElementTree.tostring(elem)
            content = content.replace("../../Programmin

                                      "@site-url@/releases/qpid-{}/programming/book/QpidJNDI.html".format(release))
            content = content.replace("../../Programming-In-Apache-Qpid/html/",
                                      "@site-url@/releases/qpid-{}/programming/book/index.html".format(release))
            content = content.replace("../../AMQP-Messaging-Broker-CPP-Book/html/",
                                      "@site-url@/releases/qpid-{}/cpp-broker/book/index.html".format(release))
            
            write("{}.in".format(path), content)
            remove(path)
def remove_namespace(doc, namespace):
    """Remove namespace in the passed document in place."""
    ns = u'{%s}' % namespace
    nsl = len(ns)
    for elem in doc.getiterator():
        if elem.tag.startswith(ns):
            elem.tag = elem.tag[nsl:]
def alternate_gen_books(source_dir, output_dir):
    input_dir = join(source_dir, "doc", "book")
    cpp_broker_input_dir = join(input_dir, "src", "cpp-b
"""
Takes raw data pulled from main guardian crawl (guardian_main_crawl.py).
Puts this data into dictionary format, with keys as 'id'.
This dict is itself saved as a pickle.
"""
reload(options)
reload(general_functions)
def extract_internal_links(HTML):
	"""
	Looks through HTML and extracts internal hyperlinks
	"""
	soup = BeautifulSoup(HTML)
	link_list = [link.get('href') for link in soup.find_all('a')]
	return link_list
raw_data = load_pickle(options.raw_pickle_path)
articles = load_pickle(options.current_articles_path)
for request in raw_data:
	article_list = request['response']['results']
	for a in article_list:
		
		save_key = a['id']
		print "Article: %s" %(save_key)
		
		if options.overwrite_articles:
			articles.pop(save_key, None)
			print "Deleting previous data (i.e. we will overwrite with new data)."
		
		if save_key in articles:
			print "We have already covered this article, skipping..."
			continue
		tags = a['tags']
		save_tags = []
		for t in tags:
			save_tags.append(

		
		save_sectionName = a['sectionName']
		save_sectionId = a['sectionId']
		save_webPublicationDate = a['webPublicationDate']
		save_date = general_functions.convert_str_to_date(a['webPublicationDate'])  
		save_webUrl = a['webUrl']
		
		try:
			save_headline = a['fields']['headline']
		except:
			save_headline = ""
		try:
			save_standfirst = a['fields']['standfirst']
		except:
			save_standfirst = ""
		try:
			save_byline = a['fields']['byline']
		except:
			save_byline = ""
		try:
			save_body = a['fields']['body']
		except:
			save_body = ""
		try:
			save_thumbnail = a['fields']['thumbnail']
		except:
			save_thumbnail = ""
		save_internal_links = ""
		if options.find_internal_links:
			try:
				soup = BeautifulSoup(save_body)
				save_internal_links = [link.get('href') for link in soup.find_all('a') if 'theguardian.com' in link.get('href')]
			except:
				None
		print "Adding data to articles store."
		articles[save_key] = 	{
									'id' : save_key,
									'sectionName' : s
class Application: 
	"""
		Class that handles application logic.
	"""
	def run(self):
		"""
			Handles applcation run.
		"""
		try: 
			self.media.run()
		except RuntimeError:
			self.exit()
	def __init__ (self, media, user_repository, data_repository, bill_repository):
		"""
			Handles application logic init. Binds itself to media. Takes parameter for media class instance.
			Sets menu tree data repository. Takes parameter data repository.
			Sets user data repository. Takes parameter user repository.
			Sets bill data repository. Takes parameter bill repository.
		"""
		self.media = media
		self.media.bind_application(self)
		self.user_repository = user_repository
		self.data_repository = data_repository
		self.bill_repository = bill_repository
	def authenticate_user(self, user,password):
		"""
			Authenticate user.
		"""
		details = self.user_repository.authenticate_user(user, password)
		if details == False:
			return False
		else:
			self.user_id = details
			return True
	def logo

		self.user_id = None
	def get_data(self):
		"""
			Gets menu tree data.
		"""
		return self.data_repository.get_data()
	def get_rent_items(self):
		"""
			Gets rent items data
		"""
		
		return self.data_repository.get_rent_items(self.get_user_id())
	def get_bill(self):
		"""
			Get bill data
		"""
		return self.bill_repository.get_data()
	def add_item(self, data): 
		"""
			Add item to bill. Takes parameter item data.
		"""
		self.bill_repository.add(data)
	def remove_item(self,index): 
		"""
			Removes a given index item from bill. Takes parameter index.
		"""
		self.bill_repository.remove(index)
	def clear_items(self):
		"""
			Clear items from bill.
		"""
		self.bill_repository.clear()
	def checkout(self):
		"""
			Marks the data as rent to user.
		"""
		user_id= self.get_user_id()
		data = self.bill_repository.get_data()
		for item in data:
			self.data_repository.borrow(user_id, item["id"])
		self.bill_repository.clear()
	def return_item(self, index): 
		"""
			Marks the item a
"""
module handing the attributes pages
Created: Aug 26, 2013
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class GroupController(BaseController):
  """Controller handling all the requests for groups"""
  def __init__(self, config, session=None):
    BaseController.__init__(self, config, session)
  def get_group_by_uuid(self, uuid):
    try:
      return self.group_broker.get_by_uuid(uuid)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise ControllerException(error)
  def get_all_groups(self):
    try:
      return self.group_broker.get_all()
    except BrokerException as error:
      raise ControllerException(error)
  def get_group_by_id(self, group_id):
    try:
      return self.group_broker.get_by_id(group_id)
    except NothingFoundException as error:
      raise ControllerNothing

    except BrokerException as error:
      raise ControllerException(error)
  def get_group_by_name(self, group_name):
    try:
      return self.group_broker.get_by_name(group_name)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise ControllerException(error)
  def insert_group(self, group, validate=True, commit=True):
    try:
      self.group_broker.insert(group, commit, validate)
    except ValidationException as error:
      message = ObjectValidator.getFirstValidationError(group)
      raise ControllerException(u'Could not add group due to: {0}'.format(message))
    except IntegrityException as error:
      raise ControllerIntegrityException(error)
    except (BrokerException) as error:
      raise ControllerException(error)
  def update_group(self, group):
    try:
      self.group_broker.update(group)
      return group
    except ValidationException as error:
      message = ObjectVali

      raise ControllerException(u'Could not update group due to: {0}'.format(message))
    except BrokerException as error:
      raise ControllerException(error)
  def remove_group_by_id(self, identifier):
    try:
      self.group_broker.remove_by_id(identifier)
    except IntegrityException as error:
      raise ControllerException('Cannot delete group. The group is referenced by elements. Disable this group instead.')
    except DeletionException:
      raise ControllerException('This group cannot be deleted')
    except BrokerException as error:
      raise ControllerException(error)
  def remove_group_by_uuid(self, uuid):
    try:
      self.group_broker.remove_by_uuid(uuid)
    except IntegrityException as error:
      raise ControllerException('Cannot delete group. The group is referenced by elements. Disable this group instead.')
    except DeletionException:
      raise ControllerException('This group cannot be deleted')
    except BrokerException as error:
      raise Contr
def repository_list(request, template_name='gitweb/repository_list.html'):
    template_context = {
        'repository_list': Repository.objects.visible_repositories_for_user(request.user),
    }
    
    return render_to_response(
        template_name,
        template_context,
        RequestContext(request)
    )
def repository_summary(request, slug, template_name='gitweb/repository_summary.html'):
    try:
        repository = Repository.objects.visible_repositories_for_user(request.user).get(slug=slug)
    except Repository.DoesNotExist:
        raise Http404
    
    clone_url = settings.GIT_CLONE_URL % os.path.split(repository.path)[1]
    
    template_context = {
        'repository': repository,
        'clone_url': clone_url,
    }
    return render_to_response(
        template_name,
        template_context,
        RequestContext(request)
    )
def repository_log(request, slug, branch=None, template_name='gitweb/repository_log.html'):
    try:
        repository = Repos

    except Repository. Repository.DoesNotExist:
        raise Http404
    
    if branch == None:
        logs = repository.repo().log()
        branch = "All"
    else:
        logs = repository.repo().log(branch)
    
    template_context = {
        'repository': repository,
        'branch':branch,
        'logs': logs
    }
    return render_to_response(
        template_name,
        template_context,
        RequestContext(request)
    )
def repository_tree(request, slug, branch, path, template_name='gitweb/repository_tree.html'):
    try:
        repository = Repository.objects.visible_repositories_for_user(request.user).get(slug=slug)
    except Repository.DoesNotExist:
        raise Http404
    tree = repository.repo().tree(branch)
    for element in path.split('/'):
        if len(element):
            tree = tree/element
    if hasattr(tree, 'mime_type'):
        is_blob = True
    else:
        is_blob = False
        tree = [{'path': os.path.join(path, e.name), 'e': e, '

    template_context = {
        'repository': repository,
        'branch': branch,
        'path': os.path.join('/', path),
        'prev_path': '/'.join(path.split('/')[0:-1]),
        'tree': tree,
        'is_blob': is_blob,
    }
    if is_blob:
        template_context.update({
            'blob_human_size': human_filesize(tree.size),
            'blob_lines': range(len(tree.data.splitlines())),
            'blob_pygmentized': pygmentize(tree.mime_type, tree.data),
        })
    return render_to_response(
        template_name,
        template_context,
        RequestContext(request)
    )
def repository_commit(request, slug, commit, template_name='gitweb/repository_commit.html'):
    try:
        repository = Repository.objects.visible_repositories_for_user(request.user).get(slug=slug)
    except Repository.DoesNotExist:
        raise Http404
    try:
        commit = repository.repo().commit(commit)
    except:
        raise Http404
    
    template_context = {
        're
'''
Created on Jan 10, 2013
@author: dough
'''
class ApplicationBoundary(object):
    '''
    classdocs
    '''
    def __init__(self):
        '''
        Constructor
        '''
        sf = SourceFactory()
        master_source_list = []
        channels_conf_file = open('/home/dough/Downloads/channels.conf')
        master_source_list += sf.produce_batch(channels_conf_file)
        self.view_sources_controller = ViewSourcesController(master_source_list)        
        self.master_recording_schedule_list = []
        self.schedule_recording_controller = ScheduleRecordingController(master_source_list, 
                                                                         self.master_recording_schedule_list)
        self.view_schedules_controller = ViewSchedulesController(self.master_recording_schedule_list)
    
    def list_sources(self, request):
        return self.view_sources_controller.list_sources(request)
    
    def list_schedules(self, request):
        return self.vie
broker="localhost" 
port=1883
sensor="tempdetector"
topic="temperature"
HOST = ''
PORT = 8888 
def sendValueToGalileoBroker(mqttc):
	tempbool = False;
	p = pexpect.spawn("sh",["/etc/init.d/clloader.sh"],timeout=None,logfile=None)
	line = p.readline()
	print "sh has been launched "+line
	while line:
                print line
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect((HOST, PORT))
                print "let's goooo trueee"
		while True:
			data = s.recv(32)
			str = data.split(' ')
			print data
			if tempbool :
				print "allume LED"
				s.send('H')
				tempbool=False
			else : 
				print "extinction LED"
				s.send('L')
				tempbool=True
def listenMessageFromCentralBroker(mqttc):
    print "LOADDD"
if __name__ == "__main__":
    mqttc = mosquitto.Mosquitto(sensor)
    mqttc.connect(broker,port,60)
    a = threading.Thread(None, listenMessageFromCentralBroker, None, (mqttc,), {}) 
    b = threading.Thread(None, sendValueToGalileoBroker, None, (mqttc,), {}) 
  
logs_information = [
    ['launch_instance', 'Instance Manage', 'add',
     'user %(user)s %(create_at)s created instance', 'true'],
    ['instance_delete', 'Instance Manage', 'del',
     'user %(user)s %(create_at)s deleted instance', 'true'],
    ['delete_instances', 'Instance Manage', 'del',
     'user %(user)s %(create_at)s batch deleted instance', 'true'],
    ['instance_reboot', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s reboot instance', 'true'],
    ['instance_pause', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s paused instance', 'false'],
    ['instance_unpause', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s unpaused instance', 'false'],
    ['instance_stop', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s stopped instance', 'true'],
    ['instance_unstop', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s unstopped instance', 'false'],
    ['change_pwd', 'Instance Manage', 'edit',
     'user %(user)s %(c

    ['update_instance', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s updated instance', 'false'],
    ['create_snapshot', 'Instance Manage', 'add',
     'user %(user)s %(create_at)s created snapshot', 'false'],
    ['restore_instance_data', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s restored instance data', 'false'],
    ['set_snapshot_public', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s set snapshot public', 'false'],
    ['distribution_instance_to_user', 'Instance Manage', 'add',
     'user %(user)s%(create_at)s add user to instance', 'false'],
    ['delete_distribution', 'Instance Manage', 'del',
     'user %(user)s %(create_at)s deleted user from instance', 'false'],
    ['select_instance_classify', 'Instance Manage', 'add',
     get_text('user %(user)s %(create_at)s create instance classify'), 'false'],
    ['instance_flavor_update', 'Instance Manage', 'edit',
     get_text('user %(user)s %(create_at)s updated instance flavor'), 
class ManageContext(DefaultContext):
    "Default context factory for Manage views."
    implements(IManageView)
class ManageSidebarRenderer(SidebarRenderer):
    def render(self, request):
        self.actions.append(HeaderSidebarAction('manage',content=u'Manage penelope', permission='manage', no_link=True))
        self.actions.append(SidebarAction('manage_users',
                                          content=u'Manage users',
                                          permission='manage',
                                          attrs=dict(href="'%s/admin/User' % request.application_url")))
        self.actions.append(SidebarAction('manage_roles',
                                          content=u'Manage roles',
                                          permission='manage',
                                          attrs=dict(href="'%s/admin/Role' % request.application_url")))
        self.actions.append(SidebarAction('manage_groups',
                                          co

                                          permission='manage',
                                          attrs=dict(href="'%s/admin/Group' % request.application_url")))
        self.actions.append(SidebarAction('manage_svn_authz',
                                          content=u'Manage SVN authz',
                                          permission='manage_svn',
                                          attrs=dict(href="'%s/manage/svn_authz' % request.application_url")))
        actions = self.actions.render(request)
        template =  get_renderer('por.dashboard.forms:templates/project_sidebar.pt').implementation()
        return template(actions=actions,
                        request=request)
gsm = zope.component.getGlobalSiteManager()
gsm.registerAdapter(ManageSidebarRenderer, (IManageView,), ISidebar)
@view_config(route_name='administrator', permission='manage', renderer='skin')
def manage_home(request):
    return {}
@view_config(route_name='manage_svn_authz', renderer='sk
"""
    Supply
    Generic Supply functionality such as catalogs and items that are used across multiple applications
"""
module = request.controller
resourcename = request.function
if not settings.has_module("supply"):
    raise HTTP(404, body="Module disabled: %s" % module)
def index():
    """
        Application Home page
    """
    module_name = settings.modules[module].name_nice
    response.title = module_name
    return dict(module_name=module_name)
def brand():
    """ RESTful CRUD controller """
    return s3_rest_controller()
def catalog():
    """ RESTful CRUD controller """
    return s3_rest_controller(rheader=s3db.supply_catalog_rheader)
def catalog_item():
    """ RESTful CRUD controller """
    return s3_rest_controller()
def distribution():
    """ RESTful CRUD controller """
    return s3_rest_controller(hide_filter=False)
def distribution_report():
    """
        RESTful CRUD controller for Supply Distributions
        - limited to just seeing aggregated data for 
class Repository:
    def __init__(self,api):
        self.api = api
class DatacenterRepository(Repository):
    def __init__(self,api):
        Repository.__init__(self,api)
    def create(self,params=ParamFactory().create_datacenter()):
        if('datcenters' in dir(self.api)):
            return self.api.datacenters.add(params)
    def show(self, datacenter):
        if('datcenters' in dir(self.api)):
            return self.api.datacenters.get(datacenter.get_name())
    def destroy(self, datacenter):
        if('datcenters' in dir(self.api)):
            datacenter_broker = self.show(datacenter)
            datacenter_broker.delete()
class ClusterRepository(Repository):
    def __init__(self,api):
        Repository.__init__(self,api)
    def show(self, cluster):
        return self.api.clusters.get(cluster.get_name())
    def create(self,params=ParamFactory().create_cluster()):
        return self.api.clusters.add(params)
    def destroy(self,cluster):
        cluster_broker = se
"""
    Sahana Eden Stats Controller
"""
module = request.controller
resourcename = request.function
if not settings.has_module(module):
    raise HTTP(404, body="Module disabled: %s" % module)
def parameter():
    """ REST Controller """
    return s3_rest_controller()
def data():
    """ REST Controller """
    return s3_rest_controller()
def source():
    """ REST Controller """
    return s3_rest_controller()
def demographic():
    """ REST Controller """
    return s3_rest_controller()
def demographic_data():
    """ REST Controller """
    return s3_rest_controller()
def demographic_aggregate():
    """ REST Controller """
    def clear_aggregates(r, **attr):
        if not s3_has_role(ADMIN):
            auth.permission.fail()
        s3db.stats_demographic_rebuild_all_aggregates()
        redirect(URL(c="stats",
                     f="demographic_aggregate",
                     args="",
                     ))
        
    s3db.set_method("stats", "demographic_aggregate",
   
try:
except ImportError:
__all__ = ['Measure', 'TimingStat', 'enable', 'disable', 'init', 'shutdown']
log = getLogger(__name__)
_save_manager = None
_measure_session = None
_save_queue = None
_save_process = None
TimingStat = namedtuple(
        "TimingStat",
        ["timestamp", "session", "name", "code", "call_count", "recursive_call_count",
        "time_total", "time_function", "calls"])
class Measure:
    time_factor = 1000
    def __init__(self,
            measure_session=None,
            measure_point_name=None,
            save_queue=None,
            data=None):
        if data is None:
            self.measure_session = measure_session
            self.point_name = measure_point_name
            self._save_queue = save_queue
            self._profile = Profile()
        else:
            self.measure_session = data[0]
            self.point_name = data[1]
            self.load(data[2])
    def load(self, data):
        self.timings = data
    def start(self):
        self.

        return self
    def stop(self):
        self._profile.disable()
        self.stats = self._profile.getstats()
        self.timings = list()
        self.timestamp = datetime.utcnow()
        for stat in self.stats:
            if stat.calls is not None:
                calls = list()
                for call in stat.calls:
                    calls.append(TimingStat(
                            self.timestamp,
                            str(self.measure_session),
                            str(self.point_name),
                            str(call.code),
                            call.callcount,
                            call.reccallcount,
                            call.totaltime * time_factor,
                            call.inlinetime * time_factor,
                            None))
            else:
                calls = None
            self.timings.append(TimingStat(
                    self.timestamp,
                    str(self.measure_session),
           

                    str(stat.code),
                    stat.callcount,
                    stat.reccallcount,
                    stat.totaltime * time_factor,
                    stat.inlinetime * time_factor,
                    calls))
        return self
    def save(self):
        self._save_queue.put_nowait((self.measure_session, self.point_name,
                self.timings))
        return self
    def __str__(self):
        buf = "<{0}: measure_session='{1}' point_name='{1}'".format(
                self.__class__, self.measure_session, self.point_name)
        if hasattr(self, "stat"):
            buf += ", stat='{}'".format(self.stats)
        if hasattr(self, "timing"):
            buf += ", timing='{}'".format(self.timings)
        buf += ">"
        return buf
def enable(measure_point_name):
    global _save_manager
    global _save_queue
    global _measure_session
    if _measure_session.value is None:
        _measure_session = _save_manager.Value(str,
              
def cut_permissions(folder):
  folder.manage_permission('Access contents information',
                            roles=['Anonymous', 'Manager'])
  folder.manage_permission('Add Documents, Images, and Files',
                            roles=['Manager'])
  folder.manage_permission('Add Envelopes', roles=['Manager'])
  folder.manage_permission('Audit Envelopes',
                            roles=['ClientFG', 'ClientODS', 'Manager'])
  folder.manage_permission('Change Collections', roles=['Manager'])
  folder.manage_permission('Change Envelopes', roles=['Manager'])
  folder.manage_permission('Delete objects', roles=['Manager'])
  folder.manage_permission('Manage properties', roles=['Manager'])
  folder.manage_permission('Release Envelopes',
                            roles=['ClientFG', 'ClientODS', 'Manager'])
  folder.manage_permission('Take ownership', roles=['Manager'])
  folder.manage_permission('Use OpenFlow',
                            roles=['ClientFG', 'ClientODS', 'Manager']

  folder.manage_permission('WebDAV Lock items', roles=['Manager'])
  folder.manage_permission('WebDAV Unlock items', roles=['Manager'])
def restore_permissions(folder):
  folder.manage_permission('Access contents information', acquire=1)
  folder.manage_permission('Add Documents, Images, and Files', acquire=1)
  folder.manage_permission('Add Envelopes', acquire=1)
  folder.manage_permission('Audit Envelopes', acquire=1)
  folder.manage_permission('Change Collections', acquire=1)
  folder.manage_permission('Change Envelopes', acquire=1)
  folder.manage_permission('Delete objects', acquire=1)
  folder.manage_permission('Manage properties', acquire=1)
  folder.manage_permission('Release Envelopes', acquire=1)
  folder.manage_permission('Take ownership', acquire=1)
  folder.manage_permission('Use OpenFlow', acquire=1)
  folder.manage_permission('WebDAV Lock items', acquire=1)
  folder.manage_permission('WebDAV Unlock items', acquire=1)
def forwards(app):
  ods = app.unrestrictedTraverse('
admin.autodiscover()
urlpatterns = patterns('',
    (r'^admin/doc/', include('django.contrib.admindocs.urls')),
    (r'^admin/', include(admin.site.urls)),
		(r'^$', 'django.contrib.auth.views.login'),
		(r'^files/(?P<path>.*)$', 'django.views.static.serve', {'document_root': settings.STATIC_DOC_ROOT}),
		(r'login/$', 'django.contrib.auth.views.login'),
		(r'login$', 'django.contrib.auth.views.login'),
		(r'register/$', 'broker.views.register'),
		(r'register$', 'broker.views.register'),
		(r'profile/$', 'broker.views.profile'),
		(r'profile$', 'broker.views.profile'),
		(r'logout/$', 'broker.views.logout_view'),
		(r'logout$', 'broker.views.logout_view'),
		(r'register_contributor/$', 'broker.views.register_contributor'),
		(r'register_contributor$', 'broker.views.register_contributor'),
		
		(r'get_consumers/$', 'broker.views.get_consumers'),
		(r'get_consumers$', 'broker.views.get_consumers'),
		(r'display/$', 'broker.views.display'),
		(r'display$', 'broker.views.display'),
		(r'ge
try:
except ImportError:
class ZopeRepository(
    Repository.Repository,
    RoleManager,
    OFS.SimpleItem.Item
    ):
    """The ZopeRepository class builds on the core Repository implementation
       to provide the Zope management interface and other product trappings."""
    security = AccessControl.ClassSecurityInfo()
    meta_type = 'Repository'
    manage_options=(
        ( {'label': 'Contents',    'action':'manage_main',
           'help': ('ZopeVersionControl', 'Repository-Manage.stx')},
          {'label': 'Properties', 'action':'manage_properties_form',
           'help': ('ZopeVersionControl', 'Repository-Properties.stx')},
        ) +
        RoleManager.manage_options +
        OFS.SimpleItem.Item.manage_options
        )
    security.declareProtected('View management screens', 'manage_main')
    manage_main = DTMLFile('dtml/RepositoryManageMain', globals())
    manage_main._setName('manage_main')
    manage = manage_main
    def __init__(self, id=None, title=''):
   

        if id is not None:
           self._setId( id )
        self.title = title
    security.declareProtected(
        'View management screens','manage_properties_form'
        )
    manage_properties_form = DTMLFile('dtml/RepositoryProperties', globals())
    security.declareProtected('Manage repositories', 'manage_edit')
    def manage_edit(self, title='', REQUEST=None):
        """Change object properties."""
        self.title = title
        if REQUEST is not None:
            message="Saved changes."
            return self.manage_properties_form(
                self, REQUEST, manage_tabs_message=message
                )
    def __getitem__(self, name):
        history = self._histories.get(name)
        if history is not None:
            return history.__of__(self)
        raise KeyError, name
    security.declarePrivate('objectIds')
    def objectIds(self, spec=None):
        return SequenceWrapper(self, self._histories.keys())
    security.declarePrivate('objectValues'
IMAGE_TITLES = {"Azure 云服务高级功能":"Azure-Cloud Services-Advanced-Features",
                "Azure媒体服务动态打包介绍":"Media Services-Dynamically-Package",
                "Azure移动服务的数据管理":"Azure-Mobile Services-Data Management",
                "Azure管理存储文件及管理工具":"Manage-Storage File-And-Management Tools",
                "Azure网站的扩展功能":"Azure-Websites-Extended-Features",
                "Azure虚拟机高级使用技巧":"Azure-VM-Advanced-Usage",
                "Azure虚拟网络介绍":"Networking-introduction",
                "Azure高级存储简介":"Azure-Advanced-Storage-Introduction",
                "HDInsight（云上Hadoop）介绍":"HDInsight Introduction",
                "SQL数据库迁移到云端":"Migrate-SQL-To-Azure",
                "SQL数据库防火墙规则介绍":"SQL-Firewall-Rule-Introduction",
                "使用Azure移动服务开发多个平台应用":"Use-Azure-Mobile Services-To-Develop-Multi-Apps",
                "使用PowerShelll管理Traffic Manager":"Use-PowerShell-To-Manage-Traffic Manager",
                "使用Visual Studio部署应用程序到Azure云服务":"Use-Visual Studio-To-Deploy-Ap

                "在Azure门户中创建和删除虚拟机":"Create-Delete-VM-In-Portal",
                "在Azure门户中管理Active Directory":"Manage-Active Directory-In-Portal",
                "在Azure门户中管理CDN":"Manage-CDN-In-Portal",
                "在Azure门户中管理HDInsight（云上的Hadoop）":"Manage-HDInsight-In-Portal",
                "在Azure门户中管理Service Bus":"Manage-Service Bus-In-Portal",
                "在Azure门户中管理SQL数据库":"Manage-SQL-In-Portal",
                "在Azure门户中管理Traffic Manager":"Manage-Traffic Manager-In-Portal",
                "在Azure门户中管理备份服务":"Manage-Backup Services-In-Portal",
                "在Azure门户中管理媒体服务":"Manage-Media Services-In-Portal",
                "在Azure门户中管理存储":"Mange-Storage-In-Portal",
                "在Azure门户中管理移动服务":"Manage-Mobile Services-In-Portal",
                "在Azure门户中管理网站":"Manage-Websites-In-Portal",
                "在Azure门户中管理虚拟机网络":"Manage-Networking-In-Portal",
                "在Azure门户中管理计划程序":"Manage-Scheduler-In-Portal",
                "在Azure门户中管理通知中心":"Manag
"""
    Sahana Eden Stats Controller
"""
module = request.controller
resourcename = request.function
if not settings.has_module(module):
    raise HTTP(404, body="Module disabled: %s" % module)
def index():
    """ Module's Home Page """
    return s3db.cms_index(module, alt_function="index_alt")
def index_alt():
    """
        Module homepage for non-Admin users when no CMS content found
    """
    s3_redirect_default(URL(f="demographic_data", args="summary"))
def parameter():
    """ REST Controller """
    return s3_rest_controller()
def data():
    """ REST Controller """
    return s3_rest_controller()
def source():
    """ REST Controller """
    return s3_rest_controller()
def demographic():
    """ REST Controller """
    return s3_rest_controller()
def demographic_data():
    """ REST Controller """
    return s3_rest_controller()
def demographic_aggregate():
    """ REST Controller """
    def clear_aggregates(r, **attr):
        if not s3_has_role(ADMIN):
            auth.
class ModelBase(models.Model):
    ''' 
    To be used by all base models. A a base model is any model
    that could be used as a standalone model. 
    '''
    class Meta:
        abstract = True
    def model_save(self, *args, **kargs):
        ''' Call the default model save '''
        models.Model.save(self, *args, **kargs)
    def save(self, *args, **kargs):
        '''
        Overrides default save behavior to call _pre_save and _post_save from 
        any interfaces that this model inherits from, as well as pre_save
        and post_save on the model itself.
        '''
        self._super_pre_save()
        models.Model.save(self, *args, **kargs)
        self._super_post_save()
    def _super_pre_save(self):
        '''
        Calls every _pre_save on any parent class (interface), calls pre_save
        on the model itself.
        '''
        if hasattr(self.__class__, 'pre_save'):
            self.__class__.pre_save(self)
        for cls in self.__class__.__bases__:
    
try:
	base = EDCBA.BrokerNameService
except:
	base = object
class Registration:
	'''Registration object used as a holding place for
	registration information'''
	def __init__(self, controlBroker, address):
		self.brokername = controlBroker
		self.ior        = address
		self.auth       = None
	def getBrokerName(self):
		'''Returns the Broker's Name'''
		return self.brokername
	def getAddress(self):
		'''Returns the Broker's Address'''
		return self.ior
	def getAuth(self):
		'''Returns a generated authtication string'''
		if not self.auth:
			self.auth = md5()
			self.auth.update(self.brokername)
			self.auth.update(self.ior)
		return self.auth.hexdigest()
class NameService( base ):
	def __init__(self):
		print "Starting Broker Name Service"
		print "Waiting for registrations..."
		self.registered = {}
	def nsregister(self, controlBroker, address):
		print "Registering %s (%s)" % (controlBroker,address)
		if controlBroker in self.registered:
			print "ERROR: %s attempted to re-register w

				(controlBroker)
			return None
		self.registered[controlBroker ] = Registration(controlBroker,address)
		return self.registered[controlBroker].getAuth()
	def deregister(self, auth, controlBroker):
		print "Deregistering %s" % (controlBroker)
		try:
			found = self.registered[controlBroker]
			if found.getAuth() == auth:
				del self.registered[controlBroker]
				return True
			else:
				print "Incorrect auth string for %s" % (controlBroker)
				return False
		except:
			print "ERROR: Failed to deregister %s" % (controlBroker)
			return False
	def getRegistered(self):
		return self.registered.keys()
	def getAddressOf(self, controlBroker):
		try:
			found = self.registered[controlBroker]
			return found.getAddress()
		except:
			return None
def quitHandler(signum, frame):
	raise KeyboardInterrupt
if __name__ == '__main__':
	orb = CORBA.ORB_init(sys.argv)
	server = NameService()
	objref = server._this()
	file('/tmp/BrokerNameService.ior', 'w').write(orb.object_to_string(objref))
	poa
class TestBroker(unittest.TestCase):
    broker_module_path = path.join('..', 'broker.py')
    broker_test_caching_plugin = 'test_broker_plugin.py'
    broker_test_caching_plugin_name = broker_test_caching_plugin.rsplit('.',1)[0]
    
    def setUp(self):
        self.broker_module = load_source('broker', self.broker_module_path)
        self.rxq = Queue()
        self.txq = Queue()
        self.broker = self.broker_module.Broker(self.rxq, self.txq)
        self.broker_process = Process(target=self.broker.start)
    
    def test_caching(self):
        self.broker.add_plugin(self.broker_test_caching_plugin_name, self.broker_test_caching_plugin)
        self.broker_process.start()
        unique_value1 = uuid().hex
        msg = events.Unknown(target="caching", msg=unique_value1)
        self.rxq.put(msg)
        
        unique_value2 = uuid().hex
        msg = events.Unknown(target="caching", msg=unique_value2)
        self.rxq.put(msg)
        
        test_val = self.txq.get(timeout
admin.autodiscover()
urlpatterns = patterns('',
    url(r'^$', UserAPI.as_view()),
    url(r'^auth/login/?$', 'rest_framework.authtoken.views.obtain_auth_token', name="login"),
    url(r'^auth/load/?$', LoginAPI.as_view(), name="load"),
    url(r'^auth/logout/?$', LogoutAPI.as_view(), name="logout"),
    url(r'^answers/(?P<rid>[0-9]{1,9})/?$', AnswerAPI.as_view()),
    url(r'^answers/?$', AnswerAPI.as_view()),
    url(r'^comments/(?P<content_type>question|answer|comment)/(?P<rid>[0-9]{1,9})/?$', CommentAPI.as_view()),
    url(r'^votes/(?P<content_type>question|answer|comment)/(?P<rid>[0-9]{1,9})/?$', VoteAPI.as_view()),
    url(r'^questions/(?P<rid>[0-9]{1,9})/?$', QuestionAPI.as_view()),
    url(r'^questions/?$', QuestionAPI.as_view()),
    url(r'^tags/?$', TagAPI.as_view()),
    url(r'^organizations/(?P<organization_id>[0-9]{1,9})/?$', OrganizationAPI.as_view()),
    url(r'^organizations/?$', OrganizationAPI.as_view()),
    url(r'^courses/?$', CourseAPI.as_view()),
    url(r'^admin/'
class TestSelectionController(unittest.TestCase):
    def setUp(self):
        self.controller = audioselector.SelectionController(0, 100)
    def test_create_partition(self):
        self.assertEqual(0, self.controller.create_partition(50))
        self.assertEqual(1, self.controller.create_partition(75))
        self.assertEqual(2, self.controller.create_partition(100))
        self.assertEqual(0, self.controller.create_partition(25))
        self.assertEqual(0, self.controller.create_partition(10))
        self.assertEqual(1, self.controller.create_partition(20))
        self.assertEqual(3, self.controller.create_partition(40))
    def test_get_partitions(self):
        self.assertEqual([], self.controller.get_partitions())
        self.assertEqual(0, self.controller.create_partition(90))
        self.assertEqual([90], self.controller.get_partitions())
        self.assertEqual(0, self.controller.create_partition(10))
        self.assertEqual([10, 90], self.controller.get_partitions(

        self.assertEqual(1, self.controller.create_partition(50))
        self.assertEqual([10, 50, 90], self.controller.get_partitions())
        self.assertEqual(2, self.controller.create_partition(50))
        self.assertEqual([10, 50, 50, 90], self.controller.get_partitions())
    def test_create_partition_out_of_range(self):
        self.assertRaises(ValueError, self.controller.create_partition, -1)
        self.assertRaises(ValueError, self.controller.create_partition, 100.001)
    def test_partition_callbacks(self):
        cbs = []
        self.controller.on_partition_created(lambda i: cbs.append(i))
        self.controller.create_partition(10)
        self.assertEqual([0], cbs)
        self.controller.create_partition(90)
        self.assertEqual([0, 1], cbs)
        self.controller.create_partition(50)
        self.assertEqual([0, 1, 1], cbs)
        self.controller.create_partition(75)
        self.assertEqual([0, 1, 1, 2], cbs)
        self.controller.create_partition(5)
 

        self.controller.create_partition(95)
        self.assertEqual([0, 1, 1, 2, 0, 5], cbs)
    def test_remove_partition(self):
        self.controller.create_partition(40)
        self.controller.create_partition(60)
        self.controller.create_partition(20)
        self.controller.create_partition(80)
        self.controller.create_partition(90)
        self.controller.create_partition(66.7)
        self.assertEqual([20, 40, 60, 66.7, 80, 90],
                         self.controller.get_partitions())
        self.assertRaises(IndexError, self.controller.remove_partition, 6)
        self.controller.remove_partition(1)
        self.assertEqual([20, 60, 66.7, 80, 90],
                         self.controller.get_partitions())
        self.controller.remove_partition(4)
        self.assertEqual([20, 60, 66.7, 80],
                         self.controller.get_partitions())
        self.controller.remove_partition(0)
        self.assertEqual([60, 66.7, 80],
                       
parser = argparse.ArgumentParser(description="Read a text stream and send it to an AMQP broker")
parser.add_argument("hostname", help="Hostname of the AMQP broker")
parser.add_argument("exchange", help="Exchange to use on the AMQP broker")
parser.add_argument("-v", "--vhost", help="Virtual host to use on the AMQP broker", default="/")
parser.add_argument("-u", "--user", help="User for the AMQP broker", default="guest")
parser.add_argument("-p", "--password", help="Password for the AMQP broker", default="guest")
def main():
    logging.basicConfig(level=logging.INFO)
    args = parser.parse_args()
    conn = BrokerConnection(
            hostname=args.hostname,
            virtual_host=args.vhost,
            userid=args.user,
            password=args.password,
    )
    consumer = Consumer(
            auto_declare    = False,
            connection      = conn,
            exclusive       = True,
            auto_delete     = True,
    )
    try:
        logging.info("Creating exchan
'''
Created on April 05, 2013
@author: AxelVoitier
@license: GNU LGPL v3
Python module allowing to create a ALBroker as if it was a
contextmanager (use with the 'with' statement).
It will also try to resolve automatically all IPs and ports of NaoQis
we could connect to.
'''
warnings.simplefilter('default', DeprecationWarning)
        
        
def _resolve_ip_port(nao_id=None, nao_port=None):
    '''
    Return a tuple (ip, port) of detectable or probable NAO.
    The suggested ID can be an IP address, a hostname like bobot.local,
    or a robot name like bobot.
    '''
    if nao_id is None:
        nao_port = None
    else:
        nao_id = str(nao_id)
        
    all_naos = avahi.find_all_naos()
        
    if nao_port is None:
        if nao_id is not None:
            return _resolve_from_id(all_naos, nao_id)
        else:
            return _suggest_ip_port(all_naos)
    else:
        nao_ip, _ = _resolve_from_id(all_naos, nao_id)
        return nao_ip, int(nao_port) 
    
def 

    '''
    Return a tuple (ip, port) corresponding to a robot 'ID'.
    The ID can be an IP address, a hostname like bobot.local,
    or a robot name like bobot.
    '''
    nao_found = _filter_naos(all_naos, lambda a_nao: nao_id in a_nao.values())
    return nao_found if nao_found else (nao_id, 9559)
    
def _suggest_ip_port(all_naos):
    '''
    Return a tuple (ip, port) likely to be an available NAO around.
    Warning: can do wild guesses.
    '''
    favorite = _filter_naos(all_naos, lambda a_nao: a_nao['favorite'])
    if favorite:
        return favorite
        
    local_ = _filter_naos(all_naos, lambda a_nao: a_nao['local'])
    if local_:
        return local_
    
    if all_naos:
        return all_naos[0]['ip_address'], all_naos[0]['naoqi_port']
        return 'nao.local', 9559
        
def _filter_naos(all_naos, func):
    '''
    Filter the list of all_naos based in the func function.
    func take one argument, a_nao. And return True if filtered in. And False if
  

    This function returns the first NAO (ip, port) tuple in the list of filtered
    NAOs. If none correspond, None is returned.
    '''
    filtered = [a_nao for a_nao in all_naos if func(a_nao)]
    if filtered:
        return filtered[0]['ip_address'], filtered[0]['naoqi_port']
def _get_local_ip(dest_addr):
    '''
    Return the IP of the *net interface capable of reaching dest_addr.
    '''
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.connect((dest_addr, 0))
    ip_addr = sock.getsockname()[0]
    sock.close()
    return ip_addr
    
@contextmanager
def create(broker_name, broker_ip=None, broker_port=0,
           nao_id=None, nao_port=None, **kwargs):
    '''
    Create a broker with the given name.
    Automatically find out NAO IP. Set the broker to listen only on the
    IP that is on the same network than NAO.
    You can specify broker_ip to listen to localhost only (127.0.0.1)
    or to everybody (0.0.0.0).
    
    It acts as a context manager. Whi
def initialize(context):
    from Products.PluginIndexes.FieldIndex.FieldIndex \
    from Products.PluginIndexes.FieldIndex.FieldIndex \
    context.registerClass(FieldIndex,
                          permission='Add Pluggable Index',
                          constructors=(manage_addFieldIndexForm,
                                        manage_addFieldIndex),
                          visibility=None,
                          )
    from Products.PluginIndexes.KeywordIndex.KeywordIndex \
    from Products.PluginIndexes.KeywordIndex.KeywordIndex \
    context.registerClass(KeywordIndex,
                          permission='Add Pluggable Index',
                          constructors=(manage_addKeywordIndexForm,
                                        manage_addKeywordIndex),
                          visibility=None,
                          )
    from Products.PluginIndexes.TopicIndex.TopicIndex \
    from Products.PluginIndexes.TopicIndex.TopicIndex \
    context.registerClass(Top

                          permission='Add Pluggable Index',
                          constructors=(manage_addTopicIndexForm,
                                        manage_addTopicIndex),
                          visibility=None,
                          )
    from Products.PluginIndexes.DateIndex.DateIndex \
    from Products.PluginIndexes.DateIndex.DateIndex \
    context.registerClass(DateIndex,
                          permission='Add Pluggable Index',
                          constructors=(manage_addDateIndexForm,
                                        manage_addDateIndex),
                          visibility=None,
                          )
    from Products.PluginIndexes.DateRangeIndex.DateRangeIndex \
    from Products.PluginIndexes.DateRangeIndex.DateRangeIndex \
    from Products.PluginIndexes.DateRangeIndex.DateRangeIndex \
    context.registerClass(DateRangeIndex,
                          permission='Add Pluggable Index',
                          constructors=(ma

                                        manage_addDateRangeIndex),
                          visibility=None,
                          )
    from Products.PluginIndexes.PathIndex.PathIndex \
    from Products.PluginIndexes.PathIndex.PathIndex \
    context.registerClass(PathIndex,
                          permission='Add Pluggable Index',
                          constructors=(manage_addPathIndexForm,
                                        manage_addPathIndex),
                          visibility=None,
                          )
        manage_addBooleanIndex
        manage_addBooleanIndexForm
    context.registerClass(BooleanIndex,
                          permission='Add Pluggable Index',
                          constructors=(manage_addBooleanIndexForm,
                                        manage_addBooleanIndex),
                          visibility=None,
                          )
        manage_addUUIDIndex
        manage_addUUIDIndexForm
    context.registerClass(UU
config = {}
config['webapp2_extras.sessions'] = {
    'secret_key': 'aklsdfnkanxcjkzbxfjkhadfsks',
class index(webapp2.RequestHandler):
    
    def dispatch(self):
        self.session_store = sessions.get_store(request=self.request)
        try:
            webapp2.RequestHandler.dispatch(self)
        finally:
            self.session_store.save_sessions(self.response)
    @webapp2.cached_property
    def session(self):
        return self.session_store.get_session()
    
    
mappings = [
    ('/', indexController.index),
    ('/gallery', galleryController.index),
    ('/profile', profileController.index),
    ('/updateprofile', updateprofileController.index),
    ('/updateprofileitems', updateprofileController.update),
    ('/user', userController.index),
    ('/userFunctions', userController.userFunctions),
    ('/uploadImage', imageController.uploadImageHandler),
    ('/addLike', imageController.addLikeHandler),
    ('/getLikes', imageController.getLikeHandler),
    ('/comment',
class BaseBrokerError(Exception):
    pass
class BrokerError(BaseBrokerError):
    def __init__(self, err_id, err_msg, f_name=None, exchange=None):
        self.err_id = err_id
        self.err_msg = err_msg
        self.f_name = f_name
        self.exchange = exchange
    def __repr__(self):
        msg = '<err_id={}, err_msg={}, f_name={}, exchange={}>'.format(
            self.err_id, self.err_msg, self.f_name, self.exchange
        )
        return msg
    def __str__(self):
        return self.__repr__()
class BrokerTimeoutError(BaseBrokerError):
    pass
class RabbitmqBroker(object):
    def __init__(self, service, config, exchange_name, queue_name,
                 handlers_map=None):
        self.broker_callback_map = {}
        self.config = config
        self.service = service
        self.broker = None
        self.broker_conn = None
        self.callback_queue = None
        self.callback_queue_name = None
        self.timeout = 10
        self.fanout_exchange_name = excha

        self.direct_exchange_name = exchange_name
        self.queue_name = queue_name + ":{}".format(self.service.service_id)
        self.direct_routing_key = self.queue_name
        self.handlers_map = handlers_map
    @defer.inlineCallbacks
    def connect_broker(self):
        delegate = TwistedDelegate()
        spec = txamqp.spec.load(self.config["rabbitmq"]["spec"])
        broker_client = ClientCreator(reactor, AMQClient, delegate=delegate, 
                                      vhost=self.config["rabbitmq"]["vhost"], 
                                      spec=spec)
        broker_conn = yield broker_client.connectTCP(self.config["rabbitmq"]["host"],
                                                     self.config["rabbitmq"]["port"])
        log.msg("Connected to broker.")
        yield broker_conn.authenticate(self.config["rabbitmq"]["user"],
                                       self.config["rabbitmq"]["password"])
        log.msg("Broker authenticated. Ready to send mes

        chan = yield broker_conn.channel(1)
        yield chan.channel_open()
        self.broker = chan
        self.broker_conn = broker_conn
        yield self.broker.queue_declare(queue=self.queue_name)
        yield self.broker.exchange_declare(exchange=self.fanout_exchange_name, type="fanout", durable=True,
                                           auto_delete=False)
        yield self.broker.exchange_declare(exchange=self.direct_exchange_name, type="direct", durable=True,
                                           auto_delete=False)
        yield self.broker.queue_bind(queue=self.queue_name, exchange=self.direct_exchange_name,
                                     routing_key=self.direct_routing_key)
        yield self.broker.queue_bind(queue=self.queue_name, exchange=self.fanout_exchange_name,
                                     routing_key='')
        yield self.broker.basic_consume(queue=self.queue_name, no_ack=True, consumer_tag=self.queue_name)
        queue = yield self.
class Controller(RestController):
    networks = networks.Controller()
    subnets = subnets.Controller()
    ports = ports.Controller()
    routers = routers.Controller()
    floatingips = floatingips.Controller()
    extensions = extensions.Controller()
    @expose('json', content_type='application/json')
    def get(self):
        return {
            "resources": [
                {
                    "links": [
                        {
                            "href": "http://localhost:9696/v2.0/subnets",
                            "rel": "self"
                        }
                    ],
                    "name": "subnet",
                    "collection": "subnets"
                },
                {
                    "links": [
                        {
                            "href": "http://localhost:9696/v2.0/networks",
                            "rel": "self"
                        }
                    ],
                    "name": "network",
       
"""Test cases for the SimpleRpcController."""
__author__ = 'nomis52@gmail.com (Simon Newton)'
class SimpleRpcControllerTest(unittest.TestCase):
  def setUp(self):
    self.callback_run = False
  def Callback(self):
    self.callback_run = True
  def testSimpleRpcController(self):
    controller = SimpleRpcController()
    self.assertFalse(controller.Failed())
    self.assertFalse(controller.IsCanceled())
    self.assertEquals(None, controller.ErrorText())
    self.assertFalse(self.callback_run)
    controller.NotifyOnCancel(self.Callback)
    controller.StartCancel()
    self.assertFalse(controller.Failed())
    self.assertFalse(not controller.IsCanceled())
    self.assertEquals(None, controller.ErrorText())
    self.assertFalse(not self.callback_run)
    self.callback_run = False
    controller.Reset()
    self.assertFalse(controller.Failed())
    self.assertFalse(controller.IsCanceled())
    self.assertEquals(None, controller.ErrorText())
    failure_string = 'foo'
    controller.Set
"""
*******************************************************************
  Copyright (c) 2013, 2014 IBM Corp.
  All rights reserved. This program and the accompanying materials
  are made available under the terms of the Eclipse Public License v1.0
  and Eclipse Distribution License v1.0 which accompany this distribution. 
  The Eclipse Public License is available at 
     http://www.eclipse.org/legal/epl-v10.html
  and the Eclipse Distribution License is available at 
    http://www.eclipse.org/org/documents/edl-v10.php.
  Contributors:
     Ian Craggs - initial implementation and/or documentation
*******************************************************************
"""
if __name__ == "__main__":
  formatter = logging.Formatter(fmt='%(levelname)s %(asctime)s %(message)s',  datefmt='%Y%m%d %H%M%S')
  ch = logging.StreamHandler()
  ch.setFormatter(formatter)
  ch.setLevel(logging.INFO)
  broker_logger = logging.getLogger('MQTT broker')
  broker_logger.addHandler(ch)
  mqtt.broker.main(sys.
c = Category(name='home')
c.save()
Page(category=c, title='Home - Property Search', url='http://www.home.co.uk', views=0).save()
Page(category=c, title='Right Move', url='http://www.rightmove.co.uk', views=0).save()
c = Category(name='sport')
c.save()
Page(category=c, title='BBC Sport', url='http://www.bbc.co.uk/sport/0/', views=0).save()
Page(category=c, title='Sky Sports', url='http://www.skysports.com/', views=0).save()
Page(category=c, title='Sports News', url='http://www.sport.co.uk/', views=0).save()
c = Category(name='fun')
c.save()
Page(category=c, title='The Fun Theory', url='http://www.thefuntheory.com/', views=0).save()
Page(category=c, title='Comp. Sci. for Fun', url='http://www.cs4fn.org/', views=0).save()
user_name = User.objects.get(username='4')
r = Restaurant(user=user_name,name='1234',table_number=10)
r.save()
Food(restaurant=r, name='red curry', description='a popular Thai dish consisting of curry paste to which coconut milk is added.', price=100).save()
Food(restaur

Food(restaurant=r, name='fire rice', description='a popular Thai dish consisting of curry paste to which coconut milk is added.', price=50).save()
Food(restaurant=r, name='noodles', description='a popular Thai dish consisting of curry paste to which coconut milk is added.', price=200).save()
Drink(restaurant=r,name="Coke").save()
Drink(restaurant=r,name="sprite").save()
Drink(restaurant=r,name="irn bru").save()
Drink(restaurant=r,name="fanta").save()
Drink(restaurant=r,name="7up").save()
Drink(restaurant=r,name="red bull").save()
Drink(restaurant=r,name="pepsi").save()
Drink(restaurant=r,name="whiskey").save()
Drink(restaurant=r,name="Beer").save()
Ingredient(restaurant=r,name="chicken", category="protein").save()
Ingredient(restaurant=r,name="beef", category="protein").save()
Ingredient(restaurant=r,name="pork", category="protein").save()
Ingredient(restaurant=r,name="fish", category="protein").save()
Ingredient(restaurant=r,name="egg", category="protein").save()
Ingredient(restauran

Ingredient(restaurant=r,name="shell", category="protein").save()
Ingredient(restaurant=r,name="rice", category="carbohydrate").save()
Ingredient(restaurant=r,name="bread", category="carbohydrate").save()
Ingredient(restaurant=r,name="sugar", category="carbohydrate").save()
Ingredient(restaurant=r,name="noodles", category="carbohydrate").save()
Ingredient(restaurant=r,name="sticky rice", category="carbohydrate").save()
Ingredient(restaurant=r,name="potato", category="carbohydrate").save()
Ingredient(restaurant=r,name="cucumber", category="vegetable").save()
Ingredient(restaurant=r,name="onions", category="vegetable").save()
Ingredient(restaurant=r,name="cabbage", category="vegetable").save()
Ingredient(restaurant=r,name="carrot", category="vegetable").save()
Ingredient(restaurant=r,name="brocoli", category="vegetable").save()
Ingredient(restaurant=r,name="spinach", category="vegetable").save()
Ingredient(restaurant=r,name="pickle", category="vegetable").save()
Ingredient(restaurant=r,n
__author__ = 'zhaolei'
logs_information = [
    ['create_controller_action', 'Common Manage', 'add', 'dsadsadsa', 'true'],
    ['controllers_instance_reboot', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s reboot instance', 'true'],
    ['controllers_instance_pause', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s paused instance', 'false'],
    ['controllers_instance_unpause', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s unpaused instance', 'false'],
    ['controllers_instance_stop', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s stopped instance', 'true'],
    ['controllers_instance_unstop', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s unstopped instance', 'false'],
    ['change_pwd', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s changed password of instance', 'false'],
    ['controllers_update_instance', 'Instance Manage', 'edit',
     'user %(user)s %(create_at)s updated instance', 'false'],
   
"""
*******************************************************************
  Copyright (c) 2013, 2014 IBM Corp.
  All rights reserved. This program and the accompanying materials
  are made available under the terms of the Eclipse Public License v1.0
  and Eclipse Distribution License v1.0 which accompany this distribution. 
  The Eclipse Public License is available at 
     http://www.eclipse.org/legal/epl-v10.html
  and the Eclipse Distribution License is available at 
    http://www.eclipse.org/org/documents/edl-v10.php.
  Contributors:
     Ian Craggs - initial implementation and/or documentation
*******************************************************************
"""
"""
1. Start the model broker.  Clean state.
2. Run the spec, one step at a time until conformance statement hit.
3. Reduce sequence to shortest.
4. Store.
Repeat until all conformance statements hit.
Do store tests that reach a conformance statement in a different way.
"""
class Brokers:
  def __init__(self):
    self.na

  def run(self):
    pass
  def stop(self):
    pass
  def reinitialize(self):
    MQTTV311_spec.state.broker.reinitialize()
  def measure(self):
    return mqtt.broker.coverage.getmeasures()
broker_log = queue.Queue()
qh = logging.handlers.QueueHandler(broker_log)
formatter = logging.Formatter(fmt='%(levelname)s %(asctime)s %(name)s %(message)s',  datefmt='%Y%m%d %H%M%S')
qh.setFormatter(formatter)
qh.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setFormatter(formatter)
ch.setLevel(logging.ERROR)
broker_logger = logging.getLogger('MQTT broker')
broker_logger.addHandler(qh)
broker_logger.propagate = False
mbt_log = queue.Queue()
qh = logging.handlers.QueueHandler(mbt_log)
formatter = logging.Formatter(fmt='%(levelname)s %(asctime)s %(name)s %(message)s',  datefmt='%Y%m%d %H%M%S')
qh.setFormatter(formatter)
qh.setLevel(logging.INFO)
mbt_logger = logging.getLogger('mbt')
mbt_logger.addHandler(qh)
mbt_logger.propagate = False
logger = logging.getLogger('suite_generate')
logger.s

ch = logging.StreamHandler()
ch.setFormatter(formatter)
ch.setLevel(logging.INFO)
logger.addHandler(ch)
logger.propagate = False
"""
Create a test.
Returns: conformance statements encountered and the lines that constitute the test.
"""
def create():
	global logger, broker_log
	conformances = set([])
	restart = False
	file_lines = []
	while not restart:
		logger.debug("stepping")
		restart = MQTTV311_spec.mbt.step()
		logger.debug("stepped")
		try:
			while (True):
				file_lines.append(data + "\n" if data[-1] != "\n" else data) 
		except:
			pass
		try:	
			data = broker_log.get(True, 0).getMessage()
		except:
			data = None
		logger.debug("data %s", data)
		while data and data.find("Waiting for request") == -1 and data.find("Finishing communications") == -1:
			if data.find("[MQTT") != -1:
				logger.debug("Conformance statement %s", data)
				if data[-1] != "\n":
					data += "\n"
				if data not in conformances:
					conformances.add(data)
			try:
				data = broker_log.get(True, 0)
class SlicerUtilSaveTests(unittest.TestCase):
  def setUp(self):
    for extension in ['nrrd', 'mrml', 'mrb']:
      try:
        os.remove(slicer.app.temporaryPath + '/SlicerUtilSaveTests.' + extension)
      except OSError:
        pass
    shutil.rmtree(slicer.app.temporaryPath + '/SlicerUtilSaveTests', True)
  def test_saveNode(self):
    node = slicer.util.getNode('MR-head')
    filename = slicer.app.temporaryPath + '/SlicerUtilSaveTests.nrrd'
    self.assertTrue(slicer.util.saveNode(node, filename))
    self.assertTrue(os.path.exists(filename))
  def test_saveSceneAsMRMLFile(self):
    filename = slicer.app.temporaryPath + '/SlicerUtilSaveTests.mrml'
    self.assertTrue(slicer.util.saveScene(filename))
    self.assertTrue(os.path.exists(filename))
  def test_saveSceneAsMRB(self):
    filename = slicer.app.temporaryPath + '/SlicerUtilSaveTests.mrb'
    self.assertTrue(slicer.util.saveScene(filename))
    self.assertTrue(os.path.exists(filename))
  def test_saveSceneAsDirectory(sel
BROKER_ENGINE = "rabbitsms.brokers.kombu"
BROKER_HOST = "localhost"
BROKER_PORT = 5672
BROKER_USER = "rabbitsms"
BROKER_PASSWORD = "rabbitsms"
BROKER_VHOST = "rabbitsms"
SMS_BACKENDS = {
    'orange': {
        'ENGINE': 'rabbitsms.backends.gammu',
    }
def setup_logging():
    root_logger = logging.getLogger('')
    root_logger.setLevel(logging.DEBUG)
    root_logger_handler = logging.StreamHandler(sys.stdout)
    root_logger_handler.setFormatter(logging.Formatter('%(asctime)s - ' \
                                                       '%(levelname)s ' \
                                                       '- %(message)s'))
    root_logger.addHandler(root_logger_handler)
if __name__ == '__main__':
    setup_logging()
    broker = {'engine': BROKER_ENGINE,
              'host': BROKER_HOST,
              'port': BROKER_PORT,
              'user': BROKER_USER,
              'password': BROKER_PASSWORD,
              'vhost': BROKER_VHOST}
    threads = []
    for name, config in SMS
class APITestCase(unittest.TestCase):
    def test_create_api(self):
        api = API("user/", {
            "doc": "Get user information",
        })
        self.assertEqual(api.url_path, "user/")
        self.assertEqual(api.documentation, "Get user information")
        self.assertEqual(api.content_type, API.CONTENT_TYPE_JSON)
        self.assertEqual(api.authorization, API.OAUTH2)
        self.assertFalse(api.authorization_optional)
    def test_set_authorization(self):
        api = API("user/", {})
        self.assertIsNone(api.authorization)
        self.assertTrue(api.authorization_optional)
        self.assertEqual(api.authorization, API.BASIC_AUTH)
    def test_process_authorization_attribute_error(self):
        with self.assertRaises(SignalsError) as e:
            API("post/", {
            })
        self.assertEqual(e.exception.msg, "Found invalid authorization attribute: oauth for post/, exiting.")
    def test_create_get_api(self):
        api = GetAPI("post/", {
   

                "200+": "$postResponse"
            }
        })
        self.assertEqual(api.response_object, "$postResponse")
        self.assertEqual(api.resource_type, GetAPI.RESOURCE_LIST)
    def test_create_get_api_detail(self):
        api = GetAPI("post/:id/", {
            "response": {
                "200+": "$postResponse"
            }
        })
        self.assertEqual(api.response_object, "$postResponse")
        self.assertEqual(api.resource_type, GetAPI.RESOURCE_DETAIL)
    def test_create_get_api_detail_override(self):
        api = GetAPI("post/:id/favorites/", {
            "resource_type": "list",
            "response": {
                "200+": "$postResponse"
            }
        })
        self.assertEqual(api.response_object, "$postResponse")
        self.assertEqual(api.resource_type, GetAPI.RESOURCE_LIST)
    def test_create_request_response_api(self):
        api = RequestResponseAPI("post/:id/favorites/", {
            "request": "$postRequest",
      
env.roledefs = {
    'local': ['root@0.0.0.0:1337'],
    'server': ['root@188.226.173.220'],
def update_podcasts():
    with cd('"{}"'.format(os.path.dirname(__file__))):
        run('python3 manage.py updatepodcasts')
def fetch_episodes():
    with cd('"{}"'.format(os.path.dirname(__file__))):
        run('python3 manage.py fetchepisodes')
def setup_dev():
    run('/etc/init.d/postgresql start')
    with cd('"{}"'.format(os.path.dirname(__file__))):
        run('python3 manage.py syncdb')
        run('python3 manage.py loaddata sample_podcasts')
        run('python3 manage.py updatepodcasts')
        run('python3 manage.py fetchepisodes')
        run('python3 manage.py update_index')
def setup_server():
    with cd('/sputnik'):
        run('python3 manage.py syncdb')
        run('python3 manage.py loaddata sample_podcasts')
        run('python3 manage.py updatepodcasts')
        run('python3 manage.py fetchepisodes')
        run('python3 manage.py update_index')
def rebuild_index():
 
reportSQLDict = {
   'genotype_report': Template("""
SELECT
    api_questionnaireob.obid,
    subjectname,
    qstudy.name AS QStudy,
    cohort,
    att_key,
    att_value
FROM api_biosubject
LEFT JOIN api_questionnaireob
    ON api_questionnaireob.biosubject_id = api_biosubject.obid
LEFT JOIN api_genotypeob
    ON api_genotypeob.biosubject_id = api_biosubject.obid
LEFT JOIN api_study AS qstudy
    ON qstudy.obid = api_questionnaireob.study_id
WHERE cohort='$cohort'
--    AND surveystudy.study='$study'
$limit
"""),
   'genotype_extract': Template("""
SELECT
    subjectname,
    cohort,
    genotypeobserved,
    finalgenotype
FROM api_biosubject
LEFT JOIN api_genotypeob
    ON api_genotypeob.biosubject_id = api_biosubject.obid
$limit
"""),
    'genotype_lg_extract': Template("""
SELECT
    subjectname,
    cohort,
    genotypeobserved
FROM api_biosubject
LEFT JOIN api_genotypeob_lg
    ON api_genotypeob_lg.biosubject_id = api_biosubject.obid
$limit
"""),
   'questionnaire_extract': Tem
logging.basicConfig()
log = logging.getLogger(__file__)
class MultipleBrokersVirtualTopic(MultipleProducerConsumer):
    
    def __init__(self, mainBrokerName, mainBrokerHost, otherBrokers, port=6163, destination='test.virtualtopic', vtPrefix='Consumer', hostcert=None, hostkey=None, messages=10, timeout=15):
        MultipleProducerConsumer.__init__(self)
        
        self.mainBrokerName = mainBrokerName
        self.mainBrokerHost = mainBrokerHost
        self.otherBrokers = otherBrokers
        self.port = port
        self.destination = destination
        self.vtPrefix = vtPrefix
        self.hostcert = hostcert
        self.hostkey = hostkey
        self.messages = messages
        self.timeout = timeout
        
    def setup(self):
        self.destinationTopic = '/topic/%s' % self.destination
        
        if self.hostcert and self.hostkey:
            self.setSSLAuthentication(self.hostcert, self.hostkey)
        self.createBroker(self.mainBrokerName, self.mainBrokerHo

        for name, host in self.otherBrokers.items():
            self.createBroker(name, host, self.port)
        
    def run(self):
        
        timer = Timer(self.timeout)
        
        ''' Starting consumers '''
        for name, host in self.otherBrokers.items():
            self.createConsumer(name, 
                                '/queue/%s.%s.%s' % (self.vtPrefix, name, self.destination), 
                                timer.left)
        time.sleep(1)
        
        ''' Creating producer and sending messages '''
        self.createProducer(self.mainBrokerName, self.destinationTopic, timer.left)
        for i in range(self.messages):
            self.sendMessage(self.mainBrokerName, 
                             self.destinationTopic, 
                             {'persistent':'true'}, 
                             'testing-%s' % i)
        self.waitForMessagesToBeSent(self.mainBrokerName,
                                     self.destinationTopic,
               

        
        for broker in self.otherBrokers:
            self.waitForMessagesToArrive(broker, '/queue/%s.%s.%s' % (self.vtPrefix, broker, self.destination), self.messages, timer.left)
        ''' Wait a couple of seconds to see if we get duplicated '''
        time.sleep(2)
        
        for broker in self.otherBrokers:
            self.assertMessagesNumber(broker, '/queue/%s.%s.%s' % (self.vtPrefix, broker, self.destination), self.messages)
            
    def stop(self):
        self.destroyAllBrokers()
if __name__ == '__main__':
    log.setLevel(logging.INFO)
    logging.getLogger('MultipleProducerConsumer').setLevel(logging.INFO)
    broker = 'vtb-71'
    brokerHost = 'vtb-generic-71'
    brokers = {'vtb-71':'vtb-generic-71', 
               'vtb-72':'vtb-generic-72', 
               'vtb-73':'vtb-generic-73',
               'vtb-74':'vtb-generic-74'}
    mbvt = MultipleBrokersVirtualTopic(broker, brokerHost, brokers, 6163)
    mbvt.setup()
    
    try:
        mbvt.star
class Dispatch:
    def format_feed(self):
        dispatch_file = urllib.request.urlretrieve('http://www.portlandonline.com/scripts/911incidents.cfm', 'dispatch_feed.xml')
        tree = ET.parse('dispatch_feed.xml')
        listings = []
        for entry in tree.iter('{http://www.w3.org/2005/Atom}entry'):
            location = entry[6].text.split()
            dispatch_id = entry[0].text
            dispatch_title = entry[4].attrib
            agency = entry[3].text.replace('at', 'Location: ').split('[')
            summary = agency[0][:-5].title()
            agency = "Portland Dispatch Agency: " + agency[1][:-16]
            listing = {"occurred_on":entry[5].text.replace('T', ' '), 
                       "latitude":location[0], 
                       "longitude":location[1], 
                       "description":summary + '\n' + agency,
                       "category_name":dispatch_title['label'].title() + ' - Portland 911',
                       "source_id":dispatch_id[-13:
class WightApp(foundation.CementApp):
    class Meta:
        label = 'wight'
        base_controller = WightDefaultController
    def __init__(self, label=None, **kw):
        super(WightApp, self).__init__(**kw)
        self.user_data = UserData.load()
        init(autoreset=True)
    def register_controllers(self):
        self.controllers = [
            AuthController,
            TargetSetController,
            TargetGetController,
            CreateTeamController,
            UpdateTeamController,
            ShowTeamController,
            DeleteTeamController,
            ShowUserController,
            TeamAddUserController,
            CreateProjectController,
            UpdateProjectController,
            DeleteProjectController,
            TeamRemoveUserController,
            ChangePasswordController,
            ScheduleLoadTestController,
            ListLoadTestController,
            InstanceLoadTestController,
            ShowResultController,
            SetDefa
manage_add_athensda_form = PageTemplateFile('browser/add_plugin',
                            globals(), __name__='manage_add_athensda_form' )
def manage_add_athensda_helper( dispatcher, id, title=None, REQUEST=None ):
    """Add an athensda Helper to the PluggableAuthentication Service."""
    sp = plugin.AthensdaHelper( id, title )
    dispatcher._setObject( sp.getId(), sp )
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect( '%s/manage_workspace'
                                      '?manage_tabs_message='
                                      'athensdaHelper+added.'
                                      % dispatcher.absolute_url() )
def register_athensda_plugin():
    try:
        registerMultiPlugin(plugin.AthensdaHelper.meta_type)
    except RuntimeError:
        pass
def register_athensda_plugin_class(context):
    context.registerClass(plugin.AthensdaHelper,
                          permission = manage_users,
                          constructors = (manage_add_
def request_no_response():
    """No response"""
    data = {'q': 'hello AMQP backend, I am Python'}
    broker = ExampleBroker()
    publisher = Publisher(
        connection = broker.amqp_connection,
        exchange = broker.exchange_name,
        exchange_type = "topic",
        routing_key = broker.binding_key,
        )
    publisher.send(json.dumps(data))
def request_with_response():
    """Example of requesting over AMQP from another process, not necessarily Python."""
    qid = str(randrange(0,999))
    data = {'qid': qid, 'q': 'what time is it?'}
    broker = ExampleBroker()
    publisher = Publisher(
        connection = broker.amqp_connection,
        exchange = broker.exchange_name,
        exchange_type = "topic",
        routing_key = broker.binding_key,
        )
    
    backend = broker.amqp_connection.create_backend()
    backend.queue_declare(
        queue="test",
        durable=False,
        exclusive=False,
        auto_delete=True,)
    backend.queue_bind(
   
@istest
def none_is_returned_if_there_is_no_repository():
    with temporary_directory() as directory:
        assert_equal(None, repository_at(working_directory=directory))
        
@istest
def git_repository_is_returned_if_path_is_working_directory_of_git_repository():
    with temporary_directory() as directory:
        mkdir_p(os.path.join(directory, ".git"))
        repository = repository_at(directory)
        assert_equal("git", repository.type)
        
@istest
def hg_repository_is_returned_if_path_is_root_of_hg_repository():
    with temporary_directory() as directory:
        mkdir_p(os.path.join(directory, ".hg"))
        repository = repository_at(directory)
        assert_equal("hg", repository.type)
        
@istest
def working_directory_of_git_repository_is_directory_above_hidden_directory():
    with temporary_directory() as directory:
        mkdir_p(os.path.join(directory, ".git"))
        repository = repository_at(directory)
        assert_equal(directory, repositor
@task
def manage(command, manage='manage.py', envdir='env'):
    """Run a django management command. e.g. deploy.manage:syncdb"""
    require('site_path')
    with cd(env.site_path):
        cmd = './bin/python {0} {1}'.format(manage, command)
        if envdir:
            cmd = 'envdir {0} {1}'.format(envdir, cmd)
        run(cmd)
@task
def pip(requirements_file='requirements.txt'):
    """Run pip install."""
    require('site_path')
    with cd(env.site_path):
        if exists(requirements_file):
            run('./bin/pip install -r {0}'.format(requirements_file))
@task
def pull():
    """Run git pull."""
    require('site_path')
    with cd(env.site_path):
        run('git pull')
@task
def supervisor(command):
    """Run a supervisorctl command. e.g. deploy.supervisor:'restart all'"""
    sudo('supervisorctl {0}'.format(command), shell=False)
@task
def update():
    """Update the site folder."""
    pull()
    pip()
    manage('syncdb')
    manage('migrate')
    manage('collectst
urlpatterns = patterns('',
    url('^index/$', frontend.index),
    url(r'^$', frontend.index, name='manage'),
    url(r'^login/$', 'manage.views.admin.login', name='manage_login'),
    url(r'^change_username/$', 'manage.views.admin.change_username', name="manage_change_username")
urlpatterns += patterns("manage.views.school",
    url(r'^school/$', "view", name='kinger_school_info'),
    url('^school/send_account/$', "send_account", name="manage_school_send_account"), 
urlpatterns += patterns("manage.views.schedule",
        url('^schedule/student/$', "student_index", name="manage_schedule_student"),
        url('^schedule/teacher/$', "teacher_index", name="manage_schedule_teacher"),
        url('^schedule/create/$', "create", name="manage_create_schedule"),
        url('^schedule/delete/(?P<schedule_id>\d+)/$', "delete", name="manage_delete_schedule"),
        url('^schedule/download/(?P<schedule_id>\d+)/$', "download", name="manage_download_schedule"),
urlpatterns += patterns("manage

    url(r'^teacher/$', "index", name='manage_teacher_list'),
    url('^teacher/create/$', "create", name='manage_teacher_create'),
    url('^teacher/(?P<teacher_id>\d+)/$', "view", name='manage_teacher_view'),
    url('^teacher/(?P<teacher_id>\d+)/delete/$', "delete", name="manage_teacher_delete"),
    url('^teacher/(?P<teacher_id>\d+)/update/$', "update", name="manage_teacher_update"),
    url(r'^teacher/template/$', "template", name='manage_teacher_template'),
urlpatterns += patterns("manage.views.student",
    url(r'^student/$', "index", name='manage_student_list'),
    url(r'^student/create/$', "create", name='manage_student_create'),
    url(r'^student/template/$', "template", name='manage_student_template'),
    url('^student/(?P<student_id>\d+)/$', "view", name='manage_student_view'),
    url(r'^student/(?P<student_id>\d+)/delete/$', "delete", name="manage_student_delete"),
    url(r'^student/(?P<student_id>\d+)/update/$', "update", name="manage_student_update"),
    url(r'^stu

urlpatterns += patterns("manage.views.class",
    url(r'^class/$', "index", name="manage_class_list"),
    url('^class/(?P<class_id>\d+)/$', "view", name="manage_class_view"),
    url('^class/(?P<class_id>\d+)/delete/$', "delete", name="manage_class_delete"),
    url('^class/create/$', "create", name="manage_class_create"),
    url('^class/(?P<class_id>\d+)/update/$', "update", name="manage_class_update"),
    url('^class/add_student/$', "add_student", name="manage_class_add_student"),
    url('^class/add_teacher/$', "add_teacher", name="manage_class_add_teacher"),
    url('^class/(?P<class_id>\d+)/student/(?P<student_id>\d+)/remove/$', "remove_student", name="manage_class_remove_student"),
    url('^class/(?P<class_id>\d+)/teacher/(?P<teacher_id>\d+)/remove/$', "remove_teacher", name="manage_class_remove_teacher"),
urlpatterns += patterns("manage.views.cookbook",
    url(r'^cookbook/$', "index", name="manage_cookbook"),  
    url(r'^cookbook/get_cookbook_date/$', "get_cookbook_date",
clientRepository = Repository()
clientValidator = ClientValidator()
clientController = ClientController(clientRepository, clientValidator)
movieRepository = Repository()
movieValidator = MovieValidator()
movieController = MovieController(movieRepository, movieValidator)
rentalRepository = Repository()
rentalValidator = RentalValidator()
rentalController = RentalController(rentalRepository, rentalValidator)
clientController.create("1", "Ionut")
clientController.create("2", "Chubaca")
clientController.create("3", "Luke")
clientController.create("4", "Vader")
clientController.create("5", "Yoda")
clientController.create("6", "Anachin")
clientController.create("7", "Obi Wan Kenobi")
movieController.create("1", "Inelu Stapanilor", "Film despre stapani si un inel", "Drama")
movieController.create("2", "Inelu Stapanilor", "Film despre stapani si un inel", "Drama")
movieController.create("3", "Inelu Stapanilor", "Film despre stapani si un inel", "Drama")
movieController.create("4", "Inelu Stapa
""" Views for Person, Name, and Surname """
dji = DjangoInterface()
    """
    Process act on person. Can return a redirect.
    """
    context["tview"] = _("Repository")
    context["tviews"] = _("Repositories")
    context["action"] = "view"
    view_template = "view_repository_detail.html"
    
    if handle == "add":
        act = "add"
    if "action" in request.POST:
        act = request.POST.get("action")
    if act == "share":
        item, handle = add_to
        context["pickform"] = PickForm("Pick repository", 
                                       Repository, 
                                       (),
                                       request.POST)     
        context["object_handle"] = handle
        context["object_type"] = item
        return render_to_response("pick.html", context)
    elif act == "save-share":
        item, handle = add_to 
        pickform = PickForm("Pick repository", 
                            Repository, 
                            ()

                            request.POST)
        if pickform.data["picklist"]:
            ref_handle = pickform.data["picklist"]
            ref_obj = Repository.objects.get(handle=ref_handle) 
            dji.add_repository_ref_default(parent_obj, ref_obj)
        else:
            context["pickform"] = pickform
            context["object_handle"] = handle
            context["object_type"] = item
            return render_to_response("pick.html", context)
    elif act == "add":
        repository = Repository(gramps_id=dji.get_next_id(Repository, "R"))
        repositoryform = RepositoryForm(instance=repository)
        repositoryform.model = repository
    elif act in ["view", "edit"]: 
        repository = Repository.objects.get(handle=handle)
        repositoryform = RepositoryForm(instance=repository)
        repositoryform.model = repository
    elif act == "save": 
        repository = Repository.objects.get(handle=handle)
        repositoryform = RepositoryForm(request.POS

        repositoryform.model = repository
        if repositoryform.is_valid():
            update_last_changed(repository, request.user.username)
            repository = repositoryform.save()
            act = "view"
        else:
            act = "edit"
    elif act == "create": 
        repository = Repository(handle=create_id())
        repositoryform = RepositoryForm(request.POST, instance=repository)
        repositoryform.model = repository
        if repositoryform.is_valid():
            update_last_changed(repository, request.user.username)
            repository = repositoryform.save()
            if add_to:
                item, handle = add_to
                model = dji.get_model(item)
                obj = model.objects.get(handle=handle)
                dji.add_repository_ref_default(obj, repository)
                obj.save_cache()
            act = "view"
        else:
            act = "add"
    elif act == "delete": 
        repository = Repository.objects.get(ha
cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"..")))
if cmd_subfolder not in sys.path:
    sys.path.insert(0, cmd_subfolder)
rc = 1
keepalive = 60
connect_packet = mosq_test.gen_connect("bridge-reconnect-test", keepalive=keepalive)
connack_packet = mosq_test.gen_connack(rc=0)
mid = 180
suback_packet = mosq_test.gen_suback(mid, 0)
publish_packet = mosq_test.gen_publish("bridge/reconnect", qos=0, payload="bridge-reconnect-message")
try:
    os.remove('mosquitto.db')
except OSError:
    pass
cmd = ['../../src/mosquitto', '-p', '1888']
broker = mosq_test.start_broker(filename=os.path.basename(__file__), cmd=cmd)
local_cmd = ['../../src/mosquitto', '-c', '06-bridge-reconnect-local-out.conf']
local_broker = mosq_test.start_broker(cmd=local_cmd, filename=os.path.basename(__file__)+'_local1')
if os.environ.get('MOSQ_USE_VALGRIND') is not None:
    time.sleep(5)
else:
    time.sleep(0.5)
local_broker.terminate()
local_

if os.environ.get('MOSQ_USE_VALGRIND') is not None:
    time.sleep(5)
else:
    time.sleep(0.5)
local_broker = mosq_test.start_broker(cmd=local_cmd, filename=os.path.basename(__file__)+'_local2')
if os.environ.get('MOSQ_USE_VALGRIND') is not None:
    time.sleep(5)
else:
    time.sleep(0.5)
pub = None
try:
    sock = mosq_test.do_client_connect(connect_packet, connack_packet)
    sock.send(subscribe_packet)
    if mosq_test.expect_packet(sock, "suback", suback_packet):
        sock.send(subscribe_packet)
        if mosq_test.expect_packet(sock, "suback", suback_packet):
            pub = subprocess.Popen(['./06-bridge-reconnect-local-out-helper.py'], stdout=subprocess.PIPE)
            pub.wait()
            if mosq_test.expect_packet(sock, "publish", publish_packet):
                rc = 0
    sock.close()
finally:
    time.sleep(1)
    broker.terminate()
    broker.wait()
    if rc:
        (stdo, stde) = broker.communicate()
        print(stde)
    local_broker.terminate()
    loca
"""
Command line tool for testing the existence of an ion service.
usage: ionsval target_name sys_name [broker_host] [broker_vhost]
Assume all ion services have an op_ping. 
A service that has been successfully spawned and bound to a queue with 
the routing key "sysname.targetname" will reply_ok if we rpc_send it a
ping.
This does not explicitly verify the complete functionality of the service,
it only verifies that the service can send and receive messages on its
"sysname.targetname" name.
A successful ping will exit with status 0
A failure (rpc_send timeout) will exit with status 1
A problem with the ion container used in this test will exit with status 2
Invoking ionsval with no arguments prints the usage and exits with status 64
@author Dorian Raymer <deldotdr@gmail.com>
"""
class Client(process.ProcessClient):
    def __init__(self, targetname, proc=None, **kw):
        kw['targetname'] = targetname
        process.ProcessClient.__init__(self, proc, **kw)
    @defer.inlineCallback

    def ping(self):
        yield self._check_init()
        request = {'piece':'of'}
        response = yield self.rpc_send('ping', request)
        defer.returnValue(response[0])
def validate(_, targetname):
    client = Client(targetname)
    d = client.ping()
    d.addCallbacks(exit_ok, exit_fail)
    return d
def exit_ok(result):
    return 0
def exit_fail(reason):
    reason.printTraceback()
    return 1
def container_error(reason):
    reason.printTraceback()
    return 2
def finish_test(status, container):
    def stop_with_status(res, status):
        reactor.stop()
        exit_status = status
    d = container.stopService()
    d.addBoth(stop_with_status, status)
    return d
def run_test(targetname, sysname, broker_host, broker_vhost):
    config = service.Options()
    config['broker_host'] = broker_host
    config['broker_vhost'] = broker_vhost
    config['no_shell'] = True
    config['args'] = 'sysname=%s' % (sysname,)
    config['script'] = None
    container = service
'''
Created on Dec 2, 2012
@author: mihai
'''
class test_controller:
    def __init__(self, bookList, clientList):
        self.__controller = LibraryController(bookList, clientList)
        self.test_addNewBook()
        self.test_updateBook()
        self.test_addNewClient()
        self.test_updateClient()
        self.test_removeClient()
        self.test_lendBook()
        self.test_searchBooks()
        self.test_searchClients()
        self.test_returnBook()
    
    def test_addNewBook(self):
        assert self.__controller.addNewBook("a", "a", "a") == None
        assert self.__controller.addNewBook("b", "b", "b") == None
        
    def test_updateBook(self):
        assert self.__controller.updateBook("a", "a", "a", "b", "1", "1") == True
        assert self.__controller.updateBook("b", "1", "1", "", "", "") == True
        assert self.__controller.updateBook("b", "1", "1", "a", "a", "a") == True
        assert self.__controller.updateBook("b", "1", "1", "a", "a", "a") == 

        
        
    def test_addNewClient(self):
        assert self.__controller.addNewClient("a", "1") == None
        assert self.__controller.addNewClient("b", "2") == None
        
    def test_updateClient(self):
        assert self.__controller.updateClient("a", "1", "b", "1") == True
        assert self.__controller.updateClient("b", "1", "", "",) == True
        assert self.__controller.updateClient("b", "1", "a", "1") == True
        assert self.__controller.updateClient("b", "1", "a", "1") == False
        
    def test_removeClient(self):
        assert self.__controller.removeClient("b", "2") == True
        assert self.__controller.removeClient("b", "2") == False
        
    def test_searchBooks(self):
        assert self.__controller.searchBooks("nothing") == []
        
    def test_searchClients(self):
        assert self.__controller.searchClients("nothing") == []
        
    def test_lendBook(self):
        assert self.__controller.lendBook("1", "1", "1", "", ""
logging.basicConfig(level=logging.DEBUG, \
    format='%(asctime)s - %(name)s - %(levelname)s: %(message)s', )
logger = logging.getLogger(__name__)
def startSTOMPBroker(config, serverUpEvent, tries=-1, delay=1, backoff=1.5):
  """
  @param tries number of times to retry starting the broker. < 0 means infinitely many.
  @param delay number of seconds to wait after the first failed attempt
  @param backoff factor by which the delay will be incremented after a failure.
  """
  mtries = tries
  mdelay = delay
  coilserver = None
  if config.has_section('coilmq'):
    for k,v in config.items('coilmq'):
      coilconfig.set('coilmq', k, v)
      logger.debug("Set %s to %s for coilmq config." % (k,v))
  while True:
    try:
      coilserver = coilmq.start.server_from_config(coilconfig)
      logger.info("Stomp server listening on %s:%s" % \
          coilserver.server_address)
      serverUpEvent.set()
      coilserver.serve_forever()
    except IOError as ex:
      logger.error("Exception wh

      if mtries != 0: 
        logger.debug("Retrying coilmq startup in %.1f seconds...", mdelay)
        time.sleep(mdelay)
        mdelay *= backoff
        mtries -= 1
      else:
        logger.debug("Ran out of trials (tried %d times) for coilmq startup. Giving up.", tries)
        break
    finally:
      if coilserver: coilserver.server_close()
def start(config, brokerTimeout = 60.0):
  """
  Start twisted event loop and the fun should begin...
  @param brokerTimeout how long to wait for a broker 
  
  @return a negative number upon failure. Otherwise, it never returns.
  """
  
  manager = multiprocessing.Manager()
  serverUpEvent = manager.Event()
  broker = multiprocessing.Process(target=startSTOMPBroker, args=(config,serverUpEvent))
  broker.daemon = True
  broker.name = 'STOMP-Broker'
  broker.start()
  serverUpEvent.wait(brokerTimeout)
  if not serverUpEvent.is_set():
    logger.fatal("Broker not available after %.1f seconds. Giving up", brokerTimeout)
    return -1
  hos
"""Base implementation classes.
The public-facing ``Events`` serves as the base class for an event interface;
its public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.
"""
_registrars = util.defaultdict(list)
def _is_event_name(name):
    return not name.startswith('_') and name != 'dispatch'
class _UnpickleDispatch(object):
    """Serializable callable that re-generates an instance of
    :class:`_Dispatch` given a particular :class:`.Events` subclass.
    """
    def __call__(self, _parent_cls):
        for cls in _parent_cls.__mro__:
            if 'dispatch' in cls.__dict__:
                return cls.__dict__['dispatch'].dispatch_cls(_parent_cls)
        else:
            raise AttributeError("No class with a 'dispa

class _Dispatch(object):
    """Mirror the event listening definitions of an Events class with
    listener collections.
    Classes which define a "dispatch" member will return a
    non-instantiated :class:`._Dispatch` subclass when the member
    is accessed at the class level.  When the "dispatch" member is
    accessed at the instance level of its owner, an instance
    of the :class:`._Dispatch` class is returned.
    A :class:`._Dispatch` class is generated for each :class:`.Events`
    class defined, by the :func:`._create_dispatcher_class` function.
    The original :class:`.Events` classes remain untouched.
    This decouples the construction of :class:`.Events` subclasses from
    the implementation used by the event internals, and allows
    inspecting tools like Sphinx to work in an unsurprising
    way against the public API.
    """
    _events = None
    """reference the :class:`.Events` class which this
        :class:`._Dispatch` is created for."""
    def __init__(s

        self._parent_cls = _parent_cls
    @util.classproperty
    def _listen(cls):
        return cls._events._listen
    def _join(self, other):
        """Create a 'join' of this :class:`._Dispatch` and another.
        This new dispatcher will dispatch events to both
        :class:`._Dispatch` objects.
        """
        if '_joined_dispatch_cls' not in self.__class__.__dict__:
            cls = type(
                    "Joined%s" % self.__class__.__name__,
                    (_JoinedDispatcher, self.__class__), {}
                )
            for ls in _event_descriptors(self):
                setattr(cls, ls.name, _JoinedDispatchDescriptor(ls.name))
            self.__class__._joined_dispatch_cls = cls
        return self._joined_dispatch_cls(self, other)
    def __reduce__(self):
        return _UnpickleDispatch(), (self._parent_cls, )
    def _update(self, other, only_propagate=True):
        """Populate from the listeners in another :class:`_Dispatch`
            object
"""
(Description)
Created on Dec 22, 2014
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013-2014, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class OldEventBroker(BrokerBase):
  def get_broker_class(self):
    return OldEvent
class OldUserBroker(BrokerBase):
  def get_broker_class(self):
    return OldUser
  def get_all(self):
    users = BrokerBase.get_all(self)
    result = list()
    for user in users:
      if user.username != 'admin':
        result.append(user)
    return result
class OldGroupBroker(BrokerBase):
  def get_broker_class(self):
    return OldGroup
class OldAttributeDefinitionsBroker(BrokerBase):
  def get_broker_class(self):
    return OldAttributeDefinition
class OldObjectDefinitionsBroker(BrokerBase):
  def get_broker_class(self):
    return OldObjectDefinition
class OldConfigBroker(BrokerBase):
  def get_broker_class(self):
    return OldCe1susConfig
class OldHandlerBroker(BrokerBase):
  def get_broke
SWITCH_CONTROLLER = '''
<nc:config xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
<capable-switch xmlns="urn:onf:of111:config:yang">
<id>%(capable_switch_id)s</id>
<logical-switches>
<switch>
<id>%(logical_switch_id)s</id>
<controllers>
<controller operation="replace">
<id>%(controller_id)s</id>
<role>%(controller_role)s</role>
<ip-address>%(controller_ip)s</ip-address>
<port>%(controller_port)s</port>
<protocol>%(controller_protocol)s</protocol>
</controller>
</controllers>
</switch>
</logical-switches>
</capable-switch>
</nc:config>
'''
CONFIG_KEYS = ['capable_switch_id',
               'logical_switch_id',
               'controller_id', 'controller_ip',
               'controller_port',
               'controller_protocol',
               'controller_role']
def set_new_controller_role(session):
    xml_config = utils.get_config_as_xml(session)
    config_map = {key: utils.get_config_value_from_xml(key, xml_config)
                  for key in CONFIG_KEYS}
    current_role = ne
admin.autodiscover()
urlpatterns = patterns('',       
    url(r'^', include('apps.public.urls')),
    
    url(r'^manage/account/', include('apps.accounts.urls')),
    url(r'^manage/store/', include('apps.stores.urls')),
    url(r'^manage/rewards/', include('apps.rewards.urls')),
    url(r'^manage/messages/', include('apps.messages.urls')),
    url(r'^manage/employees/', include('apps.employees.urls')),
    url(r'^manage/analysis/', include('apps.analysis.urls')),
    url(r'^manage/workbench/', include('apps.workbench.urls')),
    url(r'^manage/comet/', include('apps.comet.urls')),
    url(r'^manage/terms/$', views.manage_terms, name='manage_terms'),
    url(r'^manage/$', views.manage_login, name='manage_login'),
    url(r'^manage/logout$', views.manage_logout, name='manage_logout'),
    url(r'^manage/admin-controls$', views.manage_admin_controls, name='manage_admin_controls'),
    
    url(r'^gcm/', include('apps.gcm.urls')),
    
    url(r'^manage/password-reset$', 
            view
class TestManageVariants(unittest.TestCase):
	def test_variant_item_codes(self):
		manage_variant = frappe.new_doc("Manage Variants")
		manage_variant.update({
			"item_code": "_Test Variant Item",
			"attributes": [
				{
					"attribute": "Test Size",
					"attribute_value": "Small"
				},
				{
					"attribute": "Test Size",
					"attribute_value": "Large"
				}
			]
		})
		manage_variant.generate_combinations()
		self.assertEqual(manage_variant.variants[0].variant, "_Test Variant Item-S")
		self.assertEqual(manage_variant.variants[1].variant, "_Test Variant Item-L")
		
		self.assertEqual(manage_variant.variants[0].variant_attributes, "Small")
		self.assertEqual(manage_variant.variants[1].variant_attributes, "Large")
		manage_variant.create_variants()
	def test_attributes_are_unique(self):
		manage_variant = frappe.new_doc("Manage Variants")
		manage_variant.update({
			"item_code": "_Test Variant Item",
			"attributes": [
				{
					"attribute": "Test Size",
					"attribute_value":
def tests_rentController():
    filmRepo =FilmRepository()
    filmValid = FilmValidator()
    filmController = FilmController(filmRepo, filmValid)
    
    clientRepo = ClientRepository()
    clientValid = ClientValidator()
    clientController = ClientController(clientRepo, clientValid)
    
    filmController.createFilm("1", "blabla", "blaaa", "fantasy")
    filmController.createFilm("2", "blabla2", "blaaa2", "fantasy")
    filmController.createFilm("3", "blabla3", "blaaa3", "adventure")
    
    clientController.createClient("1", "stefan", "1234")
    clientController.createClient("2", "stefan2", "12345")
    clientController.createClient("3", "stefan3", "123456")
    
    
    
    
    repo = RentRepository()
    valid = RentValidator()
    ctrl = RentController(repo, valid, filmRepo, clientRepo)
    
    rent1 = ctrl.createRent("1", "2")
    assert len(ctrl.getAllRents()) == 1
    assert rent1.getIDC() == "1"
    assert rent1.getIDF() == "2"
    
    try:
        ctrl.createRent
''' Keep track of all known controllers
'''
log = logging.getLogger(__name__)
__all__ = [
    'Controllers', 'find_controller', 'get_id_list',
class Controllers(object):
    ''' List of all known controllers '''
    def __init__(self):
        log.debug('Initialise a new list of controllers')
    def find_controller(self, id):
        ''' Return a Controller instance. If there is no existing
        controller instance, then a new instance will be created.
        :param id: controller id
        :returns: Controller instance
        '''
        log.debug('find_controller(%s)', str(id))
        if not id in self._controllers:
            log.info('  create a new controller(%s)', str(id))
            self._controllers[id] = Controller(id)
        return self._controllers[id]
    def get_id_list(self):
        ''' Generates a list of controller ids
        :returns: Generated id for each controller
        '''
        for id in self._controllers.keys():
            yield(id)
    def __st
@template("repo_browser/list_repositories.html")
def list_repositories(request):
    "List the available repositories"
    repositories = repo_browser.models.Repository.objects.filter(
        show_on_index=True)
    return {"repositories": repositories}
@template("repo_browser/repository_details.html")
def repository_details(request, repository_slug, allow_sync=True):
    "Summary detail page for a repository"
    repository = get_object_or_404(
        repo_browser.models.Repository,
        slug=str(repository_slug))
    if request.method == "POST":
        if 'force_sync' in request.POST and allow_sync:
            repository.incremental_sync()
            return HttpResponseRedirect("")
    return {"repository": repository}
@template("repo_browser/commit_list.html")
def commitlist(request, repository_slug):
    "View a set of commits in a repo"
    repository = get_object_or_404(
        repo_browser.models.Repository,
        slug=str(repository_slug))
    commit_paginator = Pagi

        repository.commits.all(),
        int(request.GET.get("per_page", 50)))
    commits = commit_paginator.page(int(request.GET.get("page", 1)))
    return {"repository": repository,
            "commits": commits}
@template("repo_browser/commit_details.html")
def view_commit(request, repository_slug, commit_identifier):
    "View a single commit"
    repository = get_object_or_404(
        repo_browser.models.Repository,
        slug=str(repository_slug))
    commit = get_object_or_404(
        repository.commits.all(),
        identifier=str(commit_identifier))
    if request.GET.get("format") == "diff":
        res = HttpResponse(commit.diff, content_type="text/x-diff")
        res["Content-Disposition"] = 'attachment; filename="%s.diff"' % commit.identifier
        return res
    return {"repository": repository,
            "commit": commit}
@template("repo_browser/manifest.html")
def manifest(request, repository_slug, commit_identifier, directory=None):
    "View a single co
lib_env = gtest_env.Clone()
if lib_env.get('RELEASE'):
    lib_env.AppendUnique(CCFLAGS = ['-Os'])
    lib_env.AppendUnique(CPPDEFINES = ['NDEBUG'])
else:
    lib_env.AppendUnique(CCFLAGS = ['-g'])
if lib_env.get('LOGGING'):
    lib_env.AppendUnique(CPPDEFINES = ['TB_LOG'])
broker_test_env = lib_env.Clone()
src_dir = broker_test_env.get('SRC_DIR')
target_os = broker_test_env.get('TARGET_OS')
broker_test_env.AppendUnique(CPPPATH = ['../include'])
broker_test_env.AppendUnique(CPPPATH = ['../../../include'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/primitiveResource/include'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/expiryTimer/include'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/expiryTimer/src'])
broker_test_env.AppendUnique(CPPPATH = ['../../common/utils/include'])
broker_test_env.PrependUnique(CPPPATH = [broker_test_env.get('SRC_DIR')+'/extlibs/hippomocks-master'])
broker_test_env.AppendUnique(LIBPATH = [broker_test_env.get('BUILD_DIR')])
broker_

broker_test_env.AppendUnique(LIBS = ['connectivity_abstraction'])
broker_test_env.AppendUnique(LIBS = ['oc_logger'])
broker_test_env.AppendUnique(LIBS = ['octbstack'])
broker_test_env.AppendUnique(LIBS = ['oc'])
broker_test_env.AppendUnique(LIBS = ['rcs_client'])
broker_test_env.AppendUnique(LIBS = ['rcs_common'])
compiler = broker_test_env.get('CXX')
if 'g++' in compiler:
    broker_test_env.AppendUnique(CXXFLAGS = ['-O2', '-g', '-Wall', '-fmessage-length=0', '-std=c++0x'])
if broker_test_env.get('SECURED') == '1':
	if broker_test_env.get('WITH_TCP') == True:
		broker_test_env.AppendUnique(LIBS = ['mbedtls', 'mbedx509', 'mbedcrypto'])
broker_test_src = broker_test_env.Glob('./*.cpp')
broker_test = broker_test_env.Program('broker_test', broker_test_src)
Alias("broker_test", broker_test)
broker_test_env.AppendTarget('broker_test')
if broker_test_env.get('TEST') == '1':
        if target_os in ['linux']:
                run_test(broker_test_env,
                         '',
            
    mobile_delete_register, mobile_get_register
r_company = r'^(?P<company_id>[\w-]+)'
urlpatterns = patterns('',
    url(r_company + r'/manage/json/category/add/?$', category.mobile_add_category, name='add_category'),
    url(r_company + r'/manage/json/categories/?$', category.mobile_JSON_categories_strucutred, name='JSON_categories'),
    url(r_company + r'/manage/json/categories/all/?$', category.mobile_JSON_categories, name='JSON_categories'),
    url(r_company + r'/manage/json/contacts/?$', contact.mobile_list_contacts, name='list_contacts'),
    url(r_company + r'/manage/json/contact/add/?$', contact.mobile_add_contact, name='add_contact'),
    url(r_company + r'/manage/json/contact/get/(?P<contact_id>\d+)/?$', contact.mobile_get_contact, name='get_contact'),
    url(r_company + r'/manage/json/contact/edit/', contact.mobile_edit_contact, name='edit_contact'),
    url(r_company + r'/manage/json/contact/delete/?$', contact.mobile_delete_contact, name='delete_contact'),
    url(r_co

    url(r_company + r'/manage/json/discounts/add/?$', discount.mobile_add_discount, name='add_dicount'),
    url(r_company + r'/manage/json/discounts/delete/?$', discount.mobile_delete_discount, name='delete_discount'),
    url(r_company + r'/manage/json/discounts/edit/?$', discount.mobile_edit_discount, name='edit_discount'),
    url(r_company + r'/manage/json/units/?$', views.mobile_get_units, name='get_units'),
    url(r_company + r'/manage/json/taxes/edit/?$', tax.mobile_edit_tax, name='edit_tax'),
    url(r_company + r'/manage/json/taxes/save-default/?$', tax.mobile_save_default_tax, name='edit_tax'),
    url(r_company + r'/manage/json/taxes/delete/?$', tax.mobile_delete_tax, name='delete_tax'),
    url(r_company + r'/manage/json/products/?$', product.mobile_get_products, name='get_products'),
    url(r_company + r'/manage/json/products/add/?$', product.mobile_create_product, name='mobile_create_product'),
    url(r_company + r'/manage/json/units/?$', product.mobile_JSON_units, n

    url(r_company + r'/manage/json/bill/add/?$', bill.mobile_create_bill, name='mobile_add_bill'),
    url(r_company + r'/manage/json/bill/finish/?$', bill.mobile_finish_bill, name='mobile_add_bill'),
    url(r_company + r'/manage/json/bill/get_btc_price/?$', bill.get_payment_btc_info, name='mobile_add_bill'),
    url(r_company + r'/manage/json/bill/check_bill_status/?$', bill.check_bill_status, name='mobile_check_status'),
    url(r_company + r'/manage/json/bill/change_payment_type?$', bill.change_payment_type, name='mobile_change_payment_type'),
    url(r_company + r'/manage/json/bill/paypal-send-invoice/$', bill.send_invoice, name='mobile_send_invoice'),
    url(r_company + r'/manage/json/bill/list/?$', bill_management.list_bills, name='mobile_list_bills'),
    url(r_company + r'/manage/json/bill/print/?$', bill_management.print_bill, name='mobile_print_bill'),
    url(r_company + r'/manage/json/config/?$', configuration.get_mobile_config, name='mobile_get_config'),
    url(r_compa
                                     channels, bots)
all_views = {
    'index'             : base.index,
    'account.rpx'           : account.rpx_post,
    'account.login'         : account.login,
    'account.logout'        : account.logout,
    'account.delete'        : account.delete,
    'account.profile'       : account.profile,
    'account.register'      : account.register,
    'account.activate'      : account.activate_account,
    'account.dashboard'     : account.dashboard,
    'account.rpx_providers' : account.rpx_providers_post,
    'network.index'     : networks.index,
    'network.channels'  : networks.channels,
    'channel.index'     : '',
    'channel.browse'    : '',
    'admin.index'                   : admin.index,
    'admin.manage.groups'           : groups.list,
    'admin.manage.groups.new'       : groups.edit,
    'admin.manage.groups.edit'      : groups.edit,
    'admin.manage.groups.delete'    : groups.delete,
    'admin.manage.users'            : users.list
"""
Handles saving and loading of game states.
"""
if os.name == "posix":
   SAVE_DIR = os.path.join(os.environ["HOME"], "Documents", )
else:
   SAVE_DIR = os.environ["LOCALAPPDATA"] + "\\CCLA"
SAVE_FILE = os.path.join(SAVE_DIR, "ccla.save")
SAVE_BACKUP = os.path.join(SAVE_DIR, "ccla.backup")
FIRST_TIME = """
This is your first time running Crazy Cat Lady Apocalypse.
Let's do some setup. I'm being verbose about this because why not?
I'm going to create a directory for you. Mk, now watch.
"""
def saveGame(player):
    """Saves the player game state."""
    
    if not os.access(SAVE_DIR, os.F_OK):
        print(FIRST_TIME)
        os.makedirs(SAVE_DIR)
        time.sleep(6)
        subprocess.Popen(r"explorer /open, %s" % SAVE_DIR)
        time.sleep(1)
        print("And here comes your new save file. Keep this safe. Your cats lives depend on it.")
        time.sleep(5)
    if os.access(SAVE_FILE, os.F_OK):
        shutil.move(SAVE_FILE, SAVE_BACKUP)
    with open(SAVE_FILE, "wb") as f

        pickle.dump(player, f)
        print("(Game Saved)")
def loadGame():
    
    if not os.access(SAVE_FILE, os.F_OK):
        return None
    try:
        print("Locating save file...")
        with open(SAVE_FILE, "rb") as f:
            data = pickle.load(f)
            print("Save file loaded!")
            return data
    except EOFError:
        logging.exception("DEBUG")
        print("Locating backup file...")
        try:
            with open(SAVE_BACKUP, "rb") as f:
                data = pickle.load(f)
                print("!!! Save file was corrupted. It's ok though. We made a backup. :D")
                return data
        except EOFError:
            print("\n!!!Your save and backup file became corrupted. Who knows...",
                  "Sorry 'bout that...")
            raise(FileNotFoundError)
        
def deleteSave():
    
    try:
        os.remove(SAVE_DIR + "\\ccla.save")
        print("Deleted save")
    except FileNotFoundError:
        pass
    try:
  
__author__ = 'bretmattingly'
sys.path.append('..')
class TestAwaitbox(unittest.TestCase):
    def setUp(self):
        self.dispatch = dispatch.Dispatch(0, ("0.0.0.0", 12358))
    def test_awaitbox_add(self):
        self.dispatch._awaitbox.add(messages.Action(True, 0, 0, 15, 13, 420, 8008))
        self.assertEqual(len(self.dispatch._awaitbox.buckets[0]), 1)
    def test_awaitbox_shift(self):
        self.dispatch._awaitbox.buckets[0][0] = messages.Action(True, 0, 0, 15, 13, 420, 8008)
        lost = self.dispatch._awaitbox.shift()
        self.assertEqual(len(self.dispatch._awaitbox.buckets[0]), 0)
        self.assertEqual(len(self.dispatch._awaitbox.buckets[1]), 1)
        self.assertEqual(len(lost), 0)
    def test_awaitbox_fullshift(self):
        self.dispatch._awaitbox.buckets[0][0] = messages.Action(True, 0, 0, 15, 13, 420, 8008)
        self.dispatch._awaitbox.buckets[1][11] = messages.Action(True, 0, 11, 17, 13, 420, 8008)
        self.dispatch._awaitbox.buckets[2][13] = mess

        lost = self.dispatch._awaitbox.shift()
        self.assertEqual(len(self.dispatch._awaitbox.buckets[0]), 0, msg='{0}'.format(self.dispatch._awaitbox.buckets[0]))
        self.assertEqual(len(self.dispatch._awaitbox.buckets[1]), 1, msg='{0}'.format(self.dispatch._awaitbox.buckets[1]))
        self.assertEqual(len(self.dispatch._awaitbox.buckets[2]), 1, msg='{0}'.format(self.dispatch._awaitbox.buckets[2]))
        self.assertEqual(len(lost), 1, msg='{0}'.format(lost))
    def test_awaitbox_acknowledge(self):
        self.dispatch._awaitbox.add(messages.Action(True, 0, 0, 15, 13, 420, 8008))
        self.assertEqual(len(self.dispatch._awaitbox.buckets[0]), 1, msg='{0}'.format(self.dispatch._awaitbox.buckets[0]))
        self.dispatch._awaitbox.acknowledge(0)
        self.assertEqual(len(self.dispatch._awaitbox.buckets[0]), 0, msg='{0}'.format(self.dispatch._awaitbox.buckets[0]))
    def test_awaitbox_pull_resend(self):
        self.dispatch._awaitbox.add(messages.Action(True, 0, 
class ApplicationHelper(object):
    """ApplicationHelpers can contain functions useful in a controller. Each controller is assigned a helper.
    Either the global ApplicationHelper, or a class with the same name as the controller such as foo_helper.py,
    and being a subclass of ApplicationHelper."""
    def __init__(self, controller):
        self.controller = controller
    
    def url_for(self, controller = None, action = None, named_url  = None, url_params = None, url_args=None, url_kwargs=None):
        
        if controller:
            controller_name = controller
        else:
            controller_name = self.controller._controller_name
            
        Controller = self.controller._site.controllers.get(controller_name, None)
        if Controller is None:
            raise InvalidControllerError(controller_name)
        
        if not named_url:
            if action:
                try:
                    action = action.strip('"\'')
                    action_f
__revision__ = "__FILE__ __REVISION__ __DATE__ __DEVELOPER__"
if sys.platform == 'win32':
    _exe = '.exe'
else:
    _exe = ''
test = TestSCons.TestSCons()
test.subdir('repository', ['repository', 'src'])
workpath_repository = test.workpath('repository')
repository_foo = test.workpath('repository', 'foo' + _exe)
repository_src_bar = test.workpath('repository', 'src', 'bar' + _exe)
test.write(['repository', 'SConstruct'], """
Repository(r'%s')
SConscript('src/SConscript')
env = Environment()
env.Program(target = 'foo', source = ['aaa.c', 'bbb.c', 'foo.c'])
""" % workpath_repository)
test.write(['repository', 'aaa.c'], r"""
void
aaa(void)
        printf("repository/aaa.c\n");
""")
test.write(['repository', 'bbb.c'], r"""
void
bbb(void)
        printf("repository/bbb.c\n");
""")
test.write(['repository', 'foo.c'], r"""
extern void aaa(void);
extern void bbb(void);
int
main(int argc, char *argv[])
        argv[argc++] = "--";
        aaa();
        bbb();
        printf("repository/foo.c\
"""Majordomo Protocol Client API, Python version.
Author: Min RK <benjaminrk@gmail.com>
Based on Java example by Arkadiusz Orzechowski
"""
class MajorDomoClient(object):
    """Majordomo Protocol Client API, Python version.
    """
    broker = None
    ctx = None
    client = None
    poller = None
    timeout = 2500
    verbose = False
    
    def __init__(self, broker, verbose=False):
        self.broker = broker
        self.verbose = verbose
        self.ctx = zmq.Context()
        self.poller = zmq.Poller()
        logging.basicConfig(format="%(asctime)s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",
                level=logging.INFO)
        self.reconnect_to_broker()
        
    def reconnect_to_broker(self):
        """Connect or reconnect to broker"""
        if self.client:
            self.poller.unregister(self.client)
            self.client.close()
        self.client = self.ctx.socket(zmq.DEALER)
        self.client.linger = 0
        self.client.connect(self.broker)
   

        if self.verbose:
            logging.info("I: connecting to broker at %s...", self.broker)
    def send(self, service, request):
        """Send request to broker
        """
        if not isinstance(request, list):
            request = [request]
        
        
        request = ['', MDP.C_CLIENT, service] + request
        if self.verbose:
            logging.warn("I: send request to '%s' service: ", service)
            dump(request)
        self.client.send_multipart(request)
    def recv(self):
        """Returns the reply message or None if there was no reply."""
        try:
            items = self.poller.poll(self.timeout)
        except KeyboardInterrupt:
        
        if items:
            msg = self.client.recv_multipart()
            if self.verbose:
                logging.info("I: received reply:")
                dump(msg)
        
            assert len(msg) >= 4
            
            empty = msg.pop(0)
            header = msg.pop(0)
            ass
class EntityToRepositoryCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        self.is_entity = False
        self.is_repository = False
        self.file = self.view.file_name()
        
        self.file_is(self.file)
        if self.is_entity:
            if self.view.find('(repositoryClass)', 0):
                repository_class_region = self.view.find('(repositoryClass)', 0)
                repository_class_line = self.view.line(repository_class_region)
                repository_class_string = self.view.substr(repository_class_line)
                repository_class = re.search(r'(repositoryClass\=\")(.*)(\")', repository_class_string).group(2)
                repository_class_path = os.sep.join(repository_class.split('\\'))
                src_position = self.reg_search_file_name.group(1).find('src') + 3
                repository_class_file = self.reg_search_file_name.group(1)[:src_position] + os.sep + repository_class_path + '.php'
                if os.path.exis

                    self.view.window().open_file(repository_class_file)
                else:
                    sublime.status_message('There is no Repository Class for Entity.')
        elif self.is_repository:
            self.posible_files = find_symbol(
                self.get_entity_class_name(self.reg_search_file_name.group(5)),
                self.view.window()
            )
            if len(self.posible_files) == 1:
                self.go_to_file(self.posible_files[0][1])
            if len(self.posible_files) > 1:
                view.window().show_quick_panel(self.posible_files, self.on_done)
        else:
            sublime.status_message("This file is not Entity or Repository file")
    def file_is(self, file_name):
        self.reg_search_file_name = re.search(r'^(.*)(\/)(Entity)(\/)(.*)$', file_name)
        if self.reg_search_file_name:
            if re.search(r'^(Repository)(\/)', self.reg_search_file_name.group(5)):
                self.is_repository = True
 
manage_addRefListForm = PageTemplateFile('zpt/reflist_add', globals())
def manage_addRefList(self, id='', title='', description='', REQUEST=None):
    """ """
    id = self.utSlugify(id)
    if not id: id = PREFIX_SUFIX_REFLIST % self.utGenRandomId(6)
    ob = RefList(id, title, description)
    self._setObject(id, ob)
    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
class RefList(SimpleItem, ref_manager):
    """ """
    meta_type = METATYPE_REFLIST
    icon = 'misc_/NaayaCore/RefList.gif'
    manage_options = (
        (
            {'label': 'Items', 'action': 'manage_items_html'},
        )
        +
        SimpleItem.manage_options
    )
    security = ClassSecurityInfo()
    def __init__(self, id, title, description):
        """ """
        self.id = id
        self.title = title
        self.description = description
        ref_manager.__dict__['__init__'](self)
    security.declareProtected(view_management_screens, 'manageProperties')

    def manageProperties(self, title='', description='', REQUEST=None):
        """ """
        self.title = title
        self.description = description
        self._p_changed = 1
        if REQUEST:
            REQUEST.RESPONSE.redirect('manage_properties_html')
    security.declareProtected(view_management_screens, 'manage_add_item')
    def manage_add_item(self, id='', title='', REQUEST=None):
        """ """
        id = self.utSlugify(id)
        if not id: id = PREFIX_SUFIX_REFLISTITEM % self.utGenRandomId(6)
        self.add_item(id, title)
        if REQUEST: REQUEST.RESPONSE.redirect('manage_items_html?save=ok')
    security.declareProtected(view_management_screens, 'manage_update_item')
    def manage_update_item(self, id='', title='', REQUEST=None):
        """ """
        self.update_item(id, title)
        if REQUEST: REQUEST.RESPONSE.redirect('manage_items_html?save=ok')
    security.declareProtected(view_management_screens, 'manage_delete_items')
    def manage_delete
class TestManageProductsPage(BaseTest):
    @pytest.mark.moztrap([145, 146])
    def test_that_user_can_create_and_delete_product(self, base_url, selenium, login):
        manage_products_pg = MozTrapManageProductsPage(base_url, selenium)
        product = self.create_product(base_url, selenium)
        manage_products_pg.filter_form.filter_by(lookup='name', value=product['name'])
        assert manage_products_pg.is_element_present(*product['locator'])
        manage_products_pg.delete_product(name=product['name'])
        assert not manage_products_pg.is_element_present(*product['locator'])
    @pytest.mark.moztrap(151)
    def test_that_user_can_filter_product_by_name(self, base_url, selenium, login, product):
        manage_products_pg = MozTrapManageProductsPage(base_url, selenium)
        manage_products_pg.go_to_manage_products_page()
        filter_item = manage_products_pg.filter_form.filter_by(lookup='name', value='Another Product')
        assert not manage_products_pg.is_pr
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map():
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'], explicit=True)
    map.minimization = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.connect('/_error_test/{action}', controller='error_test')
    map.connect('/', controller='home', action='index')
    map.connect('/task/add_hint', controller='task', action='add_hint')
    map.connect('/task/drop_database', controller='task', action='drop_database')
    map.connect('/task/remove_dataset', controller='task', action='remove_dataset')
    map.connect('/task/remove_dataset/{dataset}', controller='task
class Manage_GelGroups_BaseHandler(Manage_BaseHandler):
    pass
class Manage_GelGroups_Handler(Manage_GelGroups_BaseHandler):
    def get(self):
        self.generate_manage_bar()
        self.template_vars['existingGelGroups'] = GelGroup.gql("ORDER BY DayAndTime ASC").fetch(50)
        self.template_vars['form'] = self.generate_form(GelGroup_Form)
        self.render_template("manage/gel_groups/gel_groups.html")
    def post(self):
        filled_gel_group = self.process_form(GelGroup_Form, GelGroup)
        if filled_gel_group:
            self.redirect(self.request.path)
        else:
            self.redirect(self.request.path + '?edit=%s&retry=1' % self.request.get("edit"))
class Manage_GelGroups_DeleteHandler(Manage_GelGroups_BaseHandler):
    def get(self, urlsafe_key):
        urlsafe_key = str(urllib.unquote(urlsafe_key))
        key = ndb.Key(urlsafe=urlsafe_key)
        if key.kind() == "GelGroup":
            key.delete()
        else:
            self.abort(400, "Can only
class MyAppBaseController(CementBaseController):
    class Meta:
        label = 'base'
class UsersController(CementBaseController):
    class Meta:
        label = 'users'
        description = "this is the users controller"
        stacked_on = 'base'
        stacked_type = 'nested'
class HostsController(CementBaseController):
    class Meta:
        label = 'hosts'
        description = "this is the hosts controller"
        stacked_on = 'base'
        stacked_type = 'nested'
class UsersListController(CementBaseController):
    class Meta:
        label = 'users_list'
        description = 'list all available users'
        aliases = ['list']
        aliases_only = True
        stacked_on = 'users'
        stacked_type = 'nested'
    @expose(hide=True)
    def default(self):
        print "Inside UsersListController.default()"
class HostsListController(CementBaseController):
    class Meta:
        label = 'hosts_list'
        description = 'list all available hosts'
        aliases
def load_data(apps, schema_editor):
    ExpenseCategory(category_name="Groceries",).save()
    ExpenseCategory(category_name="Books",).save()
    ExpenseCategory(category_name="School Supplies",).save()
    ExpenseCategory(category_name="Utilities",).save()
    ExpenseCategory(category_name="Insurance",).save()
    ExpenseCategory(category_name="Medical",).save()
    ExpenseCategory(category_name="Gas",).save()
    ExpenseCategory(category_name="Mortgage",).save()
    ExpenseCategory(category_name="Travel",).save()
    ExpenseCategory(category_name="Restaurant",).save()
    ExpenseCategory(category_name="Taxes",).save()
    ExpenseType(type_name="Cash",).save()
    ExpenseType(type_name="Check",).save()
    ExpenseType(type_name="Credit Card",).save()
    VendorType(vendor_name="Walmart",).save()
    VendorType(vendor_name="Amazon",).save()
    VendorType(vendor_name="Costco/Sams",).save()
    VendorType(vendor_name="Starbucks",).save()
class Migration(migrations.Migration):
    depend
def handle(controller):
    ctrls_by_site = defaultdict(list)
    ctrl_sites = ControllerSite.objects.all()
    for ctrl_site in ctrl_sites:
        ctrls_by_site[ctrl_site.site].append(ctrl_site.controller)
    sites = Site.objects.all()
    for site in sites:
        if site not in ctrls_by_site or \
            controller not in ctrls_by_site[site]:
            controller_site = ControllerSite(controller=controller, site=site)
            controller_site.save()
    ctrls_by_slice = defaultdict(list)
    ctrl_slices = ControllerSlice.objects.all()
    for ctrl_slice in ctrl_slices:
        ctrls_by_slice[ctrl_slice.slice].append(ctrl_slice.controller)
    slices = Slice.objects.all()
    for slice in slices:
        if slice not in ctrls_by_slice or \
            controller not in ctrls_by_slice:
            controller_slice = ControllerSlice(controller=controller, slice=slice)
            controller_slice.save()
    ctrls_by_user = defaultdict(list)
    ctrl_users = ControllerUser.o
"""Fabric configurations file."""
SETTINGS = {
    "TEST_PROCESS_TIMEOUT": 30,
    "TEST_PROCESSES_COUNT": -1,
    "TEST_LIVESERVER_PORT": "8081-9081",
    "TEST_PACKAGES": ",".join([
        'metrics',
        'comment',
        'faker',
        'post',
        'page',
        'rblog'])}
def clean():
    local('find . -name "*.pyc" -delete')
    local("rm -rf cover/")
    local("rm -f .coverage")
def deploy():
    local("pip install -r requirements.txt")
    local("python manage.py migrate")
def runserver():
    local("python manage.py runserver 127.0.0.1:8000")
def setup():
    local("pip install -r requirements.txt")
    local("python manage.py syncdb")
    local("python manage.py migrate")
    local("python manage.py populatedb")
def coverage():
    local((
        "python manage.py test"
        " --with-coverage"
        " --cover-html"
        " --cover-package=%(TEST_PACKAGES)s"
        " --nocapture" % SETTINGS))
def test():
    local((
        "python manage.py test"
        
'''
create web server (port:8888) on folder / and /ws
/ : do nothing
/ws : web socket server, save message to file
'''
cl = []
save_page_count = 0
save_page_fname = ''
save_page_done_fname = ''
class IndexHandler(web.RequestHandler):
    def get(self):
        self.write("This tornado server to save page.")
class SocketHandler(websocket.WebSocketHandler):
    def check_origin(self, origin):
        return True
    def open(self):
        print('SocketHandler.open')
        if self not in cl:
            cl.append(self)
    def on_message(self, message):
        global save_page_count, save_page_fname, save_page_done_fname
        if os.path.isfile(save_page_done_fname):
            os.remove(save_page_done_fname)
        if os.path.isfile(save_page_fname):
            os.remove(save_page_fname)
        f = open(save_page_fname, mode='w')
        f.write(message)
        f.close()
        open(save_page_done_fname, mode='w').close()
        ttg.reform(message)
        save_page_count +=
urlpatterns = patterns('',
    url(r'^$','supermilai.views.index'),
    url(r'^login.html','account.views.account_login'),
    url(r'^logout.html','account.views.account_logout'),
    url(r'^password_change.html$','account.views.account_password_change'),
    url(r'^profile/view.html','account.views.account_view_profile'),
    url(r'^profile/edit/id=(.+)$','account.backend_manage.user_modify'),
    url(r'^manage/user_list.html','account.backend_manage.user_list'),
    url(r'^manage/add_user.html$','account.backend_manage.user_add'),
    url(r'^manage/modify/user/id=(.+)$','account.backend_manage.user_modify'),
    url(r'^manage/remove/user/id=(.+)$','account.backend_manage.user_remove'),
    url(r'^manage/group_list.html','account.backend_manage.group_list'),
    url(r'^manage/add_group.html$','account.backend_manage.group_add'),
    url(r'^manage/modify/group/id=(.+)$','account.backend_manage.group_modify'),
    url(r'^manage/remove/group/id=(.+)$','account.backend_manage.group_remove
class ControllerTest(unittest.TestCase):
    """ControllerTest: Test Controller Singleton"""
    def assertNotNone(self):
        """ControllerTest: Test instance not null"""
        controller = puremvc.core.Controller.getInstance()
        self.assertNotEqual(None, controller) 
    def assertIController(self):
        """ControllerTest: Test instance implements IController"""
        controller = puremvc.core.Controller.getInstance()
        self.assertEqual(True, isinstance(controller, puremvc.interfaces.IController))
    def testRegisterAndExecuteCommand(self):
        """ControllerTest: Test registerCommand() and executeCommand()"""
        controller = puremvc.core.Controller.getInstance()
        controller.registerCommand('ControllerTest', utils.controller.ControllerTestCommand)
        
        vo = utils.controller.ControllerTestVO(12)
        note = puremvc.patterns.observer.Notification('ControllerTest', vo)
        controller.executeCommand(note)
        
        self.asse

          
    def testRegisterAndRemoveCommand(self): 
        """ControllerTest: Test registerCommand() and removeCommand()"""
        controller = puremvc.core.Controller.getInstance()
        controller.registerCommand('ControllerRemoveTest', utils.controller.ControllerTestCommand)
        vo = utils.controller.ControllerTestVO(12)
        note = puremvc.patterns.observer.Notification('ControllerRemoveTest', vo)
        controller.executeCommand(note)
        self.assertEqual(True, vo.result == 24 )
        vo.result = 0
        controller.removeCommand('ControllerRemoveTest')
        controller.executeCommand(note)
        self.assertEqual(True, vo.result == 0)
             
    def testHasCommand(self): 
        """ControllerTest: Test hasCommand()"""
        
        controller = puremvc.core.Controller.getInstance()
        controller.registerCommand('hasCommandTest', utils.controller.ControllerTestCommand)
        self.assertEqual(True, controller.hasCommand('hasCommandTest')
"""
@api {get} /notes Request User's notes
@apiVersion 0.1.0
@apiName Notes List
@apiGroup Notes
@apiParam {String} q search query.
@apiSuccess (200) {Object[]} notes          notes list
@apiSuccess (200) {String}   notes.message  notes message
@apiSuccessExample {json} Success-Response:
     HTTP/1.1 200 OK
     [
       {
         "message": "Hello"
       },
       {
         "message": "Hello"
       }
     ]
"""
def get_notes():
    pass
"""
@api {put} /notes Update User's notes
@apiVersion 0.1.0
@apiName Update Notes
@apiGroup Notes
@apiParam {String} messsage  note message
@apiParamExample {json} Request-Example:
    {
        "message": "Hello"
    }
@apiSuccess (200) {Object} result          result message
@apiSuccess (200) {String} result.message  put result
@apiSuccessExample {json} Success-Response:
     HTTP/1.1 200 OK
     {
       "status": "updated"
     }
"""
def put_notes():
    pass
"""
@api {get} /users Request User's List
@apiVersion 0.1.0
@apiName Users List
@apiG
freebayes_repository_name = 'freebayes_0040'
freebayes_repository_description = "Galaxy's freebayes tool for test 0040"
freebayes_repository_long_description = "Long description of Galaxy's freebayes tool for test 0040"
filtering_repository_name = 'filtering_0040'
filtering_repository_description = "Galaxy's filtering tool for test 0040"
filtering_repository_long_description = "Long description of Galaxy's filtering tool for test 0040"
class TestRepositoryCircularDependencies( ShedTwillTestCase ):
    '''Verify that the code correctly displays repositories with circular repository dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_em

        self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
    def test_0005_create_category( self ):
        """Create a category for this test suite"""
        self.create_category( name='test_0040_repository_circular_dependencies', description='Testing handling of circular repository dependencies.' )
    def test_0010_create_freebayes_repository( self ):
        '''Create and populate freebayes_0040.'''
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=freebayes_repository_name,
                                                   

                                                    long_description=freebayes_repository_long_description,
                                                    owner=common.test_user_1_name,
                                                    categories=[ 'test_0040_repository_circular_dependencies' ],
                                                    strings_displayed=[] )
        self.upload_file( repository,
                          filename='freebayes/freebayes.tar',
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=True,
                          remove_repo_files_not_in_tar=False,
                          commit_message='Uploaded the tool tarball.',
                          strings_displayed=[],
                          strings_not_displayed=[] )
    def test_0015_create_filtering_repository( self ):
        '''Create and populate filtering_0040.'''
        self.logout()
        self.login( e
dir = {
  "home": "/home/{}/.t-game/".format(getpass.getuser())
def check_data(save):
    dft = ["0","1","15"]
    if 0 < len(save) < 3:
        save = dft
    elif len(save) == 0:
        save = dft
    else:
        for value in save:
            if not value.isdigit():
                if save.index(value) < 3:
                    save[save.index(value)] = dft[save.index(value)]
def level_up(save):
    if int(save[1]) > int(save[2]):
        rest = int(save[1]) - int(save[2])
    elif int(save[1]) == int(save[2]):
        rest = 0
    else:
        rest = 0
    save[0] = int(save[0]) + 1
    save[1] = rest
    save[2] = int(save[2]) + int(math.floor(math.log10(int(save[2]))*15))
def get_exp(save):
    RAND = random.randint(1, random.randint(1, 2001) ^ int(math.floor(time.time())))
    CURR = int(int(save[1]) + int(math.floor(math.log10(RAND)*10)))
    if CURR >= int(save[2]):
        level_up(save=save)
    else:
        save[1] = str(CURR)
if __name__ == "__main__":
    def get_dir(
def insert_data(apps, schema_editor):
    '''
    Inserts initial data for repetition and weight units
    Needed so that the migrations can go through without having to load any
    fixtures or perform any intermediate steps.
    '''
    WeightUnit = apps.get_model('core', 'WeightUnit')
    WeightUnit(name='kg', pk=1).save()
    WeightUnit(name='lb', pk=2).save()
    WeightUnit(name='Body Weight', pk=3).save()
    WeightUnit(name='Plates', pk=4).save()
    WeightUnit(name='Kilometers Per Hour', pk=5).save()
    WeightUnit(name='Miles Per Hour', pk=6).save()
    RepetitionUnit = apps.get_model('core', 'RepetitionUnit')
    RepetitionUnit(name='Repetitions', pk=1).save()
    RepetitionUnit(name='Until Failure', pk=2).save()
    RepetitionUnit(name='Seconds', pk=3).save()
    RepetitionUnit(name='Minutes', pk=4).save()
    RepetitionUnit(name='Miles', pk=5).save()
    RepetitionUnit(name='Kilometers', pk=6).save()
class Migration(migrations.Migration):
    dependencies = [
        ('core
starting_queue = None
stopping_queue = None
WORKER_NAME = 'worker/1'
def make_broker(manager, max_workers, start_queue=None, stop_queue=None):
    global starting_queue
    global stopping_queue
    starting_queue = start_queue
    stopping_queue = stop_queue
    return manager_worker_broker.get(max_workers, manager, _TestWorker)
class _TestWorker(manager_worker_broker.AbstractWorker):
    def __init__(self, worker_connection, worker_number=1):
        super(_TestWorker, self).__init__(worker_connection, worker_number)
        self._thing_to_greet = 'everybody'
        self._starting_queue = starting_queue
        self._stopping_queue = stopping_queue
    def handle_stop(self, src):
        self.stop_handling_messages()
    def handle_test(self, src, an_int, a_str):
        assert an_int == 1
        assert a_str == "hello, world"
        self._worker_connection.post_message('test', 2, 'hi, ' + self._thing_to_greet)
    def run(self, host, set_up_logging):
        if self._starting_que

            self._starting_queue.put('')
        if self._stopping_queue:
            self._stopping_queue.get()
        try:
            super(_TestWorker, self).run()
        finally:
            self._worker_connection.post_message('done')
class FunctionTests(unittest.TestCase):
    def test_get__inline(self):
        self.assertTrue(make_broker(self, 1) is not None)
    def test_get__processes(self):
        if sys.platform in ('cygwin', 'win32'):
            return
        self.assertTrue(make_broker(self, 2) is not None)
class _TestsMixin(object):
    """Mixin class that implements a series of tests to enforce the
    contract all implementations must follow."""
    def name(self):
        return 'TesterManager'
    def is_done(self):
        return self._done
    def handle_done(self, src):
        self._done = True
    def handle_test(self, src, an_int, a_str):
        self._an_int = an_int
        self._a_str = a_str
    def handle_exception(self, src, exception_type, excepti

        raise exception_type(exception_value)
    def setUp(self):
        self._an_int = None
        self._a_str = None
        self._broker = None
        self._done = False
        self._exception = None
        self._max_workers = None
    def make_broker(self, starting_queue=None, stopping_queue=None):
        self._broker = make_broker(self, self._max_workers, starting_queue,
                                   stopping_queue)
    def test_name(self):
        self.make_broker()
        worker = self._broker.start_worker(1)
        self.assertEquals(worker.name(), WORKER_NAME)
        worker.cancel()
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
        self._broker.cleanup()
    def test_cancel(self):
        self.make_broker()
        worker = self._broker.start_worker(1)
        self._broker.post_message('test', 1, 'hello, world')
        worker.cancel()
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
        self._broker.cleanup()
 
""" Views for Person, Name, and Surname """
dji = DjangoInterface()
    """
    Process act on person. Can return a redirect.
    """
    context["tview"] = _("Repository")
    context["tviews"] = _("Repositories")
    context["action"] = "view"
    view_template = "view_repository_detail.html"
    
    if handle == "add":
        act = "add"
    if "action" in request.POST:
        act = request.POST.get("action")
    if act == "share":
        item, handle = add_to
        context["pickform"] = PickForm("Pick repository", 
                                       Repository, 
                                       (),
                                       request.POST)     
        context["object_handle"] = handle
        context["object_type"] = item
        return render_to_response("pick.html", context)
    elif act == "save-share":
        item, handle = add_to 
        pickform = PickForm("Pick repository", 
                            Repository, 
                            ()

                            request.POST)
        if pickform.data["picklist"]:
            ref_handle = pickform.data["picklist"]
            ref_obj = Repository.objects.get(handle=ref_handle) 
            dji.add_repository_ref_default(parent_obj, ref_obj)
        else:
            context["pickform"] = pickform
            context["object_handle"] = handle
            context["object_type"] = item
            return render_to_response("pick.html", context)
    elif act == "add":
        repository = Repository(gramps_id=dji.get_next_id(Repository, "R"))
        repositoryform = RepositoryForm(instance=repository)
        repositoryform.model = repository
    elif act in ["view", "edit"]: 
        repository = Repository.objects.get(handle=handle)
        repositoryform = RepositoryForm(instance=repository)
        repositoryform.model = repository
    elif act == "save": 
        repository = Repository.objects.get(handle=handle)
        repositoryform = RepositoryForm(request.POS

        repositoryform.model = repository
        if repositoryform.is_valid():
            update_last_changed(repository, request.user.username)
            repository = repositoryform.save()
            dji.rebuild_cache(repository)
            act = "view"
        else:
            act = "edit"
    elif act == "create": 
        repository = Repository(handle=create_id())
        repositoryform = RepositoryForm(request.POST, instance=repository)
        repositoryform.model = repository
        if repositoryform.is_valid():
            update_last_changed(repository, request.user.username)
            repository = repositoryform.save()
            dji.rebuild_cache(repository)
            if add_to:
                item, handle = add_to
                model = dji.get_model(item)
                obj = model.objects.get(handle=handle)
                dji.add_repository_ref_default(obj, repository)
                dji.rebuild_cache(obj)
            act = "view"
        else:
       
column_repository_name = 'column_maker_1087'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_1087'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 1087 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryDependencies( ShedTwillTestCase ):
    '''Test installing a repository, then updating it to include repository dependencies.'''
    def test_0000_create_or_login_admin_user( self ):
        """Create necessary user accounts and login as an admin user."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = self.test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with e

        self.test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_email
        self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
    def test_0005_create_and_populate_column_repository( self ):
        """Create a category for this test suite and add repositories to it."""
        category = self.create_category( name=category_name, descrip

        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name,
                                                    description=column_repository_description,
                                                    long_description=column_repository_long_description,
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ),
                                                    strings_displayed=[] )
        if self.repository_is_new( repository ):
            self.upload_file( repository,
                              filename='column_maker/column_maker.tar',
                              filepath=None,
                              valid_tools_only=True,
                              uncompress_file=True,
                              remo
urlpatterns = patterns('',
    url(r'^test/$', views.test, name='test'),
    url(r'^add/$', views.add, name='add'),
    url(r'^phpmyadmin/$', views.phpmyadmin, name='phpmyadmin'),
    url(r'^user/(?P<article_id>[\w\-]+)/$', user.index, name='user_index'),
    
    url(r'^register/$', front_manage.register, name='register'),
    url(r'^login/$', front_manage.user_login, name='user_login'),
    url(r'^$', front_manage.index, name='index'),
    url(r'^all_article/$', front_manage.all_article, name='all_article'),
    url(r'^category/$', front_manage.category, name='category'),
    url(r'^article/$', front_manage.article, name='article'),
    url(r'^essays/$', front_manage.essays, name='essays'),
    url(r'^all_essays/$', front_manage.all_essays, name='all_essays'),
    url(r'^commit_comment/$', front_manage.commit_comment, name='commit_comment'),
    
    url(r'^album/$', front_manage.album, name='album'),
    url(r'^message/$', front_manage.message, name='message'),
    url(r'^commit_mes

    url(r'^author/$', front_manage.author, name='author'),
    url(r'^subscribe/$', front_manage.subscribe, name='subscribe'),
    url(r'^collect/$', front_manage.collect, name='collect'),
    url(r'^logout/$', back_manage.user_logout, name='user_logout'),
    url(r'^admin/$', back_manage.admin, name='admin'),
    url(r'^change_password/$', back_manage.change_password, name='change_password'),
    url(r'^admin/category_manage/$', back_manage.category_manage, name='category_manage'),
    url(r'^admin/add_category/$', back_manage.add_category, name='add_category'),
    url(r'^admin/del_category/$', back_manage.del_category, name='del_category'),
    url(r'^admin/article_manage/$', back_manage.article_manage, name='article_manage'),
    url(r'^admin/add_article/$', back_manage.add_article, name='add_article'),
    url(r'^admin/edit_article/$', back_manage.edit_article, name='edit_article'),
    url(r'^admin/del_article/$', back_manage.del_article, name='del_article'),
    url(r'^admin/es

    url(r'^admin/add_essays/$', back_manage.add_essays, name='add_essays'),
    url(r'^admin/edit_essays/$', back_manage.edit_essays, name='edit_essays'),
    url(r'^admin/del_essays/$', back_manage.del_essays, name='del_essays'),
    url(r'^admin/comment_manage/$', back_manage.comment_manage, name='comment_manage'),
    url(r'^admin/find_comment/$', back_manage.find_comment, name='find_comment'),
    url(r'^admin/del_comment/$', back_manage.del_comment, name='del_comment'),
    url(r'^admin/message_manage/$', back_manage.message_manage, name='message_manage'),
    url(r'^admin/find_message/$', back_manage.find_message, name='find_message'),
    url(r'^admin/del_message/$', back_manage.del_message, name='del_message'),
    url(r'^admin/album_manage/$', back_manage.album_manage, name='album_manage'),
    url(r'^admin/add_album/$', back_manage.add_album, name='add_album'),
    url(r'^admin/link_manage/$', back_manage.link_manage, name='link_manage'),
    url(r'^admin/add_link/$', back_m
__all__ = ['AMQPBrokerTask', 'BrokerPool', 'AMQPBrokerSettings']
class AMQPBrokerSettings(object):
    """
    AMQP connection settings.
    """
    def __init__(self):
        self.hostname = None
        self.port = 5672
        self.username = None
        self.password = None
        self.vhost = "/"
class AMQPBrokerTask(Task):
    def __init__(self, bus=None):
        Task.__init__(self, bus)
        self.settings = AMQPBrokerSettings()
        self.pool_size = 10
        self.pool = None
    def start_task(self):
        self.bus.log("Starting AMQP broker management task")
        self.pool = BrokerPool(self.settings.hostname, self.settings.port,
                               self.settings.username, self.settings.password,
                               self.settings.vhost, self.pool_size)
        with self.pool.lock:
            pass
        self.bus.subscribe("get-amqp-broker", self.get_broker)
        self.bus.subscribe("release-amqp-broker", self.release_broker)
    start_ta

        
    def stop_task(self):
        self.bus.log("Stopping AMQP broker management task")
        self.bus.unsubscribe("get-amqp-broker", self.get_broker)
        self.bus.unsubscribe("release-amqp-broker", self.release_broker)
        self.pool.release_all()
    stop_task.priority = 90
    def get_broker(self):
        return self.pool.get()
    def release_broker(self, broker):
        self.pool.release(broker)
class BrokerPool(object):
    def __init__(self, hostname, port, username, password, vhost, pool_size=10):
        self.lock = threading.Lock()
        
        self.hostname = hostname
        self.port = port
        self.username = username
        self.password = password
        self.vhost = vhost
        self._brokers = []
        self._checkedout_brokers = []
        self.add_many(pool_size)
    def add_many(self, limit):
        with self.lock:
            for _ in range(0, limit):
                broker = BrokerConnection(hostname=self.hostname, port=self.port,


                                          virtual_host=self.vhost)
                self._brokers.append(broker)
    def add(self):
        broker = BrokerConnection(hostname=self.hostname, port=self.port,
                                  userid=self.username, password=self.password,
                                  virtual_host=self.vhost)
        with self.lock:
            self._brokers.append(broker)
    def get(self):
        with self.lock:
            broker = self._brokers.pop()
            self._checkedout_brokers.append(broker)
            return broker
    def release(self, broker):
        with self.lock:
            self._brokers.append(broker)
            if broker in self._checkedout_brokers:
                self._checkedout_brokers.remove(broker)
    def release_all(self):
        with self.lock:
            for broker in self._brokers:
                broker.close()
            self._brokers = []
            for broker in self._checkedout_brokers:
                bro
GPIO_Common.init()
class Switch:
  A = 4
  B = 22
  C = 27
  D = 17
weather = get_weather("Matosinhos")
char_test_count = 0
def display_routine_intro(display_controller):
  display_controller.text(DisplayController.LCD_LINE_1, "Welcome!")
  display_controller.text(DisplayController.LCD_LINE_2, "Buttons do Stuff")
  
def display_routine_scroll(display_controller):
  display_controller.text(DisplayController.LCD_LINE_1, "* NOT A TEST *",)
  display_controller.scroll(DisplayController.LCD_LINE_2, "This is reality", 2)
def display_routine_timestamp(display_controller):
  display_controller.text(DisplayController.LCD_LINE_1, "* DATE TIME * ")
  display_controller.scroll(DisplayController.LCD_LINE_2, timestamp_hr(), 1)
def display_routine_weather(display_controller):
  global weather
  display_controller.text(DisplayController.LCD_LINE_1, "* WEATHER * ")
  display_controller.scroll(DisplayController.LCD_LINE_2, weather, 1)
def display_char_test(display_controller):
  global char_test_count
 

  display_controller.text(DisplayController.LCD_LINE_2, "%x %s" % (char_test_count, chr(char_test_count)))
  char_test_count = char_test_count + 1
  
  
def display_routine_ip_addresses(display_controller):
  display_controller.text(DisplayController.LCD_LINE_1, "* IP ADDRESSES * ")
  display_controller.scroll(DisplayController.LCD_LINE_2, ip_str(), 2)
    
def callback_switch_A_released(event, delta):
  display_controller.set_callback(display_routine_timestamp)
def callback_switch_B_released(event, delta):
  display_controller.set_callback(display_routine_ip_addresses)
def callback_switch_C_released(event, delta):
  display_controller.set_callback(display_routine_weather)
def callback_switch_D_released(event, delta):
  display_controller.set_callback(display_char_test)
  
    
def callback_switch_D_held_long(event, delta):
  display_controller.set_callback(display_routine_intro)
  
switch_controller = SwitchController({ 
  Switch.A : {
    Action.switch_released : callback_switch_A_r
class Router(object):
    def initializeApi(self, base_url, api_list):
        """RestEngine api router initialize"""
        self.base = base_url
        
        for api in api_list:
            if not api.startswith("/"): api = "/" + api
            if not api.endswith('/'): api += "/"
            self.validateApi(api)
            pattern = re.sub(r"/:\w+", "/\w*", api)
            pattern = re.sub(r"/numeric:\w+", "/\d*", pattern)
            self.addRestApi(api, pattern)
            print(api.count("/"), pattern, api)
    def addRestApi(self, api, regex_pattern):
        rest = self.rest
        word_count = api.count("/") - 1
        parameter_count = api.count(":")
        regex = re.compile("^" + regex_pattern + "$")
        new_api = {"api": api,
                   "pattern": regex_pattern,
                   "regex": regex,
                   "resource_count": word_count - parameter_count,
                   "priority": api.count("/numeric:")
                   }
        if r

            rest[word_count] = []
        api_list = rest.get(word_count)
        for a in api_list:
                print(new_api, a)
                raise "pattern duplicated"
        api_list = rest.get(word_count)
        api_list.append(new_api)
        api_list.sort(key=itemgetter("resource_count", "priority"))
    def findRestApi(self, path):
        if(path.startswith(self.base)):
            path = path[len(self.base):]
        if not path.endswith("/"):
            path += "/"
        api_list = self.rest.get(path.count("/") - 1)
        if(isinstance(api_list, list)):
           for api in api_list:
               regex = api.get("regex")
               if regex.match(path):
                   return api, path
        if(isinstance(api_list, dict)):
            regex = api_list.get("regex")
            if(regex.match(path)):
                return api_list, path
    def validateApi(self, api):
        """/resource(/:query)* | (/resource(/:query)+)+"""
        if not self.ap
admin.autodiscover()
urlpatterns = patterns('',
    (r'^grappelli/',include('grappelli.urls')),
    url(r'^admin/', include(admin.site.urls)),
    url(r'^favicon.ico$', RedirectView.as_view(url='/static/images/favicon.png')),
    url(r'^accounts/login/$', 'engine.account.userlogin',name="userlogin"),
    url(r'^accounts/logout/$',  'django.contrib.auth.views.logout',
                                {'next_page': '/accounts/login/'},name="userlogout"),
    url(r'^accounts/changepassword/$', 'engine.account.changepassword',name="changepassword"),
    url(r'^$', 'engine.views.index'),
    url(r'^manage/class/$', 'engine.class.index',name="manageclass"),
    url(r'^manage/addclass/$', 'engine.class.addclass',name="addclass"),
    url(r'^manage/editclass/$', 'engine.class.editclass',name="editclass"),
    url(r'^manage/deleteclass/$', 'engine.class.deleteclass',name="deleteclass"),
    url(r'^ajax/get_classes_list/$', 'engine.class.get_classes_list',name="get_classes_list"),
    
    url(r'

    url(r'^manage/addstudent/$', 'engine.student.addstudent',name="addstudent"),
    url(r'^manage/editstudent/$', 'engine.student.editstudent',name="editstudent"),
    url(r'^manage/deletestudent/$', 'engine.student.deletestudent',name="deletestudent"),
    url(r'^manage/initstudent/$', 'engine.student.initstudent',name="initstudent"),
    url(r'^studentprofile/$', 'engine.student.studentprofile',name="studentprofile"),
    url(r'^ajax/get_students_list/$', 'engine.student.get_students_list',name="get_students_list"),
    url(r'^ajax/select_classes/$', 'engine.class.select_classes',name="select_classes"),
    url(r'^manage/assessment/$', 'engine.assessment.index',name="manageassessment"),
    url(r'^manage/addassessment/$', 'engine.assessment.addassessment',name="addassessment"),
    url(r'^manage/editassessment/$', 'engine.assessment.editassessment',name="editassessment"),
    url(r'^manage/deleteassessment/$', 'engine.assessment.deleteassessment',name="deleteassessment"),
    url(r

    url(r'^ajax/get_assessments_list/$', 'engine.assessment.get_assessments_list',name="get_assessments_list"),
    url(r'^ajax/view_assessments_list/$', 'engine.assessment.view_assessments_list',name="view_assessments_list"),
    url(r'^manage/goassessment/$', 'engine.assessment.goassessment',name="goassessment"),
    url(r'^ajax/go_assessments_list/$', 'engine.assessment.go_assessments_list',name="go_assessments_list"),
    url(r'^ajax/go_assessments/$', 'engine.assessment.go_assessments',name="go_assessments"),
    
    url(r'^manage/grades/$', 'engine.grade.index',name="managegrades"),
    url(r'^manage/classgrades/$', 'engine.grade.classgrades',name="classgrades"),
    url(r'^ajax/studentgrades/$', 'engine.grade.studentgrades',name="studentgrades"),
    url(r'^ajax/ajaxclassgrades/$', 'engine.grade.ajaxclassgrades',name="ajaxclassgrades"),
    url(r'^manage/behavior/$', 'engine.activity.behavior',name="behavior"),
    url(r'^manage/addbehavior/$', 'engine.activity.addbehavior',na
class Manager(object):
    def __init__(self):
        self.rxq = Queue()
        self.txq = Queue()
        self.inputs = []
    def start(self):
        broker = Broker(self.rxq, self.txq)
        broker.find_plugins()
        irc = Irc(self.rxq, self.txq)
        self.irc_p = Process(target=irc.start)
        self.broker_p = Process(target=broker.start)
        self.irc_p.start()
        self.broker_p.start()
        
        for input in settings.INPUTS:
            input_path = path.join(settings.INPUTS_DIR, "%s.py" % input)
            if path.isfile(input_path):
                module = load_source(input, input_path)
                p = Process(target=module.input, args=(self.rxq,))
                self.inputs.append(p)
                p.start()
            else:
                pass
        
    def end(self):
        """
Sends quit event to both queues and waits for them to run their course.
        """
        self.rxq.put(QuitEvent())
        self.txq.put(QuitEvent())
      
def liveness(n):
    if hasattr(n, 'live'):
        s = '\t{' + ','.join(n.live) + '}'
    else:
        s = '\t{}'
    return s
    
class PrintVisitor(Visitor):
    def visitModule(self, n):
        return self.dispatch(n.node)
    def visitStmt(self, n):
        return '{\n  ' + '\n  '.join([self.dispatch(s) + liveness(s) for s in n.nodes]) + '\n}'
    def visitCallX86(self, n):
    def visitPush(self, n):
    def visitPop(self, n):
    def visitIntMoveInstr(self, n):
        return ('movl %s, %s' % (self.dispatch(n.rhs[0]),
    def visitIntAddInstr(self, n):
        return ('addl %s, %s' % (self.dispatch(n.rhs[0]),
    def visitIntLEAInstr(self, n):
        return ('%s = %s + %s' % (self.dispatch(n.lhs),
                                 self.dispatch(n.rhs[0]),
    def visitIntSubInstr(self, n):
        return ('subl %s, %s' % (self.dispatch(n.rhs[0]), self.dispatch(n.lhs)
    def visitIntNegInstr(self, n):
        x = self.dispatch(n.lhs)
    def visitName(self, n):
        return

    def visitRegister(self, n):
        return '%' + n.name
    def visitConst(self, n):
        return repr(n.value)
class PrintVisitor2(PrintVisitor):
    def visitShiftLeftInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s << %s" % (self.dispatch(n.lhs),
                                      self.dispatch(n.rhs[0]),
                                      self.dispatch(n.rhs[1]))
        else:
            return "sall %s, %s" % (self.dispatch(n.rhs[0]),
                                    self.dispatch(n.lhs))
    def visitShiftRightInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s >> %s" % (self.dispatch(n.lhs),
                                      self.dispatch(n.rhs[0]),
                                      self.dispatch(n.rhs[1]))
        else:
            return "sarl %s, %s" % (self.dispatch(n.rhs[0]),
                                   self.dispatch(n.lhs))
    def visitIntOrInstr(self, n):
        if len(n.rhs) > 1:
            retur

                                     self.dispatch(n.rhs[0]),
                                     self.dispatch(n.rhs[1]))
        else:
            return "orl %s, %s" % (self.dispatch(n.rhs[0]),
                                  self.dispatch(n.lhs))
    def visitIntAndInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s & %s" % (self.dispatch(n.lhs),
                                     self.dispatch(n.rhs[0]),
                                     self.dispatch(n.rhs[1]))
        else:
            return "andl %s, %s" % (self.dispatch(n.lhs),
                                 self.dispatch(n.rhs[0]))
    def visitIntNotInstr(self, n):
        x = self.dispatch(n.lhs)
        return 'negl %s' % x
    
    def visitCMPLInstr(self, n):
        return "cmpl %s, %s" % (self.dispatch(n.rhs[0]),
                                 self.dispatch(n.rhs[1]))
    def visitSetIfEqInstr(self, n):
        return "sete %s" % self.dispatch(n.lhs)
    def visitSetIfNotEqInstr(self, n
sys_graphicsController = GraphicsController()
sys_gameController = GameController()
sys_inputController = Input()
sys_random = Random()
def random():
	return sys_random.nextDouble()
def drawRectangle(x, y, width, height):
	global sys_graphicsController
	sys_graphicsController.drawRectangle(x, y, width, height)
def drawCircle(x, y, radius):
	global sys_graphicsController
	sys_graphicsController.drawCircle(x, y, radius)
def drawLine(x1, y1, x2, y2):
	global sys_graphicsController
	sys_graphicsController.drawLine(x1, y1, x2, y2)
def drawPoint(x, y):
	global sys_graphicsController
	sys_graphicsController.drawPoint(x, y)
def drawString(x, y, string):
	global sys_graphicsController
	sys_graphicsController.drawString(x, y, string)
def useColour(r, g, b, a):
	global sys_graphicsController
	sys_graphicsController.useColour(r, g, b, a)
def clearScreen():
	global sys_graphicsController
	sys_gameController.clearScreen()
def newFrame():
	global sys_graphicsController
	sys_gameController.newFrame()

__all__ = ['observable']
def observable(cls):
	t = cls.__init__
	def __init__(self, *a, **kw):
		b = Broker()
		self._message_broker = b
		t(self, *a, **kw)
		assert id(b) == id(self._message_broker), "_message_broker is a reserved word for observable, don't use it any where."
	def sub(self, *a, **kw):
		self._message_broker.sub(*a, **kw)
	def unsub(self, *a, **kw):
		self._message_broker.unsub(*a, **kw)
	def pub(self, *a, **kw):
		self._message_broker.pub(*a, **kw)
	def declare(self, *a, **kw):
		self._message_broker.declare(*a, **kw)
	def retract(self, *a, **kw):
		self._message_broker.retract(*a, **kw)
	def get_declarations(self, *a, **kw):
		self._message_broker.get_declarations(*a, **kw)
	def has_declaration(self, *a, **kw):
		self._message_broker.has_declaration(*a, **kw)
	setattr(cls, '__init__', __init__)
	for k, v in dict(sub = sub,
			unsub = unsub,
			pub = pub,
			declare = declare, 
			retract = retract,
			get_declarations = get_declarations,
			has_declaration = has_decl
"""
 Copyright 2015 Telefonica Investigacion y Desarrollo, S.A.U
 This file is part of Orion Context Broker.
 Orion Context Broker is free software: you can redistribute it and/or
 modify it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.
 Orion Context Broker is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero
 General Public License for more details.
 You should have received a copy of the GNU Affero General Public License
 along with Orion Context Broker. If not, see http://www.gnu.org/licenses/.
 For those usages not covered by this license please contact with
 iot_support at tid dot es
"""
__author__ = 'Iván Arias León (ivan dot ariasleon at telefonica dot com)'
__logger__ = logging.getLogger("utils")
class Properties:
 

    properties  management
    """
    def __init__(self):
        """
        constructor
        """
    def read_configuration_json(self):
        """
        return properties from configuration.josn file
        :return: dict
        """
        return read_file_to_json("configuration.json")
    def update_properties_json_file(self, file_name, sudo_run="true"):
        """
         update properties. json from script file in setting folders
        :param file_name: script file associated to a feature
        :param sudo_run:  with superuser privileges (True | False)
        """
        if sudo_run.lower() == "true":
            sudo_run = "sudo"
        else:
            sudo_run = ""
        configuration = self.read_configuration_json()
        __logger__.info("configuration.json: %s" % str(configuration))
        if configuration["UPDATE_PROPERTIES_JSON"].lower() == "true":
            __logger__.info(" >> config file used: '%s'", file_name)
            with open("%s/%s" % (c

                for line in config_file.readlines():
                    __logger__.info("-- properties.json lines: %s %s" % (sudo_run, str(line)))
                    p = subprocess.Popen("%s %s" % (sudo_run, str(line)), shell=True, stdout=subprocess.PIPE,
                                         stderr=subprocess.STDOUT)
                    stdout = p.stdout.readlines()
                    assert stdout == [], "ERROR - modifying config files from %s/%s in setting folder. \n " \
                                         "        %s" % (configuration["PATH_TO_SETTINGS_FOLDER"], file_name, stdout)
            __logger__.info(" >> properties.json is created or updated")
        else:
            __logger__.info("properties.json is not updated")
    def read_properties(self):
        """
        Parse the properties used in project located in the acceptance folder
        :return: properties dict
        """
        self.config = read_file_to_json("properties.json")
        return self.co
class TestNSArrayControler (TestCase):
    def testMethods(self):
        self.assertResultIsBOOL(NSArrayController.automaticallyRearrangesObjects)
        self.assertResultIsBOOL(NSArrayController.clearsFilterPredicateOnInsertion)
        self.assertArgIsBOOL(NSArrayController.setClearsFilterPredicateOnInsertion_, 0)
        self.assertResultIsBOOL(NSArrayController.avoidsEmptySelection)
        self.assertArgIsBOOL(NSArrayController.setAvoidsEmptySelection_, 0)
        self.assertResultIsBOOL(NSArrayController.preservesSelection)
        self.assertArgIsBOOL(NSArrayController.setPreservesSelection_, 0)
        self.assertResultIsBOOL(NSArrayController.selectsInsertedObjects)
        self.assertArgIsBOOL(NSArrayController.setSelectsInsertedObjects_, 0)
        self.assertResultIsBOOL(NSArrayController.alwaysUsesMultipleValuesMarker)
        self.assertArgIsBOOL(NSArrayController.setAlwaysUsesMultipleValuesMarker_, 0)
        self.assertResultIsBOOL(NSArrayController.setSelectionIndexe
__author__ = 'Qingfu Wen'
urlpatterns = patterns('',
    url(r'^$', 'manage.views.index'),
    url(r'^global_search/$','manage.views.global_search'),
    url(r'^search/$', 'manage.views.search'),
    url(r'^update_search_result/$', 'manage.views.update_search_result'),
    url(r'^basic_info/$', 'manage.views.get_basic_info'),
    url(r'^update_basic_info/$', 'manage.views.update_basic_info'),
    url(r'^degree_info/$', 'manage.views.get_degree_info'),
    url(r'^update_degree_info/$', 'manage.views.update_degree_info'),
    url(r'^award_info/$', 'manage.views.get_award_info'),
    url(r'^update_award_info/$', 'manage.views.update_award_info'),
    url(r'^family_info/$', 'manage.views.get_family_info'),
    url(r'^update_family_info/$', 'manage.views.update_family_info'),
    url(r'^experience_info/$', 'manage.views.get_experience_info'),
    url(r'^update_experience_info/$', 'manage.views.update_experience_info'),
    url(r'^graduation_info/$', 'manage.views.get_graduation_info'),
    
admin.autodiscover()
urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^db/api/clear/$', 'API.Views.truncate.dropDB', name='truncateData'),
    url(r'^db/api/forum/create/$', 'API.Views.forum.create', name='create_forum'),
    url(r'^db/api/forum/details/$', 'API.Views.forum.details', name='details_forum'),
    url(r'^db/api/forum/listPosts/$', 'API.Views.forum.list_posts', name='listPosts_forum'),
    url(r'^db/api/forum/listThreads/$', 'API.Views.forum.list_threads', name='listThreads_forum'),
    url(r'^db/api/forum/listUsers/$', 'API.Views.forum.list_users', name='listUsers_forum'),
    url(r'^db/api/post/create/$', 'API.Views.post.create', name='create_post'),
    url(r'^db/api/post/details/$', 'API.Views.post.details', name='details_post'),
    url(r'^db/api/post/list/$', 'API.Views.post.post_list', name='list_post'),
    url(r'^db/api/post/remove/$', 'API.Views.post.remove', name='remove_post'),
    url(r'^db/api/post/restore/$', 'API.Views.post

    url(r'^db/api/post/update/$', 'API.Views.post.update', name='update_post'),
    url(r'^db/api/post/vote/$', 'API.Views.post.vote', name='vote_post'),
    url(r'^db/api/user/create/$', 'API.Views.user.create', name='create_user'),
    url(r'^db/api/user/details/$', 'API.Views.user.details', name='details_user'),
    url(r'^db/api/user/follow/$', 'API.Views.user.follow', name='follow_user'),
    url(r'^db/api/user/listFollowers/$', 'API.Views.user.list_followers', name='list_followers'),
    url(r'^db/api/user/listFollowing/$', 'API.Views.user.list_following', name='list_following'),
    url(r'^db/api/user/listPosts/$', 'API.Views.user.list_posts', name='posts_user'),
    url(r'^db/api/user/unfollow/$', 'API.Views.user.unfollow', name='unfollow_user'),
    url(r'^db/api/user/updateProfile/$', 'API.Views.user.update', name='update_users'),
    url(r'^db/api/thread/close/$', 'API.thread.close', name='close_thread'),
    url(r'^db/api/thread/create/$', 'API.thread.create', name='create
MAX_YAML_LENGTH = 1048576
REPOSITORY_KEY = 'repository'
REPOSITORY_BRANCHES = 'branches'
REPOSITORY_PATH = 'path'
REPOSITORY_REVISIONS = 'revisions'
BRANCH_KEY = 'branches'
BRANCH_HEAD = 'head'
REVISION_PREDECESSORS = 'predecessors'
REVISION_PROPERTIES = 'properties'
REVISION_DIFFWITHPARENT = 'diffwithparent'
def construct_repository(path, key=None):
    """ read_yaml takes a path to a yaml file """
    fsock = open(path)
    
    repository = None
    try:
        yaml_string = fsock.read(MAX_YAML_LENGTH)
        yaml_rep = yaml.load(yaml_string)
    
        repository = process_repository(yaml_rep[REPOSITORY_KEY])
        process_branch(yaml_rep[BRANCH_KEY], repository)
    
    finally:
        fsock.close()
    
    if key:
        return repository[key]
    else:
        return repository
def process_repository(repo_dict):
    """ Takes a dictionary containing keys: path, branches and revisions and 
    returns a Repository object. This method should only be called by 
    read_y

    path = repo_dict[REPOSITORY_PATH]
    revisions = {}
    if REPOSITORY_REVISIONS in repo_dict:
        for revision_id in repo_dict[REPOSITORY_REVISIONS]:
            revisions[revision_id] = None
    branches = {}
    if REPOSITORY_BRANCHES in repo_dict:
        for branch_name in repo_dict[REPOSITORY_BRANCHES]:
            branches[branch_name] = None
    
    return Repository(path, branches, revisions, True)
def process_branch(branch_dict, repo):
    """ Takes a dictionary that has branch names as keys. This method sets
    branches for repo"""
    for branch_name in branch_dict:
        branch = branch_dict[branch_name]
        repo.get_branches()[branch_name] = Branch(branch[BRANCH_HEAD], branch_name)
def process_revision(revision_dict, repo):
    """ Takes a dictionary that has revision ids as keys. This method sets 
    revisions for repo"""
    for revision_id in revision_dict:
        revision = revision_dict[revision_id]
        
        predecessors = []
        if REV
def build_create_parser(dispatch, action_parser, help=''):
    if not help:
        help = "Create a(n) {0} record".format(dispatch.dtype)
    create_parser = action_parser.add_parser('create', help=help)
    for add_arg, extract_arg, test_method in dispatch.create_args:
        add_arg(create_parser)
def build_update_parser(dispatch, action_parser, help=''):
    if not help:
        help = "Update a(n) {0}".format(dispatch.dtype)
    update_parser = action_parser.add_parser('update', help=help)
    for add_arg, extract_arg, test_method in dispatch.update_args:
        add_arg(update_parser, required=False)
def build_delete_parser(dispatch, action_parser, help=''):
    if not help:
        help = "Delete a(n) {0}".format(dispatch.dtype)
    delete_parser = action_parser.add_parser('delete', help=help)
    for add_arg, extract_arg, test_method in dispatch.delete_args:
        add_arg(delete_parser)
def build_detail_parser(dispatch, action_parser, help=''):
    if not help:
        help 
_rabbitMQBrokers = dict()
class RabbitMQBroker(object):
    def __init__(self):
        self.exchanges = dict()
        self.exchanges[''] = ExchangeMock(type='fanout')
        self.sendOrderByExchanges = list()
def startFakeRabbitMQBroker(url):
    global _rabbitMQBrokers
    _rabbitMQBrokers[_brokerKeyByURL(url)] = RabbitMQBroker()
def _brokerKeyByURL(url):
    return "%(host)s:%(port)s" % dict(host=url.host, port=url.port)
def stopFakeRabbitMQBroker(url):
    global _rabbitMQBrokers
    del _rabbitMQBrokers[_brokerKeyByURL(url)]
def removeAllBrokers():
    global _rabbitMQBrokers
    rabbitMQBrokers = dict()
def getBrokerInstanceFromURL(url):
    global _rabbitMQBrokers
    return _rabbitMQBrokers[_brokerKeyByURL(url)]
class ExchangeMock(object):
    def __init__(self, type):
        if type != 'fanout':
            raise ValueError("Mock does not support exchange types other than 'fanout'")
        self.exchange_type = type
        self.messages = Queue.Queue()
    def publish(self

        self.messages.put(message)
    def consume(self):
        return self.messages.get()
class BlockingChannelMock(object):
    def __init__(self):
        self.broker = None
        self.exchanges = None
        self.deletedExchanges = dict()
    def setBroker(self, broker):
        self.exchanges = broker.exchanges
        self.broker = broker
    def exchange_declare(self, exchange, type):
        if exchange in self.exchanges:
            existing = self.exchanges[exchange]
            self._validateExchangePropertyIsEqual(type, existing.type)
        self.exchanges[exchange] = ExchangeMock(type=type)
    def exchange_delete(self, exchange):
        assert exchange is not None
        deletedExchange = self.exchanges.pop(exchange)
        self.deletedExchanges[exchange] = deletedExchange
    def basic_publish(self, exchange, routing_key, body):
        if exchange not in self.exchanges:
            raise ValueError(exchange, "Not a declared exchange")
        self.exchanges[ex
'''
Created on Mar 24, 2014
@author: adrian.costia
'''
_MONGODB_HOST = '10.100.63.48'
_MONGODB_NAME = 'trivia'
connect(_MONGODB_NAME, host=_MONGODB_HOST)
'''
try:
    GameType(name="Default").save()
    GameType(name="Single Player").save()
    GameType(name="Multiplayer").save()
    GameType(name="Challenge").save()
    GameType(name="Play With Friends").save()
except:
    traceback.print_exc()
'''
'''
try:
    LeaderboardType(name='General').save()
    LeaderboardType(name='Friends').save()
except:
    traceback.print_exc()
'''
try:
    UserRank(ranking=1, points=10).save()
    UserRank(ranking=2, points=15).save()
    UserRank(ranking=3, points=40).save()
    UserRank(ranking=4, points=80).save()
    UserRank(ranking=5, points=120).save()
    UserRank(ranking=6, points=250).save()
    UserRank(ranking=7, points=400).save()
    UserRank(ranking=8, points=700).save()
    UserRank(ranking=9, points=1000).save()
    UserRank(ranking=10, points=1500).save()
except:
    traceback.print_ex
class RepositoryTestCase(GitTestHelper):
  def testInvalidRepository(self):
    self.assertFalse(self.repository.isValidGitRepository())
  def testInitializeRepository(self):
    self.repository.initialize()
    self.assertTrue(self.repository.isValidGitRepository())
  def testAddRemoteRepository(self):
    self.repository.initialize()
    self.repository.addRemote("testSSH", "ssh://example.com/test.git")
    self.repository.addRemote("testHTTP", "http://example.com/test.git")
    output = self.repository.executeCommand("remote", ["-v"])
    self.assertTrue(output.find("ssh://example.com/test.git"))
    self.assertTrue(output.find("http://example.com/test.git"))
  def testAdvancedCommit(self):
    self.repository.initialize()
    self.generateComplicatedCommit()
    output = self.repository.executeCommand("status")
    self.assertTrue("master" not in output)
    self.assertTrue("nothing to commit" in output)
  def testCloneRepository(self):
    self.repository.initialize()
    self.gen
'''
Testing RemindmeRepository model.
Objectives:
 - ensure a consistent interface is maintained
'''
class Test_RemindmeRepository_Model(unittest.TestCase):
    '''Tests against the RemindmeRepository model
    (remindme.models.RemindmeRepository).'''
    def setUp(self):
        self.db_file = "./test/_test.RemindmeRepository.db"
        self.repository = RemindmeRepository(self.db_file)
        self.data = [
            { "title": "my title is awesome", "content": "and so is my content" },
            { "title": "boring but real title", "content": "get some content for me" },
            { "title": "pizza lover", "content": "some good pizza for me" }
        ]
        for d in self.data:
            self.repository.create_remindme(d["title"], d["content"])
    def test_constructor_restores_remindmes(self):
        num_remindmes = self.repository.count()
        same_repo = RemindmeRepository(self.db_file)
        num_restored_remindmes = same_repo.count()
        self.assertEqual(num

    def test_insert_remindme(self):
        title = "gotcha boy"
        content = "pink stars are awesome"
        remindme = Remindme(title, content, self.repository)
        status = self.repository.insert_remindme(remindme)
        self.assertTrue(status,
            remindme''')
        found_remindme = self.repository.find_by_title(title)
        self.assertEqual(content, found_remindme.get_content(),
            remindme''')
    def test_insert_remindmes_with_same_title(self):
        title = "same old title"
        remindme_1 = Remindme(title, "some content", self.repository)
        remindme_2 = Remindme(title, "other content", self.repository)
        status = self.repository.insert_remindme(remindme_1)
        self.assertTrue(status,
        status = self.repository.insert_remindme(remindme_2)
        self.assertFalse(status,
            a remindme fails to be inserted''')
    def test_create_remindme(self):
        title = "some good title, boo"
        content = "got som

        remindme = self.repository.create_remindme(title, content)
        self.assertTrue(isinstance(remindme, Remindme),
            return an instance of Remindme''')
    def test_create_remindmes_with_same_title(self):
        title = "some random content for everyone"
        content = "got some content for you!"
        remindme = self.repository.create_remindme(title, content)
        self.assertTrue(isinstance(remindme, Remindme),
        remindme = self.repository.create_remindme(title, "soem other content")
        self.assertFalse(remindme,
            remindme with same title is being created''')
    def test_remove_remindme(self):
        remindme_to_remove = self.repository.get_remindmes()[0]
        status = self.repository.remove_remindme(remindme_to_remove)
        self.assertTrue(status,
            removing a remindme''')
        remindmes = self.repository.get_remindmes()
        found_remindme = (len([r for r in remindmes
            if r.get_title() == remindme_t
try:
except ImportError:
try:
    logging.getLogger("requests").setLevel(logging.WARNING)
except ImportError:
    requests = None
try:
except ImportError:
    redis = None
class BrokerBase(object):
    def __init__(self, broker_url, *args, **kwargs):
        purl = urlparse(broker_url)
        self.host = purl.hostname
        self.port = purl.port
        self.vhost = purl.path[1:]
        username = purl.username
        password = purl.password
        self.username = unquote(username) if username else username
        self.password = unquote(password) if password else password
    def queues(self, names):
        raise NotImplementedError
class RabbitMQ(BrokerBase):
    def __init__(self, broker_url, broker_api_url):
        super(RabbitMQ, self).__init__(broker_url)
        self.host = self.host or 'localhost'
        self.port = int(self.port or 5672)
        self.vhost = quote(self.vhost, '') or '/'
        self.username = self.username or 'guest'
        self.password = self.pa

        self._broker_api_url = broker_api_url
        if not requests:
            raise ImportError("'python-requests' library is required")
    def queues(self, names):
        if not self._broker_api_url.endswith('/'):
            self._broker_api_url += '/'
        url = urljoin(self._broker_api_url, 'queues/' + self.vhost)
        api_url = urlparse(self._broker_api_url)
        username = unquote(api_url.username or '') or self.username
        password = unquote(api_url.password or '') or self.password
        auth = requests.auth.HTTPBasicAuth(username, password)
        r = requests.get(url, auth=auth)
        if r.status_code == 200:
            try:
                info = r.json()
            except TypeError:
                info = r.json
            return [x for x in info if x['name'] in names]
        else:
            r.raise_for_status()
class Redis(BrokerBase):
    def __init__(self, broker_url, *args, **kwargs):
        super(Redis, self).__init__(broker_url)
      

        self.port = self.port or 6379
        self.vhost = self._prepare_virtual_host(self.vhost)
        if not redis:
            raise ImportError('redis library is required')
        self._redis = redis.Redis(host=self.host, port=self.port,
                                  db=self.vhost, password=self.password)
    def queues(self, names):
        return [dict(name=x, messages=self._redis.llen(x)) for x in names]
    def _prepare_virtual_host(self, vhost):
        if not isinstance(vhost, numbers.Integral):
            if not vhost or vhost == '/':
                vhost = 0
            elif vhost.startswith('/'):
                vhost = vhost[1:]
            try:
                vhost = int(vhost)
            except ValueError:
                raise ValueError(
                    'Database is int between 0 and limit - 1, not {0}'.format(
                        vhost,
                    ))
        return vhost
class Broker(object):
    def __new__(cls, broker_url, *args, **kwar
__version__ = '''0.0.01'''
__sub_version__ = '''20050819183526'''
__copyright__ = '''(c) Alex A. Naanou 2003'''
class DispatchError(Exception):
	pass
class AbstractDispatch(object):
	'''
	'''
	pass
class BasicDispatch(AbstractDispatch):
	'''
	'''
	__targets__ = None
	def resolve(self, marker):
		'''
		'''
		try:
			return self.__targets__[marker]
		except KeyError:
			raise DispatchError, 'marker "%s" is not present in the targets list.' % marker
	def addrule(self, marker, target):
		'''
		'''
		if hasattr(self, '__targets__') and self.__targets__ != None:
			self.__targets__[marker] = target
		else:
			self.__targets__ = {marker: target}
	def delrule(self, marker):
		'''
		'''
		if hasattr(self, '__targets__') and self.__targets__ != None and marker in self.__targets__:
			del self.__targets__[marker]
		else:
			raise DispatchError, 'no rule defined for marker %s.' % marker
	def clearrules(self):
		'''
		'''
		del self.__targets__
	def getrules(self):
		'''
		'''
		return self.__targe
def pin_mappers(mapper):
    mapper.connect('/pin/list',
                    controller=PinController(),
                    action='list',
                    conditions={'method': ['GET']})
    mapper.connect('/pin/list/{id}',
                    controller=PinController(),
                    action='list_by_catalog_id',
                    conditions={'method': ['GET']})
    mapper.connect('/pin/{id}',
                    controller=PinController(),
                    action='get',
                    conditions={'method': ['GET']})
    mapper.connect('/pin/user/{id}',
                    controller=PinController(),
                    action='list_by_user',
                    conditions={'method': ['GET']})
    mapper.connect('/pin/search/',
                    controller=PinController(),
                    action='search',
                    conditions={'method': ['POST']})
    mapper.connect('/pin/user/{id}/catalog/{catalog_id}',
                    controller=PinController(
def user_mappers(mapper):
    mapper.connect('/user/token',
                   controller=UserController(),
                   action='token',
                   conditions={'method': ['POST']})
    mapper.connect('/user/token/{token}',
                   controller=UserController(),
                   action='get_user_from_token',
                   conditions={'method': ['GET']})
    mapper.connect('/user/list',
                    controller=UserController(),
                    action='list',
                    conditions={'method': ['GET']})
    mapper.connect('/user/create',
                    controller=UserController(),
                    action='create',
                    conditions={'method': ['POST']})
    mapper.connect('/user/{id}/update',
                    controller=UserController(),
                    action='update',
                    conditions={'method': ['PUT']})
    mapper.connect('/user/{id}/profile',
                    controller=UserController(),
    

                    conditions={'method': ['GET']})
    mapper.connect('/user/search/{name}',
                    controller=UserController(),
                    action='search',
                    conditions={'method': ['GET']})
    mapper.connect('/user/{id}/delete',
                    controller=UserController(),
                    action='delete',
                    conditions={'method': ['DELETE']})
    mapper.connect('/user/validate/{validate_code}',
                    controller=UserController(),
                    action='validate_email',
                    conditions={'method': ['GET']})
    mapper.connect('/user/check_email/{email}',
                    controller=UserController(),
                    action='check_email',
                    conditions={'method': ['GET']})
    mapper.connect('/user/check_username/{username}',
                    controller=UserController(),
                    action='check_username',
                    conditions={'method': ['GET'
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'])
    map.minimization = False
    map.explicit = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.connect('mapping0','/',
		controller='mainController', action='index')
    map.connect('mapping2','/message/:msg',
		controller='mainController', action='message',
		msg='')
    map.connect('mapping3','/auth',
        controller='mainController', action='auth')
    map.connect('mapping6','/login',
		controller='mainController', action='login')
    map.connect('mapping6','/logout',
		controller='main
client = None
log = logging.getLogger(__name__)
_ee = pyee.EventEmitter()
def on(event, f=None):
    if client:
        log.debug('Subscribing to %s' % event)
        subscribe(event)
    return _ee.on(event, f)
def emit(event, msg=None):
    if client:
        publish(event, msg)
    return _ee.emit(event, msg)
def init(brokerHost, brokerPort=1883, baseTopic='alfred', clientId=None, start=True):
    """ Configure the connection to the mqtt broker """
    print('Coooool')
    return
    global client
    print('Coooool')
    client = mosquitto.Mosquitto(clientId)
    print(client)
    client.connected = False
    client.baseTopic = baseTopic
    client.on_message = _on_message
    client.on_connect = _on_connect
    client.on_disconnect = _on_disconnect
    client.on_subscribe = _on_subscribe
    if start:
        start_mqtt(brokerHost, brokerPort)
def stop():
    client.loop_stop()
    client.disconnect()
    client.connected = False
    log.debug("%s disconnected from broker (%s:%d)"

              (client._client_id or '', client._host, client._port))
def start_mqtt(brokerHost, brokerPort):
    """ Start the thread to handle mqtt messages """
    try:
        client.connect(brokerHost, brokerPort)
        client.connected = True
        client.loop_start()
    except Exception as E:
        log.exception("Cannot connect: %s " % E)
def _on_message(mosq, userData, msg):
    _ee.emit(msg.topic.replace(client.baseTopic+'/', ''), msg.payload)
def _on_connect(mosq, userData, rc):
    if rc == 0:
        log.debug("%s connected to broker (%s:%d)" % (
            client._client_id or '', client._host, client._port))
    else:
        log.error("Cannot connect: %s" % rc)
def _on_disconnect(mosq, userData, rc):
    log.warn("%s disconnected from broker: %s" %
             (client._client_id or '', rc))
def _on_subscribe(mosq, userData, mid, granted_qos):
    pass
def subscribe(topic):
    if client.connected:
        return client.subscribe('/'.join([client.baseTopic, topic
class VirtualController(VirtualDevice):
    _virtual_device_type = VirtualDevice.VIRTUAL_DEV_CONTROLLER
    CONTROLLER_TYPE_IDE             = "ide"
    CONTROLLER_TYPE_FDC             = "fdc"
    CONTROLLER_TYPE_SCSI            = "scsi"
    CONTROLLER_TYPE_SATA            = "sata"
    CONTROLLER_TYPE_VIRTIOSERIAL    = "virtio-serial"
    CONTROLLER_TYPE_USB             = "usb"
    CONTROLLER_TYPE_PCI             = "pci"
    CONTROLLER_TYPE_CCID            = "ccid"
    CONTROLLER_TYPES = [CONTROLLER_TYPE_IDE, CONTROLLER_TYPE_FDC,
                        CONTROLLER_TYPE_SCSI, CONTROLLER_TYPE_SATA,
                        CONTROLLER_TYPE_VIRTIOSERIAL, CONTROLLER_TYPE_USB,
                        CONTROLLER_TYPE_PCI, CONTROLLER_TYPE_CCID]
    @staticmethod
    def pretty_type(ctype):
        pretty_mappings = {
            VirtualController.CONTROLLER_TYPE_IDE           : "IDE",
            VirtualController.CONTROLLER_TYPE_FDC           : "Floppy",
            VirtualController.CONTROLLER

            VirtualController.CONTROLLER_TYPE_SATA          : "SATA",
            VirtualController.CONTROLLER_TYPE_VIRTIOSERIAL  : "Virtio Serial",
            VirtualController.CONTROLLER_TYPE_USB           : "USB",
            VirtualController.CONTROLLER_TYPE_PCI           : "PCI",
            VirtualController.CONTROLLER_TYPE_CCID          : "CCID",
       }
        if ctype not in pretty_mappings:
            return ctype
        return pretty_mappings[ctype]
    @staticmethod
    def get_class_for_type(ctype):
        if ctype not in VirtualController.CONTROLLER_TYPES:
            raise ValueError("Unknown controller type '%s'" % ctype)
        if ctype == VirtualController.CONTROLLER_TYPE_IDE:
            return VirtualControllerIDE
        elif ctype == VirtualController.CONTROLLER_TYPE_FDC:
            return VirtualControllerFDC
        elif ctype == VirtualController.CONTROLLER_TYPE_SCSI:
            return VirtualControllerSCSI
        elif ctype == VirtualController.CONT

            return VirtualControllerSATA
        elif ctype == VirtualController.CONTROLLER_TYPE_VIRTIOSERIAL:
            return VirtualControllerVirtioSerial
        elif ctype == VirtualController.CONTROLLER_TYPE_USB:
            return VirtualControllerUSB
    _controller_type = None
    def __init__(self, conn, parsexml=None, parsexmlnode=None, caps=None,
                 model=None):
        VirtualDevice.__init__(self, conn,
                                             parsexml, parsexmlnode, caps)
        self._index = 0
        self._ports = None
        self._vectors = None
        self._model = None
        self._master = VirtualDeviceMaster(conn,
                                           parsexml=parsexml,
                                           parsexmlnode=parsexmlnode,
                                           caps=caps)
        if self._is_parse():
            return
        self.model = model
    def get_type(self):
        return self._controller_type
    type =
"""
    game.commands.menu
    ~~~~~~~~~~~~~~~~~~
    Entry point, handles dispatch for all game commands received and
    pre-processed by the Eval.evaluate listener
    :copyright: (c) 2012 by Mek
    :license: BSD, see LICENSE for more details.
"""
    actions, channels
COMMANDS = {"quit": lambda controller, opt, args: \
                controller.transport.loseConnection(),
            }
NOP = lambda controller, opt, args: None
CMDS = [(COMMANDS.keys(), lambda controller, opt, args: \
             COMMANDS.get(opt, NOP)(controller, opt, args)),
        (actions.ACTIONS, lambda controller, opt, args: \
             actions.action(controller, opt, args)),
        (actions.OBSERVE, lambda controller, opt, args: \
             actions.observe(controller, opt)),
        (channels.CHANNELS.keys(), lambda controller, opt, args: \
             channels.channel(controller, opt, args)),
        (senses.SENSES.keys(), lambda controller, opt, args: \
             senses.sense(controller, opt, 

        (communication.COMMUNICATION.keys(), lambda controller, opt, args: \
             communication.communicate(controller, opt, args)),
        (Room.DIRECTIONS, lambda controller, opt, args: \
             movement.move(controller, opt, args)),
        ]
def login(controller, name):
    """Login the user so long as their name isn't currently active. In
    the future, this will support character accounts and will have to
    validate against a password if the user has a profile within some db
    """
    name = name.strip().lower()
    if not controller.players.has_key(name):
        controller.character = Character(name.lower())
        controller.players[name] = controller
        controller.character.inventory.add(Item(0, 'Random robes'))
        controller.character.inventory.add(Item(1, 'staff'))
        controller.send("You are now known as %s" % name)
        controller.broadcast("\n{} appears from somewhere or " \
                                 "another looking somewha
readline.parse_and_bind('bind ^I rl_complete')
WORKERS = 3
TIMEOUT = 5
class BrokerMonkey(object):
    def __init__(self, broker_q):
        self.broker_q = broker_q
    def delay(self, tgt, msg_type, delay):
        self.broker_q.put(('delay', tgt, msg_type, delay))
def broker_register(manager, broker_q, pid):
    inbox = manager.Queue()
    broker_q.put(('register', pid, inbox))
    return inbox
def broker_send(broker_q, src, dst, msg):
    broker_q.put(('send', src, dst, msg))
def broker_init():
    q = Queue()
    p = Process(target=broker, args=((q,)))
    p.start()
    return p, q
def _broker_register(queues, pid, queue):
    queues[pid] = queue
def _broker_send(queues, src, dst, msg):
    queues[dst].put((src, msg), False)
def _broker_set_delay(delays, tgt, msg_type, delay):
    if delay <= 0:
        try:
            del delays[(tgt, msg_type)]
        except KeyError:
            pass
    else:
        delays[(tgt, msg_type)] = delay
def _broker_maybe_send(queues, delays, dela

    msg_type = payload[0]
    try:
        delay = delays[(dst, msg_type)]
        send_time = time.time() + (delay / 1000.0)
        bisect.insort(delayed, (send_time, src, dst, payload))
    except KeyError:
        _broker_send(queues, src, dst, payload)
def _broker_maybe_send_delayed(queues, delayed):
    now = time.time()
    for msg in delayed:
        send_time, src, dst, payload = msg
        if now >= send_time:
            _broker_send(queues, src, dst, payload)
            delayed.pop(0)
        else:
            break
def broker(inbox):
    queues = {}
    delays = {}
    delayed = []
    while True:
        _broker_maybe_send_delayed(queues, delayed)
        try:
            msg = inbox.get(timeout=1)
        except Empty:
            continue
        if msg[0] == 'register':
            pid = msg[1]
            queue = msg[2]
            _broker_register(queues, pid, queue)
        if msg[0] == 'send':
            src = msg[1]
            dst = msg[2]
            payload

            _broker_maybe_send(queues, delays, delayed, src, dst, payload)
        if msg[0] == 'delay':
            tgt = msg[1]
            msg_type = msg[2]
            delay = msg[3]
            _broker_set_delay(delays, tgt, msg_type, delay)
def _worker_send(broker_q, src, dst, msg):
    broker_q.put(('send', src, dst, msg), False)
def receive(q):
    try:
        return q.get(timeout=TIMEOUT)
    except Empty:
        return None, None
def maybe_receive_msg(pid, q, debug=None):
    sender_pid, msg = receive(q)
    if msg:
        output = '{0} received message from {1}: {2}'.format(
            pid,
            sender_pid,
            msg
        )
        if debug:
            debug.put(output)
        return sender_pid, msg
    else:
        return None, None
def worker(pid, queue, broker_q, debug=None):
    state = {}
    peers = []
    while True:
        src_pid, msg = maybe_receive_msg(pid, queue, debug)
        if not msg:
            continue
        elif msg[0] == 'send
class SaveGameObject: pass
class Game:
    def __init__(self):
        self.basedir = os.path.dirname(sys.modules[self.__module__].__file__)
        self.open_save_game()
        items.init(self.basedir)
        self.name = "Renegade game"
        self.save_data = SaveGameObject()
        self.save_data.map = None
        try:
          self.load()
        except:
          self.new_game()
          self.save()
        self.hud = hud.HUD(self.save_data.hero)
        core.display.set_caption(self.name)
        self.impending_actions = []
        self.inventory_screen = InventoryScreen()
    def open_save_game(self):
        try:
          os.mkdir(SAVE_GAMES_DIR)
        except:
          pass
        self.save_game = shelve.open(os.path.join(self.basedir,"save"),'c',2)
      
    def new_game(self):
        pass
    def start_new_game(self):
        self.save_data.map.dispose()
        self.save_data = SaveGameObject()
        self.new_game()
        self.save()
        self.hud.set_he

        for k in self.save_game.keys():
            del self.save_game[k]
    def load_map(self,map_name):
        """Loads a map by name.  This should always have a module.
             game.load_map('module.map') => None
             Sets game.save_data.map to specified map
             Assumes there are no submodules"""
        map = "map-%s" % map_name
        if self.save_game.has_key(map):
          self.save_data.map = self.save_game[map]
        else:
          (map_module, map_class) = map_name.split('.')
          map_module = self.__module__ + ".maps." + map_module
          exec "self.save_data.map = module.%s()" % map_class
          self.save_data.map.init()
        self.save_data.map.show()
        self.save_data.map.focus()
    def load(self):
        data = self.save_data
        save = self.save_game
        if data.map != None:
          data.map.dispose()
        map_name = save['current_map']
        data.hero = save['hero']
        data.map = save['map-%s' % map_

        data.character = save['character']
        if self.__dict__.has_key('hud'):
          self.hud.set_hero(data.hero)
        data.map.init()
        data.map.show()
        data.map.focus()
        data.map.place_character(data.character, data.character.pos)
    def save(self):
        data = self.save_data
        save = self.save_game
        map_name = data.map.__class__.__name__
        save['hero'] = data.hero
        save['character'] = data.character
        save['current_map'] = map_name
        save['map-%s' % map_name] = data.map
    def handle_event(self, event):
        self.save_data.map.handle_event(event)
    def show_inventory(self):
        self.inventory_screen.run()
    def run(self):
        self.save_data.map.focus()
        core.wm.run()
    def quit(self):
        core.wm.running = False
    def teleport(self, loc, map_name=None, dir=None):
        core.wm.impending_actions.append(lambda: self.__teleport(loc,map_name,dir))
        self.save_data.map.blur()
urlpatterns = patterns('',
	url(r'^$', views.index, name='index'),
	url(r'^register$', views.register, name='register'),
	url(r'^login/$', views.login_handler, name='login_handler'),
	url(r'^devices/$', views.devices, name='devices'),
	url(r'^devices/add/$', views.device_add, name='device_add'),
	url(r'^devices/(?P<device_id_request>\d+)/history/$', views.history, name='history'),
	url(r'^devices/manage/$', views.devices_manage, name='device_manage'),
	url(r'^devices/(?P<device_id_request>\d+)/manage/$', views.device_manager, name='device_manager'),
	url(r'^devices/(?P<device_id_request>\d+)/modify/$', views.device_modify, name='device_modify'),
	url(r'^devices/(?P<device_id_request>\d+)/command_handler/', views.send_command, name='device_command_handler'),
	url(r'^devices/gen_dev/manage', views.manage_gendev, name='manage_gendev'),
	url(r'^devices/gen_dev/change/(?P<gendev_id>\d+)/handler', views.change_gendev_handler, name='change_gendev_handler'),
	url(r'^devices/gen_dev/(?P<gendev_

	url(r'^settings/$', views.user_settings, name='user_settings'),
	url(r'^acl/$', views.acl, name='acl'),
	url(r'^acl/groups/$', views.acl_groups, name='acl_groups'),
	url(r'^acl/groups/handler$', views.acl_groups_handler, name='acl_groups_handler'),
	url(r'^acl/groups/(?P<acl_id>\d+)/manage$', views.acl_groups_manage, name='acl_groups_manage'),
	url(r'^acl/users$', views.acl_user, name='acl_user'),
	url(r'^acl/users/(?P<user_id>\d+)/kick$', views.acl_kick_user, name='acl_kick_user'),
	url(r'^acl/users/add$', views.acl_user_add, name='acl_user_add'),
	url(r'^acl/users/add/handler$', views.acl_user_add_handler, name='acl_user_add_handler'),
	url(r'^acl/users/(?P<acl_user>\d+)/manage$', views.acl_user_manage, name='acl_user_manage'), 
	url(r'^acl/users/(?P<acl_user>\d+)/history$', views.acl_user_history, name='acl_user_history'),
	url(r'^acl/users/(?P<acl_user>\d+)/manage/handler$', views.acl_user_manage_handler, name='acl_user_manage_handler'),   
	url(r'^acl/devices/$', views.acl_devic
def basic_controller():
    return Controller()
def controller_record_buffer_occupancy():
    controller = basic_controller()
    link = basic_link()
    buffer_occupancies = range(5)
    for buffer_occupancy in buffer_occupancies:
        controller.record_buffer_occupancy(link=link,
                                           buffer_occupancy=buffer_occupancy)
    recorded_buffer_occupancies = [record[1] for record in
                                   controller.buffer_occupancy[link]]
    assert (recorded_buffer_occupancies ==
            [x * OUTPUT_BUFFER_OCCUPANCY_SCALE_FACTOR for x in buffer_occupancies])
def controller_record_flow_rate():
    controller = basic_controller()
    flow = basic_flow()
    packet_sizes = range(5)
    for packet_size in packet_sizes:
        controller.record_flow_rate(flow=flow, packet_size=packet_size)
    recorded_packet_sizes = [record[1] for record in
                             controller.flow_rate[flow]]
    assert (recorded_packet_sizes ==
 

def controller_record_link_rate():
    controller = basic_controller()
    link = basic_link()
    packet_sizes = range(5)
    for packet_size in packet_sizes:
        controller.record_link_rate(link=link, packet_size=packet_size)
    recorded_packet_sizes = [record[1] for record in
                             controller.link_rate[link]]
    assert (recorded_packet_sizes ==
            [x * OUTPUT_LINK_RATE_SCALE_FACTOR for x in packet_sizes])
def controller_record_packet_delay():
    controller = basic_controller()
    flow = basic_flow()
    packet_delays = range(5)
    for packet_delay in packet_delays:
        controller.record_packet_delay(flow=flow, packet_delay=packet_delay)
    recorded_packet_delays = [record[1] for record in
                              controller.packet_delay[flow]]
    assert recorded_packet_delays == packet_delays
def controller_record_packet_loss():
    controller = basic_controller()
    link = basic_link()
    packet_losses = [None] * 5
    for _ in
urlpatterns = patterns('app.views.api',
    (r'^api/commits/count$', 'commits_count'),
    (r'^api/commits/lines$', 'commits_lines'),
    (r'^api/license$', 'license'),
    (r'^api/line-count$', 'line_count'),
    (r'^api/line-count/python$', 'line_count_python'),
    (r'^api/pep8$', 'pep8'),
    (r'^api/popularity/collaborators$', 'popularity_collaborators'),
    (r'^api/popularity/forks$', 'popularity_forks'),
    (r'^api/popularity/issues$', 'popularity_issues'),
    (r'^api/popularity/watchers$', 'popularity_watchers'),
    (r'^api/pyflakes$', 'pyflakes'),
    (r'^api/readme$', 'readme'),
    (r'^api/setup.py$', 'setup_py'),
    (r'^api/swearing$', 'swearing'),
    (r'^api/tabs-or-spaces$', 'tabs_spaces'),
    (r'^api/distribution/(?P<name>\w+)$', 'distribution'),
    (r'^api/correlate/(?P<x>\w+)/(?P<y>\w+)$', 'correlate'),
    (r'^api/autocomplete$', 'autocomplete'),
urlpatterns += patterns('app.views.app',
    (r'^about$', 'about'),
    (r'^contact$', 'contact'),
    (r'^explore$
'''
    add a repository to a given composite repository
'''
class PublishRepository:
    
    def __init__(self, name, source_path, dest_path,repository_name,stats_uri,feature_ids):
        self._name = name
        self._source_path = source_path
        self._dest_path = dest_path
        self._repository_name = repository_name
        self._stats_uri = stats_uri
        self._feature_ids = feature_ids
        
    def check(self):
        if not repositoryutils.is_repository(self._source_path):
            raise Exception("source {0} is not a  repository".format(self._source_path))
        
        if not repositoryutils.is_composite_repository(self._dest_path):
            raise Exception("destination {0} is not a composite repository".format(self._dest_path))
        
        if repositoryutils.composite_repository_contains(self._dest_path, self._repository_name):
            raise Exception("destination {0} already contains a child {1}".format(self._dest_path, self._repository_n
"""Base implementation classes.
The public-facing ``Events`` serves as the base class for an event interface;
it's public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.
"""
_registrars = util.defaultdict(list)
def _is_event_name(name):
    return not name.startswith('_') and name != 'dispatch'
class _UnpickleDispatch(object):
    """Serializable callable that re-generates an instance of
    :class:`_Dispatch` given a particular :class:`.Events` subclass.
    """
    def __call__(self, _parent_cls):
        for cls in _parent_cls.__mro__:
            if 'dispatch' in cls.__dict__:
                return cls.__dict__['dispatch'].dispatch_cls(_parent_cls)
        else:
            raise AttributeError("No class with a 'disp

class _Dispatch(object):
    """Mirror the event listening definitions of an Events class with
    listener collections.
    Classes which define a "dispatch" member will return a
    non-instantiated :class:`._Dispatch` subclass when the member
    is accessed at the class level.  When the "dispatch" member is
    accessed at the instance level of its owner, an instance
    of the :class:`._Dispatch` class is returned.
    A :class:`._Dispatch` class is generated for each :class:`.Events`
    class defined, by the :func:`._create_dispatcher_class` function.
    The original :class:`.Events` classes remain untouched.
    This decouples the construction of :class:`.Events` subclasses from
    the implementation used by the event internals, and allows
    inspecting tools like Sphinx to work in an unsurprising
    way against the public API.
    """
    _events = None
    """reference the :class:`.Events` class which this
        :class:`._Dispatch` is created for."""
    def __init__(s

        self._parent_cls = _parent_cls
    @util.classproperty
    def _listen(cls):
        return cls._events._listen
    def _join(self, other):
        """Create a 'join' of this :class:`._Dispatch` and another.
        This new dispatcher will dispatch events to both
        :class:`._Dispatch` objects.
        """
        if '_joined_dispatch_cls' not in self.__class__.__dict__:
            cls = type(
                    "Joined%s" % self.__class__.__name__,
                    (_JoinedDispatcher, self.__class__), {}
                )
            for ls in _event_descriptors(self):
                setattr(cls, ls.name, _JoinedDispatchDescriptor(ls.name))
            self.__class__._joined_dispatch_cls = cls
        return self._joined_dispatch_cls(self, other)
    def __reduce__(self):
        return _UnpickleDispatch(), (self._parent_cls, )
    def _update(self, other, only_propagate=True):
        """Populate from the listeners in another :class:`_Dispatch`
            object
__revision__ = "__FILE__ __REVISION__ __DATE__ __DEVELOPER__"
if sys.platform == 'win32':
    _exe = '.exe'
else:
    _exe = ''
test = TestSCons.TestSCons()
test.subdir('repository', 'work')
workpath_repository = test.workpath('repository')
repository_foo = test.workpath('repository', 'foo' + _exe)
work_foo = test.workpath('work', 'foo' + _exe)
test.write(['repository', 'SConstruct'], """
Repository(r'%s')
env = Environment()
env.Program(target = 'foo', source = ['aaa.c', 'bbb.c', 'foo.c'])
""" % workpath_repository)
test.write(['repository', 'aaa.c'], r"""
void
aaa(void)
        printf("repository/aaa.c\n");
""")
test.write(['repository', 'bbb.c'], r"""
void
bbb(void)
        printf("repository/bbb.c\n");
""")
test.write(['repository', 'foo.c'], r"""
extern void aaa(void);
extern void bbb(void);
int
main(int argc, char *argv[])
        argv[argc++] = "--";
        aaa();
        bbb();
        printf("repository/foo.c\n");
        exit (0);
""")
test.run(chdir = 'repository', argument
"""This module provides container classes and interfaces
for inserting data into the database.
Created on Jul 4, 2013
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class GroupBroker(BrokerBase):
  """This is the interface between python an the database"""
  def get_broker_class(self):
    """
    overrides BrokerBase.get_broker_class
    """
    return Group
  def get_by_name(self, name):
    try:
      result = self.session.query(Group).filter(Group.name == name).one()
      return result
    except sqlalchemy.orm.exc.NoResultFound:
      raise NothingFoundException('Nothing found with name :{0}'.format(name))
    except sqlalchemy.orm.exc.MultipleResultsFound:
      raise TooManyResultsFoundException('Too many results found for name :{0}'.format(name))
    except sqlalchemy.exc.SQLAlchemyError as error:
      raise BrokerException(error)
  def get_all_notifiable_groups(self
"""
(Description)
Created on Feb 21, 2014
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class MailTemplateBroker(BrokerBase):
  """
  Mail template broker
  """
  ACTIVATION = 'Activation'
  EVENT_PUBLICATION = 'Publication'
  EVENT_UPDATE = 'Update'
  PROPOSAL = 'Proposal'
  def __init__(self, session):
    BrokerBase.__init__(self, session)
  def get_broker_class(self):
    return MailTemplate
  def __get_template(self, identifier):
    """
    Returns the object by the given identifier
    Note: raises a NothingFoundException or a TooManyResultsFound Exception
    :returns: MailTemplate
    """
    try:
      result = self.session.query(MailTemplate).filter(MailTemplate.name == identifier).one()
    except NoResultFound:
      raise NothingFoundException(u'Nothing found for function_id :{0}'.format(identifier))
    except MultipleResultsFound:
      raise TooManyResultsFou
gControllerMan = False
def GetControllerManager():
	global gControllerMan
	if gControllerMan == False:
		gControllerMan = ControllerManager()
	return gControllerMan
class ControllerManager:
	modules = {}
	controllers = {}
	def __init__(self):
		self.ImportAvailableController()
	def ImportAvailableController(self):
		controllersPath = Settings.Settings["PATH"] + "/Controllers"
		sys.path.append(controllersPath)
		for controllerName in os.listdir(controllersPath):
			if controllerName[0] != '.' and controllerName.endswith(".py"):
				controllerName = controllerName[:controllerName.find(".")]
				print "Loaded controller: " + controllerName
		print ""
	def StartConfiguredControllers(self):
		configPath = Settings.Settings["PATH"] + "/Config"
		sys.path.append(configPath)
		for configFile in os.listdir(configPath):
			if configFile[0] != '.' and configFile.endswith(".controller"):
				
				name = configFile[:configFile.find(".")]
				settingsFile = open(configPath + "/" + configFile, 'r')

def dbLogin():
    """
    dbLogin: logs into database for stock market program
    return: sql connection object or failure boolean
    """
    try:
        return psycopg2.connect("dbname=StockMarket user=postgres password=mathmatician3")
    except:
        return False
def createTables(connection):
    """
    createTables: creates tables in database connection for stockmarket
    connection - sql connection object
    return: boolean success or fail
    """
    DBcurr = connection.cursor()
    success = True
    try:
        DBcurr.execute("CREATE TABLE StockInfo (Symbol varchar, EndDate date, Usable boolean);")
        DBcurr.execute("CREATE UNIQUE INDEX SymUIndex ON StockInfo (Symbol);")
        DBcurr.execute("CREATE INDEX EndIndex ON StockInfo (EndDate);")
        DBcurr.execute("CREATE TABLE StockPoints (Symbol varchar, Date date, Open float, High float, Low float, Close float, Volume float, AdjClose float);")
        DBcurr.execute("CREATE INDEX DateIndex ON StockPoints (Dat

        DBcurr.execute("CREATE INDEX SymIndex ON StockPoints (Symbol);")
        connection.commit()
    except:
        connection.rollback()
        success = False
    DBcurr.close()
    return success
def dropTables(connection):
    """
    dropTables: drops all tables that createTables creates
    connection - sql connection object
    return: boolean success or fail
    """
    DBcurr = connection.cursor()
    success = True
    try:
        DBcurr.execute("DROP TABLE StockInfo;")
        DBcurr.execute("DROP TABLE StockPoints;")
        connection.commit()
    except:
        connection.rollback()
        success = False
    DBcurr.close()
    return success
def createBrokerTables(connection):
    """
    createBrokerTable: creates table to keep track of broker info
    connection - database connection object
    return: boolean of success
    """
    DBcurr = connection.cursor()
    try:
        print("1")
        DBcurr.execute("CREATE TABLE StockBroker (Name varchar, Bank fl

        DBcurr.execute("CREATE TABLE OwnedStocks (Broker varchar, Symbol varchar, Shares integer);")
        print("2")
        DBcurr.execute("CREATE INDEX BrokerIndex ON OwnedStocks (Broker);")
        DBcurr.execute("CREATE TABLE TransLog (Date date, Broker varchar, Symbol varchar, Shares integer, Price float, BuySell varchar);")
        print("3")
        DBcurr.execute("CREATE INDEX BrokerLogIndex ON TransLog (Broker);")
        connection.commit()
    except:
        connection.rollback()
        return False
    DBcurr.close()
    return True
def dropBrokerTables(connection):
    """
    dropBrokerTables: drop broker tables
    connection - database connection object
    return: boolean success
    """
    DBcurr = connection.cursor()
    try:
        DBcurr.execute("DROP TABLE StockBroker;")
        DBcurr.execute("DROP TABLE OwnedStocks;")
        DBcurr.execute("DROP TABLE TransLog;")
        connection.commit()
    except:
        connection.rollback()
        return False

"""Base implementation classes.
The public-facing ``Events`` serves as the base class for an event interface;
its public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.
"""
    _EmptyListener, _DispatchDescriptor
_registrars = util.defaultdict(list)
def _is_event_name(name):
    return not name.startswith('_') and name != 'dispatch'
class _UnpickleDispatch(object):
    """Serializable callable that re-generates an instance of
    :class:`_Dispatch` given a particular :class:`.Events` subclass.
    """
    def __call__(self, _parent_cls):
        for cls in _parent_cls.__mro__:
            if 'dispatch' in cls.__dict__:
                return cls.__dict__['dispatch'].dispatch_cls(_parent_cls)
        else:
            rais

class _Dispatch(object):
    """Mirror the event listening definitions of an Events class with
    listener collections.
    Classes which define a "dispatch" member will return a
    non-instantiated :class:`._Dispatch` subclass when the member
    is accessed at the class level.  When the "dispatch" member is
    accessed at the instance level of its owner, an instance
    of the :class:`._Dispatch` class is returned.
    A :class:`._Dispatch` class is generated for each :class:`.Events`
    class defined, by the :func:`._create_dispatcher_class` function.
    The original :class:`.Events` classes remain untouched.
    This decouples the construction of :class:`.Events` subclasses from
    the implementation used by the event internals, and allows
    inspecting tools like Sphinx to work in an unsurprising
    way against the public API.
    """
    _events = None
    """reference the :class:`.Events` class which this
        :class:`._Dispatch` is created for."""
    def __init__(s

        self._parent_cls = _parent_cls
    @util.classproperty
    def _listen(cls):
        return cls._events._listen
    def _join(self, other):
        """Create a 'join' of this :class:`._Dispatch` and another.
        This new dispatcher will dispatch events to both
        :class:`._Dispatch` objects.
        """
        if '_joined_dispatch_cls' not in self.__class__.__dict__:
            cls = type(
                "Joined%s" % self.__class__.__name__,
                (_JoinedDispatcher, self.__class__), {}
            )
            for ls in _event_descriptors(self):
                setattr(cls, ls.name, _JoinedDispatchDescriptor(ls.name))
            self.__class__._joined_dispatch_cls = cls
        return self._joined_dispatch_cls(self, other)
    def __reduce__(self):
        return _UnpickleDispatch(), (self._parent_cls, )
    def _update(self, other, only_propagate=True):
        """Populate from the listeners in another :class:`_Dispatch`
            object."""
       
serialPort = "/dev/ttyACM0"
controller = Controller(serialPort, 9600, 1)
def setDistance(maximum, minimum):
    controller.getSensor(2)
    current = controller.currentSensor
    if current < minimum:
        print("Going Toward!" + str(current))
        while current < minimum:
            print("Distance: " + str(current))
            controller.getSensor(2)
            current = controller.currentSensor
            controller.writeSteerPacket('S', 0, 0, 0, 0)
            controller.writeDrivePacket('D', 130, 130, 'F', 'F')
            
            
    elif current > maximum:
        print("Going Away!" + str(current))
        while current > maximum:
            print("Distance: " + str(current))
            controller.getSensor(2)
            current = controller.currentSensor
            controller.writeSteerPacket('S', 0, 0, 0, 0)
            controller.writeDrivePacket('D', 130, 130, 'R', 'R')
            
    
    controller.writeDrivePacket('D', 0, 0, 'F', 'F')
    controller
log = logging.getLogger(__name__)
class InstallTestRepositories( InstallTestRepository ):
    """Abstract test case that installs a predefined list of repositories."""
    def do_install( self, repository_dict ):
        self.logout()
        admin_email = 'test@bx.psu.edu'
        admin_username = 'test'
        self.login( email=admin_email, username=admin_username )
        admin_user = test_db_util.get_user( admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        test_db_util.get_private_role( admin_user )
        self.install_repository( repository_dict )
def generate_install_method( repository_dict=None ):
    """Generate abstract test cases for the defined list of repositories."""
    def make_install_method( repository_dict ):
        def test_install_repository( self ):
            self.do_install( repository_dict )
        return test_install_repository
    if repository_dict is None:
        return

def steps_nav(user, selected, bid=-1):
    
    all_steps = [
            ['Load Roster', 
                '',  
                    reverse('tourney:manage_roster'),
                        'staff',
                            'manage_roster',
            ],
            ['New Bracket', 
                '',  
                    reverse('tourney:new_bracket'),
                        'staff',
                            'new_bracket',
            ],
            ['Choose Bracket', 
                '',  
                    reverse('tourney:choose_bracket'),
                        'staff',
                            'choose_bracket',
            ],
            ['Clone Bracket', 
                '',  
                    reverse('tourney:bracket:clone_bracket', kwargs={'bracket': bid}),
                        'staff',
                            'clone_bracket',
            ],
            ['Manage Bracket', 
                '',  
                    reverse('tourney:bracket:manage_brac

                        'staff',
                            'manage_bracket',
            ],
            ['Manage Competitors', 
                '',  
                    reverse('tourney:bracket:manage_competitors', kwargs={'bracket': bid}),
                        'staff',
                            'manage_competitors',
            ],
            ['Manage Judges', 
                '',  
                    reverse('tourney:bracket:manage_judges', kwargs={'bracket': bid}),
                        'staff',
                            'manage_judges',
            ],
            ['Review Bracket', 
                '',  
                    reverse('tourney:bracket:review_bracket', kwargs={'bracket': bid}),
                        'staff',
                            'review_bracket',
            ],
        ]
    steps_nav = []
    for nn in all_steps:
        if nn[4] == selected:
            nn[1] = 'current'
        if nn[3] == 'any':
            steps_nav.append(nn)
        elif n
urlpatterns = patterns('',
	(r'^isinstalled/(?P<package>\w{1,50})/$', 'api.views.isinstalled'),
	(r'^isrunning/(?P<package>\w{1,50})/$', 'api.views.isrunning'),
	(r'^startapp/(?P<package>\w{1,50})/$', 'api.views.startapp'),
	(r'^stopapp/(?P<package>\w{1,50})/$', 'api.views.stopapp'),
	(r'^getappconfig/(?P<package>\w{1,50})/$', 'api.views.getappconfig'),
	(r'^setappconfig/(?P<package>\w{1,50})/$', 'api.views.setappconfig'),
	(r'^doupdateos$', 'api.views.doupdateos'),
	(r'^listupgrades$', 'api.views.listupgrades'),
	(r'^checkforupdates$', 'api.views.checkforupdates'),
	(r'^list_installed$', 'api.views.list_installed'),
	(r'^rebootnow$', 'api.views.rebootnow'),
	(r'^maintenance$', 'api.views.maintenance'),
	(r'^fileapi$', 'api.views.fileapi'),
	(r'^diskuse$', 'api.views.diskuse'),
	(r'^loadavg$', 'api.views.loadavg'),
	(r'^entropy$', 'api.views.entropy'),
	(r'^uptime$', 'api.views.uptime'),
	(r'^memory_total$', 'api.views.memory_total'),
	(r'^memory_free$', 'api.views.memory_free'),
	(r'^
log = logging.getLogger(__name__)
try:
    version = pylons.__version__.split('.')
except AttributeError:
    version = ['0', '6']
def admin_map(map, controller, url='/admin'):
    """connect the admin controller `cls` under the given `url`"""
    log.info('connecting %s to %s' % (url, controller))
    if version > ['0', '7']:
        map.connect('%s' % url, controller=controller, action='index')
        map.connect('%s/' % url, controller=controller, action='index')
        map.connect('%s/static_contents/{id}' % url, controller=controller, action='static')
        map.connect('%s/{modelname}' % url, controller=controller, action='list')
        map.connect('%s/{modelname}/{action}' % url, controller=controller)
        map.connect('%s/{modelname}/{action}/{id}' % url, controller=controller)
    else:
        map.connect('%s' % url, controller=controller, action='index')
        map.connect('%s/' % url, controller=controller, action='index')
        map.connect('%s/static_contents/:id
'''
Map URL patterns to controllers
Entries should be in the following format:
{ 'path': r'[URL pattern]',
  'controller': [controller function],
  'method': '[HTTP method in capital letters]'
'''
urls = [
  { 'path': r'^/?$',
    'controller': controllers.choose_game,
    'method': 'GET'
  },
  { 'path': r'^/one/?$',
    'controller': controllers.play_one,
    'method': 'GET'
  },
  { 'path': r'^/two/?$',
    'controller': controllers.play_two,
    'method': 'GET'
  },
  { 'path': r'^/remote/?$',
    'controller': controllers.play_remote,
    'method': 'GET'
  },
  {
    'path': r'^/check_winner/?$',
    'controller': controllers.check_winner,
    'method': 'PUT'
  },
  {
    'path': r'^/find_best_move/(?P<marker>\w)/?$',
    'controller': controllers.find_best_move,
    'method': 'PUT'
  },
  {
    'path': r'^/is_alive/?$',
    'controller': controllers.is_alive,
    'method': 'GET'
  },
  {
    'path': r'^/player/?$',
    'controller': controllers.get_players,
    'method': 'GET'
  

  {
    'path': r'^/player/(?P<player>[\w\s]+)/?$',
    'controller': controllers.add_player,
    'method': 'PUT'
  },
  {
    'path': r'^/add_player/(?P<player>[\w\s]+)/?$',
    'controller': controllers.add_player,
    'method': 'GET'
  },
  {
    'path': r'^/flush_players/?$',
    'controller': controllers.flush_players,
    'method': 'GET'
  },
  {
    'path': r'^/find_opponents/(?P<player>[\w\s]+)/?$',
    'controller': controllers.find_opponents,
    'method': 'GET'
  },
  {
    'path': r'^/game/?$',
    'controller': controllers.get_games,
    'method': 'GET'
  },
  {
    'path': r'^/flush_games/?$',
    'controller': controllers.flush_games,
    'method': 'GET'
  },
  {
    'path': r'^/game/find/(?P<player>[\w\s]+)/?$',
    'controller': controllers.find_game,
    'method': 'GET'
  },
  {
    'path': r'^/game/start/(?P<player1>[\w\s]+)/(?P<player2>[\w\s]+)/?$',
    'controller': controllers.start_game,
    'method': 'PUT'
  },
  {
    'path': r'^/game/turn/(?P<game_id>[\w-]+)/
urlpatterns = patterns('blog.views',
    url(r'popular/$', 'blog_popular', name='blog_popular'),
    url(r'create/$', 'blog_create', name='blog_create'),
    url(r'create/from/email/$', 'blog_create_by_email', name='blog_create_by_email'),
    url(r'manage/$', 'blog_manage', {'section':''}, name='blog_manage'),
    url(r'manage/published/$', 'blog_manage', {'section':'published'}, name='blog_manage_published'),
    url(r'manage/draft/$', 'blog_manage', {'section':'draft'}, name='blog_manage_draft'),
    url(r'manage/trash/$', 'blog_manage', {'section':'trash'}, name='blog_manage_trash'),
    url(r'manage/bulk/$', 'blog_manage_bulk', name='blog_manage_bulk'),
    url(r'(?P<blog_id>\d+)/$', 'blog_view', name='blog_view'),
    url(r'(?P<blog_id>\d+)/view/$', 'blog_view'),
    url(r'(?P<blog_id>\d+)/edit/$', 'blog_edit', name='blog_edit'),
    url(r'(?P<blog_id>\d+)/love/$', 'blog_love', name='blog_love'),
    url(r'(?P<blog_id>\d+)/unlove/$', 'blog_unlove', name='blog_unlove'),
    url(r'
sys.path.insert(0, os.path.abspath("../"))
class TestClusterDocLoadParse(unittest.TestCase):
    def setUp(self):
        self.clusterdoc = open("test_ec2_clusterdoc.xml").read()
        self.context_uri = "http://example.com/"
        self.context_body = {
            'brokerUri':'test_broker_uri', 
            'contextId':'test_context_id', 
            'secret':'test_secret'
        }
    def test_loadparse(self):
        nimbuscd = NimbusClusterDocument(self.clusterdoc)
        self.assertEqual(len(nimbuscd.members), 2)
        self.assertEqual(nimbuscd.members[0].quantity, 1)
        self.assertEqual(nimbuscd.members[1].quantity, 2)
    def test_build_specs(self):
        nimbuscd = NimbusClusterDocument(self.clusterdoc)
        ctx = ContextResource(self.context_uri, self.context_body)
        specs = nimbuscd.build_specs(ctx)
        self.assertEqual(len(specs), 2)
        self.assertEqual(specs[0].count, 1)
        self.assertEqual(specs[1].count, 2)
        self.assertEqual(sp

        for spec in specs:
            print "spec:"
            print spec.userdata
    def test_create_contact_element(self):
        ctx = ContextResource(self.context_uri, self.context_body)
        contact = nimboss.nimbus.create_contact_element(ctx)
        for child in contact.getiterator():
            self.assertTrue(str(child.tag)[0] == '{')
class TestEC2Cluster(unittest.TestCase):
    def setUp(self):
        self.clusterdoc = open("test_ec2_clusterdoc.xml").read()
        self.context_uri = "http://example.com/"
        self.context_body = {
            'broker_uri':'test_broker_uri', 
            'context_id':'test_context_id', 
            'secret':'test_secret'
        }
        self.broker_uri = "http://example.com/"
        self.broker_key = "broker_key"
        self.broker_secret = "broker_secret"
        self.cloud_key = os.environ["AWS_KEY"]
        self.cloud_secret = os.environ["AWS_SECRET"]
    def test_start_cluster(self):
        broker_client = BrokerClient(s

        node_driver = EC2NodeDriver(self.cloud_key, self.cloud_secret)
        cluster_driver = ClusterDriver(broker_client, node_driver)
        cluster = Cluster(self.context_uri, cluster_driver)
        fake_context = ContextResource(self.context_uri, self.context_body)
        cluster.create_cluster(self.clusterdoc, context=fake_context)
class TestNimbusCluster(unittest.TestCase):
    def setUp(self):
        self.clusterdoc = open("test_nimbus_clusterdoc.xml").read()
        self.cloud_key = os.environ["NIMBUS_KEY"]
        self.cloud_secret = os.environ["NIMBUS_SECRET"]
        self.broker_uri = "https://nimbus.ci.uchicago.edu:8888/ContextBroker/ctx/"
        self.broker_key = self.cloud_key
        self.broker_secret = self.cloud_secret
    def test_start_cluster(self):
        broker_client = BrokerClient(self.broker_uri, self.broker_key, self.broker_secret)  
        node_driver = NimbusNodeDriver(self.cloud_key, self.cloud_secret)
        cluster_driver = ClusterDriver(broke
   
def runcmd(cmd):  
  try:  
    print "Executing %s" % ' '.join(cmd)  
    output = subprocess.check_output(cmd)  
    print output  
    return output  
  except:  
    print "Failed"  
    return None  
  
VBoxManage = '/usr/bin/VBoxManage'  
vboxConfBios = './vboxConfBiosWinXP.py'  
for machine in sys.argv[1:]:  
  hdpath = os.path.join('/','data','VirtualBox VMs',machine,machine+'.vdi')  
  runcmd([VBoxManage,'createhd','--filename',hdpath,'--size',str(80*1024)])  
  runcmd([VBoxManage,'createvm','--name',machine,'--ostype','WindowsXP','--register'])  
  runcmd([VBoxManage,'storageattach', machine,'--storagectl','SATA Controller','--port','0','--device','0','--type','hdd','--medium',hdpath])  
  runcmd([VBoxManage,'storagectl',machine,'--name','PIIX4','--add','ide','--controller','PIIX4'])
  runcmd([VBoxManage,'storageattach', machine,'--storagectl','PIIX4','--port','0','--device','0','--type','dvddrive','--medium','emptydrive'])
  runcmd([VBoxManage,'storageattach', machine,'-
class TestSourceView(PtahTestCase):
    def test_source(self):
        ptah.auth_service.set_userid(ptah.SUPERUSER_URI)
        request = DummyRequest()
        manage = PtahManageRoute(request)
        res = render_view_to_response(manage, request, 'source.html', False)
        self.assertIsInstance(res, HTTPFound)
        self.assertEqual(res.headers['location'], '.')
    def test_source_view(self):
        ptah.auth_service.set_userid(ptah.SUPERUSER_URI)
        request = DummyRequest(
            params = {'pkg': 'ptah.config'})
        manage = PtahManageRoute(request)
        res = render_view_to_response(manage, request, 'source.html', False)
        self.assertIn('Source: ptah/config.py', res.text)
    def test_source_view_unknown(self):
        ptah.auth_service.set_userid(ptah.SUPERUSER_URI)
        request = DummyRequest(
            params = {'pkg': 'unknown'})
        manage = PtahManageRoute(request)
        res = render_view_to_response(manage, request, 'source.html', Fa
""" URL Mapper for Snortmanager """
try:
except ImportError as e:
	print e
def initialize_routes():
    """ Maps URLs to methods and controllers.
    
    Only these URls are allowed on the network.
    """
    mapper = cherrypy.dispatch.RoutesDispatcher()
    mapper.minimization = False
    mapper.explicit = False
    mapper.append_slash = True
    
    mapper.connect('main', '/', controller = MainController(), action = 'index')
    mapper.connect('rules', '/rules/', controller = RuleController(), action = 'index')
    mapper.connect('rules', '/rules/source/', controller = RuleController(), action = 'source')
    mapper.connect('rules', '/rules/source/:id/', controller = RuleController(), action = 'source')
    mapper.connect('rules', '/rules/register/', controller = RuleController(), action = 'register_source')
    
    mapper.connect('sensor', '/sensor/', controller = SensorController(), action = 'index')
    mapper.connect('sensor', '/sensor/addsensor/', controller = SensorControll

    mapper.connect('sensor', '/sensor/save/', controller = SensorController(), action = 'save_sensor_data')
    mapper.connect('sensor', '/sensor/get/sensor/:id/', controller = SensorController(), action = 'get_sensor_data')
    mapper.connect('sensor', '/sensor/location/add/', controller = SensorController(), action = 'add_location')
    mapper.connect('sensor', '/sensor/delete/', controller = SensorController(), action = 'delete_sensor')
    mapper.connect('policy', '/policy/', controller = PolicyController(), action = 'index')
    mapper.connect('policy', '/policy/add/', controller = PolicyController(), action = 'add_policy')
    mapper.connect('policy', '/policy/save/object/', controller = PolicyController(), action = 'save_object')
    mapper.connect('policy', '/policy/edit/policy/', controller = PolicyController(), action = 'edit_policy')
    mapper.connect('policy', '/policy/edit/policy/:id/', controller = PolicyController(), action = 'edit_policy')
    mapper.connect('policy',

    mapper.connect('policy', '/policy/edit/get_object/:id/', controller = PolicyController(), action = 'get_object')
    mapper.connect('policy', '/policy/edit/object/add/', controller = PolicyController(), action = 'add_object')
    mapper.connect('policy', '/policy/delete/:id', controller = PolicyController(), action = 'delete_policy')
    mapper.connect('policy', '/policy/remove_object/', controller = PolicyController(), action = 'remove_object')
    mapper.connect('policy', '/policy/edit/new_object/:id/', controller = PolicyController(), action = 'new_object')
    mapper.connect('policy', '/policy/edit_order/', controller = PolicyController(), action = 'edit_order')
    mapper.connect('policy', '/policy/edit/choose_object/', controller = PolicyController(), action = 'choose_object')
    
    
    mapper.connect('jobs', '/jobs/', controller = JobsController(), action='index')
    mapper.connect('jobs', '/jobs/start_job/', controller = JobsController(), action='start_job')
    mappe
class DateEncoder(json.JSONEncoder):
    def default(self, obj):
        if hasattr(obj, 'isoformat'):
            return obj.isoformat()
        else:
            return json.JSONEncoder.default(self, obj)
api = Api(app)
@api.representation('application/json')
def json_date(data, code, headers=None):
    resp = app.make_response(data if type(data) is str else json.dumps(data, cls=DateEncoder))
    resp.headers.extend(headers or {})
    resp.status_code = code
    return resp
api.add_resource(submissions.SubmissionAPI,
                 '/api/submission/<string:submission_id>',
                 '/api/submission/<string:submission_id>/<string:noun>')
api.add_resource(submissions.SubmissionsAPI,
                 '/api/submissions')
api.add_resource(tags.TagsAPI,
                 '/api/tags')
api.add_resource(tags.UserTagsAPI,
                 '/api/user-tags')
api.add_resource(tags.UserTagAPI,
                 '/api/user-tag/<string:name>')
api.add_resource(tracks.TracksAPI,
             
class Drafts(object):
    def __init__(self, controller):
        self.controller = controller
        controller.events.after_dispatch += self.on_after_dispatch
        controller.events.after_save += self.on_after_save
        controller.events.scaffold_before_apply += self.on_scaffold_before_apply
    def on_after_save(self, controller, response):
        self.clear()
    def on_after_dispatch(self, controller, response):
        controller.context['has_draft_component'] = True
        controller.context['controller_name'] = controller.name
        if controller.route.action != 'list' and controller.route.action != 'view' and controller.route.action != 'edit_data' and controller.route.action != 'update':
            draft_data = self.retrive(controller.name, users.get_current_user().email())
            form_key = controller.context.get('form_key')
            controller.context['draft_action_url'] = '/' + controller.name + '/draft_action'
            controller.context['clear_draft

            controller.context['list_action_url'] = '/' + controller.name + '?key=' + str(form_key)
            controller.context['draft_data'] = controller.util.stringify_json(draft_data)
        if controller.route.action == 'list':
            draft_data = self.retrive(controller.name, users.get_current_user().email())
            if draft_data:
                controller.context['has_draft_data'] = True
    def on_scaffold_before_apply(self, controller, container, item):
        username = users.get_current_user().email()
        exist = self.retrive(self.controller.name, username)
        if exist is not None:
            exist.key.delete()
    def retrive(self, controller_name, username):
        return Draft.query(ndb.GenericProperty('controller_name') == controller_name, ndb.GenericProperty('username') == username).get()
    def clear(self):
        controller_name = self.controller.name
        username = users.get_current_user().email()
        exist = self.retrive(controll

        if exist is not None:
            exist.key.delete()
    def save(self, params, request_obj=None):
        logging.info(request_obj)
        self.clear()
        controller_name = self.controller.name
        username = users.get_current_user().email()
        draft = Draft()
        draft.controller_name = controller_name
        draft.username = username
        for index, field in enumerate(params):
            if request_obj is not None:
                check_if_array = request_obj.POST.getall(field)
                is_array = False
                if len(check_if_array) > 0:
                    is_array = True
                if is_array:
                    value = None
                    for v in check_if_array:
                        if v is None:
                            v = ''
                        if value is None:
                            value = v
                        else:
                            value = value + '::::' + v
                else:
 
argc = len(sys.argv)
if argc != 2:
    sys.stdout.write("Usage: ")
    sys.stdout.write("{0:s} ".format(sys.argv[0]))
    sys.stdout.write("<saveFile>\n")
    sys.exit(1)
saveFile = sys.argv[1]
saveStream = open(saveFile, "rb")
saveData = array.array('B')
saveData.fromfile(saveStream, 6 * 0x500)
saveStream.close()
for i in range(6):
    saveRoot = 0x500 * i
    addChecksum = 0
    addChecksum += saveData[saveRoot + 0x1D] << 8
    addChecksum += saveData[saveRoot + 0x1C]
    xorChecksum = 0
    xorChecksum += saveData[saveRoot + 0x1F] << 8
    xorChecksum += saveData[saveRoot + 0x1E]
    addRealsum = 0
    for j in range(0x20, 0x500, 1):
        addRealsum += saveData[saveRoot + j]
    addRealsum &= 0xFFFF
    xorRealsum = 0
    for j in range(0x20, 0x500, 2):
        nextWord = 0
        nextWord += saveData[saveRoot + j + 1] << 8
        nextWord += saveData[saveRoot + j]
        xorRealsum ^= nextWord
    sys.stdout.write("\n")
    sys.stdout.write("Save block: {0:d}\n".format(i))
  
logging.basicConfig(level=logging.INFO)
if os.name == "nt":
    log_filename = "D:\\toys\\controller\\controller.log"
else:
    log_filename = os.path.expanduser("~/.controller/controller.log")
fh = logging.handlers.RotatingFileHandler(log_filename,
                                          maxBytes=1024*128,
                                          backupCount=15)
logging.getLogger('').addHandler(fh)
if __name__ == "__main__":
    now = make_now()
    odd_even = now["day"] % 2 == 0
    if odd_even:
        odd_even = "even"
    else:
        odd_even = "odd"
    print "Toy Simulation"
    print "Toy Program"
    controller = Controller()
    monkey_program(controller.programs[1], 20)
    pprint.pprint(controller.programs[1])
    monkey_program(controller.programs[2], 160)
    pprint.pprint(controller.programs[2])
    monkey_program(controller.programs[3], 200)
    pprint.pprint(controller.programs[3])
    controller.prepare_programs()
    print len(controller.programs.keys())
    i =
admin.autodiscover()
urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^fstatic/(?P<path>.*)$', 'django.views.static.serve', {
            'document_root': settings.STATIC_ROOT,
        }),
    
         
    url(r'^request/model$', 'model_manager.views.get_model'),
    url(r'^request/Tmodel$', 'model_manager.views._get_model'),
    url(r'^request/Tgetmodel$', 'model_manager.views.get_model_secondary'),
    url(r'^request/getmodel$', 'model_manager.views._get_model_secondary'),
    url(r'^request/getinfrastructures$', 'model_manager.views.get_infrastructures'),
    url(r'^request/addinfrastructures$', 'model_manager.views.add_infrastructure'),
    url(r'^submit/manifest', 'interface.views.approve_manifest'),
    url(r'^federation/new/helo', 'interface.views.start_token'),
    
    url(r'^$', 'interface.views.index'),
    
    url(r'^broker$', 'broker.views.index'),
    url(r'^broker/getproxies$', 'broker.views.index'),
    url(r'^broker/delete/(?P<prox

    url(r'^broker/owners$', 'broker.views.all_owners'),
    url(r'^broker/toggle/(?P<id>\d*)$', 'broker.views.toggle'),
    
    url(r'^broker/pull$', 'broker.views.force_pull_remote'),
    url(r'^broker/get$', 'broker.views.force_get_remote'),
    url(r'^broker/clear$', 'broker.views.clear_db'),
    
    url(r'^models$', 'model_manager.views.index'),
    url(r'^models/getmodels$', 'model_manager.views.get_model_secondary'),
    url(r'^models/add/infrastructure$', 'model_manager.views.get_model_secondary'),
    
    url(r'^submit/write$', 'data.views.submit_write' ),
    
    url(r'^export$', 'interface.views.export'),
    url(r'^print$', 'interface.views.do_export'),
    url(r'^interface/urls$', 'interface.views.urls'),
    url(r'^interface/search$', 'broker.views.search'),
    url(r'^interface/s$', 'broker.views.do_search'),
    url(r'^interface/proxies$', 'broker.views.show'),
    url(r'^interface/staticmap$', 'interface.views.download_static_map'),
    
    url(r'^sld/default$', '
urlpatterns = patterns('proxynow5_proj.proxynow5.Network.views',
                       (r'^netint/$', 'netint_page'),
                       (r'^netint/save/$', 'netint_save'),
                       (r'^netint/delete/$', 'netint_delete'),
                       (r'^netint/list/$', 'netint_list'),
                       
                       (r'^netdhcp/$', 'netdhcp_page'),
                       (r'^netdhcp/save/$', 'netdhcp_save'),
                       (r'^netdhcp/delete/$', 'netdhcp_delete'),
                       (r'^netdhcp/list/$', 'netdhcp_list'),
                       
                       (r'^netdns/$', 'netdns_page'),
                       (r'^netdns/allownet/save/$', 'netdns_allownet_save'),
                       (r'^netdns/allownet/delete/$', 'netdns_allownet_delete'),
                       (r'^netdns/relay/save/$', 'netdns_relay_save'),
                       (r'^netdns/relay/delete/$', 'netdns_relay_delete'),
                       (r'^netdns/relay/defnet/save
SAVE_MAX = 255
class PNM:
                
    def saveColor(filename, data, colorScheme):
        f = open(filename, "w")
        f.write("P3\n%d %d\n%d\n" % (len(data[0]), len(data), SAVE_MAX))
        for row in data:
            for c in row:
                if (c < 0):
                    c = 0
                if (c > 1):
                    c = 1
                x = colorScheme(c)
                x = (x[0]*SAVE_MAX, x[1]*SAVE_MAX, x[2]*SAVE_MAX)
                f.write("%d %d %d\n" %(x[0], x[1], x[2]))
    saveColor = staticmethod(saveColor)
    
    def loadToGreyscale(filename):
        f = open(filename, "r")
        f.readline()
        dimensions = map(int,f.readline().split(' '))
        maxValue = int(f.readline())
        print "Dimensions",dimensions
        data = []
        row = []
        c = 0
        band = 0;
        pixel = [];
        for line in f:
            tokens = map(float, line.split())
            for t in tokens:
                pixel.append(t)
       
class WebView(object):
    def __init__(self, port=8888, secure_url="", controller = None):
        self.controller = controller
        if secure_url != "":
            self.secure_path="/%s" % secure_url
        else:
            self.secure_path=""
        self.port = port
    def add_controller(self, controller):
        self.controller = controller
        self.init_webapp()
    def init_webapp(self):
        settings = {
            'debug': False,
            'static_path': os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static'),
        }
        handlers = [
                        (r"%s/index.html" % self.secure_path, DefaultHandler, dict(controller=self.controller)),
                        (r"%s/" % self.secure_path, DefaultHandler, dict(controller=self.controller)),
                        (r"%s/config/get/.*" % self.secure_path, GetConfigHandler, dict(controller=self.controller)),
                        (r"%s/config/set/.*" % self.secure_path, SetConfigHandler

                        (r"%s/config/reload/.*" % self.secure_path, ReloadInterHandler, dict(controller=self.controller)),
                        (r"%s/inter/get/.*" % self.secure_path, GetInterHandler, dict(controller=self.controller)),
                        (r"%s/inter/set/.*" % self.secure_path, SetInterHandler, dict(controller=self.controller)),
                        (r'%s/static/(.*)' % self.secure_path, tornado.web.StaticFileHandler, dict(path=settings['static_path'])),
                        ("/.*", ErrorHandler, dict(controller=self.controller)),
                                             ]
        self.application = tornado.web.Application(handlers, **settings)
        self.application.listen(self.port)
    def start(self):
        print "Starting View"
        sys.stdout.flush()
        tornado.ioloop.IOLoop.instance().start()
if __name__ == '__main__':
    class Controller(object):
        def __init__(self):
            print "init"
        def get_inter(self, addr
@attr.s
class _DispatchNotFound(object):
    """ a dummy object to help signify a dispatch not found """
    pass
class MultiStrategyDispatch(object):
    """
    MultiStrategyDispatch uses a
    combination of FunctionDispatch and singledispatch.
    singledispatch is attempted first. If nothing is
    registered for singledispatch, or an exception occurs,
    the FunctionDispatch instance is then used.
    """
    def __init__(self, fallback_func):
        self._function_dispatch = FunctionDispatch()
        self._function_dispatch.register(lambda cls: True, fallback_func)
        self._single_dispatch = singledispatch(_DispatchNotFound)
        self._cache = {}
    def dispatch(self, cl):
        if cl not in self._cache:
            found = False
            try:
                dispatch = self._single_dispatch.dispatch(cl)
                if dispatch is not _DispatchNotFound:
                    found = True
            except Exception:
                pass
            if not fou
from lbaas.repository.health_monitor_repository \
from lbaas.repository.load_balancer_repository \
class BaseService(Resource):
    def __init__(self):
        self.lb_persistence = LoadbalancerRepositoryOps()
        self.monitor_persistence = HealthMonitorRepositoryOps()
        self.pool_persistence = PoolRepositoryOps()
        self.member_persistence = MemberRepositoryOps()
        self.vip_persistence = VipRepositoryOps()
        self.lb_vip_persistence = LbVipRepositoryOps()
        self.content_swithcing_repository = ContentSwitchingRepositoryOps()
    def validate_resources(self):
        resources = request.view_args.copy()
        if 'healthmonitor' in request.path and request.method != 'POST':
            resources['health_monitor'] = True
        self._validate_all_resources_exist(**resources)
    def _validate_all_resources_exist(self, tenant_id=None, lb_id=None,
                                      pool_id=None, member_id=None,
                                      heal
"""
	Constants For All Twitter Endpoints
	-----------------------------------
	Version 1.1, Streaming API and REST API.
	URLs for each endpoint are composed of the following pieces:
		PROTOCOL://{subdomain}.DOMAIN/VERSION/{resource}?{parameters}
"""
__author__ = "Jonas Geduldig"
__date__ = "February 3, 2012"
__license__ = "MIT"
PROTOCOL = 'https'
DOMAIN = 'twitter.com'
VERSION = '1.1'
USER_AGENT = 'python-TwitterAPI'
CONNECTION_TIMEOUT = 5
STREAMING_TIMEOUT = 90
REST_TIMEOUT = 5
ENDPOINTS = {
    'statuses/filter':                         ('POST', 'stream'),
    'statuses/firehose':                       ('GET',  'stream'),
    'statuses/sample':                         ('GET',  'stream'),
    'site':                                    ('GET',  'sitestream'),
    'user':                                    ('GET',  'userstream'),
    'account/remove_profile_banner':           ('POST', 'api'),
    'account/settings':                        ('GET',  'api'),
    'account/update_delivery_de

    'account/update_profile':                  ('POST', 'api'),
    'account/update_profile_background_image': ('POST', 'api'),
    'account/update_profile_banner':           ('POST', 'api'),
    'account/update_profile_colors':           ('POST', 'api'),
    'account/update_profile_image':            ('POST', 'api'),
    'account/verify_credentials':              ('GET',  'api'),
    'application/rate_limit_status':           ('GET',  'api'),
    'blocks/create':                           ('POST', 'api'),
    'blocks/destroy':                          ('POST', 'api'),
    'blocks/ids':                              ('GET',  'api'),
    'blocks/list':                             ('GET',  'api'),
    'direct_messages':                         ('GET',  'api'),
    'direct_messages/destroy':                 ('POST', 'api'),
    'direct_messages/new':                     ('POST', 'api'),
    'direct_messages/sent':                    ('GET',  'api'),
    'direct_messages/show':            

    'favorites/create':                        ('POST', 'api'),
    'favorites/destroy':                       ('POST', 'api'),
    'favorites/list':                          ('GET',  'api'),
    'followers/ids':                           ('GET',  'api'),
    'followers/list':                          ('GET',  'api'),
    'friends/ids':                             ('GET',  'api'),
    'friends/list':                            ('GET',  'api'),
    'friendships/create':                      ('POST', 'api'),
    'friendships/destroy':                     ('POST', 'api'),
    'friendships/incoming':                    ('GET',  'api'),
    'friendships/lookup':                      ('GET',  'api'),
    'friendships/no_retweets/ids':             ('GET',  'api'),
    'friendships/outgoing':                    ('GET',  'api'),
    'friendships/show':                        ('GET',  'api'),
    'friendships/update':                      ('POST', 'api'),
    'lists/create':                    
class DataCatalogs():
    def __init__(self):
        self.ckan_app = CkanApplication()
    def get_ckan_packages(self):
        package_list = self.ckan_app.get_full_package_list()
        packages = []
        for package in package_list:
            if('ckan' in package.groups):
                packages.append(package)
        return packages
    def get_ckan_api_list(self):
        return [
                'http://it.ckan.net/api',
                'http://datospublicos.org/api',
                'http://dati.trentino.it/api',
                'http://dadosabertos.senado.gov.br/api',
                'http://thedatahub.org/api',
                'http://publicdata.eu/api',
                'http://opengov.es/api',
                'http://ie.ckan.net/api',
                'http://rs.ckan.net/api',
                'http://open-data.europa.eu/en/data/api',
                'http://hub.healthdata.gov/api',
                'http://data.buenosaires.gob.ar/api',
                'http://opendata.

                'http://dati.toscana.it/api',
                'http://www.datagm.org.uk/api',
                'http://www.opendata-hro.de/api',
                'http://datakilder.no/api',
                'http://fi.thedatahub.org/api',
                'http://data.gov.uk/api',
                'http://data.openpolice.ru/api',
                'http://www.daten.rlp.de/api',
                'http://data.cityofsantacruz.com/api',
                'http://br.ckan.net/api',
                'http://data.qld.gov.au/api',
                'http://cz.ckan.net/api',
                'http://ckan.emap.fgv.br/api',
                'http://data.opencolorado.org/api',
                'http://www.opendata.provincia.roma.it/api',
                'http://offenedaten.de/api',
                'http://www.data.gv.at/katalog/api',
                'http://iatiregistry.org/api',
                'http://www.nosdonnees.fr/api',
                'http://dados.novohamburgo.rs.gov.br/api',
                'http://thed
urlpatterns = [
        url(r'^$',views.index,name='index'),
        url(r'^guestlogin/(?P<target_guest>.+)/$',views.guestlogin,name='guestlogin'),
        url(r'^guestlogin/$',views.guestlogin,name='guestlogin'),
        url(r'^manage/(?P<target_type>.+)/(?P<target_object>.+)/',views.manage,name='manage'),
        url(r'^manage/(?P<target_type>.+)/',views.manage,name='manage'),
        url(r'^manage/$',views.manage,name='manage'),
        url(r'^view/(?P<target_type>.+)/(?P<target_object>.+)/(?P<second_object>.+)/',views.view,name='view'),
        url(r'^view/(?P<target_type>.+)/(?P<target_object>.+)/',views.view,name='view'),
        url(r'^unsetcomplete/(?P<form_id>.+)/(?P<guest_id>.+)/',views.unsetcomplete,name='unsetcomplete'),
        url(r'^setscore/(?P<form_id>.+)/(?P<guest_id>.+)/',views.setscore,name='setscore'),
        url(r'^runreport/(?P<report_id>.+)/',views.runreport,name='runreport'),
        url(r'^logout/$',views.logout,name='logout'),
        url(r'^edit/(?P<target_
deploy_contracts = [
    "BuildByteArrayFactory",
def test_initializing_dispute_gas_is_covered(deploy_client, get_computation_request,
                                             deploy_broker_contract, deployed_contracts,
                                             get_log_data, StatusEnum):
    factory = deployed_contracts.BuildByteArrayFactory
    broker = deploy_broker_contract(factory._meta.address)
    expected = "\x01\x02\x03\x04\x05\x06\x07"
    _id = get_computation_request(
        broker, "abcdefg",
        initial_answer="wrong",
        challenge_answer=expected,
    )
    assert broker.getRequest(_id)[5] == StatusEnum.NeedsResolution
    i_dispute_txn_hash = broker.initializeDispute(_id)
    i_dispute_txn_receipt = deploy_client.wait_for_transaction(i_dispute_txn_hash)
    assert broker.getRequest(_id)[5] == StatusEnum.Resolving
    gas_log_data = get_log_data(broker.GasReimbursement, i_dispute_txn_hash)
    gas_reimbursement = gas_log_data['value']
    gas_actual = int
djangoproject_root = "/home/Ellis/CMPT470-1131-g-team-lazy/kotw/"
sys.path.append(djangoproject_root)
os.environ['DJANGO_SETTINGS_MODULE'] = 'settings'
b=Building()
b.type="enterprise"
b.effect_name="increase income"
b.effect_val=0.6
b.save()
b=Building()
b.type="residence"
b.effect_name="increase max population"
b.effect_val=100.00
b.save()
b=Building()
b.type="industrial"
b.effect_name="decrease military training costs"
b.effect_val=0.65
b.save()
b=Building()
b.type="military_base"
b.effect_name="increase military effectiveness"
b.effect_val=0.30
b.save()
b=Building()
b.type="research_lab"
b.effect_name="decrease tech costs"
b.effect_val=0.70
b.save()
b=Building()
b.type="farm"
b.effect_name="produce food"
b.effect_val=200.00
b.save()
b=Building()
b.type="oil_rig"
b.effect_name="produce oil"
b.effect_val=75.00
b.save()
b=Building()
b.type="unused"
b.effect_name="small increase to food and population"
b.effect_val=50
b.save()
print "Completed adding Buildings"
g=Government()
g.type="M

g.save()
e=effects()
e.government=g
e.effect_name="free revolution"
e.effect_val=0
e.save()
g=Government()
g.type="Fascism"
g.save()
e=effects()
e.government=g
e.effect_name="increase resource production"
e.effect_val=1.20
e.save()
e=effects()
e.government=g
e.effect_name="decrease population"
e.effect_val=0.8
e.save()
g=Government()
g.type="Dictator"
g.save()
e=effects()
e.government=g
e.effect_name="increase military effectiveness"
e.effect_val=1.3
e.save()
e=effects()
e.government=g
e.effect_name="increase construction costs"
e.effect_val=1.20
e.save()
g=Government()
g.type="Communism"
g.save()
e=effects()
e.government=g
e.effect_name="decrease training costs"
e.effect_val=0.6
e.save()
e=effects()
e.government=g
e.effect_name="decrease income"
e.effect_val=0.8
e.save()
g=Government()
g.type="Theocracy"
g.save()
e=effects()
e.government=g
e.effect_name="decrease construction costs"
e.effect_val=0.7
e.save()
e=effects()
e.government=g
e.effect_name="decrease technology effectiveness"

e.effect_val=0.7
e.save()
g=Government()
g.type="Republic"
g.save()
e=effects()
e.government=g
e.effect_name="increase income"
e.effect_val=1.2
e.save()
e=effects()
e.government=g
e.effect_name="decrease military effectiveness"
e.effect_val=0.7
e.save()
g=Government()
g.type="Democracy"
g.save()
e=effects()
e.government=g
e.effect_name="increase technology effectiveness"
e.effect_val=1.4
e.save()
e=effects()
e.government=g
e.effect_name="decrease resource production"
e.effect_val=0.8
e.save()
print "Completed adding Governments"
m=Military()
m.unit="Troops"
m.offense=1
m.defense=1
m.fuel=0
m.save()
m=Military()
m.unit="Jets"
m.offense=4
m.defense=0
m.fuel=2
m.save()
m=Military()
m.unit="Turrets"
m.offense=0
m.defense=4
m.fuel=0
m.save()
m=Military()
m.unit="Tanks"
m.offense=6
m.defense=8
m.fuel=4
m.save()
print "Completed adding Military Units"
t=Tech()
t.type="Military"
t.effect_name="decrease military costs"
t.effect_val=0.20
t.save()
t=Tech()
t.type="Medical"
t.effect_name="reduce 
urlpatterns = patterns('report.views',
    url(r'^master_plan/manage/program/(?P<program_id>\d+)/report/$', 'view_master_plan_manage_program_report', name='view_master_plan_manage_program_report'),
    
    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/manage/report/$', 'view_master_plan_manage_report', name='view_master_plan_manage_report'),
    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/manage/report/add/$', 'view_master_plan_manage_report_add_report', name='view_master_plan_manage_report_add_report'),
    url(r'^master_plan/manage/report/(?P<report_id>\d+)/edit/$', 'view_master_plan_manage_report_edit_report', name='view_master_plan_manage_report_edit_report'),
    url(r'^master_plan/manage/report/(?P<report_id>\d+)/delete/$', 'view_master_plan_manage_report_delete_report', name='view_master_plan_manage_report_delete_report'),
    
    
    url(r'^program/(?P<program_id>\d+)/reports/$', 'view_program_reports', {'year_number':''}, name='view_program_reports'),
    url(r'^program

    
    url(r'^program/(?P<program_id>\d+)/reports/send/$', 'view_program_reports_send_list', name='view_program_reports_send_list'),
    url(r'^program/(?P<program_id>\d+)/reports/send/(?P<report_id>\d+)/$', 'view_program_reports_send_report', name='view_program_reports_send_report'),
    
    url(r'^program/(?P<program_id>\d+)/reports/manage/$', 'view_program_reports_manage_report', name='view_program_reports_manage_report'),
    url(r'^program/(?P<program_id>\d+)/reports/manage/add/$', 'view_program_reports_manage_report_add_report', name='view_program_reports_manage_report_add_report'),
    
    url(r'^program/reports/manage/(?P<report_id>\d+)/edit/$', 'view_program_reports_manage_report_edit_report', name='view_program_reports_manage_report_edit_report'),
    url(r'^program/reports/manage/(?P<report_id>\d+)/delete/$', 'view_program_reports_manage_report_delete_report', name='view_program_reports_manage_report_delete_report'),
    
    url(r'^program/(?P<program_id>\d+)/report/(?
DB_SHARED_THREAD = """\
DatabaseWrapper objects created in a thread can only \
be used in that same thread.  The object with alias '{0}' \
was created in thread id {1} and this is thread id {2}.\
"""
def patch_thread_ident():
    if getattr(patch_thread_ident, 'called', False):
        return
    try:
        if 'validate_thread_sharing' in BaseDatabaseWrapper.__dict__:
            _get_ident = thread.get_ident
            __old__init__ = BaseDatabaseWrapper.__init__
            def _init(self, *args, **kwargs):
                __old__init__(self, *args, **kwargs)
                self._thread_ident = _get_ident()
            def _validate_thread_sharing(self):
                if (not self.allow_thread_sharing
                        and self._thread_ident != _get_ident()):
                    raise DatabaseError(
                        DB_SHARED_THREAD % (
                            self.alias, self._thread_ident, _get_ident()),
                    )
            BaseDatabaseWrapper._

            BaseDatabaseWrapper.validate_thread_sharing = \
                _validate_thread_sharing
        patch_thread_ident.called = True
    except ImportError:
        pass
patch_thread_ident()
class CeleryCommand(BaseCommand):
    options = BaseCommand.option_list
    skip_opts = ['--app', '--loader', '--config']
    keep_base_opts = False
    def get_version(self):
        return 'celery {c.__version__}\ndjango-celery {d.__version__}'.format(
            c=celery, d=djcelery,
        )
    def execute(self, *args, **options):
        broker = options.get('broker')
        if broker:
            self.set_broker(broker)
        super(CeleryCommand, self).execute(*args, **options)
    def set_broker(self, broker):
        os.environ['CELERY_BROKER_URL'] = broker
    def run_from_argv(self, argv):
        self.handle_default_options(argv[2:])
        return super(CeleryCommand, self).run_from_argv(argv)
    def handle_default_options(self, argv):
        acc = []
        broker = 
class FeatureConfig(AutoConfigTemplate):
    """
    name=string:extName
    code=string:ext9999
    description=string:long description
    type=string:ext
    """
    
def loadFeatureConfig(filename, saveTemplate = False):
    files = [ filename ]
    last_file = files[-1]
    if saveTemplate == "*template*":
        saveTemplate = last_file + ".template"
        files = []
    elif saveTemplate == "*update*":
        saveTemplate = last_file
    elif not os.path.exists(last_file):
        files = []
        saveTemplate = last_file
    
    cfg = ConfigReader(files=files, saveConfig = saveTemplate)
    cfg.feature = FeatureConfig(cfg,section = "feature")
    
    if saveTemplate:
        f1w = open(saveTemplate, 'wb')
        cfg.configini.write(f1w)
        f1w.close()
    return cfg
def main():
    filename = sys.argv[1]
    if len(sys.argv) > 2:
        if sys.argv[2] == 'savetemplate':
            reloadConfig(filename, saveTemplate = '*template*')
        elif sys.argv[2] == 'u
__author__ = 'mars'
if len(sys.argv) != 3:
    print('wrong arg')
    exit(1)
data_path=sys.argv[1]
save_path=sys.argv[2]
NR_THREAD=2
cmd = 'feature_engineering/converters/add_dummy_label.py {data}test.csv {data}test.tmp.csv'.format(data=data_path)
subprocess.call(cmd, shell=True)
print('dummy label to test.csv added!\n')
cmd = 'feature_engineering/converters/parallelizer-a.py -s {nr_thread} feature_engineering/converters/pre-a.py {data}train.csv {save}tr.gbdt.dense {save}tr.gbdt.sparse'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('train set to dense and sparse format completed!\n')
cmd = 'feature_engineering/converters/parallelizer-a.py -s {nr_thread} feature_engineering/converters/pre-a.py {data}test.tmp.csv {save}te.gbdt.dense {save}te.gbdt.sparse'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('test set to dense and sparse format completed!\n')
cmd = 'feature_engineering/converter

subprocess.call(cmd, shell=True)
print('gbdt features generated!\n')
cmd = 'rm -f {path}te.gbdt.dense {path}te.gbdt.sparse {path}tr.gbdt.dense {path}tr.gbdt.sparse'.format(path=save_path)
subprocess.call(cmd, shell=True)
cmd = 'feature_engineering/converters/parallelizer-b.py -s {nr_thread} feature_engineering/converters/pre-b.py {data}train.csv {save}tr.gbdt.out {save}tr.sp'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('gbdt features added to train dataSet\n')
cmd = 'feature_engineering/converters/parallelizer-b.py -s {nr_thread} feature_engineering/converters/pre-b.py {data}test.tmp.csv {save}te.gbdt.out {save}te.sp'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('gbdt features added to test dataSet\n')
print('gbdt process completed!')
cmd = './ffm -k 4 -t 11 -s {nr_thread} {save}te.sp {save}tr.sp'.format(nr_thread=NR_THREAD,save=save_path)
subprocess.call(cmd, shell=True)
cmd = './
Manage_Restricted_Pages = {
    "ManageHandler": (0, ("/manage", "Change Log")),
    "Manage_HomePageSlides_BaseHandler": (1, ("/manage/homepage_slides", "Homepage Slides")),
    "Manage_HousingApplications_BaseHandler": (2, ("/manage/housing_applications", "Applications")),
    "Manage_NewsletterArchive_BaseHandler": (3, ("/manage/newsletter_archive", "Newsletter Archive")),
    "Manage_GelGroups_BaseHandler": (4, ("/manage/gel_groups", "Small Groups")),
    "Manage_SemesterSeries_BaseHandler": (4, ("/manage/semester_series", "Semester Series")),
    "Manage_TopTen_BaseHandler": (4, ("/manage/top_ten", "Top Ten")),
    "Manage_StudentOfficers_BaseHandler": (5, ("/manage/student_officers", "Officers")),
    "Manage_StaffPositions_BaseHandler": (5, ("/manage/staff_positions", "Staff")),
Other_Restricted_Pages = {
    "ApplicationComments": (100, ("/housing/comments", "Housing Application Comments"))
All_Restricted_Pages = dict(Manage_Restricted_Pages.items() + Other_Restricted_Pages.ite

class MultiCheckboxField(fields.SelectMultipleField):
    """
    A multiple-select, except displays a list of checkboxes.
    Iterating the field will produce subfields, allowing custom rendering of
    the enclosed checkbox fields.
    """
    widget = widgets.ListWidget(prefix_label=False)
    option_widget = widgets.CheckboxInput()
class UserPermission_Form(Form):
    id = fields.StringField(
        label=u"User Email",
        validators=[validators.required()],
        filters=[lambda x: x.lower() if x else x],
    )
    PermittedPageClasses = MultiCheckboxField(
        label="Permitted Pages",
        validators=[validators.Required()],
        choices=[(x, All_Restricted_Pages[x][1][1]) for x in sorted(All_Restricted_Pages.keys())],
    )
class UserPermission(NdbBaseModel):
    CreatedBy = ndb.UserProperty(auto_current_user_add=True)
    CreationDateTime = NdbUtcDateTimeProperty(auto_now_add=True)
    ModifiedBy = ndb.UserProperty(auto_current_user=True)
    ModifiedDateTime
class ContentWellPortletsViewlet(ViewletBase):
    name = ""
    manage_view = ""
    @property
    def dont_show(self):
        return IPloneControlPanelView.providedBy(self.view)
    @property
    def dont_show_links(self):
        """Show links to portlet manager management views only in manage
        portlets view.
        """
        return not IManagePortletsView.providedBy(self.view)
    def update(self):
        context_state = getMultiAdapter(
            (self.context,
             self.request),
            name=u'plone_context_state')
        if pap_interfaces.IManageContentTypePortletsView.providedBy(self.view):
            key = self.request.form.get('key')
            self.manageUrl = '%s/%s?key=%s' % (
                context_state.view_url(), self.manage_type_view, key)
        else:
            self.manageUrl = '%s/%s' % (
                context_state.view_url(), self.manage_view)
        mt = getToolByName(self.context, 'portal_membership')
        self.canManagePo

            'Portlets: Manage portlets', self.context)
    def showPortlets(self):
        return not self.dont_show\
            and '@@manage-portlets' not in self.request.get('URL')
    def portletManagers(self):
        managers = []
        try:
            for n in range(1, 7):
                name = 'ContentWellPortlets.%s%s' % (self.name, n)
                mgr = getUtility(
                    IPortletManager,
                    name=name,
                    context=self.context)
                managers.append((mgr, name))
            return managers
        except ComponentLookupError:
            return []
    def portletManagersToShow(self):
        visibleManagers = []
        for mgr, name in self.portletManagers():
            if mgr(self.context, self.request, self).visible:
                visibleManagers.append(name)
        managers = []
        numManagers = len(visibleManagers)
        for counter, name in enumerate(visibleManagers):
            pos = 'position

                Fraction(counter, numManagers)).replace('/', ':')
            width = 'width-%s' % (
                str(Fraction(1, numManagers)).replace('/', ':')
                if numManagers > 1 else 'full')
            managers.append(
                (name, 'cell %s %s %s' % (name.split('.')[-1], width, pos)))
        return managers
    def num_portlets_for_manager(self, name):
        """Return the number of portlets for a given portlet manager name.
        :param name: Portlet manager name
        :type name: String
        :returns: Number of portlets for the given manager name.
        :rtype: Integer
        """
        mgr = getUtility(IPortletManager,
                         name=name,
                         context=self.context)
        retriever = getMultiAdapter((self.context, mgr), IPortletRetriever)
        portlets = retriever.getPortlets()
        return len(portlets)
class PortletsInHeaderViewlet(ContentWellPortletsViewlet):
    name = 'InHeaderPortletManage
"""
	Constants For All Twitter Endpoints
	-----------------------------------
	Version 1.1, Streaming API and REST API.
	URLs for each endpoint are composed of the following pieces:
		PROTOCOL://{subdomain}.DOMAIN/VERSION/{resource}?{parameters}
"""
__author__ = "Jonas Geduldig"
__date__ = "February 3, 2012"
__license__ = "MIT"
PROTOCOL = 'https'
DOMAIN = 'twitter.com'
VERSION = '1.1'
USER_AGENT = 'python-TwitterAPI'
STREAMING_TIMEOUT = 90
REST_TIMEOUT = 5
ENDPOINTS = {
    'statuses/filter':                         ('POST', 'stream'),
    'statuses/firehose':                       ('GET',  'stream'),
    'statuses/sample':                         ('GET',  'stream'),
    'site':                                    ('GET',  'sitestream'),
    'user':                                    ('GET',  'userstream'),
    'account/remove_profile_banner':           ('POST', 'api'),
    'account/settings':                        ('GET',  'api'),
    'account/update_delivery_device':          ('POST'

    'account/update_profile':                  ('POST', 'api'),
    'account/update_profile_background_image': ('POST', 'api'),
    'account/update_profile_banner':           ('POST', 'api'),
    'account/update_profile_colors':           ('POST', 'api'),
    'account/update_profile_image':            ('POST', 'api'),
    'account/verify_credentials':              ('GET',  'api'),
    'application/rate_limit_status':           ('GET',  'api'),
    'blocks/create':                           ('POST', 'api'),
    'blocks/destroy':                          ('POST', 'api'),
    'blocks/ids':                              ('GET',  'api'),
    'blocks/list':                             ('GET',  'api'),
    'direct_messages':                         ('GET',  'api'),
    'direct_messages/destroy':                 ('POST', 'api'),
    'direct_messages/new':                     ('POST', 'api'),
    'direct_messages/sent':                    ('GET',  'api'),
    'direct_messages/show':            

    'favorites/create':                        ('POST', 'api'),
    'favorites/destroy':                       ('POST', 'api'),
    'favorites/list':                          ('GET',  'api'),
    'followers/ids':                           ('GET',  'api'),
    'followers/list':                          ('GET',  'api'),
    'friends/ids':                             ('GET',  'api'),
    'friends/list':                            ('GET',  'api'),
    'friendships/create':                      ('POST', 'api'),
    'friendships/destroy':                     ('POST', 'api'),
    'friendships/incoming':                    ('GET',  'api'),
    'friendships/lookup':                      ('GET',  'api'),
    'friendships/no_retweets/ids':             ('GET',  'api'),
    'friendships/outgoing':                    ('GET',  'api'),
    'friendships/show':                        ('GET',  'api'),
    'friendships/update':                      ('POST', 'api'),
    'lists/create':                    
urlpatterns = [
    url(r'^manage_teams/delete/(?P<pk>\d+)/$', staff_member_required(TeamDelete), name="delete_team"),
    url(r'^manage_teams/$', 'manager.views.teamManager', name='team_manager'),
    url(r'^manage_tournaments/(?P<pk>\d+)/status/(?P<status>[1-4]+)/$', 'manager.views.tournament_setstatus', name='set_status'),
    url(r'^manage_tournaments/divs/(?P<pk>\d+)/status/(?P<status>[1-3]+)/$', 'manager.views.tournament_setstatus', name='set_group_status'),
    url(r'^manage_tournaments/delete/(?P<pk>\d+)/$', TournamentDelete, name='delete_tournament'),
    url(r'^manage_tournaments/$', tournamentManager, name='tournament_manager'),
    url(r'^manage_tournaments/edit/(?P<id>\d+)/$', 'manager.views.tournamentManager', name='edit_tournament'),
    url(r'^manage_tournaments/divs/(?P<pk>\d+)/$', 'manager.views.tournamentDivGroupManager', name='divgroup_tournament'),
    url(r'^assign_group/(?P<team_pk>\d+)/(?P<tournament_pk>\d+)/(?P<division_pk>\d+)/(?P<group_pk>\d+)/$', 'manager.vi

    url(r'^assign_group/(?P<team_pk>\d+)/(?P<tournament_pk>\d+)/(?P<division_pk>\d+)/$', 'manager.views.add_team_to_div_group', name="add_team_to_div"),
    url(r'^manage_tournaments/group/drop_teams/(?P<pk>\d+)/(?P<team_pk>\d+)/$', 'manager.views.group_team_dropper', name="drop_team_from_group"),
    url(r'^manage_tournaments/group/drop_teams/(?P<pk>\d+)/$', 'manager.views.group_team_dropper', name="drop_all_teams_from_group"),
    url(r'^manage_tournaments/division/(?P<division_pk>\d+)/group/(?P<group_pk>\d+)/start_round/$', 'manager.views.start_round', name='start_round_group'),
    url(r'^manage_tournaments/division/(?P<division_pk>\d+)/start_round$', 'manager.views.start_round', name='start_round_div'),
    url(r'^manage_matches/$', 'manager.views.matchManager', name='match_manager'),
    url(r'^manage_matches/edit/(?P<id>\d+)/$', 'manager.views.matchManager', name='edit_match'),
    url(r'^manage_matches/is_setup/(?P<id>\d+)/$', 'manager.views.match_setup_complete', name='setup_
def map_routes(api):
    api.add_resource(resources.Activity,
                     '/api/v1.0/activities/<int:id>',
                     endpoint='activity')
    api.add_resource(resources.Activities,
                     '/api/v1.0/activities',
                     endpoint='activities')
    api.add_resource(resources.Score,
                     '/api/v1.0/scores/<int:id>',
                     endpoint='score')
    api.add_resource(resources.Scores,
                     '/api/v1.0/scores',
                     endpoint='scores')
    api.add_resource(resources.Tag,
                     '/api/v1.0/tags/<int:id>',
                     endpoint='tag')
    api.add_resource(resources.Tags,
                     '/api/v1.0/tags',
                     endpoint='tags')
    api.add_resource(resources.User,
                     '/api/v1.0/users/<int:id>',
                     endpoint='user')
    api.add_resource(resources.Users,
                     '/api/v1.0/users',
                     endpo
PROJECT_PATH = '/vagrant/{{ project_name }}/'
VENV_PATH = '/home/vagrant/env'
MANAGE_BIN = os.path.join(PROJECT_PATH, 'manage.py')
SETTINGS = '{{ project_name }}.settings.local'
TEST_SETTINGS = '{{ project_name }}.settings.test'
@task
def manage_py(command):
    """
    Runs a manage.py command on the server
    """
    with cd(PROJECT_PATH):
        run('{python} {manage} {command} --settings={settings}'.format(python=VENV_PATH + '/bin/python',
                                                manage=MANAGE_BIN,
                                                command=command,
                                                settings=SETTINGS))
@task
def test():
    manage_py("test", settings=TEST_SETTINGS)
@task
def migrate():
    manage_py("makemigrations")
    manage_py("migrate")
@task
def createsuperuser():
    manage_py("createsuperuser")
@task
def gunicorn_hup():
    sudo("kill -HUP $(supervisorctl pid gunicorn_app)")
@task
def gunicorn_restart():
    """Restarts gunicorn completel
urlpatterns = patterns('domain.views',
    url(r'^$', 'home', name='home'),
    url(r'^people/create/$', 'people_create', name='people_create'),
    url(r'^people/(?P<people_id>\d+)/edit/$', 'people_edit', name='people_edit'),
    url(r'^people/(?P<people_permalink>[A-Za-z0-9-_.]+)/$', 'people_detail', name='people_detail'),
    url(r'^people/$', 'people_list', name='people_list'),
    url(r'^people/(?P<people_permalink>[A-Za-z0-9-_.]+)/meter/(?P<meter_permalink>[A-Za-z0-9-_.]+)/$', 'people_detail', name='people_meter'),
    url(r'^topic/create/$', 'topic_create', name='topic_create'),
    url(r'^topic/(?P<topic_id>\d+)/edit/$', 'topic_edit', name='topic_edit'),
    url(r'^topic/(?P<topic_id>\d+)/edit/from/(?P<statement_id>\d+)/$', 'topic_edit_from_statement', name='topic_edit_from_statement'),
    url(r'^topic/(?P<topic_id>\d+)/$', 'topic_detail', name='topic_detail'),
    url(r'^topic/(?P<topic_id>\d+)/revision/(?P<topicrevision_id>\d+)/$', 'topicrevision_detail', name='topicrevision

    url(r'^topic/(?P<topic_id>\d+)/revision/(?P<topicrevision_id>\d+)/edit/$', 'topicrevision_edit', name='topicrevision_edit'),
    url(r'^topic/$', 'topic_list', name='topic_list'),
    url(r'^meter/$', 'meter_detail', name='meter_detail_default'),
    url(r'^meter/(?P<meter_permalink>[A-Za-z0-9-_.]+)/$', 'meter_detail', name='meter_detail'),
    url(r'^statement/create/$', 'statement_create', name='statement_create'),
    url(r'^statement/(?P<statement_id>\d+)/edit/$', 'statement_edit', name='statement_edit'),
    url(r'^statement/(?P<statement_permalink>[A-Za-z0-9-_.]+)/$', 'statement_detail', name='statement_detail'),
    url(r'^statement/(?P<statement_permalink>[A-Za-z0-9-_.]+)/topic-revision/(?P<topicrevision_id>\d+)/$', 'statement_topicrevision_detail', name='statement_topicrevision_detail'),
    url(r'^statement/$', 'statement_list', name='statement_list'),
    url(r'^statement/tags/(?P<tags_id>\d+)/$', 'statement_tags_detail', name='statement_tags_detail'),
    url(r'^statem
urlpatterns = patterns('',
    
    url(r'^showswf/+(?P<bookid>.*?)/*$', views.getswf, name='doc_showswf' ),
    url(r'^showpdf/+(?P<bookid>.*?)/+(?P<page>\d+)/$', views.getpdf, name='doc_showpdf' ),
    url(r'^getpdfpage/+(?P<bookid>.*?)/+(?P<page>\d+)/$', views.getpdfpage, name='doc_getpdfpage' ),
    url(r'^showhtml/+(?P<bookid>.*?)/+(?P<page>\d+)/$', views.gethtml, name='doc_showhtml' ),
    url(r'^gethtmlpage/+(?P<bookid>.*?)/+(?P<page>\d+)/$', views.gethtmlpage, name='doc_gethtmlpage' ),
    url(r'^view/+(?P<bookid>.*?)/*$', views.view, name='doc_view' ),
    url(r'^directview/+(?P<path>.*)/$', views.directview, name='doc_directview' ),
    url(r'^pdfviewer/', TemplateView.as_view(template_name="pdfviewer.html") ),
    url(r'^history/*$', views.viewhistory, name='doc_viewhistory' ),
    url(r'^search/$', search_view_factory(view_class=views.BookSearchView, load_all=False, template='search/search.html', form_class=views.BookSearchForm), name='doc_search'),
    
    
    url(r'^man

    url(r'^manage/bookupload/$', views_manage.upload, name='doc_manage_upload' ),
    url(r'^manage/bookedit/+(?P<bookid>.*)/$', views_manage.bookedit, name='doc_manage_bookedit' ),
    url(r'^manage/bookdelete/+(?P<bookid>.*)/$', views_manage.bookdelete, name='doc_manage_bookdelete' ),
    url(r'^manage/pdfregen/+(?P<bookid>.*)/$', views_manage.pdfregen, name='doc_manage_pdfregen' ),
    url(r'^manage/user/$', views_manage.userlist, name='user_manage_index' ),
    url(r'^manage/useredit/+(?P<userid>.*)/$', views_manage.useredit, name='manage_useredit' ),
    url(r'^manage/userdelete/+(?P<userid>.*)/$', views_manage.userdelete, name='manage_userdelete' ),
    url(r'^user/register/+(?P<regtype>.*?)/*$', views_users.register, name='user_register' ),
    url(r'^user/addfav/+(?P<bookid>.*?)/$', views_users.addfavorite, name='user_addfavorite' ),
    url(r'^user/myfavorite/$', views_users.myfavorite, name='user_myfavorite' ),
    url(r'^user/myfavorite/remove/+(?P<id>\d+)/$', views_users.r
def apiDispatchTableDefineCode(apis, args, apiNames, structName):
  code = '''
  struct %s
  {
    inline void setFunction(const size_t offset, void *func)
    {
      RegalAssert((offset*sizeof(void *))<sizeof(*this));
      ((void **)(this))[offset] = func;
    }
'''%(structName)
  for api in apis:
    if not api.name in apiNames:
      continue
    code += '\n'
    if api.name in cond:
    categoryPrev = None
    for function in api.functions:
      if getattr(function,'regalOnly',False)==True:
        continue
      name   = function.name
      params = paramsDefaultCode(function.parameters, True)
      rType  = typeCode(function.ret.type)
      category  = getattr(function, 'category', None)
      version   = getattr(function, 'version', None)
      if category:
        category = category.replace('_DEPRECATED', '')
      elif version:
        category = version.replace('.', '_')
        category = 'GL_VERSION_' + category
      if categoryPrev and not (category == categoryPrev):


      if category and not (category == categoryPrev):
        code += '    // %s\n\n' % category
      code += '    %s(REGAL_CALL *%s)(%s);\n' % (rType, name, params)
      categoryPrev = category
    if api.name in cond:
    code += '\n'
  if categoryPrev:
    code += '\n'
  code += '  };\n'
  return code
dispatchHeaderTemplate = Template( '''${AUTOGENERATED}
${LICENSE}
REGAL_GLOBAL_BEGIN
REGAL_GLOBAL_END
REGAL_NAMESPACE_BEGIN
namespace Dispatch
${API_GLOBAL_DISPATCH_TABLE_DEFINE}
${API_DISPATCH_TABLE_DEFINE}
  // Lookup a function pointer from the table,
  // or deeper in the stack as necessary.
  template<typename T, typename F>
  F call(T &table, F *func)
  {
    RegalAssert(func);
    if (table._enabled && *func)
      return *func;
    T *i = &table;
    RegalAssert(i);
    RegalAssert(reinterpret_cast<void *>(func)>=reinterpret_cast<void *>(i));
    RegalAssert(reinterpret_cast<void *>(func)< reinterpret_cast<void *>(i+1));
    const std::size_t offset = reinterpret_cast<char *

    F f = *func;
    // Step down the stack for the first available function in an enabled table
    while (!f || !i->_enabled)
    {
      // Find the next enabled dispatch table
      for (i = i->next(); !i->_enabled; i = i->next()) { RegalAssert(i); }
      // Get the function pointer; extra cast through void* is to avoid -Wcast-align spew
      RegalAssert(i);
      RegalAssert(i->_enabled);
      f = *reinterpret_cast<F *>(reinterpret_cast<void *>(reinterpret_cast<char *>(i)+offset));
    }
    return f;
  }
struct DispatchTable
  bool           _enabled;
  DispatchTable *_prev;
  DispatchTable *_next;
};
struct DispatchTableGL : public DispatchTable, Dispatch::GL
public:
  template<typename T> T call(T *func) { return reinterpret_cast<T>(doCall(reinterpret_cast<void **>(func))); }
  inline DispatchTableGL *next()       { return reinterpret_cast<DispatchTableGL *>(DispatchTable::_next);    }
private:
  void *doCall(void **func);  // inlined Dispatch::call consolidated to one inst
manage_add_shibboleth_headers_form = PageTemplateFile('browser/add_plugin',
                            globals(), __name__='manage_add_shibboleth_headers_form' )
def manage_add_shibboleth_headers_helper( dispatcher, id, title=None, REQUEST=None ):
    """Add an shibboleth_headers Helper to the PluggableAuthentication Service."""
    sp = plugin.Shibboleth_HeadersHelper( id, title )
    dispatcher._setObject( sp.getId(), sp )
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect( '%s/manage_workspace'
                                      '?manage_tabs_message='
                                      'shibboleth_headersHelper+added.'
                                      % dispatcher.absolute_url() )
def register_shibboleth_headers_plugin():
    try:
        registerMultiPlugin(plugin.Shibboleth_HeadersHelper.meta_type)
    except RuntimeError:
        pass
def register_shibboleth_headers_plugin_class(context):
    context.registerClass(plugin.Shibboleth_HeadersHelper,
      
class OaiRepositoryTest(SeecrTestCase):
    def testBasicProperties(self):
        oaiRepository = OaiRepository(identifier='example.org', name='The Repository Name', adminEmail='admin@meresco.org')
        self.assertEquals('example.org', oaiRepository.identifier)
        self.assertEquals('The Repository Name', oaiRepository.name)
        self.assertEquals('admin@meresco.org', oaiRepository.adminEmail)
    def testBadRepositoryIdentifier(self):
        def oaiRepository(repositoryIdentifier):
            return OaiRepository(identifier=repositoryIdentifier, name='The Repository Name', adminEmail='admin@meresco.org')
        self.assertRaises(ValueError, lambda: oaiRepository('01234'))
        self.assertRaises(ValueError, lambda: oaiRepository('a*'))
        self.assertRaises(ValueError, lambda: oaiRepository('a34.0834'))
    def testPrefixIdentifier(self):
        oaiRepository = OaiRepository(name='The Repository Name')
        self.assertEquals("id0", oaiRepository.prefixIdentifie
urlpatterns = [
    url(r'^api/heartbeat/', api_views.heartbeat),
    url(r'^api/species/$', api_views.get_species_list),
    url(r'^api/magnifications/$', api_views.get_magnification_list),
    url(r'^api/development-stages/$', api_views.get_development_stage_list),
    url(r'^api/probes/$', api_views.ProbeList.as_view()),
    url(r'^api/images/$', api_views.ImageList.as_view()),
    url(r'^api/images/(?P<pk>[0-9]+)/$', api_views.ImageDetail.as_view()),
    url(r'^api/images-jpeg/(?P<pk>[0-9]+)/$', api_views.get_image_jpeg, name='images-jpeg'),
    url(r'^api/subregions/$', api_views.SubregionList.as_view()),
    url(r'^api/subregions/(?P<pk>[0-9]+)/$', api_views.SubregionDetail.as_view()),
    url(r'^api/image-sets/$', api_views.ImageSetList.as_view()),
    url(r'^api/image-sets/(?P<pk>[0-9]+)/$', api_views.ImageSetDetail.as_view()),
    url(r'^api/anatomy-probe-map/$', api_views.AnatomyProbeMapList.as_view()),
    url(r'^api/train-model/$', api_views.TrainedModelCreate.as_view()),
 
__author__ = 'mars'
if len(sys.argv) != 3:
    print('wrong arg')
    exit(1)
data_path=sys.argv[1]
save_path=sys.argv[2]
NR_THREAD=8
cmd = 'feature_engineering/converters/add_dummy_label.py {data}test.csv {data}test.tmp.csv'.format(data=data_path)
subprocess.call(cmd, shell=True)
print('dummy label to test.csv added!\n')
cmd = 'feature_engineering/converters/parallelizer-a.py -s {nr_thread} feature_engineering/converters/pre-a.py {data}train.csv {save}tr.gbdt.dense {save}tr.gbdt.sparse'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('train set to dense and sparse format completed!\n')
cmd = 'feature_engineering/converters/parallelizer-a.py -s {nr_thread} feature_engineering/converters/pre-a.py {data}test.tmp.csv {save}te.gbdt.dense {save}te.gbdt.sparse'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('test set to dense and sparse format completed!\n')
cmd = 'feature_engineering/converter

subprocess.call(cmd, shell=True)
print('gbdt features generated!\n')
cmd = 'rm -f {path}te.gbdt.dense {path}te.gbdt.sparse {path}tr.gbdt.dense {path}tr.gbdt.sparse'.format(path=save_path)
subprocess.call(cmd, shell=True)
cmd = 'feature_engineering/converters/parallelizer-b.py -s {nr_thread} feature_engineering/converters/pre-b.py {data}train.csv {save}tr.gbdt.out {save}tr.sp'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('gbdt features added to train dataSet\n')
cmd = 'feature_engineering/converters/parallelizer-b.py -s {nr_thread} feature_engineering/converters/pre-b.py {data}test.tmp.csv {save}te.gbdt.out {save}te.sp'.format(nr_thread=NR_THREAD,data=data_path,save=save_path)
subprocess.call(cmd, shell=True)
print('gbdt features added to test dataSet\n')
print('gbdt process completed!')
cmd = './utils/ffm -k 4 -t 11 -s {nr_thread} {save}te.sp {save}tr.sp'.format(nr_thread=NR_THREAD,save=save_path)
subprocess.call(cmd, shell=True)
cmd
def build_upload_controller(config, base_controller_name):
    config['controller_name'] += 'Controller'
    controller_name = config['controller_name']
    config['base_controller_name'] = base_controller_name
    path = os.path.join(config['product']['path'], "www\\controller", controller_name + ".php")
    controller_filename = path
    create_file_from_template("upload_controller.tpl.php", config, controller_filename)
    return controller_filename
def build_controller_by_config(config):
    controller_file = build_upload_controller(config, 'AbBaseController')
    return controller_file
def load_upload_config():
    parser = OptionParser()
    parser.add_option("-n", "--name", action="store",
                  dest="controller_name", help="Provide controller name")
    parser.add_option("-f", "--filename-pattern", action="store", default='',
                  dest="filename_pattern", help="Provide filename pattern")
    parser.add_option("-s", "--subdir-pattern", action="store",
  
"""Base implementation classes.
The public-facing ``Events`` serves as the base class for an event interface;
its public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.
"""
    _EmptyListener, _ClsLevelDispatch
_registrars = util.defaultdict(list)
def _is_event_name(name):
    return not name.startswith('_') and name != 'dispatch'
class _UnpickleDispatch(object):
    """Serializable callable that re-generates an instance of
    :class:`_Dispatch` given a particular :class:`.Events` subclass.
    """
    def __call__(self, _instance_cls):
        for cls in _instance_cls.__mro__:
            if 'dispatch' in cls.__dict__:
                return cls.__dict__['dispatch'].\
                    dispatch_cls._for_class(_instanc

        else:
            raise AttributeError("No class with a 'dispatch' member present.")
class _Dispatch(object):
    """Mirror the event listening definitions of an Events class with
    listener collections.
    Classes which define a "dispatch" member will return a
    non-instantiated :class:`._Dispatch` subclass when the member
    is accessed at the class level.  When the "dispatch" member is
    accessed at the instance level of its owner, an instance
    of the :class:`._Dispatch` class is returned.
    A :class:`._Dispatch` class is generated for each :class:`.Events`
    class defined, by the :func:`._create_dispatcher_class` function.
    The original :class:`.Events` classes remain untouched.
    This decouples the construction of :class:`.Events` subclasses from
    the implementation used by the event internals, and allows
    inspecting tools like Sphinx to work in an unsurprising
    way against the public API.
    """
    __slots__ = '_parent', '_instance_cls', '_

    _empty_listener_reg = weakref.WeakKeyDictionary()
    def __init__(self, parent, instance_cls=None):
        self._parent = parent
        self._instance_cls = instance_cls
        if instance_cls:
            try:
                self._empty_listeners = self._empty_listener_reg[instance_cls]
            except KeyError:
                self._empty_listeners = \
                    self._empty_listener_reg[instance_cls] = dict(
                        (ls.name, _EmptyListener(ls, instance_cls))
                        for ls in parent._event_descriptors
                    )
        else:
            self._empty_listeners = {}
    def __getattr__(self, name):
        try:
            ls = self._empty_listeners[name]
        except KeyError:
            raise AttributeError(name)
        else:
            setattr(self, ls.name, ls)
            return ls
    @property
    def _event_descriptors(self):
        for k in self._event_names:
            yield getattr(self, k)
    def _fo
CONFIG = bottle.default_app().config
CONFIG.load_config('config.ini')
bottle.install(CSP.Plugin())
bottle.debug(True)
@bottle.route("/")
@bottle.view("search")
def index():
    return dict(
        Overlays=Overlays,
    )
@bottle.route("/<repository>")
@bottle.view("list_of_categories")
def list_of_categories(repository):
    if repository not in Trees.repositories():
        raise bottle.HTTPError(404, "Not found")
    return dict(
        Overlays=Overlays,
        Repository=Repository(repository),
    )
@bottle.route("/<repository>/<category:re:[\w+][\w+.-]*>")
@bottle.view("list_of_packages")
def list_of_packages(repository, category):
    if repository not in Trees.repositories():
        bottle.abort(404, "Not found")
    if category not in Repository(repository).categories():
        bottle.abort(404, "Not found")
    return dict(
        Overlays=Overlays,
        Category=Category(repository, category),
    )
@bottle.route("/<repository>/<category:re:[\w+][\w+.-]*>/<package:
def run_rules_engine():
    if CONTEXT['dry_run']:
        LOGGER.info('(dry run) RULES_ENGINE_NODES: %s' % CONTEXT['RULES_ENGINE_NODES'])
        return
    threads = []
    today = int(round(time.mktime(CONTEXT['today'].timetuple())))
    all_network_list = []
    for node in CONTEXT['RULES_ENGINE_NODES']:
        all_network_list.extend(node['networks'])
        broker = RulesEngineBroker(LOGGER, node['host'], node['port'], CONFIG, today)
        threads.append(broker)
    
    lock = threading.Lock()
    distributer = Distributer_Broker(all_network_list,threads,lock)    
    distributer.work()
    errors = distributer.errors
    
        for error in errors:
            LOGGER.error(error)
        if CONFIG.has_key('SEND_NOTIFICATION_TO'):
            send_notification_mail(to_addrs=CONFIG['SEND_NOTIFICATION_TO'], body='\n'.join(errors))
    
    
        to_addrs = 'Eng-Core-RPM'
        cc_addrs = 'Eng-RPMA'
        subject = 'Rules Engine Module %s Fail Notification @%s' % (CALC

        body = '''Hi all,\n\nSorry to inform you that Rules Engine failed during today's daily job.\n\nImpacted networks:\n%s\n\nThis email is sent automatically to give a head-up in time, and Eng will investigate and update ASAP.\n\nSorry for the inconvenience.\n\nThanks,\nRules Engine''' % '\n'.join(map(str, failed_networks))
        send_mail(to_addrs, cc_addrs, subject, body, 'plain')
    LOGGER.info('All rules engine instance(s) job done, res = %s', CONTEXT['plans'])
class Distributer_Broker():
    def __init__(self, network_list,broker_list,lock):
        global g_network_list
        g_network_list = network_list
        self.broker_list = broker_list
        self.failed_networks = set()
        self.errors = []
    def work(self):
        broker_num = len(self.broker_list)
        while g_network_list:
            for i in range(broker_num):   
                if self.broker_list[i].isAlive():
                    continue
                if self.broker_list[i].failed_network:


                    if not self.broker_list[i].data:
                        self.errors.append('Rules engine %s failed' % self.broker_list[i].host)
                    else:
                        plan = self.broker_list[i].data
                        network = plan['network_id']
                        version = plan['plan_version'].get(CALCULATION_MODULE, -1)
                        if version > 0:
                            CONTEXT['plans'][network] = version
                        else:
                            errors.append('Rules engine %s Module for network %d failed' 
                                % (self.broker_list[i].host, network))
                host, port = self.broker_list[i].get_host_port()  
                today = int(round(time.mktime(CONTEXT['today'].timetuple())))
                self.broker_list[i].start()
def distributer_broker(broker_list)
    broker_num = len(broker_list)
    failed_networks = set()
    errors = []
    lock = threading.Lock()
    
 
def test_holiday_title_for_new_year():
    bot = HolidayBot()
    assert "New Year's Day" == bot.holiday_title(date(2016, 1, 1))
def test_holiday_title_for_day_after_new_year():
    bot = HolidayBot()
    assert bot.holiday_title(date(2016, 1, 2)) is None
@patch("stupid.holidaybot.datetime.date")
def test_next_week_holiday_announcement(mock_date):
    mock_date.today.return_value = date(2016, 1, 11)
    broker = MagicMock(spec=SlackBroker)
    bot = HolidayBot(broker=broker)
    bot.post_next_week_holiday()
    broker.post.assert_called_once_with(
        "On the next week Monday, January 18 is day off - Birthday of Martin Luther King, Jr.",
        color='info'
    )
@patch("stupid.holidaybot.datetime.date")
def test_holiday_trigger(mock_date):
    mock_date.today.return_value = date(2016, 1, 11)
    broker = MagicMock(spec=SlackBroker)
    bot = HolidayBot(broker)
    bot.on_message(1, {"user": "x", "text": "@stupid: What are next holidays?"})
    broker.post.assert_called_once_with(
        
class ManageMachinesItem(BaseItem):
    def __init__(self):
        BaseItem.__init__(self, 'manage machines', 'system',
                          'manage machines', 'manage machines')
class ManageMachinesAction(BaseAction):
    def __init__(self, slot, parent):
        BaseAction.__init__(self, ManageMachinesItem(), 'ManageMachines', slot, parent)
class ManageDiskConfigItem(BaseItem):
    def __init__(self):
        comment = 'manage diskconfig'
        BaseItem.__init__(self, comment, 'blockdevice', comment, comment)
class ManageDiskConfigAction(BaseAction):
    def __init__(self, slot, parent):
        BaseAction.__init__(self, ManageDiskConfigItem(), 'ManageDiskConfig',
                            slot, parent)
        
class ManageKernelsItem(BaseItem):
    def __init__(self):
        comment = 'manage kernels'
        BaseItem.__init__(self, comment, 'memory', comment, comment)
class ManageKernelsAction(BaseAction):
    def __init__(self, slot, parent):
        BaseActio
class GithubUtilsTestCase(TestCase):
    def setUp(self):
        self.username = 'dobestan'
        self.github_repository = GithubRepository(self.username)
        self.valid_github_repository_url = "https://github.com/dobestan/awesome-dobestan"
        self.valid_raw_readme_url = "https://raw.githubusercontent.com/dobestan/awesome-dobestan/master/README.md"
        self.invalid_username = 'invalid_dobestan'
        self.invalid_github_repository = GithubRepository(self.invalid_username)
    def test_get_repository_url(self):
        self.assertEqual(
            self.github_repository.get_repository_url(),
            self.valid_github_repository_url,
        )
    def test_is_repository_valid(self):
        self.assertTrue(
            self.github_repository.is_repository_valid(),
        )
        self.assertFalse(
            self.invalid_github_repository.is_repository_valid(),
        )
    def test_get_raw_readme_url(self):
        raw_readme_url = self.github_repository.get_r
"""
Environment variables:
    HUBSERVER_CONF      default: /var/lib/hubclient/server.conf
    BROKER_HOST         default: amq.turnkeylinux.org
    BROKER_PORT         default: 5672
    BROKER_USER         default: server
    BROKER_PASSWORD     default: server
    BROKER_VHOST        default: /hub
"""
class HubServerConf(ConfFile):
    SET_ENVIRON = True
    CONF_FILE = os.getenv('HUBSERVER_CONF', '/var/lib/hubclient/server.conf')
class HubAMQConf(dict):
    def __init__(self):
        self['broker_host'] = os.getenv('BROKER_HOST', 'amq.turnkeylinux.org')
        self['broker_port'] = os.getenv('BROKER_PORT', '5672')
        self['broker_user'] = os.getenv('BROKER_USER', 'server')
        self['broker_password'] = os.getenv('BROKER_PASSWORD', 'server')
        self['broker_vhost'] = os.getenv('BROKER_VHOST', '/hub')
        for key in self:
            os.environ[key.upper()] = self[key]
    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError
class Ui_VcsRepositoryInfoDialog(object):
    def setupUi(self, VcsRepositoryInfoDialog):
        VcsRepositoryInfoDialog.setObjectName("VcsRepositoryInfoDialog")
        VcsRepositoryInfoDialog.resize(590, 437)
        VcsRepositoryInfoDialog.setSizeGripEnabled(True)
        self.vboxlayout = QtWidgets.QVBoxLayout(VcsRepositoryInfoDialog)
        self.vboxlayout.setObjectName("vboxlayout")
        self.infoBrowser = QtWidgets.QTextEdit(VcsRepositoryInfoDialog)
        self.infoBrowser.setReadOnly(True)
        self.infoBrowser.setObjectName("infoBrowser")
        self.vboxlayout.addWidget(self.infoBrowser)
        self.buttonBox = QtWidgets.QDialogButtonBox(VcsRepositoryInfoDialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Close)
        self.buttonBox.setObjectName("buttonBox")
        self.vboxlayout.addWidget(self.buttonBox)
        self.retranslateUi(VcsRepositoryInfoDialog)
        self.buttonB
class Command:
	routes = {
		'login': { 'controller':UsersController, 'method':'login' },
		'help': { 'controller':HelpsController, 'method':'show' },
		'create world': { 'controller':WorldsController, 'method':'create' },
	}
	callback = None
	def __init__(self, Game):
		self.Game = Game
		return
	def init(self):
		return
	def run(self, request, command):
		request.send('Command: "%s"\n\r' % command)
		if self.callback:
			self.callback(command)
			self.callback = None
			return
		prefix = False
		args = command.split(' ')
		if args[0].lower() == 'admin':
			prefix = 'admin'
			command = ' '.join(args[1:])
		if command not in self.routes:
			print('Unknown command, command not mapped')
			request.send('Unknown command')
			return
		route = self.routes[command]
		controller = route['controller'](self.Game)
		method = route['method'];
		if prefix:
			method = prefix+'_'+method
		controller.requester(request)
		getattr(controller, method)()
	def hook(self, method):
		self.callback = metho
def worker_routine():
  thread_name = threading.currentThread().getName()
  ctx = zmq.Context()
  worker = ctx.socket(zmq.REQ)
  worker.setsockopt(zmq.IDENTITY, thread_name)
  worker.connect('tcp://localhost:5555')
  print 'worker [%s] init success ...' % thread_name
  total = 0
  random.seed()
  while True:
    worker.send('Hi Boss')
    workload = worker.recv()
    if workload == 'Fired!':
      print 'worker [%s] completed: %d tasks' % (thread_name, total)
      break
    total += 1
    
    time.sleep(random.randint(1, 1000) * 0.0001)
  worker.close()
if __name__ == '__main__':
  if (len(sys.argv) < 2):
    print 'arguments error ...'
    exit()
  
  ctx = zmq.Context()
  broker = ctx.socket(zmq.ROUTER)
  broker.bind('tcp://*:5555')
  for _ in range(int(sys.argv[1])):
    threading.Thread(target=worker_routine, args=()).start()
  
  for _ in range(int(sys.argv[1]) * 50):
    addr = broker.recv()
    empty = broker.recv()
    ready = broker.recv()
    broker.send(addr, zmq.SNDMORE)

CONFIG = {
    'WORKER': {
        'HEARTBEAT_LIVENESS': 5,
        'HEARTBEAT_INTERVAL': 1000
    },
    'CLIENT': {
        'HEARTBEAT_LIVENESS': 5,
        'HEARTBEAT_INTERVAL': 1000
    },
    'BROKER': {
        'HEARTBEAT_LIVENESS': 5,
        'HEARTBEAT_INTERVAL': 1000
    }
class Manager(Base):
    HEARTBEAT_LIVENESS = 5
    HEARTBEAT_INTERVAL = 1000
    HEARTBEAT_EXPIRY = HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS
    def __init__(self, identity, conf_uri, ctrl_uri):
        self.identity = identity
        self.started = False
        self.conf_uri = conf_uri
        self.ctrl_uri = ctrl_uri
        self._cur_worker_idx = 0
        self._cur_client_idx = 0
        self._resmgr = ResourceManager()
        self.heartbeat_at = time.time() + 1e-3*self.HEARTBEAT_INTERVAL
        self.init()        
    def init(self):
        self._clients = {}
        self._workers = {}
        self._brokers = {}
        self.ctx = zmq.Context()
        self.conf_rut = self.ctx.socket(zmq.ROUTER)
  

        self.ctrl_pub = self.ctx.socket(zmq.PUB)
        self.ctrl_pub.bind(self.ctrl_uri)
        self.state_sub = self.ctx.socket(zmq.SUB)
        self.state_sub.setsockopt_string(zmq.SUBSCRIBE, u'')
        self.poller = zmq.Poller()
        self.poller.register(self.conf_rut, zmq.POLLIN)
        self.poller.register(self.state_sub, zmq.POLLIN)
    def publish_control(self, topic, msg):
        logging.debug('publish control %s => %s' %  (topic, msg))
        to_send = [topic, self.identity, dumps(msg)]
        self.ctrl_pub.send_multipart(to_send)
    def heartbeat(self):
        bw = []
        peers = self._resmgr.peers
        for bid in peers:
            broker = peers[bid]
            if not broker.isalive():
                bw.append((bid, broker))
        for bid, broker in bw:
            self.publish_control('broker.failure', {'identity': bid})
            self._resmgr.remove_peer(bid)
    def get_broker_uri(self, role):
        m = None
        broker = None
        pee

        for bid in peers:
            b = peers[bid]
            if role == 'WORKER':
                num = b.worker_total
            elif role == 'CLIENT':
                num = b.client_total
            else:
                break
            if m is None or m > num:
                m = num
                broker = b
        if not broker:
            return None
        if role == 'WORKER':
            addr = broker.worker_uri
        else:
            addr = broker.client_uri
        return addr
    def get_conf(self, role, identity):
        conf = CONFIG.get(role).copy()
        conf['ctrl_uri'] = self.ctrl_uri
        if role == 'WORKER':
            conf['broker_uri'] = self.get_broker_uri(role)
        elif role == 'CLIENT':
            conf['broker_uri'] = self.get_broker_uri(role)
        elif role == 'BROKER':
            pass
        if role != 'BROKER':
            print 'get_broker %s %s' % (identity, conf['broker_uri'])
        return conf
    def send_reply(self, ad
'''
Created on Sep 11, 2014
@author: drury
'''
class RepositoryTest(unittest.TestCase):
    '''
    Class created to test the Repository class
    '''
    def setUp(self):
        self.testRepository = repository.Repository(2)
        
    def testInstantiateRep200(self):
        testRepository = repository.Repository(200)    
    
    def testGetNumberComponents(self):
        return self.testRepository.count()
    
    def testRepositoryNoParam(self):
        self.testRepository = repository.Repository()
        
    def testRepositoryCap2(self):
        self.testRepository = repository.Repository(2)
        
    def testAddComponent(self):
        self.testRepository = repository.Repository(2)
        C1 = component.Component("C1",4,20)
        self.testRepository.addComponent(C1)
        
    
        
    def testExceptionCapacity0(self):
        expectedString = "Repository.__init__: The capacity needs to be grand than 0"        
        try:
            testRepository = reposito

            self.fail("exception was not raised")
        except ValueError as raisedException:
            diagnosticString = raisedException.args[0]
            self.assertEquals(expectedString, diagnosticString[0:len(expectedString)])
        except:
            self.fail("incorrect exception was raised")    
    
    def testCompleteRepository2(self):
        C2 = component.Component("C2",4,40)
        C3 = component.Component("C3",1,20)
        self.testRepository.addComponent(C2)
        self.testRepository.addComponent(C3)
        
    def testValidCountRepository(self):
        C2 = component.Component("C2",4,40)
        C3 = component.Component("C3",1,20)
        self.testRepository.addComponent(C2)
        self.testRepository.addComponent(C3)
        return self.testRepository.validCount()
    
    def testExceptionAddComponentNoParam(self):
        expectedString = "Repository.addComponent: The method addComponent needs a parameter"        
        try:
            self.tes

            self.fail("exception was not raised")
        except ValueError as raisedException:
            diagnosticString = raisedException.args[0]
            self.assertEquals(expectedString, diagnosticString[0:len(expectedString)])
        except:
            self.fail("incorrect exception was raised")
    
    
    
        
    def testRelativeSizes(self):
        self.testRepository = repository.Repository(5)
        component1 = component.Component(name="Component01",methodCount=1,locCount=76)
        component2 = component.Component("Component02",locCount=116,methodCount=4)
        component3 = component.Component("Component03",7,locCount=113)
        component4 = component.Component("Component04",5,103)
        component5 = component.Component("Component5",0,10)
        self.testRepository.addComponent(component1)
        self.testRepository.addComponent(component2)
        self.testRepository.addComponent(component3)
        self.testRepository.addComponent(component4)
  
UNKNOWN_STRING = "unk"
UNKNOWN_PROPERTY = "UNK"
class BaseCleaner(object):
    def __init__(
            self,
            data_path,
            broker_labeller_path,
            property_labeller_path):
        self.data_path = data_path
        self.data = self.load_data(data_path)
        self.broker_labeller_path = broker_labeller_path
        self.broker_labeller = \
                self.load_broker_labeller_data(broker_labeller_path)
        self.property_labeller_path = property_labeller_path
        self.property_labeller = \
                self.load_property_labeller_data(property_labeller_path)
        self.required_fields = [
            "bathrooms", "bedrooms", "broker", "latitude", "longitude",
            "photoCount", "price", "propertySize", "propertyType"]
    def load_data(self, path):
        with open(path, "r") as f:
            return json.load(f)
    def load_broker_labeller_data(self, path):
        with open(path, "r") as f:
            return json.load(f)
  

        if broker_string:
            if broker_string.lower() in self.broker_labeller:
                return self.broker_labeller[broker_string.lower()]
            else:
                return self.broker_labeller[UNKNOWN_STRING]
        else:
            return self.broker_labeller[UNKNOWN_STRING]
    def load_property_labeller_data(self, path):
        with open(path, "r") as f:
            return json.load(f)
    def label_property(self, property_string):
        if property_string:
            if property_string in self.property_labeller:
                return self.property_labeller[property_string]
            else:
                return self.property_labeller[UNKNOWN_PROPERTY]
        else:
            return self.property_labeller[UNKNOWN_PROPERTY]
    def is_valid_entity(self, entity):
        mandatory_fields = \
            ["bathrooms", "bedrooms", "latitude", "longitude",
             "price", "propertySize"]
        for field in mandatory_fields:
            if entit

                return False
        return True
    def filter_attributes(self, entity):
        new_entity = {}
        for field in self.required_fields:
            new_entity[field] = entity[field]
        return new_entity
    def normalize_attributes(self, entity):
        entity["broker"] = self.label_broker(entity["broker"])
    def normalize_entity(self, field, mini, maxi, entity):
        if maxi is not mini:
            entity[field] = float(entity[field] - mini) / float(maxi - mini)
    def normalize_data(self, cleaned_data):
        """
        Min-max normalization
        """
        normalized_fields = [
            "bathrooms", "bedrooms", "broker", "latitude", "longitude",
            "photoCount", "propertySize", "propertyType"]
        min_max_map = {}
        for field in normalized_fields:
            mini = min(cleaned_data, key=lambda x: x[field])[field]
            maxi = max(cleaned_data, key=lambda x: x[field])[field]
            min_max_map[field] = (mini,
log = logging.getLogger(__name__)
class InstallTestRepositories( InstallTestRepository ):
    """Abstract test case that installs and uninstalls a predefined list of repositories."""
    def do_installation( self, repository_info_dict ):
        self.logout()
        self.login( email='test@bx.psu.edu', username='test' )
        admin_user = test_db_util.get_user( 'test@bx.psu.edu' )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        self.install_repository( repository_info_dict )
    def do_uninstallation( self, repository_info_dict, deactivate_only=False ):
        self.logout()
        self.login( email='test@bx.psu.edu', username='test' )
        admin_user = test_db_util.get_user( 'test@bx.psu.edu' )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        repository = test_db

                                                                                             repository_info_dict[ 'owner' ],
                                                                                             repository_info_dict[ 'changeset_revision' ] )
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        self.uninstall_repository( repository, deactivate_only )
def generate_install_method( repository_dict=None ):
    """Generate abstract test cases for the defined list of repositories."""
    if repository_dict is None:
        return
    G = globals()
    for key, val in G.items():
        if key.startswith( 'TestInstallRepository_' ) or key.startswith( 'TestUninstallRepository_' ) or key.startswith( 'TestForTool_' ):
            del G[ key ]
    name = "TestInstallRepository_" + repository_dict[ 'name' ]
    baseclasses = ( InstallTestRepositories, )
    namespace = dict()
    def make_install_method( repository_dict ):
        def test_i

            self.do_installation( repository_dict )
        return test_install_repository
    test_method = make_install_method( repository_dict )
    test_method.__doc__ = "Install the repository %s from %s." % ( repository_dict[ 'name' ], repository_dict[ 'tool_shed_url' ] )
    namespace[ 'install_repository_%s' % repository_dict[ 'name' ] ] = test_method
    new_class_obj = new.classobj( name, baseclasses, namespace )
    G[ name ] = new_class_obj
def generate_uninstall_method( repository_dict=None, deactivate_only=False ):
    """Generate abstract test cases for the defined list of repositories."""
    if repository_dict is None:
        return
    G = globals()
    for key, val in G.items():
        if key.startswith( 'TestInstallRepository_' ) or key.startswith( 'TestForTool_' ):
            del G[ key ]
    name = "TestUninstallRepository_%s_%s" % ( repository_dict[ 'name' ], repository_dict[ 'changeset_revision' ] )
    baseclasses = ( InstallTestRepositories, )
    namespac
model = None
repository = None 
logger = None
repositoryDirectory = ''
def start(mainviewModel):
    global model
    global repository
    global logger 
     
    model = mainviewModel
    logger = model.get_logger()
    set_logger(logger)
    
    model.tabs.set_logger(logger)
    repository = FavoritesRepository(logger)
    tabcontroller.start(model.tabs)
def new_repository(directory):
    result = repository.new_repo(directory)
    if(not result):
        logger.error(__name__, 'new_repository', 'repository was not created, stopping')
        return
    repository.add_favorite(directory, 'example', 'the title of the example')
    repository.save_favorite(directory, 'example', 'a new title')
    open_repository(directory)
    
def open_repository(directory):
    global repositoryDirectory
    repositoryDirectory = directory
    
    favorites = repository.get_favorites_root(directory)
    repository.sync(directory)
    model.set_favorites(favorites)
    logger.set_commits(repositor

    
def add_child(node):
    logger.clear()
    
    name = str(random.randrange(100000))
    title = 'atitle'
    
    repository.add_favorite(repositoryDirectory, name, title,  node.getFullPath() + '/')
    favorite = Favorite(title, name)
    favorite.parent = node     
    
    logger.set_commits(repository.get_commits(repositoryDirectory))
    return favorite
def save(node, newTitle='', page = None):
    logger.clear()
    
    logger.info(__name__, 'save', node.to_string()) 
    
    if not newTitle == '':
        repository.save_favorite(repositoryDirectory, node.getFullPath(), newTitle)
    elif not page == None:
        repository.save_favorite(repositoryDirectory, node.getFullPath(), page = page)
        
    logger.set_commits(repository.get_commits(repositoryDirectory))
    
def rollback(commit = None):
    logger.clear()
    repository.rollback(repositoryDirectory, commit)
    open_repository(repositoryDirectory)
        
def delete(node):
    logger.clear()
    reposito
@six.add_metaclass(BasicTestsMetaclass)
class ResourceTests(BaseWebAPITestCase):
    """Testing the RepositoryInfoResource APIs."""
    fixtures = ['test_users', 'test_scmtools']
    sample_api_url = 'repositories/<id>/info/'
    resource = resources.repository_info
    def setup_http_not_allowed_list_test(self, user):
        repository = self.create_repository(tool_name='Test')
        return get_repository_info_url(repository)
    def setup_http_not_allowed_item_test(self, user):
        repository = self.create_repository(tool_name='Test')
        return get_repository_info_url(repository)
    def compare_item(self, item_rsp, info):
        self.assertEqual(item_rsp, info)
    def setup_basic_get_test(self, user, with_local_site, local_site_name):
        repository = self.create_repository(tool_name='Test',
                                            with_local_site=with_local_site)
        return (get_repository_info_url(repository, local_site_name),
                repository_in
urls=(
    '/list','get_credit_manage_list',
    '/create','create_credit_manage',
    '/(\d+)','manage_credit_manage'
credit_manage=models.credit_manage()
"""只返回id,公司名称，公司法人"""
class get_credit_manage_list:
    def GET(self):
        try:
            params=web.input()
            credit_type=params.credit_type
            page=params.page if hasattr(params, 'page') else 1
            perpage = params.perpage if hasattr(params, 'perpage') else 10
            return json.dumps(credit_manage.get_credit_manage_list_paged(credit_type,page,perpage),
                              cls=encoder.DateEncoder,ensure_ascii=False)
        except:
            return sr.show_result_fail()
        
"""新增贷前调查表"""
class create_credit_manage:
    
    def POST(self):
        json_data=json.loads(web.data())
        my_credit_manage=credit_manage.set_data(json_data)
        result=credit_manage.create_credit_manage(my_credit_manage)
        return sr.show_result(result)
"""管理贷前调查表"""
class manage_credit_m
class TestEventService(TestCase):
    def setUp(self):
        self.event_repository = MagicMock(EventRepository, name='event_repository')
        self.user_repository = MagicMock(UserRepository, name='user_repository')
        self.service = EventService(
            event_repository=self.event_repository,
            user_repository=self.user_repository
        )
    def test_list_events(self):
        events = self.service.list_events()
        self.assertIsNotNone(events)
class TestAttendanceService(TestCase):
    def setUp(self):
        self.event_repository = MagicMock(EventRepository,
                                          name='event_repository')
        self.user_repository = MagicMock(UserRepository, name='user_repository')
        self.user_repository.find_user_by_email.return_value = None
        self.user_repository.create_user = MagicMock(User)
        self.service = AttendanceService(
            event_repository=self.event_repository,
            user_repository=sel
@pytest.fixture
def broker_url():
    return "tcp://localhost:6666"
class TestMajorDomoWorker():
    def test_instantiate(self, broker_url):
        """Test instantiating worker model"""
        service_name = b"echo"
        verbose = False
        w = MajorDomoWorker(broker_url, service_name, verbose)
        assert w.broker == broker_url
        assert w.service == service_name
        assert w.verbose == verbose
        assert isinstance(w.ctx, zmq.Context)
        assert isinstance(w.poller, zmq.Poller)
    @pytest.mark.xfail
    def test_send_to_broker_model(self, broker_url):
        """Test send message to broker"""
        b = MajorDomoBroker(False)
        w = MajorDomoWorker(broker_url, b"echo", False)
        w.send_to_broker(constants.W_REQUEST, b.service, [b"test"])
    @pytest.mark.xfail
    def test_reconnect_to_broker_model(self, broker_url):
        """Test reconnecting to broker"""
        b = MajorDomoBroker(False)
        w = MajorDomoWorker(broker_url, b"echo", Fa
__author__ = 'Luka Strizic'
class Dose:
    def __init__(self, document):
        assert(isinstance(document, DoseDocument))
        self.document = document
    def __getitem__(self, item):
        ret = None
        try:
            ret = self.document[str(item)]
        except:
            pass
        return ret
    def save(self):
        self.document.save()
    def setInstitutionID(self, id, save=False):
        self.document['institutionID'] = str(id)
        if(save): self.save()
        return
    def setAB0(self, ab0, save=False):
        self.document['AB0'] = str(ab0)
        if(save): self.save()
        return
    def setRh(self, rh, save=False):
        self.document['RH'] = str(rh)
        if(save): self.save()
        return
    def setAvailable(self, save = False):
        self.document['status'] = 'available'
        if(save): self.save()
        return
    def setUnhealthy(self, save = False):
        self.document['status'] = 'unhealthy'
        if(save): self.sav
class CAE_Save(object):
  def __init__(self,
               save_fig_name='results',
               save_cae_name='cae'
               ):
    self.save_fig_name = save_fig_name
    self.save_cae_name = save_cae_name
  def save_fig(self, target, reconstruction):
    fig = plt.figure(1, (1,2))
    grid = ImageGrid(fig, 111, nrows_ncols = (1, 2), axes_pad=0.1)
    grid[0].imshow(target)
    grid[1].imshow(reconstruction)
    plt.savefig(self.save_fig_name)
    
  def save_cae(self,
               W,
               c,
               b,
               n_hidden,
               learning_rate,
               jacobi_penalty,
               batch_size,
               epochs,
               schatten_p,
               loss,
               X ):
    CAE_params = numpy.array([n_hidden,
               learning_rate,
               jacobi_penalty,
               batch_size,
               epochs,
               schatten_p,
               loss])
    numpy.savez(self.save_cae_name,
                W=W, c
urlpatterns = patterns('',
    url(r'^api/registration/$', views.api_registration ,name='api_registration'),
    url(r'^api/facebook_auth/$', views.facebook_auth ,name='facebook_auth'),
    url(r'^api/v1/login/$', views.api_v1_login ,name='api_login'),
    url(r'^api/v1/home/$', views.api_v1_home ,name='api_home'),
    url(r'^api/v1/logout/$', views.api_v1_logout ,name='api_logout'),
    url(r'^api/v1/my_events/$', views.api_v1_my_events ,name='api_my_events'),
    url(r'^api/v1/events/$', views.api_v1_events ,name='api_events'),
    url(r'^api/v1/my_coupons/$', views.api_v1_my_coupons ,name='api_my_coupons'),
    url(r'^api/v1/coupons/$', views.api_v1_coupons ,name='api_coupons'),
    url(r'^api/v1/leaderboard/$', views.api_v1_leaderboard ,name='api_leaderboard'),
    url(r'^api/v1/history_events/$', views.api_v1_history_events ,name='api_history_events'),
    url(r'^api/v1/history_coupons/$', views.api_v1_history_coupons ,name='api_history_coupons'),
    url(r'^api/v2/login/$', views
class Server(object):
    app = Flask(__name__)
    app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'
    app.register_blueprint(ServerController)
    app.register_blueprint(ChartController)
    app.register_blueprint(DataController)
    app.register_blueprint(DashboardController)
    app.register_blueprint(UserController)
    app.register_blueprint(ChartViewController)
    app.register_blueprint(ServerViewController)
    app.register_blueprint(DashboardViewController)
    app.register_blueprint(UserViewController)
    @app.route('/')
    def index():
        if 'username' not in session:
                return redirect(url_for('login'))
        return render_template('index.html')
    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            username = request.form['username']
            password = request.form['password']
            result = AuthenticationGateway().authenticate(username,password)
            if result is "true":
log = logging.getLogger('worker.broker')
class BrokerConnection(object):
    def __init__(self):
        self.host = settings.BROKER_SETTINGS.get("BROKER_HOST", '')
        self.port = settings.BROKER_SETTINGS.get("BROKER_PORT", '')
        self.virtual_host = settings.BROKER_SETTINGS.get("BROKER_VHOST", '')
        self.user = settings.BROKER_SETTINGS.get("BROKER_USER", '')
        self.password = settings.BROKER_SETTINGS.get("BROKER_PASSWORD", '')
    def connect_to_broker(self):
        """Returns connection object,
        """
        try:
            credentials = PlainCredentials(self.user, self.password)
            parameters = ConnectionParameters(host=self.host,
                                              port=self.port,
                                              virtual_host=self.virtual_host,
                                              credentials=credentials,
                                              heartbeat_interval=0)
            connection = BlockingConnect
web.config.dbpath = "sqlite:///db/app.db"
urls = (
	'/', 'controllers.main_controller.Index',
	'/archives', 'controllers.main_controller.Archives',
	'/archives/(.+)/(.+)/(.+)/(.+)', 'controllers.main_controller.ArchivePageYearMonthDay', 	
	'/archives/(.+)/(.+)/(.+)', 'controllers.main_controller.ArchivePageYearMonth',
	'/archives/(.+)/(.+)', 'controllers.main_controller.ArchivePageYear',
	'/archives/(.+)', 'controllers.main_controller.ArchivePage', 	 
	'/contact', 'controllers.main_controller.Contact',
	'/posts', 'controllers.main_controller.Index',
	'/posts/(.+)', 'controllers.main_controller.PostSlug',
	'/topics/(.+)/(.+)', 'controllers.main_controller.Topic',
	'/search', 'controllers.main_controller.Search', 		
	'/admin', 'controllers.admin_controller.Index',
	'/admin/posts/new', 'controllers.admin_controller.NewPost',
	'/admin/posts/edit/(.+)', 'controllers.admin_controller.EditPost',
	'/admin/posts/destroy/(.+)', 'controllers.admin_controller.DeletePost',
	'/admin/posts', 'control

	'/admin/posts/(.+)', 'controllers.admin_controller.Posts', 	
	 
	'/admin/pages/new', 'controllers.admin_controller.NewPage',
	'/admin/pages/edit/(.+)', 'controllers.admin_controller.EditPage',
	'/admin/pages/destroy/(.+)', 'controllers.admin_controller.DeletePage',	
	'/admin/pages', 'controllers.admin_controller.Pages',
	'/admin/pages/(.+)', 'controllers.admin_controller.Pages', 	
	 
	'/admin/topics', 'controllers.admin_controller.Topics',
	'/admin/topics/destroy/(.+)', 'controllers.admin_controller.DeleteTopic',
	'/admin/settings', 'controllers.admin_controller.Settings',
	 
	'/sitemap.xml', 'controllers.api_controller.Sitemap',
	'/sitemap', 'controllers.api_controller.Sitemap',
	'/sitemap.xsd', 'controllers.api_controller.Sitemap',
	'/sitemap.xsl', 'controllers.api_controller.SitemapStyle',
	'/rsd.xml', 'controllers.api_controller.Rsd',
	'/rsd.axd', 'controllers.api_controller.Rsd',
	'/wlwmanifest.xml', 'controllers.api_controller.Wlwmanifest',
	'/metaweblog.xml', 'controllers.api_
class Settings():
    def __init__(self, settings):
        self.CRONJOBS = getattr(settings, 'CRONJOBS', [])
        self.CRONTAB_EXECUTABLE = getattr(settings, 'CRONTAB_EXECUTABLE', '/usr/bin/crontab')
        self.DJANGO_PROJECT_NAME = getattr(settings, 'CRONTAB_DJANGO_PROJECT_NAME', os.environ['DJANGO_SETTINGS_MODULE'].split('.')[0])
        self.DJANGO_SETTINGS_MODULE = getattr(settings, 'CRONTAB_DJANGO_SETTINGS_MODULE', None)
        if hasattr(settings, 'CRONTAB_DJANGO_MANAGE_PATH'):
            self. DJANGO_MANAGE_PATH = settings.CRONTAB_DJANGO_MANAGE_PATH
            if not os.path.exists(self.DJANGO_MANAGE_PATH):
                print('ERROR: No manage.py file found at "%s". Check settings.CRONTAB_DJANGO_MANAGE_PATH!' % self.DJANGO_MANAGE_PATH)
        else:
            def ext(fpath):
                return os.path.splitext(fpath)[0] + '.py'
            except ImportError:
                except ImportError:
                    print('ERROR: Can\'t find your manage.py - plea
    sql="SELECT priority,project,username,start_date,expect_launch_date,real_launch_date FROM manage_s_user,manage_s_project WHERE manage_s_project.leader_p_id=manage_s_user.id"
	cur = connection.cursor()
	cur.execute(sql)
	result = cur.fetchall()
	return render_to_response("funBlog.html", locals(),context_instance=RequestContext(request))
sql="SELECT username FROM manage_s_user,manage_s_project WHERE manage_s_project.leader_p_id=manage_s_user.id;"
	cur = connection.cursor()
	cur.execute(sql)
	for res2 in puser:
        for res2.project_id in result.id:
            for res2.username_id in res1.id:
                realname=username.realname
                rs=[]
                dic = {'realname':realname}
                rs.append(dic)
    rrs = {"username":rs}
     {% for i in pname %}
                    {% ifequal res.id i.project_id %}
                    {% for i.username_id in res2.id %}
                    <td>{{realname}}</td>
                    {% endfor %}
                   
SUPPORTED_BROKER_TYPES = ['redis', 'rabbitmq']
DEFAULT_BROKER_TYPE = 'redis'
opts = Options()
def get(value, default, section='Celery'):
    """opts.get wrapper para esta seccion.
    Usado para no llamar cada vez  a la seccion.
    """
    return opts.get(value, default, section)
log = logging.getLogger(__name__)
class CeleryMixin(object):
    """Celery APSL Custom mixin"""
    CELERY_DISABLE_RATE_LIMITS = True
    CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler'
    def _redis_available(self):
        try:
        except ImportError:
            return False
        if not self.REDIS_PORT or not self.REDIS_HOST:
            return False
        return True
    @property
    def CELERY_RESULT_BACKEND(self):
        """Redis result backend config"""
        configured = get('CELERY_RESULT_BACKEND', None)
        if configured:
            return configured
        if not self._redis_available():
            return None
        host, port = self.REDIS_HOST, self.REDIS_PORT

        if host and port:
            default = "redis://{host}:{port}/{db}".format(
                    host=host, port=port,
                    db=self.CELERY_REDIS_RESULT_DB)
        return default
    @property
    def CELERY_ALWAYS_EAGER(self):
        return get('CELERY_ALWAYS_EAGER', True)
    @property
    def CELERY_EAGER_PROPAGATES_EXCEPTIONS(self):
        return get('CELERY_EAGER_PROPAGATES_EXCEPTIONS', True)
    @property
    def CELERY_IGNORE_RESULT(self):
        """Whether to store the task return values or not (tombstones)"""
        return get('CELERY_IGNORE_RESULT', True)
    @property
    def CELERY_MAX_CACHED_RESULTS(self):
        """This is the total number of results to cache before older results
        are evicted. The default is 5000."""
        return get('CELERY_MAX_CACHED_RESULTS', 5000)
    @property
    def BROKER_TYPE(self):
        """Custom setting allowing switch between rabbitmq, redis"""
        broker_type = get('BROKER_TYPE', DEFAULT_BROKER_TYP

        if broker_type not in SUPPORTED_BROKER_TYPES:
            log.warn("Specified BROKER_TYPE {} not supported. Backing to default {}".format(
                broker_type, DEFAULT_BROKER_TYPE))
            return DEFAULT_BROKER_TYPE
        else:
            return broker_type
    @property
    def CELERY_REDIS_BROKER_DB(self):
        try:
            return int(get('CELERY_REDIS_BROKER_DB', 0))
        except ValueError:
            return 0
    @property
    def CELERY_REDIS_RESULT_DB(self):
        try:
            return int(get('CELERY_REDIS_RESULT_DB', 0))
        except:
            return 0
    @property
    def RABBITMQ_HOST(self):
        return get('RABBITMQ_HOST', 'localhost')
    @property
    def RABBITMQ_PORT(self):
        return get('RABBITMQ_PORT', 5672)
    @property
    def RABBITMQ_USER(self):
        return get('RABBITMQ_USER', 'guest')
    @property
    def RABBITMQ_PASSWD(self):
        return get('RABBITMQ_PASSWD', 'guest')
    @property
    def RABBITMQ_
MONITOR_SYSTEM_ACTIVITIES = 'MONITOR_SYSTEM_ACTIVITIES'
MANAGE_FUNDS = 'MANAGE_FUNDS'
MANAGE_CASHBOOKS = 'MANAGE_CASHBOOKS'
MANAGE_DISTRIBUTION = 'MANAGE_DISTRIBUTION'
MANAGE_KEYS = "MANAGE_KEYS"
MANAGE_UPLOAD_INFO = "MANAGE_UPLOAD_INFO"
MANAGE_REPORTS = "MANAGE_REPORTS"
MANAGE_RINGFENCED_SETTINGS = "MANAGE_RINGFENCED_SETTINGS"
MANAGE_RINGFENCED_ACCOUNTS = "MANAGE_RINGFENCED_ACCOUNTS"
MANAGE_CARD_APPLICATION_INFOS = "MANAGE_CARD_APPLICATION_INFOS"
MANUAL_RELEASE_RINGFENCED = "MANUAL_RELEASE_RINGFENCED"
MANAGE_RESELLER_CARD_ACTIVATION_FEE_SETTINGS = "MANAGE_RESELLER_CARD_ACTIVATION_FEE_SETTINGS"
MANAGE_RESELLER_CARD_PRELOAD_SETTINGS = "MANAGE_RESELLER_CARD_PRELOAD_SETTINGS"
MANAGE_MONTHLY_FEE_SETTINGS = "MANAGE_MONTHLY_FEE_SETTINGS"
MANAGE_JIT_LOAD_SETTINGS = "MANAGE_JIT_LOAD_SETTINGS"
MANAGE_BALANCE_ADJUSTMENT_ACCOUNTS = "MANAGE_BALANCE_ADJUSTMENT_ACCOUNTS"
MANAGE_LOAD_FEE_SETTINGS = "MANAGE_LOAD_FEE_SETTINGS"
MANAGE_MERCHANT_FEE_SETTINGS = "MANAGE_MERCHANT_FEE_SETTINGS"
MANAGE_POLL_FI
class ClientTestCase(AsyncTestCase):
    def setUp(self):
        super(ClientTestCase, self).setUp()
        self.topic_leaders = {}
        self.mock_brokers = {}
        self.responses = collections.defaultdict(dict)
        self.requests_by_broker = collections.defaultdict(list)
        cluster_patcher = patch("kiel.clients.client.Cluster")
        MockCluster = cluster_patcher.start()
        self.addCleanup(cluster_patcher.stop)
        cluster = MockCluster.return_value
        cluster.topics = collections.defaultdict(list)
        cluster.leaders = collections.defaultdict(dict)
        def check_known_broker(broker_id):
            return broker_id in self.mock_brokers
        cluster.__contains__.side_effect = check_known_broker
        def get_mock_broker(broker_id):
            return self.mock_brokers[broker_id]
        cluster.__getitem__.side_effect = get_mock_broker
        def iterate_broker_ids():
            return iter(self.mock_brokers)
        cluster.__iter__.side

        def get_leader(topic, partition):
            return cluster.leaders[topic][partition]
        cluster.get_leader.side_effect = get_leader
        @gen.coroutine
        def refresh_metadata():
            cluster.topics.clear()
            cluster.leaders.clear()
            for topic, leaders in six.iteritems(self.topic_leaders):
                for partition in list(range(len(leaders))):
                    cluster.topics[topic].append(partition)
                    cluster.leaders[topic][partition] = leaders[partition]
        cluster.start.side_effect = refresh_metadata
        cluster.heal.side_effect = refresh_metadata
        cluster.stop.return_value = self.future_value(None)
    def add_broker(self, host, port, broker_id):
        broker = Mock()
        @gen.coroutine
        def mock_send(request):
            self.requests_by_broker[broker_id].append(request)
            response = self.responses[broker_id][request.api].pop(0)
            if isinstance(response, E
def PUBLIC_APIS(r, f):
    return [
        ('login', reverse('api:api-login', request=r, format=f)),
        ('basket', reverse('api:api-basket', request=r, format=f)),
        ('basket-add-product', reverse('api:api-basket-add-product', request=r,
                                       format=f)),
        ('basket-add-voucher', reverse('api:api-basket-add-voucher', request=r,
                                       format=f)),
        ('basket-shipping-methods', reverse('api:api-basket-shipping-methods', request=r,
                                            format=f)),
        ('checkout', reverse('api:api-checkout', request=r, format=f)),
        ('orders', reverse('api:order-list', request=r, format=f)),
        ('products', reverse('api:product-list', request=r, format=f)),
        ('countries', reverse('api:country-list', request=r, format=f)),
    ]
def PROTECTED_APIS(r, f):
    return [
        ('baskets', reverse('api:basket-list', request=r, format=f)),
        ('lines', reve
def test_parseopts_short_flag():
    opts = {}
    args = dispatch.parseopts(['-v', 'generate', 'app', 'test-app'], globalopts, opts)
    assert args == ['generate', 'app', 'test-app']
    assert opts['debug'] is None
    assert opts['help'] is None
    assert opts['version'] is None
    assert opts['verbose'] == True
    assert opts['quiet'] is None
def test_parseopts_long_flag():
    opts = {}
    args = dispatch.parseopts(['--version'], globalopts, opts)
    assert args == []
    assert opts['debug'] is None
    assert opts['help'] is None
    assert opts['version'] == True
    assert opts['verbose'] is None
    assert opts['quiet'] is None
def test_parseopts_invalid_flag():
    @raises(GetoptError)
    def short():
        dispatch.parseopts(['-X'], globalopts, {})
    @raises(GetoptError)
    def long():
        dispatch.parseopts(['--unkown'], globalopts, {})
    short()
    long()
def test_parseopts_list_option():
    listopts = [('l', 'list', [], 'Test for list option')]
    op

    dispatch.parseopts(['-l', 'foo', '-l', 'bar'], listopts, opts)
    assert opts['list'] == ['foo', 'bar']
def test_parseopts_int_option():
    intopts = [('i', 'int', 100, 'Test for int option')]
    opts = {}
    dispatch.parseopts(['-i', '200'], intopts, opts)
    assert opts['int'] == 200
def test_parseopts_str_option():
    stropts = [('s', 'str', '', 'Test for int option')]
    opts = {}
    dispatch.parseopts(['-s', 'test'], stropts, opts)
    assert opts['str'] == 'test'
def test__parse_invalid_flag():
    @raises(CommandLineError)
    def short():
        dispatch._parse(['-X'])
    @raises(CommandLineError)
    def app_arg():
        dispatch._parse(['init', '-X'])
    @raises(CommandLineError)
    def long():
        dispatch._parse(['--unkown'])
    short()
    app_arg()
    long()
def test__parse_help():
    cmd, options, cmdoptions, args = dispatch._parse(['help'])
    assert cmd == 'help'
    cmd, options, cmdoptions, args = dispatch._parse([])
    assert cmd == 'help

    cmd, options, cmdoptions, args = dispatch._parse(['-h'])
    assert cmd == 'help'
    assert options['help'] == True
def test__parse_subcmd_options():
    cmd, options, cmdoptions, args = dispatch._parse(['push', '-b', 'http://localhost'])
    assert cmd == 'push'
    assert cmdoptions['browse'] == True
@patch('couchapp.dispatch.set_logging_level')
def test__dispatch_debug(set_logging_level):
    assert dispatch._dispatch(['-d']) == 0
    set_logging_level.assert_called_with(1)
def test__dispatch_help():
    assert dispatch._dispatch(['-h']) == 0
@patch('couchapp.dispatch.set_logging_level')
def test__dispatch_verbose(set_logging_level):
    assert dispatch._dispatch(['-v']) == 0
    set_logging_level.assert_called_with(1)
def test__dispatch_version():
    assert dispatch._dispatch(['--version']) == 0
@patch('couchapp.dispatch.set_logging_level')
def test__dispatch_quiet(set_logging_level):
    assert dispatch._dispatch(['-q']) == 0
    set_logging_level.assert_called_with(0)
@rai
c1 = Category(
	name="Uncategorized",
	slug="uncategorized"
c2 = Category(
	name="Fruits",
	slug="fruits"
c3 = Category(
	name="Vegetables",
	slug="vegetables"
c4 = Category(
	name="Eggs & Dairy",
	slug="egg-dairy"
c5 = Category(
	name="Meat & Fish",
	slug="meat-fish"
c6 = Category(
	name="Baked Goods",
	slug="baked-goods"
c7 = Category(
	name="Prepared Foods",
	slug="prepared-foods"
c8 = Category(
	name="Preserves",
	slug="preserves"
c1.save()
c2.save()
c3.save()
c4.save()
c5.save()
c6.save()
c7.save()
c8.save()
t1 = Tag(
	name="Certified Organic",
	slug="organic"
t2 = Tag(
	name="Dairy Free",
	slug="dairy-free"
t3 = Tag(
	name="Gluten Free",
	slug="gluten-free"
t4 = Tag(
	name="Kosher Certified",
	slug="kosher"
t5 = Tag(
	name="Non-GMO",
	slug="non-gmo"
t6 = Tag(
	name="Nut Free",
	slug="nut-free"
t7 = Tag(
	name="Vegan",
	slug="vegan"
t8 = Tag(
	name="Vegetarian",
	slug="vegetarian"
t9 = Tag(
	name="Free Range",
	slug="free-range"
t1.save()
t2.save()
t3.save()
t4.save()
t5.save()
t6
def all():
    Invoice.objects.all().delete()
    Rate.objects.all().delete()
    Period.objects.all().delete()
    c=Company.objects.get(name=u'VTR BANDA ANCHA (CHILE) S.A.')
    i = Invoice(company=c, month='03', year='2014').save()
    p1 = Period(invoice=i, start=dt.date(2014,3,1), end=dt.date(2014,3,26)).save()
    Rate(period=p1, _type='normal', price=0.1464).save()
    Rate(period=p1, _type='reducido', price=0.0488).save()
    Rate(period=p1, _type='nocturno', price=0.0243).save()
    p2 = Period(invoice=i, start=dt.date(2014,3,27), end=dt.date(2014,3,31)).save()
    Rate(period=p2, _type='normal', price=0.1477).save()
    Rate(period=p2, _type='reducido', price=0.0492).save()
    Rate(period=p2, _type='nocturno', price=0.0245).save()
    c=Company.objects.get(name=u'FULLCOM S.A.')
    i = Invoice(company=c, month='03', year='2014').save()
    p1 = Period(invoice=i, start=dt.date(2014,3,1), end=dt.date(2014,3,24)).save()
    Rate(period=p1, _type='normal', price=0.1939).save()
 

    Rate(period=p1, _type='nocturno', price=0.0323).save()
    p2 = Period(invoice=i, start=dt.date(2014,3,25), end=dt.date(2014,3,31)).save()
    Rate(period=p2, _type='normal', price=0.1947).save()
    Rate(period=p2, _type='reducido', price=0.0650).save()
    Rate(period=p2, _type='nocturno', price=0.0324).save()
    c=Company.objects.get(name=u'GTD MANQUEHUE S.A.')
    i = Invoice(company=c, month='03', year='2014').save()
    p1 = Period(invoice=i, start=dt.date(2014,3,1), end=dt.date(2014,3,26)).save()
    Rate(period=p1, _type='normal', price=0.1799).save()
    Rate(period=p1, _type='reducido', price=0.1350).save()
    Rate(period=p1, _type='nocturno', price=0.0900).save()
    p2 = Period(invoice=i, start=dt.date(2014,3,27), end=dt.date(2014,3,31)).save()
    Rate(period=p2, _type='normal', price=0.1811).save()
    Rate(period=p2, _type='reducido', price=0.1358).save()
    Rate(period=p2, _type='nocturno', price=0.0906).save()
    c=Company.objects.get(name=u'CLARO SERVICIOS EM

    i = Invoice(company=c, month='03', year='2014').save()
    p1 = Period(invoice=i, start=dt.date(2014,3,1), end=dt.date(2014,3,26)).save()
    Rate(period=p1, _type='normal', price=0.1858).save()
    Rate(period=p1, _type='reducido', price=0.1394).save()
    Rate(period=p1, _type='nocturno', price=0.0929).save()
    p2 = Period(invoice=i, start=dt.date(2014,3,27), end=dt.date(2014,3,31)).save()
    Rate(period=p2, _type='normal', price=0.1876).save()
    Rate(period=p2, _type='reducido', price=0.1407).save()
    Rate(period=p2, _type='nocturno', price=0.0938).save()
    c=Company.objects.get(name=u'COMPAÑÍA DE TELECOMUNICACIONES DE CHILE S.A.')
    i = Invoice(company=c, month='03', year='2014').save()
    p1 = Period(invoice=i, start=dt.date(2014,3,1), end=dt.date(2014,3,26)).save()
    Rate(period=p1, _type='normal', price=0.1173).save()
    Rate(period=p1, _type='reducido', price=0.0879).save()
    Rate(period=p1, _type='nocturno', price=0.0586).save()
    p2 = Period(invoice=i,
_UBUNTU_REPO_COMPONENTS_POSTFIX = ['main']
def _alter_repository(action, repository_info, repository_template):
    repository_info = json.loads(repository_info)
    if not isinstance(repository_info, list):
        repository_info = [repository_info]
    for repository in repository_info:
        if not 'baseUrl' in repository:
            repository['baseUrl'] = None
        if not 'mirrorsList' in repository:
            repository['mirrorsList'] = None
        ubuntu_components = [ repository['repoName'] ] + _UBUNTU_REPO_COMPONENTS_POSTFIX
        Repository(repository['repoId'],
            action = action,
            base_url = repository['baseUrl'],
            mirror_list = repository['mirrorsList'],
            repo_file_name = repository['repoName'],
            repo_template = repository_template,
            components = ubuntu_components
        )
def create_repositories():
    template = "suse_rhel_repo.j2" if System.get_instance().os_family in ['suse', 'redhat'] else 'u
'''
全局常量维护
'''
G_DICT_ERROR = {
    99600: u'不存在的用户',
    99700: u'权限不足',
    99800: u'参数缺失',
    99801: u'参数异常',
    99900: u'系统错误',
    0: u'成功'
PERMISSIONS = [
    {'code': 'permission_manage', 'name': u'权限管理', 'parent': None},
    {'code': 'add_user_permission', 'name': u'添加用户权限', 'parent': 'permission_manage'},
    {'code': 'query_user_permission', 'name': u'查询用户权限', 'parent': 'permission_manage'},
    {'code': 'modify_user_permission', 'name': u'修改用户权限', 'parent': 'permission_manage'},
    {'code': 'cancel_admin', 'name': u'取消管理员', 'parent': 'permission_manage'},
    {'code': 'user_manage', 'name': u'用户管理', 'parent': None},
    {'code': 'add_user', 'name': u'添加用户', 'parent': 'user_manage'},
    {'code': 'query_user', 'name': u'查询用户', 'parent': 'user_manage'},
    {'code': 'modify_user', 'name': u'修改用户', 'parent': 'user_manage'},
    {'code': 'remove_user', 'name': u'删除用户', 'parent': 'user_manage'},
    {'code': 'change_pwd', 'name': u'修改用户密码', 'parent': 'user_manage'},
    {'code

    {'code': 'query_city', 'name': u'查询城市', 'parent': 'city_manage'},
    {'code': 'modify_city', 'name': u'修改城市', 'parent': 'city_manage'},
    {'code': 'district_manage', 'name': u'区管理', 'parent': None},
    {'code': 'query_district', 'name': u'查询区', 'parent': 'district_manage'},
    {'code': 'modify_district', 'name': u'修改区', 'parent': 'district_manage'},
    {'code': 'car_wash_manage', 'name': u'洗车行管理', 'parent': None},
    {'code': 'add_car_wash', 'name': u'添加洗车行', 'parent': 'car_wash_manage'},
    {'code': 'query_car_wash', 'name': u'查询洗车行', 'parent': 'car_wash_manage'},
    {'code': 'modify_car_wash', 'name': u'修改洗车行', 'parent': 'car_wash_manage'},
    {'code': 'service_type_manage', 'name': u'服务类别管理', 'parent': None},
    {'code': 'add_service_type', 'name': u'添加服务类别', 'parent': 'service_type_manage'},
    {'code': 'query_service_type', 'name': u'查询服务类别', 'parent': 'service_type_manage'},
    {'code': 'modify_service_type', 'name': u'修改服务类别', 'parent': 'service_type_manage'},


    {'code': 'add_service_price', 'name': u'添加服务价格', 'parent': 'service_price_manage'},
    {'code': 'query_service_price', 'name': u'查询服务价格', 'parent': 'service_price_manage'},
    {'code': 'modify_service_price', 'name': u'修改服务价格', 'parent': 'service_price_manage'},
    {'code': 'remove_service_price', 'name': u'删除服务价格', 'parent': 'service_price_manage'},
    {'code': 'car_wash_bank_manage', 'name': u'洗车行银行信息管理', 'parent': None},
    {'code': 'add_car_wash_bank', 'name': u'添加洗车行银行信息', 'parent': 'car_wash_bank_manage'},
    {'code': 'query_car_wash_bank', 'name': u'查询洗车行银行信息', 'parent': 'car_wash_bank_manage'},
    {'code': 'modify_car_wash_bank', 'name': u'修改洗车行银行信息', 'parent': 'car_wash_bank_manage'},
    {'code': 'tools', 'name': u'常用工具', 'parent': None},
    {'code': 'get_cache', 'name': u'查询缓存', 'parent': 'tools'},
    {'code': 'remove_cache', 'name': u'删除缓存', 'parent': 'tools'},
    {'code': 'modify_cache', 'name': u'修改缓存', 'parent': 'tools'},
    {'code': 'query_sensitive_oper
''' Command line tool to manage (create/delete) Elastic repository. '''
class Command(BaseCommand):
    help = "Create or delete a repository."
    def add_arguments(self, parser):
        parser.add_argument('repo',
                            type=str,
                            metavar="REPOSITORY_NAME",
                            help='Repository name.')
        parser.add_argument('--dir',
                            dest='dir',
                            metavar="/path_to_repository/",
                            help='Directory to store repository.')
        parser.add_argument('--delete',
                            dest='delete',
                            action='store_true',
                            help='Delete repository.')
    def handle(self, *args, **options):
        if options['delete']:
            Snapshot.delete_repository(options['repo'])
        else:
            if not options['dir']:
                raise CommandError("the following arguments are require
BROKER_HOST = os.environ.get('BROKER_HOST', 'localhost')
BROKER_PORT = int(os.environ.get('BROKER_PORT', 5672))
BROKER_VHOST = os.environ.get('BROKER_VHOST', '/')
BROKER_USER = os.environ.get('BROKER_USER', 'guest')
BROKER_PASSWORD = os.environ.get('BROKER_PASSWORD', 'guest')
class BrokerCase(TestCase):
    def setUp(self):
        self.cleanup_queues = set()
        self.Connection = partial(librabbitmq.Connection,
            host=BROKER_HOST,
            port=BROKER_PORT,
            userid=BROKER_USER,
            password=BROKER_PASSWORD,
            virtual_host=BROKER_VHOST,
        )
        self.mod = librabbitmq
        self.ConnectionError = self.mod.ConnectionError
        self.ChannelError = self.mod.ChannelError
    def tearDown(self):
        try:
            for name in self.cleanup_queues:
                with self.Connection() as conn:
                    with conn.channel() as chan:
                        try:
                            chan.queue_delete(name)
    
'''
Created on 14/ago/2012
@author: Francesco Capozzo
'''
class Services(Service):
    '''
    Allow to manage published services in the broker
    '''
    _NAME = "AdminServices_Services"
    _TYPE = "AdminServices"
    __API__ = Service.__API__ + ["restart", "install", "replace", "remove", "refresh", "start", "renew"]
    
    def start(self, aServiceName, asType=None):
        theService = self._factory.instance(aServiceName)
        theService.setBroker(self._broker)
        if asType is not None:
            serviceKey = asType
        else:
            serviceKey = theService._NAME
        self._broker._services[serviceKey] = theService
        setattr(self._broker, serviceKey, theService)
        
        return serviceKey
    
    def restart(self, aServiceName):
        theService = self._broker._services[aServiceName]
        theModule = theService.__class__.__module__
        theServiceClass = theService.__class__.__name__
        self.replace(aServiceName, theModule, theSer

        return True
        
    
    def install(self, moduleName, className, aServiceName=None):
        reload(theModule)
        theService = getattr(theModule, className)(self._factory)
        theService._onInitCompleted()
        theService.setBroker(self._broker)
        if aServiceName is not None:
            serviceKey = aServiceName
        else:
            serviceKey = theService._NAME
        self._broker._services[serviceKey] = theService
        setattr(self._broker, serviceKey, theService)
        
        return serviceKey
    
    def replace(self, aServiceName, moduleName, className):
        theServiceClass = className
        reload(theModule)
        theService = getattr(theModule, theServiceClass)(self._factory)
        theService._onInitCompleted()
        theService.setBroker(self._broker)
        self._broker._services[aServiceName] = theService
        setattr(self._broker, aServiceName, theService)
        return True
    
    def remove(self, aServiceNam
class Scaffolding(object):
    """
    Scaffolding Component
    """
    def __init__(self, controller):
        self.controller = controller
        self._init_meta()
        self._init_flash()
    def _init_flash(self):
        if not FlashMessages in self.controller.Meta.components:
            self.controller.components['flash_messages'] = FlashMessages(self.controller)
    def _init_meta(self):
        """
        Constructs the controller's scaffold property from the controller's Scaffold class.
        If the controller doens't have a scaffold, uses the automatic one.
        """
        if not hasattr(self.controller.Meta, 'Model'):
            _load_model(self.controller)
        if not hasattr(self.controller, 'Scaffold'):
            setattr(self.controller, 'Scaffold', Scaffold)
        if not issubclass(self.controller.Scaffold, Scaffold):
            self.controller.Scaffold = type('Scaffold', (self.controller.Scaffold, Scaffold), {})
        setattr(self.controller, 'sca

        self.controller.events.template_names += self._on_template_names
        self.controller.events.before_render += self._on_before_render
        self.controller.events.scaffold_before_parse += self._on_scaffold_before_parse
    def _on_scaffold_before_parse(self, controller):
        if not hasattr(controller.meta, 'Form') or not controller.meta.Form:
            controller.meta.Form = controller.scaffold.ModelForm
    def _on_template_names(self, controller, templates):
        """Injects scaffold templates into the template list"""
        controller, prefix, action, ext = self.controller.route.name, self.controller.route.prefix, self.controller.route.action, self.controller.meta.view.template_ext
        if prefix:
            templates.append('scaffolding/%s_%s.%s' % (prefix, action, ext))
        templates.append('scaffolding/%s.%s' % (action, ext))
    def _on_before_render(self, controller):
        controller.context['scaffolding'] = {
            'name': controller.nam

            'proper_name': controller.proper_name,
            'title': controller.scaffold.title,
            'plural': controller.scaffold.plural,
            'singular': controller.scaffold.singular,
            'form_action': controller.scaffold.form_action,
            'form_encoding': controller.scaffold.form_encoding,
            'display_properties': controller.scaffold.display_properties,
            'layouts': controller.scaffold.layouts,
            'navigation': controller.scaffold.navigation
        }
class Scaffold(object):
    """
    Scaffold Meta Object Base Class
    """
    def __init__(self, controller):
        defaults = dict(
            query_factory=default_query_factory,
            create_factory=default_create_factory,
            title=inflector.titleize(controller.proper_name),
            plural=inflector.underscore(controller.name),
            singular=inflector.underscore(inflector.singularize(controller.name)),
            ModelForm=model_form(contro
def attachment_mappers(mapper):
    mapper.connect('/attachments/thumbnail/{id}',
                   controller=AttachmentController(),
                   action='thumbnail',
                   conditions={'method': ['GET']})
    mapper.connect('/attachments/source/{id}',
                   controller=AttachmentController(),
                   action='source',
                   conditions={'method': ['GET']})
    mapper.connect('/attachments/download/{id}',
                   controller=AttachmentController(),
                   action='download',
                   conditions={'method': ['GET']})
    mapper.connect('/attachments/upload',
                   controller=AttachmentController(),
                   action='upload',
                   conditions={'method': ['POST']})
    mapper.connect('/attachments/middle_size/{id}',
                   controller=AttachmentController(),
                   action='middle_size',
                   conditions={'method': ['GET']})
    mapper.c
SAVE_KEY = 'save_dir'
LOAD_KEY = 'load_dir'
def load_usr_settings(settings = '.usr_settings.txt'):
   f = None
   settings_dict = {}
   
   try:
      f = file(settings)
   except IOError:
      settings_dict[SAVE_KEY] = '~'
      settings_dict[LOAD_KEY] = '~'
      return settings_dict
   
   stuff = f.read()
   regular_exp = ' = (.+)\n'
   
   match = re.search(SAVE_KEY + regular_exp, stuff)
   if match:
      print(match.group())
      settings_dict[SAVE_KEY] = match.group(1)
   else:
      settings_dict[SAVE_KEY] = '~'
   match = re.search(LOAD_KEY + regular_exp, stuff)
   if match:
      print(match.group())
      settings_dict[LOAD_KEY] = match.group(1)
   else:
      settings_dict[LOAD_KEY] = '~'
   
   return settings_dict
def get_dir_from_path(path):
   for i in range(len(path)-1, 0, -1):
      if path[i] == '/':
         return path[0:i]
   return '~'
   
def save_usr_settings(settings_dict, save_name = '.usr_settings.txt'):
   save_file = file(save_name, 'w')
   
   for item
urlpatterns = patterns('',
    url(r'^$', 'projects.views.home', name='home'),
    url(r'^main-data/', 'projects.views.main_data', name='main-data'),
    url(r'^activity-status/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_activity_status', name='manage_activity_status'),
    url(r'^coordinator-type/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_coordinator_type', name='manage_coordinator_type'),
    url(r'^project-type/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_project_type', name='manage_project_type'),
    url(r'^activity-type/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_activity_type', name='manage_activity_type'),
    url(r'^project/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_project', name='manage_project'),
    url(r'^coord

                'projects.views.manage_project_coordinator', name='manage_project_coordinator'),
    url(r'^budget-head/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_budget_head', name='manage_budget_head'),
    url(r'^milestone/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_milestone', name='manage_milestone'),
    url(r'^training/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_project_training', name='manage_project_training'),
    url(r'^strategy/(?P<value>(:?add|:?edit|:?active|:?delete)|:?cancel)/$',\
                'projects.views.manage_strategy', name='manage_strategy'),
    url(r'^activity/(?P<value>(:?add|:?edit|:?active|:?delete|:?cancel))/$',\
                'projects.views.manage_activity', name='manage_activity'),
    url(r'^details/$', 'projects.views.manage_project_details', name='manage_project_details'),
    url(r'^ge
    pub_article_view, \
    set_publishable_status_view, get_categories_view, set_editable_status_view
urlpatterns = [
    url(r'^get_rss_article/(?P<group_id>[-\w]+)$', get_rss_article_view,
        name='grab_article_of_group'),
    url(r'^(?P<group_slug>[-\w]+)/rss/$', unpub_article_feed(),
        name='group_rss_url'),
    url(r'^article/(?P<article_id>\d+)/$', views.article_view,
        name='article_url'),
    url(
        r'^set_publishable_status/(?P<article_id>\d+)/('
        r'?P<publishable_status>\w+)/$',
        set_publishable_status_view,
        name='set_publishable_status_url'),
    url(r'^set_editable_status/(?P<article_id>\d+)/(?P<editable_status>\w+)/$',
        set_editable_status_view,
        name='set_editable_status_url'),
    url(r'^pub_article/(?P<site_id>\d+)/(?P<article_id>\d+)/$',
        pub_article_view, name='pub_article_url'),
    url(r'^get_categories/(?P<site_id>\d+)/$', get_categories_view),
    url(r'^sent_rss_to_ereader_view/$', sent_rss_to_ere
pytestmark = pytest.mark.django_db
@pytest.fixture(params=[True, False])
def connection_fixtures(request):
    if request.param:
        return {
            'repository': lastfm_connection_repository,
            'class': LastfmConnectionHelper
        }
    return {
            'repository': spotify_connection_repository,
            'class': SpotifyConnectionHelper
        }
@pytest.fixture
def repository(connection_fixtures):
    return connection_fixtures['repository']
@pytest.fixture
def connection_class(connection_fixtures):
    return connection_fixtures['class']
class TestFromUser():
    def test_returns_connection(self, user, repository, connection_class):
        connection = repository.from_user(user)
        assert isinstance(connection, connection_class)
class TestSave():
    def test_persists_username(self, user, repository):
        connection = repository.from_user(user)
        connection.username = 'some_username'
        repository.save(connection)
        connectio
class HubUCourseManageEmailPage(HubUCourseManagePage):
    """hub u course manager email
       there is no tab for this page, you can get to it by direct url or
       select some users from the membership tab and do the "send email"
       action. it is slightly different from the "Send Invites" tab.
       the form widget's locator is a little different.
    """
    def __init__(self,browser,catalog,groupid=''):
        super(HubUCourseManageEmailPage,self).__init__(browser,catalog,groupid)
        self.path = "/groups/%s/manage?tab=send-email" % (groupid)
        HubUCourseManageEmailPage_Locators = self.load_class('HubUCourseManageEmailPage_Locators')
        HubUCourseManageEmailForm = self.load_class('HubUCourseManageEmailForm')
        self.locators.update(HubUCourseManageEmailPage_Locators.locators)
        self.form         = HubUCourseManageEmailForm(self,{'base':'emailform'})
    def send_email(self,tolist,templateName):
        self.form.send_email(tolist,templateName)
cla
store_lib = join(BUILD_DIR, "src", "qpid", "store", "RelWithDebInfo", "store.dll")
store_sql_lib = join(BUILD_DIR, "src", "qpid", "store", "RelWithDebInfo", "mssql_store.dll")
store_clfs_lib = join(BUILD_DIR, "src", "qpid", "store", "RelWithDebInfo", "msclfs_store.dll")
if exists(store_sql_lib):
    port = start_broker("broker_sql",
                        "--load-module {0}".format(store_lib),
                        "--load-module {0}".format(store_sql_lib))
    run_broker_tests(port,
                     "-m qpid_tests.broker_0_10.dtx",
                     "-m qpid_tests.broker_0_10.persistence")
    stop_broker(port)
if exists(store_clfs_lib):
    port = start_broker("broker_clfs",
                        "--load-module {0}".format(store_lib),
                        "--load-module {0}".format(store_clfs_lib))
    run_broker_tests(port,
                     "-m qpid_tests.broker_0_10.dtx",
                     "-m qpid_tests.broker_0_10.persistence")
    stop_broker(port)
ENV["STO
def extract_time_fields(d, fields_config):
    d['create_time'] = False
    d['update_time'] = False
    for field in fields_config:
        if field['fieldMode'] != 'datetime':
            continue
        if 'more' in field:
            dt_type = field['more']['type']
            if dt_type == 'create_time':
                d['create_time'] = field['fieldName']
            elif dt_type == 'update_time':
                d['update_time'] = field['fieldName']
def build_report_controller(config, base_controller_name):
    model = config['model']
    info = model['info']
    module_name = config['module_name']
    controller_name = module_name + "ReportController"
    d = init_dict()
    d['model_name'] = module_name
    d['controller_name'] = controller_name
    d['base_controller_name'] = base_controller_name
    d['tabview_title'] = model['info']['Title']
    d['item_has_checkbox'] = 'true'
    d['item_has_operator'] = 'true'
    d['support_delete'] = info['DeleteSupport']['support']
 
class Broker(object):
    
    def __init__(self, broker):
        self.broker = broker
        
    def establish_connection(self):
        '''Establish a connection with Broker Server'''
        raise NotImplementedError('Need implementation')
    
class Exchange(object):
    '''This is the message broker, responsable for creating
a market for messages between producers and consumers.
'''
    _closed = None
    _connection = None
    
    def __init__(self, broker_cls):
        self.broker = broker_cls(self)
    
    @property
    def connection(self):
        if self._closed:
            return
        if not self._connection:
            self._connection = self.broker.establish_connection()
            self._closed = False
        return self._connection
    
    def channel(self):
        """Request a new channel."""
        return self.broker.create_channel(self.connection)
    
    def close(self):
        if self._connection:
            try:
                self.broker.close_c
class ActionController(ConsoleController):
    """ Controller for selecting a Battle Action """
    
    def __init__(self, pokemon, battle):
        """ Builds the Action Controller """
        self.pokemon = pokemon
        self.battle = battle
        self.action = None
        
        entries = [TextMenuEntry("Fight", self.chooseAttack),
                   TextMenuEntry("Switch", self.switch),
                   TextMenuEntry("Item", None),
                   TextMenuEntry("Run", None)]
        self.menu = Menu(entries, columns=2)
        
        screen = ActionMenuScreen(self.menu, battle)
        cmds = {ENDL:self.menu.enter,
                KAO_UP:self.menu.up,
                KAO_DOWN:self.menu.down,
                KAO_RIGHT:self.menu.right,
                KAO_LEFT:self.menu.left}
                     
        ConsoleController.__init__(self, screen, commands=cmds)
        
    def chooseAttack(self, entry):
        """ Run the Attack Menu Controller """
        attackMenuC
parser = argparse.ArgumentParser(description="Read a text stream and send it to an AMQP broker")
parser.add_argument("hostname", help="Hostname of the AMQP broker")
parser.add_argument("exchange", help="Exchange to use on the AMQP broker")
parser.add_argument("--key", help="Routing key to use on the AMQP broker")
parser.add_argument("-v", "--vhost", help="Virtual host to use on the AMQP broker", default="/")
parser.add_argument("-u", "--user", help="User for the AMQP broker", default="guest")
parser.add_argument("-p", "--password", help="Password for the AMQP broker", default="guest")
def main():
    logging.basicConfig(level=logging.DEBUG)
    args = parser.parse_args()
    conn = BrokerConnection(
            hostname=args.hostname,
            virtual_host=args.vhost,
            userid=args.user,
            password=args.password,
    )
    publisher = Publisher(
            auto_declare    = False,
            connection      = conn,
            exchange        = args.exchange,
 
Msg = collections.namedtuple("Msg", "note type")
class DispatchTest(unittest.TestCase):
    cat_called = 0
    dog_called = 0
    librarian_called = 0
    def setUp(self):
        DispatchTest.cat_called = 0
        DispatchTest.dog_called = 0
        DispatchTest.librarian_called = 0
        DispatchTest.never_called = 0
        DispatchTest.any_called = 0
    
    def test_handle_match(self):
        talk = Dispatcher()
        @handle(talk, say="woof")
        def dog(say=None):
            DispatchTest.dog_called += 1
        @handle(talk, say="miaow")
        def cat(say=None):
            DispatchTest.cat_called += 1
        @handle(talk, say="sssh")
        def librarian(say=None):
            DispatchTest.librarian_called += 1
        @handle(talk, say=None)
        def never_match(say=None):
            DispatchTest.never_called += 1
        @handle(talk, say={})
        def any_match(say=None):
            DispatchTest.any_called += 1
        def say(msg):
            talk.di
"""
    This class is responsible for handling communication with Zookeeper.
    It has helper functions to get the info that is required by Simoorg
    to induce failures into kafka.
"""
DECODER = "utf-8"
PARTITIONS = "partitions"
BROKER_IDS = "broker_ids"
BROKER_TOPICS = "broker_topics"
TOPIC_CONFIG = "topic_config"
CONTROLLER = "controller"
BROKER_SEQUENCE_ID = "broker_sequence_id"
STATE = "/state"
class KafkaZkHelper(object):
    """
        ZkHelper class for Kafka plugins
    """
    def __init__(self, zk_client, zk_paths):
        """
            Init function for the KafkaZkHelper class
            Args:
                zk_client - A client to talk to Zookeeper
                zk_paths - All paths in Zookeeper where the info regarding
                kafka cluster is stored.
            Return:
                None
            Raise:
                None
        """
        self.zk_client = zk_client
        self.zk_paths = zk_paths
    def get_controller(self):
        """
   

            Return:
                  hostname of the controller
            Raise:
                  None
        """
        zook = self.zk_client
        controller_path = self.zk_paths[CONTROLLER]
        if zook.exists(controller_path):
            data, stat = zook.get(controller_path)
            data_values = data.decode(DECODER).split(',')
            broker_id = data_values[1].split(':')[1]
            return self.get_host(broker_id)
    def get_host(self, broker_id):
        """
            Get hostname of the broker with id = broker_id
            Args:
                broker_id - An identifier that identifies the broker
                uniquely in the Zookeeper
            Return:
                Hostname
            Raise:
                None
        """
        zook = self.zk_client
        broker_id_path = self.zk_paths[BROKER_IDS]
        broker_path = broker_id_path + "/" + str(broker_id)
        if zook.exists(broker_path):
            data, stat = zook.get(broker_

            return json.loads(data)["host"]
    def get_topics(self):
        """
            Get a list of all topics
            Return:
                  list of topic names
            Raise:
                  None
        """
        zook = self.zk_client
        broker_topics_path = self.zk_paths[BROKER_TOPICS]
        if zook.exists(broker_topics_path):
            topics = zook.get_children(broker_topics_path)
            return topics
    def get_number_of_partitions(self, topic):
        """
            Get the number of partitions for the topic
            Args:
                topic - topic name
            Return:
                number of partitions
            Raise:
                None
        """
        zook = self.zk_client
        broker_topics_path = self.zk_paths[BROKER_TOPICS]
        path = broker_topics_path + "/" + str(topic) + "/" + PARTITIONS
        if zook.exists(path):
            partitions = zook.get_children(path)
            return partitions.__len_
class Command(BaseCommand):
    """
    Create API Boilerplate from one or more django apps
    ./manage.py create_api my_app my_other_app
    """
    option_list = BaseCommand.option_list + (
        make_option(
            '--folder',
            action='store',
            default=None,
            dest='folder'
        ),
    )
    def handle(self, *args, **options):
        api = AutoAPI(*args)
        folder = options.get('folder', None)
        if folder:
            wd = os.getcwd()
            api_folder = os.path.join(wd, 'api')
            api_init = os.path.join(api_folder, '__init__.py')
            api_urls = os.path.join(api_folder, 'urls.py')
            api_views = os.path.join(api_folder, 'views.py')
            os.mkdir(api_folder)
            with open(api_init, 'a') as f:
                pass
            with open(api_urls, 'w') as f:
                f.write(api.__urlconf_str__())
            with open(api_views, 'w') as f:
                f.write(api.__resource_s
"""
(Description)
Created on Feb 21, 2014
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class ReferencesBroker(BrokerBase):
  def __init__(self, session):
    BrokerBase.__init__(self, session)
  def get_broker_class(self):
    return Reference
  def get_all_handlers(self):
    try:
      result = self.session.query(ReferenceHandler)
      return result.all()
    except SQLAlchemyError as error:
      raise BrokerException(error)
  def get_handler_by_uuid(self, uuid):
    try:
      result = self.session.query(ReferenceHandler).filter(ReferenceHandler.uuid == uuid).one()
    except NoResultFound:
      raise NothingFoundException('Nothing found with ID :{0} in {1}'.format(uuid, self.__class__.__name__))
    except MultipleResultsFound:
      raise TooManyResultsFoundException('Too many results found for ID :{0}'.format(uuid))
    except SQLAlchemyError as error:
      raise B

    return result
  def get_handler_by_id(self, identifier):
    try:
      result = self.session.query(ReferenceHandler).filter(ReferenceHandler.identifier == identifier).one()
    except NoResultFound:
      raise NothingFoundException('Nothing found with ID :{0} in {1}'.format(identifier, self.__class__.__name__))
    except MultipleResultsFound:
      raise TooManyResultsFoundException('Too many results found for ID :{0}'.format(identifier))
    except SQLAlchemyError as error:
      raise BrokerException(error)
    return result
class ReferenceDefintionsBroker(BrokerBase):
  def __init__(self, session):
    BrokerBase.__init__(self, session)
  def get_broker_class(self):
    return ReferenceDefinition
  def get_defintion_by_chksums(self, chksums):
    """
    Returns the attribute definition object with the given name
    Note: raises a NothingFoundException or a TooManyResultsFound Exception
    :param identifier: the id of the requested user object
    :type identifier: integer

    :returns: Object
    """
    try:
      definitions = self.session.query(self.get_broker_class()).filter(getattr(self.get_broker_class(), 'chksum').in_(chksums)).all()
      if definitions:
        return definitions
      else:
        return list()
    except NoResultFound:
      raise NothingFoundException(u'No {0} not found for CHKSUMS {1}'.format(self.get_broker_class().__class__.__name__,
                                                                             chksums))
    except SQLAlchemyError as error:
      self.session.rollback()
      raise BrokerException(error)
  def get_definition_by_name(self, name):
    try:
      return self.session.query(ReferenceDefinition).filter(ReferenceDefinition.name == name).one()
    except NoResultFound:
      raise NothingFoundException('Nothing found with ID :{0} in {1}'.format(name, self.__class__.__name__))
    except MultipleResultsFound:
      raise TooManyResultsFoundException('Too many results found for ID :{0}'.format(name
class TestBigcommerceApi(unittest.TestCase):
    """ Test API client creation and helpers"""
    def test_create_basic(self):
        api = bigcommerce.api.BigcommerceApi(host='store.mybigcommerce.com', basic_auth=('admin', 'abcdef'))
        self.assertIsInstance(api.connection, Connection)
        self.assertNotIsInstance(api.connection, OAuthConnection)
    def test_create_oauth(self):
        api = bigcommerce.api.BigcommerceApi(client_id='123456', store_hash='abcdef', access_token='123abc')
        self.assertIsInstance(api.connection, OAuthConnection)
    def test_default_api_endpoint(self):
        api = bigcommerce.api.BigcommerceApi(client_id='123456', store_hash='abcdef', access_token='123abc')
        self.assertEqual(api.api_service, 'api.bigcommerce.com')
    def test_alternate_api_endpoint_from_env(self):
        os.environ['BC_API_ENDPOINT'] = 'foobar.com'
        api = bigcommerce.api.BigcommerceApi(client_id='123456', store_hash='abcdef', access_token='123abc')
       

        del os.environ['BC_API_ENDPOINT']
    def test_default_auth_endpoint(self):
        api = bigcommerce.api.BigcommerceApi(client_id='123456', store_hash='abcdef', access_token='123abc')
        self.assertEqual(api.auth_service, 'login.bigcommerce.com')
    def test_alternate_auth_endpoint_from_env(self):
        os.environ['BC_AUTH_SERVICE'] = 'foobar.com'
        api = bigcommerce.api.BigcommerceApi(client_id='123456', store_hash='abcdef', access_token='123abc')
        self.assertEqual(api.auth_service, 'foobar.com')
        del os.environ['BC_AUTH_SERVICE']
    def test_create_incorrect_args(self):
        self.assertRaises(Exception, lambda: bigcommerce.api.BigcommerceApi(client_id='123', basic_auth=('admin', 'token')))
class TestApiResourceWrapper(unittest.TestCase):
    def test_create(self):
        api = MagicMock()
        api.connection = MagicMock()
        wrapper = bigcommerce.api.ApiResourceWrapper('ApiResource', api)
        self.assertEqual(api.connection, wrap
                              ProjectSheetQuestionAnswerResource, ProjectSheetQuestionResource, QuestionChoiceResource)
                       MarkerResource, MarkerCategoryResource, PostalAddressResource, PlaceResource)
admin.autodiscover()
api = Api(api_name='v0')
api.register(MapResource())
api.register(TileLayerResource())
api.register(MarkerResource())
api.register(DataLayerResource())
api.register(MarkerCategoryResource())
api.register(PostalAddressResource())
api.register(PlaceResource())
api.register(UserResource())
api.register(GroupResource())
api.register(ProfileResource())
api.register(ObjectProfileLinkResource())
api.register(BoardResource())
api.register(ListResource())
api.register(CardResource())
api.register(TaskResource())
api.register(CardCommentResource())
api.register(LabelResource())
api.register(BucketResource())
api.register(BucketTagResource())
api.register(BucketFileResource())
api.register(BucketFileCommentResource())
api.register(ProjectResource())
api.regis
starting_queue = None
stopping_queue = None
WORKER_NAME = 'TestWorker'
def make_broker(manager, max_workers, start_queue=None, stop_queue=None):
    global starting_queue
    global stopping_queue
    starting_queue = start_queue
    stopping_queue = stop_queue
    return manager_worker_broker.get(max_workers, manager, _TestWorker)
class _TestWorker(manager_worker_broker.AbstractWorker):
    def __init__(self, worker_connection, worker_arguments=None):
        super(_TestWorker, self).__init__(worker_connection)
        self._name = WORKER_NAME
        self._thing_to_greet = 'everybody'
        self._starting_queue = starting_queue
        self._stopping_queue = stopping_queue
    def set_inline_arguments(self, thing_to_greet):
        self._thing_to_greet = thing_to_greet
    def handle_stop(self, src):
        self.stop_handling_messages()
    def handle_test(self, src, an_int, a_str):
        assert an_int == 1
        assert a_str == "hello, world"
        self._worker_connection.p

    def run(self):
        if self._starting_queue:
            self._starting_queue.put('')
        if self._stopping_queue:
            self._stopping_queue.get()
        try:
            super(_TestWorker, self).run()
        finally:
            self._worker_connection.post_message('done')
class FunctionTests(unittest.TestCase):
    def test_get__inline(self):
        self.assertTrue(make_broker(self, 1) is not None)
    def test_get__processes(self):
        if sys.platform in ('cygwin', 'win32'):
            return
        self.assertTrue(make_broker(self, 2) is not None)
class _TestsMixin(object):
    """Mixin class that implements a series of tests to enforce the
    contract all implementations must follow."""
    def name(self):
        return 'TesterManager'
    def is_done(self):
        return self._done
    def handle_done(self, src):
        self._done = True
    def handle_test(self, src, an_int, a_str):
        self._an_int = an_int
        self._a_str = a_str
    def

        raise exception_type(exception_value)
    def setUp(self):
        self._an_int = None
        self._a_str = None
        self._broker = None
        self._done = False
        self._exception = None
        self._max_workers = None
    def make_broker(self, starting_queue=None, stopping_queue=None):
        self._broker = make_broker(self, self._max_workers, starting_queue,
                                   stopping_queue)
    def test_name(self):
        self.make_broker()
        worker = self._broker.start_worker()
        self.assertEquals(worker.name(), WORKER_NAME)
        worker.cancel()
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
        self._broker.cleanup()
    def test_cancel(self):
        self.make_broker()
        worker = self._broker.start_worker()
        self._broker.post_message('test', 1, 'hello, world')
        worker.cancel()
        worker.join(0.1)
        self.assertFalse(worker.is_alive())
        self._broker.cleanup()
   
class AbstractEventHandler(EventHandler):
    def __init__(self, topic, filterKey=None, filterValue=None):
        self.topic = topic
        self.activated = False
        self.eventBroker = None
        self.filter = None
        if (not filterKey == None) and (not filterValue == None):
             self.filter = FilterBuilder(filterKey, filterValue).get()
    
    def activate(self):
        if not self.activated:
            self.activated = True
            self. getEventBroker().subscribe(self.topic, self.filter, self, True)
        return self
    
    def deactivate(self):
        if self.activated:
            self.activated = False
            self.getEventBroker().unsubscribe(self);
        return self
    def getEventBroker(self):
        if self.eventBroker == None:
            self.eventBroker = E4Utils.getEclipseContext().get(Class.forName('org.eclipse.e4.core.services.events.IEventBroker'))
        return self.eventBroker
    
    def setEventBroker(self, eventBroker):

urls = (
        
    url("/", HomeController, action="login", name="login"),
    url("/login", HomeController, action="login", name="login"),
    url("/auth/login", HomeController, action="auth_login", name="auth_login"),
    url("/home", HomeController, action="home", name="home"),
   
    url("/equipes.{extension}", BancaController, action="busca_equipes", name="busca_equipes"),
    url("/equipe/{equipe_id}/atletas.{extension}", BancaController, action="busca_atletas_por_equipe", name="busca_atletas_por_equipe"),
    url("/equipe/{equipe_id}/posicao/{posicao}/atletas.{extension}", BancaController, action="busca_atletas_por_equipe_e_posicao", name="busca_atletas_por_equipe_e_posicao"),
    url("/posicao/{posicao}/atletas.{extension}", BancaController, action="busca_atletas_por_posicao", name="busca_atletas_por_posicao"),
    
    url("/banca", BancaController, action="banca", name="banca"),
    url("/supercraque.{extension}", BancaController, action="get_supercraque", name="get_super

    url("/atletas_card.{extension}", BancaController, action="atletas_card", name="atletas_card"),
    url("/cards", BancaController, action="cards_box", name="cards_box"),
    url("/atleta/{atleta_id}/comprar", BancaController, action="comprar_card", name="comprar_card"),
    url("/atleta/{atleta_id}/descartar", BancaController, action="descartar_card", name="descartar_card"),
    
    url("/loadAtletas.json", DesafioController, action="load_atletas", name="load_atletas"),
    url("/desafio/card/{card_id}/usuario_desafiado/{usuario_desafiado_id}/desafiar", DesafioController, action="enviar_desafio", name="enviar_desafio"),
    url("/desafio/{desafio_id}/card/{card_id}/aceitar", DesafioController, action="aceitar_desafio", name="aceitar_desafio"),
    url("/desafio/enviados.{extension}", DesafioController, action="busca_desafios_enviados", name="busca_desafios_enviados"),
    url("/desafio/recebidos.{extension}", DesafioController, action="busca_desafios_recebidos", name="busca_desafi
def populate():
    s1 = Signal(name="Alarm", signal_id="1")
    s2 = Signal(name="Warning", signal_id="2")
    s3 = Signal(name="Cancel", signal_id="3")
    
    s1.save()
    s2.save()
    s3.save()
    g1 = Group(group_id='123123')
    g2 = Group(group_id='123124')
    g1.save()
    g2.save()
    en1 = EnabledSignal(group=g1, signal=s1)
    en2 = EnabledSignal(group=g1, signal=s2)
    en3 = EnabledSignal(group=g1, signal=s3)
    en4 = EnabledSignal(group=g2, signal=s1)
    en5 = EnabledSignal(group=g2, signal=s3)
    en1.save()
    en2.save()
    en3.save()
    en4.save()
    en5.save()
    u1 = Person(name=u"Вася Пупкин", group=g1, registration_id='12353')
    u2 = Person(name=u"Иван Помидоров", group=g1, registration_id='45678')
    u3 = Person(name=u"Коля Иванов", group=g1, registration_id='457932')
    u4 = Person(name=u"Женя Некрасов", group=g2, registration_id='122345')
    u5 = Person(name=u"Галя Петрова", group=g2, registration_id='578632')
    u1.save()
    u2.save()
    u3
class Object(object): pass
class SaveCoverImageTest(unittest.TestCase, test.CustomAssertions):
    """Test all behavior related with te cover image.
    """
    def setUp(self):
        os = Mock()
        os.remove = Mock()
        self.saveImage = save_image.SaveImage(dependencies=test.mocks)
        self.saveImage.warnings = False
        self.saveImage.clientModel.form = {
            'cover': True
            ,'ext': 'png'
            ,'cover_image': 'ñalsjdfñlaksdjf'
            ,'id': 1}
        self.saveImage.get_article = Mock(return_value={
            'directory': ':memory:/prueba-1'
            ,'article_name': 'prueba-1'})
    def test_SaveImage_instance(self):
        """Should be an SaveImage instance."""
        self.assertIsInstance(self.saveImage, save_image.SaveImage)
    @unittest.skip('For now the cover image is out to use.')
    def test_get_article_model(self):
        """Should get the article model."""
        self.saveImage.setUp(Mock())
        self.assertCal

    @unittest.skip('I need find a way to test the random uuid in the name.')
    def test_cover_file_path(self):
        """Should create the path of the cover image file."""
        self.saveImage.setUp()
        self.saveImage.multimedia.get = Mock(return_value=[''])
        expected = ':memory:/prueba-1/prueba-1-cover.png'
        obtained = self.saveImage.create_file_name()
        self.assertEqual(obtained, expected)
    @unittest.skip('Not implemented yet.')
    def test_should_create_all_files_paths(self):
        self.saveImage.setUp()
        expected = [
            ':memory:/prueba-1/prueba-1-cover.png'
            ,':memory:/prueba-1/prueba-1-cover.png'
            ,':memory:/prueba-1/prueba-1-cover.png'
            ,':memory:/prueba-1/prueba-1-cover.png'
            ,':memory:/prueba-1/prueba-1-cover.png'
            ,':memory:/prueba-1/prueba-1-cover.png'
        ]
    @unittest.skip('For now the cover image is out to use.')
    def test_get_buffer_cover_image(self):
   

        return the raw image of the cover.
        """
        obtained = self.saveImage.get_buffer_image(self.saveImage.clientModel.form)
        expected = 'ñalsjdfñlaksdjf'
        self.assertEqual(obtained, expected)
    @unittest.skip('For now the cover image is out to use.')
    def test_erase_the_old_cover_image(self):
        """Should remove the old cover image file."""
        self.saveImage.setUp(Mock())
        self.saveImage.multimedia.get = Mock(
            return_value=[':memory:/prueba-1/prueba-1-cover.png'])
        self.saveImage.save_file()
        self.saveImage.remove.assert_called_with(
            ':memory:/prueba-1/prueba-1-cover.png')
class SaveImageTest(unittest.TestCase, test.CustomAssertions):
    """Test all behavior of the multimedia associated to an article.
    """
    def setUp(self):
        self.saveImage = save_image.SaveImage(dependencies=test.mocks)
        self.saveImage.warnings = False
        FieldStorage = Object()
        FieldStorage.filen
'''
Created on 10 nov. 2014
@author: Narcis2007
'''
'''
class TestRepositoryPLab:
    def __init__(self):
        self.__repository=RepositoryPLab()
        p1=ProblemaLaborator(1,1,"w","t")
        p2=ProblemaLaborator(2,2,"t","y")
        p3=ProblemaLaborator(3,3,"g","h")
        self.__repository.save(p1)
        self.__repository.save(p2)
        self.__repository.save(p3)
    
    def test_save(self):
        try:
            p1=ProblemaLaborator(1,1,"w","t")
            self.__repository.save(p1)
            assert False
        except EroareID:
            assert True
            
    def test_lungime(self):
        assert self.__repository.lungime()==3
    
    def test_delete(self):
        self.__repository.delete(11)
        assert self.__repository.lungime()==2
        try:
            self.__repository.delete(11)
            assert False
        except EroareID:
            assert True
    def test_find(self):
        p=self.__repository.find(22)
        p2=ProblemaLaborat

        assert p==p2
    
    def test_update(self):
        p2=ProblemaLaborator(2,2,"t","y")
        self.__repository.update(p2)
        p=self.__repository.find(22)
        assert p2==p
        try:
            p2=ProblemaLaborator(2,3,"r","b")
            self.__repository.update(p2)
            p=self.__repository.find(33)
            assert False
        except EroareID:
            assert True
        
    def test_get_all(self):
        l=self.__repository.get_all()
        assert len(l)==2
        
    def test_repository_plab(self):
        self.test_save()
        self.test_lungime()
        self.test_delete()
        self.test_find()
        self.test_update()
        self.test_get_all()
'''
class TestRepositoryPlab(unittest.TestCase):
    def setUp(self):
        self.__repository=RepositoryPLab()
        p1=ProblemaLaborator(1,1,"w","t")
        p2=ProblemaLaborator(2,2,"t","y")
        p3=ProblemaLaborator(3,3,"g","h")
        self.__repository.save(p1)
        self.__

        self.__repository.save(p3)
    
    def test_save(self):
        p1=ProblemaLaborator(1,1,"w","t")
        self.assertRaises(EroareID,lambda: self.__repository.save(p1))
            
    def test_lungime(self):
        assert self.__repository.lungime()==3
    
    def test_delete(self):
        self.__repository.delete(11)
        assert self.__repository.lungime()==2
        self.assertRaises(EroareID, lambda:self.__repository.delete(11))
    def test_find(self):
        p=self.__repository.find(22)
        p2=ProblemaLaborator(2,2,"t","y")
        assert p==p2
    
    def test_update(self):
        p2=ProblemaLaborator(2,2,"t","y")
        self.__repository.update(p2)
        p=self.__repository.find(22)
        assert p2==p
        p2=ProblemaLaborator(2,3,"r","b")
        self.assertRaises(EroareID, lambda:self.__repository.update(p2))
        
    def test_get_all(self):
        l=self.__repository.get_all()
        assert len(l)==3 
def suite():
    suite=unittest.Test
class Save(Plugin):
    warn_message     = Plugin.Property(default="WARNING: saving map in {delay}.")
    message          = Plugin.Property(default="MAP IS SAVING.")
    warn_command     = Plugin.Property(default="say %s")
    save_command     = Plugin.Property(default="save-all")
    save_off_command = Plugin.Property(default="save-off")
    save_on_command  = Plugin.Property(default="save-on")
    save_allowed     = True
    
    def setup(self):
        self.register(self.save, Hook, public=True, name='save', doc='save the map')
        self.register(self.save_off, Hook, public=True, name='save-plugin-off', doc='Disable save plugin.')
        self.register(self.save_on, Hook, public=True, name='save-plugin-on', doc='Enable save plugin.')
    
    def warn(self, delay):
        self.send_format(self.warn_command % self.warn_message, delay=delay)
    
    def save(self, event):
        if (self.save_allowed):
            action = self.save_real
            if event.args:
            
controller = MotionController.PyMotionController()
initialized = False
try:
    initialized = controller.initMotionManager()
except:
    print('\nException occured')
if initialized:
    print("Initialized")
    
    controller.initWalking()
    time.sleep(1)
    controller.walk(5, 0, 0)
    time.sleep(1)
    controller.walk(5, 10)
    time.sleep(1)
    controller.walk(5, -10)
    time.sleep(1)
    controller.walk(-1, 0, 2)
    
    time.sleep(5)
    controller.stopWalking()
    time.sleep(2)
    
    controller.initActionEditor()
    time.sleep(0.5)
    controller.executePage(15)
    while controller.actionRunning():
        time.sleep(0.5)
        
    controller.executePage(1)
    while controller.actionRunning():
        time.sleep(0.5)
        
    controller.executePage(15)
    while controller.actionRunning():
        time.sleep(0.5)
        
    controller.initHead()
    controller.moveHeadToHome()
    time.sleep(1)
    (l,r,u,d) = controller.getHeadAngleLimits()
    (p,t) = con
feeds = {
    'jobs' : feed.JobFeed
urlpatterns, debug_patterns = (
        urls_common.generate_patterns('frontend.afe', 'AfeClient'))
resource_patterns = defaults.patterns(
        '',
        (r'^/?$', resources.ResourceDirectory.dispatch_request),
        (r'^atomic_group_classes/?$',
         resources.AtomicGroupClassCollection.dispatch_request),
        (r'^atomic_group_classes/(?P<ag_name>.+?)/?$',
         resources.AtomicGroupClass.dispatch_request),
        (r'^atomic_taggings/?$',
         resources.AtomicLabelTaggingCollection.dispatch_request),
        (r'^atomic_taggings/(?P<ag_name>.+?),(?P<label_name>.+?)/?$',
         resources.AtomicLabelTagging.dispatch_request),
        (r'^labels/?$', resources.LabelCollection.dispatch_request),
        (r'^labels/(?P<label_name>.+?)/?$', resources.Label.dispatch_request),
        (r'^users/?$', resources.UserCollection.dispatch_request),
        (r'^users/(?P<username>[@\w]+)/?$', resources.User.dispatch_request),
        (r'^use

         resources.UserAclMembershipCollection.dispatch_request),
        (r'^user_acls/(?P<username>.+?),(?P<acl_name>.+?)/?$',
         resources.UserAclMembership.dispatch_request),
        (r'^acls/?$', resources.AclCollection.dispatch_request),
        (r'^acls/(?P<acl_name>.+?)/?$', resources.Acl.dispatch_request),
        (r'^hosts/?$', resources.HostCollection.dispatch_request),
        (r'^hosts/(?P<hostname>.+?)/?$', resources.Host.dispatch_request),
        (r'^labelings/?$', resources.HostLabelingCollection.dispatch_request),
        (r'^labelings/(?P<hostname>.+?),(?P<label_name>.+?)/?$',
         resources.HostLabeling.dispatch_request),
        (r'^host_acls/?$',
         resources.HostAclMembershipCollection.dispatch_request),
        (r'^host_acls/(?P<hostname>.+?),(?P<acl_name>.+?)/?$',
         resources.HostAclMembership.dispatch_request),
        (r'^tests/?$', resources.TestCollection.dispatch_request),
        (r'^tests/(?P<test_name>.+?)/?$', resources.Test.dis

        (r'^test_dependencies/?$',
         resources.TestDependencyCollection.dispatch_request),
        (r'^test_dependencies/(?P<test_name>.+?),(?P<label_name>.+?)/?$',
         resources.TestDependency.dispatch_request),
        (r'^execution_info/?$', resources.ExecutionInfo.dispatch_request),
        (r'^queue_entries_request/?$',
         resources.QueueEntriesRequest.dispatch_request),
        (r'^jobs/?$', resources.JobCollection.dispatch_request),
        (r'^jobs/(?P<job_id>\d+)/?$', resources.Job.dispatch_request),
        (r'^queue_entries/?$', resources.QueueEntryCollection.dispatch_request),
        (r'^queue_entries/(?P<queue_entry_id>\d+?)/?$',
         resources.QueueEntry.dispatch_request),
        (r'^health_tasks/?$', resources.HealthTaskCollection.dispatch_request),
        (r'^health_tasks/(?P<task_id>\d+)/?$',
         resources.HealthTask.dispatch_request),
    )
urlpatterns += defaults.patterns(
        '', (r'^resources/', defaults.include(resource_patterns)
"""
@name:      PyHouse/src/Modules/Lighting/test/xml_controllers.py
@author:    D. Brian Kimmel
@contact:   D.BrianKimmel@gmail.com
@copyright: (c) 2014-2017 by D. Brian Kimmel
@license:   MIT License
@note:      Created on Nov 22, 2014
@Summary:
There is a matrix of controllers to create here
"""
__updated__ = '2017-01-19'
        XML_DEVICE_INSTEON, \
        XML_DEVICE_UPB
        XML_SERIAL_LINUX_INTERFACE, \
        XML_USB_INTERFACE
        XML_UPB
        XML_SERIAL
        XML_USB
TESTING_CONTROLLER_SECTION = 'ControllerSection'
TESTING_CONTROLLER = 'Controller'
L_SERIAL_INTERFACE = XML_SERIAL_LINUX_INTERFACE
L_CONTROLLER_SECTION_START = '<' + TESTING_CONTROLLER_SECTION + '>'
L_CONTROLLER_SECTION_END = '</' + TESTING_CONTROLLER_SECTION + '>'
L_CONTROLLER_END = '</' + TESTING_CONTROLLER + '>'
TESTING_CONTROLLER_NAME_0 = 'Insteon Serial Controller'
TESTING_CONTROLLER_KEY_0 = '0'
TESTING_CONTROLLER_ACTIVE_0 = 'True'
TESTING_CONTROLLER_UUID_0 = 'Controlr-0000-0000-0000-2468acb6eb6

TESTING_CONTROLLER_COMMENT = 'Controller Comment'
TESTING_CONTROLLER_COMMENT_0 = 'Device Comment 0'
TESTING_CONTROLLER_FAMILY_INSTEON = 'Insteon'
TESTING_CONTROLLER_TYPE = '1'
TESTING_CONTROLLER_SUBTYPE = '2'
TESTING_CONTROLLER_ROOM_X = '3.4'
TESTING_CONTROLLER_ROOM_Y = '5.6'
TESTING_CONTROLLER_ROOM_Z = '1.2'
TESTING_CONTROLLER_ROOM_COORDS = '[' + TESTING_CONTROLLER_ROOM_X + ', ' + TESTING_CONTROLLER_ROOM_Y + ', ' + TESTING_CONTROLLER_ROOM_Z + ']'
TESTING_CONTROLLER_ROOM_NAME = "Testing Room Name ABDG"
TESTING_CONTROLLER_ROOM_UUID = 'Device..-Room-0001-0002-deadbeef1234'
L_CONTROLLER_START_0 = '    ' + \
        '<Controller Name="' + TESTING_CONTROLLER_NAME_0 + \
        '" Key="' + TESTING_CONTROLLER_KEY_0 + \
        '" Active="' + TESTING_CONTROLLER_ACTIVE_0 + \
        '">'
L_CONTROLLER_UUID_0 = '    <UUID>' + TESTING_CONTROLLER_UUID_0 + '</UUID>'
L_CONTROLLER_0 = '\n'.join([
    L_CONTROLLER_START_0,
    L_CONTROLLER_UUID_0,
    XML_DEVICE_INSTEON,
    XML_INSTEON_1,
    L_SERIA
def quitHandler(signum, frame):
	raise KeyboardInterrupt
signal.signal(signal.SIGQUIT, quitHandler)
signal.signal(signal.SIGTSTP, quitHandler)
omniORB.omniidlArguments(["-I./idl"])
orb          = CORBA.ORB_init(sys.argv)
ior          = file('/tmp/BrokerNameService.ior').read()
obj          = orb.string_to_object(ior)
nameservice  = obj._narrow(EDCBA.BrokerNameService)
registered = nameservice.getRegistered()
for item in registered:
	print "%s: %s" %( item, nameservice.getAddressOf(item))
if 'IP Broker' in registered:
	print "IP broker exists"
	tmp      = orb.string_to_object(nameservice.getAddressOf('IP Broker'))
	ipBroker = tmp._narrow(EDCBA.IPControlBroker)
	print 'Adding test: %s' % ipBroker.addInterface('test')
	print 'Adding test again: %s' % ipBroker.addInterface('test')
	print 'Adding test1: %s' % ipBroker.addInterface('test1')
	print 'Adding test2: %s' % ipBroker.addInterface('test2')
	ipBroker.test(EDCBA.IPInterface(None,None,None,None,None))
	print ipBroker.getInterface('test
def ursula_controller_ips(hostvars, groups, controller_name='controller'):
    controller_ips = set()
    for host in groups[controller_name]:
        controller_primary_interface = hostvars[host]['primary_interface']
        ip = hostvars[host][controller_primary_interface]['ipv4']['address']
        controller_ips.add(ip)
    return sorted(list(controller_ips))
def ursula_memcache_hosts(hostvars, groups, memcache_port, controller_name='controller'):
    controller_ips = ursula_controller_ips(hostvars, groups, controller_name)
    host_strings = ['%s:%s' % (c, memcache_port) for c in controller_ips]
    return ','.join(host_strings)
def ursula_package_path(project, version):
    package_name_format = "openstack-%(version)s" % locals()
    path = os.path.join("/opt/bbc", package_name_format, project)
    return path
class FilterModule(object):
    ''' ursula utility filters '''
    def filters(self):
        return {
            'ursula_controller_ips':    ursula_controller_ips,
      
"""
Fichier responsable de la sauvegarde et du chargement des informations
sur une partie (avancement des quetes, fillière etc...)
"""
currentSaveName = None
def check(name):
    return os.path.exists("save/"+name+".save")
def getAllNames():
    l = os.listdir("save/")
    lnames = []
    for item in l:
        if item.endswith(".save"):
            lnames.append(item[:-5])
    if "debugSave_" in lnames:
        lnames.remove("debugSave_")
    return lnames
def create(name,classe):
    if check(name):
        return False
    try:
        saveFile = open("save/"+name+".save","w")
        saveFile.write("1;  lvl joueur\n")
        if classe == "PTSI":
            saveFile.write("RLC;    capacite 1\n")
            saveFile.write("0;  lvl cap 1\n")
            saveFile.write("PFS;    capacite 2\n")
            saveFile.write("0;  lvl cap 2\n")
            saveFile.write("RDM;    capacite 3\n")
            saveFile.write("0;  lvl cap 3\n")
            saveFile.write("Laplace;    ulti\n")
 

        elif classe == "MPSI":
            saveFile.write("RLC;    capacite 1\n")
            saveFile.write("0;  lvl cap 1\n")
            saveFile.write("PFS;    capacite 2\n")
            saveFile.write("0;  lvl cap 2\n")
            saveFile.write("RDM;    capacite 3\n")
            saveFile.write("0;  lvl cap 3\n")
            saveFile.write("Laplace;    ulti\n")
            saveFile.write("0;  ulti lvl\n")
        elif classe == "PCSI":
            saveFile.write("RLC;    capacite 1\n")
            saveFile.write("0;  lvl cap 1\n")
            saveFile.write("PFS;    capacite 2\n")
            saveFile.write("0;  lvl cap 2\n")
            saveFile.write("RDM;    capacite 3\n")
            saveFile.write("0;  lvl cap 3\n")
            saveFile.write("Laplace;    ulti\n")
            saveFile.write("0;  ulti lvl\n")
        
        saveFile.write("1;  point bonus\n")
        
        saveFile.write("[]\n")
        saveFile.write("[1,t;2,t]")
    except:
        return False
    e

        saveFile.close()
    return True
def load(name,player):
    global currentSaveName
    if currentSaveName:
        return False
    else:
        currentSaveName = name
        try:
            saveFile = open("save/"+currentSaveName+".save","r")
            l = saveFile.readline()
            player.position = l.strip().split(",")
            player.position[1] = float(player.position[1])
            player.position[2] = float(player.position[2])
            player.lvl = int( saveFile.readline().strip().split(";")[0] )
            player.hp = 100*player.lvl
            player.classe = saveFile.readline().strip().split(";")[0]
            player.capacite1 = saveFile.readline().strip().split(";")[0]
            player.capacite1Lvl = int( saveFile.readline().strip().split(";")[0] )
            player.capacite2 = saveFile.readline().strip().split(";")[0]            
            player.capacite2Lvl = int( saveFile.readline().strip().split(";")[0] )
            player.capacite3 = s
log = logging.getLogger( 'test.tool_shed.test_db_util' )
def delete_obj( obj ):
    sa_session.delete( obj )
    sa_session.flush()
    
def delete_user_roles( user ):
    for ura in user.roles:
        sa_session.delete( ura )
    sa_session.flush()
    
def flush( obj ):
    sa_session.add( obj )
    sa_session.flush()
    
def get_all_repositories():
    return sa_session.query( model.Repository ).all()
def get_all_installed_repositories( actually_installed=False ):
    if actually_installed:
        return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ) \
                         .filter( and_( galaxy.model.tool_shed_install.ToolShedRepository.table.c.deleted == False,
                                        galaxy.model.tool_shed_install.ToolShedRepository.table.c.uninstalled == False,
                                        galaxy.model.tool_shed_install.ToolShedRepository.table.c.status == galaxy.model.tool_shed_install.ToolShedRepository.installation_

                         .all()
    else:
        return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ).all()
    
def get_category_by_name( name ):
    return sa_session.query( model.Category ) \
                     .filter( model.Category.table.c.name == name ) \
                     .first()
                     
def get_default_user_permissions_by_role( role ):
    return sa_session.query( model.DefaultUserPermissions ) \
                     .filter( model.DefaultUserPermissions.table.c.role_id == role.id ) \
                     .all()
                     
def get_default_user_permissions_by_user( user ):
    return sa_session.query( model.DefaultUserPermissions ) \
                     .filter( model.DefaultUserPermissions.table.c.user_id==user.id ) \
                     .all()
                     
def get_galaxy_repository_by_name_owner_changeset_revision( repository_name, owner, changeset_revision ):
    return install_session.query( galaxy.mod

                     .filter( and_( galaxy.model.tool_shed_install.ToolShedRepository.table.c.name == repository_name,
                                    galaxy.model.tool_shed_install.ToolShedRepository.table.c.owner == owner,
                                    galaxy.model.tool_shed_install.ToolShedRepository.table.c.changeset_revision == changeset_revision ) ) \
                     .first()
                     
def get_installed_repository_by_id( repository_id ):
    return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ) \
                     .filter( galaxy.model.tool_shed_install.ToolShedRepository.table.c.id == repository_id ) \
                     .first()
                     
def get_installed_repository_by_name_owner( repository_name, owner, return_multiple=False ):
    query = install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ) \
                           .filter( and_( galaxy.model.tool_shed_install.ToolShedRepositor
"""
*******************************************************************
  Copyright (c) 2013, 2014 IBM Corp.
  All rights reserved. This program and the accompanying materials
  are made available under the terms of the Eclipse Public License v1.0
  and Eclipse Distribution License v1.0 which accompany this distribution. 
  The Eclipse Public License is available at 
     http://www.eclipse.org/legal/epl-v10.html
  and the Eclipse Distribution License is available at 
    http://www.eclipse.org/org/documents/edl-v10.php.
  Contributors:
     Ian Craggs - initial implementation and/or documentation
*******************************************************************
"""
"""
1. Start the model broker.  Clean state.
2. Run the spec, one step at a time until conformance statement hit.
3. Reduce sequence to shortest.
4. Store.
Repeat until all conformance statements hit.
Do store tests that reach a conformance statement in a different way.
"""
class Brokers(threading.Thread):
  def __init__(

    threading.Thread.__init__(self)
  def run(self):
    mqtt.broker.run()
    while not mqtt.broker.server:
      time.sleep(.1)
    time.sleep(1)
  def stop(self):
    mqtt.broker.stop()
    while mqtt.broker.server:
      time.sleep(.1) 
    time.sleep(1)
  def reinitialize(self):
    mqtt.broker.reinitialize()
qlog = queue.Queue()
qh = logging.handlers.QueueHandler(qlog)
formatter = logging.Formatter(fmt='%(levelname)s %(asctime)s %(name)s %(message)s',  datefmt='%Y%m%d %H%M%S')
qh.setFormatter(formatter)
qh.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setFormatter(formatter)
ch.setLevel(logging.ERROR)
broker_logger = logging.getLogger('MQTT broker')
broker_logger.addHandler(qh)
broker_logger.addHandler(ch)
logger = logging.getLogger('suite_generate')
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setFormatter(formatter)
ch.setLevel(logging.INFO)
logger.addHandler(ch)
def create():
	global logger, qlog
	conformances = set([])
	restart = False
	while not r

		logger.debug("stepping")
		restart = MQTTV311_spec.mbt.step()
		logger.debug("stepped")
		data = qlog.get().getMessage()
		logger.debug("data %s", data)
		while data and data.find("Waiting for request") == -1 and data.find("Finishing communications") == -1:
			if data.find("[MQTT") != -1:
				logger.debug("Conformance statement %s", data)
				conformances.add(data + "\n" if data[-1] != "\n" else data)
			data = qlog.get().getMessage()
			logger.debug("data %s", data)
	return conformances
if __name__ == "__main__":
	os.system("rm -rf tests")
	os.mkdir("tests")
	test_no = 0
	logger.info("Generation starting")
	broker = Brokers() 
	broker.start()
	while test_no < 10:
		test_no += 1
		conformance_statements = create()
		logger.info("Test %d created", test_no)
		filename = "tests/test.log.%d" % (test_no,)
		infile = open(filename)
		lines = infile.readlines()
		infile.close()
		outfile = open(filename, "w")
		outfile.writelines(list(conformance_statements) + lines)
		outfile.close()
		br
log = getLogger(__name__)
class SilkExtension(SingletonPlugin):
    
    implements(IConfigurer, inherit=True)
    implements(IGenshiStreamFilter, inherit=True)
    implements(IRoutes, inherit=True)
    
    def update_config(self, config):
        here = os.path.dirname(__file__)
        rootdir = os.path.dirname(os.path.dirname(here))
        our_public_dir = os.path.join(rootdir, 'ckanext',
                                      'silk', 'theme', 'public')
        template_dir = os.path.join(rootdir, 'ckanext',
                                    'silk', 'theme', 'templates')
        config['extra_public_paths'] = ','.join([our_public_dir,
                config.get('extra_public_paths', '')])
        config['extra_template_paths'] = ','.join([template_dir,
                config.get('extra_template_paths', '')])
    
    def filter(self, stream):
        routes = request.environ.get('pylons.routes_dict')
        log.info(routes)
        if routes.get('controller') == 'package':
     

                    
                    '''<li class>
                        <a class href="/silk/%s">
                            <img src="/images/icons/rdf_flyer.24.png" height="16px" width="16px" alt="None" class="inline-icon ">
                            Silk
                        </a>
                    </li>''' % routes.get('id')
                    
                ))
        return stream
        
    def before_map(self, map):
        map.connect('/silk/editlinkagerules/{id}/{linkage_rule_id}', controller='ckanext.silk.controller:SilkController', action='edit_linkage_rules')
        map.connect('/silk/readlinkagerule/{id}/{linkage_rule_id}', controller='ckanext.silk.controller:SilkController', action='resource_read')
        map.connect('/silk/removelinkagerule/{id}/{linkage_rule_id}', controller='ckanext.silk.controller:SilkController', action='remove_linkage_rule')
        map.connect('/silk/editrestriction/{linkage_rule_id}/{dataset}', controller='ckanext.silk.contr

        map.connect('/silk/editpathinput/{linkage_rule_id}/{dataset}/{path_input_id}', controller='ckanext.silk.controller:SilkController', action='path_input_edit')
        map.connect('/silk/newpathinput/{linkage_rule_id}/{dataset}', controller='ckanext.silk.controller:SilkController', action='path_input_new')
        map.connect('/silk/edittransformation/{linkage_rule_id}', controller='ckanext.silk.controller:SilkController', action='transformation_edit')
        map.connect('/silk/editcomparison/{linkage_rule_id}', controller='ckanext.silk.controller:SilkController', action='comparison_edit')
        map.connect('/silk/editaggregation/{linkage_rule_id}', controller='ckanext.silk.controller:SilkController', action='aggregation_edit')
        map.connect('/silk/get_resources/{value}', controller='ckanext.silk.controller:SilkController', action='get_resources')
        map.connect('/silk/get_classes/{property}/{resource_url}', controller='ckanext.silk.controller:SilkController', acti
__author__ = "Patrick Meyer"
class Root():
	def index(self):
		return "You found the index. There is nothing here. Go, use the API."
if __name__ == '__main__':
	ip = '127.0.0.1'
	port = 8000
	cherrypy.config.update({'server.socket_host': ip})
	cherrypy.config.update({'server.socket_port': port})
	index_controller = Root()
	api_controller = Api()
	d = cherrypy.dispatch.RoutesDispatcher()
	d.connect(name='root',		action='index',								controller=index_controller,	route='/')
	d.connect(name='api',		action='register',							controller=api_controller,	route='/api/register')
	d.connect(name='api',		action='login',								controller=api_controller,	route='/api/login')	
	d.connect(name='api',		action='getUsers',							controller=api_controller,	route='/api/getUsers')
	d.connect(name='api',		action='getPositionsMap',					controller=api_controller,	route='/api/getPositionsMap')
	d.connect(name='api',		action='getUserPath',						controller=api_controller,	route='/api/getUserPath')
	d.connect(nam

	d.connect(name='api',		action='getAllLogbookEntriesByUser',		controller=api_controller,	route='/api/getAllLogbookEntriesByUser')
	d.connect(name='api',		action='secretValidForNextCache',			controller=api_controller,	route='/api/secretValidForNextCache')
	d.connect(name='api',		action='makeGuestbookEntry',				controller=api_controller,	route='/api/makeGuestbookEntry')
	d.connect(name='api',		action='getGuestbookIndex',					controller=api_controller,	route='/api/getGuestbookIndex')
	d.connect(name='api',		action='getGuestbookEntryById',				controller=api_controller,	route='/api/getGuestbookEntryById')
	d.connect(name='api',		action='nop',								controller=api_controller,	route='/api/nop')
	d.connect(name='api',		action='updatePosition',					controller=api_controller,	route='/api/updatePosition')
	d.connect(name='api',		action='makeLogbookEntry',					controller=api_controller,	route='/api/makeLogbookEntry')
	d.connect(name='api',		action='markPuzzleSolved',					controller=api_controlle
class EmenciaMailingListExporterView(TemplateView):
    
    @classmethod
    def as_csv(cls, request, **kwargs):
        mailing_list = MailingList.objects.get(pk=kwargs['mailing_list_id'])
        
        response = HttpResponse(mimetype='text/csv')
        response['Content-Disposition'] = 'attachment; filename=%sEmailList%s.csv' % (mailing_list.name, date.today().strftime('%Y%m%d'))
        
        subscribers = mailing_list.subscribers
        
        writer = csv.writer(response)
        
        emails = []
        
        for subscriber in subscribers.all():
            emails.append(subscriber.email)
        
        writer.writerow(emails)
        
        ''' writer.writerow(['Broker',
                         '30 Days (' + data['date_plus_30'].strftime('%Y-%m-%d') + ')',
                         '60 Days (' + data['date_plus_60'].strftime('%Y-%m-%d') + ')',
                         '90 Days (' + data['date_plus_90'].strftime('%Y-%m-%d') + ')'])
        
        for brok
class redis_live(daemonized):
    def run_daemon(self):
        define("port", default=8888, help="run on the given port", type=int)
        define("debug", default=0, help="debug mode", type=int)
        tornado.options.parse_command_line()
        
        print os.path.abspath('.')
        handlers = [
        (r"/api/servers", ServerListController),
        (r"/api/info", InfoController),
        (r"/api/status", StatusController),
         (r"/api/infolist",InfoListController),
        (r"/api/commands", CommandsController),
        (r"/api/settings",SettingsController),
        (r"/api/slowlog",SlowlogController),
        (r"/(.*)", BaseStaticFileHandler, {"path": os.path.abspath('.')+'/www'})
        ]
    
        server_settings = {'debug': options.debug}
        application = tornado.web.Application(handlers, **server_settings)
        application.listen(options.port)
        tornado.ioloop.IOLoop.instance().start()
if __name__ == "__main__":
    live= redis_live()
    live.s
"""This module provides container classes and interfaces
for inserting data into the database.
Created on Jul 9, 2013
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class ObjectBroker(BrokerBase):
  """
  This broker handles all operations on event objects
  """
  def __init__(self, session):
    BrokerBase.__init__(self, session)
  def get_broker_class(self):
    """
    overrides BrokerBase.get_broker_class
    """
    return Object
  def get_parent_object_by_object(self, obj):
    try:
      result = self.session.query(RelatedObject).filter(RelatedObject.child_id == obj.identifier).one()
      return result.parent
    except sqlalchemy.orm.exc.NoResultFound:
      raise NothingFoundException('No parent found for object with ID {0} in {1}'.format(obj.identifier, self.__class__.__name__))
    except sqlalchemy.exc.SQLAlchemyError as error:
      raise BrokerException(error)
 
class ControllerGUIFrame(QtGui.QFrame):
    def __init__(self):
        super(ControllerGUIFrame, self).__init__()
        self.init_ui()
    def init_ui(self):
        self.ui = QTControllerGUIFrame()
        self.ui.setupUi(self)
        self.ui.start_button.clicked.connect(self.start_button_clk)
        self.ui.kill_button.clicked.connect(self.kill_button_clk)
        self.controller = "l_arm_controller"
        self.ui.controller_combo.addItem("l_arm_controller")
        self.ui.controller_combo.addItem("l_cart")
        self.ui.controller_combo.addItem("r_arm_controller")
        self.ui.controller_combo.addItem("r_cart")
        self.ui.controller_combo.activated[str].connect(self.combo_activated)
    def combo_activated(self, text):
        self.controller = text
    def start_button_clk(self):
        if self.controller is not None:
            Popen("rosrun pr2_controller_manager pr2_controller_manager start %s" % self.controller, 
                  shell=True)
    def kill_bu
if sys.version_info[0] == 2:
else:
class TestResolve(unittest.TestCase):
    def _repository_factory(self, packages):
        repository = Repository()
        for p in packages:
            repository.add_package(p)
        return repository
    def test__latest_package_simple(self):
        packages = [
            dummy_repository_package_factory("swig", "1.3.40", 1),
            dummy_repository_package_factory("swig", "1.3.40", 2),
            dummy_repository_package_factory("swig", "2.0.1", 1),
        ]
        repository = self._repository_factory(packages)
        resolver = Resolve(repository)
        latest = resolver._latest_package(
            _LegacyRequirement.from_requirement_string("swig")
        )
        self.assertEqual(latest.key, "swig-2.0.1-1.egg")
        resolver = Resolve(repository)
        latest = resolver._latest_package(
            _LegacyRequirement.from_requirement_string("swigg")
        )
        self.assertIsNone(latest)
    def test__latest_pack
class TestManageVariants(unittest.TestCase):
	def test_variant_item_codes(self):
		manage_variant = frappe.new_doc("Manage Variants")
		manage_variant.update({
			"item": "_Test Variant Item",
			"attributes": [
				{
					"attribute": "Test Size",
					"attribute_value": "Small"
				},
				{
					"attribute": "Test Size",
					"attribute_value": "Large"
				}
			]
		})
		manage_variant.generate_combinations()
		self.assertEqual(manage_variant.variants[0].variant, "_Test Variant Item-S")
		self.assertEqual(manage_variant.variants[1].variant, "_Test Variant Item-L")
		
		self.assertEqual(manage_variant.variants[0].variant_attributes, "Small")
		self.assertEqual(manage_variant.variants[1].variant_attributes, "Large")
		manage_variant.create_variants()
	def test_attributes_are_unique(self):
		manage_variant = frappe.new_doc("Manage Variants")
		manage_variant.update({
			"item": "_Test Variant Item",
			"attributes": [
				{
					"attribute": "Test Size",
					"attribute_value": "Small"
	
class AuthenticationTests(ApplicationTest):
  pluginPackages = {
    IAuth: authentication
  }
  def _generateRepositoryDirectory(self, name=None, dir=None):
    if name is None:
      return tempfile.mkdtemp('.git', 'tmp', dir)
    else:
      if dir is not None:
        path = dir + "/" + name + ".git"
      else:
        path = "/tmp/" + name + ".git"
      os.mkdir(path)
      return path
  def _testHTTP(self, user=None, name=None):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(name, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("http", self.http, remoteRepository.path.split('/')[-1], user))
    self.generateComplicatedCommit()
    return remoteRepository
  def _testSSH(self, user, name=None):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(name, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("ssh", self.ssh, remoteRepository.path.spli

    self.generateComplicatedCommit()
    return remoteRepository
  def _setUp(self, allowAnon=False):
    self.config = _createDrupalAuthConfigFile(self.repoPath, allowAnon)
    self.app = Factory(self.config, self.pluginPackages)
    self.ssh = reactor.listenTCP(0, self.app.createSSHFactory())
    self.http = reactor.listenTCP(0, self.app.createHTTPFactory())
  def testInitialization(self):
    self._setUp()
    self.app._invariant()
  def tearDown(self):
    if self.ssh is not None:
      self.ssh.stopListening()
    if self.http is not None:
      self.http.stopListening()
    GitTestHelper.tearDown(self)
class AnonymousAuthenticationTests(AuthenticationTests):
  def testAllowed(self):
    self._setUp(True)
    remoteRepository = self._testHTTP()
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
  def testDisallowed(self):
    self._setUp(False)

    remoteRepository = self._testHTTP()
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
class PasswordAuthenticationTests(AuthenticationTests):
  def testInitialization(self):
    self._setUp()
    self.app._invariant()
    self.assertTrue(isinstance(self.app.getAuth(), DrupalTestAuth))
  def testHTTPValidUserPass(self):
    self._setUp()
    remoteRepository = self._testHTTP("test")
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository, "pass").addCallback(processEnded)
  def testHTTPValidUserInvalidPass(self):
    self._setUp()
    remoteRepository = self._testHTTP("test")
    def processEnded(result):
      self.assertPermissionDenied()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepositor
"""PPA.Template - templating support in PPA.
This package defines a set of classes to find, interpret and evaluate templates
in various templating languages.
PPA.Template provides:
fromString              - compiles template passed as string
fromFile                - compiles template from file-like object
TemplateController      - controller for all template operation, use it if you
                          need more control
FileSourceFinder        - finds templates by name from series of directories
TemplateNotFoundError   - exception, raise when template not found
You may look deeper in code to use all provided classes directly, but more
common usage is like this:
Simple usage:
    template = Template.fromString('<h1><%= title %></h1>', type='pyem')
    result = template.toString({'title': 'Python rulez!'})
    template = Template.fromFile('template.pyem')
    template.toFile(sys.stdout, {'title': 'Python rulez!'})
More complex example:
    source_finder = Template.FileSourceFinder

                                               '/path/to/tamplates2'])
    controller = Template.TemplateController(source_finder)
    template = controller.getTemplate('template')
    template.toFile(sys.stdout, global_ns, local_ns)
"""
__all__ = ['TemplateNotFoundError', 'TemplateController', 'FileSourceFinder']
_controller = None
def fromString(source, name='?', type=None, controller=None):
    '''Compiles template passed as string (str or unicode) and returns
    TemplateWrapper instance.'''
    global _controller
    if controller is None:
        if _controller is None:
            _controller = TemplateController()
        controller = _controller
    return controller.compileString(source, name, type)
def fromFile(source_file, name=None, type=None, controller=None):
    '''Compiles template from path or file-like object and returns
    TemplateWrapper instance.'''
    global _controller
    close = False
    if not hasattr(source_file, 'read'):
        source_file = open(sourc
try:
    class DjangoURLTests(unittest.TestCase):
        def test_controller_data_url(self):
            """URL controller/controller.path should resolve to the helio_get_controller_data method."""
            resolution = urlpatterns[0].resolve('controller/the.controller.path')
            self.assertEqual(resolution.func, helio_get_controller_data)
            self.assertEqual(resolution.kwargs, {'controller_path': 'the.controller.path'})
        def test_notification_url(self):
            """URL notification/controller/name should resolve to the helio_dispatch_notification method."""
            resolution = urlpatterns[1].resolve('notification/a.controller.path/the-notification')
            self.assertEqual(resolution.func, helio_dispatch_notification)
            self.assertEqual(resolution.kwargs, {'controller_path': 'a.controller.path',
                                                 'notification_name': 'the-notification'})
        def test_get_view_state_url(self):
       
def GetRegisterController(User, LoginController):
    """ Return the RegisterController in the proper scope """
    class RegisterController(CreateController):
        """ Controller to register a user """
        
        def __init__(self, toJson, pwdScheme=None, recordValueProvider=None):
            """ Initialize the Register Controller """
            self.pwdScheme = PasswordScheme() if pwdScheme is None else pwdScheme
            self.loginController = LoginController(toJson, pwdScheme=pwdScheme)
            CreateController.__init__(self, User, None, recordValueProvider=recordValueProvider)
        
        def performWithJSON(self, json=None):
            """ Create a User record with the given credentials """
            try:
                createKwargs = dict(json)
                createKwargs['password'] = self.pwdScheme.make(json['password'])
                user = self.create(createKwargs)
                return self.loginController.performWithJSON(json=json)
          
ResourceType = Enum(**{'DVD Drive': 'DVD Drive', 'Graphics Controller': 'Graphics Controller', 'Other': 'Other', 'Memory': 'Memory', 'Other Storage': 'Other Storage', 'Parallel SCSI HBA': 'Parallel SCSI HBA', 'Other Network Adapter': 'Other Network Adapter', 'IEEE 1394 Controller': 'IEEE 1394 Controller', 'PCI Controller': 'PCI Controller', 'Storage Extent': 'Storage Extent', 'SIO Controller': 'SIO Controller', 'PS2 Controller': 'PS2 Controller', 'CD Drive': 'CD Drive', 'None': 'None', 'iSCSI HBA': 'iSCSI HBA', 'Base Partitionable Unit': 'Base Partitionable Unit', 'Keyboard': 'Keyboard', 'Power Supply': 'Power Supply', 'IB HCA': 'IB HCA', 'Ethernet Adapter': 'Ethernet Adapter', 'Processor': 'Processor', 'Pointing Device': 'Pointing Device', 'Disk Drive': 'Disk Drive', 'Serial Port': 'Serial Port', 'Floppy Drive': 'Floppy Drive', 'Parallel Port': 'Parallel Port', 'USB Controller': 'USB Controller', 'I/O Device': 'I/O Device', 'Tape Drive': 'Tape Drive', 'Computer': 'Computer', 'FC HBA':
LOG = logging.getLogger(__name__)
class SimpleReadOnlyNovaManageTest(tempest.cli.ClientTestBase):
    """
    This is a first pass at a simple read only nova-manage test. This
    only exercises client commands that are read only.
    This should test commands:
    * with and without optional parameters
    * initially just check return codes, and later test command outputs
    """
    def test_admin_fake_action(self):
        self.assertRaises(subprocess.CalledProcessError,
                          self.nova_manage,
                          'this-does-nova-exist')
    def test_help_flag(self):
        self.nova_manage('', '-h')
    def test_version_flag(self):
        self.assertNotEqual("", self.nova_manage('', '--version',
                                                 merge_stderr=True))
        self.assertEqual(self.nova_manage('version'),
                         self.nova_manage('', '--version', merge_stderr=True))
    def test_debug_flag(self):
        self.assertNotEqual("
__author__ = 'jintao'
global_config = ConfigLoader()
global_binlog_event_manage = BinlogEventManage()
global_binlog_data_manage = BinlogDataManage()
global_packet_manage = PacketManage(global_binlog_event_manage, global_binlog_data_manage)
global_signal = threading.Event()
def start_sync():
    global global_config
    start_pos = global_config.pos()
    start_binlog = global_config.binlog()
    global_binlog_data_manage.set_filename(start_binlog)
    global_binlog_data_manage.set_position(start_pos)
    while True:
        mysql_channel = MYSQLChannel(global_config.host(), global_config.port(), global_config.username(), global_config.password(), global_config.database(), global_config.master_id())
        if mysql_channel.initChannel() == False:
            return False
        recv_data = mysql_channel.dump_binlog(start_pos, start_binlog)
        print 'dump...'
        if recv_data != '':
            (packet_list, count) = global_packet_manage.parse(recv_data)
            start_pos 
admin.autodiscover()
urlpatterns = patterns('',
    (r'^grappelli/',include('grappelli.urls')),
    url(r'^admin/', include(admin.site.urls)),
    url(r'^favicon.ico$', 'django.views.generic.simple.redirect_to', {'url': '/static/images/favicon.png'}),
    url(r'^accounts/login/$', 'engine.account.userlogin',name="userlogin"),
    url(r'^accounts/logout/$',  'django.contrib.auth.views.logout',
                                {'next_page': '/accounts/login/'},name="userlogout"),
    url(r'^accounts/changepassword/$', 'engine.account.changepassword',name="changepassword"),
    url(r'^$', 'engine.views.index'),
    url(r'^manage/class/$', 'engine.class.index',name="manageclass"),
    url(r'^manage/addclass/$', 'engine.class.addclass',name="addclass"),
    url(r'^manage/editclass/$', 'engine.class.editclass',name="editclass"),
    url(r'^manage/deleteclass/$', 'engine.class.deleteclass',name="deleteclass"),
    url(r'^ajax/get_classes_list/$', 'engine.class.get_classes_list',name="get_class

    
    url(r'^manage/student/$', 'engine.student.index',name="managestudent"),
    url(r'^manage/addstudent/$', 'engine.student.addstudent',name="addstudent"),
    url(r'^manage/editstudent/$', 'engine.student.editstudent',name="editstudent"),
    url(r'^manage/deletestudent/$', 'engine.student.deletestudent',name="deletestudent"),
    url(r'^manage/initstudent/$', 'engine.student.initstudent',name="initstudent"),
    url(r'^studentprofile/$', 'engine.student.studentprofile',name="studentprofile"),
    url(r'^ajax/get_students_list/$', 'engine.student.get_students_list',name="get_students_list"),
    url(r'^ajax/select_classes/$', 'engine.class.select_classes',name="select_classes"),
    url(r'^manage/assessment/$', 'engine.assessment.index',name="manageassessment"),
    url(r'^manage/addassessment/$', 'engine.assessment.addassessment',name="addassessment"),
    url(r'^manage/editassessment/$', 'engine.assessment.editassessment',name="editassessment"),
    url(r'^manage/deleteassess

    url(r'^view/assessment/$', 'engine.assessment.viewassessment',name="viewassessment"),
    url(r'^ajax/get_assessments_list/$', 'engine.assessment.get_assessments_list',name="get_assessments_list"),
    url(r'^ajax/view_assessments_list/$', 'engine.assessment.view_assessments_list',name="view_assessments_list"),
    url(r'^manage/goassessment/$', 'engine.assessment.goassessment',name="goassessment"),
    url(r'^ajax/go_assessments_list/$', 'engine.assessment.go_assessments_list',name="go_assessments_list"),
    url(r'^ajax/go_assessments/$', 'engine.assessment.go_assessments',name="go_assessments"),
    
    url(r'^manage/grades/$', 'engine.grade.index',name="managegrades"),
    url(r'^manage/classgrades/$', 'engine.grade.classgrades',name="classgrades"),
    url(r'^ajax/studentgrades/$', 'engine.grade.studentgrades',name="studentgrades"),
    url(r'^ajax/ajaxclassgrades/$', 'engine.grade.ajaxclassgrades',name="ajaxclassgrades"),
    url(r'^manage/behavior/$', 'engine.activity.beha
class Command(NoArgsCommand):
    help = "Initialize attributes"
    def handle_noargs(self, **options):
        ChemotherapySchema(title='Capecitabina 2gr', risk=0).save()
        ChemotherapySchema(title='Cisplatino/pemetrexed', risk=0).save()
        ChemotherapySchema(title='Dacarbazina', risk=0).save()
        ChemotherapySchema(title='Docetaxel semanal', risk=0).save()
        ChemotherapySchema(title='Folfiri', risk=0).save()
        ChemotherapySchema(title='Gemcitabina 1gr', risk=0).save()
        ChemotherapySchema(title='Gemcitabina 1.25gr', risk=0).save()
        ChemotherapySchema(title='Paclitaxel semanal', risk=0).save()
        ChemotherapySchema(title='Pemetrexed', risk=0).save()
        ChemotherapySchema(title='Capecitabina 2.5gr', risk=1).save()
        ChemotherapySchema(title='Carboplatino/gemcitabina AUC 4-6 1gr d 1 y 8', risk=1).save()
        ChemotherapySchema(title='Carboplatino/pemetrexed', risk=1).save()
        ChemotherapySchema(title='Carboplatino/paclit

        ChemotherapySchema(title='Cisplatino/ gemcitabina d 1 y 8', risk=1).save()
        ChemotherapySchema(title='ECF', risk=1).save()
        ChemotherapySchema(title='Folfox 85 mg', risk=1).save()
        ChemotherapySchema(title='Gemcitabina/irinotecan', risk=1).save()
        ChemotherapySchema(title='Doxorrubicina liposomal 50 mg c/4 sem', risk=1).save()
        ChemotherapySchema(title='Topotecan semanal', risk=1).save()
        ChemotherapySchema(title='Xelox', risk=1).save()
        ChemotherapySchema(title='5fu/leucovorina (Roswell-park)', risk=2).save()
        ChemotherapySchema(title='5fu/leucovorina(Mayo)', risk=2).save()
        ChemotherapySchema(title='5-fu/lv + bevacizumab', risk=2).save()
        ChemotherapySchema(title='CAF', risk=2).save()
        ChemotherapySchema(title='Carboplatino/docetaxel 75 / 75', risk=2).save()
        ChemotherapySchema(title='Cisplatino/etoposido', risk=2).save()
        ChemotherapySchema(title='Cisplatino/gemcitabina D 1,8 y 15', r

        ChemotherapySchema(title='Cisplatino/paclitaxel 135- 24hs c/3 sem', risk=2).save()
        ChemotherapySchema(title='CMF clasico', risk=2).save()
        ChemotherapySchema(title='Doxorrubicina c/3 sem', risk=2).save()
        ChemotherapySchema(title='Folfox 100/30', risk=2).save()
        ChemotherapySchema(title='Gemcitabina/pemetrexed', risk=2).save()
        ChemotherapySchema(title='Irinotecan cada 3 semanas', risk=2).save()
        ChemotherapySchema(title='Paclitaxel cada 3 semanas', risk=2).save()
        ChemotherapySchema(title='Docetaxel cada 3 semanas', risk=2).save()
        ChemotherapySchema(title='Topotecan semanal', risk=2).save()
        medic = Group(name="Medic")
        medic.save()
        medic.permissions.add(Permission.objects.get(codename='add_patient'))
        medic.permissions.add(Permission.objects.get(codename='change_patient'))
        medic.permissions.add(Permission.objects.get(codename='delete_patient'))
        medic.permissions.add(Permiss
  'target_defaults': {
    'variables': {
      'deps': [
        'libchrome-<(libbase_ver)',
        'dbus-c++-1',
      ],
      'enable_exceptions': 1,
    },
  },
  'targets': [
    {
      'target_name': 'permission-broker-proxy',
      'type': 'none',
      'variables': {
        'xml2cpp_type': 'proxy',
        'xml2cpp_in_dir': '../permission_broker/dbus_bindings',
        'xml2cpp_out_dir': 'include',
      },
      'sources': [
        '<(xml2cpp_in_dir)/org.chromium.PermissionBroker.xml',
      ],
      'includes': ['../../platform2/common-mk/xml2cpp.gypi'],
    },
    {
      'target_name': 'broker_service',
      'type': 'executable',
      'variables': {
        'deps': ['libbrillo-<(libbase_ver)'],
      },
      'dependencies': [
        'permission-broker-proxy',
      ],
      'sources': [
        'broker_service.cc',
        'broker_service.h',
        'org.chromium.PermissionBroker.h',
      ],
    },
    {
      'target_name': 'container_config_parser',
      'type

      'cflags': [
        '-fvisibility=default',
      ],
      'sources': [
        'container_config_parser.cc',
      ],
    },
    {
      'target_name': 'device_jail',
      'type': 'executable',
      'variables': {
        'deps': [
          'fuse',
          'libbrillo-<(libbase_ver)',
        ],
      },
      'dependencies': [
        'permission-broker-proxy',
      ],
      'sources': [
        'device_jail/device_jail.cc',
        'device_jail/permission_broker_client.cc',
        'device_jail/permission_broker_client.h',
      ],
    },
  ],
  'conditions': [
    ['USE_test == 1', {
      'targets': [
        {
          'target_name': 'container_config_parser_unittest',
          'type': 'executable',
          'includes': ['../common-mk/common_test.gypi'],
          'defines': ['UNIT_TEST'],
          'variables': {
            'deps': [
              'libbrillo-test-<(libbase_ver)',
              'libchrome-test-<(libbase_ver)',
            ],
          },
         
CURRENT_DIR = os.path.abspath(os.path.dirname(__file__))
CONFIG_FILE = CURRENT_DIR + "".join('/../conf/config.ini')
class RootController(object):
    @cherrypy.expose
    def index(self):
        return "o-jigi"
    @cherrypy.expose
    def default(self,*args, **kwargs):
        if cherrypy.request.method == "POST":
            path = "".join(args)
            payload = json.loads(kwargs["payload"])
            dispatch = Dispatch(path.lower(), payload, CONFIG_FILE)
            script = "{0}{1}/{2}".format(dispatch.dispatch_path,
                                         dispatch.repository,
                                         dispatch.script_name)
            cherrypy.log('DISPATCH Executing: {0}'.format(script))
            result = dispatch.run()
            if result['status_code'] == 0:
                message = result['message']
                cherrypy.log('DISPATCH Successful Execution: {0}'.format(script))
            elif result['status_code'] == -1:
                messa
class Manage (object):
	def __init__(self):
		self.mapper=routes.Mapper()
		self.container_controller=ContainerController()
		self.image_controller=ImageController()
		self.mapper.connect('/containers',
				controller=self.container_controller,
				action='index',
				conditions={'method':['GET']},
		)
		self.mapper.connect('/containers/{container_id}',
				controller=self.container_controller,
				action='inspect',
				conditions={'method':['GET']},
		)
		self.mapper.connect('/containers',
				controller=self.container_controller,
				action='create',
				conditions={'method':['POST']},
		)
		
		self.mapper.connect('/containers/{container_id}',
				controller=self.container_controller,
				action='delete',
				conditions={'method':['DELETE']},
		)
		self.mapper.connect('/images',
				controller=self.image_controller,
				action='index',
				conditions={'method':['GET']},
		)
		self.mapper.connect('/images/{image_id}',
				controller=self.image_controller,
				action='inspect',
				con
def forwardDeclartions():
	"Force some functions to be dynamic"
	mockRepository = settings.Repository()
	settings.addListsToRepository(None, None, mockRepository)
	settings.cancelRepository(mockRepository)
	settings.getDisplayedDialogFromConstructor(mockRepository)
	settings.getProfileBaseName(mockRepository)
	settings.getReadRepository(mockRepository)
	settings.readSettingsFromText(mockRepository, '')
	settings.saveRepository(mockRepository)
	settings.startMainLoopFromConstructor(mockRepository)
	settings.writeSettings(mockRepository)
	settings.writeSettingsPrintMessage(mockRepository)
	settings.StringSetting().getFromValue('', mockRepository, '')
	settings.StringSetting().getFromValueOnly('', mockRepository, '')
	settings.StringSetting().getFromValueOnlyAddToRepository('', mockRepository, '')
	settings.FileNameInput().getFromFileName([('','')], '', mockRepository, '')
	settings.GridVertical(0, 0).setExecutablesRepository(mockRepository)
	settings.HelpPage().setToNameRepository('', mo
deploy_contracts = [
    "BuildByteArrayFactory",
def test_initializing_dispute_gas_is_covered(deploy_client, get_computation_request,
                                             deploy_broker_contract, deployed_contracts,
                                             get_log_data, StatusEnum):
    factory = deployed_contracts.BuildByteArrayFactory
    broker = deploy_broker_contract(factory._meta.address)
    expected = "\x01\x02\x03\x04\x05\x06\x07"
    _id = get_computation_request(
        broker, "abcdefg",
        initial_answer="wrong",
        challenge_answer=expected,
        initialize_dispute=True,
    )
    exec_txn_hash = broker.executeExecutable(_id, 0)
    exec_txn_receipt = deploy_client.wait_for_transaction(exec_txn_hash)
    assert broker.getRequest(_id)[5] == StatusEnum.FirmResolution
    gas_log_data = get_log_data(broker.GasReimbursement, exec_txn_hash)
    gas_reimbursement = gas_log_data['value']
    gas_actual = int(exec_txn_receipt['gasUsed'], 16)
    assert g
def _get_base_folder(host):
    return '~/sites/' + host
def _get_manage_dot_py(host):
    return '{path}/virtualenv/bin/python {path}/source/manage.py'.format(
        path=_get_base_folder(host)
    )
def reset_database():
    run('{manage_py} flush --noinput'.format(
        manage_py=_get_manage_dot_py(env.host)
    ))
def create_session_on_server(email, password):
    cmd_string = (
        "{manage_py} create_session_cookie "
        "--email={email} --password={password}"
    )
    serialized_cookie= run(cmd_string.format(
        manage_py=_get_manage_dot_py(env.host),
        email=email,
        password=password,
    ))
    print(serialized_cookie)
def create_user(email, password):
    cmd_string = (
        "{manage_py} create_user "
        "--email={email} --password={password}"
    )
    run(cmd_string.format(
        manage_py=_get_manage_dot_py(env.host),
        email=email,
        password=password,
    ))
def send_fixture_file(filepath):
    fixtures_path = (
     
requests.packages.urllib3.disable_warnings() 
logger=logging.getLogger(__name__)
class ContextBrokerError(Exception) :
    pass
class attrib(UserDict) :
    def as_list(self) :
        r=[]
        for (k,v) in self.items() :
            d=dict(name=k,value=str(v))
            if (type(v)==float) :
                d["type"]="float"
            else :
                if (type(v)==int) :
                    d["type"]="integer"
                else :
                    d["type"]="string"
            r.append(d)
        return(r)
class cb_entity() :
    def __init__(self,theid,thebroker) :
        self.id=theid
        self.broker=thebroker
    def values(self) :
        r=self.broker.request("v1/contextEntities/%s" % (self.id))
        if r["statusCode"]["code"]=="200" :
            return r["contextElement"]
        else :
            raise ContextBrokerError(json.dumps(r["statusCode"]))
    def __iter__(self) :
        v=self.values()
        return((a["name"] for a in v["attributes"])

           
    def __getitem__(self,key) :
        r=self.broker.request("v1/contextEntities/%s/attributes/%s" % (self.id,key))
        if "attributes" in r and r["attributes"][0]["name"]==key :
            v=r["attributes"][0]
            try :
                if v["type"]=="float" :
                    return float(v["value"])
                if v["type"]=="integer" :
                    return int(v["value"])
            except ValueError :
                pass
            return v["value"]
        else :
            raise KeyError("%s: %s" % (key,json.dumps(r["statusCode"])))
    def __setitem__(self,key,val) :
        r=self.broker.request("v1/contextEntities/%s/attributes/%s" % (self.id,key),
                                   verb="post",
                                   data=json.dumps(dict(value=val)))
        if r["code"]=="200" :
            return
        else :
            raise ContextBrokerError(json.dumps(r["statusCode"]))
    
class contextbroker() :
    
    def _

        self._url=url
        param.update(dict(headers={'Content-Type' : 'application/json', 
                                   'Accept' : 'application/json'}))
        self._param=param
    def request(self,path,verb="get",**mparam):
        if mparam :
            param=self._param.copy()
            param.update(**mparam)
        else :
            param=self._param
        try :
            method=getattr(requests,verb)
        except AtttributeError as e:
            raise AttributeError("verb can be get, put, post - got %s" % verb)
        return method(urllib.parse.urljoin(self._url,path),**param).json()
    def __getitem__(self,key) :
        return cb_entity(key,self)
   
    def __setitem__(self,key,ob) :
        data=json.dumps({ 'attributes' : ob.as_list()})
        r=self.request("v1/contextEntities/%s" % key,
                            verb="post",
                            data=data
                            )
        logger.debug("set %s to %s : %s" % (key,data,
BUYING_VALUE = 32.87
SELLING_VALUE = 33.92
SHARES = 1000
COMMISSION = .02
    
BOUGHT_FOR = SHARES * BUYING_VALUE
PAID_BROKER = BOUGHT_FOR * COMMISSION
JOE_PAID = BOUGHT_FOR + PAID_BROKER
SOLD_FOR = SHARES * SELLING_VALUE
BROKER_MADE = SOLD_FOR * COMMISSION
JOE_MADE = SOLD_FOR - JOE_PAID - BROKER_MADE
    
print('Joe purchased ', SHARES, ' shares at $', BUYING_VALUE,\
      ' per share for a total of $', format(BOUGHT_FOR, '.2f'), sep='')
print('Joe paid his broker a 2% commission fee, which equates to $',\
      format(PAID_BROKER, '.2f'), sep='')
print('Joe paid $', format(JOE_PAID, '.2f'),\
      ' for the shares along with the commission fee.', sep='')
print()
print('Joe sold ', SHARES, ' shares at $', SELLING_VALUE,\
      ' per share for a total of $', format(SOLD_FOR, '.2f'), sep='')
print('Joe paid his broker a 2% commission fee again, which totaled to $',
      format(BROKER_MADE, '.2f'), sep='')
print("For Joe's final income of $", format(JOE_MADE, '.2f'), sep='')
print()
if 
try:
    saveFile = open("saves.txt", 'r')
    saveFile.close()
except Exception:
    saveFile = open("saves.txt", 'w+')
    saveFile.close()
def checkSave():
    saveFile = open("saves.txt", 'r')
    if saveFile.read() == '':
        return False
    return True
def saveGame(vararray):
    saveFile = open("saves.txt", 'w+')
    saveInfo = ''
    for key in vararray:
        saveInfo += str(key) + '*' + str(vararray[key]) + '-' 
    saveFile.write(saveInfo)
    saveFile.close()
    print ('Save complete.')
def loadGame():
    saveFile = open("saves.txt", 'r')
    saveInfo = saveFile.read()
    vararray = {}
    temp1 = ''
    temp2 = ''
    stg1 = True
    stg2 = False
    for letter in saveInfo:
        if stg1:
            if letter != '*':
                temp1 += letter
            else:
                stg1 = False
                stg2 = True
        elif stg2:
            if letter != '-':
                temp2 += letter
            else:
                stg1 = True
             
Ice.loadSlice('-I {} Geocloud.ice'.format(Ice.getSliceDir()))
class GroundStation(Ice.Application):
    def run(self,args):
        com = self.communicator()
        if not com:
            raise RuntimeError("Not communicator")
        else:
            print "ID:",args[0]
            query = com.stringToProxy('IceGrid/Query')
            q = IceGrid.QueryPrx.checkedCast(query)
            if not q:
                raise RuntimeError("Invalid proxy")
            try:
                broker = q.findObjectById(com.stringToIdentity('broker'))
                brokerPrx = geocloud.BrokerPrx.checkedCast(broker)
                print brokerPrx
                orch = q.findObjectById(com.stringToIdentity('orchestrator'))
                orchestratorPrx = geocloud.OrchestratorPrx.checkedCast(orch)
                print orchestratorPrx
            except Exception as e:
                print e
                sys.exit(-1)
            brokerPrx.begin_startScenario(1)
            sys.exit(0)
if _
"""celeryconfig wrapper.
   .. moduleauthor:: Xiaodong Wang <xiaodongwang@huawei.com>
"""
if os.environ.get('CELERY_CONFIG_LOGGING'):
    flags.init()
    flags.OPTIONS.logfile = util.parse(setting.CELERY_LOGFILE)
    logsetting.init()
CELERY_RESULT_BACKEND = 'amqp://'
BROKER_PROTOCOL = 'amqp'
DEFAULT_BROKER_USER = 'guest'
BROKER_USER = lazypy.delay(
    lambda: util.get_from_config(
        setting.CONFIG, [
            'propertySources', 0, 'source',
            'lograbbitmq.instance.username'
        ],
        DEFAULT_BROKER_HOST
    )
BROKER_PASSWORD_ENCRYPT_PATTERN = {
    'strContent': '%(password)s',
    'strSecretkey': lazypy.delay(
        lambda: util.get_from_config(
            setting.CONFIG, [
                'propertySources', 0, 'source',
                'lograbbitmq.instance.secretkey'
            ],
            'DEPLOY'
        )
    ),
    'strSecretValue': lazypy.delay(
        lambda: util.get_from_config(
            setting.CONFIG, [
                'propertySou

                'lograbbitmq.instance.secretValue'
            ],
            'B2CAD4CE182A2736D90D8AA46D1683191D975D9D3150297'
            'F9497F06FE35004F6E396D98426B4490755FAEBC5FC4713F1'
        )
    )
DEFAULT_BROKER_ENCRYPTED_PASSWORD = '98BC9FF413F3C5F993FD2400ECFA0EBD'
BROKER_ENCRYPTED_PASSWORD = lazypy.delay(
    lambda: util.get_from_config(
        setting.CONFIG, [
            'propertySources', 0, 'source',
            'lograbbitmq.instance.password'
        ],
        DEFAULT_BROKER_ENCRYPTED_PASSWORD
    )
DEFAULT_BROKER_PASSWORD = 'guest'
BROKER_PASSWORD = lazypy.delay(
    lambda: util.cipher_password(
        url=setting.DECRYPT_URL,
        params=BROKER_PASSWORD_ENCRYPT_PATTERN,
        password=BROKER_ENCRYPTED_PASSWORD,
        encrypted_key=None,
        default_password=DEFAULT_BROKER_PASSWORD
    )
DEFAULT_BROKER_HOST = 'rabbitmq'
BROKER_HOST = lazypy.delay(
    lambda: util.get_from_config(
        setting.CONFIG, [
            'propertySources', 0, 'source'

            'rabbitmq.host'
        ],
        DEFAULT_BROKER_HOST
    )
DEFAULT_BROKER_PORT = 5672
BROKER_PORT = lazypy.delay(
    lambda: util.get_from_config(
        setting.CONFIG, [
            'propertySources', 0, 'source',
            'rabbitmq.port'
        ],
        DEFAULT_BROKER_PORT
    )
BROKER_ADDR = lazypy.delay(
    lambda: (
        '%s:%s' % (util.parse(BROKER_HOST), util.parse(BROKER_PORT))
    )
BROKER_URL = lambda: '%s://%s:%s@%s//' % (
    util.parse(BROKER_PROTOCOL),
    util.parse(BROKER_USER),
    util.parse(BROKER_PASSWORD),
    util.parse(BROKER_ADDR)
CELERY_IMPORTS = ('orca.tasks.tasks',)
CELERY_ACCEPT_CONTENT = ['pickle', 'json', 'msgpack', 'yaml']
CELERY_CREATE_MISSING_QUEUES = True
CELERY_DEFAULT_QUEUE = 'deploy'
CELERY_DEFAULT_EXCHANGE = 'deploy'
CELERY_DEFAULT_ROUTING_KEY = 'deploy'
C_FORCE_ROOT = 1
celeryconfig_file = util.parse(setting.CELERYCONFIG_FILE)
if celeryconfig_file:
    celeryconfig_dir = util.parse(setting.CELERYCONFIG_DIR)
    CELERY_C
  "targets": [
    {
      "target_name": "libINCHIAPI",
      "type": "static_library",
      'conditions': [
        ['OS=="mac"',
          {
            'xcode_settings': {
            }
          }
        ],
        ['OS=="linux"',
          {
            'cflags': [
              '-w',
              '-fexceptions'
            ]
          }
        ]
      ],
      "direct_dependent_settings": {
        'include_dirs': [
           "INCHI-1-API/INCHI_API"
        ]
      },
      "sources": [
      "INCHI-1-API/INCHI_API/inchi_dll/ichi_bns.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichi_io.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichican2.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichicano.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichicans.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiisot.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichilnct.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichimak2.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichimake.c",
      "INCHI-1-API/INCHI_API/

      "INCHI-1-API/INCHI_API/inchi_dll/ichimap2.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichimap4.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichinorm.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiparm.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiprt1.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiprt2.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiprt3.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiqueu.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiread.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichiring.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr1.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr2.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr3.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr4.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr5.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr6.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichirvr7.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichisort.c",
      "INCHI-1-API/INCHI_API/inchi_dll/ichister.c",
      "INCH
repositories = []
def get_tile_repository(mapservice, conf):
    repos = pick_repository_from_list(conf)
    if repos is None:
        repos = create_repos_inst(mapservice, conf)
        append_repository_to_list(repos, conf)
    return repos
def append_repository_to_list(repos, conf):
    global repositories
    repos_entry = {"repos": repos, "configpath": conf.init_path, "type": conf.repository_type}
    repositories.append(repos_entry)
    return True
def pick_repository_from_list(conf):
    """returns instance of repository from list or None"""
    global repositories
    found_repos = None
    idx = 0
    for rep in repositories[:]:
        if rep["repos"].is_finished():
            del repositories[idx]
            idx = idx - 1
        else:
            if rep["configpath"] == conf.init_path and rep["type"] == conf.repository_type:
                found_repos = rep["repos"]
        idx = idx + 1
    return found_repos
def create_repos_inst(mapservice, conf):
    if conf.reposito
                                view_repository, repository_settings, repository_area51,    \
                                repository_branches, repository_commits, repository_graphs
urlpatterns = [
    url(r'new$', new_repository, name='new_repository'),
    url(r'^api/', include('repository.api.urls')),
    url(r'(?P<username>\w+)/(?P<repository>[-\w]+).git/info/refs', get_info_refs, name='get_info_refs'),
    url(r'(?P<username>\w+)/(?P<repository>[-\w]+).git/git-upload-pack$', service_rpc, name='service_rpc'),
    url(r'(?P<username>\w+)/(?P<repository>[-\w]+).git/git-receive-pack$', service_rpc, name='service_rpc'),
    url(r'(?P<username>\w+)/(?P<repository>[-\w]+).git/settings$', repository_settings, name='repository_settings'),
    url(r'(?P<username>\w+)/(?P<repository>[-\w]+).git/area51$', repository_area51, name='repository_area51'),
    url(r'(?P<username>\w+)/(?P<repository>[-\w]+).git/branches$', repository_branches, name='repository_branches'),
    url(r'(?P<username>\
                                    WampClientProtocol
brokers_list = []
use_xy = True
class SensorDataConsumerClientProtocol(WampClientProtocol):
   """
   Protocol for the sensor data consumer client. Uses WAMP protocol.
   """
   def onSessionOpen(self):
      print "Connected to ", wsuri
      def default_response(topic, event):
         print "Received event: ", topic, event
      
      def save_to_file(topic, event):
         io_file.write(str(str(event['sensor']) + "," + event['lat']) + "," + str(event['lng']) + "," + str(event['data']) + "," + str(event['timestamp']) + "," + str((datetime.datetime.now() - datetime.datetime.strptime(event['timestamp'], "%Y-%m-%d %H:%M:%S.%f")).total_seconds()) + "\n")
         io_file.flush()
      for sensor in sensors.split(","):
         self.subscribe(sensor, save_to_file)
def request_broker_address(registry_address,location):
   """Request one broker"""
   payload = {'location': location}
   req = requests.get(registry_address+"/request_br

   response_json = req.text
   response = json.loads(response_json)
   return response["broker_address"]
def request_brokers_l(registry_address, location, radius, max_brokers, sensors):
   """Request a list of up to max_brokers brokers based on a location string (e.g. "Moscow")"""
   payload = {'location': location, 'max_brokers' : max_brokers, 'radius' : radius, 'sensors' : sensors}
   req = requests.get(registry_address + "/request_brokers", params=payload)
   response_json = req.text
   response = json.loads(response_json)
   return response
def request_brokers_xy(registry_address, lat, lng, radius, max_brokers, sensors):
   """Request a list of up to max_brokers brokers based on coordinates"""
   payload = {'lat': lat, 'lng' : lng, 'max_brokers' : max_brokers, 'radius' : radius, 'sensors' : sensors}
   try: 
      req = requests.get(registry_address + "/request_brokers", params=payload) 
      response_json = req.text
      response = json.loads(response_json)
      return respons

   except requests.exceptions.RequestException:
      print "Trying to get the broker again"
      time.sleep(0.5)
      request_brokers_xy(registry_address, lat, lng, radius, max_brokers, sensors)
if __name__ == '__main__':
   log.startLogging(sys.stdout)
   
   parser = argparse.ArgumentParser()
   parser.add_argument('-r', '--registry', type=str)
   parser.add_argument('-s', '--sensors', type=str)
   parser.add_argument('-l', '--location', type=str)
   parser.add_argument('-b', '--maxbrokers', type=int)
   parser.add_argument('-d', '--radius', type=int)
   parser.add_argument('-x', '--lat', type=str)
   parser.add_argument('-y', '--lng', type=str)
   parser.add_argument('-o', '--outputfilename', type=str)
   args = parser.parse_args()
   sensors = args.sensors
   location = args.location
   lat = args.lat
   lng = args.lng
   registry_address = args.registry
   max_brokers = args.maxbrokers
   radius = args.radius
   output = args.outputfilename
   if (location != None):
      use_
V = EnpkgVersion.from_string
class TestRepository(unittest.TestCase):
    def packages_from_definition(self, packages_definition,
                                 repository_info=None):
        repository_info = repository_info or RepositoryInfo("dummy")
        parser = PrettyPackageStringParser(EnpkgVersion.from_string)
        return [
            RepositoryPackageMetadata(
                parser.parse_to_package(line), repository_info
            )
            for line in packages_definition.splitlines()
        ]
    def test_simple(self):
        packages_definition = textwrap.dedent(u"""\
        dummy 1.0.1-1
        dummy_with_appinst 1.0.0-1
        dummy_with_entry_points 1.0.0-1
        dummy_with_proxy 1.3.40-3
        dummy_with_proxy_scripts 1.0.0-1
        dummy_with_proxy_softlink 1.0.0-1
        nose 1.2.1-1
        nose 1.3.0-1
        nose 1.3.0-2\
        """)
        packages = self.packages_from_definition(packages_definition)
        repository = Repository()
  

        repository = Repository(packages)
        self.assertEqual(len(repository), len(packages))
        self.assertEqual(list(repository), packages)
        repository = Repository(reversed(packages))
        self.assertEqual(len(repository), len(packages))
        self.assertEqual(list(repository), packages)
    def test_update(self):
        packages_definition = textwrap.dedent(u"""\
        dummy 1.0.1-1
        dummy_with_appinst 1.0.0-1
        dummy_with_entry_points 1.0.0-1
        dummy_with_proxy 1.3.40-3
        dummy_with_proxy_scripts 1.0.0-1
        dummy_with_proxy_softlink 1.0.0-1
        nose 1.2.1-1
        nose 1.3.0-1
        nose 1.3.0-2\
        """)
        packages = self.packages_from_definition(packages_definition)
        repository = Repository(packages[:4])
        self.assertEqual(len(repository), 4)
        repository.update(packages[4:])
        self.assertEqual(len(repository), len(packages))
        self.assertEqual(list(repository), packages)
    

        packages_definition = textwrap.dedent(u"""\
        dummy 1.0.1-1
        dummy_with_appinst 1.0.0-1
        dummy_with_entry_points 1.0.0-1
        dummy_with_proxy 1.3.40-3
        dummy_with_proxy_scripts 1.0.0-1
        dummy_with_proxy_softlink 1.0.0-1
        nose 1.2.1-1
        nose 1.3.0-1
        nose 1.3.0-2\
        """)
        packages = self.packages_from_definition(packages_definition)
        repository = Repository(packages)
        package = repository.find_package("nose", V("1.3.0-1"))
        self.assertEqual(package.name, "nose")
        self.assertEqual(package.version, V("1.3.0-1"))
    def test_find_unavailable_package(self):
        packages_definition = textwrap.dedent(u"""\
        dummy 1.0.1-1
        dummy_with_appinst 1.0.0-1
        dummy_with_entry_points 1.0.0-1
        dummy_with_proxy 1.3.40-3
        dummy_with_proxy_scripts 1.0.0-1
        dummy_with_proxy_softlink 1.0.0-1
        nose 1.2.1-1
        nose 1.3.0-1
        nose 1.3.0-2\
  
class KaskoCalcTestCase(unittest.TestCase):
    config = json.load(open("config.json"))
    controller = None
    @staticmethod
    def wait(condition_function, timeout=60):
        attempts = 0
        while condition_function() and attempts < timeout:
            time.sleep(1)
            attempts += 1
    @classmethod
    def setUpClass(cls):
        cls.controller = Controller(Firefox())
        cls.controller.driver.maximize_window()
        cls.controller.driver.get(cls.config["url"])
        with open(cls.config["output"], 'w') as fd:
            fd.write("Марка,Модель,Год,Цена,Только ущерб (без угона),Угон (без ключей) + ущерб\n")
    @classmethod
    def tearDownClass(cls):
        cls.controller.driver.close()
    @parameterized.expand(from_csv(config["input"]))
    def test(self, car):
        self.controller.option(self.controller.car_brand, car.brand).click()
        time.sleep(3)
        self.controller.option(self.controller.car_model, car.model).click()
        self.con

        self.controller.car_price.clear()
        self.controller.car_price.send_keys(car.price)
        self.controller.car_usage_date.clear()
        self.controller.car_usage_date.send_keys("01.01.{0}".format(car.year))
        self.controller.option(self.controller.car_horse_power, "201 и более").click()
        self.controller.new_car.click() if car.year == 2014 else self.controller.old_car.click()
        self.controller.no_credit.click()
        self.controller.auto_start_no.click()
        self.controller.closed_list.click()
        self.controller.driver_age.clear()
        self.controller.driver_age.send_keys(30)
        self.controller.driver_experience.clear()
        self.controller.driver_experience.send_keys(10)
        self.controller.option(self.controller.driver_sex, "Мужской").click()
        self.controller.option(self.controller.driver_marital_status, "Состою в браке").click()
        self.controller.option(self.controller.driver_children, "Есть").click()
        

        self.controller.variable_insured_sum.click()
        self.controller.no_franchise.click()
        self.controller.last_name.clear()
        self.controller.last_name.send_keys(u"Фамилия")
        self.controller.first_name.clear()
        self.controller.first_name.send_keys(u"Имя")
        self.controller.patronymic.clear()
        self.controller.patronymic.send_keys(u"Отчество")
        self.controller.age.clear()
        self.controller.age.send_keys(30)
        self.controller.phone_code.clear()
        self.controller.phone_code.send_keys(u"999")
        self.controller.phone_number.clear()
        self.controller.phone_number.send_keys(u"9999999")
        self.controller.email.clear()
        self.controller.email.send_keys(u"1@example.com")
        self.controller.calculate.click()
        self.wait(self.controller.calculate_loading.is_displayed)
        self.controller.only_damage.click()
        self.wait(self.controller.loading.is_displayed)
        bonus = Bonus(ri
class WorkerThread(threading.Thread):
    _worker = None
    _lock = None
    _confpath = None
    def __init__(self, lock, confpath):
        threading.Thread.__init__(self)
        self._lock = lock
        self._confpath = confpath
    def stop(self):
        if self._worker:
            self._worker.stop()
    def isup(self):
        if self._worker:
            return self._worker.isup()
        else:
            return False
    def run(self):
        self._lock.acquire()
        self._worker = wmain(self._confpath)
        self._lock.release()
        self._worker.work()
class BrokerThread(threading.Thread):
    _broker = None
    _lock = None
    _confpath = None
    def __init__(self, lock, confpath):
        threading.Thread.__init__(self)
        self._lock = lock
        self._confpath = confpath
    def stop(self):
        if self._broker:
            self._broker.stop()
    def isup(self):
        res = False
        if self._broker:
            if self._broker.isup():
  

        return res
    def run(self):
        self._lock.acquire()
        self._broker = bmain(self._confpath)
        self._lock.release()
class InfraLauncher(object):
    brokerlist = []
    workerlist = []
    conf = None
    @staticmethod
    def waitbrokers():
        maxtry = 0
        while maxtry < 5:
            maxtry += 1
            res = True
            for b in InfraLauncher.brokerlist:
                print b
                if not(b.isup()):
                    res = False
            if not(res):
                sleep(0.3)
            else:
                break
        if not(res):
            assert 0, 'broker not started'
    @staticmethod
    def waitworkers():
        maxtry = 0
        while maxtry < 5:
            maxtry += 1
            res = True
            for b in InfraLauncher.workerlist:
                if not(b.isup()):
                    res = False
            if not(res):
                sleep(0.3)
            else:
                break
        i
try:
except ImportError:
class ZopeVersionHistory(
    VersionHistory.VersionHistory,
    RoleManager,
    OFS.SimpleItem.Item,
    ):
    """The ZopeVersionHistory build on the core VersionHistory class to
       provide the Zope management interface and other product trappings."""
    security = AccessControl.ClassSecurityInfo()
    security.setDefaultAccess('deny')
    meta_type = 'Version History'
    manage_options=(
        ( {'label': 'Contents',    'action':'manage_main',
           'help': ('ZopeVersionControl', 'VersionHistory-Manage.stx')},
          {'label': 'Properties', 'action':'manage_properties_form',
           'help': ('ZopeVersionControl', 'VersionHistory-Properties.stx')},
        ) +
        RoleManager.manage_options +
        OFS.SimpleItem.Item.manage_options
        )
    icon='misc_/ZopeVersionControl/VersionHistory.gif'
    security.declareProtected('View management screens', 'manage_main')
    manage_main = DTMLFile('dtml/VersionHistoryManageMain', globals

    manage_main._setName('manage_main')
    manage = manage_main
    security.declareProtected(
        'View management screens', 'manage_properties_form'
        )
    manage_properties_form = DTMLFile(
        'dtml/VersionHistoryProperties', globals()
        )
    security.declareProtected('Manage repositories', 'manage_edit')
    def manage_edit(self, REQUEST=None):
        """Change object properties."""
        if REQUEST is not None:
            message="Saved changes."
            return self.manage_properties_form(
                self, REQUEST, manage_tabs_message=message
                )
    def __getitem__(self, name):
        activity = self._branches.get(name)
        if activity is not None:
            return activity.__of__(self)
        raise KeyError, name
    security.declarePrivate('objectIds')
    def objectIds(self, spec=None):
        return self._branches.keys()
    security.declarePrivate('objectValues')
    def objectValues(self, spec=None):
        retur
class EventService:
    def __init__(self, event_repository, user_repository):
        self._event_repository = event_repository
        self._user_repository = user_repository
    def list_events(self, current_user_email=None):
        user = None
        if current_user_email:
            user = self._user_repository.find_user_by_email(current_user_email)
        return self._event_repository.list_events(current_user=user)
    @service
    def create_event(self, name, description, start, end):
        event = self._event_repository.create_event(
            name, description, start, end
        )
        return event.event_id
class AttendanceService:
    def __init__(self, event_repository, user_repository):
        self._event_repository = event_repository
        self._user_repository = user_repository
    @service
    def attend_event_by_user(self, event_id, user_email):
        event = self._event_repository.read_event(event_id)
        user = self._user_repository.find_user_by_e
def save_wave_file(filename, data):
    wf = wave.open(filename, 'wb')
    wf.setnchannels(1)
    wf.setsampwidth(2)
    wf.setframerate(SAMPLING_RATE)
    wf.writeframes("".join(data))
    wf.close()
NUM_SAMPLES = 2000
SAMPLING_RATE = 8000
LEVEL = 1500
COUNT_NUM = 20
SAVE_LENGTH = 8
pa = PyAudio()
stream = pa.open(format=paInt16, channels=1, rate=SAMPLING_RATE, input=True,
                 frames_per_buffer=NUM_SAMPLES)
save_count = 0
save_buffer = []
while True:
    string_audio_data = stream.read(NUM_SAMPLES)
    audio_data = np.fromstring(string_audio_data, dtype=np.short)
    large_sample_count = np.sum(audio_data > LEVEL)
    print np.max(audio_data)
    if large_sample_count >COUNT_NUM:
        save_count = SAVE_LENGTH
    else:
        save_count -=1
    if save_count < 0:
        save_count = 0
    if save_count > 0:
        save_buffer.append(string_audio_data)
    else:
		
        if len(save_buffer) >0:
            filename ="voice.wav"
            save_wave_file(filename, 
log = logging.getLogger( __name__ )
column_repository_name = 'column_maker_0150'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0150'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0150 Simple Prior Installation'
category_description = 'Test 0150 Simple Prior Installation'
'''
Create column_maker and convert_chars.
Column maker repository dependency:
<repository toolshed="self.url" name="convert_chars" owner="test" changeset_revision="c3041382815c" prior_installation_required="True" />
Verify display.
Galaxy side:
Install column_maker.
Verify that convert_chars was installed first, contrary to the ordering that would be present without prior_installation_required.
'''
running_standalone = False
class TestSimplePriorInstallation( ShedTwillTestCase ):
    '''Test features related to 

    
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        galaxy_admin_user_private_role = test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        

        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        
    def test_0005_create_convert_repository( self ):
        '''Create and populate convert_chars_0150.'''
        global running_standalone
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=convert_repository_name, 
                                                    description=convert_repository_description, 
                                                    long_description=convert_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_
manage_add_sqlusermanager_form = PageTemplateFile('browser/add_plugin',
                            globals(), __name__='manage_add_sqlusermanager_form' )
def manage_add_sqlusermanager_helper( dispatcher, id, title=None, REQUEST=None ):
    """Add an sqlusermanager Helper to the PluggableAuthentication Service."""
    sp = plugin.SqlusermanagerHelper( id, title )
    dispatcher._setObject( sp.getId(), sp )
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect( '%s/manage_workspace'
                                      '?manage_tabs_message='
                                      'sqlusermanagerHelper+added.'
                                      % dispatcher.absolute_url() )
def register_sqlusermanager_plugin():
    try:
        registerMultiPlugin(plugin.SqlusermanagerHelper.meta_type)
    except RuntimeError:
        pass
def register_sqlusermanager_plugin_class(context):
    context.registerClass(plugin.SqlusermanagerHelper,
                          permission = manage_
log = logging.getLogger( __name__ )
category_name = 'Test 1430 Repair installed repository'
category_description = 'Test script 1430 for repairing an installed repository.'
filter_repository_name = 'filter_1430'
column_repository_name = 'column_1430'
filter_repository_description = "Galaxy's filter tool for test 1430"
column_repository_description = 'Add a value as a new column'
filter_repository_long_description = '%s: %s' % ( filter_repository_name, filter_repository_description )
column_repository_long_description = '%s: %s' % ( column_repository_name, column_repository_description )
'''
In the Tool Shed:
1) Create and populate the filter_1430 repository
2) Create and populate the column_1430 repository
3) Upload a repository_dependencies.xml file to the column_1430 repository that creates a repository dependency on the filter_1430 repository.
In Galaxy:
1) Install the column_1430 repository, making sure to check the checkbox to Handle repository dependencies so that the filter
   r

2) Uninstall the filter_1430 repository.
3) Repair the column_1430 repository.
4) Make sure the filter_1430 repository is reinstalled and the tool is loaded into the tool panel in the same section specified in step 1.
'''
class TestRepairRepository( ShedTwillTestCase ):
    '''Test repairing an installed repository.'''
    def test_0000_initiate_users_and_category( self ):
        """Create necessary user accounts and login as an admin user."""
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
        self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_2_email, username=common.test_user_2_name )
        te

        assert test_user_2 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_2_email
        self.test_db_util.get_private_role( test_user_2 )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_email
        self.test_db_util.get_private_role( test_user_1 )
    def test_0005_create_filter_repository( self ):
        '''Create and populate the filter_1430 repository.'''
        '''
        This is step 1 - Create and populate the filter_1430 repository.
        This repository will be depended on by the column_1430 repository.
        '''
        category = self.test_db_util.get_category_by_name( category_name )
        repository = self.get_or_create_repository( name=filter_repository_name,
     
class BrokersTest(unittest.TestCase):
    def setUp(self):
        self.sommelier_broker = SommelierBroker()
        db = MagicMock()
        db.execute = MagicMock()
        db.fetch_all = MagicMock()
        db.fetch_one = MagicMock()
        self.sommelier_broker.db = db
    def test_get_authors(self):
        authors = self.sommelier_broker.get_authors()
        expected_query = self.sommelier_broker.authors_query
        self.sommelier_broker.db.execute.asset_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_all.assert_called_once()
    
    def test_get_wines(self):
        authors = self.sommelier_broker.get_wines()
        expected_query = self.sommelier_broker.wines_query
        self.sommelier_broker.db.execute.asset_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_all.assert_called_once()
    
    def test_get_wine_page(self):
        page = self.sommelier_broker.get_wine_page(1)
        expected_query = self.sommelier_broker.wine

        self.sommelier_broker.db.execute.assert_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_all.assert_called_once_with()
    
    def test_get_wine_num_pages(self):
        numpages = self.sommelier_broker.get_num_wine_pages()
        expected_query = self.sommelier_broker.wine_count_query
        self.sommelier_broker.db.execute.assert_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_one.assert_called_once_with()
    
    def test_get_wine(self):
        wine = self.sommelier_broker.get_wine(123)
        expected_query = self.sommelier_broker.wine_query.format(123)
        self.sommelier_broker.db.execute.assert_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_one.assert_called_once_with()
    
    def test_get_author_ids(self):
        ids = self.sommelier_broker.get_author_ids()
        expected_query = self.sommelier_broker.author_ids_query
        self.sommelier_broker.db.execute.assert_called_once_with(ex

        self.sommelier_broker.db.fetch_all.assert_called_once_with()
    def test_get_author_page(self):
        page = self.sommelier_broker.get_author_page(1)
        expected_query = self.sommelier_broker.author_page_query.format(50, 0)
        self.sommelier_broker.db.execute.assert_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_all.assert_called_once_with()
    
    def test_get_author_num_pages(self):
        numpages = self.sommelier_broker.get_num_author_pages()
        expected_query = self.sommelier_broker.author_count_query
        self.sommelier_broker.db.execute.assert_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_one.assert_called_once_with()
    
    def test_get_author(self):
        author = self.sommelier_broker.get_author(123)
        expected_query = self.sommelier_broker.author_query.format(123)
        self.sommelier_broker.db.execute.assert_called_once_with(expected_query)
        self.sommelier_broker.db.fetch_
"""cyme.managers
- These are the managers for our models in :mod:`cyme.models`.
- They are not to be used directly, but accessed through
  the ``objects`` attribute of a Model.
"""
class BrokerManager(ExtendedManager):
    def get_default(self):
        return self.get_or_create(url=self.default_url)[0]
    @property
    def default_url(self):
        return celery.broker_connection().as_uri()
class AppManager(ExtendedManager):
    def from_json(self, name=None, broker=None):
        return {'name': name, 'broker': self.get_broker(broker)}
    def recreate(self, name=None, broker=None, arguments=None,
            extra_config=None):
        d = self.from_json(name, broker)
        return self.get_or_create(name=d['name'],
                                  defaults={'broker': d['broker'],
                                            'arguments': arguments,
                                            'extra_config': extra_config})[0]
    def instance(self, name=None, broker=None):
       

    def get_broker(self, url):
        return self.Brokers.get_or_create(url=url)[0]
    def add(self, name=None, broker=None, arguments=None, extra_config=None):
        broker = self.get_broker(broker) if broker else None
        return self.get_or_create(name=name, defaults={
                'broker': broker,
                'arguments': arguments,
                'extra_config': extra_config})[0]
    def get_default(self):
        return self.get_or_create(name='cyme')[0]
    @cached_property
    def Brokers(self):
        return self.model.Broker._default_manager
class InstanceManager(ExtendedManager):
    def enabled(self):
        return self.filter(is_enabled=True)
    def _maybe_queues(self, queues):
        if isinstance(queues, basestring):
            queues = queues.split(',')
        return [(queue.name if isinstance(queue, self.model.Queue) else queue)
                    for queue in queues]
    def add(self, name=None, queues=None, max_concurrency=1,
            min_c

            arguments=None, extra_config=None):
        instance = self.create(name=name or uuid(),
                               max_concurrency=max_concurrency,
                               min_concurrency=min_concurrency,
                               pool=pool,
                               app=app,
                               arguments=arguments,
                               extra_config=extra_config)
        needs_save = False
        if queues:
            instance.queues = self._maybe_queues(queues)
            needs_save = True
        if broker:
            instance._broker = broker
            needs_save = True
        if needs_save:
            instance.save()
        return instance
    def _action(self, name, action, *args, **kwargs):
        instance = self.get(name=name)
        getattr(instance, action)(*args, **kwargs)
        return instance
    def remove(self, name):
        return self._action(name, 'delete')
    def enable(self, name):
        return s
host = "http://epubs.siam.org"
jl = {}
class SIAM_I_Parser(HTMLParser):
	save_data = False
	save_link = ""
	save_citation = False
	save_authors = False
	save_doi = False
	marker = ""
	articles = {}
	def handle_starttag(self, tag, attrs):
		dAttrs = dict(attrs)
		if (tag=='a'):
			if ('class' in dAttrs):
				if ((dAttrs['class']=='ref nowrap')&(not('/doi/ref/' in dAttrs['href']))):
					self.save_link = dAttrs['href']
					self.articles[self.save_link] = {'doi':"",'title':"",'authors':"","citation":""}
				elif (dAttrs['class']=='entryAuthor'):
					self.save_authors = True
				elif (dAttrs['class']=='ref doi'):				
				    self.articles[self.save_link]['doi']=dAttrs['href']
		elif (tag =='div'):
			if ('class' in dAttrs):
				if (dAttrs['class']=='art_title'):
					
					self.save_data = True
				if (dAttrs['class']=='citation tocCitation'):
					self.save_citation = True
		elif (tag == 'span'):
			if ('class' in dAttrs):
				if (dAttrs['class']=='ciationPageRange'):
					self.save_cit

	def handle_data(self, data):
		if (self.save_data):
			self.articles[self.save_link]['title'] = data
			self.save_data = False	
		elif (self.save_authors):
			if ('authors' in self.articles[self.save_link]):
				authors = self.articles[self.save_link]['authors']
			else:
				authors = ""
			self.articles[self.save_link]['authors'] = authors + "," + data
			self.save_authors = False
		elif (self.save_citation):
			if ('citation' in self.articles[self.save_link]):
				cit = self.articles[self.save_link]['citation']
			else:
				cit = ""
			self.articles[self.save_link]['citation'] = cit + " " + data.strip()
			self.save_citation = False
			
class SIAM_J_Parser(HTMLParser):
	issues = {}
	save_data = False
	marker = ""
	def handle_starttag(self, tag, attrs):
		if (tag=='a'):
			for attr in attrs:
				if attr[0]=='href':
					if attr[1][0:len(self.marker)]==self.marker:
						self.save_data = True
						self.save_link = attr[1]
	def handle_data(self, data):
		if (self.save_data):
			self.
c_p = os.path.dirname(os.getcwd())+"/"
'''------------一些必要设置的选项-----------------'''
filename  = c_p+"model/ctm/weijin/weijin.train"
indexes = [3,4]
stopword_filename = c_p+"model/ctm/weijin/stopwords.txt"
'''------------一些可选设置的选项-----------------'''
model_name="weijin.model"
delete=True
str_splitTag="^"
tc_splitTag="\t"
'''------------------------分步训练时需要的设置的选项'''
dic_path =save_main_path+"model/" +dic_name
sample_save_path = save_main_path+"temp/"+"svm.train"
svm_model_save_path = save_main_path+"model/" +model_name
svm_param='-c 45.2548339959 -g 0.125' 
test_path = sample_save_path 
for_lsa_train_save_path =  save_main_path+"temp/" +"for_lsa.train"
k = 500
lsa_train_save_path =  save_main_path+"temp/"  +"lsa_"+str(k)+".train"
lsa_save_path = save_main_path+"temp/"  + "lsa_"+str(k)
lsa_svm_param  = '-c 2.0 -g 1.0'
lsa_svm_model_save_path  = save_main_path + "LSA_title_content"+str(k)+".model"
extra_filename = save_main_path+".extra"
print "欢迎使用旺旺聊天欺诈监控系统，LSA模型训练系统"
choice = int(raw_inp
'''
Created on 17-Jul-2012
@author: vijay
'''
def create_releases_data():
    data_1 = Release(relname='4.1 U3, Kl.Nxt', active=True)
    data_1.save()
    data_2 = Release(relname='5.1, MN.Nxt', active=True)
    data_2.save()
    data_3 = Release(relname='WS8', active=True)
    data_3.save()
    data_4 = Release(relname='WS9', active=True)
    data_4.save()
    data_5 = Release(relname='KL Next U3', active=True)
    data_5  .save()
def create_phase_data():
    rel_1 = ReleasePhase(release_phase='WS9', active=True)
    rel_1.save()
    rel_2 = ReleasePhase(release_phase='GA-1(RTM)', active=True)
    rel_2.save()
    rel_3 = ReleasePhase(release_phase='Regression', active=True)
    rel_3.save()
    rel_4 = ReleasePhase(release_phase='RC3', active=True)
    rel_4.save()
    rel_5 = ReleasePhase(release_phase='RTM1', active=True)
    rel_5.save()
    rel_6 = ReleasePhase(release_phase='RTM2', active=True)
    rel_6.save()
    rel_7 = ReleasePhase(release_phase='RTM3', active=True)
    rel
manage = ContentManage()
def IP(r): return r.META["REMOTE_ADDR"]
def tag_list(r, cate='', lang='', offset=0, limit=100, mode='list', track=''):
    cate = manage.load_category(cate, lang)
    count, tags = manage.tag_list(cate, offset, limit, mode, track, IP(r))
    r = []
    for t in tags:
        r.append({})
        r[-1]['name'] = t.name
        r[-1]['shape'] = t.shape
        r[-1]['count'] = t.count
    return (count, r)
def cate_list(r, lang='', track=''):
    count, cates = manage.cate_list(lang, track, IP(r))
    r = []
    for t in cates:
        r.append({})
        r[-1]['id'] = t.id
        r[-1]['code'] = t.code
        r[-1]['name'] = t.name 
    return (count, r)
def tag(r, cate='', lang='', tag='', offset=0, limit=50, mode='list', track=''):
    cate = manage.load_category(cate, lang)
    count, messages = manage.tag(cate, tag, offset, limit, mode, track, IP(r))
    
    if mode == 'randmom': messages = manage.random(messages, 1)
    r = []
    for t in messages:
   

        r[-1]['id'] = t.id
        r[-1]['create_date'] = t.create_date
        r[-1]['text'] = t.text
        r[-1]['tags'] = t.tags
        
    return (count, r)    
    
def cate(r, cate='', lang='', offset=0, limit=50, mode='list', track=''):
    """
    mode: list, random, hot, new
    """
    cate = manage.load_category(cate, lang)
    count, messages = manage.cate(cate, tag, offset, limit, mode, track, IP(r))
    
    if mode == 'randmom': messages = manage.random(messages, 1)
    r = []
    for t in messages:
        r.append({})
        r[-1]['id'] = t.id
        r[-1]['create_date'] = t.create_date
        r[-1]['text'] = t.text
        r[-1]['tags'] = t.tags
        
    return (count, r)
def vote(r, cate='', lang='', msg_id='', v='', msg='', user='', session='', track=''):
    cate = manage.load_category(cate, lang)
    user = manage.load_user(user, session)
    error, message = manage.vote(cate, msg_id, v, msg, user, track, IP(r))
    error = error is None and "OK" or er
django.setup()
def run():
    s1 = SystemRole(role_name = 'TableScreen')
    s2 = SystemRole(role_name = 'ReceptionScreen')
    s3 = SystemRole(role_name = 'ServeScreen')
    s4 = SystemRole(role_name = 'ChefScreen')
    s5 = SystemRole(role_name = 'StockScreen')
    s6 = SystemRole(role_name = 'ManagerDashboard')
    s1.save()
    s2.save()
    s3.save()
    s4.save()
    s5.save()
    s6.save()
    all_sysrole = SystemRole.objects.all()
    u1 = User(username ='janin',password='jap',role_id=s1)
    u2 = User(username ='fony',password='fony',role_id=s2)
    u3 = User(username ='aiiaor',password='aiiaor',role_id=s3)
    u4 = User(username ='ong',password='ong',role_id=s4)
    u5 = User(username ='eakamon',password='eakamon',role_id=s5)
    u6 = User(username ='iboss',password='iboss',role_id=s6)
    u1.save()
    u2.save()
    u3.save()
    u4.save()
    u5.save()
    u6.save()
    all_user = User.objects.all()
    d1 = DTable(description='aiiaor',user_id=u1)
    d2 = DTable(descriptio

    d3 = DTable(description='ong',user_id=u3)
    d4 = DTable(description='janin',user_id=u4)
    d5 = DTable(description='fony',user_id=u5)
    d6 = DTable(description='pete',user_id=u6)
    d1.save()
    d2.save()
    d3.save()
    d3.save()
    d4.save()
    d5.save()
    d6.save()
    cg1= CustomerGroup(number_of_customer=3)
    cg2= CustomerGroup(number_of_customer=2)
    cg3= CustomerGroup(number_of_customer=5)
    cg4= CustomerGroup(number_of_customer=1)
    cg5= CustomerGroup(number_of_customer=4)
    cg6= CustomerGroup(number_of_customer=2)
    cg1.save()
    cg2.save()
    cg3.save()
    cg4.save()
    cg5.save()
    cg6.save()
    r1 = Reservation(firstname='janin',lastname='jap',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg1)
    r2 = Reservation(firstname='aiiaor',lastname='boon',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg2)
    r3 = Reservation(firstname='iboss',lastname='ibosza',home_tel_no='012345678',mobile_no='0123456789',customer_id

    r4 = Reservation(firstname='fony',lastname='laew',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg4)
    r5 = Reservation(firstname='ong',lastname='patinya',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg5)
    r6 = Reservation(firstname='aekamon',lastname='pete',home_tel_no='012345678',mobile_no='0123456789',customer_id=cg6)
    r1.save()
    r2.save()
    r3.save()
    r4.save()
    r5.save()
    r6.save()
    m1 = Menu(name='janin',description='jap',pic_path='emp_pic/1.jpg')
    m2 = Menu(name='boonjira',description='aor',pic_path='emp_pic/1.jpg')
    m3 = Menu(name='ssobi',description='iboss',pic_path='emp_pic/1.jpg')
    m4 = Menu(name='selseo',description='oesles',pic_path='emp_pic/1.jpg')
    m5 = Menu(name='jirat',description='earth',pic_path='emp_pic/1.jpg')
    m6 = Menu(name='pannat',description='tannap',pic_path='emp_pic/1.jpg')
    m1.save()
    m2.save()
    m3.save()
    m4.save()
    m5.save()
    m6.save()
    ol1 = Orderlist(dtable_id=d
DeleteAllPlots()
ResetView()
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 1
SaveWindowAtts.outputDirectory = "."
SaveWindowAtts.fileName = 'particle-v-'
SaveWindowAtts.family = 1
SaveWindowAtts.width = 1285
SaveWindowAtts.height = 785
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 80
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
View3DAtts = View3DAttributes()
View3DAtts.viewNormal = (-0.616596, 0.605379, 0.503315)
View3DAtts.focus = (-7.1792e-09, -2.18366e-07, 0.000262933)
View3DAtts.viewUp = (0.348624, 0.783166, -0.51489)
View3DAtts.viewAngle = 30
View3DAtts.parallelScale = 0.000175567
View3DAtts.nearPlane = -0.000351133
View3DAtts.farPlane = 0.000351133
View3DAtts.imagePan = (0, 0)
View3DAtts.imageZoom = 1.00215
View3DAtts.perspective = 1
View3DAtts.eyeAngle =
log = logging.getLogger("flooding.management.start_scenario")
class Command(BaseCommand):
    help = ("Example: bin/django start_scenario_new "\
            "--scenario_id 50 "\
            "--workflowtemplate_id 1 "\
            "--log_level DEBUG")
    option_list = BaseCommand.option_list + (
            make_option('--log_level',
                        help='logging level 10=debug 50=critical',
                        default='DEBUG',
                        type='str'),
            make_option('--scenario_id',
                        help='scenarios',
                        type='int'),
            make_option('--workflowtemplate_id',
                        help='id of workflow template',
                        type='int'))
    def handle(self, *args, **options):
        """
        Opens connection to broker.
        Creates ActionWorkflow object.
        Creates logging handler to send loggings to broker.
        Sets logging handler to ActionWorkflow object.
        Perform
__author__ = 'Wang Chao'
__date__ = '4/3/14'
HUB_URL = "https://{0}:{1}".format(settings.HUB_HOST, settings.HUB_HTTPS_PORT)
HTTPSAPIClient.install_pem('/opt/ca/client.pem')
apicall = HTTPSAPIClient()
api_server_list = partial(apicall, cmd=HUB_URL + '/api/server-list/')
api_server_register = partial(apicall, cmd=HUB_URL + '/api/server-list/register/')
api_account_login = partial(apicall, cmd=HUB_URL + '/api/account/login/')
api_account_bind = partial(apicall, cmd=HUB_URL + '/api/account/bind/')
api_character_create = partial(apicall, cmd=HUB_URL + '/api/character/create/')
api_character_failure = partial(apicall, cmd=HUB_URL + '/api/character/failure/')
api_store_get = partial(apicall, cmd=HUB_URL + '/api/store/get/')
api_store_buy = partial(apicall, cmd=HUB_URL + '/api/store/buy/')
api_activatecode_use = partial(apicall, cmd=HUB_URL + '/api/activatecode/use/')
api_get_checkin_data = partial(apicall, cmd=HUB_URL + '/api/checkin/get/')
api_purchase_verify = partial(apicall, cmd=HUB_URL +
datatypes_repository_name = 'emboss_datatypes_0110'
datatypes_repository_description = "Galaxy applicable data formats used by Emboss tools."
datatypes_repository_long_description = "Galaxy applicable data formats used by Emboss tools.  This repository contains no tools."
emboss_repository_name = 'emboss_0110'
emboss_repository_description = 'Galaxy wrappers for Emboss version 5.0.0 tools'
emboss_repository_long_description = 'Galaxy wrappers for Emboss version 5.0.0 tools'
category_name = 'Test 0110 Invalid Repository Dependencies'
category_desc = 'Test 0110 Invalid Repository Dependencies'
class TestBasicRepositoryDependencies( ShedTwillTestCase ):
    '''Testing emboss 5 with repository dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts and login as an admin user."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.tes

        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % common.test_user_1_email
        self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        self.test_db_util.get_private_role( admin_user )
    def test_0005_create_category( self ):
        """Create a category for this test suite"""
        self.create_category( name=category_name, description=category_desc )
    def test_0010_create_emboss_datatypes_repository_and_upload_tarball( self ):
        '''Create and populate the emboss_datatypes repository.'''
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        category = self.test_db_util.get

        repository = self.get_or_create_repository( name=datatypes_repository_name,
                                             description=datatypes_repository_description,
                                             long_description=datatypes_repository_long_description,
                                             owner=common.test_user_1_name,
                                             category_id=self.security.encode_id( category.id ),
                                             strings_displayed=[] )
        self.upload_file( repository,
                          filename='emboss/datatypes/datatypes_conf.xml',
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=True,
                          remove_repo_files_not_in_tar=False,
                          commit_message='Uploaded datatypes_conf.xml.',
                          strings_displayed=[],
                          strings_not_displayed=[
class Gnome2048Application(Gtk.Application):
    def __init__(self):
        Gtk.Application.__init__(self)
        engine = GameEngine()
        
        config_file = path.join(Directories.USER_CONFIG_DIR, "settings.json")
        self.config_manager = UserConfigManager(config_file)
        self.user_config = UserConfig()
        self.css_provider = Gtk.CssProvider()
        self.main_window_controller = MainWindowController(engine, self.css_provider)
        self.theme_selection_controller = ThemeSelectionController()
        self.theme_selection_controller.window.set_transient_for(self.main_window_controller.window)
        self.theme_selection_controller.register_theme_changed(self)
        self.gmenu_controller = GmenuController(self)
        self.about_controller = AboutController()
        about_win = self.about_controller.window
        main_win = self.main_window_controller.window
        about_win.set_transient_for(main_win)
        self.load_config()
        
    def load_c
"""
Django settings for django_celery_demo project.
For more information on this file, see
https://docs.djangoproject.com/en/1.6/topics/settings/
For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.6/ref/settings/
"""
BASE_DIR = os.path.dirname(os.path.dirname(__file__))
with open(os.path.join(BASE_DIR, 'envs/dev.json')) as env_file:
    ENV_TOKENS = json.load(env_file)
with open(os.path.join(BASE_DIR, 'envs/auth.json')) as env_file:
    AUTH_TOKENS = json.load(env_file)
CACHES = ENV_TOKENS['CACHES']
DEBUG = True
TEMPLATE_DEBUG = True
ALLOWED_HOSTS = []
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'djcelery',
    'tester_app',
MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfV

    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
ROOT_URLCONF = 'django_celery_demo.urls'
WSGI_APPLICATION = 'django_celery_demo.wsgi.application'
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True
STATIC_URL = '/static/'
djcelery.setup_loader()
CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler'
BROKER_POOL_LIMIT = 0
BROKER_CONNECTION_TIMEOUT = 1
CELERY_RESULT_BACKEND = 'cache'
CELERY_CACHE_BACKEND = 'celery'
BROKER_HEARTBEAT = 10.0
BROKER_HEARTBEAT_CHECKRATE = 2
CELERYD_PREFETCH_MULTIPLIER = 1
CELERY_BROKER_TRANSPORT = ENV_TOKENS.get("CELERY_BROKER_TRANSPORT", "")
CELERY_BROKER_HOSTNAME = ENV_TOKENS.get("CELERY_BROKER_HOSTNAME", "")
CELERY_BROKER_VHOST = ENV_TOKENS.
class Messaging(object):
    def __init__(self, controller):
        self.controller = controller
        self.transform = False
        if not hasattr(self.controller.meta, 'Message'):
            if not hasattr(self.controller.meta, 'Model'):
                raise ValueError('Controller.Meta must have a Message or Model class.')
            setattr(self.controller.meta, 'Message', model_message(self.controller.meta.Model))
        if not hasattr(self.controller.meta, 'messaging_prefixes'):
            setattr(self.controller.meta, 'messaging_prefixes', ('api',))
        if not hasattr(self.controller.meta, 'messaging_variable_names'):
            setattr(self.controller.meta, 'messaging_variable_names', ('data',))
        if hasattr(self.controller, 'scaffold'):
            self.controller.meta.messaging_variable_names += (self.controller.scaffold.singular, self.controller.scaffold.plural)
        self.controller.events.before_startup += self._on_before_startup
        self.controlle

    def _on_before_startup(self, controller, *args, **kwargs):
        if controller.route.prefix in self.controller.meta.messaging_prefixes:
            self.activate()
    def activate(self):
        self.transform = True
        self.controller.meta.Parser = 'Message'
        self.controller.meta.change_view('Message')
        if hasattr(self.controller, 'scaffold'):
            self.controller.scaffold.flash_messages = False
            self.controller.scaffold.redirect = False
    __call__ = activate
    def _get_data(self):
        for v in self.controller.meta.messaging_variable_names:
            data = self.controller.context.get(v, None)
            if data:
                return data
    def _transform_data(self, data):
        if isinstance(data, Message):
            return data
        if isinstance(data, (list, ndb.Query)):
            return self._transform_query(data)
        if isinstance(data, ndb.Model):
            return self._transform_entity(data)
        retu
class TestDatabaseRepository(unittest.TestCase):
    def setUp(self):
        self.dbstring = 'sqlite:///test.db'
        
    def tearDown(self):
        if os.path.exists('test.db'):
            os.remove('test.db')
            
    def setup_table(self, dbstring, table_name):
        engine = create_engine(dbstring)
        metadata = MetaData()
        metadata.bind = engine
        table = Table(table_name, metadata)
        return table
            
    def assertTableExists(self, dbstring, table_name):
        table = self.setup_table(dbstring, table_name)
        self.assertTrue(table.exists())
        
    def assertTableDoesNotExist(self, dbstring, table_name):
        table = self.setup_table(dbstring, table_name)
        self.assertFalse(table.exists())
        
    def test_initialize_database(self):
        """The table _evolve should be created"""
        dbstring = self.dbstring
        repository = DatabaseRepository(dbstring)
        repository.initialize()
        se
REPOSITORY_GROUP="""
    <repositoryGroups>
        <repositoryGroup>
            <id>$ID</id>
            <mergedIndexPath>.indexer</mergedIndexPath>
            <repositories>
                <repository>internal</repository>
                <repository>snapshots</repository>
            </repositories>
        </repositoryGroup>
    </repositoryGroups>
"""
REMOTE_REPOSITORIES="""
        <remoteRepository>
            <url>$URL</url>
            <downloadRemoteIndex>false</downloadRemoteIndex>
            <downloadRemoteIndexOnStartup>false</downloadRemoteIndexOnStartup>
            <id>$REPO_ID</id>
            <name>$REPO_NAME</name>
        </remoteRepository>
"""
PROXY_CONNECTORS="""
        <proxyConnector>
            <order>$ORDER</order>
            <sourceRepoId>internal</sourceRepoId>
            <targetRepoId>$TARGET_REPO_ID</targetRepoId>
            <policies>
                <releases>hourly</releases>
                <propagate-errors>queue error</propagate-errors>
  
NEW_PROJECT_FORMS = [('project', forms.NewProjectForm),
                     ('repository', forms.NewRepositoryForm),
                     ('server', forms.NewServerForm)]
NEW_PROJECT_TEMPLATE = {
    'project': 'project/create/project.html',
    'repository': 'project/create/repository.html',
    'server': 'project/create/server.html',
class NewProjectWizard(SessionWizardView):
    def get_template_names(self):
        return [NEW_PROJECT_TEMPLATE[self.steps.current]]
    def done(self, form_list, **kwargs):
        project_form, repository_form, server_form = form_list
        project = project_form.save(commit=False)
        repository = repository_form.save(commit=False)
        repository.name = '%s Repository' % project.name
        repository.save()
        server = server_form.save(commit=False)
        server.name = '%s Server Test' % project.name
        server.superuser_login = 'root'
        server.save()
        project.server = server
        project.repository = reposito
def index():
    if not plugins.manage_groups.admin_group:
        return T('use syntax: plugin_manage_groups/group/<groupname> --or-- set plugins.manage_groups.admin_group in model db.py (or other one - see model/plugin_manage_groups)')
    redirect(URL('group', args=plugins.manage_groups.admin_group))
@auth.requires_membership(plugins.manage_groups.admin_group)
def group():
        hint = None
        groups = db(plugins.manage_groups.table_group.role==request.args[0]).select()
        if groups:
            group_id = groups.first().id
        elif plugins.manage_groups.create:
            group_id = plugins.manage_groups.table_group.insert(role=request.args[0])
            db.commit()
        else:
            return T('creating of new groups is not enabled - to change this setting see model/plugin_manage_groups')
        groups = db(plugins.manage_groups.table_group).select(orderby=plugins.manage_groups.table_group.role.lower())
        member_counts = {}
        count = plugins.m

        member_counts_db = db(plugins.manage_groups.table_membership).select(
                plugins.manage_groups.table_membership.group_id, count,
                orderby=plugins.manage_groups.table_membership.group_id,
                groupby=plugins.manage_groups.table_membership.group_id
                )
        for membership in member_counts_db:
            member_counts[membership.auth_membership.group_id] = membership[count]
        order_users = plugins.manage_groups.table_user.username.lower() if auth.settings.use_username else plugins.manage_groups.table_user.email.lower()
        users = db(plugins.manage_groups.table_user).select(orderby=order_users, limitby=(0, plugins.manage_groups.limit_hide_users))
        member_fields = [plugins.manage_groups.table_user.username, plugins.manage_groups.table_user.email] if auth.settings.use_username else [plugins.manage_groups.table_user.email]
        members = db((plugins.manage_groups.table_membership.group_id==group_id) & (plu

                plugins.manage_groups.table_user.id, *member_fields, orderby=order_users)
        if len(users)>=plugins.manage_groups.limit_hide_users:
            large = SQLFORM.factory(
                    Field('candidate', label=(T("User") if auth.settings.use_username else T("E-mail")),
                            comment=(T("enter username or email (exact or starting characters)") if auth.settings.use_username
                                else T("enter email or its starting characters"))),
                    submit_button=T("Find and add the user"))
            if large.process(keepvalues=True).accepted:
                if large.vars.candidate:
                    pattern = large.vars.candidate.lower()
                    new_member = db(plugins.manage_groups.table_user.email.lower()==pattern).select().first() if ('@' in pattern) else None
                    if not new_member:
                        if auth.settings.use_username:
                            new_member = 
matplotlib_repository_name = 'package_matplotlib_1_2_0170'
matplotlib_repository_description = "Contains a tool dependency definition that downloads and compiles version 1.2.x of the the python matplotlib package."
matplotlib_repository_long_description = "This repository is intended to be defined as a complex repository dependency within a separate repository."
numpy_repository_name = 'package_numpy_1_7_0170'
numpy_repository_description = "Contains a tool dependency definition that downloads and compiles version 1.7 of the the python numpy package."
numpy_repository_long_description = "This repository is intended to be defined as a complex repository dependency within a separate repository."
category_name = 'Test 0170 Prior Installation Complex Dependencies'
category_description = 'Test 0170 Prior Installation Complex Dependencies'
'''
1. Create and populate repositories package_matplotlib_1_2_0170 and package_numpy_1_7_0170.
2. Create a complex repository dependency on package_numpy

3. Verify that package_matplotlib_1_2_0170 now depends on package_numpy_1_7_0170, and that the inherited tool dependency displays correctly.
'''
class TestComplexPriorInstallation( ShedTwillTestCase ):
    '''Test features related to datatype converters.'''
    
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the d

        admin_user_private_role = self.test_db_util.get_private_role( admin_user )
        
    def test_0005_create_matplotlib_repository( self ):
        '''Create and populate the package_matplotlib_1_2_0170 repository.'''
        '''
        This is step 1 - Create and populate repositories package_matplotlib_1_2_0170 and package_numpy_1_7_0170.
        '''
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=matplotlib_repository_name, 
                                                    description=matplotlib_repository_description, 
                                                    long_description=matplotlib_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                   
column_repository_name = 'column_maker_1087'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_1087'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 1087 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryDependencies( ShedTwillTestCase ):
    '''Test installing a repository, then updating it to include repository dependencies.'''
    def test_0000_create_or_login_admin_user( self ):
        """Create necessary user accounts and login as an admin user."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = self.test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with e

        galaxy_admin_user_private_role = self.test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = self.test_db_util.get_private_role( admin_user )
  
    def test_0005_create_and_populate_column_repository( self ):
        """Create a category for this test suite and add repositories to 

        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name, 
                                                    description=column_repository_description, 
                                                    long_description=column_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        if self.repository_is_new( repository ):
            self.upload_file( repository, 
                              filename='column_maker/column_maker.tar',
                              filepath=None,
                              valid_to
def initialize(context):
    context.registerClass(
        OFS.DTMLMethod.DTMLMethod,
        permission=add_documents_images_and_files,
        constructors=(OFS.DTMLMethod.addForm, OFS.DTMLMethod.addDTMLMethod,),
        legacy=(
            ('manage_addDocument', OFS.DTMLMethod.addDTMLMethod),
            ('manage_addDTMLMethod', OFS.DTMLMethod.addDTMLMethod),
        )
    )
    context.registerClass(
        OFS.DTMLDocument.DTMLDocument,
        permission=add_documents_images_and_files,
        constructors=(OFS.DTMLDocument.addForm,
                      OFS.DTMLDocument.addDTMLDocument),
        legacy=(('manage_addDTMLDocument', OFS.DTMLDocument.addDTMLDocument),),
    )
    context.registerClass(
        OFS.Image.Image,
        permission=add_documents_images_and_files,
        constructors=(('imageAdd', OFS.Image.manage_addImageForm),
                      OFS.Image.manage_addImage),
        legacy=(OFS.Image.manage_addImage,),
    )
    context.registerClass(
        OFS
good = maybeerror.MaybeError.pure
bad = maybeerror.MaybeError.error
class TestParser(u.TestCase):
    
    def testParseGood(self):
                         good(Data('hi', {'me': Save({}, [])})))
    
    def testParseGoodComplex(self):
        inp = """
        data_start
         save_st1
          _a 1
          _b 2
         save_
         save_st2
          _c 3
          loop_
           _d _e
           w x y z m n
          stop_
         save_
        """
        ast = Data('start',
                   {'st1': Save({'a': '1', 'b': '2'}, []),
                    'st2': Save({'c': '3'}, [Loop(['d', 'e'], [['w', 'x'], ['y', 'z'], ['m', 'n']])])})
        self.assertEqual(parse_star_ast(inp), good(ast))
class TestParserErrors(u.TestCase):
    def test_cst_problem(self):
                         bad({'phase': 'CST construction', 
                              'message': [('data', (1,1)), ('save', (1,9)), ('save close', 'EOF')]}))
    
    def test_star_ast_problem(self):
        se

                         bad({'phase': 'AST construction',
                              'message': {'message': 'duplicate key', 'nodetype': 'save',
                                          'key': 'a', 'first': (1,17), 'second': (1,22)}}))
    def test_nmrstar_ast_problem(self):
        self.assertEqual(parse_nmrstar_ast("data_hi save_me _A.a 1 _A.Sf_category 2 save_"),
                         bad({'phase': 'NMRSTAR AST construction', 
                              'message': {'message': 'missing key "Sf_framecode"', 'nodetype': 'save'}}))
    def test_unconsumed_input(self):
        self.assertEqual(parse_nmrstar_ast("data_hi _what?"), 
                         bad({'phase': 'CST construction',
                              'message': [('unparsed tokens remaining', (1,9))]}))
    def test_junk(self):
        self.assertEqual(parse_nmrstar_ast("what is this junk?  this isn't nmr-star"), 
                         bad({'phase': 'CST construction',
                              'messag
try:
except ImportError:
try:
except ImportError:
    psutil = None
class localBroker(object):
    def __init__(self, debug, nice=0, backend='ZMQ'):
        """Starts a broker on random unoccupied ports"""
        self.backend = backend
        if backend == 'ZMQ':
        else:
        if nice:
            if not psutil:
                scoop.logger.error("'nice' used while psutil not installed.")
                raise ImportError("psutil is needed for nice functionnality.")
            p = psutil.Process(os.getpid())
            p.set_nice(nice)
        self.localBroker = Broker(debug=debug)
        self.brokerPort, self.infoPort = self.localBroker.getPorts()
        self.broker = Thread(target=self.localBroker.run)
        self.broker.daemon = True
        self.broker.start()
        scoop.logger.debug("Local broker launched on ports {0}, {1}"
                      ".".format(self.brokerPort, self.infoPort))
    def sendConnect(self, data):
        """Send a CONNECT command to the b

            :param data: List of other broker main socket URL"""
        if self.backend == 'ZMQ':
            self.context = zmq.Context()
            self.socket = self.context.socket(zmq.DEALER)
            self.socket.setsockopt(zmq.IDENTITY, b'launcher')
            self.socket.connect(
                "tcp://127.0.0.1:{port}".format(
                    port=self.brokerPort,
                )
            )
            self.socket.send_multipart([b"CONNECT",
                                        pickle.dumps(data,
                                                     pickle.HIGHEST_PROTOCOL)])
        else:
            pass
    def getHost(self):
        return "127.0.0.1"
    def getPorts(self):
        return (self.brokerPort, self.infoPort)
    def close(self):
        scoop.logger.debug('Closing local broker.')
class remoteBroker(object):
    def __init__(self, hostname, pythonExecutable, debug=False, nice=0,
                 backend='ZMQ', rsh=False, ssh_executable='ssh'):


        self.backend = backend
        brokerString = ("{pythonExec} -m scoop.broker.__main__ "
                        "--echoGroup "
                        "--echoPorts "
                        "--backend {backend} ".format(
                            pythonExec=pythonExecutable,
                            backend=backend,
                            )
                        )
        if nice:
            brokerString += "--nice {nice} ".format(nice=nice)
        if debug:
            brokerString += "--debug --path {path} ".format(
                path=os.getcwd()
            )
        self.hostname = hostname
        BASE_SSH[0] = ssh_executable
        cmd = BASE_RSH if rsh else BASE_SSH + [
            hostname,
            brokerString.format(pythonExec=pythonExecutable)
        ]
        scoop.logger.debug("Launching remote broker: {cmd}"
                           "".format(cmd=" ".join(cmd)))
        self.shell = subprocess.Popen(
            cmd,
            bufsize=0,
os.rename("./repository/metadata", "./repository/metadata.staged")
repository = load_repository("./repository")
repository.release.add_key(pubRootKey)
repository.timestamp.add_key(pubRootKey)
repository.release.load_signing_key(priRootKey)
repository.timestamp.load_signing_key(priRootKey)
repository.timestamp.expiration = "2014-10-29 12:08:00"
shutil.copyfile("./repository/metadata.staged/targets.txt", "./repository/metadata.staged/tmp")
f = open("./repository/metadata.staged/targets.txt", "w+b")
tmp = open("./repository/metadata.staged/tmp", "r+b")
for l in f:
	try:
		k = l.index("c5d031")
		e = l.index("d7\"")
		m = hashlib.sha256()
		gem = open("./repository/targets/gems/arbitrary-0.0.6.gem", "r")
		m.update(gem.read())
		ha = m.hexdigest()
		f.write(l[0,k])
		f.write(ha)
		f.write("\"\n")
		continue
	except(ValueError):
		pass
	f.write(l)
repository.write( True )
os.rename("./repository/metadata.staged", "./repository/metadata")
os.chdir("./repository")
Handler = SimpleHTTPServer.S
api_auth = patterns('',
    url(r'/login$', api.AuthLogin.as_view(), name = 'api-login'),
    url(r'/logout$', api.AuthLogout.as_view(), name = 'api-logout'),
api_self = patterns('',
    url(r'/friends$', api.FriendSearchList.as_view(), name = 'api-friendsearchlist'),
    url(r'/requests$', api.RequestSearchList.as_view(), name = 'api-requestsearchlist'),
api_users = patterns('',
    url(r'/search$', api.UserSearchList.as_view(), name = 'api-usersearchlist'),
    url(r'/self', include(api_self))
api_register = patterns('',
    url(r'/availability$', api.Availability.as_view(), name = 'api-availability'),
    url(r'$', api.Register.as_view(), name = 'api-register'),
api_firebase = patterns('',
    url(r'/url$', api.FireBaseUrl.as_view(), name = 'api-firebaseurl'),
    url(r'/auth$', api.FireBaseAuth.as_view(), name = 'api-firebaseauth'),
api_ping = patterns('',
    url(r'/firebase', include(api_firebase)),
    url(r'/outbox$', api.PingOutbox.as_view(), name = 'api-pingoutbox'),
api_urls
True, False = 1, 0
def manage_addBoaDebugger(self, REQUEST=None):
    """
    Factory Method
    """
    self._setObject('BoaDebugger', BoaDebugger())
    if REQUEST:
        REQUEST.RESPONSE.redirect('%s/manage_main' % REQUEST['URL3'])
class BoaDebugger (PropertyManager, SimpleItem):
    """
    A BoaDebugger plug-in for your Zope
    """
    meta_type = 'BoaDebugger'
    id = 'Boa Debugger'
    title = 'Boa Constructor Zope debug module'
    icon = 'www/boa.gif'
        
    __ac_permissions__ = PropertyManager.__ac_permissions__ + (
        (view_management_screens, ('manage_start', 'manage_stop', 'manage_callBreakpoint')),
        ) + SimpleItem.__ac_permissions__
    property_extensible_schema__ = 0
    _properties = PropertyManager._properties + (
        {'id':'port',     'type':'int',    'mode':'w'},
        {'id':'username', 'type':'string', 'mode':'w'},
        {'id':'password', 'type':'string', 'mode':'w'},
        )
    
    manage_options = (
        { 'label': 'Properties

          'help': ('BoaDebugger', 'debugger.stx') },
        { 'label': 'Start', 'action':'manage_start' },
        { 'label': 'Stop', 'action':'manage_stop' },
        { 'label': 'Breakpoint Mode', 'action':'manage_callBreakpoint' },
        ) + SimpleItem.manage_options
    manage_main = PropertyManager.manage_propertiesForm
    
    def __init__(self):
        self.username = ''
        self.password = ''
        self.host='localhost'
        self.port = 26200
    def manage_start(self,REQUEST=None):
        """ """
        if getattr(self, '_v_active', False):
            REQUEST.set('manage_tabs_message', 'The debug server is already active')
            return self.manage_main(self, REQUEST)            
        try :
            self._v_active = True
            start(self.username, self.password, self.host, self.port)
        except Exception, e:
            if REQUEST:
                typ, val, tb = sys.exc_info()
                s = "The debug server could not be started.<br>

                REQUEST.set('manage_tabs_message', s)
                return self.manage_main(self, REQUEST)
            else:
                raise
        if REQUEST:
            REQUEST.set('manage_tabs_message', 'The debug server is active now')
            return self.manage_main(self, REQUEST)
        
    def manage_stop(self, REQUEST=None):
        """ """
        if not getattr(self, '_v_active', False):
            if REQUEST:
                REQUEST.set('manage_tabs_message', 'The debug server is already stopped')
                return self.manage_main(self, REQUEST)
            else:
                return
        try :
            self._v_active = False
            stop()
        except Exception, e:
            if REQUEST:
                typ, val, tb = sys.exc_info()
                s = "The debug server could not be stopped.<br>%s<br>\n" % traceback.format_exception(typ, val, tb) + "<br>\n"
                REQUEST.set('manage_tabs_message', s)
                return s
log = logging.getLogger( __name__ )
UNRESTRICTED = 'unrestricted'
TOOL_DEPENDENCY_DEFINITION = 'tool_dependency_definition'
types = [ UNRESTRICTED, TOOL_DEPENDENCY_DEFINITION ]
def build_repository_type_select_field( trans, repository=None, name='repository_type' ):
    """Called from the Tool Shed to generate the current list of supported repository types."""
    if repository:
        selected_type = str( repository.type )
    else:
        selected_type = None
    repository_type_select_field = SelectField( name=name )
    for type_label, type_class in trans.app.repository_types_registry.repository_types_by_label.items():
        option_label = str( type_class.label )
        option_value = str( type_class.type )
        if selected_type and selected_type == option_value:
            selected = True
        else:
            selected = False
        if repository:
            if repository.type == option_value:
                repository_type_select_field.add_option( option_label, o
manage_addLinksListForm = PageTemplateFile('zpt/linkslist_add', globals())
def manage_addLinksList(self, id='', title='', portlet='', REQUEST=None):
    """ """
    id = self.utSlugify(id)
    if not id: id = PREFIX_SUFIX_LINKSLIST % self.utGenRandomId(6)
    ob = LinksList(id, title)
    self._setObject(id, ob)
    if portlet:
        self.create_portlet_for_linkslist(self._getOb(id))
    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
class LinksList(SimpleItem, links_manager):
    """ """
    implements(ILinksList)
    meta_type = METATYPE_LINKSLIST
    icon = 'misc_/NaayaCore/LinksList.gif'
    manage_options = (
        (
            {'label': 'Links', 'action': 'manage_links_html'},
        )
        +
        SimpleItem.manage_options
    )
    security = ClassSecurityInfo()
    def __init__(self, id, title):
        """ """
        self.id = id
        self.title = title
        links_manager.__dict__['__init__'](self)
    security.declareP

    def manageProperties(self, title='', REQUEST=None):
        """ """
        self.title = title
        self._p_changed = 1
        if REQUEST:
            REQUEST.RESPONSE.redirect('manage_properties_html')
    security.declareProtected(view_management_screens, 'manage_add_link_item')
    def manage_add_link_item(self, id='', title='', description='', url='', relative='', permission='', order='', REQUEST=None):
        """ """
        if relative: relative = 1
        else: relative = 0
        try: order = abs(int(order))
        except: order = 0
        self.add_link_item(self.utGenRandomId(), title, description, url, relative, permission, order)
        if REQUEST: REQUEST.RESPONSE.redirect('manage_links_html?save=ok')
    security.declareProtected(view_management_screens, 'manage_update_link_item')
    def manage_update_link_item(self, id='', title='', description='', url='', relative='', permission='', order='', REQUEST=None):
        """ """
        if relative: relative = 
urlpatterns = patterns('kpi.views',
    url(r'^sector/(?P<sector_ref_no>\d+)/kpi/$', 'view_sector_kpi', name='view_sector_kpi'),
    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/kpi/$', 'view_master_plan_kpi', name='view_master_plan_kpi'),
    
    url(r'^program/(?P<program_id>\d+)/kpi/$', 'view_program_kpi', {'kpi_year':0}, name='view_program_kpi'),
    url(r'^program/(?P<program_id>\d+)/kpi/(?P<kpi_year>\d+)/$', 'view_program_kpi', name='view_program_kpi_year'),
    
    url(r'^program/(?P<program_id>\d+)/kpi/manage/$', 'view_program_manage_kpi_and_schedule', name='view_program_manage_kpi_and_schedule'),
    url(r'^program/(?P<program_id>\d+)/kpi/manage/kpi/$', 'view_program_manage_kpi', name='view_program_manage_kpi'),
    url(r'^program/(?P<program_id>\d+)/kpi/manage/kpi/add/$', 'view_program_manage_kpi_add_kpi', name='view_program_manage_kpi_add_kpi'),
    url(r'^program/kpi/manage/kpi/(?P<kpi_id>\d+)/edit/$', 'view_program_manage_kpi_edit_kpi', name='view_program_manage_kpi_ed

    url(r'^program/kpi/manage/kpi/(?P<kpi_id>\d+)/delete/$', 'view_program_manage_kpi_delete_kpi', name='view_program_manage_kpi_delete_kpi'),
    
    url(r'^program/(?P<program_id>\d+)/kpi/manage/schedule/$', 'view_program_manage_kpi_schedule', {'kpi_year':0}, name='view_program_manage_kpi_schedule'),
    url(r'^program/(?P<program_id>\d+)/kpi/manage/schedule/(?P<kpi_year>\d+)/$', 'view_program_manage_kpi_schedule', name='view_program_manage_kpi_schedule_year'),
    
    url(r'^master_plan/manage/program/(?P<program_id>\d+)/kpi/$', 'view_master_plan_manage_program_kpi', {'kpi_year':0}, name='view_master_plan_manage_program_kpi'),
    url(r'^master_plan/manage/program/(?P<program_id>\d+)/kpi/(?P<kpi_year>\d+)/$', 'view_master_plan_manage_program_kpi', name='view_master_plan_manage_program_kpi_year'),
    
    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/manage/kpi/$', 'view_master_plan_manage_kpi', {'kpi_year':''}, name='view_master_plan_manage_kpi'),
    url(r'^master_plan/(?P<mas

    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/manage/kpi/add/$', 'view_master_plan_manage_kpi_add_kpi', name='view_master_plan_manage_kpi_add_kpi'),
    url(r'^master_plan/manage/kpi/(?P<kpi_id>\d+)/edit/$', 'view_master_plan_manage_kpi_edit_kpi', name='view_master_plan_manage_kpi_edit_kpi'),
    url(r'^master_plan/manage/kpi/(?P<kpi_id>\d+)/delete/$', 'view_master_plan_manage_kpi_delete_kpi', name='view_master_plan_manage_kpi_delete_kpi'),
    
    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/manage/kpi/categoty/$', 'view_master_plan_manage_kpi_category', name='view_master_plan_manage_kpi_category'),
    url(r'^master_plan/(?P<master_plan_ref_no>\d+)/manage/kpi/category/add/$', 'view_master_plan_manage_kpi_add_category', name='view_master_plan_manage_kpi_add_category'),
    url(r'^master_plan/manage/kpi/category/(?P<kpi_category_id>\d+)/edit/$', 'view_master_plan_manage_kpi_edit_category', name='view_master_plan_manage_kpi_edit_category'),
    url(r'^master_plan/manage/kpi/cat
class TestMagnumDbManage(base.TestCase):
    def setUp(self):
        super(TestMagnumDbManage, self).setUp()
        def clear_conf():
            db_manage.CONF.reset()
            db_manage.CONF.unregister_opt(db_manage.command_opt)
        clear_conf()
        self.addCleanup(clear_conf)
    @mock.patch('magnum.db.migration.version')
    @mock.patch('sys.argv', ['magnum-db-manage', 'version'])
    def test_db_manage_version(self, mock_version):
        with mock.patch('sys.stdout', new=six.StringIO()) as fakeOutput:
            mock_version.return_value = '123456'
            db_manage.main()
            self.assertEqual('Current DB revision is 123456\n',
                             fakeOutput.getvalue())
            mock_version.assert_called_once_with()
    @mock.patch('magnum.db.migration.upgrade')
    @mock.patch('sys.argv', ['magnum-db-manage', 'upgrade'])
    def test_db_manage_upgrade(self, mock_upgrade):
        db_manage.main()
        mock_upgrade.assert_called_once_with
"""Majordomo Protocol Client API, Python version.
Author: Min RK <benjaminrk@gmail.com>
Based on Java example by Arkadiusz Orzechowski
"""
class MajorDomoClient(object):
    """Majordomo Protocol Client API, Python version.
    """
    broker = None
    ctx = None
    client = None
    poller = None
    timeout = 2500
    retries = 3
    verbose = False
    
    def __init__(self, broker, verbose=False):
        self.broker = broker
        self.verbose = verbose
        self.ctx = zmq.Context()
        self.poller = zmq.Poller()
        logging.basicConfig(format="%(asctime)s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",
                level=logging.INFO)
        self.reconnect_to_broker()
        
    def reconnect_to_broker(self):
        """Connect or reconnect to broker"""
        if self.client:
            self.poller.unregister(self.client)
            self.client.close()
        self.client = self.ctx.socket(zmq.REQ)
        self.client.linger = 0
        self.client.connect(sel

        self.poller.register(self.client, zmq.POLLIN)
        if self.verbose:
            logging.info("I: connecting to broker at %s...", self.broker)
    def send(self, service, request):
        """Send request to broker and get reply by hook or crook.
        
        Takes ownership of request message and destroys it when sent.
        Returns the reply message or None if there was no reply.
        """
        if not isinstance(request, list):
            request = [request]
        request = [MDP.C_CLIENT, service] + request
        if self.verbose:
            logging.warn("I: send request to '%s' service: ", service)
            dump(request)
        reply = None
        retries = self.retries
        while retries > 0:
            self.client.send_multipart(request)
            try:
                items = self.poller.poll(self.timeout)
            except KeyboardInterrupt:
            
            if items:
                msg = self.client.recv_multipart()
               
__author__ = 'zhangbohan'
class ReplicationControllerManage(object):
    def __init__(self, kubenetesClient=None):
        self.kubenetesClient = kubenetesClient
        pass
    def createReplicationController(self,replicationControllerRequest):
        self.kubenetesClient.createReplicationController(replicationControllerRequest)
        pass
    def deleteReplicationController(self, replicationControllerRequest):
        ReplicationControllerId = replicationControllerRequest.getId()
        result = self.kubenetesClient.deleteReplicationController(ReplicationControllerId)
        return result
    def queryReplicationController(self, replicationControllerRequest):
        ReplicationControllerId = replicationControllerRequest.getId()
        result = self.kubenetesClient.queryReplicationController(ReplicationControllerId)
        return result
    def queryReplicationControllersInFarm(self, replicationControllerRequest):
        labels = replicationControllerRequest.getLabels()
    

        labelValues = labels[labelName]
        queryLabels = "%s=%s" % (labelName, labelValues)
        result = self.kubenetesClient.queryReplicationControllerByLabel(queryLabels)
        return result
    def queryReplicationControllersInRole(self, replicationControllerRequest):
        labels = replicationControllerRequest.getLabels()
        labelName = "rolelabel"
        labelValues = labels[labelName]
        queryLabels = "%s=%s" % (labelName, labelValues)
        result = self.kubenetesClient.queryReplicationControllerByLabel(queryLabels)
        return result
    def resizeReplicationController(self, replicationControllerRequest, newSize):
        ReplicationControllerId = replicationControllerRequest.getId()
        status, result = self.kubenetesClient.queryReplicationController(ReplicationControllerId)
        if status == 200:
            recentReplicationControllerModel = ReplicationController.fromJSON(result)
            resourceVersion = recentReplicationControllerMo
class TestController(unittest.TestCase):
    
    
    def testAddClient(self):
        controller = Controller()
        controller.repository.addClient("Paul","12345")
        self.assertEqual(len(controller.repository.clients),1)
        
    def testAddMovie(self):
        controller = Controller()
        controller.repository.addMovie("titanic","12345","drama")
        controller.repository.addMovie("titanic","12345","drama")
        controller.repository.addMovie("titanic","12345","drama")
        self.assertEqual(len(controller.repository.movies),3)
    def testDeleteClient(self):
        controller = Controller()
        client1 = controller.repository.addClient("Paul","123451")
        client2 = controller.repository.addClient("Paula","1234511")
        client3 = controller.repository.addClient("Paulaa","1234522")
        client4 = controller.repository.addClient("Paulaaa","1234533")
        client5 = controller.repository.addClient("Paulaaaa","1234544")
        controller.re

        controller.repository.deleteClient(client5.id)
        self.assertEqual(len(controller.repository.clients),3)
    def testDeleteMovie(self):
        controller = Controller()
        movie1 = controller.repository.addMovie("titanic1","12345","drama")
        movie2 = controller.repository.addMovie("titanic2","12345","drama")
        movie3 = controller.repository.addMovie("titanic3","12345","drama")
        self.assertEqual(controller.repository.deleteMovie(movie2.id),True)
        self.assertEqual(len(controller.repository.movies),2)
    def testUpdateClient(self):
        controller = Controller()
        client1 = controller.repository.addClient("Paul","123451")
        client2 = controller.repository.addClient("Paula","1234511")
        controller.repository.updateClient(client1.id,"Dan","69")
        self.assertEqual(controller.repository.clients[0].name,"Dan")
        self.assertEqual(controller.repository.clients[0].cnp,"69")
    
    def testUpdateMovie(self):
        

        movie1 = controller.repository.addMovie("titanic1","12345","drama")
        movie2 = controller.repository.addMovie("titanic2","12345","drama")
        movie3 = controller.repository.addMovie("titanic3","12345","drama")
        controller.repository.updateMovie(movie1.id,"Titlu","Desc","Comed")
        self.assertEqual(controller.repository.movies[0].title,"Titlu")
        self.assertEqual(controller.repository.movies[0].description,"Desc")
        self.assertEqual(controller.repository.movies[0].genre,"Comed")
    def testSearchClient(self):
        controller = Controller()
        client1 = controller.repository.addClient("Paul","123451")
        client2 = controller.repository.addClient("Paula","1234511")
        self.assertEqual(controller.searchForClient("Paul").id,client1.id)
        self.assertEqual(controller.searchForClient("Dan"),None)
    def testSearchMovie(self):
        controller = Controller()
        movie1 = controller.repository.addMovie("mov","12345","dram
roslib.load_manifest('controller_manager')
class Tracker:
    def __init__(self, topic, Msg):
        self.sub = rospy.Subscriber(topic, Msg, self.callback)
    def callback(self, msg):
        self.msg = msg
def print_usage(exit_code = 0):
    print '''Commands:
    load <name>          - Load the controller named <name>
    unload <name>        - Unload the controller named <name>
    start <name>         - Start the controller named <name>
    stop <name>          - Stop the controller named <name>
    spawn <name>         - Load and start the controller named <name>
    kill <name>          - Stop and unload the controller named <name>
    list                 - List active controllers
    list-types           - List controller Types
    reload-libraries     - Reloads all plugin controller libraries'''
    sys.exit(exit_code)
if __name__ == '__main__':
    args = rospy.myargv()
    if len(args) < 2:
        print_usage()
    if args[1] == 'lt' or args[1] == 'list-types':
        co

    elif args[1] == 'lc' or args[1] == 'list':
        controller_manager_interface.list_controllers()
    elif args[1] == 'reload-libraries':
        print "ARGS", args, args[2:]
        if '--restore' in args[2:]:
            print "RE1"
            controller_manager_interface.reload_libraries(True, restore = True)
        else:
            controller_manager_interface.reload_libraries(True)
    elif args[1] == 'load':
        for c in args[2:]:
            controller_manager_interface.load_controller(c)
    elif args[1] == 'unload':
        for c in args[2:]:
            controller_manager_interface.unload_controller(c)
    elif args[1] == 'start':
        for c in args[2:]:
            controller_manager_interface.start_controller(c)
    elif args[1] == 'stop':
        for c in args[2:]:
            controller_manager_interface.stop_controller(c)
    elif args[1] == 'sp' or args[1] == 'spawn':
        for c in args[2:]:
            controller_manager_interface.load_controller(c)

def run():
 n1= node_user(fb_id="34",user_name="joe")
 n1.save()
 n2= node_user(fb_id="35",user_name="sam")
 n2.save()
 n3= node_user(fb_id="36",user_name="john")
 n3.save()
 n4= node_user(fb_id="37",user_name="jeff")
 n4.save()
 n5= node_user(fb_id="38",user_name="tom")
 n5.save()
 n6= node_user(fb_id="39",user_name="ravi")
 n6.save()
 n7= node_user(fb_id="40",user_name="lucky")
 n7.save()
 edge_friend(node_user_1=n1,node_user_2= n2).save()
 edge_friend(node_user_1=n2,node_user_2= n1).save()
 edge_friend(node_user_1=n1,node_user_2=n3).save()
 edge_friend(node_user_1=n3,node_user_2=n1).save()
 edge_friend(node_user_1=n4,node_user_2=n1).save()
 edge_friend(node_user_1=n1,node_user_2=n4).save()
 edge_friend(node_user_1=n2,node_user_2=n5).save()
 edge_friend(node_user_1=n5,node_user_2=n2).save()
 reviews(product_id=1234,user_id=n2,comment="ABC",rating=2).save()
 reviews(product_id=1234,user_id=n3,comment="DEF",rating=3).save()
 reviews(product_id=1234,user_id=n4,comment="GHI",rating=4).sa
generate_and_write_rsa_keypair("./key", 2048, "password")
repository = create_new_repository("./repository")
repository.root.add_key(pubKey)
repository.targets.add_key(pubKey)
repository.release.add_key(pubKey)
repository.timestamp.add_key(pubKey)
repository.root.threshold = 1
repository.root.load_signing_key(privKey)
repository.targets.load_signing_key(privKey)
repository.release.load_signing_key(privKey)
repository.timestamp.load_signing_key(privKey)
repository.targets.delegate("unclaimed", [pubKey], [])
repository.targets.unclaimed.load_signing_key(privKey)
y = 0
while y < 4096:
    prefix = []
    for k in range(y, y + 4):
        a = hex(k)
        pre = ''
        if len(a[2:]) == 1:
            pre = "00" + a[2:]
        elif len(a[2:]) == 2:
            pre = "0" + a[2:]
        else:
            pre = a[2:]
        prefix.append(pre)
    delName = hex(y)
    if len(delName[2:]) == 1:
        delName = "00" + delName[2:]
    elif len(delName[2:]) == 2:
        delName = "0" + d
class ApiRefs(object):
    WHAT__API_INIT = "api.tas.stateControl.init"
    WHAT__API_START = "api.tas.stateControl.start"
    WHAT__API_STOP = "api.tas.stateControl.stop"
    WHAT__API_PAUSE = "api.tas.stateControl.pause"
    WHAT__API_PAUSEATEND = "api.tas.stateControl.pauseAtEnd"
    WHAT__API_TERMINATE = "api.tas.stateControl.terminate"
    WHAT__API_SIGNALSENABLE = "api.tas.signalFilter.mute.disable"
    WHAT__API_SIGNALSDISABLE = "api.tas.signalFilter.mute.ensable"
    WHAT__API_SIGNALSADD = "api.tas.signalFilter.add"
    WHAT__API_SIGNALSREMOVE = "api.tas.signalFilter.remove"
    WHAT__API_SIGNALSRETRIEVE = "api.tas.signalFilter.retrieve"
    WHAT__API_SIGNALSMUTEALL = "api.tas.signalFilter.muteAll"
    WHAT__API_SIGNALSENABLEALL = "api.tas.signalFilter.globalEnable.enable"
    WHAT__API_SIGNALSQUERY = "api.tas.signalFilter.query"
    WHAT__API_SIGNALSQUERYALL = "api.tas.signalFilter.queryAll"
    WHAT__API_SIGNALSREMOVEALL = "api.tas.signalFilter.removeAll"
    WHAT__API_TAS_ST

    WHAT__API_TESTS_NEW = "api.testManagement.tests.newTests"
    WHAT__API_TESTS_STATS = "api.testManagement.tests.testStatsChange"
    WHAT__API_TESTS_STATS_REFRESH = "api.testManagement.tests.stats"
    WHAT__API_TESTS_QUERY = "api.testManagement.tests.query"
    WHAT__API_TESTS_QUERY_ALL = "api.testManagement.tests.queryAll"
    WHAT__API_TESTS_QUERY_METADATA = "api.testManagement.tests.queryMetadata"
    WHAT__API_TESTS_STATE = "api.testManagement.tests.testStateChange"
    WHAT__API_PEERS_STATS = "api.peers.peerStatsChange"
    WHAT__API_PEERS_STATS_REFRESH = "api.peers.stats"
    WHAT__API_PEERS_STATE = "api.peers.peerStateChange"
    WHAT__API_PEERS_NEW = "api.peers.newPeers"
    WHAT__API_PEERS_REMOVE = "api.peers.remove"
    WHAT__API_PEERS_QUERY = "api.peers.query"
    WHAT__API_PEERS_QUERY_ALL = "api.peers.queryAll"
    WHAT__API_TRMS_UPLOAD = "api.results.trms.upload"
    WHAT__API_PACKAGE_STATUS_CHANGE = "api.results.package.status"
    WHAT__API_RESULT_STATS = "api.resu
api = pyvcal.get_api('git')
path = os.path.join(os.path.dirname(__file__), '..', 'repositories', 'git')
class BasicRepository(object):
    """Represents our 'basic' test repository"""
    def __init__(self):
        """Run the create_basic_repository script"""
        super(BasicRepository, self).__init__()
        os.chdir(path)
        if (os.path.exists(os.path.join(path, 'testrepo01'))):
            self.teardown() 
        subprocess.Popen(['bash', 'create_basic_repository.sh'],    
                         stdout=subprocess.PIPE).wait()
        
    def repo(self):
        """Return a newly initiated PyVCAL Repository"""
        return api.Repository(path=os.path.join(path, 'testrepo01'))
    def teardown(self):
        """Clean up the created repository"""
        rmrf(os.path.join(path, 'testrepo01'))
test_git = TestSuite()
def test_create(testinstance):
    """Test Git repository creation."""
    basic_repo = BasicRepository()
    repo = basic_repo.repo()
    testinstance.asse
DB_SHARED_THREAD = """\
DatabaseWrapper objects created in a thread can only \
be used in that same thread.  The object with alias '{0}' \
was created in thread id {1} and this is thread id {2}.\
"""
def patch_thread_ident():
    if getattr(patch_thread_ident, 'called', False):
        return
    try:
        if 'validate_thread_sharing' in BaseDatabaseWrapper.__dict__:
            _get_ident = thread.get_ident
            __old__init__ = BaseDatabaseWrapper.__init__
            def _init(self, *args, **kwargs):
                __old__init__(self, *args, **kwargs)
                self._thread_ident = _get_ident()
            def _validate_thread_sharing(self):
                if (not self.allow_thread_sharing
                        and self._thread_ident != _get_ident()):
                    raise DatabaseError(
                        DB_SHARED_THREAD % (
                            self.alias, self._thread_ident, _get_ident()),
                    )
            BaseDatabaseWrapper._

            BaseDatabaseWrapper.validate_thread_sharing = \
                _validate_thread_sharing
        patch_thread_ident.called = True
    except ImportError:
        pass
patch_thread_ident()
class CeleryCommand(BaseCommand):
    options = BaseCommand.option_list
    skip_opts = ['--app', '--loader', '--config']
    keep_base_opts = False
    def get_version(self):
        return 'celery {c.__version__}\ndjango-celery {d.__version__}'.format(
            c=celery, d=djcelery,
        )
    def execute(self, *args, **options):
        broker = options.get('broker')
        if broker:
            self.set_broker(broker)
        super(CeleryCommand, self).execute(*args, **options)
    def set_broker(self, broker):
        os.environ['CELERY_BROKER_URL'] = broker
    def run_from_argv(self, argv):
        self.handle_default_options(argv[2:])
        return super(CeleryCommand, self).run_from_argv(argv)
    def handle_default_options(self, argv):
        acc = []
        broker = 
class PrintVisitor2(PrintVisitor):
    def visitShiftLeftInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s << %s" % (self.dispatch(n.lhs),
                                      self.dispatch(n.rhs[0]),
                                      self.dispatch(n.rhs[1]))
        else:
            return "sall %s, %s" % (self.dispatch(n.rhs[0]),
                                    self.dispatch(n.lhs))
    def visitShiftRightInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s >> %s" % (self.dispatch(n.lhs),
                                      self.dispatch(n.rhs[0]),
                                      self.dispatch(n.rhs[1]))
        else:
            return "sarl %s, %s" % (self.dispatch(n.rhs[0]),
                                   self.dispatch(n.lhs))
    def visitIntOrInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s | %s" % (self.dispatch(n.lhs),
                                     self.dispatch(n.rhs[0]),
               

        else:
            return "orl %s, %s" % (self.dispatch(n.rhs[0]),
                                  self.dispatch(n.lhs))
    def visitIntAndInstr(self, n):
        if len(n.rhs) > 1:
            return "%s = %s & %s" % (self.dispatch(n.lhs),
                                     self.dispatch(n.rhs[0]),
                                     self.dispatch(n.rhs[1]))
        else:
            return "andl %s, %s" % (self.dispatch(n.lhs),
                                 self.dispatch(n.rhs[0]))
    def visitIntNotInstr(self, n):
        x = self.dispatch(n.lhs)
        return 'negl %s' % x
    
    def visitCMPLInstr(self, n):
        return "cmpl %s, %s" % (self.dispatch(n.rhs[0]),
                                 self.dispatch(n.rhs[1]))
    def visitSetIfEqInstr(self, n):
        return "sete %s" % self.dispatch(n.lhs)
    def visitSetIfNotEqInstr(self, n):
        return "setne %s" % self.dispatch(n.lhs)
    def visitIntMoveZeroExtendInstr(self, n):
        return "movbzl %s,
class MongoDBIO:
    def __init__(self, host, port, name, password, database, collection):
        self.host = host
        self.port = port
        self.name = name
        self.password = password
        self.database = database
        self.collection = collection
    def Connection(self):
        connection = pymongo.Connection(host=self.host, port=self.port)
        db = connection[self.database]
        if self.name or self.password:
        posts = db[self.collection]
        return posts
def ResultSave(save_host, save_port, save_name, save_password, save_database, save_collection, save_content):
    posts = MongoDBIO(save_host, save_port, save_name,
                      save_password, save_database, save_collection).Connection()
    posts.save(save_content)
def num2name(category_num):
    Category_Map = {
        "1": u"外汇",
        "2": u"股市",
        "3": u"商品",
        "4": u"债市",
        "5": u"央行",
        "9": u"中国",
        "10": u"美国",
        "11": u"欧元区",
        "1

        "13": u"英国",
        "14": u"澳洲",
        "15": u"加拿大",
        "16": u"瑞士",
        "17": u"其他地区"
    }
    if Category_Map.has_key(category_num):
        return Category_Map[category_num]
    else:
        return ""
def Spider(url, data):
    return content
def ContentSave(item):
    save_host = "localhost"
    save_port = 27017
    save_name = ""
    save_password = ""
    save_database = "textclassify"
    save_collection = "WallstreetcnSavePython"
91
    source = "wallstreetcn"
    createdtime = datetime.datetime.now()
    type = item[0]
    content = item[1].decode("unicode_escape")
    content = content.encode("utf-8")
    categorySet = item[2]
     category_num = categorySet.split(",")
     category_name = map(num2name, category_num)
     districtset = set(category_name) & {
                       u"中国", u"美国", u"欧元区", u"日本", u"英国", u"澳洲", u"加拿大", u"瑞士", u"其他地区"}
     district = ",".join(districtset)
     propertyset = set(category_name) & {u"外汇", u"股市", u"商品", u"债市"}


     centralbankset = set(category_name) & {u"央行"}
     centralbank = ",".join(centralbankset)
     save_content = {
         "source": source,
         "createdtime": createdtime,
         "content": content,
         "type": type,
         "district": district,
         "property": property,
         "centralbank": centralbank
     }
     ResultSave(save_host, save_port, save_name, save_password,
                save_database, save_collection, save_content)
 def func(page): 
     url = "http://api.wallstreetcn.com/v2/livenews" 
     data = { 
         "page":page 
     } 
     content = Spider(url, data) 
     if len(items) == 0: 
         print "The End Page:", page 
         full_url = url+'?'+data 
         print full_url 
     else: 
         print "The Page:", page, "Downloading..." 
         for item in items: 
             ContentSave(item) 
 if __name__ == '__main__': 
     start = datetime.datetime.now() 
     start_page = 1 
     end_page = 3000 
     pages = [i for i in r
log = logging.getLogger( 'test.tool_shed.test_db_util' )
def delete_obj( obj ):
    sa_session.delete( obj )
    sa_session.flush()
    
def delete_user_roles( user ):
    for ura in user.roles:
        sa_session.delete( ura )
    sa_session.flush()
    
def flush( obj ):
    sa_session.add( obj )
    sa_session.flush()
    
def get_all_repositories():
    return sa_session.query( model.Repository ).all()
def get_all_installed_repositories( actually_installed=False ):
    if actually_installed:
        return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ) \
                         .filter( and_( galaxy.model.tool_shed_install.ToolShedRepository.table.c.deleted == False,
                                        galaxy.model.tool_shed_install.ToolShedRepository.table.c.uninstalled == False,
                                        galaxy.model.tool_shed_install.ToolShedRepository.table.c.status == galaxy.model.tool_shed_install.ToolShedRepository.installation_

                         .all()
    else:
        return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ).all()
    
def get_category_by_name( name ):
    return sa_session.query( model.Category ) \
                     .filter( model.Category.table.c.name == name ) \
                     .first()
                     
def get_default_user_permissions_by_role( role ):
    return sa_session.query( model.DefaultUserPermissions ) \
                     .filter( model.DefaultUserPermissions.table.c.role_id == role.id ) \
                     .all()
                     
def get_default_user_permissions_by_user( user ):
    return sa_session.query( model.DefaultUserPermissions ) \
                     .filter( model.DefaultUserPermissions.table.c.user_id==user.id ) \
                     .all()
                     
def get_galaxy_repository_by_name_owner_changeset_revision( repository_name, owner, changeset_revision ):
    return install_session.query( galaxy.mod

                     .filter( and_( galaxy.model.tool_shed_install.ToolShedRepository.table.c.name == repository_name,
                                    galaxy.model.tool_shed_install.ToolShedRepository.table.c.owner == owner,
                                    galaxy.model.tool_shed_install.ToolShedRepository.table.c.changeset_revision == changeset_revision ) ) \
                     .first()
                     
def get_installed_repository_by_id( repository_id ):
    return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ) \
                     .filter( galaxy.model.tool_shed_install.ToolShedRepository.table.c.id == repository_id ) \
                     .first()
                     
def get_installed_repository_by_name_owner( repository_name, owner ):
    return install_session.query( galaxy.model.tool_shed_install.ToolShedRepository ) \
                     .filter( and_( galaxy.model.tool_shed_install.ToolShedRepository.table.c.name == repository_n
try:
except ImportError:
    multiprocessing = None
starting_queue = None
stopping_queue = None
def make_broker(manager, worker_model, start_queue=None, stop_queue=None):
    global starting_queue
    global stopping_queue
    starting_queue = start_queue
    stopping_queue = stop_queue
    options = get_options(worker_model)
    return manager_worker_broker.get(port.get("test"), options, manager, _TestWorker)
class _TestWorker(manager_worker_broker.AbstractWorker):
    def __init__(self, broker_connection, worker_number, options):
        self._broker_connection = broker_connection
        self._options = options
        self._worker_number = worker_number
        self._name = 'TestWorker/%d' % worker_number
        self._stopped = False
        self._canceled = False
        self._starting_queue = starting_queue
        self._stopping_queue = stopping_queue
    def handle_stop(self, src):
        self._stopped = True
    def handle_test(self, src, an_int, a_str):
        assert an_in

        assert a_str == "hello, world"
        self._broker_connection.post_message('test', 2, 'hi, everybody')
    def is_done(self):
        return self._stopped or self._canceled
    def name(self):
        return self._name
    def cancel(self):
        self._canceled = True
    def run(self, port):
        if self._starting_queue:
            self._starting_queue.put('')
        if self._stopping_queue:
            self._stopping_queue.get()
        try:
            self._broker_connection.run_message_loop()
            self._broker_connection.yield_to_broker()
            self._broker_connection.post_message('done')
        except Exception, e:
            self._broker_connection.post_message('exception', (type(e), str(e), None))
def get_options(worker_model):
    option_list = (manager_worker_broker.runtime_options() +
                   printing.print_options() +
                   [optparse.make_option("--experimental-fully-parallel", default=False),
                    optpa

    parser = optparse.OptionParser(option_list=option_list)
    options, args = parser.parse_args(args=['--worker-model', worker_model])
    return options
class FunctionTests(unittest.TestCase):
    def test_get__inline(self):
        self.assertTrue(make_broker(self, 'inline') is not None)
    def test_get__processes(self):
        if sys.platform in ('cygwin', 'win32'):
            return
        if multiprocessing:
            self.assertTrue(make_broker(self, 'processes') is not None)
        else:
            self.assertRaises(ValueError, make_broker, self, 'processes')
    def test_get__unknown(self):
        self.assertRaises(ValueError, make_broker, self, 'unknown')
class _TestsMixin(object):
    """Mixin class that implements a series of tests to enforce the
    contract all implementations must follow."""
    def name(self):
        return 'Tester'
    def is_done(self):
        return self._done
    def handle_done(self, src):
        self._done = True
    def handle_test(
@mock.patch('msword_cli.WORD', spec_set=MockApp(['foo.docx']))
class TestSaveCommand(unittest.TestCase):
    def setUp(self):
        self.runner = CliRunner()
    def test_save_defaults(self, mock_app):
        ''' Test save defaults. '''
        result = self.runner.invoke(msword_cli.save)
        self.assertEqual(result.exit_code, 0)
        mock_app.ActiveDocument.Save.assert_called_with(NoPrompt=False)
    def test_save_path(self, mock_app):
        ''' Test save to path. '''
        filename = 'bar.docx'
        result = self.runner.invoke(msword_cli.save, ['--path', filename])
        self.assertEqual(result.exit_code, 0)
        mock_app.ActiveDocument.SaveAs.assert_called_with(os.path.abspath(filename))
    def test_force_save(self, mock_app):
        ''' Test force save. '''
        result = self.runner.invoke(msword_cli.save, ['--force'])
        self.assertEqual(result.exit_code, 0)
        mock_app.ActiveDocument.Save.assert_called_with(NoPrompt=True)
    def test_save_all
class HTMLResources():
    ''' HTML Resources '''
    
    
    const.MAIN_HTML = '/main.html'
    const.USER_SIGNIN_HTML = '/user_signin.html'
    const.ID_CHECK_HTML = '/id_check.html'
    const.EDIT_PERSONAL_HTML = 'edit_personal.html'
    
    const.BOARD_HTML = '/board.html'
    const.ARTICLE_NOTICE_HTML = '/article_notice.html'
    const.ARTICLE_READ_HTML = '/article_read.html'
    const.ARTICLE_WRITE_HTML = '/article_write.html'
    
    const.RANK_HTML = '/rank.html'
    
    const.TEAM_HTML = '/team.html'
    const.TEAM_MAKE_HTML = '/team_make.html'
    const.TEAM_MANAGE_HTML = '/team_manage.html'
    const.TEAM_INFORMATION_HTML = '/team_information.html'
    
    const.SUBMISSION_RECORD_HTML = '/submission_record.html'
    const.SUBMISSION_CODE_HTML = '/submission_code.html'
    
    const.PROBLEM_HTML = '/problem.html'
    const.PROBLEM_RECORD_HTML = '/problem_record.html'
    const.PROBLEM_LIST_HTML = '/problem_list.html'
  
    const.SERVER_ADD_CLASS_HTML = '/server_add_cl
@pytest.fixture
def listener():
    return mock.Mock()
@pytest.fixture
def broker():
    return Broker()
def test_calls_subscribed(broker, listener):
    event = 'test'
    sentinel = object()
    broker.subscribe(event, listener.test_cb)
    broker.publish(event, s=sentinel)
    assert_that(listener.test_cb, called_once_with(s=sentinel))
def test_disconnect(broker, listener):
    event = 'test'
    broker.subscribe(event, listener.test_cb)
    broker.subscribe(event, listener.test2_cb)
    broker.publish(event)
    broker.disconnect(event, listener.test_cb)
    broker.publish(event)
    assert_that(listener.test_cb.call_count, equal_to(1))
    assert_that(listener.test2_cb.call_count, equal_to(2))
def test_disconnect_exc(broker, listener):
    event = 'test'
    listener.spam_cb = mock.Mock(side_effect=Disconnect)
    broker.subscribe(event, listener.spam_cb)
    broker.subscribe(event, listener.spam_cb2)
    broker.publish(event)
    broker.publish(event)
    assert_that(listener.spa
"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""
LiveBroker = livebroker.LiveBroker
class BacktestingBroker(backtesting.Broker):
    MIN_TRADE_USD = 5
    """A Bitstamp backtesting broker.
    :param cash: The initial amount of cash.
    :type cash: int/float.
    :param barFeed: The bar feed that will provide the bars.
    :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`
    :param fee: The fee percentage for each order. Defaults to 0.25%.
    :type fee: float.
    .. note::
        * Only limit orders are supported.
        * Orders are automatically set as **goodTillCanceled=True** and  **allOrNone=False**.
        * BUY_TO_COVER orders are mapped to BUY orders.
        * SELL_SHORT orders are mapped to SELL orders.
    """
    def __init__(self, cash, barFeed, fee=0.0025):
        commission = backtesting.TradePercentage(fee)
        backtesting.Broker.__init__(self, cash, barFeed, commission)
    def getInstrumentTraits(self, instrument):


    def submitOrder(self, order):
        if order.isInitial():
            order.setAllOrNone(False)
            order.setGoodTillCanceled(True)
        return backtesting.Broker.submitOrder(self, order)
    def createMarketOrder(self, action, instrument, quantity, onClose=False):
        raise Exception("Market orders are not supported")
    def createLimitOrder(self, action, instrument, limitPrice, quantity):
        if instrument != common.btc_symbol:
            raise Exception("Only BTC instrument is supported")
        if action == broker.Order.Action.BUY_TO_COVER:
            action = broker.Order.Action.BUY
        elif action == broker.Order.Action.SELL_SHORT:
            action = broker.Order.Action.SELL
        if limitPrice * quantity < BacktestingBroker.MIN_TRADE_USD:
            raise Exception("Trade must be >= %s" % (BacktestingBroker.MIN_TRADE_USD))
        if action == broker.Order.Action.BUY:
            fee = self.getCommission().calculate(None, limitPrice, quanti

            cashRequired = limitPrice * quantity + fee
            if cashRequired > self.getCash(False):
                raise Exception("Not enough cash")
        elif action == broker.Order.Action.SELL:
            if quantity > self.getShares(common.btc_symbol):
                raise Exception("Not enough %s" % (common.btc_symbol))
        else:
            raise Exception("Only BUY/SELL orders are supported")
        return backtesting.Broker.createLimitOrder(self, action, instrument, limitPrice, quantity)
    def createStopOrder(self, action, instrument, stopPrice, quantity):
        raise Exception("Stop orders are not supported")
    def createStopLimitOrder(self, action, instrument, stopPrice, limitPrice, quantity):
        raise Exception("Stop limit orders are not supported")
class PaperTradingBroker(BacktestingBroker):
    """A Bitstamp paper trading broker.
    :param cash: The initial amount of cash.
    :type cash: int/float.
    :param barFeed: The bar feed that will p
"""
Copyright (C) 2016 Dariusz Suchojad <dsuch at zato.io>
Licensed under LGPLv3, see LICENSE.txt for terms and conditions.
"""
logger = logging.getLogger(__name__)
class Worker(BaseZMQConnection):
    """ Standalone implementation of a worker for ZeroMQ Majordomo Protocol 0.1 http://rfc.zeromq.org/spec:7
    """
    def __init__(self, service_name, broker_address='tcp://localhost:47047', linger=0, poll_interval=100, log_details=False,
            heartbeat=3, heartbeat_mult=2, reconnect_sleep=2):
        self.service_name = service_name
        super(Worker, self).__init__(broker_address, linger, poll_interval, log_details)
        self.heartbeat = heartbeat
        self.heartbeat_mult = heartbeat_mult
        self.reconnect_sleep = reconnect_sleep
        self.broker_last_heartbeat = None
        self.worker_last_heartbeat = None
        self.last_connected = datetime.utcnow()
        self.has_debug = logger.isEnabledFor(logging.DEBUG)
        self.handle_event_map = {
            co

            const.v01.heartbeat: self.on_event_heartbeat,
            const.v01.disconnect: self.on_event_disconnect,
        }
    def connect(self):
        logger.info('Connecting to broker %s', self.broker_address)
        self.client_socket.connect(self.broker_address)
        self.worker_socket = self.ctx.socket(zmq.DEALER)
        self.worker_socket.linger = self.linger
        self.worker_poller = zmq.Poller()
        self.worker_poller.register(self.worker_socket, zmq.POLLIN)
        self.worker_socket.connect(self.broker_address)
        self.notify_ready()
        self.last_connected = datetime.utcnow()
    def stop(self):
        self.worker_poller.unregister(self.worker_socket)
        self.worker_socket.close()
        self.stop_client_socket()
        self.connect_client_socket()
        logger.info('Stopped worker for %s', self.broker_address)
    def needs_reconnect(self):
        base_timestamp = self.broker_last_heartbeat if self.broker_last_heartbeat else self.last

        return datetime.utcnow() >= base_timestamp + timedelta(seconds=self.heartbeat * self.heartbeat_mult)
    def reconnect(self):
        last_hb = '{} (UTC)'.format(self.broker_last_heartbeat.isoformat()) if self.broker_last_heartbeat else 'never'
        logger.info('Sleeping for %ss before reconnecting to broker %s, last HB from broker: %s',
            self.reconnect_sleep, self.broker_address, last_hb)
        time.sleep(self.reconnect_sleep)
        logger.info('Reconnecting to broker %s', self.broker_address)
        self.stop()
        self.connect()
        time.sleep(self.reconnect_sleep)
    def needs_hb_to_broker(self):
        return datetime.utcnow() >= self.worker_last_heartbeat + timedelta(seconds=self.heartbeat)
    def serve_forever(self):
        log_details = self.log_details
        while self.keep_running:
            try:
                items = self.worker_poller.poll(self.poll_interval)
            except KeyboardInterrupt:
                self.notify_disc
def tests_rent_controller():
    movieRepo = movie_repository()
    movieValid = movie_validator()
    movieController = movie_controller(movieRepo, movieValid)
    
    clientRepo = client_repository()
    clientValid = client_validator()
    clientController = client_controller(clientRepo, clientValid)
    
    movie_controller.createmovie("1", "blabla", "blaaa", "fantasy")
    movie_controller.createmovie("2", "blabla2", "blaaa2", "fantasy")
    movie_controller.createmovie("3", "blabla3", "blaaa3", "adventure")
    
    client_controller.createClient("1", "gabi", "1234")
    client_controller.createClient("2", "gabi23", "12345")
    client_controller.createClient("3", "gabi3", "123456")
    
    
    
    
    repo = rent_repository()
    valid = rent_validator()
    ctrl = rent_controller(repo, valid, movieRepo, clientRepo)
    
    rent1 = ctrl.createrent("1", "2")
    assert len(ctrl.getAllrents()) == 1
    assert rent1.getIDC() == "1"
    assert rent1.getIDF() == "2"
    
    t
"""
functionality for the setup of repositories;
this should really be more interface consuming
"""
class RepositorySetupError(Exception):
    """marker exception for errors occuring during repository setup"""
class RepositorySetup(object):
    """interface defining repository setup via TracLegos"""
    def __init__(self):
        self.name = self.__class__.__name__
        if not hasattr(self, 'description'):
            self.description = self.__doc__ 
    def options_fulfilled(self, vars):
        """returns whether all of the options are provided in vars"""
        return set([option.name for option in self.options]).issubset(vars)
    def enabled(self):
        """
        is this type of repository capable of being created 
        on this computer?
        """
        return False
    def config(self):
        """return a dictionary of .ini options"""
        return {}
    
    def setup(self, **vars):
        """
        create the repository
        """
class NoRepository(Repo

    """No repository"""
    options = []
    
    def enabled(self):
        return True
    def __len__(self):
        """test False"""
        return 0
class NewSVN(RepositorySetup):
    """Create a new SVN repository"""
    options = [ var('repository_dir', 'location to create the SVN repository')]
    def enabled(self):
        try:
            subprocess.call(['svnadmin', 'help'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return True
        except OSError:
            return False
    def config(self):
        return { 'trac': { 'repository_dir': '${repository_dir}',
                           'repository_type': 'svn' } }
    def setup(self, **vars):
        if not self.options_fulfilled(vars):
            raise RepositorySetupError("Missing directory")
        subprocess.call(['svnadmin', 'create', vars['repository_dir']])
        
class ExistingSVN(RepositorySetup):
    """Use an existing repository"""
    options = [ var('repository_dir', 'location of SVN re

    def enabled(self):
        return True
    def config(self):
        return { 'trac': { 'repository_dir': '${repository_dir}',
                           'repository_type': 'svn' } }
                        
class SVNSync(RepositorySetup):
    """Mirror SVN (1.4) repository"""
    options = [ var('repository_url', 'URL of remote svn repository (must be SVN v1.4)',
                    default='http://'),
                var('repository_dir', 'desired mirror location') ]
    def enabled(self):
        try:
        except ImportError:
            return False
        return True
    def config(self):
        return { 'svn': { 'repository_url': '${repository_url}', },
                 'trac': { 'repository_dir': '${repository_dir}',
                           'repository_type': 'svnsync' } } 
    def setup(self, **vars):
        if not self.options_fulfilled(vars):
            raise RepositorySetupError("Missing options")
class NewMercurialRepository(RepositorySetup):
    """Create a 
def index(request):
    return HttpResponse('ok')
def repository_list(request):
    repositories = Repository.objects.all()
    render_data = {
        'repository_list': repositories
    }
    return render(request, 'repository_list.html', render_data)
def view_repoository(request, uuid):
    repository = get_object_or_404(Repository, uuid=uuid)
    scan_url = request.build_absolute_uri(reverse('scan_repository', args=(repository.uuid,)))
    render_data = {
        'repository': repository,
        'scan_url': scan_url
    }
    return render(request, 'view_repository.html', render_data)
def view_scan(request, uuid):
    scan = get_object_or_404(RepositoryScan, uuid=uuid)
    return render(request, 'view_scan.html', {'scan': scan})
def run_scan(request, uuid):
    repository = get_object_or_404(Repository, uuid=uuid)
    scan_repository.delay(repository.id)
    return HttpResponse('Queued repo scan')
def create_repository(request):
    if request.method == 'POST':
        repository_

        if repository_form.is_valid():
            repository = repository_form.save(commit=False)
            repository.owner = request.user
            repository.save()
            keypair = RSA.generate(2048)
            private_key = keypair.exportKey('PEM')
            public_key = keypair.publickey().exportKey('OpenSSH')
            repository_key = RepositoryKey()
            repository_key.repository = repository
            repository_key.private_key = private_key
            repository_key.public_key = public_key
            repository_key.save()
            return redirect(reverse('view_repository', args=(repository.uuid,)))
    else:
        repository_form = RepositoryForm()
    return render(request, 'create_repository.html', {
        'form': repository_form,
    })
def add_scanner(request, repo_uuid):
    repository = Repository.objects.get(uuid=repo_uuid)
    if request.method == 'POST':
        form = RepositoryScannerForm(request.POST)
        repo_scanner = form.

        if form.is_valid():
            repo_scanner.repository = repository
            repo_scanner.save()
        return redirect(reverse('view_repository', args=(repository.uuid,)))
    else:
        form = RepositoryScannerForm()
    return render(request, 'add_scanner.html', {
        'form': form,
        'repository': repository
    })
def scanner_settings(request, uuid, scanner_name):
    repository = get_object_or_404(Repository, uuid=uuid)
    scanner = get_object_or_404(Scanner, short_name=scanner_name)
    repository_scanner = get_object_or_404(RepositoryScanner, repository=repository, scanner=scanner)
    try:
        settings = ScannerSettings(repository_scanner)
        if request.method == 'POST':
            settings.clear_settings()
            scanner_settings_form = scanner.scanner_class.settings_form(request.POST)
            if scanner_settings_form.is_valid():
                for field_name, value in request.POST.items():
                    if '/property/' in 
'''
Project container wrapping git version control
'''
class GitAnalysisProject(object):
    '''
    This project controller creates a git repository to store project files
    and their changes, and reads/writes to a plain-text (ini) configuration
    file within that repository to indicate settings in use.
    '''
    
    implements(pc.IAnalysisProject)
    
    
    settings_repository = ini_repo.INIDataRepository()
    file_repository = git_repo.GitDataRepository()
    
    def create_project(self, project_identifier, settings_source=None):
        """
        Create new project container.
        
        Initializes a git repo into the given directory (assumed to not exist).
        Creates a new settings ini called "project_settings.ini" in that directory.
        Creates a new log file called "project_history.txt" in that directory.
        """
        print "Creating a new project at \"%s\"..."%project_identifier
        
        proj_dir = os.path.abspath(project_identifier)

        try:
            os.stat(proj_dir)
        except:
            os.mkdir(proj_dir)
            
        self.identifier = project_identifier
        
        self.settings_repository.create_repository(project_identifier + "/project_settings.cfg")
        self.file_repository.create_repository(project_identifier)
        
        self.load_default_settings(settings_source)
        
        self.save_project()
        
    def open_project(self, project_identifier):
        """Point internal project reference to existing project"""
        self.identifier = project_identifier
        
        print "Using project at \"%s\"..."%project_identifier
        proj_dir = os.path.abspath(project_identifier)
        
        try:
            os.stat(proj_dir)
        except:
            print "No project directory found at %s"
            return
        
        self.settings_repository.open_repository(project_identifier + "/project_settings.cfg")
        self.file_repository.open_reposit

        
        for s in self.settings_repository.get_available_items():
            print s
        
    def save_project(self):
        '''
        Saves each project repository.
        '''
        self.settings_repository.save_repository()
        self.file_repository.save_repository()
        
    def close_project(self):
        '''
        Closes project repositories.
        '''
        self.file_repository.close_repository()
        self.settings_repository.close_repository()
    
    def load_default_settings(self, settings_source=None):
        """
        Load in settings from a local config file.
        (This assumes INIDataRepository use.)
        
        If not explicitly provided, looks in
        os.getcwd() + "/settings/"
                    + self.__class__.__name__
                    +"_default_settings.cfg"
        E.g. ./settings/SifterAnalysisProject_default_settings.cfg
        """
        if settings_source is None:
            settings_source = os.getcwd(
    ActionWorkflow, ActionTaskPublisher, ActionHeartbeat)
log = logging.getLogger("flooding.management.start_scenario")
def start_workflow(
    scenario_id, workflowtemplate_id, log_level='INFO',
    scenario_type="flooding_scenario"):
    """
    Opens connection to broker.
    Creates ActionWorkflow object.
    Creates logging handler to send loggings to broker.
    Sets logging handler to ActionWorkflow object.
    Performs workflow.
    Removes handler.
    Closes connection.
    See also: worker.action_workflow.ActionWorkflow object
    """
    numeric_level = getattr(logging, log_level.upper(), None)
    if not isinstance(numeric_level, int):
        log.error("Invalid log level: %s" % log_level)
        numeric_level = 10
    broker = BrokerConnection()
    connection = broker.connect_to_broker()
    if connection is None:
        log.error("Could not connect to broker.")
        return
    action = ActionWorkflow(
        connection, scenario_id, workflowtemplate_id,
        sc

    logging.handlers.AMQPMessageHandler = AMQPMessageHandler
    broker_handler = logging.handlers.AMQPMessageHandler(
        action, numeric_level)
    action.set_broker_logging_handler(broker_handler)
    status = action.perform_workflow()
    action.log.removeHandler(broker_handler)
    if connection.is_open:
        connection.close()
    return status
def start_task(task_id, log_level='INFO'):
    """
    Publish a message to execute a separate task.
    """
    task = WorkflowTask.objects.get(pk=task_id)
    numeric_level = getattr(logging, log_level.upper(), None)
    if not isinstance(numeric_level, int):
        log.error("Invalid log level: %s" % log_level)
        numeric_level = 10
    broker = BrokerConnection()
    connection = broker.connect_to_broker()
    if connection is None:
        log.error("Could not connect to broker.")
        return
    action = ActionTaskPublisher(connection, task)
    logging.handlers.AMQPMessageHandler = AMQPMessageHandler
    broker_hand
"""
    Sahana Eden Stats Controller
"""
module = request.controller
resourcename = request.function
if not settings.has_module(module):
    raise HTTP(404, body="Module disabled: %s" % module)
def parameter():
    """ REST Controller """
    return s3_rest_controller()
def data():
    """ REST Controller """
    return s3_rest_controller()
def aggregate():
    """ REST Controller """
    tablename = "stats_aggregate"
    table = s3db[tablename]
    def prep(r):
        if r.method == "clear":
            if not s3_has_role(ADMIN):
                auth.permission.fail()
            s3db.stats_rebuild_aggregates()
            redirect(URL(c="stats",
                         f="aggregate",
                         args="",
                         ))
        return True
    s3.prep = prep
    output = s3_rest_controller()
    return output
def demographic():
    """ REST Controller """
    return s3_rest_controller()
def demographic_data():
    """ REST Controller """
    return s3_rest_
broker_urls		= [ mcbroker.BRO_URL ]
'''
def test_client_simple():
    """
    This is a test of a simple client-broker session allocation
    """
    context		= zmq.Context()
    broker_threads	= mcbroker.demo_broker_servers( context, 10 )
    broker		= context.socket( zmq.REQ )
    broker.setsockopt( zmq.RCVTIMEO, 250 )
    for url in broker_urls:
        broker.connect( url )
    session 		= None
    broker.send_multipart( [ '' ] )
    try:
        key, url 	= broker.recv_multipart()
        session		= context.socket( zmq.REQ )
        session.setsockopt( zmq.RCVTIMEO, 1250 )
        session.connect( url )
        session.send_multipart( [key, 'Hello'] )
        response	= session.recv_multipart()
        assert len( response ) == 3
        assert response[0] == key
        assert response[1] == 'Hello'
        assert response[2] == 'World'
        session.send_multipart( [key] )
        ack		= session.recv_multipart()
        assert len( ack ) == 1
        assert ack[0] == key
    f
class RepositoryTestCase(unittest.TestCase):
    
    def mockConfigWithRepos(self, repositories):
        config = ConfigParser.SafeConfigParser()
        
        config.add_section('repositories')
        for repo in repositories:
            config.set('repositories', repo, repo)
        
        return config
    
    def mockConfigWithoutRepos(self):
        return ConfigParser.SafeConfigParser()
    
    def testItShouldRetrieveNoAdditionalRepositories(self):
        Configuration._Configuration__config = self.mockConfigWithRepos([])
        
        assert Repository.all() == []
    
    def testItShouldRetrieveAnAdditionalRepository(self):
        Configuration._Configuration__config = self.mockConfigWithRepos(['/usr/local/mercury/modules'])
        
        assert Repository.all() == ['/usr/local/mercury/modules']
    
    def testItShouldRetrieveAllWithoutAConfigFile(self):
        Configuration._Configuration__config = self.mockConfigWithoutRepos()
        
        assert R

    
    def testItShouldBuildDroidhgModulesPathAsDefault(self):
        Configuration._Configuration__config = self.mockConfigWithRepos([])
        
        assert Repository.droidhg_modules_path() == ""
    
    def testItShouldBuildDroidhgModulesPathWithAnAdditionalRepository(self):
        Configuration._Configuration__config = self.mockConfigWithRepos(['/usr/local/mercury/modules'])
        
        assert Repository.droidhg_modules_path() == "/usr/local/mercury/modules"
        
    def testItShouldBuildDroidhgModulesPathWithTwoAdditionalRepository(self):
        Configuration._Configuration__config = self.mockConfigWithRepos(['/usr/local/mercury/modules', '/tmp/modules'])
        
        assert Repository.droidhg_modules_path() == "/usr/local/mercury/modules:/tmp/modules"
        
    def testItShouldBuildDroidhgModulesPathWithoutAConfigFile(self):
        Configuration._Configuration__config = self.mockConfigWithoutRepos()
        
        assert Repository.droidhg_modules_pa

    
    def testItShouldCreateAModuleRepository(self):
        Configuration._Configuration__config = self.mockConfigWithoutRepos()
        
        Repository.create("./tmp")
        
        assert os.path.exists("./tmp")
        assert os.path.exists("./tmp/__init__.py")
        assert os.path.exists("./tmp/.mercury_repository")
        
        assert Repository.all() == ["./tmp"]
        
        shutil.rmtree("./tmp")
    
    def testItShouldNotCreateARepositoryOverAnExistingRecord(self):
        Configuration._Configuration__config = self.mockConfigWithoutRepos()
        
        Repository.create("./tmp")
        
        try:
            Repository.create("./tmp")
            assert False, "expected NotEmptyException"
        except NotEmptyException:
            pass
        
        shutil.rmtree("./tmp")
    
    def testItShouldNotCreateARepositoryOverAnExistingFolder(self):
        Configuration._Configuration__config = self.mockConfigWithoutRepos()
        
        os
class DocumentListControllerTest(unittest.TestCase):
    def add_dict_test(self):
        controller = DocumentListController()
        document = Document()
        
        controller.add(document)
        
        self.assertEquals(document, controller.association.values()[0])
        self.assertTrue(type(controller.association.keys()[0]) == QtGui.QStandardItem)
        
    def add_item_name_test(self):
        controller = DocumentListController()
        document = Document()
        document.path = "/path/to/test.tf"
        
        
        controller.add(document)
        item = controller.association.keys()[0]
        
        self.assertEquals("test.tf", item.text())
        
        
    def add_item_name2_test(self):
        controller = DocumentListController()
        
        document = Document()
        document.path = "/path/to/othertest.tf"
        
        controller.add(document)
        item = controller.association.keys()[0]
        
        self.assertEquals("

        
    def remove_item_dict_test(self):
        controller = DocumentListController()
        
        document = Document()
        controller.add(document)
        controller.remove(document)
        
        self.assertEquals(0, len(controller.association))
        
    def remove_item_dict2_test(self):
        controller = DocumentListController()
        
        document = Document()
        document2 = Document()
        controller.add(document)
        controller.add(document2)
        controller.remove(document)
        
        self.assertEquals(1, len(controller.association))
        self.assertTrue(document2 in controller.association.values())
        self.assertFalse(document in controller.association.values())
        
    def remove_item_return_test(self):
        controller = DocumentListController()
        
        document = Document()
        controller.add(document)
        
        document_item = controller.association.items()[0][0]
        removed_item = 
class ModelBase(models.Model):
    ''' 
    To be used by all base models. A a base model is any model
    that could be used as a standalone model. 
    '''
    class Meta:
        abstract = True
    def model_save(self, *args, **kargs):
        ''' Call the default model save '''
        models.Model.save(self, *args, **kargs)
    def save(self, *args, **kargs):
        '''
        Overrides default save behavior to call _pre_save and _post_save from 
        any interfaces that this model inherits from, as well as pre_save
        and post_save on the model itself.
        '''
        self._super_pre_save()
        models.Model.save(self, *args, **kargs)
        self._super_post_save()
    def _super_pre_save(self):
        '''
        Calls every _pre_save on any parent class (interface), calls pre_save
        on the model itself.
        '''
        if hasattr(self.__class__, 'pre_save'):
            self.__class__.pre_save(self)
        for cls in self.__class__.__bases__:
    
DIRECTORIES = (
   ('newsletter/unit_tests/test_views.py',
    './manage.py test --settings=test_settings newsletter.ViewsTestCase'),
   ('newsletter/unit_tests/test_templatetags.py',
    './manage.py test --settings=test_settings newsletter.NewsletterExtrasTestCase'),
               
   ('newsletter/unit_tests', 
    './manage.py test --settings=test_settings newsletter'),
   ('newsletter/views.py',
    './manage.py test --settings=test_settings newsletter.ViewsTestCase.test_find_clubs_by_location'),
   ('newsletter/templatetags/newsletter_extras.py',
    './manage.py test --settings=test_settings newsletter.NewsletterExtrasTestCase'),
   ('welcome',
    './manage.py test --settings=test_settings welcome'),
               
               
   ('djangopeople/unit_tests/test_utils.py',
    './manage.py test --settings=test_settings djangopeople.UtilsTestCase'),
   ('djangopeople/utils.py',
    './manage.py test --settings=test_settings djangopeople.UtilsTestCase'),
   ('djangopeople/unit
class TestController(Controller):
    class Meta:
        prefixes = ['pre']
    @route_with('/[controller]/[action]/<a>/<b>/<c>')
    @route_with('/[controller]/[action]/<a>/<b>')
    @route_with('/[controller]/[action]/<a>')
    @route_with('/[controller]/[action]')
    def method(self, a=0, b=0, c=0):
        return 'method_' + '/'.join([str(i) for i in (a, b, c)])
    @route_with('/[prefix]/[controller]/[action]/<a>/<b>/<c>')
    @route_with('/[prefix]/[controller]/[action]/<a>/<b>')
    @route_with('/[prefix]/[controller]/[action]/<a>')
    @route_with('/[prefix]/[controller]/[action]')
    def pre_method(self, a=0, b=0, c=0):
        return 'pre_method_' + '/'.join([str(i) for i in (a, b, c)])
    @route
    def urls(self):
        assert self.uri('test_controller:method') == '/test_controller/method'
        assert self.uri('test_controller:method-2', a=1) == '/test_controller/method/1'
        assert self.uri('test_controller:method-3', a=1, b=2) == '/test_controller/method/1/2

        assert self.uri('test_controller:method-4', a=1, b=2, c=3) == '/test_controller/method/1/2/3'
        return 'done'
    @route
    def prefixed_urls(self):
        assert self.uri('pre:test_controller:method') == '/pre/test_controller/method'
        assert self.uri('pre:test_controller:method-2', a=1) == '/pre/test_controller/method/1'
        assert self.uri('pre:test_controller:method-3', a=1, b=2) == '/pre/test_controller/method/1/2'
        assert self.uri('pre:test_controller:method-4', a=1, b=2, c=3) == '/pre/test_controller/method/1/2/3'
        return 'done'
class DefaultArgsTest(AppEngineWebTest):
    def setUp(self):
        super(DefaultArgsTest, self).setUp()
        TestController._build_routes(self.testapp.app.router)
    def test_default_args(self):
        response = self.testapp.get('/test_controller/method')
        self.assertEqual(response.body, 'method_0/0/0')
        response = self.testapp.get('/test_controller/method/1')
        self.assertEqual(respon

        response = self.testapp.get('/test_controller/method/1/2')
        self.assertEqual(response.body, 'method_1/2/0')
        response = self.testapp.get('/test_controller/method/1/2/3')
        self.assertEqual(response.body, 'method_1/2/3')
    def test_prefixed_default_args(self):
        response = self.testapp.get('/pre/test_controller/method')
        self.assertEqual(response.body, 'pre_method_0/0/0')
        response = self.testapp.get('/pre/test_controller/method/1')
        self.assertEqual(response.body, 'pre_method_1/0/0')
        response = self.testapp.get('/pre/test_controller/method/1/2')
        self.assertEqual(response.body, 'pre_method_1/2/0')
        response = self.testapp.get('/pre/test_controller/method/1/2/3')
        self.assertEqual(response.body, 'pre_method_1/2/3')
    def test_stacking_route_uri_building(self):
        response = self.testapp.get('/test_controller/urls')
        self.assertEqual(response.body, 'done')
        response = self.testapp.
class HerdemLevel(object):
    sheep = []
    dogs = []
    threats = []
    map_path = "levels/level0.xml"
    time_limit = 100
    lose_limit = 1
    def __init__(self, controller):
        self.controller = controller
        self.save_target = len(self.sheep)
        return
    def create(self):
        bg = tm.TileMap(self.map_path, self.controller)
        self.controller.scene.add(bg, z = -1)
        for s in self.sheep:
            self.controller.sheeps.append(s)
            self.controller.scene.add(s)
        self.controller.total_sheep = len(self.sheep)
        self.controller.dog = []
        for e, d in enumerate(self.dogs):
            self.controller.dog.append(d)
            self.controller.dog[e].player_number = e
            self.controller.scene.add(d)
        for a in self.threats:
            pass
    def won(self):
        if self.controller.saved_sheeps == self.save_target:
            return True
        return False
    def lost(self):
        if self.controll

            return True
        return False
class Level1(HerdemLevel):
    def __init__(self, controller):
        self.map_path = "levels/level1.tmx"
        self.sheep = [sheep.SheepSprite(controller, pos = (600, 600), image_file = "sheep"),
                      sheep.SheepSprite(controller, pos = (700, 700), image_file = "sheep"),
                      sheep.SheepSprite(controller, pos = (900, 700), image_file = "sheep"),
                     ]
        self.dogs = [dog.DogSprite(controller, pos = (470, 170), image_file = "dog"),]
        super(Level1, self).__init__(controller)
        self.save_target = 3
        self.name = "The Meadow"
        return
class Level2(HerdemLevel):
    def __init__(self, controller):
        self.map_path = "levels/level1.tmx"
        self.sheep = [sheep.SheepSprite(controller, pos = (600, 600), image_file = "sheep"),
                      sheep.SheepSprite(controller, pos = (700, 700), image_file = "sheep"),
                      sheep.SheepSprite
"""
Copyright (c) Microsoft Open Technologies (Shanghai) Co. Ltd.  All rights reserved.
The MIT License (MIT)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF 
__author__ = 'christophe'
class ApplicationGitTests(ApplicationTest):
  def setUp(self):
    ApplicationTest.setUp(self)
    self.startApplication(pluginPackages={
      IAuth: default
    })
  def testSSHPush(self):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(None, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("ssh", self.ssh, remoteRepository.path.split('/')[-1]))
    self.generateComplicatedCommit()
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository, "derp").addCallback(processEnded)
  def testHTTPPush(self):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(None, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("http", self.http, remoteRepository.path.split('/')[-1]))
    self.generateComplicatedCommit()
    def processEnded(res

      self.assertNoError()
      self.assertEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
  def testSSHPull(self):
    self.repository.initialize()
    otherRepository = self.createTemporaryRepository(None, self.repository.path, False)
    self.repository.addRemote("origin", formatRemote("ssh", self.ssh, otherRepository.path.split('/')[-1]))
    self.generateComplicatedCommit(otherRepository)
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, otherRepository)
    self.assertNotEqual(self.repository, otherRepository)
    return self.pullRepository(self.repository).addCallback(processEnded)
  def testHTTPPull(self):
    self.repository.initialize()
    otherRepository = self.createTemporaryRepository(None, self.repository.path, False)
    self.repository.addRemote("origin", formatRemote("http", self.http, otherRepository.path.split('/')[-1]) + "/.git")
    self.generateComp
class RepositoryInternal:
	def __init__(self):
		self.uuid_counter = 0
		self.mappings = {}
class LocalRepository:
	def __init__(self, data = None):
		if data == None:
			data = RepositoryInternal()
		self.data = data
	def uuid(self):
		try:
			return 'u%05d' % self.data.uuid_counter
		finally:
			self.data.uuid_counter += 1
	def lookup(self, uuid):
		assert type(uuid) == str
		return self.data.mappings[uuid]
	def register(self, uuid, v):
		assert type(uuid) == str
		self.data.mappings[uuid] = v
class SharedRepository:
	def __init__(self):
		self.lock = threading.Lock()
		self.data = RepositoryInternal()
	def uuid(self):
		self.lock.acquire()
		try:
			return 'u%05d' % self.data.uuid_counter
		finally:
			self.data.uuid_counter += 1
			self.lock.release()
	def lookup(self, uuid):
		assert type(uuid) == str
		self.lock.acquire()
		try:
			return self.data.mappings[uuid]
		finally:
			self.lock.release()
	def register(self, uuid, v):
		assert type(uuid) == str
		self.lock.acquire()
		try

			self.data.mappings[uuid] = v
		finally:
			self.lock.release()
Repository = SharedRepository
global_repository = Repository()
uuid, lookup, register = global_repository.uuid, global_repository.lookup, global_repository.register
def get_global_repository():
	global global_repository
	return global_repository
def set_global_repository(repository):
	global global_repository
	global uuid, lookup, register 
	old_global_repository = global_repository
	global_repository = repository
	uuid, lookup, register = repository.uuid, repository.lookup, repository.register
	return old_global_repository
def register_object(obj):
	id = uuid()
	register(id, obj)
	return id
class Mixin:
	def __init__(self):
		self.register_self()
	def register_self(self):
		"This method can be called by cloned objects to register themselves as new objects."
		self.uuid = uuid()
		register(self.uuid, self)
	def register_self_in(self, repository):
		"This method can be called by cloned objects to register themselves in a
"""
module handing the event pages
Created: Aug 28, 2013
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class EventsController(BaseController):
  """event controller handling all actions in the event section"""
  def __init__(self, config, session=None):
    BaseController.__init__(self, config, session)
    self.event_broker = self.broker_factory(EventBroker)
    self.relation_controller = RelationController(config, session)
  def get_events(self, offset, limit, user, parameters=None):
    try:
      user = self.user_broker.get_by_id(user.identifier)
      if offset:
        int_off = int(offset) - 1
      if limit:
        int_lim = int(limit)
      isadmin = is_user_priviledged(user)
      if isadmin:
        if offset and limit:
          events = self.event_broker.get_all_limited(int_lim, int_off, parameters)
          nbr_total_events = self.event_broker.get_total_events

        else:
          events = self.event_broker.get_all()
          nbr_total_events = len(events)
        return (events, nbr_total_events)
      else:
        if offset and limit:
          events = self.event_broker.get_all_limited_for_user(int_lim, int_off, user, parameters)
          nbr_total_events = self.event_broker.get_total_events_for_user(user, parameters)
        else:
          events = self.event_broker.get_all_for_user(user)
          nbr_total_events = len(events)
        return (events, nbr_total_events)
    except (BrokerException, ValueError) as error:
      raise ControllerException(error)
  def get_unvalidated_events(self, offset, limit, user, parameters=None):
    try:
      int_lim = int(limit) - 1
      int_off = int(offset) - 1
      events = self.event_broker.get_all_unvalidated(int_lim, int_off, parameters)
      nbr_total_events = self.event_broker.get_all_unvalidated_total(parameters)
      return (events, nbr_total_events)
    except (BrokerException,
def generate_controller(model_name, model_components):
    model_name = model_name.lower()
    db_model_name = model_name.title()
    controller_path = os.path.join(BASEDIR, 'controllers/' + model_name + '.py')
    
    controller_file = open(controller_path,'w')
    controller_file.write(model_name+"_view = Blueprint('"+model_name+"_view', __name__)\n\n")
    controller_file.write("@"+model_name+"_view.route('/" + model_name + "/',methods=['GET','POST'],defaults={'id':None})\n")
    controller_file.write("@"+model_name+"_view.route('/" + model_name + "/<id>',methods=['GET','PUT','DELETE'])\n")
    controller_file.write("def " + model_name + "_controller(id):\n")
    for component in model_components:
        controller_file.write(WHITE_SPACE + component['field_name'].lower() + " = request.values.get('" + component['field_name'].lower() + "')\n")
    controller_file.write("\n"+ WHITE_SPACE +"if id:\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + model_name+" = "+model_name.ti

    controller_file.write(WHITE_SPACE + WHITE_SPACE + "if "+model_name+":\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "if request.method == 'GET':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "if request.values.get('json'):\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return json.dumps(dict("+model_name+"="+model_name+".json))\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE +"return render_template('" + model_name + "_view.html'," + model_name + " = " + model_name + ", title = \"" + model_name.title() + " List\")\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "elif request.method == 'PUT':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + " = edit_parser(" + model_name + ",request)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + W

    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return 'Value Updated', 204\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "elif request.method == 'DELETE':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + ".delete()\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "return 'Item deleted', 204\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "else:\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + WHITE_SPACE +"return 'Method Not Allowed'\n")
    controller_file.write(WHITE_SPACE + "else:\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + "if request.method == 'GET':\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + model_name + "_list = "+model_name.title()+".query().fetch(1000)\n")
    controller_file.write(WHITE_SPACE + WHITE_SPACE + WHITE_SPACE + "entries=None\n")

def main(request):
    """context processor for LFC.
    """
    current_language = translation.get_language()
    default_language = settings.LANGUAGE_CODE
    is_default_language = default_language == current_language
    if current_language == "0" or is_default_language:
        link_language = ""
    else:
        link_language = current_language
    return {
        "PORTAL": lfc.utils.get_portal(),
        "LFC_MULTILANGUAGE": getattr(settings, "LFC_MULTILANGUAGE", True),
        "LFC_MANAGE_WORKFLOWS": getattr(settings, "LFC_MANAGE_WORKFLOWS", True),
        "LFC_MANAGE_APPLICATIONS": getattr(settings, "LFC_MANAGE_APPLICATIONS", True),
        "LFC_MANAGE_COMMENTS": getattr(settings, "LFC_MANAGE_COMMENTS", True),
        "LFC_MANAGE_USERS": getattr(settings, "LFC_MANAGE_USERS", True),
        "LFC_MANAGE_PERMISSIONS": getattr(settings, "LFC_MANAGE_PERMISSIONS", True),
        "LFC_MANAGE_SEO": getattr(settings, "LFC_MANAGE_SEO", True),
        "LFC_MANAGE_UTILS": getattr(setting
app = giga_web
def register_api(view, endpoint, url, pk='id'):
    view_func = view.as_view(endpoint)
    app.add_url_rule(url, defaults={pk: None},
                         view_func=view_func, methods=['GET', ])
    if endpoint == 'project_api':
        app.add_url_rule(url + '<org_perma>/<proj_perma>/', defaults={pk: None},
                         view_func=view_func, methods=['GET'])
    app.add_url_rule(url, view_func=view_func, methods=['POST', ])
    app.add_url_rule('%s<%s>' % (url, pk), view_func=view_func,
                     methods=['GET', 'PUT', 'DELETE'])
register_api(UserAPI, 'user_api', '/users/')
register_api(PledgeAPI, 'pledge_api', '/pledges/')
register_api(ProjectAPI, 'project_api', '/projects/')
register_api(OrganizationAPI, 'organization_api', '/organizations/')
register_api(TransactionAPI, 'transaction_api', '/transactions/')
register_api(MarketingListAPI, 'marketing_list_api', '/marketing_lists/')
register_api(ContactAPI, 'contact_api', '/marketing_lists/<ml_i
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s\t(%(threadName)-10s) %(filename)s:%(lineno)d\t%(message)s')
app = Flask(__name__)
controller = Controller()
@app.route("/")
def hello():
    return render_template('form.html', **build_constants())
@app.route("/<code>")
def move(code):
    logging.debug('processing: %s' % code)
    try:
        c = int(code)
        controller.process(c)
    except ValueError:
        pass
    return render_template('form.html', **build_constants())
def build_constants():
    map = {
        'move_forward': Controller.MOVE_FORWARD,
        'move_backward': Controller.MOVE_BACKWARD,
        'turn_left': Controller.TURN_LEFT,
        'turn_right': Controller.TURN_RIGHT,
        'head_left': Controller.HEAD_LEFT,
        'head_right': controller.HEAD_RIGHT,
        'left_arm_up': Controller.LEFT_ARM_UP,
        'left_arm_down': controller.LEFT_ARM_DOWN,
        'right_arm_up': Controller.RIGHT_ARM_UP,
        'r
try:
except ImportError:
class ZopeVersionHistory(
    VersionHistory.VersionHistory,
    RoleManager,
    OFS.SimpleItem.Item,
    ):
    """The ZopeVersionHistory build on the core VersionHistory class to 
       provide the Zope management interface and other product trappings."""
    security = AccessControl.ClassSecurityInfo()
    security.setDefaultAccess('deny')
    meta_type = 'Version History'
    manage_options=(
        ( {'label': 'Contents',    'action':'manage_main',
           'help': ('ZopeVersionControl', 'VersionHistory-Manage.stx')},
          {'label': 'Properties', 'action':'manage_properties_form',
           'help': ('ZopeVersionControl', 'VersionHistory-Properties.stx')},
        ) +
        RoleManager.manage_options +
        OFS.SimpleItem.Item.manage_options
        )
    icon='misc_/ZopeVersionControl/VersionHistory.gif'
    security.declareProtected('View management screens', 'manage_main')
    manage_main = DTMLFile('dtml/VersionHistoryManageMain', global

    manage_main._setName('manage_main')
    manage = manage_main
    security.declareProtected(
        'View management screens', 'manage_properties_form'
        )
    manage_properties_form = DTMLFile(
        'dtml/VersionHistoryProperties', globals()
        )
    security.declareProtected('Manage repositories', 'manage_edit')
    def manage_edit(self, REQUEST=None):
        """Change object properties."""
        if REQUEST is not None:
            message="Saved changes."
            return self.manage_properties_form(
                self, REQUEST, manage_tabs_message=message
                )
    def __getitem__(self, name):
        activity = self._branches.get(name)
        if activity is not None:
            return activity.__of__(self)
        raise KeyError, name
    security.declarePrivate('objectIds')
    def objectIds(self, spec=None):
        return self._branches.keys()
    security.declarePrivate('objectValues')
    def objectValues(self, spec=None):
        retur
__author__ = 'zhaolei'
reload(sys)
sys.setdefaultencoding('utf8')
logs_information = [
    ['create_network_action','Virtual NetWork Manage','add','user %(user)s %(create_at)s create network','false'],
    ['delete_network_action','Virtual NetWork Manage','del','user %(user)s %(create_at)s delete network','false'],
    ['edit_network_action','Virtual NetWork Manage','edit','user %(user)s %(create_at)s edit network','false'],
    ['create_subnet_action','Virtual NetWork Manage','add','user %(user)s %(create_at)s create subnet','false'],
    ['edit_subnet_action','Virtual NetWork Manage','edit','user %(user)s %(create_at)s edit subnet','false'],
    ['delete_subnet_action','Virtual NetWork Manage','del','user %(user)s %(create_at)s delete subnet','false'],
    ['create_port_action','Virtual NetWork Manage','add','user %(user)s %(create_at)s create port','false'],
    ['edit_port_action','Virtual NetWork Manage','edit','user %(user)s %(create_at)s edit port','false'],
    ['delete_port_ac
'''
AutoSave - Sublime Text Plugin
Provides a convenient way to turn on and turn off
automatically saving the current file after every modification.
'''
settings_filename = "auto_save.sublime-settings"
on_modified_field = "auto_save_on_modified"
delay_field = "auto_save_delay_in_seconds"
class AutoSaveListener(sublime_plugin.EventListener):
  def on_modified(self, view):
    settings = sublime.load_settings(settings_filename)
    delay = settings.get(delay_field)
    '''
    Must use this callback for ST2 compatibility
    '''
    def callback():
      view.run_command("save")
    '''
    If the queue is longer than 1, pop the last item off,
    Otherwise save and reset the queue.
    '''
    def debounce_save():
      if len(AutoSaveListener.save_queue) > 1:
        AutoSaveListener.save_queue.pop()
      else:
        sublime.set_timeout(callback, 0)
        AutoSaveListener.save_queue = []
    if settings.get(on_modified_field) and view.file_name():
class AutoSaveCommand(sublime_plu
logger = Logger(level=logging.INFO)
class SyncControllerSlicePrivileges(OpenStackSyncStep):
    provides=[SlicePrivilege]
    requested_interval=0
    observes=ControllerSlicePrivilege
    def fetch_pending(self, deleted):
        if (deleted):
            return ControllerSlicePrivilege.deleted_objects.all()
        else:
            return ControllerSlicePrivilege.objects.filter(Q(enacted__lt=F('updated')) | Q(enacted=None)) 
    def sync_record(self, controller_slice_privilege):
        logger.info("sync'ing controler_slice_privilege %s at controller %s" % (controller_slice_privilege, controller_slice_privilege.controller))
        if not controller_slice_privilege.controller.admin_user:
            logger.info("controller %r has no admin_user, skipping" % controller_slice_privilege.controller)
            return
	template = os_template_env.get_template('sync_controller_users.yaml')
        roles = [controller_slice_privilege.slice_privilege.role.role]
        if not controller_slic

            raise Exception('Sliceless user %s'%controller_slice_privilege.slice_privilege.user.email)
        else:
            user_fields = {
                       'endpoint':controller_slice_privilege.controller.auth_url,
		       'name': controller_slice_privilege.slice_privilege.user.email,
                       'email': controller_slice_privilege.slice_privilege.user.email,
                       'password': controller_slice_privilege.slice_privilege.user.remote_password,
                       'admin_user': controller_slice_privilege.controller.admin_user,
		       'admin_password': controller_slice_privilege.controller.admin_password,
                       'ansible_tag':'%s@%s@%s'%(controller_slice_privilege.slice_privilege.user.email.replace('@','-at-'),controller_slice_privilege.slice_privilege.slice.name,controller_slice_privilege.controller.name),
		       'admin_tenant': controller_slice_privilege.controller.admin_tenant,
		       'roles':roles,
		       'tenant':cont

	    rendered = template.render(user_fields)
	    expected_length = len(roles) + 1
	    res = run_template('sync_controller_users.yaml', user_fields, path='controller_slice_privileges', expected_num=expected_length)
            controller_slice_privilege.role_id = res[0]['id']
            controller_slice_privilege.save()
    def delete_record(self, controller_slice_privilege):
        if controller_slice_privilege.role_id:
            driver = self.driver.admin_driver(controller=controller_slice_privilege.controller)
            user = ControllerUser.objects.get(
                controller=controller_slice_privilege.controller, 
                user=controller_slice_privilege.slice_privilege.user
            )
            slice = ControllerSlice.objects.get(
                controller=controller_slice_privilege.controller, 
                user=controller_slice_privilege.slice_privilege.user
            )
            driver.delete_user_role(
                user.kuser_id, 
          
"""
Migration script to add the remote_repository_url and homepage_url
columns to the repository table.
"""
log = logging.getLogger( __name__ )
log.setLevel(logging.DEBUG)
handler = logging.StreamHandler( sys.stdout )
format = "%(name)s %(levelname)s %(asctime)s %(message)s"
formatter = logging.Formatter( format )
handler.setFormatter( formatter )
log.addHandler( handler )
metadata = MetaData()
def upgrade( migrate_engine ):
    print __doc__
    metadata.bind = migrate_engine
    metadata.reflect()
    Repository_table = Table( "repository", metadata, autoload=True )
    c_remote = Column( "remote_repository_url", TrimmedString( 255 ) )
    c_homepage = Column( "homepage_url", TrimmedString( 255 ) )
    try:
        c_remote.create( Repository_table )
        c_homepage.create( Repository_table )
        assert c_remote is Repository_table.c.remote_repository_url
        assert c_homepage is Repository_table.c.homepage_url
    except Exception, e:
        print "Adding remote_reposito
urlpatterns = [
    url(r'^$',                              views.home, name='picker-home'),
    url(r'^roster/$',                       views.roster, name='picker-roster'),
    url(r'^roster/(?P<season>20\d\d)/$',    views.roster, name='picker-season-roster'),
    url(r'^roster/p/(\w+)/$',               views.roster_profile, name='picker-roster-profile'),
    url(r'^teams/$',                        views.teams, {'abbr': None}, name='picker-teams'),
    url(r'^teams/(?P<abbr>\w+)/$',          views.teams, name='picker-team'),
    url(r'^schedule/$',                     views.schedule, {'season': None}, name='picker-schedule'),
    url(r'^schedule/(?P<season>\d{4})$',    views.schedule, name='picker-schedule'),
    
    url(r'^results/$',                      views.results, name='picker-results'),
    url(r'^results/(\d{4})/$',              views.results_by_season, name='picker-season-results'),
    url(r'^results/(\d{4})/(-?\d+)/$',      views.results_by_week, name='picker-game-sequenc

    url(r'^results/(\d{4})/playoffs/$',     views.results_for_playoffs, name='picker-playoffs-results'),
    
    url(r'^picks/$',                        views.picks, name='picker-picks'),
    url(r'^picks/(\d{4})/$',                views.picks_by_season, name='picker-season-picks'),
    url(r'^picks/(\d{4})/(-?\d+)/$',        views.picks_by_week, name='picker-picks-sequence'),
    url(r'^picks/(\d{4})/playoffs/$',       views.picks_for_playoffs, name='picker-playoffs-picks'),
    url(r'^picks/history/$',                views.picks_history),
    
    url(r'^manage/$',                       views.management_home, name='picker-manage'),
    url(r'^manage/game/(\d+)/$',            views.manage_game, name='picker-manage-game'),
    url(r'^manage/(\d{4})/$',               views.manage_season),
    url(r'^manage/(\d{4})/(-?\d+)/$',       views.manage_week, name='picker-manage-week'),
    url(r'^manage/(\d{4})/(playoffs)/$',    views.manage_playoffs, name='picker-manage-week'),
    url(r'^ma
"""
Tests for txREST controllers
"""
    MockBaseController, MockController, MockControllerChildOne,
    MockControllerChildTwo, MockControllerSubChildOne,
    MockControllerSubChildTwo
class ControllerTest(unittest.TestCase):
    """ Tests for txrest.controller
    """
    def setUp(self):
        self.c = controller.BaseController()
    def test_class_inherits_twisted_web_resource(self):
        self.assertTrue(
            issubclass(controller.BaseController, resource.Resource)
        )
    def test_parent_is_none_by_default(self):
        self.assertIsNone(self.c.__parent__)
    def test_register_path_returns_empty(self):
        self.assertEqual(self.c.get_path(), '')
class ControllerManagerTest(unittest.TestCase):
    """ Tests for txrest.managers.controllers
    """
    def setUp(self):
        self.mgr = ControlManager()
    def tearDown(self):
        self.mgr._controllers.clear()
    def test_install_controller(self):
        controller = MockController()
        self.mgr.i

        self.assertEqual(len(self.mgr._controllers), 1)
        c = self.mgr._controllers.get(controller.get_path())
        self.assertEqual(c, controller)
    def test_get_controllers_is_list(self):
        self.assertIsInstance(self.mgr.get_controllers(), list)
    def test_get_controllers_is_empty(self):
        self.assertEqual(len(self.mgr.get_controllers()), 0)
    def test_length(self):
        self.assertEqual(len(self.mgr), 0)
    def test_length_after_install(self):
        controller = MockController()
        self.mgr.install_controller(controller)
        self.assertEqual(len(self.mgr), 1)
    def test_get_root_controller(self):
        controller = MockController()
        self.mgr.install_controller(controller)
        base_controller = self.mgr.get_root_controller()
        self.assertIsInstance(base_controller, MockBaseController)
    def test_get_full_path(self):
        controller = MockController()
        self.mgr.install_controller(controller)
        path = sel

        self.assertEqual(path, '/api')
    def test_get_full_path_on_child(self):
        parent = MockController()
        self.mgr.install_controller(parent)
        child = MockControllerChildOne()
        self.mgr.install_controller(child)
        path = self.mgr.get_full_route(parent)
        self.assertEqual(path, '/api')
        path = self.mgr.get_full_route(child)
        self.assertEqual(path, '/api/v1')
    def test_get_full_path_on_multiple_children(self):
        parent = MockController()
        self.mgr.install_controller(parent)
        child1 = MockControllerChildOne()
        self.mgr.install_controller(child1)
        child2 = MockControllerChildTwo()
        self.mgr.install_controller(child2)
        path = self.mgr.get_full_route(parent)
        self.assertEqual(path, '/api')
        path = self.mgr.get_full_route(child1)
        self.assertEqual(path, '/api/v1')
        path = self.mgr.get_full_route(child2)
        self.assertEqual(path, '/api/v2')
    def test
__author__ = 'alirezasadeghi'
vendor_port_number = random.randint(1235, 50000)
BROKER_PORT = 1234
product__ = random.choice(Book, Service, )
def broker_handshake(connection, address, arg):
    print("Initiating the handshake")
    msg = connection.recv(1024)
    print("RECEIVED THIS GUY : ", msg)
def handle_customer_connection(connection, address):
    message = connection.recv(1024)
    print("Okay came here to handle the connection")
def customer_connection_ready(sock, fd, events):
    while True:
        try:
            connection, address = sock.accept()
        except socket.error as e:
            if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):
                raise
            return
        connection.setblocking(0)
        tmp_callback = functools.partial(handle_customer_connection, connection)
        io_loop.add_handler(connection.fileno(), tmp_callback, io_loop.READ)
customer_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
customer_sock.setsockopt(socket
urlpatterns = patterns('clwmail.admin.views',
    (r'user/manage/page/(?P<page_num>\d{1,})/$'            ,'usermanage'),
    (r'user/manage/page/$'                                 ,'usermanage'),
    (r'user/add/$'                                         ,'useradd'),
    (r'user/(?P<userid>.*)/domain/(?P<domain>.*)/edit/$'   ,'useredit'),
    (r'user/(?P<userid>.*)/domain/(?P<domain>.*)/hide/$'   ,'userhide'),
    (r'user/(?P<userid>.*)/domain/(?P<domain>.*)/unhide/$' ,'userunhide'),
    (r'group/manage/$'                                     ,'groupmanage'),
    (r'group/manage/page/(?P<page_num>\d{1,})/$'           ,'groupmanage'),
    (r'group/(?P<alias>.*)/domain/(?P<domain>.*)/edit/$'   ,'groupedit'),
    (r'group/(?P<alias>.*)/domain/(?P<domain>.*)/delete/$' ,'groupdelete'),
    (r'group/add/$'                                        ,'groupadd'),
    (r'domain/(?P<domain_name>.*)/userget/$'               ,'getaliasusers'),
    (r'domain/manage/$'                                   
"""
GarfieltBlog(webpy) is a light weight blog system base on web.py.It is similar 
to WordPress that provides commonly functions and featurs of a blog system.
Homepage and details: http://www.iscsky.net/
Copyright (c) 2012, Garfielt <liuwt123@gmail.com>.
License: MIT (see LICENSE.txt for details)
"""
web.config.debug = Setting.is_debug
urls = (
    '/', 'Index',
    '/page/(\d+)', 'Index',
    '/category/(.+)/page/(\d+)', 'Category',
    '/category/(.+)', 'Category',
    '/tag/(.+)/page/(\d+)', 'Tag',
    '/tag/(.+)', 'Tag',
    '/blog/(.+).html', 'Post',
    '/comment/(\d+)', 'Comment',
    '/search', 'Search',
    '/rss', 'Rss',
    '/sitemap.xml', 'Sitemap',
    '/trans/(.+)/(\d+)', 'Trans',
    '/favicon.ico', 'Favicon',
    '/valiimage', 'Valiimage',
    '/install', 'Install',
    '/install/(\d+)', 'Install',
    Setting.login_url, 'Login',
    '/manage/main/(\w+)', 'Manage',
    '/manage/postlist', 'ManagePostlist',
    '/manage/postlist/(\w+)/(\d+)', 'ManagePostlist',
    '/man

    '/manage/post/(\d+)', 'ManagePost',
    '/manage/category', 'ManageCategory',
    '/manage/category/(\w+)/(\d+)', 'ManageCategory',
    '/manage/tags', 'ManageTags',
    '/manage/tags/edit/(\d+)', 'ManageTags',
    '/manage/data', 'ManageData',
    '/manage/attachment', 'ManageAttachment',
    '/manage/comment/(\w+)/(\d+)', 'ManageComment',
    '/manage/comment', 'ManageComment',
    '/manage/links', 'ManageLinks',
    '/manage/links/(\w+)/(\d+)', 'ManageLinks',
    '/manage/setting', 'ManageSetting',
    '/manage/upload', 'ManageUpload',
    '/manage/files', 'ManageFiles',
    '/manage/user', 'ManageUser',
    '/manage/logout', 'ManageLogout',
    '/manage/result/(.+)', 'ManageResult'
app = web.application(urls, globals())
if Setting.runtime == "SAE":
    application = sae.create_wsgi_app(app.wsgifunc())
elif Setting.runtime == "BAE":
    application = WSGIApplication(app.wsgifunc())
else:
    pass
web.config.session_parameters['cookie_name'] = 'Garfitle_session'
web.config.sessi
def finish():
    print "Shutting down webserver"
    server.shutdown()
    
    print "Shutting down data providers"
    for p in providers:
        p.shutdown()
    
    print "Shutting down message broker"
    broker.shutdown()
    
    print "Shutting external connections"
    for c in connections.keys():
        conn = connections[c]
        conn.shutdown()
    sys.exit(0)
print "Establishing connections..."
connections = {
  'MythTV': MythTVConnection(),
  'StateTable': StateTable()
print "Building message broker..."
broker = MessageBroker()
print "Building channel providers..."
providers = [
  TimeProvider(broker),
  MythRecordingProvider(broker, connections['MythTV']),
  MythUpcomingProvider(broker, connections['MythTV']),
  StateTableProvider(broker, connections['StateTable'])
myScript = sys.argv[0]
myDir = os.path.dirname(myScript)
myIp = '127.0.0.1'
myPort = 1234
if len(sys.argv) > 2:
    myIp = sys.argv[1]
    myPort = int(sys.argv[2])
server = WebServer(myIp, myPort, [
  S

  PushMessageChannel( re.compile('^/channel/longpoll/(.*)$'),             broker),
  RegisterHandler(    re.compile('^/channel/register/(.*)$'),             broker),
  SubscribeHandler(   re.compile(r'^/channel/subscribe/([\w\.]+)/(.*)$'), broker),
  RedirectHandler(    re.compile('^/\w*$'),                               '/static/index.html'),
  InfoHandler(        re.compile('^/info/(.*)$'),                         broker, connections),
  RandomImageHandler( re.compile('^/image/random$'),                      os.path.join(myDir, 'img'), os.path.join(myDir, 'imgDefault')),
  StateTableHandler(  re.compile('^/state/(\w+)/(.*)$'),                  connections['StateTable']),
  RefreshHandler(     re.compile('^/refresh/(.+)'),                       broker),
  DebugChannelHandler(re.compile('^/debug/channel/([\w+\.]+)/(\d)$'),     broker)
])
gevent.signal(signal.SIGTERM, finish)
keepRunning = True
while keepRunning:
    try:
        time.sleep(10)
    except KeyboardInterrupt:
        pri
class TestNSObjectController (TestCase):
    def testMethods(self):
        self.failUnlessResultIsBOOL(NSObjectController.automaticallyPreparesContent)
        self.failUnlessArgIsBOOL(NSObjectController.setAutomaticallyPreparesContent_, 0)
        self.failUnlessResultIsBOOL(NSObjectController.isEditable)
        self.failUnlessArgIsBOOL(NSObjectController.setEditable_, 0)
        self.failUnlessResultIsBOOL(NSObjectController.canAdd)
        self.failUnlessResultIsBOOL(NSObjectController.canRemove)
        self.failUnlessResultIsBOOL(NSObjectController.validateUserInterfaceItem_)
        self.failUnlessResultIsBOOL(NSObjectController.fetchWithRequest_merge_error_)
        self.failUnlessArgIsBOOL(NSObjectController.fetchWithRequest_merge_error_, 1)
        self.failUnlessArgIsOut(NSObjectController.fetchWithRequest_merge_error_, 2)
        self.failUnlessResultIsBOOL(NSObjectController.usesLazyFetching)
        self.failUnlessArgIsBOOL(NSObjectController.setUsesLazyFetching_, 0)
if 
logger = Logger(level=logging.INFO)
class SyncControllerNetworks(OpenStackSyncStep):
    requested_interval = 0
    provides=[Network]
    observes=ControllerNetwork	
    def alloc_subnet(self, uuid):
        uuid_masked = uuid & 0xffff
        a = 10
        b = uuid_masked >> 8
        c = uuid_masked & 0xff
        d = 0
        cidr = '%d.%d.%d.%d/24'%(a,b,c,d)
        return cidr
    def fetch_pending(self, deleted):
        if (deleted):
            return ControllerNetwork.deleted_objects.all()
        else:
            return ControllerNetwork.objects.filter(Q(enacted__lt=F('updated')) | Q(enacted=None))
    def save_controller_network(self, controller_network):
        network_name = controller_network.network.name
        subnet_name = '%s-%d'%(network_name,controller_network.pk)
        cidr = self.alloc_subnet(controller_network.pk)
        network_fields = {'endpoint':controller_network.controller.auth_url,
                    'admin_password':slice.creator.remote_password

                    'name':network_name,
                    'subnet_name':subnet_name,
                    'ansible_tag':'%s-%s@%s'%(network_name,slice.slicename,controller_network.controller.name),
                    'cidr':cidr
                    }
        res = run_template('sync_controller_networks.yaml', network_fields, path = 'controller_networks',expected_num=2)
        network_id = res[0]['id']
        subnet_id = res[1]['id']
        controller_network.net_id = network_id
        controller_network.subnet = cidr
        controller_network.subnet_id = subnet_id
	controller_network.backend_status = '1 - OK'
        controller_network.save()
    def sync_record(self, controller_network):
        logger.info("sync'ing network controller %s for network %s slice %s controller %s" % (controller_network, controller_network.network, str(controller_network.network.owner), controller_network.controller))
        if not controller_network.controller.admin_user:
            logger.info

            return
        if controller_network.network.owner and controller_network.network.owner.creator:
	    self.save_controller_network(controller_network)
	    logger.info("saved network controller: %s" % (controller_network))
    def delete_record(self, controller_network):
        driver = OpenStackDriver().client_driver(caller=controller_network.network.owner.creator,
                                                 tenant=controller_network.network.owner.name,
                                                 controller=controller_network.controller.name)
        if (controller_network.router_id) and (controller_network.subnet_id):
            driver.delete_router_interface(controller_network.router_id, controller_network.subnet_id)
        if controller_network.subnet_id:
            driver.delete_subnet(controller_network.subnet_id)
        if controller_network.router_id:
            driver.delete_router(controller_network.router_id)
        if controller_network.net_id:
urlpatterns = patterns('',
                       url(r'^$', views.day_journal, name='new_day_journal'),
                       url(r'^journals/$', views.all_day_journals, name='all_day_journals'),
                       url(r'^approve/$', views.approve, name='approve_day_journal'),
                       url(r'^(?P<journal_date>\d{4}-\d{2}-\d{2})/$', views.day_journal, name='view_day_journal'),
                       url(r'^save/cash_sales/$', views.save_cash_sales, name='save_cash_sales'),
                       url(r'^save/summary_cash/$', views.save_summary_cash, name='save_summary_cash'),
                       url(r'^save/summary_sales_tax/$', views.save_summary_sales_tax, name='save_summary_sales_tax'),
                       url(r'^save/summary_transfer/$', views.save_summary_transfer, name='save_summary_transfer'),
                       url(r'^save/summary_inventory/$', views.save_summary_inventory, name='save_summary_inventory'),
                       url(r'^save/inventory_

                       url(r'^save/card_sales/$', views.save_card_sales, name='save_card_sales'),
                       url(r'^save/cash_equivalent_sales/$', views.save_cash_equivalent_sales,
                           name='save_cash_equivalent_sales'),
                       url(r'^save/lotto_detail/$', views.save_lotto_detail, name='save_lotto_detail'),
                       url(r'^delete_attachment/$', views.delete_attachment, name='delete_attachment'),
                       url(r'^save_attachments/$', views.save_attachments, name='save_attachments'),
                       url(r'^save_lotto_sales_as_per_dispenser/$', views.save_lotto_sales_as_per_dispenser,
                           name='save_lotto_sales_as_per_dispenser'),
                       url(r'^save/vendor_payout/$', views.save_vendor_payout, name='save_vendor_payout'),
                       url(r'^save/other_payout/$', views.save_other_payout, name='save_other_payout'),
                       url(r'^last_lotto_det
    AbstractSancio, AbstractExpulsio, AbstractIncidencia, AbstractTipusIncidencia, AbstractTipusSancio
    sancio_post_save, sancio_pre_save,\
    sancio_clean
    incidencia_pre_save, Incidencia_pre_delete, incidencia_clean
    expulsio_post_save, expulsio_pre_save, expulsio_clean
class FrassesIncidenciaAula(AbstractFrassesIncidenciaAula):
    pass
class TipusSancio(AbstractTipusSancio):
    def clean(self):
        pass
class Sancio(AbstractSancio):
    def clean(self):
        sancio_clean(self)
class Expulsio(AbstractExpulsio):
    def clean(self):
        expulsio_clean(self)
class TipusIncidencia(AbstractTipusIncidencia):
    def clean(self):
        pass
class Incidencia(AbstractIncidencia):
    def clean(self):
        incidencia_clean(self)
        
pre_delete.connect(Incidencia_pre_delete, sender= Incidencia)
pre_save.connect(incidencia_pre_save, sender = Incidencia )
post_save.connect(Incidencia_post_save, sender = Incidencia )
pre_save.connect(sancio_pre_save, sender = Sanc
class Volare(object):
    def __init__(self, user, password, broker):
        self.user = user
        self.password = password
        if not broker:
            raise ValueError(u"A url do broker é obrigatória.")
        if not broker.startswith("stomp://"):
            raise ValueError(u"A url do broker deve usar 'stomp://'.")
         
        self.host, dummy, strport = broker[8:].rstrip('/').partition(':')
        if len(self.host) == 0 or not strport.isdigit():
            raise ValueError(u"O host e a porta do broker são obrigatórios.")
        self.port = int(strport)
    def connect(self):
        try:
            self._connection = Connection([(self.host, self.port)], self.user, self.password)
            self._connection.start()
            self._connection.connect(wait=True)
        except ConnectFailedException, err:
            raise OfflineBrokerError("Failed to connect to the broker at stomp://%s:%s/" % (self.host, self.port) )
    def assert_is_connected(self):
      
def saveGame(settings, gameEnded):
	canvas = settings["canvas"]
	if not gameEnded():
		if file.exists(settings["saveFile"]):
			if not tkMessageBox.askyesno("Save", "There is already a game saved, would you like to overwrite it?"):
				return
		saveSettings = settings.copy()
		saveSettings["hints"] = None
		saveSettings["canvas"] = None
		saveGrid = []
		saveHints = []
		for row in range(0, settings["guesses"]):
			saveGrid.append([])
			saveHints.append([])
			for col in range(0, settings["pegs"]):
				pegColour = canvas.itemcget(settings["grid"][row][col], "fill")
				hintColour = canvas.itemcget(settings["hints"][row][col], "fill")
				saveGrid[row].append(pegColour)
				saveHints[row].append(hintColour)
		f = open("save.dat", "w")
		saveTuple = (saveSettings, saveGrid, saveHints)
		pickle.dump(saveTuple, f)
		f.close()
		tkMessageBox.showinfo("Save", "Game has been saved.")
	else:
		tkMessageBox.showinfo("Save", "The game has finished, there is no need to save.")
def exists(filenam
@contextmanager
def manage_world():
    world = World((0, 0), True)
    yield world
@contextmanager
def manage_static_body(world, *args, **kwargs):
    body = world.create_static_body(*args, **kwargs)
    yield body
    world.destroy_body(body)
@contextmanager
def manage_kinematic_body(world, *args, **kwargs):
    body = world.create_kinematic_body(*args, **kwargs)
    yield body
    world.destroy_body(body)
@contextmanager
def manage_dynamic_body(world, *args, **kwargs):
    body = world.create_dynamic_body(*args, **kwargs)
    yield body
    world.destroy_body(body)
@contextmanager
def manage_circle_fixture(body, *args, **kwargs):
    fixture = body.create_circle_fixture(*args, **kwargs)
    yield fixture
    body.destroy_fixture(fixture)
@contextmanager
def manage_edge_fixture(body, *args, **kwargs):
    fixture = body.create_edge_fixture(*args, **kwargs)
    yield fixture
    body.destroy_fixture(fixture)
@contextmanager
def manage_polygon_fixture(body, *args, **kwargs):
    fixtur

    yield fixture
    body.destroy_fixture(fixture)
@contextmanager
def manage_loop_fixture(body, *args, **kwargs):
    vertex_array = VertexArray()
    fixture = body.create_loop_fixture(vertex_array, *args, **kwargs)
    yield fixture
    body.destroy_fixture(fixture)
@contextmanager
def manage_revolute_joint(world, *args, **kwargs):
    revolute_joint = world.create_revolute_joint(*args, **kwargs)
    yield revolute_joint
    world.destroy_joint(revolute_joint)
@contextmanager
def manage_prismatic_joint(world, *args, **kwargs):
    prismatic_joint = world.create_prismatic_joint(*args, **kwargs)
    yield prismatic_joint
    world.destroy_joint(prismatic_joint)
@contextmanager
def manage_distance_joint(world, *args, **kwargs):
    distance_joint = world.create_distance_joint(*args, **kwargs)
    yield distance_joint
    world.destroy_joint(distance_joint)
def test_exercise():
    with manage_world() as world:
        with manage_dynamic_body(world) as body:
            with manage_c

                pass
            with manage_edge_fixture(body) as fixture:
                pass
            with manage_polygon_fixture(body) as fixture:
                pass
            with manage_loop_fixture(body) as fixture:
                pass
def test_create_revolute_joint():
    with manage_world() as world:
        with manage_static_body(world) as body_a:
            with manage_dynamic_body(world) as body_b:
                with manage_revolute_joint(world, body_a, body_b, (0, 0)) as revolute_joint:
                    pass
def test_create_prismatic_joint():
    with manage_world() as world:
        with manage_static_body(world) as body_a:
            with manage_dynamic_body(world) as body_b:
                with manage_prismatic_joint(world, body_a, body_b, (0, 0), (0, 0)) as prismatic_joint:
                    pass
def test_create_distance_joint():
    with manage_world() as world:
        with manage_static_body(world) as body_a:
            with manage_dynamic_body
class CeleryCommand(BaseCommand):
    options = BaseCommand.option_list
    skip_opts = ["--app", "--loader", "--config"]
    def get_version(self):
        return "celery %s\ndjango-celery %s" % (celery.__version__,
                                                djcelery.__version__)
    def execute(self, *args, **options):
        broker = options.get("broker")
        if broker:
            self.set_broker(broker)
        super(CeleryCommand, self).execute(*args, **options)
    def set_broker(self, broker):
        settings.BROKER_HOST = broker
    def handle_default_options(self, argv):
        acc = []
        broker = None
        for i, arg in enumerate(argv):
            if "--settings=" in arg:
                _, settings_module = arg.split("=")
                os.environ["DJANGO_SETTINGS_MODULE"] = settings_module
            elif "--pythonpath=" in arg:
                _, pythonpath = arg.split("=")
                sys.path.insert(0, pythonpath)
            elif "--broker="
manage_add_oauth_form = PageTemplateFile('browser/add_plugin' , globals(), __name__='manage_add_oauth_form')
def manage_add_oauth_plugin_base( dispatcher, id, title=None, REQUEST=None ):
    """Add an oauth plugin base to the PluggableAuthentication Service."""
    sp = plugin.OauthPluginBase( id, title )
    dispatcher._setObject( sp.getId(), sp )
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect( '%s/manage_workspace'
                                      '?manage_tabs_message='
                                      'OauthPluginBase+added.'
                                      % dispatcher.absolute_url() )
def register_oauth_plugin():
    try:
        registerMultiPlugin(plugin.OauthPluginBase.meta_type)
    except RuntimeError:
        pass
def register_oauth_plugin_class(context):
    context.registerClass(plugin.OauthPluginBase,
                          permission = manage_users,
                          constructors = (manage_add_oauth_form,
                    
def setRoutes(root):
    cherrypy.checker.check_static_paths = None 
    d = cherrypy.dispatch.RoutesDispatcher()
    
    m = d.mapper
    m.explicit = True
    m.minimization = False
    
    d.connect('newProject-1',   '/new/:lang', controller=root, action='newProject')
    d.connect('newProject-2',   '/new', controller=root, action='newProject')
    
    d.connect('deleteFile',     '/deleteFile', controller=root, action='deleteFile')
    d.connect('addFile',        '/addFile', controller=root, action='addFile')
    d.connect('saveTicket',     '/saveTicket', controller=root, action='saveTicket')
    d.connect('deleteTicket',   '/deleteTicket', controller=root, action='deleteTicket')
    d.connect('editTicket',     '/editTicket',   controller=root, action='editTicket')
    d.connect('saveComment',    '/saveComment', controller=root, action='saveComment')
    d.connect('getTicketsList', '/getTicketsList', controller=root, action='getTicketsList')
    d.connect('getCommentsList','/getC

    d.connect('setSort',        '/setSort', controller=root, action='setSort')
    d.connect('editTicketForm', '/editTicketForm', controller=root, action='editTicketForm')
    d.connect('doLogin',        '/doLogin', controller=root, action='doLogin')
    d.connect('deleteUser',     '/deleteUser', controller=root, action='deleteUser')
    d.connect('acceptUser',     '/acceptUser', controller=root, action='acceptUser')
    d.connect('updateUserLevel','/updateUserLevel', controller=root, action='updateUserLevel')
    d.connect('sendInvitations','/sendInvitations', controller=root, action='sendInvitations')
    d.connect('updateEMail',    '/updateEMail', controller=root, action='updateEMail')
    d.connect('updatePwd',      '/updatePwd', controller=root, action='updatePwd')
    d.connect('createProject',   '/createProject', controller=root, action='createProject')
    d.connect('doRegister',   '/doRegister', controller=root, action='doRegister')
    d.connect('doLostPassword',   '/doLostP

    
    d.connect('raiseError',     '/raiseError', controller=root, action='raiseError')
    d.connect('disconnect',     '/:project/disconnect', controller=root, action='disconnect')
    
    d.connect('file',          '/:project/file/:id', controller=root, action='files')
    
    
    d.connect('manageUsers',    '/:project/users', controller=root, action='users')
    d.connect('newTicket',      '/:project/:category/new', controller=root, action='newTicket')
    d.connect('profile',        '/:project/profile', controller=root, action='profile')
    d.connect('search-1',       '/:project/search/:search', controller=root, action='search')
    d.connect('search-2',       '/:project/search', controller=root, action='search')
    d.connect('register',       '/:project/register', controller=root, action='register')
    d.connect('lostPassword',   '/:project/lostPassword',                   controller=root, action='lostPassword')
    
    d.connect('logMeIn-3',      '/:project/login',     
class ConfigurationRepository(ConfigurationRepositoryBase, ConfigurationRepositoryActions):
    '''
    classdocs
    '''
    def __init__(self, repositoryProperty=list(), artifactPath=list(), repositoryType=None, artifact=list(), repositoryPath=None, readOnly=False, syncIntervalSeconds=None, artifactType=None):
        '''
        Constructor
        @param repositoryProperty: repositoryProperty minOccurs=0 maxOccurs=unbounded
        @type repositoryProperty: Property
        @param artifactPath: artifactPath minOccurs=0 maxOccurs=unbounded
        @type artifactPath: string
        @param repositoryType: repositoryType minOccurs=0
        @type repositoryType: string
        @param artifact: artifact minOccurs=0 maxOccurs=unbounded
        @type artifact: Link
        @param repositoryPath: repositoryPath minOccurs=0
        @type repositoryPath: string
        @param readOnly: readOnly
        @type readOnly: boolean
        @param syncIntervalSeconds: syncIntervalSeconds minOccurs
try:
except ImportError:
    multiprocessing = None
starting_queue = None
stopping_queue = None
def make_broker(manager, worker_model, start_queue=None, stop_queue=None):
    global starting_queue
    global stopping_queue
    starting_queue = start_queue
    stopping_queue = stop_queue
    options = get_options(worker_model)
    return manager_worker_broker.get(port.get("test"), options, manager, _TestWorker)
class _TestWorker(manager_worker_broker.AbstractWorker):
    def __init__(self, broker_connection, worker_number, options):
        self._broker_connection = broker_connection
        self._options = options
        self._worker_number = worker_number
        self._name = 'TestWorker/%d' % worker_number
        self._stopped = False
        self._canceled = False
        self._starting_queue = starting_queue
        self._stopping_queue = stopping_queue
    def handle_stop(self, src):
        self._stopped = True
    def handle_test(self, src, an_int, a_str):
        assert an_in

        assert a_str == "hello, world"
        self._broker_connection.post_message('test', 2, 'hi, everybody')
    def is_done(self):
        return self._stopped or self._canceled
    def name(self):
        return self._name
    def cancel(self):
        self._canceled = True
    def run(self, port):
        if self._starting_queue:
            self._starting_queue.put('')
        if self._stopping_queue:
            self._stopping_queue.get()
        try:
            self._broker_connection.run_message_loop()
            self._broker_connection.yield_to_broker()
            self._broker_connection.post_message('done')
        except Exception, e:
            self._broker_connection.post_message('exception', (type(e), str(e), None))
def get_options(worker_model):
    option_list = manager_worker_broker.runtime_options()
    parser = optparse.OptionParser(option_list=option_list)
    options, args = parser.parse_args(args=['--worker-model', worker_model])
    return options
class Fu

    def test_get__inline(self):
        self.assertTrue(make_broker(self, 'inline') is not None)
    def test_get__threads(self):
        self.assertTrue(make_broker(self, 'threads') is not None)
    def test_get__processes(self):
        if sys.platform in ('cygwin', 'win32'):
            return
        if multiprocessing:
            self.assertTrue(make_broker(self, 'processes') is not None)
        else:
            self.assertRaises(ValueError, make_broker, self, 'processes')
    def test_get__unknown(self):
        self.assertRaises(ValueError, make_broker, self, 'unknown')
class _TestsMixin(object):
    """Mixin class that implements a series of tests to enforce the
    contract all implementations must follow."""
    def name(self):
        return 'Tester'
    def is_done(self):
        return self._done
    def handle_done(self, src):
        self._done = True
    def handle_test(self, src, an_int, a_str):
        self._an_int = an_int
        self._a_str = a_str
    def hand
this_module = sys.modules[ __name__ ]
tools = (CMFOpenflowTool,)
z_tool_bases = utils.initializeBasesPhase1(tools, this_module)
cmfopenflow_globals = globals()
registerDirectory( 'skins', globals() )
registerDirectory( 'skins/zpt_cmfopenflow', globals() )
def initialize(context):
    utils.initializeBasesPhase2(z_tool_bases, context)
    utils.ToolInit( 'CMF OpenFlow Tool',
                    tools = tools,
                    icon='images/Openflow.png'
                    ).initialize( context )
    context.registerClass(CMFOpenflowTool,
                          meta_type="Openflow (Reflab)",
                          constructors=(manage_addOpenflowForm, manage_addOpenflow),
                          icon='images/Openflow.png')
    context.registerClass(process,
                          constructors=(manage_addProcessForm, manage_addProcess),
                          icon='images/Process.png')
    context.registerClass(instance,
                          constructors=(manage_addI
"""Modulo principal que inicializa el Gestor Académico
"""
__author__ = 'Gregorio y Ángel'
def main():
    """
    1 - Crea un contenedor de las vistas y añade las intancias de éstas.\n
    2 - Inicializa los controladores de las entidades del proyecto.\n
    3 - Asigna los controladores anteriormente inicializados a cada vista del contenedor, y posteriormente la lanza
    """
    terminales = list()
    terminales.append(Terminal())
    alumno_controller = AlumnoController(terminales)
    asignatura_controller = AsignaturaController(terminales)
    centro_controller = CentroController(terminales)
    grado_controller = GradoController(terminales)
    sesion_controller = SesionController(terminales)
    for terminal in terminales:
        terminal.set_alumno_controller(alumno_controller)
        terminal.set_asignatura_controller(asignatura_controller)
        terminal.set_centro_controller(centro_controller)
        terminal.set_grado_controller(grado_controller)
        terminal.set_
app = Flask(__name__)
port=2000
def getProviders_f(broker_url, scope, entity):
    target_url = broker_url+"/getProviders"
    r = requests.get(target_url, params={'scope': scope, 'entity': entity})
    return r.content
def subscribe_f(broker_url, entity, scope_list, url, time):
    target_url = broker_url+"/subscribe"
    entity_a = entity.split('|')
    subscribe_tuple = {'entity': entity_a[1], 'type': entity_a[0], 'scopeList': scope_list, 'callbackUrl': url, 'time': time}
    r = requests.get(target_url, params=subscribe_tuple)
    return r.content
def getContext_f(broker_url, entities, scope_list):
    target_url = broker_url+"/getContext"
    getcontext_tuple = {'scopeList': scope_list, 'entities': entities}
    r = requests.get(target_url, params=getcontext_tuple)
    return r.content
@app.route('/getProviders')
def getProviders():
    broker_url = request.args.get('broker_url')
    scope= request.args.get('scope')
    entity= request.args.get('entity')
    result = getProviders_

    return result
@app.route('/subscribe')
def subscribe():
    broker_url = request.args.get('broker_url')
    entity = request.args.get('entity')
    scope_list = request.args.get('scope_list')
    url = request.args.get('url')
    time = request.args.get('time')
    result = subscribe_f(broker_url, entity, scope_list, url, time)
    return result
@app.route('/getContext')
def getContext():
    broker_url = request.args.get('broker_url')
    entity = request.args.get('entity')
    scope_list = request.args.get('scope_list')
    result = getContext_f(broker_url, entity, scope_list)
    return result
@app.route('/')
def index():
    getp_entity=''
    getp_scope='test5'
    subs_entity='username|anderson'
    subs_scopes='test2,scope2'
    subs_url= 'http://localhost:'+str(port)
    subs_time= '30'
    getc_entities='username|anderson'
    getc_scopes='test2'
    return render_template("index.html", broker_url="http://localhost:5000",
                           getp_entity=getp_entity
"""
Tests for cue broker object.
"""
class BrokerObjectsTests(base.FunctionalTestCase):
    dbapi = db_api.get_instance()
    def create_object_broker(self, **kw):
        """Create a broker object."""
        test_broker_dict = func_utils.get_test_broker_dict(**kw)
        new_broker = objects.Broker(**test_broker_dict)
        self.validate_broker_values(test_broker_dict, new_broker)
        new_broker.create_broker(self.context)
        broker_query = sqlalchemy_api.model_query(
            self.context, models.Broker).filter_by(id=test_broker_dict['id'])
        db_broker = broker_query.one()
        broker_obj = objects.Broker._from_db_object(objects.Broker(),
                                                    db_broker)
        return broker_obj
    def validate_broker_values(self, broker_ref, broker_cmp):
        """Validate Broker Object fields."""
        self.assertEqual(broker_ref.id if hasattr(broker_ref, "id") else
                         broker_ref["id"],
              

                         broker_cmp["id"],
                         "Invalid broker id value")
        self.assertEqual(broker_ref.name if hasattr(broker_ref, "name")
                         else broker_ref["name"],
                         broker_cmp.name if hasattr(broker_cmp, "name")
                         else broker_cmp["name"],
                         "Invalid name value")
        self.assertEqual(broker_ref.active if hasattr(broker_ref,
                         "active") else broker_ref["active"],
                         broker_cmp.active if hasattr(broker_cmp,
                         "active") else broker_cmp["active"],
                         "Invalid active status")
        self.assertTrue(test_utils.compare_dates(broker_ref["created_at"],
                                                 broker_cmp["created_at"]),
                        "Invalid created_at value")
        self.assertTrue(test_utils.compare_dates(broker_ref["updated_at"],
                             

                        "Invalid updated_at value")
        self.assertTrue(test_utils.compare_dates(broker_ref["deleted_at"],
                                                 broker_cmp["deleted_at"]),
                        "Invalid deleted_at value")
    def test_broker_object_generation(self):
        """Test Broker Object generation from a broker dictionary object."""
        broker_dict = func_utils.get_test_broker_dict()
        broker_object = objects.Broker(**broker_dict)
        self.validate_broker_values(broker_dict, broker_object)
    def test_broker_db_to_object_to_db(self):
        """Tests Broker db object conversion to Broker object and back
        to db object.
        """
        broker_dict = func_utils.get_test_broker_dict()
        db_broker_object = models.Broker()
        db_broker_object.update(broker_dict)
        object_broker = objects.Broker._from_db_object(objects.Broker(),
                                                       db_broker_object)
       
urlpatterns = patterns('plugins.filebrowser.views',
    url(r'^$', 'repositories', name='filebrowser_repositories'),
    url(r'^(?P<repository_name>[\w-]+)/$', 'root', name='filebrowser_root'),
    url({'en': r'^(?P<repository_name>[\w-]+)/listing/$',
         'es': r'^(?P<repository_name>[\w-]+)/listado/$'},
         'listing', name='filebrowser_root_listing'),
    url({'en': r'^(?P<repository_name>[\w-]+)/listing/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/listado/(?P<path>.*)$'},
         'listing', name="filebrowser_dir_listing"),
    url({'en': r'^(?P<repository_name>[\w-]+)/download/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/descargar/(?P<path>.*)$'},
         'download', name='filebrowser_download'),
    url({'en': r'^(?P<repository_name>[\w-]+)/upload/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/subir/(?P<path>.*)$'},
         'upload', name='filebrowser_upload'),
    url({'en': r'^(?P<repository_name>[\w-]+)/create/folder/(

         'es': r'^(?P<repository_name>[\w-]+)/crear/carpeta/(?P<path>.*)$'},
         'createdir', name='filebrowser_createdir'),
    url({'en': r'^(?P<repository_name>[\w-]+)/action/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/accion/(?P<path>.*)$'},
         'action', name='filebrowser_action'),
    url({'en': r'^search/files/$',
         'es': r'^buscar/ficheros/$'},
         'search', name='filebrowser_search'),
    url({'en': r'^(?P<repository_name>[\w-]+)/create/document/(?P<path>.*)$',
         'es': r'^(?P<repository_name>[\w-]+)/crear/documento/(?P<path>.*)$'},
         'createdoc', name='filebrowser_createdoc'),
    url({'en': ur'^(?P<repository_name>[\w-]+)/view/document/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$',
         'es': ur'^(?P<repository_name>[\w-]+)/ver/documento/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$'},
         'viewdoc', name='filebrowser_viewdoc'),
    url({'en': ur'^(?P<repository_name>[\w-]+)/edit/document/(?P<doc_slug>[-ÑñáéíóúÁÉÍÓÚ\w]+)/$',
        
v1_api = Api(api_name="v1")
v1_api.register(CentroResource())
v1_api.register(ClienteResource())
v1_api.register(CompraResource())
v1_api.register(ContactoResource())
v1_api.register(CotizacionResource())
v1_api.register(EquipoResource())
v1_api.register(FamiliaResource())
v1_api.register(HistorialResource())
v1_api.register(LugarResource())
v1_api.register(ProductoResource())
v1_api.register(NombreProductoResource())
v1_api.register(FotoProductoResource())
v1_api.register(UnidadProductoResource())
v1_api.register(PrecioMesProductoResource())
v1_api.register(ProveedorResource())
v1_api.register(SolicitudResource())
v1_api.register(ProductoSolicitudResource())
v1_api.register(TipoEquipoResource())
v1_api.register(UsuarioResource())
v1_api.register(ConsolidadorSolicitanteResource())
v1_api.register(SolicitanteCodificadorResource())
v1_api.register(AprobadorSolicitudesSolicitanteResource())
v1_api.register(AprobadorSolicitudesCompradorResource())
v1_api.register(CompradorAprobadorComprasR
class ExecuteWorkflowCommand(LaunchWorkflowCommandBase):
    injector_modules = [
            BrokerConfiguration,
            RedisConfiguration,
            ServiceLocatorConfiguration,
    ]
    local_workflow = True
    def setup_services(self, net):
        self.setup_shell_command_handlers()
        self.setup_orchestrator_handlers()
        self.setup_historian_handler()
        self.setup_completion_handler(net)
    def setup_shell_command_handlers(self):
        self.broker.register_handler(
                self.injector.get(ForkShellCommandMessageHandler))
    def setup_orchestrator_handlers(self):
        self.broker.register_handler(
                self.injector.get(PetriCreateTokenHandler))
        self.broker.register_handler(
                self.injector.get(PetriNotifyPlaceHandler))
        self.broker.register_handler(
                self.injector.get(PetriNotifyTransitionHandler))
    def setup_historian_handler(self):
        self.broker.register_handler(
        
"""
All button and tab command objects.
Each object has a 'do' method that takes no parameters. Any necessary parameter
should be passed in upon initialization.
"""
class ControllerCommand(object):
    """ base class for commands on controller """
    
    def __init__(self, controller):
        self.controller = controller
        
    def do(self):
        pass
        
class LeftCommand(ControllerCommand):
    def do(self):
        self.controller.jog_left()
class RightCommand(ControllerCommand):
    def do(self):
        self.controller.jog_right()
        
class TowardCommand(ControllerCommand):
    def do(self):
        self.controller.jog_toward()
        
class AwayCommand(ControllerCommand):
    def do(self):
        self.controller.jog_away()
        
class GoCommand(ControllerCommand):
    def do(self):
        self.controller.mill_board()
class PauseCommand(ControllerCommand):
    def do(self):
        self.controller.pause_board()
class ResetCommand(ControllerCommand):
   
def repositoryWithPath (path):
	try:
		repo = hgapi.Repo(path)
		result = HgRepository(repo, path)
		repo.hg_status()
	except:
		try:
			repo = Repo(path)
			result = GitRepository(repo, path)
		except ImportError, exception:
			print "Use sudo apt-get install python-git for Ubuntu/Debian"
			print "Use sudo yum install GitPython for Fedora/RHEL/CentOS"
			print "Or manually running the following command: easy_install gitpython"
		except:
			result = SnapshotRepository('', path)
	return result
class Repository(object):
	def __init__ (self, repository, path):
		self.repository = repository
		self.path = path
	def revision (self):
		raise NotImplementedError()
	def areTherePendingChanges (self):
		raise NotImplementedError()
	def version (self):
		result = self.revision()
		if self.areTherePendingChanges():
			result = '>>> ' + result + ' <<<'
		return result
class GitRepository(Repository):
	def revision (self):
		try:
			return self.repository.head.commit.hexsha
		except:
			return sel
'''
Represents a GitHub repository
@since 1.0
@author Oskar Jarczyk
'''
class MyRepository():
    element_type = 'Team'
    key = None
    def __init__(self):
        self.data = []
    repository_branches = None
    repository_commits = None
    repository_contributors = None
    repository_created_at = None
    repository_description = None
    repository_fork = None
    repository_forks = None
    repository_forks_count = None
    repository_has_downloads = None
    repository_has_issues = None
    repository_has_wiki = None
    repository_homepage = None
    repository_integrate_branch = None
    repository_issues = None
    repository_labels = None
    repository_language = None
    repository_master_branch = None
    repository_name = None
    repository_open_issues = None
    repository_organization = None
    repository_owner = None
    repository_private = None
    repository_pulls = None
    repository_pushed_at = None
    repository_size = None
    repository_stargazers = No

    repository_subscribers = None
    repository_watchers = None
    repository_url = None
    repo_object = None
    def setRepoObject(self, repoobject):
        self.repo_object = repoobject
    def getRepoObject(self):
        return self.repo_object
    def setKey(self, key):
        self.key = key
    def getKey(self):
        return self.key
    def purge(self):
        'TO DO: implement this method'
    'basicly first init of data transcripted from input (csvs)'
    'name with owner, and count of forks and watchers'
    def setInitials(self, name, owner):
        self.repository_name = name
        self.repository_owner = owner
    def setName(self, name):
        self.repository_name = name
    def getName(self):
        return self.repository_name
    def setOwner(self, owner):
        self.repository_owner = owner
    def getOwner(self):
        return self.repository_owner
    def setForks(self, forks):
        self.repository_forks = forks
    def setCommits(self, commits)

        self.repository_commits = commits
    def getCommits(self):
        return self.repository_commits
    def getCommitsCount(self):
        return (len(self.repository_commits) if self.repository_commits is not None else 0)
    def getForks(self):
        return self.repository_forks
    def getForksCount(self):
        return self.repository_forks_count
    def setWatchers(self, watchers):
        self.repository_watchers = watchers
    def getWatchers(self):
        return self.repository_watchers
    def getWatchersCount(self):
        return self.repository_watchers_count
    def setContributors(self, contributors):
        self.repository_contributors = contributors
    def getContributors(self):
        return self.repository_contributors
    def getContributorsCount(self):
        return (len(self.repository_contributors) if self.repository_contributors is not None else 0)
    def setSubscribers(self, subscribers):
        self.repository_subscribers = subscribers
    def
    ManageDeadlinesView, CreateProgram, ManageUsers, LoginAsUser, ManageEmailTemplates, ManageConference, ManageEmailQueue, ManageActiveConference
urlpatterns = patterns('',
                       url(r'^$', ManageIncludedSubmissionsView.as_view(), name="manage_included"),
                       url(r'^reviewers/$', ManageAssignedReviewersView.as_view(), name="manage_reviewers"),
                       url(r'^add-reviewer/$', ManageAddReviewerView.as_view(), name="manage_add_reviewer"),
                       url(r'^papers/$', ManagePapersView.as_view(), name="manage_papers"),
                       url(r'^deadlines/$', ManageDeadlinesView.as_view(), name="manage_deadlines"),
                       url(r'^create-program/$', CreateProgram.as_view(), name="manage_program"),
                       url(r'^users/$', ManageUsers.as_view(), name="manage_users"),
                       url(r'^emails/$', ManageEmailTemplates.as_view(), name="manage_emails"),
                       url(r'^email-
class MyTestCase(unittest.TestCase):
    def setUp(self):
        self.broker = ZmqBroker()
        self.broker.start()
        self.workers = []
    def tearDown(self):
        for worker in self.workers:
            worker.quit()
            worker.join()
        self.broker.quit()
        self.broker.join()
    def test_1_message_1_worker(self):
        worker = ZmqWorker()
        worker.start()
        self.workers.append(worker)
        self.broker.put_on_queue('Hello')
        while not len(worker.finished) > 0:
            time.sleep(.1)
        self.assertEqual('Hello', worker.finished[0].decode())
    def test_1_message_2_workers(self):
        worker1 = ZmqWorker()
        worker2 = ZmqWorker()
        worker1.start()
        worker2.start()
        self.workers.append(worker1)
        self.workers.append(worker2)
        self.broker.put_on_queue('Hello')
        while not len(worker1.finished) + len(worker2.finished) == 1:
            time.sleep(.1)
        finished_work = 

        self.assertTrue('Hello' in finished_work)
    def test_5_messages_1_worker(self):
        worker = ZmqWorker()
        worker.start()
        self.workers.append(worker)
        self.broker.put_on_queue('Hello1')
        self.broker.put_on_queue('Hello2')
        self.broker.put_on_queue('Hello3')
        self.broker.put_on_queue('Hello4')
        self.broker.put_on_queue('Hello5')
        while not len(worker.finished) == 5:
            time.sleep(.1)
        self.assertTrue('Hello1' in worker.finished)
        self.assertTrue('Hello2' in worker.finished)
        self.assertTrue('Hello3' in worker.finished)
        self.assertTrue('Hello4' in worker.finished)
        self.assertTrue('Hello5' in worker.finished)
    def test_5_messages_2_workers(self):
        worker1 = ZmqWorker()
        worker2 = ZmqWorker()
        worker1.start()
        worker2.start()
        self.workers.append(worker1)
        self.workers.append(worker2)
        self.broker.put_on_queue('Hello1')
   
__all__ = (
    invoicebase_saved.__all__ +
    invoicebase_changed_state.__all__ +
    make_purchase_order.__all__ +
    make_invoice.__all__ +
    invoice_cancelled.__all__
"""
SIGNALS
"""
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_quotation, sender=QuotationSaved)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_quotation, sender=QuotationChangedState)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_quotation, sender=QuotationMakePurchaseOrder)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_quotation, sender=QuotationMakeInvoice)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_quotation, sender=QuotationMakeDownPaymentInvoice)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_purchase_order, sender=PurchaseOrderSaved)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_purchase_order, sender=PurchaseOrderChangedState)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_purchase_order, sender=PurchaseOrderMakeInvoice)

signals.pre_save.connect(InvoicingTimelineEntry.pre_save_purchase_order, sender=PurchaseOrderMakeDownPaymentInvoice)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_invoice, sender=InvoiceSaved)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_invoice, sender=InvoiceChangedState)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_invoice, sender=InvoiceCancelled)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_down_payment_invoice, sender=DownPaymentInvoiceSaved)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_down_payment_invoice, sender=DownPaymentInvoiceChangedState)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_down_payment_invoice, sender=DownPaymentInvoiceCancelled)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_credit_note, sender=CreditNoteSaved)
signals.pre_save.connect(InvoicingTimelineEntry.pre_save_credit_note, sender=CreditNoteChangedState)
signals.post_save.connect(TimelineEntry.post_save, sender=QuotationSave

signals.post_save.connect(TimelineEntry.post_save, sender=QuotationChangedState)
signals.post_save.connect(TimelineEntry.post_save, sender=QuotationMakeInvoice)
signals.post_save.connect(TimelineEntry.post_save, sender=QuotationMakeDownPaymentInvoice)
signals.post_save.connect(TimelineEntry.post_save, sender=PurchaseOrderSaved)
signals.post_save.connect(TimelineEntry.post_save, sender=PurchaseOrderChangedState)
signals.post_save.connect(TimelineEntry.post_save, sender=PurchaseOrderMakeInvoice)
signals.post_save.connect(TimelineEntry.post_save, sender=PurchaseOrderMakeDownPaymentInvoice)
signals.post_save.connect(TimelineEntry.post_save, sender=InvoiceSaved)
signals.post_save.connect(TimelineEntry.post_save, sender=InvoiceChangedState)
signals.post_save.connect(TimelineEntry.post_save, sender=InvoiceCancelled)
signals.post_save.connect(TimelineEntry.post_save, sender=DownPaymentInvoiceSaved)
signals.post_save.connect(TimelineEntry.post_save, sender=DownPaymentInvoiceChangedState)
signa
LOG = logging.getLogger(__name__)
config = setup_app('planner')
BROKER_URL = config.broker
if "amqp" in config.broker:
    default_exchange = Exchange('default')
    monitor_exchange = Exchange('monitor', type='fanout')
    reactor_exchange = Exchange('reactor', type='fanout')
    planner_exchange = Exchange('planner', type='fanout')
    CELERY_RESULT_BACKEND = "amqp"
    CELERY_QUEUES = (
        Queue('default', default_exchange, routing_key='default'),
    )
elif "redis" in config.broker:
    CARROT_BACKEND = "redis"
    CELERY_RESULT_BACKEND = BROKER_URL
    CELERY_QUEUES = {
        "default": {"default": "default"},
    }
CELERY_RESULT_EXCHANGE = 'results'
CELERY_RESULT_EXCHANGE_TYPE = 'fanout'
CELERY_TASK_RESULT_EXPIRES = 300
CELERY_IMPORTS = (
    "planner.tasks",
CELERY_ACCEPT_CONTENT = ['json', 'msgpack', 'yaml', 'application/x-python-serialize',]
CELERY_DEFAULT_QUEUE = 'default'
CELERY_DEFAULT_EXCHANGE = 'default'
CELERY_DEFAULT_EXCHANGE_TYPE = 'topic'
CELERY_DEFAULT_ROUTING
column_repository_name = 'column_maker_1087'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_1087'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 1087 Advanced Circular Dependencies'
category_description = 'Test circular dependency features'
class TestRepositoryDependencies( ShedTwillTestCase ):
    '''Test installing a repository, then updating it to include repository dependencies.'''
    def test_0000_create_or_login_admin_user( self ):
        """Create necessary user accounts and login as an admin user."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = self.test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with e

        galaxy_admin_user_private_role = self.test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = self.test_db_util.get_private_role( admin_user )
  
    def test_0005_create_and_populate_column_repository( self ):
        """Create a category for this test suite and add repositories to 

        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=column_repository_name, 
                                                    description=column_repository_description, 
                                                    long_description=column_repository_long_description, 
                                                    owner=common.test_user_1_name,
                                                    category_id=self.security.encode_id( category.id ), 
                                                    strings_displayed=[] )
        if self.repository_is_new( repository ):
            self.upload_file( repository, 
                              filename='column_maker/column_maker.tar',
                              filepath=None,
                              valid_to
connect('suloop')
prof = InterestCategory(name='Professional').save()
sport = InterestCategory(name='Sports & Recreation').save()
music = InterestCategory(name='Music, Arts & Theater').save()
social = InterestCategory(name='Social').save()
religious = InterestCategory(name='Religious').save()
GSB = Interest(name='GSB')
GSB.interestcategory = prof
GSB.save()
GSC = Interest(name='GSC')
GSC.interestcategory = social
GSC.save()
Basketball = Interest(name='Basketball')
Basketball.interestcategory = sport
Basketball.save()
Rowing = Interest(name='Rowing')
Rowing.interestcategory = sport
Rowing.save()
Track = Interest(name='Track')
Track.interestcategory = sport
Track.save()
bYoga = Interest(name='Bhakti Yoga')
bYoga.interestcategory = religious
bYoga.save()
CCRMA = Interest(name='CCRMA')
CCRMA.interestcategory = music
CCRMA.save()
Art = Interest(name='Cantor Arts Center')
Art.interestcategory = music
Art.save()
tnp = Event(name='Tuck & Patti').save()
stor = Event(name='Storied Past: Four Cen

ncaa = Event(name='Ncaa Championships Second Day').save()
womrow = Event(name="Women's Rowing").save()
tnpcc = InterestEvent(interest=CCRMA, event=tnp).save()
tnpa = InterestEvent(interest=Art, event=tnp).save()
stora = InterestEvent(interest=Art, event=stor).save()
storgc = InterestEvent(interest=GSC, event=stor).save()
womrowrow =InterestEvent(interest=Rowing, event=womrow).save()
ncaatr = InterestEvent(interest=Track, event=ncaa).save()
sally = User(email='sally@example.com')
sally.first_name = 'sally'
sally.last_name = 'cooper'
sally.save()
sallyGSB = InterestUser(interest=GSB, user=sally).save()
sallyGSC = InterestUser(interest=GSC, user=sally).save()
sallyart = InterestUser(interest=Art, user=sally).save()
sallyBasketball = InterestUser(interest=Basketball, user=sally).save()
sallyRowing = InterestUser(interest=Rowing, user=sally).save()
sallyTrack = InterestUser(interest=Track, user=sally).save()
sallywomrow = EventUser(event=womrow, user=sally).save()
sallyncaa = EventUser(eve

sallystor = EventUser(event=stor, user=sally).save()
adam = User(email='adam@example.com')
adam.first_name = 'adam'
adam.last_name = 'newell'
adam.save()
adamGSC = InterestUser(interest=GSC, user=adam).save()
adambYoga = InterestUser(interest=bYoga, user=adam).save()
adamCCRMA = InterestUser(interest=CCRMA, user=adam).save()
adamstor = EventUser(event=stor, user=adam).save()
adamtnp = EventUser(event=tnp, user=adam).save()
jake = User(email='jake@example.com')
jake.first_name = 'jake'
jake.last_name = 'veloz'
jake.save()
jakeGSB = InterestUser(interest=GSB, user=jake).save()
jakeBasketball = InterestUser(interest=Basketball, user=jake).save()
jakeRowing = InterestUser(interest=Rowing, user=jake).save()
jakeTrack = InterestUser(interest=Track, user=jake).save()
jakeCCRMA = InterestUser(interest=CCRMA, user=jake).save()
jaketnp = EventUser(event=tnp, user=jake).save()
jakewomrow = EventUser(event=womrow, user=jake).save()
jakencaa = EventUser(event=ncaa, user=jake).save()
adamtnpmes = E
    CSEventApi,
    CSEventCategoryApi,
    CSUser,
    SmsApi,
    HermesReceiverApi,
    UserApi,
    CityApi,
    DistrictApi,
    ZoneApi,
    EntryApi,
    RegionApi,
    CityManageApi,
    RegionBrandApi,
    WhiteCollarBuildingApi,
    TransactionQueryConfigApi,
    RegionTransactionApi,
    RestaurantApi,
    RestaurantMenuApi,
    FoodApi,
    FoodCategoryApi,
    FoodImageApi,
    RecruitApi,
    RstInfoNotificationApi,
    RstBankCardApi,
    RstGroupApi)
    ActPayNoticeApi,
    RstActivityApi,
    FoodActivityApi,
    ActivityContractApi,
    ActivityPaymentApi,
    CustomerServiceUserApi,
    OrderAuditApi,
__all__ = [
    PingApi,
    LoginApi,
    FileApi,
    AmendedPoiApi,
    UserApi,
    RegionApi,
    CityApi,
    DistrictApi,
    ZoneApi,
    EntryApi,
    CityManageApi,
    RegionBrandApi,
    WhiteCollarBuildingApi,
    TransactionQueryConfigApi,
    RegionTransactionApi,
    CertificationApi,
    CouponApi,
    CouponBatchApi,
    RefundApi,
    PaymentApi,
   
s1 = Sector(sector_name='Healthcare');
s2 = Sector(sector_name='Education');
s3 = Sector(sector_name='Civic Technology');
s4 = Tag(tag_name='Disaster Response');
s1.save();
s2.save();
s3.save();
s4.save();
c1 = City(city_name='Delhi');
c2 = City(city_name='Gurgaon');
c3 = City(city_name='Noida');
c1.save();
c2.save();
c3.save();
sb1 = Sublocation(sublocation_name='Saket');
sb2 = Sublocation(sublocation_name='Connaught Place');
sb3 = Sublocation(sublocation_name='Haus Khas Village');
sb1.save();
sb2.save();
sb3.save();
t1 = Tag(tag_name='government schools');
t2 = Tag(tag_name='advertising');
t3 = Tag(tag_name='legal');
t4 = Tag(tag_name='community project');
t1.save();
t2.save();
t3.save();
t4.save();
u1 = User(user_email='arushij@stanford.edu');
u1.save();
u2 = User(user_email='arushijain1993@gmail.com');
u2.save();
sk1 = Skill(skill_name='Information Architecture');
sk2 = Skill(skill_name='Web Development');
sk3 = Skill(skill_name='Photography&Filmography');
sk4 = Skill(skill_name='B
response.title = settings.title
response.subtitle = settings.subtitle
response.meta.author = '%(author)s <%(author_email)s>' % settings
response.meta.keywords = settings.keywords
response.meta.description = settings.description
response.menu = [
(T('Business Service Catalogue'),URL('default','index')==URL(),URL('default','index'),[
    (T('Business Service Catalogue'),URL('default','index')==URL(),URL('default','index'),[],),
    (T('Notification'),URL('default','manage_notification')==URL(),URL('default','manage_notification'),[],),
]),
(T('Inventory'),URL('default','device_manage')==URL(),URL('default','device_manage'),[
    (T('Device'),URL('default','device_manage')==URL(),URL('default','device_manage'),[]),
    (T('Device&IP Association'),URL('default','device2ip_manage')==URL(),URL('default','device2ip_manage'),[]),
    (T('Ip'),URL('default','ip_manage')==URL(),URL('default','ip_manage'),[]),
    (T('IP&Port association'),URL('default','ip2port_manage')==URL(),URL('default','ip2
api_name = "metadata"
__all__ = [
    "MetadataRequest",
    "MetadataResponse",
    "TopicMetadata",
    "PartitionMetadata",
    "Broker",
class MetadataRequest(Request):
    """
    ::
      MetadataRequest =>
        topics => [String]
    """
    api = "metadata"
    parts = (
        ("topics", Array.of(String)),
    )
class Broker(Part):
    """
    ::
      Broker =>
        broker_id => Int32
        host => String
        port => Int32
    """
    parts = (
        ("broker_id", Int32),
        ("host", String),
        ("port", Int32),
    )
class PartitionMetadata(Part):
    """
    ::
      PartitionMetadata =>
        error_code => Int16
        partition_id => Int32
        leader => Int32
        replicas => [Int32]
        isrs => [Int32]
    """
    parts = (
        ("error_code", Int16),
        ("partition_id", Int32),
        ("leader", Int32),
        ("replicas", Array.of(Int32)),
        ("isrs", Array.of(Int32)),
    )
class TopicMetadata(Part):
    """
    ::
web.config.debug = False
urls = (
    '/\d{4}/\d{1,2}/\d{2}/([^/]+)\.html','views.article_by_slug',
    '/(\d{4})/(\d{2})','views.article_by_month',
    '/(\d{4})','views.article_by_year',
    '/category/(.*)','views.article_by_category',
    '/post_comment','views.post_comment',    
    '/tag/(.*)','views.article_by_tag',
    '/feed','views.feed',
    '/error/(\d+)','views.error',
    '/(.*)/', 'views.redirect',
    '/notfound','views.notfound',
    '/media/([^/]*)/{0,1}.*','views.get_media',
    '/login','views.login',
    '/logout','views.logout',
    
    '/manage','views.manage_config',
    '/manage/article','views.manage_article',
    '/manage/article/edit','views.manage_article_edit',
    '/manage/article/del','views.manage_article_del',
    '/manage/comments','views.manage_comments',
    '/manage/comments/del','views.manage_comments_del',
    '/manage/category','views.manage_category',
    '/manage/category/edit','views.manage_category_edit',
    '/manage/category/del','views.m
urlpatterns = patterns('SampleISP.views',
    url(r'^(?i)SampleISP/$', 'index', name='index'),
    url(r'^(?i)SampleISP/customers/$', 'customer_list', name='customer_list'),
    url(r'^(?i)SampleISP/customers/(?P<customer_id>\d+)/$', 'customer_detail', name='customer_detail'),
    url(r'^(?i)SampleISP/switches/$', 'switch_list', name='switch_list'),
    url(r'^(?i)SampleISP/routers/$', views.RouterListView.as_view(), name='router_list'),
    url(r'^(?i)SampleISP/routers/(?P<pk>\d+)/$', views.RouterDetailView.as_view(), name='router_detail'),
    url(r'^(?i)SampleISP/routers/(\w+)/$', views.RouterListView.as_view(), name='router_filtered_list'),
    url(r'^(?i)SampleISP/routerports/$', views.RouterPortListView.as_view(), name='routerport_list'),
    url(r'^(?i)SampleISP/routerports/manage/$', 'manage_routerport', name='manage_routerport'),
    url(r'^(?i)SampleISP/routerports/new_manage/$', views.RouterPortManageView.as_view(), name='new_manage_routerport'),
    url(r'^(?i)SampleISP/rou
class TestMajorDomo(TestCase):
    def setUp(self):
        self.uri = 'inproc://mdp-test'
        self.broker = mdp.MajorDomoBroker(
            self.uri,
            poll_interval=0.1)
        self.broker_reactor = self.broker.reactor()
        self.broker_reactor.next()
    def tearDown(self):
        self.broker.stop()
        list(self.broker_reactor)
        self.broker.destroy()
    def test_setup(self):
        pass
class TestMajorDomoClient(TestMajorDomo):
    def test_client_queued(self):
        cli = mdp.MajorDomoClient(self.uri)
        cli.send_async('echo', 'hello')
        self.broker_reactor.next()
        service = self.broker.require_service('echo')
        self.assertEqual(len(service.requests), 1)
        cli.destroy()
    def test_client_retries(self):
        cli = mdp.MajorDomoClient(self.uri, timeout=0, retries=1)
        self.assertRaises(mdp.err.MaxRetryError, cli.send, 'echo', 'hello')
        self.broker_reactor.next()
        self.broker_reactor.next()
   

        self.assertEqual(len(service.requests), 2)
        cli.destroy()
    def test_worker_gets_queued_requests(self):
        cli = mdp.MajorDomoClient(self.uri, timeout=0)
        req = cli.send_async('echo', 'hello')
        self.broker_reactor.next()
        wrk = mdp.MajorDomoWorker(self.uri, 'echo', _echo)
        wrk_reactor = wrk.reactor()
        wrk_reactor.next()
        self.assertEqual(req.recv(), ['hello'])
        cli.destroy()
        wrk.stop()
        list(wrk_reactor)
        wrk.destroy()
class TestMajorDomoWorker(TestMajorDomo):
    def setUp(self):
        super(TestMajorDomoWorker, self).setUp()
        self.worker = mdp.MajorDomoWorker(self.uri, 'echo', _echo)
        self.worker_reactor = self.worker.reactor()
        self.worker_reactor.next()
    def tearDown(self):
        self.worker.stop()
        list(self.worker_reactor)
        self.worker.destroy()
        super(TestMajorDomoWorker, self).tearDown()
    def test_setup(self):
        pass
    def tes
def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application.
    """
    authentication_policy = AuthTktAuthenticationPolicy('')
    authorization_policy = ACLAuthorizationPolicy()
    session_factory = session_factory_from_settings(settings)
    config = Configurator(root_factory=Root, settings=settings,
        authentication_policy=authentication_policy,
        authorization_policy=authorization_policy,
        session_factory=session_factory)
    config.add_static_view('deform_static', 'deform:static')
    config.add_static_view('static', 'vanity_app:static', cache_max_age=3600)
    config.add_route('favicon', '/favicon.ico')
    config.add_view('vanity_app.views.favicon', route_name='favicon')
    config.add_route('google_verify', '')
    config.add_view('vanity_app.views.google_verify',
        route_name='google_verify')
    config.add_route('robots', '/robots.txt')
    config.add_view('vanity_app.views.robots', route_name='robots')
    config.

    config.add_view('vanity_app.views.humans', route_name='humans')
    config.add_view('vanity_app.views.vanity_403',
        context='pyramid.exceptions.Forbidden',
        renderer='vanity_app:templates/vanity_403.mak')
    config.add_view('vanity_app.views.vanity_404',
        context='pyramid.exceptions.NotFound',
        renderer='vanity_app:templates/vanity_404.mak')
    config.add_view('vanity_app.views.vanity_root',
        context='vanity_app:resources.Root',
        renderer='vanity_app:templates/vanity_root.mak')
    config.add_route('vanity_about', '/about')
    config.add_view('vanity_app.views.vanity_about',
        route_name='vanity_about',
        renderer='vanity_app:templates/vanity_about.mak')
    config.add_route('home_of_the_one_click_release', '/ONE_CLICK_RELEASE')
    config.add_route('one_click', '/ONE_CLICK')
    config.add_view('vanity_app.views.one_click', route_name='one_click')
    config.add_view('vanity_app.views.home_of_the_one_click_release',
       

    config.add_route('vanity_activity', '/activity')
    config.add_view('vanity_app.views.vanity_activity',
        route_name='vanity_activity',
        renderer='vanity_app:templates/vanity_activity.mak')
    path = buildout()
    config.add_route('buildout_redir', '/buildout')
    config.add_view('vanity_app.views.buildout_redir',
        route_name='buildout_redir')
    config.add_static_view(name='buildout', path=path)
    config.add_route('buildout_software_version',
    config.add_route('buildout_software_version_filename',
        '/build/{software}/{version}/{filename}')
    config.add_view('vanity_app.views.buildout_software_version',
        route_name='buildout_software_version')
    config.add_view('vanity_app.views.buildout_software_version_filename',
        route_name='buildout_software_version_filename')
    config.add_route('contact', '/contact')
    config.add_view('vanity_app.views.contact',
        route_name='contact',
        renderer='vanity_app:templates/cont
class rent_controller():
    
    def __init__(self, repository, validator, movie_repository, client_repository):
        self.__repository = repository
        self.__validator = validator
        self.__movie_repository = movie_repository
        self.__client_repository = client_repository
    
    def createRent(self, idc, idm):
        '''Rents a movie to a client'''
        if self.__client_repository.findByID(idc) == True and self.__movie_repository.findByID(idm) == True:
            rent1 = rent(idc, idm)
            self.__validator.validate(rent1)
            self.__repository.storeRent(rent1)
            return rent1
        else:
            raise ValueError("The id of the client or movie does not exist")
    
    def getAllRents(self):
        '''Returns all rents'''
        return self.__repository.getAll()
    
    def returnMovie(self, idm):
        
        '''Sets the IsRented status of a movie to False'''
        try:
            self.__repository.returnMovie(idm)
  
"""Top-level presubmit script for loading.
See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts
for more details on the presubmit API built into depot_tools.
"""
def CommonChecks(input_api, output_api):
  output = []
  blacklist = [r'cloud/frontend/lib/*']
  output.extend(input_api.canned_checks.RunPylint(
      input_api, output_api, black_list=blacklist))
  output.extend(input_api.canned_checks.RunUnitTests(
      input_api,
      output_api,
      [input_api.os_path.join(input_api.PresubmitLocalPath(), 'run_tests')]))
  if input_api.is_committing:
    output.extend(input_api.canned_checks.PanProjectChecks(input_api,
                                                           output_api,
                                                           owners_check=False))
  return output
def CheckChangeOnUpload(input_api, output_api):
  return CommonChecks(input_api, output_api)
def CheckChangeOnCommit(input_api, output_api):
  return CommonChecks(input_api, output_ap
class Dailymotion(foauth.providers.OAuth2):
    provider_url = 'http://www.dailymotion.com/'
    docs_url = 'http://www.dailymotion.com/doc/api/graph-api.html'
    category = 'Videos'
    authorize_url = 'https://api.dailymotion.com/oauth/authorize'
    access_token_url = 'https://api.dailymotion.com/oauth/token'
    api_domain = 'api.dailymotion.com'
    available_permissions = [
        (None, 'access your public profile information'),
        ('email', 'access your email address'),
        ('userinfo', 'read and write to your private profile information'),
        ('manage_videos', 'publish, modify and delete your videos'),
        ('manage_comments', 'publish comments on videos'),
        ('manage_playlists', 'create, edit and delete your playlists'),
        ('manage_tiles', 'read and write to your saved tiles'),
        ('manage_subscriptions', 'manage your subscriptions'),
        ('manage_friends', 'manage your list of friends'),
        ('manage_favorites', 'manage your list o
class CrudExtension(wsgi.ExtensionRouter):
    """Previously known as the OS-KSADM extension.
    Provides a bunch of CRUD operations for internal data types.
    """
    def add_routes(self, mapper):
        tenant_controller = identity.TenantController()
        user_controller = identity.UserController()
        role_controller = identity.RoleController()
        service_controller = catalog.ServiceController()
        mapper.connect("/tenants", controller=tenant_controller,
                    action="create_tenant",
                    conditions=dict(method=["POST"]))
        mapper.connect("/tenants/{tenant_id}",
                    controller=tenant_controller,
                    action="update_tenant",
                    conditions=dict(method=["PUT", "POST"]))
        mapper.connect("/tenants/{tenant_id}",
                    controller=tenant_controller,
                    action="delete_tenant",
                    conditions=dict(method=["DELETE"]))
        mapper.conne

                    controller=user_controller,
                    action="get_tenant_users",
                    conditions=dict(method=["GET"]))
        mapper.connect("/users",
                    controller=user_controller,
                    action="get_users",
                    conditions=dict(method=["GET"]))
        mapper.connect("/users",
                    controller=user_controller,
                    action="create_user",
                    conditions=dict(method=["POST"]))
        mapper.connect("/users/{user_id}",
                    controller=user_controller,
                    action="update_user",
                    conditions=dict(method=["PUT"]))
        mapper.connect("/users/{user_id}",
                    controller=user_controller,
                    action="delete_user",
                    conditions=dict(method=["DELETE"]))
        mapper.connect("/users/{user_id}/password",
                    controller=user_controller,
                    actio

                    conditions=dict(method=["PUT"]))
        mapper.connect("/users/{user_id}/OS-KSADM/password",
                    controller=user_controller,
                    action="set_user_password",
                    conditions=dict(method=["PUT"]))
        mapper.connect("/users/{user_id}/tenant",
                    controller=user_controller,
                    action="update_user_tenant",
                    conditions=dict(method=["PUT"]))
        mapper.connect("/users/{user_id}/OS-KSADM/tenant",
                    controller=user_controller,
                    action="update_user_tenant",
                    conditions=dict(method=["PUT"]))
        mapper.connect("/users/{user_id}/enabled",
                    controller=user_controller,
                    action="set_user_enabled",
                    conditions=dict(method=["PUT"]))
        mapper.connect("/users/{user_id}/OS-KSADM/enabled",
                    controller=user_controller,
                    
urlpatterns = patterns('',
    url(r'^$', 'api.views.index'),
    url(r'^db/api/clear', 'api.views.clear'),
    url(r'^db/api/createTables', 'api.views.createTables'),
    url(r'^db/api/recreateDatabase', 'api.views.recreateDatabase'),
    url(r'^db/api/forum/create', 'api.handlers.forum.create'),
    url(r'^db/api/forum/details/$', 'api.handlers.forum.details'),
    url(r'^db/api/forum/listPosts/$', 'api.handlers.forum.listPosts'),
    url(r'^db/api/forum/listThreads/$', 'api.handlers.forum.listThreads'),
    url(r'^db/api/forum/listUsers/$', 'api.handlers.forum.listUsers'),
    url(r'^db/api/post/create', 'api.handlers.post.create'),
    url(r'^db/api/post/details/$', 'api.handlers.post.details'),
    url(r'^db/api/post/list/$', 'api.handlers.post.list'),
    url(r'^db/api/post/remove', 'api.handlers.post.remove'),
    url(r'^db/api/post/restore', 'api.handlers.post.restore'),
    url(r'^db/api/post/update', 'api.handlers.post.update'),
    url(r'^db/api/post/vote', 'api.handlers.pos

    url(r'^db/api/user/create', 'api.handlers.user.create'),
    url(r'^db/api/user/details/$', 'api.handlers.user.details'),
    url(r'^db/api/user/follow', 'api.handlers.user.follow'),
    url(r'^db/api/user/listFollowers/$', 'api.handlers.user.listFollowers'),
    url(r'^db/api/user/listFollowing/$', 'api.handlers.user.listFollowing'),
    url(r'^db/api/user/listPosts/$', 'api.handlers.user.listPosts'),
    url(r'^db/api/user/unfollow', 'api.handlers.user.unfollow'),
    url(r'^db/api/user/updateProfile', 'api.handlers.user.updateProfile'),
    url(r'^db/api/thread/close', 'api.handlers.thread.close'),
    url(r'^db/api/thread/create', 'api.handlers.thread.create'),
    url(r'^db/api/thread/details/$', 'api.handlers.thread.details'),
    url(r'^db/api/thread/list/$', 'api.handlers.thread.list'),
    url(r'^db/api/thread/listPosts/$', 'api.handlers.thread.listPosts'),
    url(r'^db/api/thread/open', 'api.handlers.thread.open'),
    url(r'^db/api/thread/remove', 'api.handlers.thread.
def _makeApp():
    conf = Configurator()
    conf.include('rebecca.repository')
    conf.scan(".")
    conf.commit()
    request = testing.DummyResource(registry=conf.registry)
    return request
def test_repository():
    request = _makeApp()
    result = get_repository(request, "testing")
    assert isinstance(result, TestingRepository)
    assert result.value == 9999
def test_repository_factory():
    request = _makeApp()
    result = create_repository(request, "testing1", args=(8888,))
    assert isinstance(result, TestingRepository)
    assert result.value == 8888
def test_repository_factory_with_passed_args():
    request = _makeApp()
    result = create_repository(request, "testing2")
    assert isinstance(result, TestingRepository)
    assert result.value == 8282
@repository_config(name="testing", args=(9999,))
@repository_factory_config(name="testing1")
@repository_factory_config(name="testing2", args=(8282,))
class TestingRepository(object):
    """ testing
    """
    def _
"""Routes configuration
The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'],
                 always_scan=config['debug'])
    map.minimization = False
    map.explicit = False
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')
    map.redirect("/", "/index")
    map.redirect('/*(url)/', '/{url}',
             _redirect_code='301 Moved Permanently')
    map.connect("/login", controller='account', action='login')
    map.connect("/logout", controller='account', action='logout')
    map.connect("/register", controller='account', action='register')
    map.connect("/welcome", controller='account', action='welcome')
    map.connect("/

    map.connect("/owner/{owner_uuid}", controller='vocabs', action='owner')
    map.connect("/index", controller='webpages', action='index')
    map.connect("/about", controller='webpages', action='about')
    map.connect("/contact", controller='webpages', action='contact')
    map.connect("/help", controller='webpages', action='help')
    map.connect("/privacy", controller='webpages', action='privacy')
    map.connect('/vocabs/create', controller='admin', action='create')
    map.connect('/vocabs/rename/{prefix}', controller='admin', action='rename')
    map.connect('/vocabs/generate/{prefix}', controller='admin', action='generate')
    map.connect('/vocabs', controller='vocabs', action='index')
    map.connect('/vocabs/external/{vocab_name}', controller='vocabs', action='render_external_vocab')
    map.connect('/publish', controller='vocabs', action='publish')
    map.connect('/{vocab}', controller='vocabs', action='render_vocab')
    map.connect('/{vocab}/{filename:.*}', controller
c_p = os.path.dirname(os.getcwd())+"/"
'''------------一些必要设置的选项-----------------'''
filename  = c_p+"model/im_info/10.19_33000/trainset.train"
indexs = [6,7,8,9,10]
stopword_filename = c_p+"model/im_info/10.19_33000/stopwords.txt"
'''------------一些可选设置的选项-----------------'''
model_name="im.model"
train_name = "svm.train"
param_name = "svm.param"
delete=True
str_splitTag="^"
tc_splitTag="\t"
'''------------------------分步训练时需要的设置的选项'''
dic_path =save_main_path+"model/" +dic_name
sample_save_path = save_main_path+"temp/"+"svm.train"
svm_model_save_path = save_main_path+"model/" +model_name
svm_param='-c 2.82842712475 -g 1.0' 
test_path = sample_save_path 
for_lsa_train_save_path =  save_main_path+"temp/" +"for_lsa.train"
k = 500
lsa_train_save_path =  save_main_path+"temp/"  +"lsa_"+str(k)+".train"
lsa_save_path = save_main_path+"temp/"  + "lsa_"+str(k)
lsa_svm_param  = '-c 2.0 -g 1.0'
lsa_svm_model_save_path  = save_main_path + "LSA_title_content"+str(k)+".model"
extra_filename = save_ma

print "欢迎使用旺旺聊天欺诈监控系统，LSA模型训练系统"
choice = int(raw_input("0为自动生成模型，1为构造SVM训练的样本； 2为训练模型;3为LSA模型生成训练文本格式；4为构造LSA模型；5为训练LSA生成的模型；6为用原模型计算内容得分提取其他特征;7为向原模型中增加原先误判的样本；7为向LSA模型中增加原先误判样本。-1为退出模型"))
while choice!=-1:
    if choice==0:
        ctm_train(filename,indexs,save_main_path,stopword_filename)
    if choice==1:
        cons_train_sample_for_cla(filename,indexs,dic_path,sample_save_path,delete,str_splitTag)
    if choice==2:
      m=ctm_train_model(sample_save_path,svm_param,svm_model_save_path) 
    if choice==3:
        save_train_for_lsa(test_path,svm_model_save_path,for_lsa_train_save_path)
    if choice==4:
        M = len(read_dic(dic_path))
        ctm_lsa(M,threhold,k,for_lsa_train_save_path,lsa_train_save_path,lsa_save_path)
    if choice ==5:
        ctm_train_model(lsa_train_save_path,lsa_svm_param,lsa_svm_model_save_path)
    if choice ==6:
      add_sample_to_model(extra_filename,indexs,dic_path,sample_save_path,delete,str_splitTag)  
    choice = int(raw_input("0为自动生成模型，1
"""
    clihub/repository.py
    ~~~~~~~~~~~~~~~~~~~~
    :copyright: (c) 2012 by Stephane Wirtel <stephane@wirtel.be>
    :license: BSD, see LICENSE for more details
"""
class Repository(object):
    @classmethod
    def create(cls, account, repository_name, has_issues=True, has_wiki=True):
        values = {
            "name": repository_name,
            "private": False,
            "has_issues": has_issues,
            "has_wiki": has_wiki,
        }
        url = 'https://api.github.com/user/repos'
        query = requests.post(url,
                              auth=(account.username, account.password),
                              data=json.dumps(values))
        if query.status_code == 201:
            print query.json()['ssh_url']
            return Repository(account, repository_name)
        else:
            raise Exception("Can't create the repository")
    def __init__(self, account, repository_name):
        self.account = account
        self.repository_name = reposi
"""
    Sahana Eden Stats Controller
"""
module = request.controller
resourcename = request.function
if not settings.has_module(module):
    raise HTTP(404, body="Module disabled: %s" % module)
def parameter():
    """ REST Controller """
    return s3_rest_controller()
def data():
    """ REST Controller """
    return s3_rest_controller()
def aggregate():
    """ REST Controller """
    def prep(r):
        if r.method == "clear":
            if not s3_has_role(ADMIN):
                auth.permission.fail()
            s3db.stats_rebuild_aggregates()
            redirect(URL(c="stats",
                         f="aggregate",
                         args="",
                         ))
        return True
    s3.prep = prep
    output = s3_rest_controller()
    return output
def demographic():
    """ REST Controller """
    return s3_rest_controller()
def demographic_data():
    """ REST Controller """
    return s3_rest_controller()
def group():
    """ REST Controller """
    retu
class Environment(Base):
    def find(self, repository_id, environment_id=None):
        if environment_id:
            url = str(repository_id) + '/server_environments/' + str(environment_id) + '.json'
        else:
            url = str(repository_id) + '/server_environments.json'
        return self._do_get(url)
    def find_all(self, repository_id):
        return self.find(repository_id)
    def create(self, repository_id, name, branch_name, automatic=False):
        url = str(repository_id) + '/server_environments.json'
        data = {
            'server_environment': {
                "name": name,
                "automatic": automatic,
                "branch_name": branch_name
            }
        }
        return self._do_post(url, data)
    def update(self, repository_id, environment_id, update_data):
        url = str(repository_id) + '/server_environments/' + str(environment_id) + '.json'
        data = {
            'server_environment': update_data
        }
        
v1_api = Api(api_name=API_VERSION)
v1_api.register(execution.RunResource())
v1_api.register(execution.RunCaseVersionResource())
v1_api.register(execution.RunSuiteResource())
v1_api.register(execution.ResultResource())
v1_api.register(execution.SuiteSelectionResource())
v1_api.register(library.CaseResource())
v1_api.register(library.CaseVersionResource())
v1_api.register(library.CaseStepResource())
v1_api.register(library.SuiteResource())
v1_api.register(library.CaseSelectionResource())
v1_api.register(library.SuiteCaseResource())
v1_api.register(library.CaseVersionSelectionResource())
v1_api.register(library.CaseVersionSearchResource())
v1_api.register(environments.ProfileResource())
v1_api.register(environments.EnvironmentResource())
v1_api.register(environments.ElementResource())
v1_api.register(environments.CategoryResource())
v1_api.register(core.UserResource())
v1_api.register(core.ProductResource())
v1_api.register(core.ProductVersionResource())
v1_api.register(core.ProductVersio
__author__ = 'Ahmed Gamal A. Ali'
class ImagesCollectorTest(unittest.TestCase):
    def test_image_file_not_exists(self):
        image_file = '/path/not/found/file.txt'
        save_dir = '/some/save/dir'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir)
        except OSError, e:
            self.assertEqual(e.message, "File %s Not Found" % image_file)
        except Exception, e:
            self.fail('Unexpected exception thrown: %s' % e)
        else:
            self.fail('Expected Exception not thrown')
        remove_save_dir(save_dir)
    def test_image_save_dir_not_exists(self):
        image_file = './tests/fixtures/empty.txt'
        save_dir = '/some/save/dir'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir)
        except OSError, e:
            self.assertIn("Save Directory not found", e.message)
        except Exception, e:
            self.fail('Unexpected exception thrown: %s' % e)
        else:
          

        remove_save_dir(save_dir)
    def test_image_save_dir_permission_denied(self):
        image_file = './tests/fixtures/empty.txt'
        save_dir = '/dir'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir, create=True)
        except OSError, e:
            self.assertEqual(e.errno, errno.EACCES)
        except Exception, e:
            self.fail('Unexpected exception thrown: %s' % e)
        else:
            self.fail('Expected Exception not thrown')
        remove_save_dir(save_dir)
    def test_image_empty_file(self):
        image_file = './tests/fixtures/empty.txt'
        save_dir = '/tmp/save_dir/'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir, create=True)
        except Exception, e:
            self.assertEqual('Images File is Empty', e.message)
        else:
            self.fail('Expected Exception not thrown')
        remove_save_dir(save_dir)
    def test_no_urls_in_file(self):
        image_file = 

        save_dir = '/tmp/save_dir/'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir, create=True)
        except Exception, e:
            self.assertEqual('No Valid URLs Found', e.message)
        else:
            self.fail('Expected Exception not thrown')
        remove_save_dir(save_dir)
    def test_one_urls_in_file(self):
        image_file = './tests/fixtures/one_url.txt'
        save_dir = '/tmp/save_dir/'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir, create=True)
        except Exception, e:
            self.fail('Not Expected Exception thrown: ' + str(e))
        self.assertEqual(1, len(os.listdir(os.path.join(save_dir, 'images'))))
        remove_save_dir(save_dir)
    def test_valid_but_not_found_urls(self):
        image_file = './tests/fixtures/valid_not_found.txt'
        save_dir = '/tmp/save_dir/'
        try:
            CollectImages(image_file=image_file, save_dir=save_dir, create=True)
        exce
class TestMenuController(unittest.TestCase):
  def setUp(self):
    pass
  def tearDown(self):
    if(hasattr(MenuController, '_instance')):
      MenuController._instance = None
  def test_success(self):
    self.controller = MenuController(parent_window=Tk.Tk())
    self.assertNotEqual(self.controller, None, "MenuController should be defined if" + \
      "tkinter.Tk() instance is passed in")
  def test_success_with_subsequent_calls(self):
    try:
      self.controller = MenuController(parent_window=Tk.Tk())
      self.controller = MenuController()
    except ValueError as e:
      self.fail("Menu Controller should work after being initialized property" + \
        "and being called subsequently without arguments.")
  def test_singleton(self):
    try:
      self.controller = MenuController()
      self.fail("MenuController needs to be passed reference " + \
        "to tkinter.Tk() upon first instantiation")
    except ValueError as e:
      pass
  def test_wrong_argument_passed_in
__all__ = ['load']
class Storage(object):
    """Storage is organized as follow:
    $ROOT/images/<image_id>/json
    $ROOT/images/<image_id>/layer
    $ROOT/repositories/<namespace>/<repository_name>/<tag_name>
    """
    repositories = 'repositories'
    images = 'images'
    buffer_size = 128 * 1024
    supports_bytes_range = False
    def images_list_path(self, namespace, repository):
        repository_path = self.repository_path(
            namespace=namespace, repository=repository)
        return '{0}/_images_list'.format(repository_path)
    def image_json_path(self, image_id):
        return '{0}/{1}/json'.format(self.images, image_id)
    def image_mark_path(self, image_id):
        return '{0}/{1}/_inprogress'.format(self.images, image_id)
    def image_checksum_path(self, image_id):
        return '{0}/{1}/_checksum'.format(self.images, image_id)
    def image_layer_path(self, image_id):
        return '{0}/{1}/layer'.format(self.images, image_id)
    def image_ancestry_

        return '{0}/{1}/ancestry'.format(self.images, image_id)
    def image_files_path(self, image_id):
        return '{0}/{1}/_files'.format(self.images, image_id)
    def image_diff_path(self, image_id):
        return '{0}/{1}/_diff'.format(self.images, image_id)
    def repository_path(self, namespace, repository):
        return '{0}/{1}/{2}'.format(
            self.repositories, namespace, repository)
    def tag_path(self, namespace, repository, tagname=None):
        repository_path = self.repository_path(
            namespace=namespace, repository=repository)
        if not tagname:
            return repository_path
        return '{0}/tag_{1}'.format(repository_path, tagname)
    def repository_json_path(self, namespace, repository):
        repository_path = self.repository_path(
            namespace=namespace, repository=repository)
        return '{0}/json'.format(repository_path)
    def repository_tag_json_path(self, namespace, repository, tag):
        repositor

            namespace=namespace, repository=repository)
        return '{0}/tag{1}_json'.format(repository_path, tag)
    def index_images_path(self, namespace, repository):
        repository_path = self.repository_path(
            namespace=namespace, repository=repository)
        return '{0}/_index_images'.format(repository_path)
    def private_flag_path(self, namespace, repository):
        repository_path = self.repository_path(
            namespace=namespace, repository=repository)
        return '{0}/_private'.format(repository_path)
    def is_private(self, namespace, repository):
        return self.exists(self.private_flag_path(namespace, repository))
    def get_content(self, path):
        raise NotImplementedError
    def put_content(self, path, content):
        raise NotImplementedError
    def stream_read(self, path, bytes_range=None):
        raise NotImplementedError
    def stream_write(self, path, fp):
        raise NotImplementedError
    def list_directory(se
 	
class ControllerTest(unittest.TestCase):
	"""ControllerTest: Test Controller Singleton"""
	def assertNotNone(self):
		"""ControllerTest: Test instance not null"""
		controller = puremvc.core.Controller.getInstance()
   		self.assertNotEqual(None, controller) 
	def assertIController(self):
		"""ControllerTest: Test instance implements IController"""
		controller = puremvc.core.Controller.getInstance()
   		self.assertEqual(True, isinstance(controller, puremvc.interfaces.IController))
	def testRegisterAndExecuteCommand(self):
 		"""ControllerTest: Test registerCommand() and executeCommand()"""
		controller = puremvc.core.Controller.getInstance()
		controller.registerCommand('ControllerTest', utils.controller.ControllerTestCommand)
		
		vo = utils.controller.ControllerTestVO(12)
		note = puremvc.patterns.observer.Notification('ControllerTest', vo)
		controller.executeCommand(note)
		
		self.assertEqual(True, vo.result == 24 )
  		
	def testRegisterAndRemoveCommand(self): 
		"""Controll
"""Plot results from the turbinesFoam RM2 simulation."""
if __name__ == "__main__":
    set_sns()
    plt.rcParams["axes.grid"] = True
    parser = argparse.ArgumentParser(description="Generate plots.")
    parser.add_argument("plot", nargs="*", help="What to plot", default="perf",
                        choices=["perf", "wake", "blade-perf", "strut-perf",
                                 "perf-curves", "perf-curves-exp", "recovery",
                                 "verification", "wake-profiles",
                                 "wake-profiles-exp"])
    parser.add_argument("--all", "-A", help="Generate all figures",
                        default=False, action="store_true")
    parser.add_argument("--save", "-s", help="Save to `figures` directory",
                        default=False, action="store_true")
    parser.add_argument("--no-show", default=False, action="store_true",
                        help="Do not call matplotlib show function")
    parser.add_argument("-q", help

                        default=["alpha", "rel_vel_mag"])
    args = parser.parse_args()
    if args.save:
        if not os.path.isdir("figures"):
            os.mkdir("figures")
    if "wake" in args.plot or args.all:
        plot_meancontquiv(save=args.save)
        plot_kcont(save=args.save)
    if "wake-profiles" in args.plot or args.all:
        plot_wake_profiles(save=args.save)
    if "wake-profiles-exp" in args.plot or args.all:
        plot_wake_profiles(exp=True, save=args.save)
    if "perf" in args.plot or args.all:
        plot_cp(save=args.save)
    if "blade-perf" in args.plot or args.all:
        plot_blade_perf(save=args.save, quantities=args.q)
    if "strut-perf" in args.plot or args.all:
        plot_strut_perf(save=args.save, quantities=args.q)
    if "perf-curves" in args.plot or args.all:
        plot_perf_curves(exp=False, save=args.save)
    if "perf-curves-exp" in args.plot or args.all:
        plot_perf_curves(exp=True, save=args.save)
    if "recovery" in 
urlpatterns = [
	url(r'^$', views.index, name='index'),
	url(r'^add/', views.add, name='add'),
	url(r'^admin/', include(admin.site.urls)),
	url(r'^auth/$', cal.auth, name='auth'),
	url(r'^changePassword/', views.changePassword, name='changePassword'),
	url(r'^confirm/(?P<activation_key>\w+)', views.register_confirm, name='confirm_email'),
	url(r'^forgotPassword/(?P<login_key>\w*)', views.forgotPassword, name='forgotPassword'),
	url(r'^login/$', views.user_login, name='login'),
	url(r'^loginEvent/$', views.user_loginEvent, name='loginEvent'),
	url(r'^logout/$', views.user_logout, name='logout'),
	url(r'^manageCreator/', views.manageCreator, name='manageCreator'),
	url(r'^manageInvitee/', views.manageInvitee, name='manageInvitee'),
	url(r'^manageMessage/', views.manageMessage, name='manageMessage'),
	url(r'^manageNotification/', views.manageNotification, name='manageNotification'),
	url(r'^register/$', views.register, name='register'),
	url(r'^registerEvent/$', views.registerEvent, name=
urlpatterns = patterns('',
    url(r'^user/$', api_user, name='api_user'),
    url(r'^forum/$', api_forum, name='api_forum'),    
    url(r'^forums/$', api_forums, name='api_forums'),    
    url(r'^authentication/$', api_authentication, name='api_authentication'),        
    url(r'^annotations/$', api_annotations, name='api_annotations'),   
    url(r'^annotation/$', api_annotation, name='api_annotation'),   
    url(r'^map/$', api_map, name='api_map'),   
    url(r'^timeline/$', api_timeline, name='api_timeline'),   
    url(r'^threads/$', api_threads, name='api_threads'),   
    url(r'^User/$', api_user, name='api_user'),
    url(r'^Group/$', api_forum, name='api_forum'),    
    url(r'^Groups/$', api_forums, name='api_forums'),        
    url(r'^Login/$', api_authentication, name='api_authentication'),        
    url(r'^Annotations/$', api_annotations, name='api_annotations'),                
    url(r'^Annotation/$', api_annotation, name='api_annotation'),   
    url(r'^Map/$',
class ManageUsersAdapter:
    def __init__(self):
        pass
    @staticmethod
    def create(manage_user_guid=None,
               manage_user_email=None,
               manage_user_password=None,
               manage_user_first_name=None,
               manage_user_last_name=None,
               manage_user_phone=None,
               is_system=False,
               is_deleted=False,
               is_active=False
               ):
        manage_user = ManageUsers(manage_user_guid=manage_user_guid,
                                  manage_user_email=manage_user_email,
                                  manage_user_password=manage_user_password,
                                  manage_user_first_name=manage_user_first_name,
                                  manage_user_last_name=manage_user_last_name,
                                  manage_user_phone=manage_user_phone,
                                  is_system=is_system,
                                  is_deleted=is_deleted,

setup(name='application_repository',
      version=version.getVersion(),
      description='A Django site for serving versioned application and '
      'plug-in downloads.',
      keywords='application distribute plugin download django',
      author='Christian Fobel',
      author_email='christian@fobel.net',
      url='http://github.com/cfobel/application_repository.git',
      license='GPL',
      packages=['application_repository',
                'application_repository.application',
                'application_repository.application.scripts',
                'application_repository.plugins',
                'application_repository.plugins.scripts',
                'application_repository.repository'],
      install_requires=['application_repository.jsonrpc'],
      package_data={'application_repository': ['settings.py.skeleton',
                                               'app_data/.empty_file',
                                               'config/apache/*',
               
def throttling(validator):
    """
    Adds throttling validator to a function.
    """
    def decorator(view_func):
        def _throttling(self, *args, **kwargs):
            validator.validate(self.request)
            return view_func(self, *args, **kwargs)
        return wraps(view_func, assigned=available_attrs(view_func))(_throttling)
    return decorator
def throttling_all(klass):
    """
    Adds throttling validator to a class.
    """
    dispatch = getattr(klass, 'dispatch')
    setattr(klass, 'dispatch', throttling()(dispatch))
    return klass
def add_attribute_wrapper(name, value):
    def decorator(view_func):
        def _wrapper(*args, **kwargs):
            return view_func(*args, **kwargs)
        setattr(_wrapper, name, value)
        return wraps(view_func, assigned=available_attrs(view_func))(_wrapper)
    return decorator
def throttling_exempt():
    """
    Marks a function as being exempt from the throttling protection.
    """
    return add_attribute_wrappe
def _get_base_folder(host):
    return '/var/www/sites/' + host
def _get_manage_py(host):
    command = ('export $(cat /etc/www/gunicorn-{host}|xargs) && '
        '{path}/virtualenv/bin/python {path}/source/manage.py '.format(
            host=host, path=_get_base_folder(host)))
    return command
def reset_database():
    run('{manage} flush --noinput'.format(manage=_get_manage_py(env.host)))
def create_admin_on_server(username, password, email):
    run('{manage} create_admin {username} {password} {email}'.format(
        manage=_get_manage_py(env.host), username=username, password=password,
        email=email))
def create_testrecipe_on_server(name):
    slug = run('{manage} create_testrecipe {name}'.format(
        manage=_get_manage_py(env.host), name=name))
    print(slug)
def create_ingredient(name, type):
    pk = run('{manage} create_ingredient {name} -t {type}'.format(name=name,
        manage=_get_manage_py(env.host), type=type))
    print(pk)
def add_ingredient_to_recipe(p
def index(request):
    client_list = Client.objects.all()
    output = ', '.join([c.name for c in client_list])
    return HttpResponse(output)
def init(request):
	Programm.objects.all().delete()
	Age.objects.all().delete()
	Room.objects.all().delete()
	Source.objects.all().delete()
	Client.objects.all().delete()
	Staff.objects.all().delete()
	age_1_3 = Age(age='1-3')
	age_1_3.save()
	age_4_6 = Age(age='4-6')
	age_4_6.save()
	age_unlimit = Age(age='Без ограничения')
	age_unlimit.save()
	room_1 = Room(name='Зал 1',floor='1 этаж',building='1')
	room_1.save()
	room_2 = Room(name='Зал 2',floor='1 этаж',building='1')
	room_2.save()
	room_3 = Room(name='Зал 3',floor='1 этаж',building='1')
	room_3.save()
	Source(name='Буду мамой').save()
	Source(name='Вывеска').save()
	Source(name='Галерея').save()
	Source(name='День матери').save()
	Source(name='Директор').save()
	Source(name='Знакомые').save()	
	Source(name='Друзья').save()	
	Source(name='Вконтакте').save()
	Source(name='Мероприятие').save

	Source(name='Партнёры узнайки').save()	
	Source(name='Узнайка').save()	
	Source(name='Сертификат').save()	
	Source(name='Реклама').save()	
	Source(name='Сайт').save()
	Source(name='Семинар для беременных').save()
	Source(name='Хеппилон').save()
	Programm(name='Смарт-спорт', age = age_unlimit).save()
	Programm(name='Танцы', age = age_unlimit).save()
	Programm(name='Йога', age = age_unlimit).save()
	Programm(name='Йога для беременных', age = age_unlimit).save()
	Programm(name='Подв. ЛФК', age = age_unlimit).save()
	Programm(name='Арт. терапия', age = age_unlimit).save()
	Programm(name='BWA', age = age_unlimit).save()
	Programm(name='BWA экспресс', age = age_unlimit).save()
	Programm(name='ОГ', age = age_unlimit).save()
	Programm(name='Фёст степ', age = age_unlimit).save()
	staff_Katya = Staff(first_name='Катя',trainer=False)
	staff_Katya.save()
	staff_Yulia = Staff(first_name='Юля',trainer=False)
	staff_Yulia.save()
	Staff(first_name='Наташа',trainer=False).save()
	Staff(first_name='Да
class CreateVideoForm(forms.ModelForm):
    def save(self, commit=True, request=None):
        kwargs = {
            'video': vidscraper.auto_scrape(self.cleaned_data['original_url']),
            'commit': False,
        }
        if request and request.user.is_authenticated():
            kwargs['owner'] = request.user
        instance = Video.from_vidscraper_video(**kwargs)
        def save_m2m():
            instance.save_m2m()
        if commit:
            instance.save()
            save_m2m()
        else:
            self.save_m2m = save_m2m
        return instance
class CreateFeedForm(forms.ModelForm):
    def save(self, commit=True, request=None):
        if request and request.user.is_authenticated():
            self.instance.owner = request.user
        instance = super(CreateFeedForm, self).save(commit)
        if commit:
        else:
            old_save_m2m = self.save_m2m
            def save_m2m():
                old_save_m2m()
            self.save_m2m = save_m2m
log = logging.getLogger(__name__)
class InstallTestRepositories( InstallTestRepository ):
    """Abstract test case that installs a predefined list of repositories."""
    def do_install( self, repository_dict ):
        self.logout()
        admin_email = 'test@bx.psu.edu'
        admin_username = 'test'
        self.login( email=admin_email, username=admin_username )
        admin_user = test_db_util.get_user( admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = test_db_util.get_private_role( admin_user )
        self.install_repository( repository_dict )
def generate_install_method( repository_dict=None ):
    """Generate abstract test cases for the defined list of repositories."""
    def make_install_method( repository_dict ):
        def test_install_repository( self ):
            self.do_install( repository_dict )
        return test_install_repository
    if repository_dic
__author__ = 'Administrator'
def fun_template():
    '''
    default 模板的 方法控制器
    '''
    funMap={}
    funMap['404']=(views.page404,('/404.html',))
    funMap['index']=(views.index,('/index.html',))
    funMap['blogAdmin']=(views.blogAdmin,('/admindefault.html',))
    funMap['manageMenu']=(views.manageMenu,('/adminMenu.html',))
    funMap['manageMenu_save']=(views.manageMenu_save,('/adminMenu.html',))
    funMap['webinfo']=(views.webinfo,('/admindefault.html',))
    funMap['AdminInfo']=(views.adminInfo,('/adminInfo.html',))
    funMap['AdminInfo_save']=(views.adminInfo_save,('/adminInfo.html',))
    funMap['managePaper_save']=(views.managePaper_save,('/adminedit.html',))
    funMap['managePaperImage_save']=(views.managePaperImage_save,('/adminimageedit.html',))
    funMap['managePaperImage_upload']=(views.managePaperImage_upload,('/adminimageedit.html',))
    funMap['managePaper_list']=(views.managePaper_list,('/adminPaperList.html',))
    funMap['manageAlbum_list']=(views.manageAlbu

    funMap['manageAlbum_save']=(views.manageAlbum_save,('/adminAlbumSave.html',))
    funMap['manageAlbum_upload']=(views.manageAlbum_upload,('/adminalbumupload.html',))
    funMap['paper']=(views.paperShow,('/paper.html','/paperImage.html'))
    funMap['paperlist']=(views.paperlist,('/paperlist.html',))
    funMap['albumlist']=(views.albumlist,('/albumlist.html',))
    funMap['column']=(views.column,('/column.html',))
    funMap['keywords']=(views.keywords,('/column.html',))
    funMap['commentAdd']=(views.commentAdd,('',))
    funMap['commentList']=(views.commentList,('',))
    funMap['papercount']=(views.papercount,('',))
    funMap['websiteNum']=(views.websiteNum,('',))
    funMap['emailSubscribe']=(views.emailSubscribe,('/emailSubscribe.html',))
    funMap['picshow']=(views.picshow,('',))
    funMap['getImageListByTitleId']=(views.getImageListByTitleId,('',))
    funMap['saveImageInfoByTitleId']=(views.saveImageInfoByTitleId,('',))
    funMap['delImageInfoByImgId']=(views.delImag
c_p = os.path.dirname(os.getcwd())+"/"
'''------------model_0829_dic1------------------
save_main_path = c_p+"model/model_0829_dic1/0901/"
dic_main_path = c_p+"Dictionary/ctm/"
filename  = save_main_path+"train_set.txt"
indexs = [1,2]
dic_path =dic_main_path+"Dic1_title_content.key"
glo_aff_path  = dic_main_path+"Dic1_title_content.glo"
sample_save_path = save_main_path+"title_content.train"
delete =True
tc_splitTag="\t"
str_splitTag ="^"
svm_model_save_path = save_main_path+"title.model"
svm_param='-c 16.0 -g 0.00048828125' 
test_path = sample_save_path 
for_lsa_train_save_path =  save_main_path +"for_lsa.train"
k = 10
lsa_train_save_path =  save_main_path +"0905_lsa_"+str(k)+".train"
lsa_save_path = save_main_path + "0905_lsa"
lsa_svm_param  = '-c -g'
lsa_svm_model_save_path  = save_main_path + "LSA_title.model"
extra_filename  = save_main_path +"data.extra"
-------------------------------------------------'''
'''------------model_ban禁限售样本---------------------------------------------
'''
Created on Sep 9, 2014
@author: Taylor
'''
class TestRepository(unittest.TestCase):
    def test100_010_ShouldConstructRepositoryExplicitCapacity(self):
        self.assertIsInstance(Repository.Repository(capacity=100), Repository.Repository)
        
    def test100_020_ShouldConstructRepositoryDefaultCapacity(self):
        self.assertIsInstance(Repository.Repository(), Repository.Repository)
        
    def test100_910_ShouldRaiseExceptionOnNonIntCapacity(self):
        expectedString = "Repository.__init__:"
        try:
            myRepository = Repository.Repository("a")                                                
            self.fail("exception was not raised")                    
        except ValueError as raisedException:                                           
            diagnosticString = raisedException.args[0]                                   
            self.assertEquals(expectedString, diagnosticString[0:len(expectedString)]) 
        except:
         

    
    def test100_920_ShouldRaiseExceptionOnInvalidCapacity(self):
        expectedString = "Repository.__init__:"
        try:
            myRepository = Repository.Repository(capacity=0)                                                
            self.fail("exception was not raised")                    
        except ValueError as raisedException:                                           
            diagnosticString = raisedException.args[0]                                   
            self.assertEquals(expectedString, diagnosticString[0:len(expectedString)]) 
        except:
            self.fail("incorrect exception was raised")     
    
    def test200_010_shouldAddComponent(self):
        maxCapacity = 2
        theRepository = Repository.Repository(maxCapacity)
        for i in range(maxCapacity):
            self.assertEquals(i+1, theRepository.addComponent(Component.Component("C"+str(i), i+1, i+1)))
            
    def test200_020_shouldAddComponentPastCapacity(self

        maxCapacity = 2
        theRepository = Repository.Repository(maxCapacity)
        for i in range(maxCapacity):
            theRepository.addComponent(Component.Component("C"+str(i), i+1, i+1))
            
        self.assertEquals(maxCapacity, theRepository.addComponent(Component.Component("overflow", 1, 10)))
        
    def test200_020_shouldDeleteOldestPastCapacity(self):
        maxCapacity = 2
        theRepository = Repository.Repository(maxCapacity)
        for i in range(maxCapacity+1):
            theRepository.addComponent(Component.Component("C"+str(i), i, i+1))
        self.assertEquals(2, theRepository.validCount())
        
    def test200_910_shouldRaiseExceptionIfComponentMissing(self):
        expectedString = "Repository.addComponent:"
        theRepository = Repository.Repository()
        try:                                             
            theRepository.addComponent()
            self.fail("exception was not raised")                    
       
logger = logging.getLogger(__name__)
class BrokerView(BaseHandler):
    @web.authenticated
    @gen.coroutine
    def get(self):
        app = self.application
        broker_options = self.capp.conf.BROKER_TRANSPORT_OPTIONS
        http_api = None
        if app.transport == 'amqp' and app.options.broker_api:
            http_api = app.options.broker_api
        try:
            broker = Broker(app.capp.connection().as_uri(include_password=True),
                            http_api=http_api, broker_options=broker_options)
        except NotImplementedError:
            raise web.HTTPError(
                404, "'%s' broker is not supported" % app.transport)
        try:
            queue_names = ControlHandler.get_active_queue_names()
            if not queue_names:
                queue_names = set([self.capp.conf.CELERY_DEFAULT_QUEUE])
            queues = yield broker.queues(sorted(queue_names))
        except Exception as e:
            raise web.HTTPError(404, "Unable to get que
"""
**DEPRECATED**
Use :mod:`celery.defaults` instead.
"""
_DEFAULTS = defaults.DEFAULTS
conf = current_app.conf
ALWAYS_EAGER = conf.CELERY_ALWAYS_EAGER
EAGER_PROPAGATES_EXCEPTIONS = conf.CELERY_EAGER_PROPAGATES_EXCEPTIONS
RESULT_BACKEND = conf.CELERY_RESULT_BACKEND
CACHE_BACKEND = conf.CELERY_CACHE_BACKEND
CACHE_BACKEND_OPTIONS = conf.CELERY_CACHE_BACKEND_OPTIONS
TASK_SERIALIZER = conf.CELERY_TASK_SERIALIZER
TASK_RESULT_EXPIRES = conf.CELERY_TASK_RESULT_EXPIRES
IGNORE_RESULT = conf.CELERY_IGNORE_RESULT
TRACK_STARTED = conf.CELERY_TRACK_STARTED
ACKS_LATE = conf.CELERY_ACKS_LATE
REDIRECT_STDOUTS = conf.CELERY_REDIRECT_STDOUTS
REDIRECT_STDOUTS_LEVEL = conf.CELERY_REDIRECT_STDOUTS_LEVEL
RESULT_DBURI = conf.CELERY_RESULT_DBURI
RESULT_ENGINE_OPTIONS = conf.CELERY_RESULT_ENGINE_OPTIONS
MAX_CACHED_RESULTS = conf.CELERY_MAX_CACHED_RESULTS
SEND_EVENTS = conf.CELERY_SEND_EVENTS
DEFAULT_RATE_LIMIT = conf.CELERY_DEFAULT_RATE_LIMIT
DISABLE_RATE_LIMITS = conf.CELERY_DISABLE_RATE_LIMITS
CELERYD_TASK_

CELERYD_TASK_SOFT_TIME_LIMIT = conf.CELERYD_TASK_SOFT_TIME_LIMIT
CELERYD_MAX_TASKS_PER_CHILD = conf.CELERYD_MAX_TASKS_PER_CHILD
STORE_ERRORS_EVEN_IF_IGNORED = conf.CELERY_STORE_ERRORS_EVEN_IF_IGNORED
CELERY_SEND_TASK_ERROR_EMAILS = conf.CELERY_SEND_TASK_ERROR_EMAILS
CELERY_TASK_ERROR_WHITELIST = conf.CELERY_TASK_ERROR_WHITELIST
CELERYD_LOG_FORMAT = conf.CELERYD_LOG_FORMAT
CELERYD_TASK_LOG_FORMAT = conf.CELERYD_TASK_LOG_FORMAT
CELERYD_LOG_FILE = conf.CELERYD_LOG_FILE
CELERYD_LOG_COLOR = conf.CELERYD_LOG_COLOR
CELERYD_LOG_LEVEL = conf.CELERYD_LOG_LEVEL
CELERYD_STATE_DB = conf.CELERYD_STATE_DB
CELERYD_CONCURRENCY = conf.CELERYD_CONCURRENCY
CELERYD_PREFETCH_MULTIPLIER = conf.CELERYD_PREFETCH_MULTIPLIER
CELERYD_POOL_PUTLOCKS = conf.CELERYD_POOL_PUTLOCKS
CELERYD_POOL = conf.CELERYD_POOL
CELERYD_LISTENER = conf.CELERYD_CONSUMER
CELERYD_MEDIATOR = conf.CELERYD_MEDIATOR
CELERYD_ETA_SCHEDULER = conf.CELERYD_ETA_SCHEDULER
CELERYD_ETA_SCHEDULER_PRECISION = conf.CELERYD_ETA_SCHEDULER_PRECISION
ADM

SERVER_EMAIL = conf.SERVER_EMAIL
EMAIL_HOST = conf.EMAIL_HOST
EMAIL_HOST_USER = conf.EMAIL_HOST_USER
EMAIL_HOST_PASSWORD = conf.EMAIL_HOST_PASSWORD
EMAIL_PORT = conf.EMAIL_PORT
BROKER_HOST = conf.BROKER_HOST
BROKER_PORT = conf.BROKER_PORT
BROKER_USER = conf.BROKER_USER
BROKER_PASSWORD = conf.BROKER_PASSWORD
BROKER_VHOST = conf.BROKER_VHOST
BROKER_USE_SSL = conf.BROKER_USE_SSL
BROKER_INSIST = conf.BROKER_INSIST
BROKER_CONNECTION_TIMEOUT = conf.BROKER_CONNECTION_TIMEOUT
BROKER_CONNECTION_RETRY = conf.BROKER_CONNECTION_RETRY
BROKER_CONNECTION_MAX_RETRIES = conf.BROKER_CONNECTION_MAX_RETRIES
BROKER_BACKEND = conf.BROKER_BACKEND
DEFAULT_QUEUE = conf.CELERY_DEFAULT_QUEUE
DEFAULT_ROUTING_KEY = conf.CELERY_DEFAULT_ROUTING_KEY
DEFAULT_EXCHANGE = conf.CELERY_DEFAULT_EXCHANGE
DEFAULT_EXCHANGE_TYPE = conf.CELERY_DEFAULT_EXCHANGE_TYPE
DEFAULT_DELIVERY_MODE = conf.CELERY_DEFAULT_DELIVERY_MODE
QUEUES = conf.CELERY_QUEUES
CREATE_MISSING_QUEUES = conf.CELERY_CREATE_MISSING_QUEUES
ROUTES = conf.CELERY_
"""Build and check configuration for quattor documentation."""
logger = fancylogger.getLogger()
cfgfile = ".docbuilder.cfg"
def check_repository_map(repository_map):
    """Check if a repository mapping is valid."""
    logger.info("Checking repository map.")
    if repository_map is None:
        logger.error("Repository map is None.")
        return False
    if len(repository_map) == 0:
        logger.error("Repository map is an empty list.")
        return False
    for repository in repository_map.keys():
        keys = repository_map[repository].keys()
        for opt in ['targets', 'sitesection']:
            if opt not in keys:
                logger.error("Respository %s does not have a '%s' in repository_map." % (repository, opt))
                return False
        if type(repository_map[repository]['targets']) is not list:
            logger.error("Repository %s targets is not a list." % repository)
            return False
    return True
def build_repository_map(location

    """Build a repository mapping for repository_location."""
    logger.info("Building repository map in %s." % location)
    root_dirs = [f for f in os.listdir(location) if os.path.isdir(os.path.join(location, f))]
    repomap = {}
    for repo in root_dirs:
        logger.info("Checking %s." % repo)
        fullcfgfile = os.path.join(location, repo, cfgfile)
        if os.path.isfile(fullcfgfile):
            cfg = read_config(fullcfgfile)
            if cfg:
                repomap[repo] = cfg
            else:
                logger.warning("Invalid config file found in %s. Not using it." % repo)
        else:
            logger.warning("No config file found in %s. Not using it." % repo)
    if check_repository_map(repomap):
        return repomap
    else:
        return False
def read_config(configfile):
    """Read a given config file."""
    config = ConfigParser.ConfigParser()
    config.read(configfile)
    section = 'docbuilder'
    options = {}
    for option in ['sitesec
                            topic_edit, topic_manage, category_create, category_manage, category_edit, category_serialize,
                            user_data_serialize
                            )
urlpatterns = [
    url(r'^$', index, name='index'),
    url(r'^category/create$', category_create, name='category_create'),
    url(r'^category/all/$', category_manage, name='category_manage'),
    url(r'^category/all/serialize/$', category_serialize, name='category_serialize'),
    url(r'^category/(?P<category_id>\d+)/edit$', category_edit, name='category_edit'),
    url(r'^forum/all/$', forum_manage, name='forum_manage'),
    url(r'^forum/create/$', forum_create, name='forum_create'),
    url(r'^forum/(?P<forum_id>\d+)/edit/$', forum_edit, name='forum_edit'),
    url(r'^forum/all/data_serialize/$', forum_serialize, name='forum_serialize'),
    url(r'^topic/manage$', topic_manage, name='topic_manage'),
    url(r'^topic/(?P<topic_id>\d+)/edit$', topic_edit, name='topic_edit'),
    url(r'
@pytest.fixture(scope='module')
def controller(cloud):
    ''' Params needed for initialisation of the controller '''
    logging.basicConfig()
    if (cloud.get_cloud_type() == 'dummy'):
        return None
    config_parser = conftest.config_parser(cloud.get_cloud_type())
    config_parser.add_section('manager')
    config_parser.set('manager', 'TYPE', 'helloworld')
    config_parser.set('manager', 'SERVICE_ID', '1')
    config_parser.set('manager', 'USER_ID', '123')
    config_parser.set('manager', 'CREDIT_URL',
                      'https://localhost:5555/credit')
    config_parser.set('manager', 'TERMINATE_URL',
                      'https://localhost:5555/terminate')
    config_parser.set('manager', 'CA_URL',
                      'https://localhost:5555/ca')
    config_parser.set('manager', 'APP_ID', '1')
    controller = Controller(config_parser)
    controller._Controller__reservation_map['manager'].stop()
    mockedController = Mock(spec=controller)
    mockedController.ded
app = env.app = {
    'live_catalogue-repo': 'https://svn.eionet.europa.eu/repositories/Python/flis.live_catalogue',
    'localrepo': ppath(__file__).abspath().parent.parent,
except: pass
app.update({
    'instance_var': app['repo']/'instance',
    'manage_var': app['repo']/'live_catalogue',
    'live_catalogue_var': app['repo']/'live_catalogue'/'live_catalogue',
    'sandbox': app['repo']/'sandbox',
    'user': 'edw',
})
@task
def ssh():
    open_shell("cd '%(repo)s'" % app)
def _install_random_key(remote_path, key_length=20, mode=0600):
    vocabulary = string.ascii_letters + string.digits
    key = ''.join(random.choice(vocabulary) for c in xrange(key_length))
    put(StringIO(key), remote_path, mode=mode)
def _svn_repo(repo_path, origin_url, update=True):
    if not exists(repo_path/'.svn'):
        run("mkdir -p '%s'" % repo_path)
        with cd(repo_path):
            run("svn co '%s' ." % origin_url)
    elif update:
        with cd(repo_path):
            run("svn up")
@task
d

    _svn_repo(app['repo'], app['live_catalogue-repo'], update=True)
    if not exists(app['sandbox']):
        run("virtualenv --distribute '%(sandbox)s'" % app)
    run("%(sandbox)s/bin/pip install -r %(repo)s/requirements.txt" % app)
    if not exists(app['manage_var']/'media'):
        run("mkdir -p '%(manage_var)s/media'" % app)
    if not exists(app['instance_var']):
        run("mkdir -p '%(instance_var)s'" % app)
    if not exists(app['instance_var']/'files'):
        run("mkdir -p '%(instance_var)s/files'" % app)
    secret_key_path = app['instance_var']/'secret_key.txt'
    if not exists(secret_key_path):
        _install_random_key(str(secret_key_path))
    upload_template(app['localrepo']/'fabfile'/'supervisord.conf',
                    str(app['sandbox']/'supervisord.conf'),
                    context=app, backup=False)
    run("%s/bin/python %s/manage.py syncdb" % (app['sandbox'], app['manage_var']))
    run("%s/bin/python %s/manage.py migrate" % (app['sandbox'], app['m

    run("%s/bin/python %s/manage.py loaddata initial_categories" % (app['sandbox'], app['manage_var']))
    run("%s/bin/python %s/manage.py loaddata initial_flis_topics" % (app['sandbox'], app['manage_var']))
    run("%s/bin/python %s/manage.py loaddata initial_themes" % (app['sandbox'], app['manage_var']))
    run("%s/bin/python %s/manage.py collectstatic --noinput" % (app['sandbox'], app['manage_var']))
@task
def live_catalogue_supervisor():
    run("'%(sandbox)s/bin/supervisord'" % {
            'sandbox': app['sandbox'],
        })
@task
def update_live_catalogue():
    _svn_repo(app['repo'], app['live_catalogue-repo'], update=True)
    if not exists(app['sandbox']):
        run("virtualenv --distribute '%(sandbox)s'" % app)
    run("%(sandbox)s/bin/pip install -r %(repo)s/requirements.txt" % app)
    if not exists(app['manage_var']/'media'):
        run("mkdir -p '%(manage_var)s/media'" % app)
    if not exists(app['instance_var']):
        run("mkdir -p '%(instance_var)s'" % app
"""
Created on Wed Nov 30 16:37:44 2016
@author: Yara
"""
def FindPath(FolderName='RawDataCSVs'):
    cur_dir= os.getcwd()
    while True :
        file_list= os.listdir(cur_dir)
        parent_dir = os.path.dirname(cur_dir)
        if FolderName in file_list:
            path= cur_dir + os.sep + FolderName
            break
        else:
                print( "File not found, make sure your directory is not too wide...It would be preferred if you were in the repo ")
                break
            else:
                cur_dir = parent_dir
    return path
def Alliance(RawDataPath=[], Save= False, SavePath=[] ):
    if not RawDataPath:
        RawDataPath= FindPath()
    path_alliance= RawDataPath + os.sep +"alliance.csv"
    data=alliance[alliance.RelativeCommitment > -1]
    columns00length= len(alliance[alliance['country1.1'] > -1])
    temp= np.array([alliance['country1.1'], alliance['country2.1'],alliance['Year.1'],alliance['RelativeCommitment.1'] ]).T
    mat2= temp[0:columns0

    mat1= np.array([data.country1, data.country2, data.Year, data.RelativeCommitment]).T
    mat2= np.array(mat2, dtype= np.int32)
    mat1= np.array(mat1, dtype=np.int32)
    alliancearray= np.vstack([mat1,mat2])
    if Save is True:
        if not SavePath:
            curr_dir= os.getcwd()
            SavePath = curr_dir + os.sep +'Alliance'
        else:
            SavePath= SavePath + os.sep+'Alliance'
        np.save(SavePath, alliancearray)
    return alliancearray
def Conflict(RawDataPath=[], Save= False, SavePath=[] ):
    if not RawDataPath:
        RawDataPath= FindPath()
    path_conflict= RawDataPath + os.sep+"conflict.csv"
    temp= np.array([conflict['country1.1'], conflict['country2.1'],conflict['Year.1'],conflict['Conflict.1'] ]).T
    mat1= np.array([data.country1, data.country2, data.Year, data.Conflict]).T
    mat1= np.array(mat1, dtype=np.int32)
    conarray= np.vstack([mat1,mat2])
    if Save is True:
        if not SavePath:
            curr_dir= os.getcwd()
  

        else:
            SavePath= SavePath + os.sep +'Conflict'
        np.save(SavePath, conarray)
    return conarray
def Trade(RawDataPath=[], Save= False, SavePath=[] ):
    if not RawDataPath:
        RawDataPath= FindPath()
    path_trade= RawDataPath + os.sep +"trade.csv"
    data=pd.read_csv(path_trade)
    mat1= np.array([data.country1, data.country2, data.Year, data.Dependence]).T
    mat1= np.array(mat1, dtype=np.float)
    if Save is True:
        if not SavePath:
            curr_dir= os.getcwd()
            SavePath = curr_dir + os.sep + 'Trade'
        else:
            SavePath= SavePath + os.sep + 'Trade'
        np.save(SavePath, mat1)
    return mat1
def NCA(RawDataPath=[], Save= False, SavePath=[] ):
    if not RawDataPath:
        RawDataPath= FindPath()
    path_NCA= RawDataPath + os.sep + "fixedNCA.csv"
    NCA=pd.read_csv(path_NCA)
    data=NCA[NCA.Aggregated>= 0]
    mat1= np.array([data.country1, data.country2, data.Year, data.Aggregated]).T
    mat1= np.ar
LOG = logging.getLogger(__name__)
config = setup_app('monitor')
BROKER_URL = config.broker
if "amqp" in config.broker:
    default_exchange = Exchange('default')
    monitor_exchange = Exchange('monitor', type='fanout')
    reactor_exchange = Exchange('reactor', type='fanout')
    planner_exchange = Exchange('planner', type='fanout')
    CELERY_RESULT_BACKEND = "amqp"
    CELERY_QUEUES = (
        Queue('default', default_exchange, routing_key='default'),
        Queue('monitor', monitor_exchange, routing_key='monitor_%s' % config.hostname),
    )
elif "redis" in config.broker:
    CARROT_BACKEND = "redis"
    CELERY_RESULT_BACKEND = BROKER_URL
    CELERY_QUEUES = {
        "default": {"default": "default"},
    }
CELERY_RESULT_EXCHANGE = 'results'
CELERY_RESULT_EXCHANGE_TYPE = 'fanout'
CELERY_TASK_RESULT_EXPIRES = 120
CELERY_IMPORTS = (
    "monitor.tasks",
CELERY_DEFAULT_QUEUE = 'default'
CELERY_DEFAULT_EXCHANGE = 'default'
CELERY_DEFAULT_EXCHANGE_TYPE = 'topic'
CELERY_DEFAULT_ROUTIN
square_img = os.path.abspath(os.path.join(os.path.dirname(__file__), 'testdata', 'square_img.jpg'))
vert_img = os.path.abspath(os.path.join(os.path.dirname(__file__), 'testdata', 'vert_img.jpg'))
horiz_img = os.path.abspath(os.path.join(os.path.dirname(__file__), 'testdata', 'horiz_img.jpg'))
Transmogrify(square_img, [('a', '100x100'),]).save()
Transmogrify(vert_img, [('a', '100x100'),]).save()
Transmogrify(horiz_img, [('a', '100x100'),]).save()
Transmogrify(square_img, [('t', '200'),]).save()
Transmogrify(vert_img, [('t', '200'),]).save()
Transmogrify(horiz_img, [('t', '200'),]).save()
Transmogrify(square_img, [('t', 'x200'),]).save()
Transmogrify(vert_img, [('t', 'x200'),]).save()
Transmogrify(horiz_img, [('t', 'x200'),]).save()
Transmogrify(square_img, [('t', '200x200'),]).save()
Transmogrify(vert_img, [('t', '200x200'),]).save()
Transmogrify(horiz_img, [('t', '200x200'),]).save()
Transmogrify(square_img, [('r', '500'),]).save()
Transmogrify(vert_img, [('r', '500'),]).save()
Transmo

Transmogrify(square_img, [('r', 'x500'),]).save()
Transmogrify(vert_img, [('r', 'x500'),]).save()
Transmogrify(horiz_img, [('r', 'x500'),]).save()
Transmogrify(square_img, [('r', '500x500'),]).save()
Transmogrify(vert_img, [('r', '500x500'),]).save()
Transmogrify(horiz_img, [('r', '500x500'),]).save()
Transmogrify(square_img, [('l', '500x500-f00'),]).save()
Transmogrify(vert_img, [('l', '500x500-f00'),]).save()
Transmogrify(horiz_img, [('l', '500x500-f00'),]).save()
Transmogrify(square_img, [('l', '500x500-fffee1'),]).save()
Transmogrify(vert_img, [('l', '500x500-fffee1'),]).save()
Transmogrify(horiz_img, [('l', '500x500-fffee1'),]).save()
Transmogrify(square_img, [('s', '300x300'),]).save()
Transmogrify(vert_img, [('s', '300x300'),]).save()
Transmogrify(horiz_img, [('s', '300x300'),]).save()
Transmogrify(square_img, [('c', '100x100'),]).save()
Transmogrify(vert_img, [('c', '100x100'),]).save()
Transmogrify(horiz_img, [('c', '100x100'),]).save()
Transmogrify(square_img, [('r', '300x30
    def __init__(self, name):
        self.name = name
        self.label = name.replace('_', ' ').capitalize()
        self.description = self.label + ' ' + self.__class__.__name__.capitalize()
    def __str__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.label)
    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.label)
class Permission(ACObject): pass
admin_application = Permission('admin')
access_business = Permission('access_business')
manage_own_profile = Permission('manage_own_profile')
manage_invoices = Permission('manage_invoices')
manage_biz_profile = Permission('manage_biz_profile')
apply_membership = Permission('apply_membership')
view_own_invoices = Permission('view_own_invoices')
search_biz = Permission('search_biz')
approve_membership = Permission('approve_membership')
invite_member = Permission('invite_member')
activate_member = Permission('activate_member')
manage_team = Permission('manage_team')
class Role(ACObject): p
if len(sys.argv) == 1:
	print "requires at least one argument [path to gemsontuf]"
	print "can have two [path to gemsontuf] [path to client folder]"
	sys.exit()
if len(sys.argv) == 2:
	sys.argv.append("/tmp/.gemtuf/client")
generate_and_write_rsa_keypair("./key", bits=2048, password="password")
shutil.rmtree("./repository")
os.makedirs("./repository")
repository = create_new_repository("./repository")
repository.root.add_key(pubRootKey)
repository.targets.add_key(pubRootKey)
repository.release.add_key(pubRootKey)
repository.timestamp.add_key(pubRootKey)
repository.root.threshhold = 1
repository.root.load_signing_key(priRootKey)
repository.targets.load_signing_key(priRootKey)
repository.release.load_signing_key(priRootKey)
repository.timestamp.load_signing_key(priRootKey)
repository.timestamp.expiration = "2014-10-28 12:08:00"
os.rmdir("./repository/targets/")
shutil.copytree(sys.argv[1] + "repository/targets", "./repository/targets/")
list_of_targets = repository.get_filepaths_in_direc
npcdmod_broker = modulesctx.get_module('npcdmod')
Npcd_broker = npcdmod_broker.Npcd_broker
sys.setcheckinterval(10000)
modconf = Module()
modconf.module_name = "ncpd"
modconf.module_type = npcdmod_broker.properties['type']
modconf.modules = []
modconf.properties = npcdmod_broker.properties.copy()
class TestNpcd(ShinkenTest):
    def add(self, b):
        self.broks[b.id] = b
    def fake_check(self, ref, exit_status, output="OK"):
        print "fake", ref
        now = time.time()
        ref.schedule()
        check = ref.actions.pop()
        check.check_time = now
        check.output = output
        check.exit_status = exit_status
        check.execution_time = 0.001
        check.status = 'waitconsume'
        self.sched.waiting_results.append(check)
    def scheduler_loop(self, count, reflist):
        for ref in reflist:
            (obj, exit_status, output) = ref
            obj.checks_in_progress = []
        for loop in range(1, count + 1):
            print "processing ch

            for ref in reflist:
                (obj, exit_status, output) = ref
                obj.update_in_checking()
                self.fake_check(obj, exit_status, output)
            self.sched.consume_results()
            self.worker_loop()
            for ref in reflist:
                (obj, exit_status, output) = ref
                obj.checks_in_progress = []
            self.sched.update_downtimes_and_comments()
    def worker_loop(self):
        self.sched.delete_zombie_checks()
        self.sched.delete_zombie_actions()
        checks = self.sched.get_to_run_checks(True, False)
        actions = self.sched.get_to_run_checks(False, True)
        for a in actions:
            a.status = 'inpoller'
            a.exit_status = 0
            self.sched.put_results(a)
    def update_broker(self):
        self.sched.get_new_broks()
        ids = self.sched.brokers['Default-Broker']['broks'].keys()
        ids.sort()
        for i in ids:
            brok = self.sched.broker

            brok.prepare()
            self.npcdmod_broker.manage_brok(brok)
        self.sched.broks = {}
    def print_header(self):
    def write_correct_config(self):
        file = open("npcd.cfg", "w")
        file.write("perfdata_file = /tmp/pfnerf")
        file.write("perfdata_spool_dir = /tmp/pnp4shinken/var/perfdata")
        file.write("perfdata_spool_filename=pferf")
        file.close()
    def write_incomplete_config(self):
        file = open("npcd.cfg", "w")
        file.write("perfdata_file = /tmp/pfnerf")
        file.write("perfdata_spool_filename=pferf")
        file.close()
    def test_write_perfdata_file(self):
        self.print_header()
        if os.path.exists("./perfdata"):
            os.unlink("./perfdata")
        self.npcdmod_broker = Npcd_broker(modconf, None, './perfdata', '.', 'perfdata-target', 15)
        self.npcdmod_broker.properties['to_queue'] = 0
        self.npcdmod_broker.init()
        self.sched.conf.skip_initial_broks = False
        sel
__version__ = '0.1'
__all__ = ['core']
'''
    ('/api/info.*', 'api.core.Info'),
    ('/api/version.*', 'api.core.Version'),
    ('/api/debug_jqGrid.*', 'api.core.Debug_jqGrid'),
    ('/api/debug_geo.*', 'api.core.DebugGeo'),
    ('/api/get_geo.*', 'api.core.GetGeo'),
    ('/api/gmap/ceng*', 'api.core.GMapCeng'),
    ('/api/misc/drivers*', 'api.core.Sys_Misc_Drivers'),
    ('/api/admin/operations*', 'api.core.Admin_Operations'),
    ('/api/geo/del.*', 'api.geo.Del'),
    ('/api/geo/taskdel.*', 'api.geo.Task_Del'),
    ('/api/geo/get*', 'api.geo.Get'),
    ('/api/geo/dates*', 'api.geo.Dates'),
    ('/api/geo/info*', 'api.geo.Info'),
    ('/api/geo/last*', 'api.geo.Last'),
    ('/api/geo/count*', 'api.geo.Count'),
    ('/api/geo/report*', 'api.geo.Report'),
    ('/api/geo/purge*', 'api.geo.Purge'),
    ('/api/report/get*', 'api.report.Get'),
    ('/api/export/xls*', 'api.export.XLS'),
    ('/api/export/list*', 'api.export.List'),
    ('/api/export/del*', 'api.export.Del'),
    ('/api/exp

    ('/api/system/add*', 'api.system.Add'),
    ('/api/system/del*', 'api.system.Del'),
    ('/api/system/desc*', 'api.system.Desc'),
    ('/api/system/sort*', 'api.system.Sort'),
    ('/api/system/config*', 'api.system.Config'),
    ('/api/system/tags*', 'api.system.Tags'),
    ('/api/system/car*', 'api.system.Car'),
    ('/api/system/secure_list*', 'api.system.SecureList'),
    ('/api/system/saveconfig*', 'api.system.SaveConfig'),
    ('/api/system/seticon*', 'api.system.SetIcon'),
    ('/api/param/desc*', 'api.param.Desc'),
    ('/api/logs/get*', 'api.logs.Get'),
    ('/api/logs/del*', 'api.logs.Del'),
    ('/api/zone/add*', 'api.zone.Add'),
    ('/api/zone/get*', 'api.zone.Get'),
    ('/api/zone/del*', 'api.zone.Del'),
    ('/api/zone/info*', 'api.zone.Info'),
    ('/api/zone/rule/create*', 'api.zone.Rule_Create'),
    ('/api/zone/rule/get*', 'api.zone.Rule_Get'),
    ('/api/zone/rule/del*', 'api.zone.Rule_Del'),
    ('/api/alarm/confirm*', 'api.alarm.Confirm'),
    ('/api/alarm/c
FACETS = [
    FacetClass(
        "country",
        "Country",
        renderfn=utils.country_name_from_code,
    )
urlpatterns = patterns('',
    url(r'^search/?$', views.PortalSearchListView.as_view(
        model=models.Repository,
        facetclasses=FACETS,
        template_name="repository_search.html"), name='repository_search'),
    url(r'^search/(?P<facet>[^\/]+)/?$', views.PaginatedFacetView.as_view(
        redirect='repository_search',
        form_class=forms.FacetListSearchForm,
        model=models.Repository,
        facetclasses=FACETS),
            name='collection_facets'),
    url(r'^/?$', views.PortalListView.as_view(
        model=models.Repository,
        template_name="repository_list.html",
        ), name='repository_list'),
    url(r'^create/?$', 
            user_passes_test(permissions.is_staff)(
                views.RepositoryEditView.as_view()), name='repository_create'),
    url(r'^edit/(?P<slug>[-\w]+)/?$',
            user_passes_test(permissions.

                views.RepositoryEditView.as_view()), name='repository_edit'),
    url(r'^delete/(?P<slug>[-\w]+)/?$', 
            user_passes_test(permissions.is_staff)(
                views.RepositoryDeleteView.as_view()), name='repository_delete'),
    url(r'^history/(?P<slug>[-\w]+)/?$', views.PortalHistoryView.as_view(
            model=models.Repository,
        ), name='repository_history'),
    url(r'^restore/(?P<slug>[-\w]+)/v/(?P<revision>\d+)/?$', views.PortalRestoreView.as_view(
            model=models.Repository,
        ), name='repository_restore'),
    url(r'^diff/(?P<slug>[-\w]+)/?$', views.PortalRevisionDiffView.as_view(
            model=models.Repository,
            template_name="repository_diff.html",
        ), name='repository_diff'),
    url(r'^(?P<slug>[-\w]+)/collections/create/?$', 
            views.RepositoryCollectionCreateView.as_view(), 
                name='repository_collection_create'),
    
    url(r'^(?P<slug>[-\w]+)/v/(?P<revision>\d+)/?$', v
class Crittstarter(object):
    def __init__(self):
        self.mTree = ElementTree.parse('CrittWorkPlan.xml')
        self.mRoot = self.mTree.getroot()
        self.mSettings = {}
        self.mCrittBrokerData = {}
        self.mCritterData = {}
    def start(self):
        self.__getSettings()
        self.__readCrittBrokers()
        self.__readCritters()
        self.__startCrittBrokers()
        self.__startCritters()
    def __getSettings(self):
        settings = self.mRoot.find('settings')
        self.mSettings['username'] = settings.find('username').text
        self.mSettings['workingDirectory'] = settings.find('workingDirectory').text
        self.mSettings['heartbeat'] = settings.find('heartbeat').text
        self.mSettings['maxDelay'] = settings.find('maxDelay').text
        self.mCrittBrokerData = {}
    def __readCrittBrokers(self):
        crittBrokers = self.mRoot.find('infrastructure').find('crittBrokers')
        for crittBroker in crittBrokers:
            name =

            self.mCrittBrokerData[name] = {}
            self.mCrittBrokerData[name]['name'] = crittBroker.find('name').text
            self.mCrittBrokerData[name]['host'] = crittBroker.find('host').text
            self.mCrittBrokerData[name]['connections'] = {}
            self.mCrittBrokerData[name]['connections']['publish'] = {}
            self.mCrittBrokerData[name]['connections']['subscribe'] = {}
            self.mCrittBrokerData[name]['connections']['ui'] = {}
            self.mCrittBrokerData[name]['connections']['brokerPublish'] = {}
            connections = crittBroker.find('connections')
            self.mCrittBrokerData[name]['connections']['publish']['protocol'] = connections.find('publish').find('protocol').text
            self.mCrittBrokerData[name]['connections']['publish']['port'] = connections.find('publish').find('port').text
            self.mCrittBrokerData[name]['connections']['subscribe']['protocol'] = connections.find('subscribe').find('protocol').text
   

            self.mCrittBrokerData[name]['connections']['ui']['protocol'] = connections.find('ui').find('protocol').text
            self.mCrittBrokerData[name]['connections']['ui']['port'] = connections.find('ui').find('port').text
            self.mCrittBrokerData[name]['connections']['brokerPublish']['protocol'] = connections.find('brokerPublish').find('protocol').text
            self.mCrittBrokerData[name]['connections']['brokerPublish']['port'] = connections.find('brokerPublish').find('port').text
            self.mCrittBrokerData[name]['brokers'] = []
            for brokerConnection in connections.find('brokers'):
                self.mCrittBrokerData[name]['brokers'].append(brokerConnection.find('name').text)
    def __readCritters(self):
        critters = self.mRoot.find('infrastructure').find('critters')
        for critter in critters:
            crittnick = critter.find('crittnick').text
            self.mCritterData[crittnick] = {}
            self.mCritterData[crittnic
sys.path.append('..')
if(len(sys.argv) <= 1):
    print "no save object: all, ascii"
    sys.exit(1)
SAVE_OBJECT = sys.argv[1]
if(len(sys.argv) <= 2):
    print "no save directory"
    sys.exit(1)
SAVE_DIR = sys.argv[2]
def cut(image):
    l = -1 
    r = -1 
    l = -1 
    d = -1 
    for i in range(image.size[0]):
        if(not is_vline(image, i, 0)):
            l = i
            break
    for i in range(image.size[0]-1, -1, -1):
        if(not is_vline(image, i, 0)):
            r = i+1
            break
    for i in range(image.size[1]):
        if(not is_hline(image, i, 0)):
            u = i
            break
    for i in range(image.size[1]-1, -1, -1):
        if(not is_hline(image, i, 0)):
            d = i+1
            break
    if(l == -1):
        return image
    return image.crop((l,u,r,d))
def save_at(i):
    ch = unichr(i)
    print(u"{0}:[{1}]".format(hex(i), ch))
    image = get_word_image(ch)
    barray = g_to_barray(image.getdata())
    gimg = Image.new("L", imag

    gimg.putdata(b_to_garray(barray))
    gimg = cut(gimg).resize((20,20))
    name = "{0:0>4}".format(hex(i)[2:].upper())
    gimg.save(SAVE_DIR + "/{0}.png".format(name))
def save_range(start, end):
    for i in range(start, end + 1):
        save_at(i)
zenkaku_symbol_list = [
        u"、",
        u"。",
        u"？",
        u"「",
        u"」",
        u"『",
        u"』",
        u"○",
        u"ー",
        u"＆",
        u"％",
        u"＃",
        u"＄",
        u"！",
        u"＊",
        u"＝",
        u"＋",
        ]
zenkaku_kanji_list = [
        u"門",
        u"鮎",
        u"安",
        u"井",
        u"戸",
        u"右", u"左", u"上", u"下",
        u"鳥",
        u"白", u"赤", u"青", u"黒", u"黄",
        u"色",
        u"永",
        u"駅",
        u"王",
        u"化",
        u"口", u"因", u"国",
        u"日", u"年", u"月",
        u"花", u"草",
        u"海", u"湖",
        u"外",
        u"本",
        u"学",
        u"甘",
        u"辛",
        u"丸",
        u"二", u"三", u"四", u"五", u"六", u"七", u"八"

        u"百", u"千", u"万", u"億",
        u"曲",
        u"犬", u"猫",
        u"野", u"球",
        u"見",
        u"工",
        u"作",
        u"子",
        u"親",
        u"次",
        u"人",
        u"中",
        u"何",
        u"夏", u"秋", u"冬", u"春",
        u"朝", u"昼", u"夜",
        u"東", u"西", u"南", u"北",
        u"文",
        u"漫", u"画", u"映",
        u"英", u"語",
        u"呼",
        u"表",
        u"動", u"虫", u"物",
        ]
zenkaku_kana_list = [
        u"あ", u"い", u"う", u"え", u"お",
        u"か", u"き", u"く", u"け", u"こ",
        u"さ", u"し", u"す", u"せ", u"そ",
        u"た", u"ち", u"つ", u"て", u"と",
        u"な", u"に", u"ぬ", u"ね", u"の",
        u"は", u"ひ", u"ふ", u"へ", u"ほ",
        u"ま", u"み", u"む", u"め", u"も",
        u"や", u"ゆ", u"よ",
        u"ゃ", u"ゅ", u"ょ",
        u"ら", u"り", u"る", u"れ", u"ろ",
        u"わ", u"を", u"ん",
        u"ア", u"イ", u"ウ", u"エ", u"オ",
        u"カ", u"キ", u"ク", u"ケ", u"コ",
        u"サ", u"シ", u"ス", u"セ", u"ソ",
        u"タ", u"チ", u"ツ", u"テ", u"ト",
        u"ナ", u"ニ
"""
VMController Host - a general purpose host-side virtual machine controller via exposed hypervisors apis.
"""
try:
except ImportError, e:
    print "Import error in %s : %s" % (__name__, e)
    sys.exit()
logger = logging.getLogger(__name__)
def init_logging(logfile=None, loglevel=logging.INFO):
    """
    Sets logging configuration.
    @param logfile: File to log messages. Default is None.
    @param loglevel: Log level. Default is logging.INFO.
    """
    format = '%(asctime)s - [%(threadName)s] %(filename)s:%(lineno)s - (%(levelname)s) %(message)s'
    if logfile:
        logging.basicConfig(filename=logfile, level=loglevel, format=format)
    else:
        logging.basicConfig(level=loglevel, format=format)
def init():
    """
    Initializes VMController Host package.
    First parses command line options. Then, creates config object from default cfg file.
    Re-initializes config object if a config file is supplied and sets logger configuration.
    Finally, uses dependency

    """
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="configfile",
                      help="Read configuration from FILE. (Overrides default config file.)", metavar="FILE")
    parser.add_option("-a", "--host", dest="xmlrpc_host",
                      help="Listen on specified address for XMLRPC interface (default 127.0.0.1)", metavar="ADDR")
    parser.add_option("-p", "--port", dest="xmlrpc_port",
                      help="Listen on specified port for XMLRPC interface (default 50505)", type="int", metavar="PORT")
    parser.add_option("-l", "--logfile", dest="logfile",
                      help="Log to specified file.", metavar="FILE")
    parser.add_option("--debug", action="store_true", dest="debug", default=False, 
                      help="Sets logging to debug (unless logging configured in config file).")
    (options, args) = parser.parse_args()
    config = init_config()
    injector = inject.Injector()
    inject.register(injector)
    in

    injector.bind('stompEngine', to=HostStompEngine, scope=inject.appscope)
    injector.bind('words', to=HostWords.getWords) 
    injector.bind('stompProtocol', to=StompProtocol, scope=inject.appscope)
    injector.bind('subject', to=Host) 
    injector.bind('hvController', to=HyperVisorController)
    init_config_file(options.configfile)
    if options.xmlrpc_host is not None:
        config.set('xmlrpc', 'host', options.xmlrpc_host)
        
    if options.xmlrpc_port is not None:
        config.set('xmlrpc', 'port', str(options.xmlrpc_port))
    level = logging.DEBUG if options.debug else logging.INFO
    init_logging(logfile=options.logfile, loglevel=level)
def start_coilmq(config, server_event, tries=-1, delay=1, backoff=1.5):
    """
    Starts CoilMQ broker.
    @param config: Config for CoilMQ.
    @param server_event: Event attached to multiprocessing manager.
    @param tries: Maximum retries to start the server. Default -1 (infinite).
    @param delay: Time to wait before 
__author__ = 'snipe'
class EventsGetter():
    db = None
    csv_files = None
    csv_data = None
    first_row = None
    def open_mongo_db(self):
        self.db = MongoClient(host='localhost', port=27017)
    def print_to_csv(self, data):
        with codecs.open('csv/export_labels.csv', 'a+', 'utf-8-sig') as f:
            f.write(u"repository_owner;repository_url;repository_name;issue;label")
            for item in data:
                try:
                    f.write(u"\r\n"+'u"%(repository_owner)s";"%(repository_url)s";"%(repository_name)s";"%(issue)s";"%(label)s"' % item)
                except Exception, e:
                    print e, item
    def get_data(self):
        issues = self.db.wikiteams.labels.find()
        ev = []
        for issue in issues:
            print '.',
            for label in issue['labels']:
                tmp = {'repository_owner': issue['repository_owner'], 'repository_url': issue['repository_url'], 'repository_name': issue['repository_name'],
'''
Created on 1 dec. 2014
@author: Narcis2007
'''
class TestRepositoryPlab(unittest.TestCase):
    def setUp(self):
        self.__repository=RepositoryUniversal(ValidatorPlab())
        p1=ProblemaLaborator(1,1,"w","t")
        p2=ProblemaLaborator(2,2,"t","y")
        p3=ProblemaLaborator(3,3,"g","h")
        self.__repository.save(p1)
        self.__repository.save(p2)
        self.__repository.save(p3)
    
    def test_save(self):
        p1=ProblemaLaborator(1,1,"w","t")
        self.assertRaises(EroareID,lambda: self.__repository.save(p1))
            
    def test_lungime(self):
        assert self.__repository.lungime()==3
    
    def test_delete(self):
        self.__repository.delete(11)
        assert self.__repository.lungime()==2
        self.assertRaises(EroareID, lambda:self.__repository.delete(11))
    def test_find(self):
        p=self.__repository.find(22)
        p2=ProblemaLaborator(2,2,"t","y")
        assert p==p2
    
    def test_update(self):
        p2=Pro
class NoneHandler(ResponseHandler):
    type = types.NoneType
    def process(self, handler, result):
        if handler.meta.view.auto_render:
            handler._clear_redirect()
            handler.response = handler.meta.view.render()
        return handler.response
class SplitView(object):
    def __init__(self, controller):
        self.controller = controller
        controller.events.after_dispatch += self.on_after_dispatch
        controller.events.before_dispatch += self.on_before_dispatch
        controller.events.scaffold_before_apply += self.on_scaffold_before_apply
    def on_before_dispatch(self, controller):
        if 'paginate' in self.controller.components:
            self.controller.components.pagination.auto_paginate = False
    def on_after_dispatch(self, controller, response):
        if controller.route.action == 'list':
            controller.context['has_splitview_component'] = True
            controller.context['full_url'] = controller.request.url.split('&

            old_context = controller.context.get(controller.meta.sv_result_variable)
            try:
                status = controller.request.params['status']
            except:
                status = 1
            _type = str(type(controller.context.get(controller.meta.sv_result_variable)))
            if _type == "<type 'list'>":
                logging.info("LIST DETECTED =====> %s", controller.context.get(controller.meta.sv_result_variable))
                pass
            else:
                self.check_content(old_context, controller)
                self.apply_filter(controller, status, old_context)
    def apply_filter(self, controller, status, old_context):
        approval_level = self.approval_level(controller, status)
        if status == 'all' or approval_level == 'all':
            controller.components.pagination.auto_paginate = True
            controller.components.pagination.paginate(old_context)
            pass
        else:
            field = eval('contr

            if controller.name == 'replenishments':
                result = old_context.filter(field == approval_level)
            else:
                if int(status) > 0 and int(status) < 6:
                    result = old_context.filter(field == int(status))
                else:
                    result = old_context.filter(field == 1)
            controller.context[controller.meta.sv_result_variable] = result
            controller.components.pagination.pagination_limit = 10
            controller.components.pagination.auto_paginate = True
            logging.info("result ===============> %s", result)
            controller.components.pagination.paginate(query=result, cursor=controller.request.get('cursor'))
    def check_content(self, context, controller):
        logging.info("context ======>" + str(context.fetch()))
        if not context.fetch():
            if controller.route.action == 'list':
                controller.meta.view.auto_render = False
                key
def ping(cfg, args):
    """Perform a ping to check config."""
    api = UserApi(cfg.api_url, cfg.username, cfg.api_key)
    api.ping()
def applog(cfg, args):
    """Load the applog entries."""
    api = AdminApi(cfg.api_url, cfg.username, cfg.api_key)
    api.applog(
       args.days,
       args.status,
       args.filter)
def to_readable(cfg, args):
    """Check the list of urls we need to readable parse still."""
    api = AdminApi(cfg.api_url, cfg.username, cfg.api_key)
    api.to_readable()
def readable_reindex(cfg, args):
    """Reindex all the bookmarks in the system."""
    api = AdminApi(cfg.api_url, cfg.username, cfg.api_key)
    api.readable_reindex()
def invite_list(cfg, args):
    """Handle the invite list call."""
    api = AdminApi(cfg.api_url, cfg.username, cfg.api_key)
    api.invite_status()
def invite_set(cfg, args):
    """Handle the invite set call to add invites to a user."""
    api = AdminApi(cfg.api_url, cfg.username, cfg.api_key)
    api.invite_set(args.usern
"""
This module contains functions for API discovery.
"""
def cuda_id():
    """Returns the identifier of the ``PyCUDA``-based API."""
    return 'cuda'
def ocl_id():
    """Returns the identifier of the ``PyOpenCL``-based API."""
    return 'ocl'
def api_ids():
    """
    Returns a list of identifiers for all known
    (not necessarily available for the current system) APIs.
    """
    return [ocl_id(), cuda_id()]
def supports_api(api_id):
    """
    Returns ``True`` if given API is supported.
    """
    try:
        get_api(api_id)
    except ImportError:
        return False
    return True
def supported_api_ids():
    """
    Returns a list of identifiers of supported APIs.
    """
    return [api_id for api_id in api_ids() if supports_api(api_id)]
def get_api(api_id):
    """
    Returns an API module with the generalized interface :py:mod:`reikna.cluda.api`
    for the given identifier.
    """
    if api_id == cuda_id():
        return reikna.cluda.cuda
    elif api_id == oc
MIDI_CHANNEL = 1
TEXT_CONTROLLER = 0
BG_CONTROLLER = 1
PREV_CONTROLLER = 43
NEXT_CONTROLLER = 44
BLANK_TEXT_CONTROLLER = 64
BLANK_BG_CONTROLLER = 65
BLANK_ALL_CONTROLLER = 45
LOGO_CONTROLLER = 19
ON_VALUE = 127
OFF_VALUE = 0
def print_message(midi, textSlider, bgSlider, app):
  try:
    if midi.isController():
      if midi.getControllerNumber() == TEXT_CONTROLLER:
        newSpeed = round(((midi.getControllerValue() / 127.0) * 3), 1)
        textSlider.AXValue = newSpeed
      elif midi.getControllerNumber() == BG_CONTROLLER:
        newSpeed = round(((midi.getControllerValue() / 127.0) * 3), 1)
        bgSlider.AXValue = newSpeed
      elif midi.getControllerNumber() == PREV_CONTROLLER and midi.getControllerValue() == ON_VALUE:
        app.sendKey(atomac.AXKeyboard.LEFT)
      elif midi.getControllerNumber() == NEXT_CONTROLLER and midi.getControllerValue() == ON_VALUE:
        app.sendKey(atomac.AXKeyboard.RIGHT)
      elif midi.getControllerNumber() == BLANK_TEXT_CONTROLLER and midi

        app.sendKey(atomac.AXKeyboard.F2)
      elif midi.getControllerNumber() == BLANK_BG_CONTROLLER and midi.getControllerValue() == ON_VALUE:
        app.sendKey(atomac.AXKeyboard.F3)
      elif midi.getControllerNumber() == BLANK_ALL_CONTROLLER and midi.getControllerValue() == ON_VALUE:
        app.sendKey(atomac.AXKeyboard.F1) 
      elif midi.getControllerNumber() == LOGO_CONTROLLER and midi.getControllerValue() == ON_VALUE:
        app.sendKey(atomac.AXKeyboard.F6) 
      else:
        print 'CONTROLLER', midi.getControllerNumber(), midi.getControllerValue()
  except atomac._a11y.ErrorInvalidUIElement:
    pass
  
def setUpLights():
  midiout = rtmidi.RtMidiOut()
  ports = range(midiout.getPortCount())
  if ports:
    for i in ports:
      print i, midiout.getPortName(i)
    midiout.openPort(0)
    midiout.sendMessage(rtmidi.MidiMessage.controllerEvent(MIDI_CHANNEL, PREV_CONTROLLER, ON_VALUE))
    midiout.sendMessage(rtmidi.MidiMessage.controllerEvent(MIDI_CHANNEL, NEXT_CONTRO

    midiout.sendMessage(rtmidi.MidiMessage.controllerEvent(MIDI_CHANNEL, BLANK_TEXT_CONTROLLER, ON_VALUE))
    midiout.sendMessage(rtmidi.MidiMessage.controllerEvent(MIDI_CHANNEL, BLANK_BG_CONTROLLER, ON_VALUE))
    midiout.sendMessage(rtmidi.MidiMessage.controllerEvent(MIDI_CHANNEL, BLANK_ALL_CONTROLLER, ON_VALUE))
    midiout.sendMessage(rtmidi.MidiMessage.controllerEvent(MIDI_CHANNEL, LOGO_CONTROLLER, ON_VALUE))
  return midiout
def main():
  print "Getting transition sliders..."
  pp = atomac.getAppRefByBundleId("com.renewedvision.ProPresenter4")
  textSlider = pp.findFirstR(AXRole="AXSlider", AXHelp="Slide transition time")
  bgSlider = pp.findFirstR(AXRole="AXSlider", AXHelp="Image/Video transition time")
  
  print "Getting available MIDI controllers..."
  
  midiin = rtmidi.RtMidiIn()
  ports = range(midiin.getPortCount())
  if ports:
    for i in ports:
      print i, midiin.getPortName(i)
    print "Setting up lights..."
    midiout = setUpLights()
    midiin.openPort(0)
   
__author__ = 'qianfunian'
connection = MySQLdb.connect(user="readonly_v2", passwd="aNjuKe9dx1Pdw", host='10.10.8.128', db="mobile_db")
cursor = connection.cursor()
globalBrokerIds = {}
pageCount = 10
timeFile = open('time.log', 'a+')
start = int(time.time())
def generateData(brokerIds):
    for brokerId in brokerIds:
        if (globalBrokerIds.has_key(brokerId[0])):
            continue
        globalBrokerIds[brokerId[0]] = ''
        sql = 'select count(*) from (select  community_id from broker_community_sign_201410 where broker_id=' \
              + str(
            brokerId[0]) + ' union select  community_id from broker_community_sign_201411 where broker_id=' + str(
            brokerId[0]) + ' )as tmp'
        cursor.execute(sql)
        data = cursor.fetchall()
        AJKDBConnection = MySQLdb.connect(user="readonly_v2", passwd="aNjuKe9dx1Pdw", host='10.10.8.80',
                                          db="anjuke_db")
        sql = 'select ajk_brokerextend.BrokerId,ajk_broke

              'ajk_brokerextend.CityId,ajk_brokerextend.BelongCom,ajk_citytype.CityName from ajk_brokerextend ' \
              'left join ajk_citytype on ajk_brokerextend.CityId=ajk_citytype.CityId where BrokerId= ' + str(
            brokerId[0])
        AJKCursor = AJKDBConnection.cursor()
        AJKCursor.execute(sql)
        brokerInfo = AJKCursor.fetchall()
        for info in brokerInfo[0]:
            file_object.write(str(info) + ',')
        file_object.write(str(data[0][0]) + '\n')
    pass
for db in ['broker_community_sign_201410', 'broker_community_sign_201411']:
    page = 1
    while True:
        offset = (page - 1) * pageCount
        sql = 'select distinct broker_id from ' + db + ' order by broker_id desc limit ' + offset.__str__() + ',10'
        cursor.execute(sql)
        brokerIds = cursor.fetchall()
        if (brokerIds == ()):
            break
        file_object = open('thefile.csv', 'a+')
        generateData(brokerIds)
        page += 1
        file_objec
timeout = 5
socket.setdefaulttimeout(timeout)
PROVISION_BASE = '/provision'
PROVISION_ACTIVATE         = PROVISION_BASE +  '/activate'
PROVISION_DOWNLOAD         = PROVISION_BASE + '/download'
PROVISION_MANAGE           = PROVISION_BASE + '/manage'
PROVISION_MANAGE_MODEL     = PROVISION_MANAGE + '/model/'
PROVISION_MANAGE_CONTENT   = PROVISION_MANAGE + '/content/'
PROVISION_REGISTER         = PROVISION_BASE + '/register'
class Provision(object):
  def __init__(self, host='http://m2.exosite.com', manage_by_cik=True):
    self._host = host
    self._manage_by_cik = manage_by_cik
  def _filter_options(self, aliases=True, comments= True, historical=True):
    options = []
    if not aliases: options.append('noaliases')
    if not comments: options.append('nocomments')
    if not historical: options.append('nohistorical')
    return options
  def _request(self, path, key, data, method, is_cik=True, extra_headers={}):
    if method == "GET":
      url = self._host + path + '?' + data
      r

    else:
      url = self._host + path
      req = urllib2.Request(url, data)
    if is_cik:
      req.add_header('X-Exosite-CIK',key)
    else:
      req.add_header('X-Exosite-Token',key)
    req.add_header('Accept',
                   'text/plain, text/csv, application/x-www-form-urlencoded')
    for name in extra_headers.keys():
      req.add_header(name, extra_headers[name])
    req.get_method = lambda : method
    try:
      resp = urllib2.urlopen(req)
      resp_data = resp.read()
      resp.close()
      return resp_data
    except HTTPError, e:
      print 'Http error code: ' + str(e.code)
    except URLError, e:
      print 'Failed to reach server! Reason: ' + str(e.reason)
    except Exception,e:
      print "Caught exception from provision:", e
    return None
  def content_create(self, key, model, contentid, description):
    data = urllib.urlencode({'id':contentid, 'description':description})
    path = PROVISION_MANAGE_CONTENT + model + '/'
    return self._request(path

  def content_download(self, cik, vendor, model, contentid):
    data = urllib.urlencode({'vendor':vendor, 'model': model, 'id':contentid})
    headers = {"Accept":"*"}
    return self._request(PROVISION_DOWNLOAD, cik, data, 'GET', True, headers)
  def content_info(self, key, model, contentid, vendor=None):
      path = PROVISION_MANAGE_CONTENT + model + '/' + contentid
      return self._request(path, key, '', 'GET', self._manage_by_cik)
      data = urllib.urlencode({'vendor':vendor, 'model': model, \
              'id':contentid, 'info':'true'})
      return self._request(PROVISION_DOWNLOAD, key, data, 'GET')
  def content_list(self, key, model):
    path = PROVISION_MANAGE_CONTENT + model + '/'
    return self._request(path, key, '', 'GET', self._manage_by_cik)
  def content_remove(self, key, model, contentid):
    path = PROVISION_MANAGE_CONTENT + model + '/' + contentid
    return self._request(path, key, '', 'DELETE', self._manage_by_cik) != None
  def content_upload(self, key,
'''
Created on 03-07-2013
'''
class Repository(Node):
    element_type = "team"
    
    repository_url = String(nullable=False)
    repository_has_downloads = None(nullable=True)
    repository_created_at = String(nullable=False)
    repository_has_issues = None(nullable=True)
    repository_description = String(nullable=True)
    repository_forks = Integer(nullable=True)
    repository_fork  = String(nullable=True)
    repository_has_wiki  = None(nullable=True)
    repository_homepage = String(nullable=True)
    repository_size = Integer(nullable=True)
    repository_private = String(nullable=True)
    repository_name = String(nullable=True)
    repository_owner = String(nullable=True)
    repository_open_issues = Integer(nullable=True)
    repository_watchers = Integer(nullable=True)
    repository_pushed_at = String(nullable=True)
    repository_language = String(nullable=True)
    repository_organization = String(nullable=True)
    repository_integrate_branch = String(nullable=Tru
class ClassLevel:
    def __init__(self, value, bab, fort_save, ref_save, will_save, specials):
        self.value = value
        self.bab = bab
        self.fort_save = fort_save
        self.ref_save= ref_save
        self.will_save = will_save
        self.specials = specials
        self.spells_per_day = None
        self.spells_known = None
class MonkLevel(ClassLevel):
    def __init__(self, value, bab, fort_save, ref_save, will_save, specials):
        ClassLevel.__init__(self, value, bab, fort_save, ref_save, will_save, specials)
        self.flurry_bonus = None
    def setFlurryBonus(self, value):
        self.flurry_bonus = value
    def setUnarmedDamage(self, value):
        self.unarmed_damage = None
    def setACBonus(self, value):
        self.ac_bonus = value
    def setFastMovement(self, value):
        self.fast_movement = value
class GameClass:
    def __init__(self):
        self.name = None
        self.base_attack_bonus = []
        self.level = 0
        self.fort
opt_parser = OptionParser()
opt_parser.add_option("-r",
                      "--routing-key",
                      dest="routing_key",
                      help="Routing key for message (e.g. myalert.im)")
opt_parser.add_option("-m",
                      "--message",
                      dest="message", 
                      help="Message text for alert.")
args = opt_parser.parse_args()[0]
creds_broker = pika.PlainCredentials("alert_user", "alertme")
conn_params = pika.ConnectionParameters("localhost",
                                        virtual_host = "/",
                                        credentials = creds_broker)
conn_broker = pika.BlockingConnection(conn_params)
channel = conn_broker.channel()
msg = json.dumps(args.message)
msg_props = pika.BasicProperties()
msg_props.content_type = "application/json"
msg_props.durable = False
channel.basic_publish(body=msg,
                      exchange="alerts",
                      properties=msg_props,
                      
@task
def build():
    """
    Build project environment.
    """
    stage('Updating virtual environment...')
    do('[ -d venv ] || virtualenv venv --no-site-packages --python=python2.7')
    do('venv/bin/pip install --upgrade -r requirements.txt')
    stage('Update assets...')
    manage('compilemessages')
    manage('collectstatic --noinput -v 0')
    stage('Updating database...')
    manage('syncdb --noinput')
    manage('migrate --noinput')
@task
def r(cmd="127.0.0.1:8000"):
    """
    Start project in debug mode (for development).
    """
    manage('runserver_plus {0}'.format(cmd))
@task
def run(cmd="127.0.0.1:8000"):
    """
    Start project in debug mode (for development).
    """
    manage('runserver {0}'.format(cmd))
@task
def manage(cmd):
    """
    Run django manage `cmd`
    """
    return do('venv/bin/python ./manage.py {0}'.format(cmd))
@task
def test(cmd='--noinput'):
    return manage('test {0}'.format(cmd))
def stage(message):
    """
    Show `message` about cu
class TestApiFactory(unittest.TestCase):
    def setUp(self):
        print "cwd: ", os.getcwd()
        path = os.path.realpath("config/ipc")
        ConfigurationManager(cwd=path)
        self.apis = []
    def tearDown(self):
        ConfigurationManager.destroySingleton()
        for api in self.apis:
            try:    api.teardown()
            except: pass
    def testValid(self):
        t = eApiType.EO_V1
        assert eApiType.isValid(t)
        api_ = ApiFactory.get(t)
        self.apis.append(api_)
        assert isinstance(api_, iApi)
        t = eApiType.EO_V1__HANDLER
        assert eApiType.isValid(t)
        api_ = ApiFactory.get(t)
        self.apis.append(api_)
        assert isinstance(api_, iApi)
    def testInvalidType(self):
        t = eApiType.EO_V1 + "hello.world!"
        assert not eApiType.isValid(t)
        try:
            ApiFactory.get(t)
        except ApiParamError, e:
            assert e.item == t
            assert eApiType in e.allowedTypes
    
def usage():
    """
    Usage function
    """
    print("""Usage: %s -b <Broker IP-address:Port> -t <topic>
-h    Show this help message and exit
-b    Specify different broker IP-address and port, default "jedibroker.ikp.kfa-juelich.de:1883"
-t    Retained MQTT topic to delete
""" % sys.argv[0])
def main(argv):
    brokerPort = 1883
    try:         
        opts, args = getopt.getopt(argv, "hb:t:")
    except getopt.GetoptError as err:
        print(str(err)+"\n")
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt == "-h":
            usage()
            sys.exit()
        elif opt == "-b":
            brokerIP= arg.split(":")[0]
            brokerPort = float(arg.split(":")[1])
        elif opt == "-t":
            topic = str(arg)
            
    try:
        uid = "delretained_"+str(os.getpid())
        payload = [(topic, None, 0, True)]
        publish.multiple(payload, brokerIP, brokerPort, uid)
        print("Deleting "+topic+" from "+brokerIP+":"+s
__author__ = 'Ydface'
save_obj = None
mysession = None
class Save(object):
    def __init__(self):
        super(Save, self).__init__()
    @staticmethod
    def save():
        sav_obj = dict()
        sav_obj["user"] = dict()
        sav_obj["bag"] = dict()
        sav_obj["skill"] = []
        player = gamestate.player
        sav_obj["user"] = player.user_serialize_save()
        sav_obj["item"] = player.item_serialize_save()
        sav_obj["equiped"] = player.equiped_serialize_save()
        j = json.dumps(sav_obj)
        out = open("save.sav", "wb")
        cPickle.dump(sav_obj, out)
        out.close()
        global mysession
        if not mysession:
            mysession = session.Session()
        result = mysession.save_exp(False, j)
    @staticmethod
    def init_save():
        global save_obj
        save_obj = dict()
        save_obj["user"] = dict()
        save_obj["bag"] = dict()
        user_obj = save_obj["user"]
        user_obj["level"] = 1
        user_obj["ex
b = BostonZip(zipcode='01760', name='Framingham')
b.save()
b = BostonZip(zipcode='01730', name='Bedford')
b.save()
b = BostonZip(zipcode='01731', name='Hanscom Air Force Base')
b.save()
b = BostonZip(zipcode='01773', name='Lincoln')
b.save()
b = BostonZip(zipcode='01801', name='Woburn')
b.save()
b = BostonZip(zipcode='01803', name='Burlington')
b.save()
b = BostonZip(zipcode='01867', name='Reading')
b.save()
b = BostonZip(zipcode='01880', name='Wakefield')
b.save()
b = BostonZip(zipcode='01887', name='Wilmington')
b.save()
b = BostonZip(zipcode='01890', name='Winchester')
b.save()
b = BostonZip(zipcode='01902', name='Lynn')
b.save()
b = BostonZip(zipcode='01904', name='East Lynn')
b.save()
b = BostonZip(zipcode='01905', name='West Lynn')
b.save()
b = BostonZip(zipcode='01906', name='Saugus')
b.save()
b = BostonZip(zipcode='01907', name='Swampscott')
b.save()
b = BostonZip(zipcode='01908', name='Nahant')
b.save()
b = BostonZip(zipcode='01940', name='Lynnfield')
b.save()
b = BostonZip(zi

b.save()
b = BostonZip(zipcode='01960', name='Peabody')
b.save()
b = BostonZip(zipcode='01970', name='Salem')
b.save()
b = BostonZip(zipcode='02021', name='Canton')
b.save()
b = BostonZip(zipcode='02025', name='Cohasset')
b.save()
b = BostonZip(zipcode='02026', name='Dedham')
b.save()
b = BostonZip(zipcode='02030', name='Dover')
b.save()
b = BostonZip(zipcode='02043', name='Hingham')
b.save()
b = BostonZip(zipcode='02045', name='Hull')
b.save()
b = BostonZip(zipcode='02062', name='Norwood')
b.save()
b = BostonZip(zipcode='02090', name='Westwood')
b.save()
b = BostonZip(zipcode='02108', name='Boston')
b.save()
b = BostonZip(zipcode='02109', name='Boston')
b.save()
b = BostonZip(zipcode='02110', name='Boston')
b.save()
b = BostonZip(zipcode='02111', name='Boston')
b.save()
b = BostonZip(zipcode='02113', name='Boston')
b.save()
b = BostonZip(zipcode='02114', name='Boston')
b.save()
b = BostonZip(zipcode='02115', name='Boston')
b.save()
b = BostonZip(zipcode='02116', name='Boston')
b.save

b = BostonZip(zipcode='02118', name='Roxbury')
b.save()
b = BostonZip(zipcode='02119', name='Roxbury')
b.save()
b = BostonZip(zipcode='02120', name='Roxbury')
b.save()
b = BostonZip(zipcode='02121', name='Dorchester')
b.save()
b = BostonZip(zipcode='02122', name='Dorchester')
b.save()
b = BostonZip(zipcode='02124', name='Dorchester')
b.save()
b = BostonZip(zipcode='02125', name='Dorchester')
b.save()
b = BostonZip(zipcode='02126', name='Mattapan')
b.save()
b = BostonZip(zipcode='02127', name='South Boston')
b.save()
b = BostonZip(zipcode='02128', name='East Boston')
b.save()
b = BostonZip(zipcode='02129', name='Charlestown')
b.save()
b = BostonZip(zipcode='02130', name='Jamaica Plain')
b.save()
b = BostonZip(zipcode='02131', name='Roslindale')
b.save()
b = BostonZip(zipcode='02132', name='West Roxbury')
b.save()
b = BostonZip(zipcode='02134', name='Allston')
b.save()
b = BostonZip(zipcode='02135', name='Brighton')
b.save()
b = BostonZip(zipcode='02136', name='Hyde Park')
b.save()
b = 
"""
Migration script to add the includes_datatypes, has_repository_dependencies, includes_tools, includes_tool_dependencies and includes_workflows
columns to the repository_metadata table.
"""
log = logging.getLogger( __name__ )
log.setLevel(logging.DEBUG)
handler = logging.StreamHandler( sys.stdout )
format = "%(name)s %(levelname)s %(asctime)s %(message)s"
formatter = logging.Formatter( format )
handler.setFormatter( formatter )
log.addHandler( handler )
metadata = MetaData()
def upgrade(migrate_engine):
    print __doc__
    metadata.bind = migrate_engine
    metadata.reflect()
    if migrate_engine.name == 'mysql' or migrate_engine.name == 'sqlite':
        default_false = "0"
    elif migrate_engine.name in ['postgres', 'postgresql']:
        default_false = "false"
    RepositoryMetadata_table = Table( "repository_metadata", metadata, autoload=True )
    c = Column( "includes_datatypes", Boolean, default=False, index=True )
    try:
        c.create( RepositoryMetadata_table, ind

        assert c is RepositoryMetadata_table.c.includes_datatypes
        migrate_engine.execute( "UPDATE repository_metadata SET includes_datatypes=%s" % default_false )
    except Exception, e:
        print "Adding includes_datatypes column to the repository_metadata table failed: %s" % str( e )
    c = Column( "has_repository_dependencies", Boolean, default=False, index=True )
    try:
        c.create( RepositoryMetadata_table, index_name="ix_repository_metadata_has_repo_deps")
        assert c is RepositoryMetadata_table.c.has_repository_dependencies
        migrate_engine.execute( "UPDATE repository_metadata SET has_repository_dependencies=%s" % default_false )
    except Exception, e:
        print "Adding has_repository_dependencies column to the repository_metadata table failed: %s" % str( e )
    c = Column( "includes_tools", Boolean, default=False, index=True )
    try:
        c.create( RepositoryMetadata_table, index_name="ix_repository_metadata_inc_tools")
        asser

        migrate_engine.execute( "UPDATE repository_metadata SET includes_tools=%s" % default_false )
    except Exception, e:
        print "Adding includes_tools column to the repository_metadata table failed: %s" % str( e )
    c = Column( "includes_tool_dependencies", Boolean, default=False, index=True )
    try:
        c.create( RepositoryMetadata_table, index_name="ix_repository_metadata_inc_tool_deps")
        assert c is RepositoryMetadata_table.c.includes_tool_dependencies
        migrate_engine.execute( "UPDATE repository_metadata SET includes_tool_dependencies=%s" % default_false )
    except Exception, e:
        print "Adding includes_tool_dependencies column to the repository_metadata table failed: %s" % str( e )
    c = Column( "includes_workflows", Boolean, default=False, index=True )
    try:
        c.create( RepositoryMetadata_table, index_name="ix_repository_metadata_inc_workflows")
        assert c is RepositoryMetadata_table.c.includes_workflows
        migrate_e
DEBUG = True
class Actuation(object):
    def __init__(self,*args,**kwargs):
        t_start = time.time()
        pwm_controller_port = None
        olfactometer_ports = []
        current_controller_port = None
        self.pwm_controller = None
        self.olfactometers = None
        self.current_controller = None
        arduino_device_ports = findArduinoDevicePorts()
        for port in arduino_device_ports:
            port_info = arduino_device_ports[port]
            if isPwmControllerPortInfo(port_info):
                pwm_controller_port = port
            elif isOlfactometerPortInfo(port_info):
                olfactometer_ports.append(port)
            elif isCurrentControllerPortInfo(port_info):
                current_controller_port = port
        if pwm_controller_port is not None:
            self.pwm_controller = PwmController(port=pwm_controller_port)
            self.pwm_controller.setDeviceName('pwm_controller')
        if len(olfactometer_ports) != 0:
         
__all__ = (
	invoicebase_saved.__all__ +
	invoicebase_changed_state.__all__ +
    make_purchase_order.__all__ +
    make_invoice.__all__ +
	invoice_cancelled.__all__
"""
SIGNALS
"""
signals.post_save.connect(Notification.post_save, sender=QuotationSaved)
signals.post_save.connect(Notification.post_save, sender=QuotationChangedState)
signals.post_save.connect(Notification.post_save, sender=QuotationMakePurchaseOrder)
signals.post_save.connect(Notification.post_save, sender=QuotationMakeInvoice)
signals.post_save.connect(Notification.post_save, sender=QuotationMakeDownPaymentInvoice)
signals.post_save.connect(Notification.post_save, sender=InvoiceSaved)
signals.post_save.connect(Notification.post_save, sender=InvoiceChangedState)
signals.post_save.connect(Notification.post_save, sender=InvoiceCancelled)
signals.post_save.connect(Notification.post_save, sender=DownPaymentInvoiceSaved)
signals.post_save.connect(Notification.post_save, sender=DownPaymentInvoiceChangedState)
signals.post_sav
urlpatterns = patterns('',
                       url(r'^$', views.day_journal, name='new_day_journal'),
                       url(r'^journals/$', views.all_day_journals, name='all_day_journals'),
                       url(r'^scratch-off-latest/$', views.scratch_off_latest, name='scratch_off_latest'),
                       url(r'^scratch-off-latest/(?P<id>[0-9]+)$', views.scratch_off_latest, name='update_scratch_off_latest'),
                       url(r'^scratch-off-latest-register/$', views.list_scratch_off_latest, name='scratch_off_latest_register'),
                       url(r'^scratch-off-latest/search/$', views.search_scratch_off_latest, name='search_scratch_off_latest'),
                       url(r'^scratch-off-latest/save/$', views.save_scratch_off_latest, name='save_scratch_off_latest'),
                       url(r'^get-previous-scratch-off/(?P<date>\d{4}-\d{2}-\d{2})/$', views.get_previous_scratch, name='get_previous_scratch_off'),
                       url(r'^journals

                           name='all_day_journals_improvised'),
                       url(r'^approve/$', views.approve, name='approve_day_journal'),
                       url(r'^unapprove/(?P<journal_date>\d{4}-\d{2}-\d{2})/$', views.unapprove,
                           name='unapprove_day_journal'),
                       url(r'^(?P<journal_date>\d{4}-\d{2}-\d{2})/$', views.day_journal, name='view_day_journal'),
                       url(r'^save/cash_sales/$', views.save_cash_sales, name='save_cash_sales'),
                       url(r'^save/summary_cash/$', views.save_summary_cash, name='save_summary_cash'),
                       url(r'^save/summary_sales_tax/$', views.save_summary_sales_tax, name='save_summary_sales_tax'),
                       url(r'^save/summary_transfer/$', views.save_summary_transfer, name='save_summary_transfer'),
                       url(r'^save/summary_inventory/$', views.save_summary_inventory, name='save_summary_inventory'),
                       

                       url(r'^save/card_sales/$', views.save_card_sales, name='save_card_sales'),
                       url(r'^save/cash_equivalent_sales/$', views.save_cash_equivalent_sales,
                           name='save_cash_equivalent_sales'),
                       url(r'^save/lotto_detail/$', views.save_lotto_detail, name='save_lotto_detail'),
                       url(r'^delete_attachment/$', views.delete_attachment, name='delete_attachment'),
                       url(r'^save_attachments/$', views.save_attachments, name='save_attachments'),
                       url(r'^save_lotto_sales_as_per_dispenser/$', views.save_lotto_sales_as_per_dispenser,
                           name='save_lotto_sales_as_per_dispenser'),
                       url(r'^save/vendor_payout/$', views.save_vendor_payout, name='save_vendor_payout'),
                       url(r'^save/vendor_charge/$', views.save_vendor_charge, name='save_vendor_charge'),
                       url(r'^save/deposi
def find_faces(imgDir, facemodelFile, posemodelFile, imgSaveDir, xmlSaveDir): 
    imgDir = os.path.expanduser(imgDir)
    if imgSaveDir!="-":
        imgSaveDir = os.path.expanduser(imgSaveDir)
        if not os.path.exists(imgSaveDir):
            os.makedirs(imgSaveDir)
    if xmlSaveDir!="-":
    	xmlSaveDir = os.path.expanduser(xmlSaveDir)
    	if not os.path.exists(xmlSaveDir): 
            os.makedirs(xmlSaveDir)
    imgs = glob.glob(os.path.join(imgDir,"*.jpg"))
    for i,img in enumerate(imgs):
        print("Processing {0}/{1}: {2}".format(i+1,len(imgs),img))
        imgName = os.path.splitext(os.path.basename(img))[0];
        if imgSaveDir=="-": 
            imgSaveName="-"
        else: 
            imgSaveName = os.path.join(imgSaveDir,imgName+".jpg")
        if xmlSaveDir=="-":
            xmlSaveName="-"
        else:
            xmlSaveName = os.path.join(xmlSaveDir,imgName+".xml")
        subprocess.call(["./facefinder",img,facemodelFile,posemodelFile,imgSaveName,xmlS
class Router:
    async def route_request(self, message, client):
        parameters = message.content
        if parameters[0] != '!':
            raise Exception
        parsed = parameters.split(" ")
        selected_controller = None
        try:
            if len(parsed) >= 1 and parsed[0] != "":
                selected_controller = parsed[0]
                parsed.remove(selected_controller)
                selected_controller = selected_controller[1:]
                if not self.controller_exists(selected_controller):
                    raise Exception
            else:
                raise Exception
        except:
            pass
        controller_class = getattr(controller_module, selected_controller.capitalize())
        controller_instance = controller_class()
        await controller_instance.process(parsed, message, client)
    def controller_exists(self, controller_file_name):
        return os.path.exists(os.path.join(os.path.join(os.path.dirname(__file__), "contr
router = routers.DefaultRouter()
router.register(r'users', views.UserAuthViewSet)
router.register(r'groups', views.GroupViewSet)
router.register(r'employees', views.EmployeeViewSet)
router.register(r'announcements', views.AnnouncementViewSet)
router.register(r'levels', views.LevelViewSet)
router.register(r'calendar', views.CalendarViewSet)
router.register(r'salary', views.SalaryViewSet)
router.register(r'salarybase', views.SalaryBaseViewSet)
urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    url(r'^$','Website.views.index',name="home"),
    
    url(r'^Introduce$','Website.views.Introduce',name="Introduce"),
    url(r'^Structure$','Website.views.Structure',name="Structure"),
    url(r'^Greattarget$','Website.views.Greattarget',name="Greattarget"),
	url(r'^Partnership$','Website.views.Partnership',name="Partnership"),
	url(r'^Greatleader$','Website.views.Greatleader',name="Greatleader"),
	url(r'^LeaderIntro$','Website.views.LeaderIntro',name="LeaderIntro"),
	url(r'^Direc

	url(r'^Teamstructure$','Website.views.Teamstructure',name="Teamstructure"),
	url(r'^Teamtarget$','Website.views.Teamtarget',name="Teamtarget"),
	url(r'^Teammember$','Website.views.Teammember',name="Teammember"),
	url(r'^PersonIntro$','Website.views.PersonIntro',name="PersonIntro"),
	url(r'^skr1620$','Website.views.skr1620',name="skr1620"),
	url(r'^Announce$','Website.views.Announce',name="Announce"),
	url(r'^AnnDetail$','Website.views.AnnDetail',name="AnnDetail"),
	url(r'^News$','Website.views.News',name="News"),
	url(r'^NewsDetail$','Website.views.NewsDetail',name="NewsDetail"),
	url(r'^Policy$','Website.views.Policy',name="Policy"),
	url(r'^Magazine$','Website.views.Magazine',name="Magazine"),
	url(r'^ContactCop$','Website.views.ContactCop',name="ContactCop"),
	url(r'^ContactJob$','Website.views.ContactJob',name="ContactJob"),
    url(r'^API/REST/', include(router.urls),name='REST'),
    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),
    url(r'^mana

    url(r'^manage/logout$','Manager.views.logout',name="logout"),
    url(r'^manage/index$','Manager.views.index',name="index"),
    url(r'^manage/clicknotification$','Manager.views.clicknotification',name="clicknotification"),
    url(r'^manage/addannounce$','Manager.views.addannounce',name="addannounce"),
    url(r'^manage/editannounce$','Manager.views.editannounce',name="editannounce"),
    url(r'^manage/delannounce$','Manager.views.delannounce',name="delannounce"),
    url(r'^manage/readannounce$','Manager.views.readannounce',name="readannounce"),
    url(r'^manage/profilepage$','Manager.views.profilepage',name="profilepage"),
    url(r'^manage/profileedit$','Manager.views.profileedit',name="profileedit"),
    url(r'^manage/changepassword$','Manager.views.changepassword',name="changepassword"),
    url(r'^manage/uploadhead$','Manager.views.uploadhead',name="uploadhead"),
    url(r'^manage/userlist$','Manager.views.userlist',name="userlist"),
    url(r'^manage/adduser$','Manager.vi
class TestManage:
    @pytest.mark.slow
    def test_fetch_url(self):
        heros = manage.fetch_main_index()
        assert len(heros) > 5
        
        hero = heros[0]
        assert hero['name']
        assert hero['decks']
        
        deck = hero['decks'][0]
        assert deck['desc']
        assert deck['_id']
        card = deck['cards'][0]
        assert card['count']
        assert card['id'] is not None
    @pytest.mark.slow
    @pytest.mark.single
    def test_fetch_decks(self):
        mongo.db.deck.remove()
        assert mongo.db.deck.find().count() == 0
        heros = manage.fetch_main_index()
        for t in [x['name'] for x in heros]:
            print t
            
        assert u'德鲁伊' in [x['name'] for x in heros]
        assert len(heros[0]['decks'][0]['cards']) > 1
        
        assert mongo.db.deck.find({'name': u'德鲁伊'}).count()
    @pytest.mark.slow
    def test_detail_card_url(self):
        url = manage.parse_detail_cards_url('http://ls.duowan.
urlpatterns = patterns('',
    url(r'^acidentes_rodovias/$', 'app.controller.index_controller.index'),
    url(r'^acidentes_rodovias/regiao$', 'app.controller.consultabasica_regiao_controller.consulta_por_regiao'),
    url(r'^acidentes_rodovias/periodo$', 'app.controller.consultabasica_periodo_controller.consulta_por_periodo'),
    url(r'^acidentes_rodovias/municipios-regiao$', 'app.controller.consultabasica_regiao_controller.consulta_municipios_na_regiao'),
    url(r'^acidentes_rodovias/consulta/municipio$', 'app.controller.consultabasica_regiao_controller.consulta_ocorrencias_por_municipio'),
    url(r'^acidentes_rodovias/consulta/periodo$', 'app.controller.consultabasica_periodo_controller.consulta_ocorrencias_por_periodo'),
    url(r'^acidentes_rodovias/estatisticas/tipos-acidentes$', 'app.controller.estatisticas_tipos_controller.tipos_acidentes'),
    url(r'^acidentes_rodovias/estatisticas/causas-acidentes$', 'app.controller.estatisticas_causas_controller.causas_acidentes'),
    u
datatypes_repository_name = 'emboss_datatypes_0020'
datatypes_repository_description = "Galaxy applicable data formats used by Emboss tools."
datatypes_repository_long_description = "Galaxy applicable data formats used by Emboss tools.  This repository contains no tools."
emboss_repository_name = 'emboss_0020'
emboss_repository_description = 'Galaxy wrappers for Emboss version 5.0.0 tools for test 0020'
emboss_repository_long_description = 'Galaxy wrappers for Emboss version 5.0.0 tools for test 0020'
class TestBasicRepositoryDependencies( ShedTwillTestCase ):
    '''Testing emboss 5 with repository dependencies.'''
    def test_0000_initiate_users( self ):
        """Create necessary user accounts and login as an admin user."""
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email

        test_user_1_private_role = self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin_username )
        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        admin_user_private_role = self.test_db_util.get_private_role( admin_user )
  
    def test_0005_create_category( self ):
        """Create a category for this test suite"""
        self.create_category( name='Test 0020 Basic Repository Dependencies', description='Testing basic repository dependency features.' )
    def test_0010_create_emboss_datatypes_repository_and_upload_tarball( self ):
        '''Create and populate the emboss_datatypes repository.'''
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        category = self.test_db_util.get_catego

        repository = self.get_or_create_repository( name=datatypes_repository_name, 
                                             description=datatypes_repository_description, 
                                             long_description=datatypes_repository_long_description, 
                                             owner=common.test_user_1_name,
                                             category_id=self.security.encode_id( category.id ), 
                                             strings_displayed=[] )
        self.upload_file( repository, 
                          filename='emboss/datatypes/datatypes_conf.xml', 
                          filepath=None,
                          valid_tools_only=True,
                          uncompress_file=False,
                          remove_repo_files_not_in_tar=False,
                          commit_message='Uploaded datatypes_conf.xml.',
                          strings_displayed=[], 
                          strings_not_dis
class ControllerManagerClient:
    '''
    Class for starting/stopping/loading/unloading PR2 controllers.
    '''
    def __init__(self):
        load_controller_service_uri = 'pr2_controller_manager/load_controller'
        unload_controller_service_uri = 'pr2_controller_manager/unload_controller'
        list_controllers_service_uri = 'pr2_controller_manager/list_controllers'
        switch_controller_service_uri = 'pr2_controller_manager/switch_controller'
        rospy.wait_for_service(load_controller_service_uri)
        rospy.wait_for_service(unload_controller_service_uri)
        rospy.wait_for_service(list_controllers_service_uri)
        rospy.wait_for_service(switch_controller_service_uri)
        self._load_controller_service = rospy.ServiceProxy(load_controller_service_uri, LoadController)
        self._unload_controller_service = rospy.ServiceProxy(unload_controller_service_uri, UnloadController)
        self._list_controllers_service = rospy.ServiceProxy(list_controllers_

        self._switch_controller_service = rospy.ServiceProxy(switch_controller_service_uri, SwitchController)
        try:
            controllers_config = rospy.get_param('known_controllers')
        except KeyError:
            config_filename = os.path.join(roslib.packages.get_pkg_dir('pr2_python'), 'config/known_controllers.yaml')
            controllers_config = yaml.load(open(config_filename).read())
        self._known_controllers = controllers_config['controllers']
        self._default_controllers = controllers_config['default_controllers']
        self._controllers = {}
        self._update()
    def _update(self):
        '''
        Update list of controllers and their state.
        '''
        res = self._list_controllers_service()
        self._controllers = {}
        for controller_name, controller_state in zip(res.controllers, res.state):
            self._controllers[controller_name] = controller_state
    def list_controllers(self):
        '''
        Get list of 

        **Returns:**
            controllers ([string]): Dictionary whose keys are the names of the loaded controllers,
            and whose values are their respective states.
        '''
        self._update()
        return copy.copy(self._controllers)
        
    def load_controller(self, controller_name):
        '''
        Load the given controller.
        **Args:**
            **controller_name (string):** Name of controller to load.
        **Raises:**
        
            **exceptions.ControllerManagerError:** if unable to load controller.
        '''
        self._update()
        if controller_name in self._controllers:
            return True
        res = self._load_controller_service(controller_name)
        if not res.ok:
            raise ControllerManagerError('Unable to load controller %s' % controller_name)
    def unload_controller(self, controller_name):
        '''
        Unload the given controller.
        Succeeds quietly if controller not loaded.
       
"""Majordomo Protocol Client API, Python version.
Author: Min RK <benjaminrk@gmail.com>
Based on Java example by Arkadiusz Orzechowski
"""
class MajorDomoClient(object):
    """Majordomo Protocol Client API, Python version.
    """
    broker = None
    ctx = None
    client = None
    poller = None
    timeout = 2500
    verbose = False
    def __init__(self, broker, verbose=False):
        self.broker = broker
        self.verbose = verbose
        self.ctx = zmq.Context()
        self.poller = zmq.Poller()
        logging.basicConfig(format="%(asctime)s %(message)s", datefmt="%Y-%m-%d %H:%M:%S",
                level=logging.INFO)
        self.reconnect_to_broker()
    def reconnect_to_broker(self):
        """Connect or reconnect to broker"""
        if self.client:
            self.poller.unregister(self.client)
            self.client.close()
        self.client = self.ctx.socket(zmq.DEALER)
        self.client.linger = 0
        self.client.connect(self.broker)
        self.poll

        if self.verbose:
            logging.info("I: connecting to broker at %s...", self.broker)
    def send(self, service, request):
        """Send request to broker
        """
        if not isinstance(request, list):
            request = [request]
        request = ['', MDP.C_CLIENT, service] + request
        if self.verbose:
            logging.warn("I: send request to '%s' service: ", service)
            dump(request)
        self.client.send_multipart(request)
    def recv(self):
        """Returns the reply message or None if there was no reply."""
        try:
            items = self.poller.poll(self.timeout)
        except KeyboardInterrupt:
        if items:
            msg = self.client.recv_multipart()
            if self.verbose:
                logging.info("I: received reply:")
                dump(msg)
            assert len(msg) >= 4
            empty = msg.pop(0)
            header = msg.pop(0)
            assert MDP.C_CLIENT == header
            service = 
log = logging.getLogger( 'test.tool_shed.test_db_util' )
def delete_obj( obj ):
    sa_session.delete( obj )
    sa_session.flush()
    
def delete_user_roles( user ):
    for ura in user.roles:
        sa_session.delete( ura )
    sa_session.flush()
    
def flush( obj ):
    sa_session.add( obj )
    sa_session.flush()
    
def get_all_repositories():
    return sa_session.query( model.Repository ).all()
def get_all_installed_repositories( actually_installed=False ):
    if actually_installed:
        return ga_session.query( galaxy.model.ToolShedRepository ) \
                         .filter( and_( galaxy.model.ToolShedRepository.table.c.deleted == False,
                                        galaxy.model.ToolShedRepository.table.c.uninstalled == False,
                                        galaxy.model.ToolShedRepository.table.c.status == galaxy.model.ToolShedRepository.installation_status.INSTALLED ) ) \
                         .all()
    else:
        return ga_session.quer

    
def get_category_by_name( name ):
    return sa_session.query( model.Category ) \
                     .filter( model.Category.table.c.name == name ) \
                     .first()
                     
def get_default_user_permissions_by_role( role ):
    return sa_session.query( model.DefaultUserPermissions ) \
                     .filter( model.DefaultUserPermissions.table.c.role_id == role.id ) \
                     .all()
                     
def get_default_user_permissions_by_user( user ):
    return sa_session.query( model.DefaultUserPermissions ) \
                     .filter( model.DefaultUserPermissions.table.c.user_id==user.id ) \
                     .all()
                     
def get_galaxy_repository_by_name_owner_changeset_revision( repository_name, owner, changeset_revision ):
    return ga_session.query( galaxy.model.ToolShedRepository ) \
                     .filter( and_( galaxy.model.ToolShedRepository.table.c.name == repository_name,
                

                                    galaxy.model.ToolShedRepository.table.c.changeset_revision == changeset_revision ) ) \
                     .first()
                     
def get_installed_repository_by_id( repository_id ):
    return ga_session.query( galaxy.model.ToolShedRepository ) \
                     .filter( galaxy.model.ToolShedRepository.table.c.id == repository_id ) \
                     .first()
                     
def get_installed_repository_by_name_owner( repository_name, owner ):
    return ga_session.query( galaxy.model.ToolShedRepository ) \
                     .filter( and_( galaxy.model.ToolShedRepository.table.c.name == repository_name,
                                    galaxy.model.ToolShedRepository.table.c.owner == owner ) ) \
                     .first()
                     
def get_private_role( user ):
    for role in user.all_roles():
        if role.name == user.email and role.description == 'Private Role for %s' % user.email:
            retu
class GridFactory():
    def __init__(self):
        self.brokerClient = None
        self.id = None
        self.nid=None
        self.config = None
        self.roles = list()
    def _loadConfig(self,test=True):
        if not j.application.__dict__.has_key("config"):
            raise RuntimeWarning("Grid/Broker is not configured please run configureBroker/configureNode first and restart jshell")
        self.config = j.application.config
        if self.config == None:
            raise RuntimeWarning("Grid/Broker is not configured please run configureBroker/configureNode first and restart jshell")
        self.id = j.application.whoAmI.gid
        self.nid = j.application.whoAmI.nid
        if test:
            if self.id == 0:
                j.errorconditionhandler.raiseInputError(msgpub="Grid needs grid id to be filled in in grid config file", message="", category="", die=True)
            if self.nid == 0:
                j.errorconditionhandler.raiseInputError(msgpub="Grid n
class Franck:
    def __init__(self):
        self.config = ConfigParser.ConfigParser()
        if os.path.isfile("/usr/local/etc/moustash/moustash.ini") == False:
            print "Configuration file (/usr/local/etc/moustash/moustash.ini) not found !!!"
            print "Exit !!!"
            sys.exit(1)
        self.config.read("/usr/local/etc/moustash/moustash.ini")
        self.moustash_config = {}
        self.moustash_config["Moustash"] = config_section_map(self.config, "Moustash")
        self.moustash_config["Cuir"] = config_section_map(self.config, "Cuir")
        self.broker = {}
        if self.moustash_config["Moustash"]["transport"] == "redis":
            redis_parameters = {"redis_host" : "localhost", "redis_port" : "6379", "redis_db" : "0", "redis_namespace": "logstash:moustash"}
            self.fill_broker_options(redis_parameters)
            self.broker_connection = self.connect_to_redis()
        elif self.moustash_config["Moustash"]["transport"] == "rabbitmq":
 

                                   "rabbitmq_ssl" : "0", "rabbitmq_ssl_key" : None, 
                                   "rabbitmq_ssl_cert" : None, "rabbitmq_ssl_cacert" : None,
                                   "rabbitmq_vhost" : "/", "rabbitmq_username" : "guest",
                                   "rabbitmq_password" : "guest",
                                   "rabbitmq_queue" : "logstash-queue", "rabbitmq_queue_durable" : "0",
                                   "rabbitmq_exchange_type" : "direct", "rabbitmq_exchange_durable" : "0",
                                   "rabbitmq_key" : "logstash-key", "rabbitmq_exchange" : "logstash-exchange"}
            self.fill_broker_options(rabbitmq_parameters)
            self.broker_connection = self.connect_to_rabbitmq()
        else:
            print("Not yet implemented : %s !" % moustash_config["Moustash"]["transport"])
            
    def fill_broker_options(self, options):
        for option_name, option_value in options.iteritems(

            if option_name in self.moustash_config["Moustash"]:
                self.broker[option_name] = self.moustash_config["Moustash"][option_name]
            else:
                self.broker[option_name] = option_value
    def connect_to_redis(self):
        r = redis.StrictRedis(host=self.broker["redis_host"], port=int(self.broker["redis_port"]), db=int(self.broker["redis_db"]))
        return r
    def connect_to_rabbitmq(self):
        credentials_rabbitmq = pika.PlainCredentials(self.broker["rabbitmq_username"], self.broker["rabbitmq_password"])
        parameters_rabbitmq = pika.ConnectionParameters(host=self.broker["rabbitmq_host"], port=int(self.broker["rabbitmq_port"]),
                                                        virtual_host=self.broker["rabbitmq_vhost"], credentials=credentials_rabbitmq)
        connection = pika.BlockingConnection(parameters_rabbitmq)
        channel = connection.channel()
        channel.queue_declare(queue=self.broker["rabbitmq_queue"]
response.title = settings.title
response.subtitle = settings.subtitle
response.meta.author = '%(author)s <%(author_email)s>' % settings
response.meta.keywords = settings.keywords
response.meta.description = settings.description
response.menu = [
(T('Index'),URL('default','index')==URL(),URL('default','index'),[]),
(T('Estado'),URL('default','estado_manage')==URL(),URL('default','estado_manage'),[]),
(T('Sede'),URL('default','sede_manage')==URL(),URL('default','sede_manage'),[]),
(T('Comunidad'),URL('default','comunidad_manage')==URL(),URL('default','comunidad_manage'),[]),
(T('Area'),URL('default','area_manage')==URL(),URL('default','area_manage'),[]),
(T('Sexo'),URL('default','sexo_manage')==URL(),URL('default','sexo_manage'),[]),
(T('Estudiante'),URL('default','estudiante_manage')==URL(),URL('default','estudiante_manage'),[]),
(T('Proponente'),URL('default','proponente_manage')==URL(),URL('default','proponente_manage'),[]),
(T('Tutor'),URL('default','tutor_manage')==URL(),URL('defaul
app = Flask(__name__)
def bind_controller(app, rule, controller, methods):
    endpoint = re.split('\.',controller.__module__)[1]
    app.add_url_rule(rule=rule,
                     endpoint=endpoint,
                     view_func=controller.handle_request,
                     methods=methods)
bind_controller(app=app,
                rule='/login/form',
                controller=login_form.Controller(),
                methods=['GET'])
bind_controller(app=app,
                rule='/login',
                controller=login.Controller(user_model_cls=User, session_model_cls=Session),
                methods=['POST'])
bind_controller(app=app,
                rule='/',
                controller=dashboard.Controller(User),
                methods=['GET'])
bind_controller(app=app,
                rule='/tasklist/add/form',
                controller=tasklist_add_form.Controller(),
                methods=['GET'])
bind_controller(app=app,
                rule='/tasklist/add',
           

                methods=['POST'])
bind_controller(app=app,
                rule='/tasklist/edit/form/<int:tasklist_id>',
                controller=tasklist_edit_form.Controller(Tasklist),
                methods=['GET'])
bind_controller(app=app,
                rule='/tasklist/edit/<int:tasklist_id>',
                controller=tasklist_edit.Controller(Tasklist),
                methods=['POST'])
bind_controller(app=app,
                rule='/task/add/form/<int:tasklist_id>',
                controller=task_add_form.Controller(Tasklist),
                methods=['GET'])
bind_controller(app=app,
                rule='/task/add/<int:tasklist_id>',
                controller=task_add.Controller(Tasklist),
                methods=['POST'])
bind_controller(app=app,
                rule='/task/edit/form/<int:task_id>',
                controller=task_edit_form.Controller(Task),
                methods=['GET'])
bind_controller(app=app,
                rule='/task/edit/<int:task_id>',
     
"""Test feature controller in scripts."""
__metaclass__ = type
    get_relevant_feature_controller,
    install_feature_controller,
    )
    FeatureController,
    NullFeatureController,
    )
class FakeScript(LaunchpadScript):
    """A dummy script that only records which feature controller is active."""
    observed_feature_controller = object()
    def __init__(self, name):
        super(FakeScript, self).__init__(name=name, test_args=[])
    def main(self):
        self.observed_feature_controller = get_relevant_feature_controller()
    _init_zca = FakeMethod()
    _init_db = FakeMethod()
    record_activity = FakeMethod()
class TestScriptFeatureController(TestCase):
    layer = DatabaseFunctionalLayer
    def setUp(self):
        super(TestScriptFeatureController, self).setUp()
        self.original_controller = get_relevant_feature_controller()
    def tearDown(self):
        install_feature_controller(self.original_controller)
        super(TestScriptFeatureController, self).te
serialPort = "/dev/ttyACM0"
controller = Controller(serialPort, 9600, 1)
sensors = [0, 0, 0, 0]
angle = 0
parallel = 0
distance = 0
def setDistance(maximum, minimum):
    controller.getSensor(2)
    current = controller.currentSensor
    if current < minimum:
        print("Going Toward!" + str(current))
        while current < minimum:
            print("Distance: " + str(current))
            controller.getSensor(2)
            current = controller.currentSensor
            controller.writeSteerPacket('S', 0, 0, 0, 0)
            controller.writeDrivePacket('D', 130, 130, 'R', 'R')
            
            
    elif current > maximum:
        print("Going Away!" + str(current))
        while current > maximum:
            print("Distance: " + str(current))
            controller.getSensor(2)
            current = controller.currentSensor
            controller.writeSteerPacket('S', 0, 0, 0, 0)
            controller.writeDrivePacket('D', 130, 130, 'F', 'F')
            
    
    cont

    controller.writeSteerPacket('S', 90, 90, 90, 90)
def getParallel():
    print("Gettin' Parallel!")
    parallel = 0
    while parallel == 0:
        controller.getSensor(2)
        sensors[0] = controller.currentSensor
        controller.getSensor(3)
        sensors[1] = controller.currentSensor
        angle = math.atan2((sensors[0]-sensors[1]), 480)
        if angle < -0.05:
            controller.writeSteerPacket('S', 45, 135, 45, 135)
            controller.writeDrivePacket('D', 255, 255, 'R', 'F')
        elif angle > 0.05:
            controller.writeSteerPacket('S', 45, 135, 45, 135)
            controller.writeDrivePacket('D', 255, 255, 'F', 'R')
                         
        else:
            controller.writeSteerPacket('S', 90, 90, 90, 90)
            controller.writeDrivePacket('D', 0, 0, 'F', 'F')
            parallel = 1
            return parallel
            
def driveTime(speed, direction, duration):
    controller.writeDrivePacket('D', speed, speed, direction,

    time.sleep(duration)
    controller.writeDrivePacket('D', 0, 0, 'F', 'F')
def checkWall():
    controller.getSensor(2)
    rearSensor = controller.currentSensor
    controller.getSensor(3)
    frontSensor = controller.currentSensor
    if (frontSensor-500)>rearSensor:
        print (str(frontSensor-500) + " " + str(rearSensor))
        return 'R'
    elif (rearSensor-500)>frontSensor:
        print (str(rearSensor-500) + " " + str(frontSensor))
        return 'F'
    else:
        return 'N'
try:
    if controller.connected:
        print("Controller Connected!")
        time.sleep(5)
    else:
        print("Controller Failed to Connect!")
        raise KeyboardInterrupt
    direction = 'F'
    checkDirection = 'N'
    print("Setting Distance")
    setDistance(1500, 1000)
    print("Getting Parallel")
    getParallel()
    
    while True:
        driveTime(130, 'R', 3)
        setDistance(1500, 1000)
        getParallel()
        print("Do it again!")
        
except KeyboardInt
def main():
    controller_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'controllers')
    if controller_dir not in sys.path:
        sys.path.insert(0, controller_dir)
    print 'Loading controllers.. ({0})'.format(controller_dir)
    files = os.walk(controller_dir).next()[2]
    dont_include = [ '__init__.py', '__init__.pyc' ]
    list_of_controllers = [ re.sub('.py$', '', x) for x in filter(lambda c: c not in dont_include and re.search('.py$',c), files) ]
    controllers = {}
    for controller in list_of_controllers:
        print 'Controller[{0}] loaded'.format(controller)
    print 'Adding routes..'
    handlers = []
    for controller in controllers:
        c = controllers[controller]
        if isinstance(c.params.route, basestring):
            handlers.append((c.params.route, c.Handler))
        else:
            for uri_string in c.params.route:
               handlers.append((uri_string, c.Handler))
        
    print handlers
    run_server(handlers)
if
'''
Copyright (c) 2015-2016 Skylable Ltd. <info-copyright@skylable.com>
License: see LICENSE.md for more details.
'''
def anonymous_only(cls):
    """Decorator for Views that can only be accessed by anonymous users."""
    dispatch = cls.dispatch
    def wrapped(self, *args, **kwargs):
        if not self.request.user.is_authenticated():
            return dispatch(self, *args, **kwargs)
        messages.warning(self.request, _(
            "You can't do this while logged in."))
        return redirect('home')
    wrapped.__doc__ = dispatch.__doc__
    cls.dispatch = wrapped
    return cls
def regular_user_only(cls):
    """Decorator for Views that can only be performed on regular users."""
    assert issubclass(cls, UserViewMixin)
    dispatch = cls.dispatch
    def wrapped(self, *args, **kwargs):
        if self.user and not self.user.is_reserved:
            return dispatch(self, *args, **kwargs)
        raise Http404()
    wrapped.__doc__ = dispatch.__doc__
    cls.dispatch = wrapp
log = logging.getLogger( __name__ )
column_repository_name = 'column_maker_0150'
column_repository_description = "Add column"
column_repository_long_description = "Compute an expression on every row"
convert_repository_name = 'convert_chars_0150'
convert_repository_description = "Convert delimiters"
convert_repository_long_description = "Convert delimiters to tab"
category_name = 'Test 0150 Simple Prior Installation'
category_description = 'Test 0150 Simple Prior Installation'
'''
Create column_maker and convert_chars.
Column maker repository dependency:
<repository toolshed="self.url" name="convert_chars" owner="test" changeset_revision="c3041382815c" prior_installation_required="True" />
Verify display.
Galaxy side:
Install column_maker.
Verify that convert_chars was installed first, contrary to the ordering that would be present without prior_installation_required.
'''
running_standalone = False
class TestSimplePriorInstallation( ShedTwillTestCase ):
    '''Test features related to 

    
    def test_0000_initiate_users( self ):
        """Create necessary user accounts."""
        self.galaxy_logout()
        self.galaxy_login( email=common.admin_email, username=common.admin_username )
        galaxy_admin_user = self.test_db_util.get_galaxy_user( common.admin_email )
        assert galaxy_admin_user is not None, 'Problem retrieving user with email %s from the database' % common.admin_email
        galaxy_admin_user_private_role = self.test_db_util.get_galaxy_private_role( galaxy_admin_user )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        test_user_1 = self.test_db_util.get_user( common.test_user_1_email )
        assert test_user_1 is not None, 'Problem retrieving user with email %s from the database' % test_user_1_email
        test_user_1_private_role = self.test_db_util.get_private_role( test_user_1 )
        self.logout()
        self.login( email=common.admin_email, username=common.admin

        admin_user = self.test_db_util.get_user( common.admin_email )
        assert admin_user is not None, 'Problem retrieving user with email %s from the database' % admin_email
        admin_user_private_role = self.test_db_util.get_private_role( admin_user )
        
    def test_0005_create_convert_repository( self ):
        '''Create and populate convert_chars_0150.'''
        global running_standalone
        category = self.create_category( name=category_name, description=category_description )
        self.logout()
        self.login( email=common.test_user_1_email, username=common.test_user_1_name )
        repository = self.get_or_create_repository( name=convert_repository_name, 
                                                    description=convert_repository_description, 
                                                    long_description=convert_repository_long_description, 
                                                    owner=common.test_user_1_name,
          
"""
(Description)
Created on Dec 24, 2014
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013-2014, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class ConditionController(BaseController):
  """Controller handling all the requests for objects"""
  def __init__(self, config, session=None):
    BaseController.__init__(self, config, session)
    self.condition_broker = self.broker_factory(ConditionBroker)
  def get_condition_by_id(self, identifier):
    try:
      return self.condition_broker.get_by_id(identifier)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise ControllerException(error)
  def get_condition_by_uuid(self, uuid):
    try:
      return self.condition_broker.get_by_uuid(uuid)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise Controll

  def get_all_conditions(self):
    try:
      return self.condition_broker.get_all()
    except BrokerException as error:
      raise ControllerException(error)
  def insert_condition(self, condition, commit=True):
    try:
      self.condition_broker.insert(condition, False)
      self.condition_broker.do_commit(commit)
    except ValidationException as error:
      message = ObjectValidator.getFirstValidationError(condition)
      raise ControllerException(u'Could not add condition due to: {0}'.format(message))
    except (BrokerException) as error:
      raise ControllerException(error)
  def update_condition(self, condition):
    try:
      self.condition_broker.update(condition, True)
    except ValidationException as error:
      message = ObjectValidator.getFirstValidationError(condition)
      raise ControllerException(u'Could not add condition due to: {0}'.format(message))
    except (BrokerException) as error:
      raise ControllerException(error)
  def remove_condition_by
try:
except:
    psutil = None
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Starts the broker on the"
                                                 "current computer")
    parser.add_argument('--tPort',
                        help='The port of the task socket',
                        default="*")
    parser.add_argument('--mPort',
                        help="The port of the info socket",
                        default="*")
    parser.add_argument('--nice',
                        help="Adjust the process niceness",
                        type=int,
                        default=0)
    parser.add_argument('--debug',
                        help="Activate the debug",
                        action='store_true')
    parser.add_argument('--path',
                        help="Path to run the broker",
                        default="")
    parser.add_argument('--backend',
                        help="Choice of communication backend",
             

                        default='ZMQ')
    parser.add_argument('--headless',
                        help="Enforce headless (cloud-style) operation",
                        action='store_true')
    parser.add_argument('--echoGroup',
                        help="Echo the process Group ID before launch",
                        action='store_true')
    parser.add_argument('--echoPorts',
                        help="Echo the listening ports",
                        action='store_true')
    args = parser.parse_args()
    if args.echoGroup:
        sys.stdout.write(str(os.getpgrp()) + "\n")
        sys.stdout.flush()
    if args.path:
        try:
            os.chdir(args.path)
        except OSError:
            sys.stderr.write('Could not chdir in {0}.'.format(args.path))
            sys.stderr.flush()
    if args.backend == 'ZMQ':
    else:
    thisBroker = Broker("tcp://*:" + args.tPort,
                        "tcp://*:" + args.mPort,
                        debug=args.debug,
   
"""
Migration script to add the long_description and times_downloaded columns to the repository table.
"""
log = logging.getLogger( __name__ )
log.setLevel(logging.DEBUG)
handler = logging.StreamHandler( sys.stdout )
format = "%(name)s %(levelname)s %(asctime)s %(message)s"
formatter = logging.Formatter( format )
handler.setFormatter( formatter )
log.addHandler( handler )
metadata = MetaData( migrate_engine )
db_session = scoped_session( sessionmaker( bind=migrate_engine, autoflush=False, autocommit=True ) )
def upgrade():
    print __doc__
    metadata.reflect()
    Repository_table = Table( "repository", metadata, autoload=True )
    c = Column( "long_description" , TEXT )
    try:
        c.create( Repository_table )
        assert c is Repository_table.c.long_description
    except Exception, e:
        print "Adding long_description column to the repository table failed: %s" % str( e )
        log.debug( "Adding long_description column to the repository table failed: %s" % str( e 

    c = Column( "times_downloaded" , Integer )
    try:
        c.create( Repository_table )
        assert c is Repository_table.c.times_downloaded
    except Exception, e:
        print "Adding times_downloaded column to the repository table failed: %s" % str( e )
        log.debug( "Adding times_downloaded column to the repository table failed: %s" % str( e ) )
    cmd = "UPDATE repository SET long_description = ''"
    db_session.execute( cmd )
    cmd = "UPDATE repository SET times_downloaded = 0"
    db_session.execute( cmd )
    
def downgrade():
    metadata.reflect()
    Repository_table = Table( "repository", metadata, autoload=True )
    try:
        Repository_table.c.long_description.drop()
    except Exception, e:
        print "Dropping column long_description from the repository table failed: %s" % str( e )
        log.debug( "Dropping column long_description from the repository table failed: %s" % str( e ) )
    try:
        Repository_table.c.times_downloaded.drop()

"""Saving some data to the demo application"""
def save_data():
    """Save test data for the demo application"""
    
    comfortable = Keyword(word="Comfortable")
    comfortable.save()
    
    trainers = Keyword(word="Trainers")
    trainers.save()
    
    sporty = Keyword(word="Sporty")
    sporty.save()
    
    cool = Keyword(word='Cool')
    cool.save()
    
    trendy = Keyword(word='Trendy')
    trendy.save()
    hollywood = City(name="Hollywood", in_south=True)
    hollywood.save()
    
    helsinki = City(name="Helsinki", in_south=False)        
    helsinki.save()
    
    almaty = City(name="Almaty", in_south=False)
    almaty.save()
    
    bishkek = City(name="Bishkek", in_south=False)
    bishkek.save()
    
    diesel = Manufacturer(name="Diesel", home_city=hollywood)
    diesel.save()
    
    lange = Manufacturer(name="Lange", home_city=helsinki)
    lange.save()
    
    for_sports = ShoeCategory(name='For Sports')
    for_sports.save()
    
    casual = ShoeCate

    casual.save()
    
    sneakers = ShoePair(
        name="Sneakers",
        manufacturer=diesel,
        for_winter=False,
        image_path='/images/Trainers.gif',
        category=casual
    )
    sneakers.save()
    sneakers.keywords.add(comfortable,trainers, cool)
    sneakers.save()
    
    rubber_shoes = ShoePair(
        name="Rubber Shoes",
        manufacturer=diesel,
        for_winter=False,
        image_path='/images/Rubber_Boots.gif'
    )
    rubber_shoes.save()
    rubber_shoes.keywords.add(comfortable)
    rubber_shoes.save()
    
    ski_boots = ShoePair(
        name='RS 130',
        manufacturer=lange,
        for_winter=True,
        image_path='/images/ski-boot.jpg',
        category=for_sports       
    )
    ski_boots.save()
    ski_boots.keywords.add(sporty)
    ski_boots.save()
    
    design_shoes = ShoePair(
        name="Design Shoes",
        category=casual,
        for_winter=False
    )
    design_shoes.save()
    design_shoes.keywords.add(co

    sneakers.save()    
    
    octane_sl = ShoePair(
        name="Octane SL",
        category=for_sports,
        for_winter=False
    )
    octane_sl.save()
    
    alice = User(
        name="Alice",
        age=19,
        home_city=hollywood
    )
    alice.save()
    alice.viewed_shoes.add(rubber_shoes)
    alice.likes_shoes.add(sneakers)
    alice.save()
    
    ShoeRating.objects.create(
        user=alice,
        shoe_pair=design_shoes,
        stars=4)
    
    bob = User(
        name="Bob",
        age=18,
        home_city=hollywood
    )
    bob.save()
    bob.viewed_shoes.add(sneakers)
    bob.words_searched.add(sporty, comfortable)
    bob.likes_shoes.add(sneakers)
    bob.save()
    
    ShoeRating.objects.create(
        user=bob,
        shoe_pair=design_shoes,
        stars=1)
    
    cindy = User(
        name="Cindy",
        age=25,
        home_city=helsinki
    )
    cindy.save()
    cindy.viewed_shoes.add(rubber_shoes)
    cindy.words_searched.add(comf
path.append('..')
RequestHandler.get[re.compile("^$")] = posts_controller.index
RequestHandler.get[re.compile("^/$")] = posts_controller.index
RequestHandler.get[re.compile("^/posts$")] = posts_controller.index
RequestHandler.get[re.compile("^/posts/(?P<id>\d+)$")] = posts_controller.show
RequestHandler.get[re.compile("^/posts/new$")] = posts_controller.new
RequestHandler.post[re.compile("^/posts$")] = posts_controller.create
RequestHandler.post[re.compile("^/comments$")] = comments_controller.create
RequestHandler.get[re.compile("^/users/(?P<id>\d+)$")] = users_controller.show
RequestHandler.get[re.compile("^/signup$")] = users_controller.new
RequestHandler.post[re.compile("^/signup$")] = users_controller.create
RequestHandler.get[re.compile("^/login$")] = sessions_controller.new
RequestHandler.post[re.compile("^/login$")] = sessions_controller.login
RequestHandler.get[re.compile("^/logout$")] = sessions_controller.logout
if __name__ == '__main__':
    run_server('', 8080, RequestHand
try:
except ImportError:
def parse_url(url):
    urlparse.uses_netloc.append('mongodb')
    urlparse.uses_netloc.append('celery')
    url = urlparse.urlparse(url)
    path = url.path[1:]
    path = path.split('?', 2)[0]
    return {
        'database': path or '',
        'port': url.port or '',
        'host': url.hostname or '',
        'user': url.username,
        'password': url.password,
    }
def split_uris(uri):
    return uri.split(';')
MONGODB_URIS = config('MONGODB_URIS', default='mongodb://localhost:27017',
        cast=split_uris)
MONGODB_DBNAME = config('MONGODB_DBNAME', default='pypln')
MONGODB_COLLECTION =  config('MONGODB_COLLECTION', default='analysis')
ELASTICSEARCH_CONFIG = {
    'hosts': config('ELASTICSEARCH_HOSTS',
        default='127.0.0.1,172.16.4.46,172.16.4.52', cast=Csv())
CELERY_BROKER_CONFIG = config('CELERY_CONFIG',
        default='amqp://guest:guest@localhost:5672', cast=parse_url)
BROKER_URL = 'amqp://{}:{}@{}:{}//'.format(
        CELERY_BROKER_CONFI
ssh_command = os.environ['SSH_ORIGINAL_COMMAND']
user = sys.argv[1]
m = re.search("^(git-receive-pack|git-upload-pack) '(\w+)\.git'$", ssh_command)
if m == None:
    exit(1)
command = m.group(1)
repoName = m.group(2)
db=MySQLdb.connect(host='localhost',user='root',
passwd='ceis12345*',db='captivaproject')
cursor=db.cursor()
sql='SELECT Repository.id, Repository.name, Repository.Owner FROM Repository INNER JOIN repository_writeusers ON Repository.id = repository_writeusers.Repository_id WHERE Repository.name="'+repoName+'" AND repository_writeusers.writeUsers_id='+user
cursor.execute(sql)
resultado=cursor.fetchone()
if resultado == None and command == "git-upload-pack":
	sql='SELECT Repository.id, Repository.name, Repository.Owner FROM Repository INNER JOIN repository_readusers ON Repository.id = repository_readusers.Repository_id WHERE Repository.name="'+repoName+'" AND repository_readusers.readUsers_id='+user
	cursor.execute(sql)
	resultado=cursor.fetchone()
if resultado != None:
	arg
class UserInterfaceLogic():
    def __init__(self, led_controller):
        self.led_controller = led_controller
        self.t0 = time.time()
        self.state_cache = None
    def tick(self):
        if time.time() - self.t0 > 5:
            if self.state_cache:
                self.update_state(self.state_cache)
            self.t0 = time.time()
    def update_state(self, state):
        self.state_cache = state
        tainted = state.is_state_tainted()
        if state.state == state.State.DOWN:
            if not tainted:
                self.led_controller.set_led('down', self.led_controller.LedState.ON)
            else:
                self.led_controller.set_led('down', self.led_controller.LedState.BLINK_SLOW)
            self.led_controller.set_led('closed', self.led_controller.LedState.OFF)
            self.led_controller.set_led('member', self.led_controller.LedState.OFF)
        if state.state == state.State.CLOSED:
            if not tainted:
                self.led_co

            else:
                self.led_controller.set_led('closed', self.led_controller.LedState.BLINK_SLOW)
            self.led_controller.set_led('down', self.led_controller.LedState.OFF)
            self.led_controller.set_led('member', self.led_controller.LedState.OFF)
        if state.state == state.State.MEMBER:
            if not tainted:
                self.led_controller.set_led('member', self.led_controller.LedState.ON)
            else:
                self.led_controller.set_led('member', self.led_controller.LedState.BLINK_SLOW)
            self.led_controller.set_led('down', self.led_controller.LedState.OFF)
            self.led_controller.set_led('closed', self.led_controller.LedState.OFF)
        if state.state == state.State.PUBLIC:
            if not tainted:
                self.led_controller.set_led('closed', self.led_controller.LedState.ON)
                self.led_controller.set_led('down', self.led_controller.LedState.ON)
                self.led_controlle
def is_unbound_method(func):
    return inspect.ismethod(func) and func.im_self is None
class RoutesBinder(object):
    def __init__(self, mapper, annotation):
        self.mapper = mapper
        self._annotation = annotation
        self.controller_map = {}
    def connect(self, *args, **kwargs):
        controller = kwargs.get('controller')
        if controller is None:
            raise TypeError('no controller specified')
        key = unicode((id(controller), repr(controller)))
        self.controller_map[key] = controller
        kwargs['controller'] = key
        self.mapper.connect(*args, **kwargs)
    def match(self, url, environ):
        old_environ, self.mapper.environ = self.mapper.environ, environ
        try:
            return self.mapper.match(url)
        finally:
            self.mapper.environ = old_environ
class RoutesModule(Module):
    annotation = None
    def run_configure(self, binder):
        self._mapper = routes.Mapper()
        self.routes_binder = Rout

        binder.bind(RoutesBinder,
                to_instance=self.routes_binder,
                annotated_with=self.annotation)
        self.configure(self.routes_binder)
        self._mapper.create_regs([])
    def configure(self, routes_binder):
        raise NotImplementedError
class AutoRoutesModule(RoutesModule):
    def configure(self, routes_binder):
        for route, controller in self.configured_routes.items():
            if hasattr(controller, 'im_class'):
                routes_binder.connect(route,
                        controller=controller.im_class,
                        action=controller.__name__)
            else:
                routes_binder.connect(route, controller=controller)
class Application(object):
    def __init__(self, injector):
        self._injector = injector
    def __call__(self, environ, start_response):
        request = Request(environ)
        binder = self._injector.get_instance(RoutesBinder)
        route = binder.match(environ['PATH_INFO

        if not route:
            return HTTPNotFound('no matching route')(environ, start_response)
        controller = route.pop('controller')
        controller = binder.controller_map.get(controller)
        if inspect.isclass(controller):
            action = route.pop('action', 'index')
            controller = self.controller_from_class(controller, action)
        elif is_unbound_method(controller):
            controller = self.controller_from_method(controller)
        elif not callable(controller):
            return HTTPNotFound()(environ, start_response)
        if not controller:
            return HTTPNotFound()(environ, start_response)
        response = controller(request, **route)
        return response(environ, start_response)
    def controller_from_class(self, controller, action):
        controller = self._injector.get_instance(controller)
        return getattr(controller, action, None)
    def controller_from_method(self, controller):
        return self.contro
try:
except ImportError:
try:
except ImportError:
    psutil = None
class localBroker(object):
    def __init__(self, debug, nice=0, backend='ZMQ'):
        """Starts a broker on random unoccupied ports"""
        self.backend = backend
        if backend == 'ZMQ':
        else:
        if nice:
            if not psutil:
                scoop.logger.error("'nice' used while psutil not installed.")
                raise ImportError("psutil is needed for nice functionnality.")
            p = psutil.Process(os.getpid())
            p.set_nice(nice)
        self.localBroker = Broker(debug=debug)
        self.brokerPort, self.infoPort = self.localBroker.getPorts()
        self.broker = Thread(target=self.localBroker.run)
        self.broker.daemon = True
        self.broker.start()
        scoop.logger.debug("Local broker launched on ports {0}, {1}"
                      ".".format(self.brokerPort, self.infoPort))
    def sendConnect(self, data):
        """Send a CONNECT command to the b

            :param data: List of other broker main socket URL"""
        if self.backend == 'ZMQ':
            self.context = zmq.Context()
            self.socket = self.context.socket(zmq.DEALER)
            self.socket.setsockopt(zmq.IDENTITY, b'launcher')
            self.socket.connect(
                "tcp://127.0.0.1:{port}".format(
                    port=self.brokerPort,
                )
            )
            self.socket.send_multipart([b"CONNECT",
                                        pickle.dumps(data,
                                                     pickle.HIGHEST_PROTOCOL)])
        else:
            pass
    def getHost(self):
        return "127.0.0.1"
    def getPorts(self):
        return (self.brokerPort, self.infoPort)
    def close(self):
        scoop.logger.debug('Closing local broker.')
class remoteBroker(object):
    def __init__(self, hostname, pythonExecutable, debug=False, nice=0,
                 backend='ZMQ', rsh=False):
        """Starts a br

        self.backend = backend
        brokerString = ("{pythonExec} -m scoop.broker.__main__ "
                        "--echoGroup "
                        "--echoPorts "
                        "--backend {backend} ".format(
                            pythonExec=pythonExecutable,
                            backend=backend,
                            )
                        )
        if nice:
            brokerString += "--nice {nice} ".format(nice=nice)
        if debug:
            brokerString += "--debug --path {path} ".format(
                path=os.getcwd()
            )
        self.hostname = hostname
        cmd = BASE_RSH if rsh else BASE_SSH + [
            hostname,
            brokerString.format(pythonExec=pythonExecutable)
        ]
        scoop.logger.debug("Launching remote broker: {cmd}"
                           "".format(cmd=" ".join(cmd)))
        self.shell = subprocess.Popen(
            cmd,
            bufsize=0,
            stdout=subprocess.PIPE,

"""Test cases for the SimpleRpcController."""
__author__ = 'nomis52@gmail.com (Simon Newton)'
class SimpleRpcControllerTest(unittest.TestCase):
  def setUp(self):
    self.callback_run = False
  def Callback(self):
    self.callback_run = True
  def testSimpleRpcController(self):
    controller = SimpleRpcController()
    self.assertFalse(controller.Failed())
    self.assertFalse(controller.IsCanceled())
    self.assertEquals(None, controller.ErrorText())
    self.assertFalse(self.callback_run)
    controller.NotifyOnCancel(self.Callback)
    controller.StartCancel()
    self.assertFalse(controller.Failed())
    self.assertFalse(not controller.IsCanceled())
    self.assertEquals(None, controller.ErrorText())
    self.assertFalse(not self.callback_run)
    self.callback_run = False
    controller.Reset()
    self.assertFalse(controller.Failed())
    self.assertFalse(controller.IsCanceled())
    self.assertEquals(None, controller.ErrorText())
    failure_string = 'foo'
    controller.Set
try:
except ImportError:
class ZopeRepository(
    Repository.Repository,
    RoleManager,
    OFS.SimpleItem.Item
    ):
    """The ZopeRepository class builds on the core Repository implementation
       to provide the Zope management interface and other product trappings."""
    security = AccessControl.ClassSecurityInfo()
    meta_type = 'Repository'
    manage_options=(
        ( {'label': 'Contents',    'action':'manage_main',
           'help': ('ZopeVersionControl', 'Repository-Manage.stx')},
          {'label': 'Properties', 'action':'manage_properties_form',
           'help': ('ZopeVersionControl', 'Repository-Properties.stx')},
        ) +
        RoleManager.manage_options +
        OFS.SimpleItem.Item.manage_options
        )
    security.declareProtected('View management screens', 'manage_main')
    manage_main = DTMLFile('dtml/RepositoryManageMain', globals())
    manage_main._setName('manage_main')
    manage = manage_main
    def __init__(self, id=None, title=''):
   

        if id is not None:
           self._setId( id )
        self.title = title
    security.declareProtected(
        'View management screens','manage_properties_form'
        )
    manage_properties_form = DTMLFile('dtml/RepositoryProperties', globals())
    security.declareProtected('Manage repositories', 'manage_edit')
    def manage_edit(self, title='', REQUEST=None):
        """Change object properties."""
        self.title = title
        if REQUEST is not None:
            message="Saved changes."
            return self.manage_properties_form(
                self, REQUEST, manage_tabs_message=message
                )
    def __getitem__(self, name):
        history = self._histories.get(name)
        if history is not None:
            return history.__of__(self)
        raise KeyError, name
    security.declarePrivate('objectIds')
    def objectIds(self, spec=None):
        return SequenceWrapper(self, self._histories.keys())
    security.declarePrivate('objectValues'
"""Unittests for the MDPWorker class.
"""
__license__ = """
    This file is part of MDP.
    MDP is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    MDP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with MDP.  If not, see <http://www.gnu.org/licenses/>.
"""
__author__ = 'Guido Goldstein'
__email__ = 'gst-py@a-nugget.de'
_do_print = True
class MyWorker(MDPWorker):
    HB_LIVENESS = 10
    def on_request(self, msg):
        answer = ['REPLY'] + msg
        self.reply(answer)
        return
class Test_MDPWorker(unittest.TestCase):
    end

    service = b'test'
    def setUp(self):
        print 'set up'
        sys.stdout.flush()
        self.context = zmq.Context()
        self.broker = None
        self._msgs = []
        return
    def tearDown(self):
        print 'tear down'
        sys.stdout.flush()
        if self.broker:
            self._stop_broker()
        self.broker = None
        self.context = None
        return
    def _on_msg(self, msg):
        if _do_print:
            print 'broker received:',
            pprint(msg)
        self.target = msg.pop(0)
            print 'READY'
            self.target = msg[0]
            return
            print 'HB'
            return
            IOLoop.instance().stop()
            return
        return
    def _start_broker(self, do_reply=False):
        """Helper activating a fake broker in the ioloop.
        """
        socket = self.context.socket(zmq.XREP)
        self.broker = ZMQStream(socket)
        self.broker.socket.setsockopt(zmq.LINGER, 0)
        s

        self.broker.on_recv(self._on_msg)
        self.broker.do_reply = do_reply
        self.broker.ticker = PeriodicCallback(self._tick, MyWorker.HB_INTERVAL)
        self.broker.ticker.start()
        self.target = None
        return
    def _stop_broker(self):
        if self.broker:
            self.broker.ticker.stop()
            self.broker.ticker = None
            self.broker.socket.close()
            self.broker.close()
            self.broker = None
        return
    def _tick(self):
        if self.broker and self.target:
            msg = [self.target, b'MPDW01', chr(4)]
            self.broker.send_multipart(msg)
        return
    def send_req(self):
        data = ['AA', 'bb']
        msg = [self.target, b'MPDW01', chr(2), self.target, b''] + data
        print 'borker sending:',
        pprint(msg)
        self.broker.send_multipart(msg)
        return
    def test_01_simple_01(self):
        """Test MDPWorker simple req/reply.
        """
        self._start_bro
class RepositoryAuthorizationTests(AuthenticationTest):
  def setUp(self):
    ApplicationTest.setUp(self)
    self.startApplication(pluginPackages={
      IAuth: repoAuthorization
    })
  def testSSHPush(self):
    remoteRepository = self._testPush(None)
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository, keyFile = "test").addCallback(processEnded)
  def testSSHPull(self):
    remoteRepository = self._testPull(None)
    def processEnded(result):
      self.assertError("Only PUSH requests are supported.")
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pullRepository(self.repository, keyFile = "test").addCallback(processEnded)
  def testHTTPPush(self):
    remoteRepository = self._testPush(None, True)
    def processEnded(result):
      self.assertError("Only PUSH requests are supported.")
      self.assertNotEqual(self.repository, remoteRepositor

    return self.pushRepository(self.repository).addCallback(processEnded)
  def testHTTPPull(self):
    remoteRepository = self._testPull(None, True)
    def processEnded(result):
      self.assertError("Only PUSH requests are supported.")
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pullRepository(self.repository).addCallback(processEnded)
class PerLabelAuthorizationTests(ApplicationTest):
  def setUp(self):
    ApplicationTest.setUp(self)
    self.startApplication(pluginPackages={
      IAuth: refsAuthorization
    })
  def testSSHUnauthorizedPush(self):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(None, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("ssh", self.ssh, remoteRepository.path.split('/')[-1]))
    self.generateComplicatedCommit()
    def processEnded(result):
      self.assertNotSuccess()
      self.assertNotEqual(self.repository, remoteRepository)
    return self.

  def testHTTPUnauthorizedPush(self):
    self.repository.initialize()
    remoteRepository = self.createTemporaryRepository(None, self.repository.path, True)
    self.repository.addRemote("origin", formatRemote("http", self.http, remoteRepository.path.split('/')[-1]))
    self.generateComplicatedCommit()
    def processEnded(result):
      self.assertError("You are not allowed to PUSH to second-branch.")
      self.assertNotEqual(self.repository, remoteRepository)
    return self.pushRepository(self.repository).addCallback(processEnded)
  def testSSHAuthorizedPull(self):
    self.repository.initialize()
    otherRepository = self.createTemporaryRepository(None, self.repository.path, False)
    self.repository.addRemote("origin", formatRemote("ssh", self.ssh, otherRepository.path.split('/')[-1]))
    self.generateComplicatedCommit(otherRepository)
    def processEnded(result):
      self.assertNoError()
      self.assertEqual(self.repository, otherRepository)
    self.assertNotEqual(s
"""Main Controller"""
__all__ = ['RootController']
class RootController(BaseController):
    """
    The root controller for the Brie application.
    
    All the other controllers and WSGI applications should be mounted on this
    controller. For example::
    
        panel = ControlPanelController()
        another_app = AnotherWSGIApplication()
    
    Keep in mind that WSGI applications shouldn't be mounted directly: They
    must be wrapped around with :class:`tg.controllers.WSGIAppController`.
    
    """
    auth = AuthRestController()
    rooms = RoomsController()
    show = ShowController()
    edit = EditController(show)
    members = MembersController(edit)
    administration = AdministrationController()
    stats = StatsController()
    getemails = GetEmailsController()
    error = ErrorController()
    search = SearchController()
    registration = RegistrationController(edit, administration)
    treasury = TreasuryController()
    plugins = PluginsController()
    
 
class TestDialogController(unittest.TestCase):
  def setUp(self):
    pass
  def tearDown(self):
    if(hasattr(DialogController, '_instance')):
      DialogController._instance = None
  def test_success(self):
    self.controller = DialogController(parent_window=Tk.Tk())
    self.assertNotEqual(self.controller, None, "DialogController should be defined if" + \
      "tkinter.Tk() instance is passed in")
  def test_success_with_subsequent_calls(self):
    try:
      self.controller = DialogController(parent_window=Tk.Tk())
      self.controller = DialogController()
    except ValueError as e:
      self.fail("Menu Controller should work after being initialized property" + \
        "and being called subsequently without arguments.")
  def test_singleton(self):
    try:
      self.controller = DialogController()
      self.fail("DialogController needs to be passed reference " + \
        "to tkinter.Tk() upon first instantiation")
    except ValueError as e:
      pass
  def test_wrong_
urlpatterns = patterns('management.views',
    url(r'^manage/organization/$', 'view_managing_organization', name='view_managing_organization'),
    url(r'^manage/users/$', 'view_managing_users', name='view_managing_users'),
    url(r'^manage/users/section/$', 'view_managing_section_users', name='view_managing_section_users'),
    url(r'^manage/users/project/$', 'view_managing_project_users', name='view_managing_project_users'),
    url(r'^manage/users/add/$', 'add_managing_user', name='add_managing_user'),
    url(r'^manage/users/(?P<user_id>\d+)/add/responsibility/$', 'add_managing_user_responsibility', name='add_managing_user_responsibility'),
    url(r'^manage/users/(?P<user_id>\d+)/password/$', 'view_managing_user_password', name='view_managing_user_password'),
    url(r'^manage/users/(?P<user_id>\d+)/edit/$', 'edit_managing_user', name='edit_managing_user'),
    url(r'^manage/users/(?P<user_id>\d+)/edit/projects/$', 'edit_managing_user_projects', name='edit_managing_user_projects'
__version__='$Revision: 1.6 $'[11:-2]
class ZopeVersion(
    Version.Version,
    AccessControl.Role.RoleManager,
    OFS.SimpleItem.Item
    ):
    """The ZopeVersion class builds on the core Version class to provide
       the Zope management interface and other product trappings."""
    security = AccessControl.ClassSecurityInfo()
    security.setDefaultAccess('deny')
    meta_type = 'Version'
    manage_options=(
        ( {'label': 'Information',  'action':'manage_main',
           'help': ('ZopeVersionControl', 'Version-Manage.stx')},
          {'label': 'Properties', 'action':'manage_properties_form',
           'help': ('ZopeVersionControl', 'Version-Properties.stx')},
        ) +
        AccessControl.Role.RoleManager.manage_options +
        OFS.SimpleItem.Item.manage_options
        )
    icon='misc_/ZopeVersionControl/Version.gif'
    security.declareProtected('View management screens', 'manage_main')
    manage_main = DTMLFile('dtml/VersionManageMain', globals())
    manag
log = logging.getLogger( __name__ )
def default_value_mapper( trans, repository_metadata ):
    value_mapper = { 'id' : trans.security.encode_id( repository_metadata.id ),
                     'repository_id' : trans.security.encode_id( repository_metadata.repository_id ) }
    if repository_metadata.time_last_tested:
        value_mapper[ 'time_last_tested' ] = time_ago( repository_metadata.time_last_tested )
    return value_mapper
class RepositoryRevisionsController( BaseAPIController ):
    """RESTful controller for interactions with tool shed repository revisions."""
    @web.expose_api
    def index( self, trans, **kwd ):
        """
        GET /api/repository_revisions
        Displays a collection (list) of repository revisions.
        """
        repository_metadata_dicts = []
        clause_list = []
        downloadable =  kwd.get( 'downloadable', None )
        if downloadable is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.downloadable

        malicious =  kwd.get( 'malicious', None )
        if malicious is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.malicious == util.string_as_bool( malicious ) )
        tools_functionally_correct = kwd.get( 'tools_functionally_correct', None )
        if tools_functionally_correct is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.tools_functionally_correct == util.string_as_bool( tools_functionally_correct ) )
        missing_test_components = kwd.get( 'missing_test_components', None )
        if missing_test_components is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.missing_test_components == util.string_as_bool( missing_test_components ) )
        do_not_test = kwd.get( 'do_not_test', None )
        if do_not_test is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.do_not_test == util.string_as_bool( do_not_test ) )
        includes_tools = 

        if includes_tools is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.includes_tools == util.string_as_bool( includes_tools ) )
        test_install_error = kwd.get( 'test_install_error', None )
        if test_install_error is not None:
            clause_list.append( trans.model.RepositoryMetadata.table.c.test_install_error == util.string_as_bool( test_install_error ) )
        skip_tool_test = kwd.get( 'skip_tool_test', None )
        if skip_tool_test is not None:
            skip_tool_test = util.string_as_bool( skip_tool_test )
            skipped_metadata_ids_subquery = select( [ trans.app.model.SkipToolTest.table.c.repository_metadata_id ] )
            if skip_tool_test:
                clause_list.append( trans.model.RepositoryMetadata.id.in_( skipped_metadata_ids_subquery ) )
            else:
                clause_list.append( not_( trans.model.RepositoryMetadata.id.in_( skipped_metadata_ids_subquery ) ) )
        try:
            q
admin.autodiscover()
urlpatterns = patterns('',
    
    url(r'^admin/', include(admin.site.urls)),
    url(r'^db/api/clear/$', 'api.views.dbclear.clear', name='db_clear'),
    url(r'^db/api/user/create/$', 'api.views.user.create', name='user_create'),
    url(r'^db/api/user/details/$', 'api.views.user.details', name='user_details'),
    url(r'^db/api/user/follow/$', 'api.views.user.follow', name='user_follow'),
    url(r'^db/api/user/unfollow/$', 'api.views.user.unfollow', name='user_unfollow'),
    url(r'^db/api/user/listFollowers/$', 'api.views.user.list_followers', name='user_list_followers'),
    url(r'^db/api/user/listFollowing/$', 'api.views.user.list_following', name='user_list_following'),
    url(r'^db/api/user/updateProfile/$', 'api.views.user.update', name='user_update'),
    url(r'^db/api/user/listPosts/$', 'api.views.user.list_posts', name='user_posts'),
    url(r'^db/api/post/create/$', 'api.views.post.create', name='post_create'),
    url(r'^db/api/post/details/$', 'api

    url(r'^db/api/post/list/$', 'api.views.post.post_list', name='post_post_list'),
    url(r'^db/api/post/remove/$', 'api.views.post.remove', name='post_remove'),
    url(r'^db/api/post/restore/$', 'api.views.post.restore', name='post_restore'),
    url(r'^db/api/post/update/$', 'api.views.post.update', name='post_update'),
    url(r'^db/api/post/vote/$', 'api.views.post.vote', name='post_vote'),
    url(r'^db/api/forum/create/$', 'api.views.forum.create', name='forum_create'),
    url(r'^db/api/forum/details/$', 'api.views.forum.details', name='forum_details'),
    url(r'^db/api/forum/listThreads/$', 'api.views.forum.list_threads', name='forum_listThreads'),
    url(r'^db/api/forum/listPosts/$', 'api.views.forum.list_posts', name='forum_listPosts'),
    url(r'^db/api/forum/listUsers/$', 'api.views.forum.list_users', name='forum_listUsers'),
    url(r'^db/api/thread/create/$', 'api.views.thread.create', name='thread_create'),
    url(r'^db/api/thread/details/$', 'api.views.thread.det
def get_channel_rules():
    rules = [Rule('/', endpoint='channel.index')]
    tmp = '/'
    for digits, part in ((4, 'year'), (2, 'month'), (2, 'day')):
        tmp += '<int(fixed_digits=%d):%s>/' % (digits, part)
        rules.extend([
            Rule(tmp, defaults={'page': 1}, endpoint='channel.browse'),
            Rule(tmp + 'page/<int:page>', endpoint='channel.browse'),
        ])
    return rules
urls_map = Map([
    Rule('/', endpoint='index'),
    Submount('/account', [
        Rule('/login', endpoint='account.login'),
        Rule('/logout', endpoint='account.logout'),
        Rule('/delete', endpoint='account.delete'),
        Rule('/profile', endpoint='account.profile'),
        Rule('/dashboard', endpoint='account.dashboard'),
        Rule('/__rpx__', endpoint='account.rpx'),
        Rule('/register', endpoint='account.register'),
        Rule('/__rpx_providers__', endpoint='account.rpx_providers'),
        Rule('/activate', defaults={'key': None}, endpoint='account.activ

        Rule('/activate/<string:key>', endpoint='account.activate')
    ]),
    Submount('/network', [
        Rule('/', endpoint='network.index'),
        Rule('/', endpoint='network.index2'),
        Submount('/<string:network>', [
            Rule('/', endpoint='network.channels'),
            Submount('/<string:channel>', get_channel_rules())
        ]),
    ]),
    Submount('/admin', [
        Rule('/', endpoint='admin.index'),
        Submount('/manage', [
            Rule('/', endpoint='admin.manage.groups'),
            Submount('/groups', [
                Rule('/', endpoint='admin.manage.groups'),
                Rule('/new', endpoint='admin.manage.groups.new'),
                Rule('/edit/<int:group_id>',
                     endpoint='admin.manage.groups.edit'),
                Rule('/delete/<int:group_id>',
                     endpoint='admin.manage.groups.delete'),
            ]),
            Submount('/users', [
                Rule('/', endpoint='admin.manage.users'),

                Rule('/new', endpoint='admin.manage.users.new'),
                Rule('/edit/<int:user_id>',
                     endpoint='admin.manage.users.edit'),
                Rule('/delete/<int:user_id>',
                     endpoint='admin.manage.users.delete'),
            ]),
            Submount('/networks', [
                Rule('/', endpoint='admin.manage.networks'),
                Rule('/new', endpoint='admin.manage.networks.new'),
                Rule('/edit/<int:network_id>',
                     endpoint='admin.manage.networks.edit'),
                Rule('/delete/<network_id>',
                     endpoint='admin.manage.networks.delete'),
            ]),
            Submount('/channels', [
                Rule('/', endpoint='admin.manage.channels'),
                Rule('/new', endpoint='admin.manage.channels.new'),
                Rule('/edit/<int:channel_id>',
                     endpoint='admin.manage.channels.edit'),
                Rule('/delete/<channel_i
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 6
_modified_time = 1418449607.913338
_template_filename='templates/admin/tool_shed_repository/repository_installation_status.mako'
_template_uri='admin/tool_shed_repository/repository_installation_status.mako'
_template_cache=cache.Cache(__name__, _modified_time)
_source_encoding='ascii'
_exports = ['render_repository_status']
def render_body(context,**pageargs):
    context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        def render_repository_status(repository):
            return render_render_repository_status(context.locals_(__M_locals),repository)
        repository = context.get('repository', UNDEFINED)
        __M_writer = context.writer()
        __M_writer(u'\n\n')
        __M_writer(unicode(render_repository_status( repository )))
        __M_writer(u'\n')
        return ''
    finally:
        context.caller_stack._pop_frame()

def render_render_repository_status(context,repository):
    context.caller_stack._push_frame()
    try:
        trans = context.get('trans', UNDEFINED)
        __M_writer = context.writer()
        __M_writer(u'\n    ')
        if repository.status in [ trans.install_model.ToolShedRepository.installation_status.CLONING,
                                  trans.install_model.ToolShedRepository.installation_status.SETTING_TOOL_VERSIONS,
                                  trans.install_model.ToolShedRepository.installation_status.INSTALLING_TOOL_DEPENDENCIES,
                                  trans.install_model.ToolShedRepository.installation_status.LOADING_PROPRIETARY_DATATYPES ]:
            bgcolor = trans.install_model.ToolShedRepository.states.INSTALLING
        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.NEW,
                                    trans.install_model.ToolShedRepository.installation_status.UNINSTALLED ]:
            bgcolor = 

        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.ERROR ]:
            bgcolor = trans.install_model.ToolShedRepository.states.ERROR
        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.DEACTIVATED ]:
            bgcolor = trans.install_model.ToolShedRepository.states.WARNING
        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.INSTALLED ]:
            if repository.missing_tool_dependencies or repository.missing_repository_dependencies:
                bgcolor = trans.install_model.ToolShedRepository.states.WARNING
            else:
                bgcolor = trans.install_model.ToolShedRepository.states.OK
        else:
            bgcolor = trans.install_model.ToolShedRepository.states.ERROR
        rval = '<div class="count-box state-color-%s" id="RepositoryStatus-%s">' % ( bgcolor, trans.security.encode_id( repository.id ) )
        rval += '%s</div>' % 
mail_new_user = django.dispatch.Signal(providing_args=["user"])
mail_recovery_password = django.dispatch.Signal(providing_args=["user"])
mail_question_created = django.dispatch.Signal(providing_args=["question", "user"])
mail_question_assigned = django.dispatch.Signal(providing_args=["question", "user"])
mail_question_deleted = django.dispatch.Signal(providing_args=["question", "user"])
mail_project_created = django.dispatch.Signal(providing_args=["project", "user"])
mail_project_modified = django.dispatch.Signal(providing_args=["project", "user"])
mail_project_deleted = django.dispatch.Signal(providing_args=["project", "user"])
mail_milestone_created = django.dispatch.Signal(providing_args=["milestone", "user"])
mail_milestone_modified = django.dispatch.Signal(providing_args=["milestone", "user"])
mail_milestone_deleted = django.dispatch.Signal(providing_args=["milestone", "user"])
mail_userstory_created = django.dispatch.Signal(providing_args=["us", "user"])
mail_userstory_modified =
urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^profile/$', views.manage_profile, name='manage_profile'),
    url(r'^profile/edit/$', views.profile_edit, name='profile_edit'),
    url(r'^professional-profile/$', views.manage_pro_profile, name='manage_pro_profile'),
    url(r'^professional-profile/edit$', views.pro_profile_edit, name='pro_profile_edit'),
    url(r'^authentication/$', views.manage_authentication, name='manage_authentication'),
    url(r'^identities/$', views.manage_identities, name='manage_identities'),
    url(r'^licenses/$', views.manage_licenses, name='manage_licenses'),
    url(r'^applications/$', views.manage_applications, name='manage_applications'),
    url(r'^notifications/settings/$', views.manage_notifications, name='manage_notifications'),
    url(r'^register/$', views.register, name='register'),
    url(r'^nees-account/(?:(?P<step>\d+)/)?$', views.nees_migration, name='nees_migration'),
    url(r'^registration-successful/$', views.regist
'''
Created on 24 avr. 2013
@author: guillaume
'''
class Metrics(object):
    BROKER_in_nb_worker_reply = 'BROKER_in_nb_worker_reply'
    BROKER_out_nb_client_reply = 'BROKER_out_nb_client_reply'
    BROKER_in_nb_client_request = 'BROKER_in_nb_client_request'
    BROKER_out_nb_worker_request = 'BROKER_out_nb_worker_request'
    BROKER_in_invalid = 'BROKER_in_invalid'
    nb_inc = 0
    measures = {BROKER_in_nb_worker_reply: 0,
                BROKER_out_nb_client_reply: 0,
                BROKER_in_nb_client_request: 0,
                BROKER_out_nb_worker_request: 0,
                BROKER_in_invalid: 0}
    def __init__(self, params):
        '''
        Constructor
        '''
        pass
    @staticmethod
    def addmetric(metric):
        if not metric in Metrics.measures.keys():
            Metrics.measures[metric] = 0
    @staticmethod
    def inc(metric):
        Metrics.nb_inc = Metrics.nb_inc + 1
        if metric in Metrics.measures.keys():
            Metrics.measures[metr
class NewPygameController:
    """ Command to Create a new Pygame Controller """
    TEMPLATE_LOADER = TemplateLoader("pygame_controller.py", TemplatesRoot)
    
    def addArguments(self, parser):
        """ Add arguments to the parser """
        parser.add_argument('destination', action='store', help='Destination for the new pygame controller')
    
    def run(self, arguments):
        """ Run the command """
        controllerFileName = arguments.destination
        controllerName = GetPythonClassnameFromFilename(controllerFileName)
        print "Creating Pygame Controller:", controllerName, "at:", controllerFileName
        self.createController(controllerFileName, controllerName)
        
    def createController(self, controllerFileName, controllerName):
        """ Create the controller file """
        viewName = controllerName.replace("Controller", "Screen")
        viewFileName = controllerFileName.replace("controller", "screen")
        keywords = {"%ControllerName%":con
class PermissionService:
    def check(req, data={}, **kwargs):
        data.update(kwargs)
        res = None
        if isinstance(req, ApiBulletinsHandler):
            res = ApiBulletinsPermission.check(req, data) 
        elif isinstance(req, ApiBulletinHandler):
            res = ApiBulletinPermission.check(req, data)
        elif isinstance(req, ApiProblemsHandler):
            res = ApiProblemsPermission.check(req, data)
        elif isinstance(req, ApiProblemHandler):
            res = ApiProblemPermission.check(req, data)
        elif isinstance(req, ApiProblemExecuteHandler):
            res = ApiProblemExecutePermission.check(req, data)
        elif isinstance(req, ApiProblemTagHandler):
            res = ApiProblemTagPermission.check(req, data)
        elif isinstance(req, ApiProblemRejudgeHandler):
            res = ApiProblemRejudgePermission.check(req, data)
        elif isinstance(req, ApiSubmissionsHandler):
            res = ApiSubmissionsPermission.check(req, data)


            res = ApiSubmissionPermission.check(req, data)
        elif isinstance(req, ApiSubmissionRejudgeHandler):
            res = ApiSubmissionRejudgePermission.check(req, data)
        elif isinstance(req, ApiExecuteTypesHandler):
            res = ApiExecuteTypesPermission.check(req, data)
        elif isinstance(req, ApiExecuteTypeHandler):
            res = ApiExecuteTypePermission.check(req, data)
        elif isinstance(req, ApiExecuteTypesPriorityHandler):
            res = ApiExecuteTypesPriorityPermission.check(req, data)
        elif isinstance(req, ApiVerdictTypesHandler):
            res = ApiVerdictTypesPermission.check(req, data)
        elif isinstance(req, ApiVerdictTypeHandler):
            res = ApiVerdictTypePermission.check(req, data)
        elif isinstance(req, ApiTestdatasHandler):
            res = ApiTestdatasPermission.check(req, data)
        elif isinstance(req, ApiTestdataHandler):
            res = ApiTestdataPermission.check(req, data)
        elif

            res = ApiContestsPermission.check(req, data)
        elif isinstance(req, ApiContestHandler):
            res = ApiContestPermission.check(req, data)
        elif isinstance(req, ApiContestSubmissionsHandler):
            res = ApiContestSubmissionsPermission.check(req, data)
        elif isinstance(req, ApiContestScoreboardHandler):
            res = ApiContestScoreboardPermission.check(req, data)
        elif isinstance(req, ApiUsersHandler):
            res = ApiUsersPermission.check(req, data)
        elif isinstance(req, ApiUserHandler):
            res = ApiUserPermission.check(req, data)
        elif isinstance(req, ApiGroupsHandler):
            res = ApiGroupsPermission.check(req, data)
        elif isinstance(req, ApiGroupHandler):
            res = ApiGroupPermission.check(req, data)
        elif isinstance(req, ApiGroupUserHandler):
            res = ApiGroupUserPermission.check(req, data)
        elif isinstance(req, ApiGroupUserPowerHandler):
            res 
class PrintVisitor(Visitor):
    def visitModule(self, n):
        return self.dispatch(n.node)
    def visitStmt(self, n):
        return '{\n' + '\n'.join([self.dispatch(s) for s in n.nodes]) + '\n}'
    def visitCallX86(self, n):
        return 'call ' + n.name
    def visitPush(self, n):
        return 'push ' + self.dispatch(n.arg)
    def visitPop(self, n):
        return 'pop ' + repr(n.bytes)
    def visitIntMoveInstr(self, n):
        return '%s = %s' % (self.dispatch(n.lhs),
                             self.dispatch(n.rhs[0]))
    def visitIntAddInstr(self, n):
        return '%s += %s' % (self.dispatch(n.lhs),
                             self.dispatch(n.rhs[0]))
    def visitIntLEAInstr(self, n):
        return '%s = %s + %s' % (self.dispatch(n.lhs),
                                 self.dispatch(n.rhs[0]),
                                 self.dispatch(n.rhs[1]))
    def visitIntSubInstr(self, n):
        return '%s -= %s' % (self.dispatch(n.lhs),
                        
'''
'''
sys.path.append('..')
class Broker():
    def __init__(self, conf_path = ''):
        logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level = logging.DEBUG)
        self.conf = Configure(conf_path).conf
        self.meta = MetaManager(self.conf['meta-server'], self.conf['meta-root'])
        logging.info('broker init OK, conf: %s' % str(self.conf))
        logging.info('broker init OK, zk addr: %s, zk root: %s' % (self.conf['meta-server'], self.conf['meta-root']))
    def register_to_serve(self):
        node_path = '/Broker'
        node_value = "%s:%s" % (socket.gethostbyname(platform.node()), self.conf['listen-port'])
        self.meta.create_node(node_path)
        if self.meta.register_node(path = node_path, value = node_value):
            logging.info('register broker OK, addr %s' % node_value)
            return True
        else:
            logging.error('register broker failed, addr %s' % node_value)
            return False
    def start_rest
class Channel(RpcChannel):
    def __init__(self, loop=None):
        self._header = "!I"
        self._loop = loop or get_hub().loop
        self._services = {}
        self._pending_request = {}
        self._transmit_id = 0
        self._send_queue = {}
        self._default_sock = None
        self._greenlet_accept = {}
    def set_default_sock(self, sock):
        if self._default_sock is not None:
            self._default_sock.close()
        self._default_sock = sock
    def append_service(self, service):
        self._services[service.DESCRIPTOR.full_name] = service
    def CallMethod(self, method, controller, request, response_class, done):
        if not isinstance(controller, Controller):
            raise Exception("controller should has type Controller")
        controller.response_class = response_class
        controller.proto.full_service_name = method.containing_service.full_name
        controller.proto.method_name = method.name
        if controller.sock is None:
  

        if controller.proto.notify:
            return self.send_notify(controller, request)
        else:
            return self.send_request(controller, request)
    def send_request(self, controller, request):
        if not self._send_queue.has_key(controller.sock):
            controller.SetFailed("did not connect")
            return None
        self._transmit_id += 1
        controller.async_result = AsyncResult()
        controller.proto.transmit_id = self._transmit_id
        self._pending_request[self._transmit_id] = controller
        controller.proto.stub = True
        controller.proto.message = request.SerializeToString()
        self._send_queue[controller.sock].put(controller)
        return controller.async_result.get()
    def send_notify(self, controller, request):
        controller.proto.stub = True
        controller.proto.message = request.SerializeToString()
        self._send_queue[controller.sock].put(controller)
        return None
    def send_response(se

        controller.proto.stub = False
        if not controller.Failed:
            controller.proto.message = response.SerializeToString()
        self._send_queue[controller.sock].put(controller)
    def connect(self, host, port, as_default=False):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        while True:
            try:
                result = sock.connect((host, port))
            except socket.error as err:
                raise
            else:
                break
        self.new_connection(sock)
        if as_default:
            self.set_default_sock(sock)
        return sock
    def listen(self, host, port, backlog=1):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((host, port))
        sock.listen(backlog)
        greenlet_accept = Greenlet.spawn(self._do_accept, sock)
        self._greenlet_accept[sock] = greenlet_accept
    def new_c
  'variables': {
    'chromium_code': 1,
  },
  'includes': [
    '../../../build/common.gypi',
  ],
  'targets': [
    {
      'target_name': 'broker_rpc_idl',
      'type': 'none',
      'sources': [
        'broker_rpc_lib.idl',
      ],
      'msvs_settings': {
        'VCMIDLTool': {
          'OutputDirectory': '<(SHARED_INTERMEDIATE_DIR)',
          'DLLDataFileName': '$(InputName)_dlldata.c',
          'DefaultCharType': '0',
          'AdditionalOptions': '/prefix all "BrokerRpcClient_" '
                               'server "BrokerRpcServer_"'
        },
      },
      'direct_dependent_settings': {
        'include_dirs': ['<(SHARED_INTERMEDIATE_DIR)'],
      },
    },
    {
      'target_name': 'broker_rpc_lib',
      'type': 'static_library',
      'dependencies': [
        'broker_rpc_idl',
      ],
      'sources': [
        '<(SHARED_INTERMEDIATE_DIR)/broker_rpc_lib_c.c',
        '<(SHARED_INTERMEDIATE_DIR)/broker_rpc_lib_s.c',
      ],
      'msvs_settings': {
      

          'UsePrecompiledHeader': '0',
          'ForcedIncludeFiles': '$(NOINHERIT)',
        },
      },
    },
    {
      'target_name': 'broker',
      'type': 'static_library',
      'dependencies': [
        'broker_rpc_idl',
        '../common/common.gyp:ie_common',
        '../common/common.gyp:ie_common_settings',
        '../plugin/toolband/toolband.gyp:toolband_idl',
        '../../../base/base.gyp:base',
        '../../../build/temp_gyp/googleurl.gyp:googleurl',
        '../../../ceee/common/common.gyp:initializing_coclass',
        '../../../ceee/common/common.gyp:ceee_common',
        '<(DEPTH)/chrome_frame/chrome_frame.gyp:chrome_tab_idl',
        '<(DEPTH)/webkit/support/webkit_support.gyp:webkit_user_agent',
      ],
      'sources': [
        'api_dispatcher.cc',
        'api_dispatcher.h',
        'api_dispatcher_docs.h',
        'api_module_constants.cc',
        'api_module_constants.h',
        'api_module_util.cc',
        'api_module_util.h',
        'broker.c

        'broker.h',
        'broker_docs.h',
        'broker_rpc_client.cc',
        'broker_rpc_client.h',
        'broker_rpc_server.cc',
        'broker_rpc_server.h',
        'broker_rpc_utils.cc',
        'broker_rpc_utils.h',
        'chrome_postman.cc',
        'chrome_postman.h',
        'common_api_module.cc',
        'common_api_module.h',
        'cookie_api_module.cc',
        'cookie_api_module.h',
        'event_dispatching_docs.h',
        'executors_manager.cc',
        'executors_manager.h',
        'executors_manager_docs.h',
        'infobar_api_module.cc',
        'infobar_api_module.h',
        'tab_api_module.cc',
        'tab_api_module.h',
        'webnavigation_api_module.cc',
        'webnavigation_api_module.h',
        'webrequest_api_module.cc',
        'webrequest_api_module.h',
        'window_api_module.cc',
        'window_api_module.h',
        'window_events_funnel.cc',
        'window_events_funnel.h',
        '<(DEPTH)/chrome_frame/metrics_service.
CONF = config.CONF
LOG = logging.getLogger(__name__)
class SimpleReadOnlyNovaManageTest(tempest.cli.ClientTestBase):
    """
    This is a first pass at a simple read only nova-manage test. This
    only exercises client commands that are read only.
    This should test commands:
    * with and without optional parameters
    * initially just check return codes, and later test command outputs
    """
    @classmethod
    def setUpClass(cls):
        if not CONF.service_available.nova:
            msg = ("%s skipped as Nova is not available" % cls.__name__)
            raise cls.skipException(msg)
        if not CONF.cli.has_manage:
            msg = ("%s skipped as *-manage commands not available"
                   % cls.__name__)
            raise cls.skipException(msg)
        super(SimpleReadOnlyNovaManageTest, cls).setUpClass()
    def test_admin_fake_action(self):
        self.assertRaises(subprocess.CalledProcessError,
                          self.nova_manage,
                

    def test_help_flag(self):
        self.nova_manage('', '-h')
    def test_version_flag(self):
        self.assertNotEqual("", self.nova_manage('', '--version',
                                                 merge_stderr=True))
        self.assertEqual(self.nova_manage('version'),
                         self.nova_manage('', '--version', merge_stderr=True))
    def test_debug_flag(self):
        self.assertNotEqual("", self.nova_manage('flavor list',
                            '--debug'))
    def test_verbose_flag(self):
        self.assertNotEqual("", self.nova_manage('flavor list',
                            '--verbose'))
    def test_version(self):
        self.assertNotEqual("", self.nova_manage('version'))
    def test_flavor_list(self):
        self.assertNotEqual("", self.nova_manage('flavor list'))
    def test_db_archive_deleted_rows(self):
        self.nova_manage('db archive_deleted_rows 50')
    def test_db_sync(self):
        self.nova_manage('db sync')
    def te
"""
Base classes for storage engines
"""
_BACKEND_MAPPING = {'sqlalchemy': 'cue.db.sqlalchemy.api'}
IMPL = db_api.DBAPI.from_config(cfg.CONF, backend_mapping=_BACKEND_MAPPING,
                                lazy=True)
def get_instance():
    """Return a DB API instance."""
    return IMPL
@six.add_metaclass(abc.ABCMeta)
class Connection(object):
    """Base class for storage system connections."""
    @abc.abstractmethod
    def __init__(self):
        """Constructor."""
    @abc.abstractmethod
    def get_clusters(self, context, *args, **kwargs):
        """Returns a list of Cluster objects for specified project_id.
        :param context: request context object
        :returns: a list of :class:'Cluster' object
        """
    @abc.abstractmethod
    def create_cluster(self, context, cluster_values):
        """Creates a new cluster.
        :param context: request context object
        :param cluster_values: Dictionary of several required items
               ::
               {


                'project_id': obj_utils.str_or_none,
                'name': obj_utils.str_or_none,
                'flavor': obj_utils.str_or_none,
                'size': obj_utils.int_or_none,
                'volume_size': obj_utils.int_or_none,
               }
        """
    @abc.abstractmethod
    def update_cluster(self, context, cluster_values, cluster_id):
        """Updates values in a cluster record indicated by cluster_id
        :param context: request context object
        :param cluster_values: Dictionary of cluster values to update
        :param cluster_id: UUID of a cluster
        """
    @abc.abstractmethod
    def get_cluster_by_id(self, context, cluster_id):
        """Returns a Cluster objects for specified cluster_id.
        :param context: request context object
        :param cluster_id: UUID of a cluster
        :returns: a :class:'Cluster' object
        """
    @abc.abstractmethod
    def get_nodes_in_cluster(self, context, cluster_id):
        """Retu

        :param context: request context object
        :param cluster_id: UUID of the cluster
        :returns: a list of :class:'Node' object
        """
    @abc.abstractmethod
    def get_node_by_id(self, context, node_id):
        """Returns a node for the specified node_id.
        :param context: request context object
        :param node_id: UUID of the node
        :returns: a :class:'Node' object
        """
    @abc.abstractmethod
    def update_node(self, context, node_values, node_id):
        """Updates values in a node record indicated by node_id
        :param context: request context object
        :param node_values: Dictionary of node values to update
        :param node_id:
        :return:
        """
    @abc.abstractmethod
    def get_endpoints_in_node(self, context, node_id):
        """Returns a list of Endpoint objects for specified node.
        :param context: request context object
        :param node_id: UUID of the node
        :returns: a list of :class:
app = Flask(__name__)
api = Api(app)
api.add_resource(UserListApi, '/api/v1.0/users', endpoint='users')
api.add_resource(UserApi, '/api/v1.0/users/<int:id>', endpoint='user')
api.add_resource(BeerReviewUserApi, '/api/v1.0/users/<int:id>/reviews', endpoint='user_reviews')
api.add_resource(BeerGlassListApi, '/api/v1.0/beer_glasses', endpoint='beer_glasses')
api.add_resource(BeerGlassApi, '/api/v1.0/beer_glasses/<int:id>', endpoint='beer_glass')
api.add_resource(BeerListApi, '/api/v1.0/beers', endpoint='beers')
api.add_resource(BeerApi, '/api/v1.0/beers/<int:id>', endpoint='beer')
api.add_resource(BeerReviewBeerApi, '/api/v1.0/beers/<int:id>/reviews', endpoint='beer_reviews')
api.add_resource(BeerReviewListApi, '/api/v1.0/beer_reviews', endpoint='reviews')
api.add_resource(BeerReviewApi, '/api/v1.0/beer_reviews/<int:id>', endpoint='review')
api.add_resource(FavoritesUserApi, '/api/v1.0/users/<int:id>/favorites', endpoint='user_favorites')
api.add_resource(FavoritesBeerApi, '/api/v1.0/beer
"""
(Description)
Created on Jan 9, 2015
"""
__author__ = 'Weber Jean-Paul'
__email__ = 'jean-paul.weber@govcert.etat.lu'
__copyright__ = 'Copyright 2013-2014, GOVCERT Luxembourg'
__license__ = 'GPL v3+'
class ReportController(BaseController):
  """event controller handling all actions in the event section"""
  def __init__(self, config, session=None):
    BaseController.__init__(self, config, session)
    self.report_broker = self.broker_factory(ReportBroker)
    self.reference_broker = self.broker_factory(ReferenceBroker)
    self.reference_definition_broker = self.broker_factory(ReferenceDefintionsBroker)
  def get_report_by_id(self, identifier):
    try:
      return self.report_broker.get_by_id(identifier)
    except BrokerException as error:
      raise ControllerException(error)
  def get_report_by_uuid(self, uuid):
    try:
      return self.report_broker.get_by_uuid(uuid)
    except BrokerException as error:
      raise ControllerException(error)
  def insert_report(self, repo

    try:
      user = self.user_broker.get_by_id(user.identifier)
      self.set_extended_logging(report, user, user.group, True)
      self.report_broker.insert(report)
    except IntegrityException as error:
      self.logger.debug(error)
      self.logger.info(u'User {0} tried to insert a report with uuid "{1}" but the uuid already exists'.format(user.username, report.uuid))
      raise ControllerException(u'An report with uuid "{0}" already exists'.format(report.uuid))
    except BrokerException as error:
      raise ControllerException(error)
  def update_report(self, report, user, commit=True):
    try:
      user = self.user_broker.get_by_id(user.identifier)
      self.set_extended_logging(report, user, user.group, False)
      self.report_broker.update(report, commit)
    except BrokerException as error:
      raise ControllerException(error)
  def remove_report(self, report, user, commit=True):
    try:
      self.report_broker.remove_by_id(report.identifier)
    except Broke

      raise ControllerException(error)
  def get_reference_definitions_by_id(self, identifier):
    try:
      return self.reference_definition_broker.get_by_id(identifier)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise ControllerException(error)
  def get_reference_definitions_by_uuid(self, uuid):
    try:
      return self.reference_definition_broker.get_by_uuid(uuid)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise ControllerException(error)
  def get_reference_by_id(self, identifier):
    try:
      return self.reference_broker.get_by_id(identifier)
    except NothingFoundException as error:
      raise ControllerNothingFoundException(error)
    except BrokerException as error:
      raise ControllerException(error)
  def get_reference_by_uuid(self, uuid):
    try:
      return self.reference_b
manage = ContentManage()
def IP(r): return r.META["REMOTE_ADDR"]
def tag_list(r, cate='lei', lang='zh'):    
    cate = manage.load_category(cate, lang)
    tag_count, tags_list = manage.tag_list(cate, 1, 100,)
    cate_count, cate_list = manage.cate_list(lang)
    
    return ("dyd_admin_tag.html", {
                                   'cur_cate': cate,
                                   "tags_list": tags_list,
                                   "cate_list": cate_list,                                    
                                   })
    
    
def update_tag(r, cate='', lang='', tag='', shape=''):
    cate = manage.load_category(cate, lang)
    tag = manage.load_tag(cate, tag)
    tag.shape = shape
    tag.put()
    manage.clear_cache()
    
def admin_post(r, cate='lei', lang='zh', message='', tags='', user='', session='', track='', ajax='N'):
    
    cate = manage.load_category(cate, lang)
    tag_count, tags_list = manage.tag_list(cate, 1, 100,)
    cate_count, cate_list = m
broker = "iot.eclipse.org"
broker_port = 1883
broker_keepalive = 60
topic = "OPiMiniMQTT17"
espeak_call = "/usr/bin/espeak"
espeak_args = "-vpt+f1 -p 60"
def speak_message(msg_str):
    cmd = " ".join([espeak_call, espeak_args, "'"+msg_str+"'"])
    print "Executing cmd '%s'" % cmd
    args = shlex.split(cmd)
    try:
        subprocess.Popen(args)
    except:
        print "Error occurred when trying to call '%s'" % cmd
def on_connect(client, userdata, flags, rc):
    print "Connected to the broker '%s' (rc %s)" % (broker, str(rc))
    client.subscribe(topic)
    print "Subscribed to '%s'" % (topic)
def on_message(client, userdata, msg):
    msg_str = str(msg.payload)
    print "Message received from topic '%s': '%s'" % (msg.topic, msg_str)
    if msg_str.startswith("speak "):
        speak_message(msg_str.replace("speak ",""))
def main():
    try:
        print "Initializing..."
        client = mqtt.Client()
        client.on_connect = on_connect
        client.on_message = on_messa
"""
This holds our SimpleConsumer and SimpleProducer -- classes that interact with
Kafka but have no communication with ZooKeeper
Behaviors to support:
* Starting from a particular offset for each partition.
* starting from the beginning (or first available partition)
* starting from the last available partition
* Support multiple brokers
* Be able to be jump started from a ZKConsumer
"""
log = logging.getLogger('brod.simple')
class SimpleConsumer(object):
    """We'll make more convenient constructors later..."""
    def __init__(self, topic, broker_partitions, end_broker_partitions=None):
        """If broker_partitions is a list of BrokerPartitions, we assume that
        we'll start at the latest offset. If broker_partitions is a mapping of
        BrokerPartitions to offsets, we'll start at those offsets."""
        self._topic = topic
        self._broker_partitions = sorted(broker_partitions)
        self._stats = defaultdict(lambda: ConsumerStats(fetches=0, bytes=0, messages=0,

        self._bps_to_next_offsets = broker_partitions
        broker_conn_info = frozenset((bp.broker_id, bp.host, bp.port)
                                     for bp in self._broker_partitions)
        self._connections = dict((broker_id, Kafka(host, port))
                                 for broker_id, host, port in broker_conn_info)
        if isinstance(broker_partitions, Mapping):
            self._bps_to_next_offsets = broker_partitions
        else:
            self._bps_to_next_offsets = dict((bp, self._connections[bp].latest_offset(bp.topic, bp.partition))
                                             for bp in broker_partitions)
        self._end_broker_partitions = end_broker_partitions or {}
    @property
    def id(self): return id(self)
    @property
    def topic(self): return self._topic
    @property
    def consumer_group(self): return None
    @property
    def autocommit(self): return False
    @property
    def broker_partitions(self): return self._broker_partiti

    @property
    def brokers(self):
        return sorted(frozenset(bp.broker_id for bp in self._broker_partitions))
    def close(self):
        pass
    @property
    def stats(self): 
        ''' Returns the aggregate of the stats from all the broker partitions
        '''
        fetches = 0
        bytes = 0
        messages = 0
        max_fetch = 0
        for stats in self._stats.values():
            fetches += stats.fetches
            bytes += stats.bytes
            messages += stats.messages
            max_fetch = max(max_fetch, stats.max_fetch)
        return ConsumerStats(fetches, bytes, messages, max_fetch)
    def stats_by_broker_partition(self):
        return dict(self._stats)
    def commit_offsets(self):
        """This isn't supported for SimpleConsumers, but is present so that you
        don't have to change code when swapping a SimpleConsumer for a 
        ZKConsumer."""
        pass
    def fetch(self, max_size=None, min_size=None, fetch_step=None):
      
class CodeSounds:
    _error_wait_time = 3
    def __init__(self, broker, config_path):
        self._broker = broker
        config_file = open(config_path, 'r')
        config_str = config_file.read()
        config_file.close()
        self._config = json.loads(config_str)
        self._connect_to_broker()
    def _connect_to_broker(self):
        try:
            print('Connecting to broker.')
            self._client = mosquitto.Mosquitto('code_sounds')
            self._client.on_connect = self.on_connect
            self._client.on_disconnect = self.on_disconnect
            self._client.on_subscribe = self.on_subscribe
            self._client.on_message = self.on_message
            self._client.connect(self._broker, 1883, 60)
            self._client.subscribe("hasi/code_scanner", 0)
        except:
            print('Could not connect to broker. Trying again in a few seconds.')
            time.sleep(self._error_wait_time)
            self._connect_to_broker()
    def on_con

        print('Connected to the broker.')
    def on_disconnect(self, mosq, obj, rc):
        print('Disconnected from the broker. Reconnecting now.')
        self._connect_to_broker()
    def on_subscribe(self, mosq, obj, mid, qos_list):
        print('Subscribed to the topic.')
    def on_message(self, mosq, obj, msg):
        code = msg.payload.decode('utf-8')
        if code in self._config:
            self.play_sound(self._config[code])
    def play_sound(self, path):
        subprocess.Popen(['aplay', path])
    def loop(self):
        try:
            for i in range(6000):
                self._client.loop(10)
            self._client.disconnect()
            self._connect_to_broker()
        except:
             print('Fatal error. Trying to reconnect to the scanner.')
             time.sleep(self._error_wait_time)
             self._connect_to_broker()
if __name__ == '__main__':
    code_sounds = CodeSounds('atlas.hasi', 'sounds.conf')
    
    while True:
        code_sound
'''
Represents a GitHub repository
@since 1.0
@author Oskar Jarczyk
'''
class MyRepository():
    element_type = 'Team'
    key = None
    def __init__(self):
        self.data = []
    repository_branches = None
    repository_commits = None
    repository_contributors = None
    repository_created_at = None
    repository_description = None
    repository_fork = None
    repository_forks = None
    repository_forks_count = None
    repository_has_downloads = None
    repository_has_issues = None
    repository_has_wiki = None
    repository_homepage = None
    repository_integrate_branch = None
    repository_issues = None
    repository_labels = None
    repository_language = None
    repository_master_branch = None
    repository_name = None
    repository_open_issues = None
    repository_organization = None
    repository_owner = None
    repository_private = None
    repository_pulls = None
    repository_pushed_at = None
    repository_size = None
    repository_stargazers = No

    repository_subscribers = None
    repository_watchers = None
    repository_url = None
    repo_object = None
    def setRepoObject(self, repoobject):
        self.repo_object = repoobject
    def getRepoObject(self):
        return self.repo_object
    def setKey(self, key):
        self.key = key
    def getKey(self):
        return self.key
    def purge(self):
        'TO DO: implement this method'
    'basicly first init of data transcripted from input (csvs)'
    'name with owner, and count of forks and watchers'
    def setInitials(self, name, owner, watchers, forks):
        self.repository_name = name
        self.repository_owner = owner
        self.repository_watchers_count = watchers
        self.repository_forks_count = forks
    def setName(self, name):
        self.repository_name = name
    def getName(self):
        return self.repository_name
    def setOwner(self, owner):
        self.repository_owner = owner
    def getOwner(self):
        return self.reposito

    def setForks(self, forks):
        self.repository_forks = forks
    def setCommits(self, commits):
        self.repository_commits = commits
    def getCommits(self):
        return self.repository_commits
    def getCommitsCount(self):
        return (len(self.repository_commits) if self.repository_commits is not None else 0)
    def getForks(self):
        return self.repository_forks
    def getForksCount(self):
        return self.repository_forks_count
    def setWatchers(self, watchers):
        self.repository_watchers = watchers
    def getWatchers(self):
        return self.repository_watchers
    def getWatchersCount(self):
        return self.repository_watchers_count
    def setContributors(self, contributors):
        self.repository_contributors = contributors
    def getContributors(self):
        return self.repository_contributors
    def getContributorsCount(self):
        return (len(self.repository_contributors) if self.repository_contributors is not None else
class State:
    SearchStartAPI = 0
    RemoveEmptyLinesAfterAPIStart = 1
    SearchEndAPI = 2
    DoneAPI = 3
docs_folder = "docs/appendix/"
appendix_file = docs_folder + "apis.md"
btstack_folder = "../../../"
code_identation = "    "
api_header = """
<a name ="appendix:API_LABLE"></a>
"""
api_ending = """
"""
list_of_apis = [ 
    [btstack_folder+"port/arduino/BTstack.h", "BTstack", "api_btstack"],
def replacePlaceholder(template, title, lable):
    api_title = title + " API"
    snippet = template.replace("API_TITLE", title).replace("API_LABLE", lable)
    return snippet
def writeAPI(fout, infile_name):
    global code_identation
    state = State.SearchStartAPI
    with open(infile_name, 'rb') as fin:
        for line in fin:
            if state == State.SearchStartAPI:
                parts = re.match('\s*(/\*).*API_START.*(\*/)',line)
                if parts:
                    state = State.RemoveEmptyLinesAfterAPIStart
                    continue
            
            if
    LocationSearchAPI, CartStatusAPI, CartTypeAPI, TicketAPI, LocationAPI, AdminDefaultLocation, TicketStatusAPI, \
    TicketCommentAPI, TicketServiceTypeAPI, FileUploadListAPI, RouteListAPI, CartServiceChargesAPI, CartPartsAPI, \
    FileUploadAPI, ProfileAPI, ReportFileListAPI, HelpRequestAPIView
urlpatterns = patterns('cascade.apps.api.views',
                       url(r'^location/profile/(?P<location_id>[a-zA-Z0-9]+)?$', LocationAPI.as_view(),
                           name='location_api_profile'),
                       url(r'^location/search/$',
                           cache_page(60 * 3)(LocationSearchAPI.as_view()), name='location_api_search'),
                       url(r'^default/location/$', AdminDefaultLocation.as_view(), name='admin_api_location'),
                       url(r'^cart/search/$', cache_page(60 * 3)(CartSearchAPI.as_view()), name='cart_api_search', ),
                       url(r'^cart/profile/(?P<serial_number>[a-zA-Z0-9]+)?$', CartProfileAPI.as_view(),


                       url(r'^cart/type/options/$', CartTypeAPI.as_view(), name='cart_type_api'),
                       url(r'^cart/services/charges/$', CartServiceChargesAPI.as_view(),
                           name='cart_service_charge_api'),
                       url(r'cart/parts/options/$', CartPartsAPI.as_view(), name='cart_parts_api'),
                       url(r'^cart/status/options/$', CartStatusAPI.as_view(), name='cart_status_api'),
                       url(r'^customer/profile/(?P<customer_id>[a-zA-Z0-9]+)?$', CustomerProfileAPI.as_view(),
                           name='customer_api_profile'),
                       url(r'^upload/files/', FileUploadAPI.as_view(), name='upload_file_api'),
                       url(r'^files/search/', FileUploadListAPI.as_view(), name='upload_file_list_api'),
                       url(r'^ticket/list/$', TicketSearchAPI.as_view(), name='tickets_api_download'),
                       url(r'^ticket/(?P<ticket_id>[a-zA-Z0-9]+)?$',
       
roslib.load_manifest( 'nao_core' );
class NaoBroker( object ):
    """
    NaoBroker
    """
    BROKER_IP = '0.0.0.0';
    BROKER_PORT = 0;
    def __init__( self, parentIp, parentPort ):
        self.parentIp = parentIp;
        self.parentPort = parentPort;
        
        try:
            self.broker = ALBroker( 'nao_utils_broker_{id}'.format( id = id( self ) ), self.BROKER_IP, self.BROKER_PORT, self.parentIp, self.parentPort );
        except RuntimeError, e:
            rospy.logerr( 'Unable to create a proxy to the NaoQi broker on {parentIp}:{parentPort}.'.format( parentIp = self.parentIp, parentPort = self.parentPort ) );
            sys.exit( 1 );
'''
    instance = None;
    def __init__( self, parentIp, parentPort ):
        if( NaoBroker.instance == None ):
            self.parentIp = parentIp;
            self.parentPort = parentPort;
            
            try:
                self.broker = ALBroker( 'nao_utils_broker_{id}'.format( id = id( self ) ), self.BROKER_IP, se
c_p = os.path.dirname(os.getcwd())+"/"
save_main_path = c_p+"model/model_0829_dic1/0915_lsa/"
dic_main_path = c_p+"Dictionary/ctm/"
filename  = "D:/张知临/源代码/python_ctm/model/model_0829_dic1/post.train"
title_content_indexs = [1,2]
title_content_dic_path =dic_main_path+"Dic_all.key"
title_content_glo_aff_path  = dic_main_path+"Dic_all_1.glo"
title_content_sample_save_path = save_main_path+"title_content_1.train"
delete =True
tc_splitTag="\t"
str_splitTag ="^"
title_content_svm_model_save_path = save_main_path+"title_content_1.model"
title_content_svm_param='-c 8.0 -g 0.0078125' 
title_content_test_path = title_content_sample_save_path 
title_content_for_lsa_train_save_path =  save_main_path +"for_lsa.train"
k = 500
title_content_lsa_train_save_path =  save_main_path +"lsa_title_content_"+str(k)+".train"
title_content_lsa_save_path = save_main_path + "lsa_title_content_"+str(k)
title_content_lsa_svm_param  = '-c 0.5 -g 0.5'
title_content_lsa_svm_model_save_path  = save_main_path + "LSA_ti

extra_filename = save_main_path+".extra"
print "欢迎使用C社区帖子监控，LSA模型训练系统"
choice = int(raw_input("1为构造SVM训练的样本； 2为训练模型；3为生成初始分类得分；4为构造LSA模型；5为训练LSA生成的模型;6为向原模型中增加原先误判的样本；7为向LSA模型中增加原先误判样本。0为退出模型"))
while choice!=0:
    if choice==1:
        cons_train_sample_for_cla(filename,title_content_indexs,title_content_dic_path,title_content_glo_aff_path,title_content_sample_save_path,delete,str_splitTag)
    if choice==2:
      m=ctm_train_model(title_content_sample_save_path,title_content_svm_param,title_content_svm_model_save_path) 
    if choice==3:
        save_train_for_lsa(title_content_test_path,title_content_svm_model_save_path,title_content_for_lsa_train_save_path)
    if choice==4:
        ctm_lsa(title_content_M,threhold,k,title_content_for_lsa_train_save_path,title_content_lsa_train_save_path,title_content_lsa_save_path)
    if choice ==5:
        ctm_train_model(title_content_lsa_train_save_path,title_content_lsa_svm_param,title_content_lsa_svm_model_save_path)
    if choice ==6:
   
logging.basicConfig()
log = logging.getLogger(__file__)
class StompTest(MultipleProducerConsumer):
    
    def __init__(self, brokerName, brokerHost, port=6163, destination='/queue/test.topic', hostcert=None, hostkey=None, timeout=15, messages=1):
        MultipleProducerConsumer.__init__(self)
        
        self.brokerName = brokerName
        self.brokerHost = brokerHost
        self.port = port
        self.destination = destination
        self.hostcert = hostcert
        self.hostkey = hostkey
        self.timeout = timeout
        self.messages = messages
        
    def setup(self):
        
        if self.hostcert and self.hostkey:
            self.setSSLAuthentication(self.hostcert, self.hostkey)
        self.createBroker(self.brokerName, self.brokerHost, self.port)
        
    def run(self):
        
        timer = Timer(self.timeout)
        
        ''' Starting consumer '''
        self.createConsumer(self.brokerName, self.destination, timer.left)
        if self.d

            time.sleep(1)
        
        ''' Creating producer and sending a message '''
        self.createProducer(self.brokerName, self.destination, timer.left)
        for i in range(self.messages):
            self.sendMessage(self.brokerName, 
                             self.destination, 
                             {'persistent':'true'}, 
                             'testing-%s' % i)
        self.waitForMessagesToBeSent(self.brokerName,
                                     self.destination,
                                     timer.left)
        
        ''' Ensuring that we received a message '''
        self.waitForMessagesToArrive(self.brokerName, self.destination, self.messages, timer.left)
        self.assertMessagesNumber(self.brokerName, self.destination, self.messages)
            
    def stop(self):
        self.destroyAllBrokers()
if __name__ == '__main__':
    log.setLevel(logging.INFO)
    logging.getLogger('MultipleProducerConsumer').setLevel(logging.INFO)

urlpatterns = patterns("djangopypi.views",
    url(r'^$', "root", name="djangopypi-root"),
    url(r'^packages/$','packages.index', name='djangopypi-package-index'),
    url(r'^simple/$','packages.simple_index', name='djangopypi-package-index-simple'),
    url(r'^search/$','packages.search',name='djangopypi-search'),
    url(r'^pypi/$', 'root', name='djangopypi-release-index'),
    url(r'^rss/$', ReleaseFeed(), name='djangopypi-rss'),
    
    url(r'^simple/(?P<package>[\w\d_\.\-]+)/$','packages.simple_details',
        name='djangopypi-package-simple'),
    
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/$','packages.details',
        name='djangopypi-package'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/rss/$', ReleaseFeed(),
        name='djangopypi-package-rss'),    
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/doap.rdf$','packages.doap',
        name='djangopypi-package-doap'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/manage/$','packages.manage',
        name='djangopypi-package-manage'),

    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/manage/versions/$','packages.manage_versions',
        name='djangopypi-package-manage-versions'),
    
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/$',
        'releases.details',name='djangopypi-release'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/doap.rdf$',
        'releases.doap',name='djangopypi-release-doap'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/manage/$',
        'releases.manage',name='djangopypi-release-manage'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/metadata/$',
        'releases.manage_metadata',name='djangopypi-release-manage-metadata'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/files/$',
        'releases.manage_files',name='djangopypi-release-manage-files'),
    url(r'^pypi/(?P<package>[\w\d_\.\-]+)/(?P<version>[\w\d_\.\-]+)/files/upload/$',
        'releases.upload_file',name='djangopypi-relea
"""
A simple stock exchange simulation
"""
equities={'Nokia':1000000,
          'Google': 2000000,
          'Apple': 2400000}
tally={'Laura': {'Nokia':0,
                 'Google':0,
                  'Apple':0},
       'John':{'Nokia':0,
                'Google':0,
                'Apple':0},
       'Mark': {'Nokia':0,
                 'Google':0,
                  'Apple':0}}
def purchase_stock(broker):
    """
    Broker buys 50 shares of each company
    """
    for company in equities.keys():
        equities[company]=equities[company]-50
    temp_dict=tally[broker]
    for company in temp_dict.keys():
        temp_dict[company]=temp_dict[company]+50
def sell_stock(broker):
    """
    Broker sells 25 shares of each company back to the exchange
    """
    temp_dict=tally[broker]
    for company in temp_dict.keys():
        if temp_dict[company]!=0:
            """
            Broker can sell shares back only if he/she bought it
            in the first place
            """
    

            equities[company]=equities[company]+25
def reset_exchange():
    """
    Sets the tally of each broker to 0
    """
    tally={'Laura': {'Nokia':0,
                     'Google':0,
                      'Apple':0},
           'John':{'Nokia':0,
                    'Google':0,
                    'Apple':0},
           'Mark': {'Nokia':0,
                     'Google':0,
                      'Apple':0}}
def trade():
    for broker in tally.keys():
        probability=random.uniform(0,1)
        if probability>0.5:
            purchase_stock(broker)
        else:
            sell_stock(broker)
def pretty_print_tally(dictionary):
    """
    Pretty prints a tally of stocks
    """
    for broker in dictionary.keys():
        print broker + ": "
        print "Equities"
        for company in dictionary[broker].keys():
            print company + ": " + str(dictionary[broker][company])
def pretty_print_exchange(dictionary):
    """
    Pretty prints the number of shares remai
manage_add_osiris_form = PageTemplateFile('browser/add_plugin',
                            globals(), __name__='manage_add_osiris_form' )
def manage_add_osiris_helper( dispatcher, id, title=None, REQUEST=None ):
    """Add an osiris Helper to the PluggableAuthentication Service."""
    sp = plugin.OsirisHelper( id, title )
    dispatcher._setObject( sp.getId(), sp )
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect( '%s/manage_workspace'
                                      '?manage_tabs_message='
                                      'osirisHelper+added.'
                                      % dispatcher.absolute_url() )
def register_osiris_plugin():
    try:
        registerMultiPlugin(plugin.OsirisHelper.meta_type)
    except RuntimeError:
        pass
def register_osiris_plugin_class(context):
    context.registerClass(plugin.OsirisHelper,
                          permission = manage_users,
                          constructors = (manage_add_osiris_form,
       
admin.autodiscover()
computation_list = ListView.as_view(model=Computation, template_name='computation/list.html')
urlpatterns = patterns('',
    url(r'^VisualControllerApp/comp/(?P<pk>[a-z\d]+)/$', 'VisualControllerApp.views.comp_detail', name='comp_detail'),
    url(r'^VisualControllerApp/computation/partial/(?P<pk>[a-z\d]+)/$', 'VisualControllerApp.views.partial_res', name='partial_res'),
    url(r'^VisualControllerApp/computation/configuration/(?P<pk>[a-z\d]+)/$', 'VisualControllerApp.views.view_configuration', name='view_conf'),
    url(r'^VisualControllerApp/computation/download_ind/(?P<pk>[a-z\d]+)/$', 'VisualControllerApp.views.download_ind'),
    url(r'^VisualControllerApp/computation/download_spacing/(?P<pk>[a-z\d]+)/$', 'VisualControllerApp.views.download_spacing'),
    url(r'^VisualControllerApp/order/computation/$', 'VisualControllerApp.views.orderComputation'),
    url(r'^VisualControllerApp/order/configuration/$', 'VisualControllerApp.views.set_configuration'),
    url(r
class TestFakeAccountBroker(unittest.TestCase):
    def test_fake_broker_get_info(self):
        broker = utils.FakeAccountBroker()
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            info = broker.get_info()
        timestamp = Timestamp(now)
        expected = {
            'container_count': 0,
            'object_count': 0,
            'bytes_used': 0,
            'created_at': timestamp.internal,
            'put_timestamp': timestamp.internal,
        }
        self.assertEqual(info, expected)
    def test_fake_broker_list_containers_iter(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.list_containers_iter(), [])
    def test_fake_broker_metadata(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.metadata, {})
    def test_fake_broker_get_policy_stats(self):
        broker = utils.FakeAccountBroker()
        self.assertEqual(broker.get_policy_stats(), {})
class TestAccountUti

    def test_get_response_headers_fake_broker(self):
        broker = utils.FakeAccountBroker()
        now = time.time()
        expected = {
            'X-Account-Container-Count': 0,
            'X-Account-Object-Count': 0,
            'X-Account-Bytes-Used': 0,
            'X-Timestamp': Timestamp(now).normal,
            'X-PUT-Timestamp': Timestamp(now).normal,
        }
        with mock.patch('time.time', new=lambda: now):
            resp_headers = utils.get_response_headers(broker)
        self.assertEqual(resp_headers, expected)
    def test_get_response_headers_empty_memory_broker(self):
        broker = backend.AccountBroker(':memory:', account='a')
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            broker.initialize(Timestamp(now).internal)
        expected = {
            'X-Account-Container-Count': 0,
            'X-Account-Object-Count': 0,
            'X-Account-Bytes-Used': 0,
            'X-Timestamp': Timestamp(now).norm

            'X-PUT-Timestamp': Timestamp(now).normal,
        }
        resp_headers = utils.get_response_headers(broker)
        self.assertEqual(resp_headers, expected)
    @patch_policies
    def test_get_response_headers_with_data(self):
        broker = backend.AccountBroker(':memory:', account='a')
        now = time.time()
        with mock.patch('time.time', new=lambda: now):
            broker.initialize(Timestamp(now).internal)
        ts = (Timestamp(t).internal for t in itertools.count(int(now)))
        total_containers = 0
        total_objects = 0
        total_bytes = 0
        for policy in POLICIES:
            delete_timestamp = next(ts)
            put_timestamp = next(ts)
            object_count = int(policy)
            bytes_used = int(policy) * 10
            broker.put_container('c-%s' % policy.name, put_timestamp,
                                 delete_timestamp, object_count, bytes_used,
                                 int(policy))
            total_conta
POSSIBLE_ARM_CONTROLLERS = ['%s_arm_controller', '%s_cart']
class ControllerSwitcher:
    def __init__(self):
        self.load_controller = rospy.ServiceProxy('pr2_controller_manager/load_controller', 
                                                  LoadController)
        self.unload_controller = rospy.ServiceProxy('pr2_controller_manager/unload_controller', 
                                                    UnloadController)
        self.switch_controller_srv = rospy.ServiceProxy('pr2_controller_manager/switch_controller', 
                                                        SwitchController)
        self.list_controllers_srv = rospy.ServiceProxy('pr2_controller_manager/list_controllers', 
                                                       ListControllers)
        self.load_controller.wait_for_service()
        self.unload_controller.wait_for_service()
        self.switch_controller_srv.wait_for_service()
        self.list_controllers_srv.wait_for_service()
        rospy

    def switch(self, old_controller, new_controller, param_file=None):
        if param_file is None:
            self.load_controller(new_controller)
            resp = self.switch_controller_srv([new_controller], [old_controller], 1)
            self.unload_controller(old_controller)
            return resp.ok
        else:
            params = rosparam.load_file(roslib.substitution_args.resolve_args(param_file))
            rosparam.upload_params("", params[0][0])
            self.switch_controller_srv([], [old_controller], 1)
            self.unload_controller(old_controller)
            if old_controller != new_controller:
                self.unload_controller(new_controller)
            self.load_controller(old_controller)
            if old_controller != new_controller:
                self.load_controller(new_controller)
            resp = self.switch_controller_srv([new_controller], [], 1)
            return resp.ok
    def carefree_switch(self, arm, new_controller, param_fi

        if '%s' in new_controller:
            new_controller = new_controller % arm
        if param_file is not None:
            params = rosparam.load_file(roslib.substitution_args.resolve_args(param_file))
            rosparam.upload_params("", params[0][0])
        if possible_controllers is None:
            possible_controllers = POSSIBLE_ARM_CONTROLLERS
        check_arm_controllers = [controller % arm for controller in possible_controllers]
        resp = self.list_controllers_srv()
        start_controllers, stop_controllers = [new_controller], []
        for i, controller in enumerate(resp.controllers):
            if controller in check_arm_controllers and resp.state[i] == 'running':
                stop_controllers.append(controller)
        self.load_controller(new_controller)
        rospy.loginfo("[pr2_controller_switcher] Starting controller %s" % (start_controllers[0]) +
                      " and stopping controllers: [" + ",".join(stop_controllers) + "]")
       
path_join = os.path.join
def main():
    parser = argparse.ArgumentParser(description=pyquality.__doc__)
    parser.add_argument('repository', help='Path or URL to the Git repository')
    args = parser.parse_args()
    repository = args.repository
    repository_path = repository
    if not os.path.exists(repository):
        repository_path = os.path.basename(repository).replace('.git', '')
        pyquality.git_clone(repository, repository_path)
    else:
        repository_path = os.path.normpath(repository_path)
    repository_name = os.path.basename(repository_path)
    results_path = path_join(os.path.curdir,
                             'results-{}'.format(repository_name))
    if not os.path.exists(results_path):
        os.mkdir(results_path)
    tags_filename = path_join(results_path, repository_name + '-tags.csv')
    ratios_filename = path_join(results_path, repository_name + '-pep8-{}.csv')
    pyquality.analyse_repository(repository_path, tags_filename,
                 
'''
Created on 17 nov. 2016
@author: Henrik
@author: Alejandro P. Hernandez
'''
if __name__ == '__main__':
    
    
    
    config = {
    '/': {
        'tools.encode.debug': True,
        'tools.encode.text_only': False,
        'tools.encode.encoding': 'utf8'
    },
    cherrypy.tree.mount(
        Checkout(), '/api/checkout',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    cherrypy.tree.mount(
        Book(), '/api/book',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        Index(), '/api',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        UserLogin(), '/api/login',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        RegisterPage(), '/api/register

        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        Register(), '/api/registersend',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    
    cherrypy.tree.mount(
        LoginResult(), '/api/loginresult',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    cherrypy.tree.mount(
        Logout(), '/api/logoutpage',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    cherrypy.tree.mount(
        TicketPage(), '/api/ticket',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        BookPage(), '/api/bookPage',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    cherrypy.tree.mount

        ShoppingCart(), '/api/shoppingCart',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        DeleteShoppingCart(), '/api/deleteshoppingCart',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    
    cherrypy.tree.mount(
        AddShoppingCart(), '/api/addshoppingCart',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    cherrypy.tree.mount(
        SearchResult(), '/api/search',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    
    cherrypy.tree.mount(
        AllBooks(), '/api/allBooks',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}
        }
    )
    cherrypy.tree.mount(
        Tickets(), '/api/tickets',
        {'/':
            {'request.dispatch': cherrypy.dispatch.MethodDisp
class Model(metaclass=ABCMeta):
    def __init__(self, instrument, mode='all', pricebuffer_size=1000, tick_source=None, **params):
        self.buffer = PriceBuffer(size=pricebuffer_size)
        self.instrument = tuple(instrument)
        self.mode = mode
        self.params = params
        self.trades = []
        if tick_source:
            self.tick_source = Driver.init_module_config(tick_source)
        else:
            self.tick_source = None
    @abstractmethod
    def train(self):
        pass
    def open_position(self, broker, instrument, volume, order_type='market', expiry=None, **args):
        trade = broker.open(instrument, volume, order_type, expiry, **args)
        if trade:
            self.trades.append(trade)
        return trade
    def close_position(self, broker, trade):
        ret = broker.close(trade)
        if ret is not None:
            for t in self.trades:
                if t.id == trade.id:
                    self.trades.remove(t)
                bre
roslib.load_manifest( 'nao_core' );
try:
except ImportError, e:
    sys.exit( 1 );
    
class NaoNode( object ):
    """
    NaoNode
    """
    broker = None;
    def __init__( self ):
        
        parser = ArgumentParser();
        parser.add_argument( '--pip', dest = 'parentIp', default = '127.0.0.1', 
                             help = 'IP address of the parent broker (default is 127.0.0.1).' );
        parser.add_argument( '--pport', dest = 'parentPort', default = 9559, 
                             help = 'Port of the parent broker (default is 9559).' );
        
        
        self.parentIp = args.parentIp;
        self.parentPort = int( args.parentPort );
        
        self.broker = NaoBroker( self.parentIp, self.parentPort );
    
    def getProxy( self, name ):
        proxy = None;
        
        try:
            proxy = ALProxy( name, self.parentIp, self.parentPort );
        except RuntimeError, e:
            rospy.logerr( 'Unable to create a proxy to "{name}"
dir(ConfigParser)
class paasController():
	def __init__(self):
		self.controller_file = os.path.expanduser('~/.paascontroller')
		self.config = ConfigParser.ConfigParser()
		if os.path.exists(self.controller_file):
			self.config.read(self.controller_file)
		else:
			self.config.add_section('controllers')
		self.request_headers = { 'Content-type': 'application/json' }
		
	def list_controllers(self):
		controllers = {}
		try:
			controllers = self.config.items('controllers')	
		except Exception as e: 
			pass
		print controllers
		print "Current Controllers:"
		print ""
		for controller in controllers:
			print "    Shortname: {}  - Host: {}".format(controller[0], controller[1] )
		print ""
	def get_controller(self, controller):
		try:
			return self.config.get('controllers', controller)
		except:
			print "Controller not found"
			raise Exception
	def add_controller(self, controller, hostname):
		self.config.set('controllers', controller, hostname)
		with open(self.controller_file, "wb

			self.config.write(configfile)
		print "Controller {} added".format(controller)
	def remove_controller(self, controller):
		output = self.config.remove_option('controllers', controller)	
		if output == True:
			print "Removed Controller {}".format(controller)
		else:
			print "Controller {} not found".format(controller)
	def create_application(self, controller, app_name):
		controller_address = self.get_controller(controller)
		payload = { "name": app_name }
		r = requests.post("{}/app/".format(controller_address), headers=self.request_headers, data = json.dumps(payload) )
		if r.status_code == 201:
			print "Application {} created".format(app_name)
			print ""
			print r.text
		else:
			print "Error creating application {}".format(app_name)
	def update_application(self, controller, app_name, **args):
		pass
	def get_application(self, controller, app_name):
		controller_address = self.get_controller(controller)
		r = requests.get("{}/app/{}".format(controller_address, app_name))
		i

			print r.text
		else:
			print "Unable to return application data"
	def delete_application(self, controller, app_name):
		controller_address = self.get_controller(controller)
		r = requests.delete("{}/app/{}".format(controller_address, app_name))
		if r.status_code == 200:
			print "Application {} deleted".format(app_name)
		else:
			print "Unable to delete {}".format(app_name)
	def globals(self, controller):
		controller_address = self.get_controller(controller)
		r = requests.get("{}/global".format(controller_address))
		print r.status_code
		print r.text
	def main():
		
		pass
if __name__ == '__main__':
	paas = paasController()
	paas.add_controller("localhost", "http://127.0.0.1:8000")
	paas.list_controllers()
	paas.remove_controller("localhost")
	paas.remove_controller("localhost")
	paas.add_controller("localhost", "http://127.0.0.1:8000")
	paas.create_application("localhost", "testapp5")
	paas.create_application("localhost", "testapp5")
	paas.get_application("localhost", "testa
"""
Testing signals before/after saving and deleting.
"""
class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)
    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)
def pre_save_nokwargs_test(sender, instance):
    print 'pre_save_nokwargs signal'
def post_save_nokwargs_test(sender, instance):
    print 'post_save_nokwargs signal'
def pre_save_test(sender, instance, **kwargs):
    print 'pre_save signal,', instance
    if kwargs.get('raw'):
        print 'Is raw'
def post_save_test(sender, instance, **kwargs):
    print 'post_save signal,', instance
    if 'created' in kwargs:
        if kwargs['created']:
            print 'Is created'
        else:
            print 'Is updated'
    if kwargs.get('raw'):
        print 'Is raw'
def pre_delete_test(sender, instance, **kwargs):
    print 'pre_delete signal,', instance
    print 'instance.id is not None: %s' % (instance.id != None)
de

    print 'post_delete signal,', instance
    print 'instance.id is None: %s' % (instance.id == None)
__test__ = {'API_TESTS':"""
>>> dispatcher.connect(pre_save_nokwargs_test, signal=models.signals.pre_save)
>>> dispatcher.connect(post_save_nokwargs_test, signal=models.signals.post_save)
>>> dispatcher.connect(pre_save_test, signal=models.signals.pre_save)
>>> dispatcher.connect(post_save_test, signal=models.signals.post_save)
>>> dispatcher.connect(pre_delete_test, signal=models.signals.pre_delete)
>>> dispatcher.connect(post_delete_test, signal=models.signals.post_delete)
>>> p1 = Person(first_name='John', last_name='Smith')
>>> p1.save()
pre_save_nokwargs signal
pre_save signal, John Smith
post_save_nokwargs signal
post_save signal, John Smith
Is created
>>> p1.first_name = 'Tom'
>>> p1.save()
pre_save_nokwargs signal
pre_save signal, Tom Smith
post_save_nokwargs signal
post_save signal, Tom Smith
Is updated
>>> p1.save_base(raw=True)
pre_save_nokwargs signal
pre_save signal, Tom 

Is raw
post_save_nokwargs signal
post_save signal, Tom Smith
Is updated
Is raw
>>> p1.delete()
pre_delete signal, Tom Smith
instance.id is not None: True
post_delete signal, Tom Smith
instance.id is None: False
>>> p2 = Person(first_name='James', last_name='Jones')
>>> p2.id = 99999
>>> p2.save()
pre_save_nokwargs signal
pre_save signal, James Jones
post_save_nokwargs signal
post_save signal, James Jones
Is created
>>> p2.id = 99998
>>> p2.save()
pre_save_nokwargs signal
pre_save signal, James Jones
post_save_nokwargs signal
post_save signal, James Jones
Is created
>>> p2.delete()
pre_delete signal, James Jones
instance.id is not None: True
post_delete signal, James Jones
instance.id is None: False
>>> Person.objects.all()
[<Person: James Jones>]
>>> dispatcher.disconnect(pre_save_nokwargs_test, signal=models.signals.pre_save)
>>> dispatcher.disconnect(post_save_nokwargs_test, signal=models.signals.post_save)
>>> dispatcher.disconnect(post_delete_test, signal=models.signals.post_delet
"""
Setup your Routes options here
"""
def make_map(global_conf={}, app_conf={}):
    map = Mapper()
    mc = map.connect
    admin_routes.add(mc)
    
    mc('/login',    controller='front', action='login')
    mc('/logout',   controller='front', action='logout')
    mc('/adminon',  controller='front', action='adminon')
    mc('/adminoff', controller='front', action='adminoff')
    mc('/submit',   controller='front', action='submit')
    mc('/validuser',   controller='front', action='validuser')
    mc('/over18',   controller='post', action='over18')
    
    mc('/search', controller='front', action='search')
    mc('/sup', controller='front', action='sup')
    mc('/traffic', controller='front', action='site_traffic')
    
    mc('/about/:location', controller='front', 
       action='editreddit', location = 'about')
    
    mc('/reddits/create', controller='front', action='newreddit')
    mc('/reddits/search', controller='front', action='search_reddits')
    mc('/reddits/:where', co

       where = 'popular',
       requirements=dict(where="popular|new|banned"))
    mc('/reddits/mine/:where', controller='myreddits', action='listing',
       where='subscriber',
       requirements=dict(where='subscriber|contributor|moderator'))
    
    mc('/buttons', controller='buttons', action='button_demo_page')
    mc('/button_content', controller='buttons', action='button_content')
    mc('/button', controller='buttons', action='button_embed')
    mc('/buttonlite', controller='buttons', action='button_lite')
    
    mc('/widget', controller='buttons', action='widget_demo_page')
    mc('/bookmarklets', controller='buttons', action='bookmarklets')
    
    mc('/stats', controller='front', action='stats')
    
    mc('/feedback', controller='feedback', action='feedback')
    mc('/ad_inq',   controller='feedback', action='ad_inq')
    
    mc('/admin/i18n', controller='i18n', action='list')
    mc('/admin/i18n/:action', controller='i18n')
    mc('/admin/i18n/:action/:lang', cont

    mc('/admin/:action', controller='admin')
    
    mc('/user/:username/about', controller='user', action='about',
       where='overview')
    mc('/user/:username/:where', controller='user', action='listing',
       where='overview')
    
    mc('/prefs/:location', controller='front',
       action='prefs', location='options')
    
    mc('/info/0:article/*rest', controller = 'front', 
       action='oldinfo', dest='comments', type='ancient')
    mc('/info/:article/:dest/:comment', controller='front',
       action='oldinfo', type='old', dest='comments', comment=None)
    mc('/related/:article/:title', controller='front',
       action = 'related', title=None)
    mc('/details/:article/:title', controller='front',
       action = 'details', title=None)
    mc('/traffic/:article/:title', controller='front',
       action = 'traffic', title=None)
    mc('/shirt/:article/:title', controller='front',
       action = 'shirt', title=None)
    mc('/comments/:article/:title/:comment', cont
class Manage_NewsletterArchive_BaseHandler(Manage_BaseHandler):
    pass
class Manage_NewsletterArchive_Handler(Manage_NewsletterArchive_BaseHandler):
    def get(self):
        self.generate_manage_bar()
        self.template_vars['uploadURL'] = blobstore.create_upload_url('/manage/newsletter_archive/upload')
        self.template_vars['Newsletters'] = Newsletter.gql("ORDER BY DisplayOrder DESC").fetch(50)
        self.render_template("manage/newsletter_archive/newsletter_archive.html")
class Manage_NewsletterArchive_UploadHandler(blobstore_handlers.BlobstoreUploadHandler, Manage_NewsletterArchive_BaseHandler):
    def post(self):
        newNewsletter = Newsletter(
            Title=self.request.get("title"),
            NewsletterBlob=self.get_uploads('file')[0]._BlobInfo__key,
        )
        displayOrderObject = Newsletter.gql("ORDER BY DisplayOrder DESC").get()
        newNewsletter.DisplayOrder = displayOrderObject.DisplayOrder + 1 if displayOrderObject else 1
        newNewsl

        self.redirect('/manage/newsletter_archive')
class Manage_NewsletterArchive_ServeHandler(blobstore_handlers.BlobstoreDownloadHandler, Manage_NewsletterArchive_BaseHandler):
    def get(self, resource):
        resource = str(urllib.unquote(resource))
        blob_info = blobstore.BlobInfo.get(resource)
        self.send_blob(blob_info)
class Manage_NewsletterArchive_DeleteHandler(Manage_NewsletterArchive_BaseHandler):
    def get(self, urlsafe_key):
        urlsafe_key = str(urllib.unquote(urlsafe_key))
        key = ndb.Key(urlsafe=urlsafe_key)
        if key.kind() == "Newsletter":
            newsletter = key.get()
            blobstore.BlobInfo(newsletter.NewsletterBlob).delete()
            key.delete()
        else:
            self.abort(400, "Can only delete kind 'Newsletter'")
        self.redirect('/manage/newsletter_archive')
class Manage_NewsletterArchive_OrderHandler(Manage_NewsletterArchive_BaseHandler):
    def get(self, direction, displayOrderToMove):
        di

        FirstObject = Newsletter.gql("WHERE DisplayOrder = :1", displayOrderToMove).get()
        if direction == 'u':
            SecondObject = Newsletter.gql("WHERE DisplayOrder > :1 ORDER BY DisplayOrder ASC", displayOrderToMove).get()
        else:
            SecondObject = Newsletter.gql("WHERE DisplayOrder < :1 ORDER BY DisplayOrder DESC",
                                          displayOrderToMove).get()
        FirstObject.DisplayOrder, SecondObject.DisplayOrder = SecondObject.DisplayOrder, FirstObject.DisplayOrder
        FirstObject.put()
        SecondObject.put()
        self.redirect('/manage/newsletter_archive')
application = webapp.WSGIApplication([
    ('/manage/newsletter_archive/order/([ud])/(\d+)', Manage_NewsletterArchive_OrderHandler),
    ('/manage/newsletter_archive/delete/([^/]+)', Manage_NewsletterArchive_DeleteHandler),
    ('/manage/newsletter_archive/serve/([^/]+)', Manage_NewsletterArchive_ServeHandler),
    ('/manage/newsletter_archive/upload.*', Manag
class CreatedByBaseAdmin(admin.ModelAdmin):
	""" 
	Base class for handling created by stuff
	"""
	readonly_fields = ('created_by', 'created_date')
	def save_formset(self, request, form, formset, change):
		instances = formset.save(commit=False)
		for instance in instances:
			if not change:
				instance.created_by = request.user
				instance.save()
		formset.save()
	def save_model(self, request, obj, form, change):
		if not change:
			obj.created_by = request.user
		obj.save()
	class Meta:
		abstract = True		
class FullAuditBaseAdmin(admin.ModelAdmin):
	""" 
	Base class for handling created by stuff
	"""
	readonly_fields = ('created_by', 'created_date', 'modified_by', 'modified_date', 'deleted_by', 'deleted_date')
	def save_formset(self, request, form, formset, change):
		instances = formset.save(commit=False)
		for instance in instances:
			if not change:
				instance.created_by = request.user
				instance.save()
		formset.save()
	def save_model(self, request, obj, form, change):
		if
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 6
_modified_time = 1433361617.093292
_template_filename='templates/admin/tool_shed_repository/repository_installation_status.mako'
_template_uri='admin/tool_shed_repository/repository_installation_status.mako'
_template_cache=cache.Cache(__name__, _modified_time)
_source_encoding='ascii'
_exports = ['render_repository_status']
def render_body(context,**pageargs):
    context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        def render_repository_status(repository):
            return render_render_repository_status(context.locals_(__M_locals),repository)
        repository = context.get('repository', UNDEFINED)
        __M_writer = context.writer()
        __M_writer(u'\n\n')
        __M_writer(unicode(render_repository_status( repository )))
        __M_writer(u'\n')
        return ''
    finally:
        context.caller_stack._pop_frame()

def render_render_repository_status(context,repository):
    context.caller_stack._push_frame()
    try:
        trans = context.get('trans', UNDEFINED)
        __M_writer = context.writer()
        __M_writer(u'\n    ')
        if repository.status in [ trans.install_model.ToolShedRepository.installation_status.CLONING,
                                  trans.install_model.ToolShedRepository.installation_status.SETTING_TOOL_VERSIONS,
                                  trans.install_model.ToolShedRepository.installation_status.INSTALLING_TOOL_DEPENDENCIES,
                                  trans.install_model.ToolShedRepository.installation_status.LOADING_PROPRIETARY_DATATYPES ]:
            bgcolor = trans.install_model.ToolShedRepository.states.INSTALLING
        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.NEW,
                                    trans.install_model.ToolShedRepository.installation_status.UNINSTALLED ]:
            bgcolor = 

        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.ERROR ]:
            bgcolor = trans.install_model.ToolShedRepository.states.ERROR
        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.DEACTIVATED ]:
            bgcolor = trans.install_model.ToolShedRepository.states.WARNING
        elif repository.status in [ trans.install_model.ToolShedRepository.installation_status.INSTALLED ]:
            if repository.missing_tool_dependencies or repository.missing_repository_dependencies:
                bgcolor = trans.install_model.ToolShedRepository.states.WARNING
            else:
                bgcolor = trans.install_model.ToolShedRepository.states.OK
        else:
            bgcolor = trans.install_model.ToolShedRepository.states.ERROR
        rval = '<div class="count-box state-color-%s" id="RepositoryStatus-%s">' % ( bgcolor, trans.security.encode_id( repository.id ) )
        rval += '%s</div>' % 
"""Library for obtaining API clients and messages."""
class UnknownAPIError(exceptions.Error):
  """Unable to find API in APIs map."""
  def __init__(self, api_name):
    super(UnknownAPIError, self).__init__(
        'API named [{0}] does not exist in the APIs map'.format(api_name))
class UnknownVersionError(exceptions.Error):
  """Unable to find API version in APIs map."""
  def __init__(self, api_name, api_version):
    super(UnknownVersionError, self).__init__(
        'The [{0}] API does not have version [{1}] in the APIs map'.format(
            api_name, api_version))
_API_NAME_ALIASES = {
    'bigtable': 'bigtableclusteradmin',
    'debug': 'clouddebugger',
    'functions': 'cloudfunctions',
    'projects': 'cloudresourcemanager',
    'sql': 'sqladmin',
def _GetApiNameAndAlias(api_name):
  return (_API_NAME_ALIASES.get(api_name, api_name), api_name)
def _CamelCase(snake_case):
  parts = snake_case.split('_')
  return ''.join(s.capitalize() for s in parts)
def ConstructApiDef(ap

                    api_version,
                    is_default,
                    base_pkg='googlecloudsdk.third_party.apis'):
  """Creates and returns the APIDef specified by the given arguments.
  Args:
    api_name: str, The API name (or the command surface name, if different).
    api_version: str, The version of the API.
    is_default: bool, Whether this API version is the default.
    base_pkg: str, Base package from which generated API files are accessed.
  Returns:
    APIDef, The APIDef created using the given args.
  """
  api_name, _ = _GetApiNameAndAlias(api_name)
  client_cls_name = _CamelCase(api_name) + _CamelCase(api_version)
  common_fmt = '{base}.{api_name}.{api_version}.{api_name}_{api_version}_'
  client_cls_path_fmt = common_fmt + 'client.{api_client_class}'
  client_cls_path = client_cls_path_fmt.format(base=base_pkg,
                                               api_name=api_name,
                                               api_version=api_version,
     

  messages_mod_path_fmt = common_fmt + 'messages'
  messages_mod_path = messages_mod_path_fmt.format(base=base_pkg,
                                                   api_name=api_name,
                                                   api_version=api_version)
  return apis_map.APIDef(client_cls_path, messages_mod_path, is_default)
def AddToApisMap(api_name, api_version, is_default,
                 base_pkg='googlecloudsdk.third_party.apis'):
  """Adds the APIDef specified by the given arguments to the APIs map.
  This method should only be used for runtime patcing of the APIs map. Additions
  to the map should ensure that there is only one and only one default version
  for each API.
  Args:
    api_name: str, The API name (or the command surface name, if different).
    api_version: str, The version of the API.
    is_default: bool, Whether this API version is the default.
    base_pkg: str, Base package from which generated API files are accessed.
  """
  api_name, _ = _GetApiNam
def create_brokers(mode, pairs, exchangeNames):
    brokers = []
    for name in exchangeNames:
        if (name == 'VIRCUREX'):
            xchg = Vircurex(config.VIRCUREX_USER, config.VIRCUREX_SECURITY_WORD)
        elif (name == 'BTCE'):
            xchg = BTCE(config.BTCE_KEYFILE)
        elif (name == 'BTER'):
            xchg = BTER(config.BTER_KEYFILE)
        elif (name == 'COINS-E'):
            xchg = CoinsE(config.COINS_E_API_KEY, config.COINS_E_SECRET)
        elif (name == 'CRYPTSY'):
            xchg = Cryptsy(config.CRYPTSY_API_KEY, config.CRYPTSY_SECRET)
        elif (name == 'CRYPTO-TRADE'):
            xchg = CryptoTrade(config.CRYPTOTRADE_API_KEY, config.CRYPTOTRADE_SECRET)
        elif (name == 'COINEX'):
            xchg = CoinEx(config.COINEX_API_KEY, config.COINEX_SECRET)
        else:
            print('Exchange ' + name + ' not supported!')
            continue
        print('%s initialized' % (xchg.name))
        broker = Broker(mode, xchg)
        if mode == 
XPIDL_MODULE = 'necko_rtsp'
MODULE = 'necko'
EXPORTS.mozilla.net += [
    'controller/RtspController.h',
    'controller/RtspControllerChild.h',
    'controller/RtspControllerParent.h',
    'controller/RtspMetaData.h',
    'rtsp/RTSPSource.h',
    'RtspChannel.h',
    'RtspHandler.h',
SOURCES += [
    'controller/RtspController.cpp',
    'controller/RtspControllerChild.cpp',
    'controller/RtspControllerParent.cpp',
    'controller/RtspMetaData.cpp',
    'rtsp/AAMRAssembler.cpp',
    'rtsp/AAVCAssembler.cpp',
    'rtsp/AH263Assembler.cpp',
    'rtsp/AMPEG4AudioAssembler.cpp',
    'rtsp/AMPEG4ElementaryAssembler.cpp',
    'rtsp/APacketSource.cpp',
    'rtsp/ARawAudioAssembler.cpp',
    'rtsp/ARTPAssembler.cpp',
    'rtsp/ARTPConnection.cpp',
    'rtsp/ARTPSource.cpp',
    'rtsp/ARTPWriter.cpp',
    'rtsp/ARTSPConnection.cpp',
    'rtsp/ASessionDescription.cpp',
    'rtsp/RTSPSource.cpp',
    'RtspChannel.cpp',
    'RtspHandler.cpp',
FAIL_ON_WARNINGS = True
LIBXUL_LIBRARY = True
MSVC_EN
Time=10
NumOfS=1
try:
    with open('url.txt',encoding='utf-8') as f:
        url=f.read().rstrip(r'/')
except FileNotFoundError:
    print('逗比，url那个文件夹是不是被干掉了，没办法，再帮你创建一个吧')
    with open('url.txt','w') as f:
        f.write('add url')
    print('press Enter')
    input()
    os._exit(0)
else: pass
if (os.path.exists('jpg'))==False:
    os.makedirs('jpg')
os.chdir('jpg')
if os.path.exists('save.pickle'):
    with open('save.pickle','rb') as f:
        save=pickle.load(f)
else: save={'g':0}
if save['g']!=0 and save['dir']==url:
    url=save['url']
    WantPg=save['left']
else:
    
    try:
        WantPg=max(int(input('how many pages do you want to download\n')),0)
        
    except:
        print("输入纯数字")
        input()
    else:
        pass
    
if save['g']==0: save['dir']=url
save['g']=1
save['left']=WantPg
BaseLink=r'http://tieba.baidu.com'
if url.find(r'?')>-1:
    GetPg=int(url.split('=')[-1])
else: GetPg=1
print(GetPg)
Tot=anals(url)
print(Tot)
for Pg in range(GetPg,min(To

